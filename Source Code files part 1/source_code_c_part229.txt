             return this.Copy();
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            IsolatedStorageFilePermission operand = (IsolatedStorageFilePermission)target;
    
            if (this.IsUnrestricted() || operand.IsUnrestricted()) 
            {
		return new IsolatedStorageFilePermission( PermissionState.Unrestricted );
            }
            else
            {
		IsolatedStorageFilePermission union;
		union = new IsolatedStorageFilePermission( PermissionState.None );
                union.m_userQuota = max(m_userQuota,operand.m_userQuota);	
                union.m_machineQuota = max(m_machineQuota,operand.m_machineQuota);	
                union.m_expirationDays = max(m_expirationDays,operand.m_expirationDays);	
                union.m_permanentData = m_permanentData || operand.m_permanentData;	
                union.m_allowed = (IsolatedStorageContainment)max((long)m_allowed,(long)operand.m_allowed);	
                return union;
            }
        }   

        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return ((m_userQuota == 0) &&
                        (m_machineQuota == 0) &&
                        (m_expirationDays == 0) &&
                        (m_permanentData == false) &&
                        (m_allowed == IsolatedStorageContainment.None));
            }

            try
            {
                IsolatedStorageFilePermission operand = (IsolatedStorageFilePermission)target;

                if (operand.IsUnrestricted())
                    return true;

                return ((operand.m_userQuota >= m_userQuota) &&
                        (operand.m_machineQuota >= m_machineQuota) &&
                        (operand.m_expirationDays >= m_expirationDays) &&
                        (operand.m_permanentData || !m_permanentData) &&
                        (operand.m_allowed >= m_allowed));
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }                

        }
        
        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
                return null;
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }

            IsolatedStorageFilePermission operand = (IsolatedStorageFilePermission)target;

            if(operand.IsUnrestricted()) 
                return Copy();
            else if(IsUnrestricted())
                return target.Copy();
            
            IsolatedStorageFilePermission intersection;
            intersection = new IsolatedStorageFilePermission( PermissionState.None );
            intersection.m_userQuota = min(m_userQuota,operand.m_userQuota);	
            intersection.m_machineQuota = min(m_machineQuota,operand.m_machineQuota);	
            intersection.m_expirationDays = min(m_expirationDays,operand.m_expirationDays);	
            intersection.m_permanentData = m_permanentData && operand.m_permanentData;	
            intersection.m_allowed = (IsolatedStorageContainment)min((long)m_allowed,(long)operand.m_allowed);	

	    if ((intersection.m_userQuota == 0) &&
		(intersection.m_machineQuota == 0) &&
		(intersection.m_expirationDays == 0) &&
		(intersection.m_permanentData == false) &&
		(intersection.m_allowed == IsolatedStorageContainment.None))
			return null;

            return intersection;
        }
      
        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.Copy"]/*' />
        public override IPermission Copy()
        {
	    IsolatedStorageFilePermission copy ;
	    copy = new IsolatedStorageFilePermission(PermissionState.Unrestricted);
            if(!IsUnrestricted()){
                copy.m_userQuota = m_userQuota;	
                copy.m_machineQuota = m_machineQuota;	
                copy.m_expirationDays = m_expirationDays;	
                copy.m_permanentData = m_permanentData;	
                copy.m_allowed = m_allowed;	
 	        }
            return copy;
        }


        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return IsolatedStorageFilePermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.IsolatedStorageFilePermissionIndex;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\tripledes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// TripleDES.cs
//

namespace System.Security.Cryptography {
    using SecurityElement = System.Security.SecurityElement;
    /// <include file='doc\TripleDES.uex' path='docs/doc[@for="TripleDES"]/*' />
    public abstract class TripleDES : SymmetricAlgorithm
    {
        private static  KeySizes[] s_legalBlockSizes = {
            new KeySizes(64, 64, 0)
        };

        private static  KeySizes[] s_legalKeySizes = {
            new KeySizes(2*64, 3*64, 64)
        };
      
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\TripleDES.uex' path='docs/doc[@for="TripleDES.TripleDES"]/*' />
        public TripleDES() {
            KeySizeValue = 3*64;
            BlockSizeValue = 64;
            FeedbackSizeValue = BlockSizeValue;
            LegalBlockSizesValue = s_legalBlockSizes;
            LegalKeySizesValue = s_legalKeySizes;
        }
    
        /*********************** PROPERTY METHODS ************************/

        /// <include file='doc\TripleDES.uex' path='docs/doc[@for="TripleDES.Key"]/*' />
        public override byte[] Key {
            get { 
                if (KeyValue == null) {
                    // Never hand back a weak key
                    do {
                        GenerateKey();
                    } while (IsWeakKey(KeyValue));
                }
                return (byte[]) KeyValue.Clone(); 
            }
            set {
                if (value == null) throw new ArgumentNullException("value");
                if (!ValidKeySize(value.Length * 8)) { // must convert bytes to bits
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
                }
                if (IsWeakKey(value)) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_Weak"),"TripleDES");
                }
                KeyValue = (byte[]) value.Clone();
                KeySizeValue = value.Length * 8;
            }
        }
        
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\TripleDES.uex' path='docs/doc[@for="TripleDES.Create"]/*' />
        new static public TripleDES Create() {
            return Create("System.Security.Cryptography.TripleDES");
        }

        /// <include file='doc\TripleDES.uex' path='docs/doc[@for="TripleDES.Create1"]/*' />
        new static public TripleDES Create(String str) {
            return (TripleDES) CryptoConfig.CreateFromName(str);
        }

        /// <include file='doc\TripleDES.uex' path='docs/doc[@for="TripleDES.IsWeakKey"]/*' />    
        public static bool IsWeakKey(byte[] rgbKey) {
            // All we have to check for here is (a) we're in 3-key mode (192 bits), and
            // (b) either K1 == K2 or K2 == K3
            if (!IsLegalKeySize(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
            }
            byte[] rgbOddParityKey = FixupKeyParity(rgbKey);
            if (EqualBytes(rgbOddParityKey,0,8,8)) return(true);
            if ((rgbOddParityKey.Length == 24) && EqualBytes(rgbOddParityKey,8,16,8)) return(true);
            return(false);
        }
    
        /************************* PRIVATE METHODS ************************/

        private static bool EqualBytes(byte[] rgbKey, int start1, int start2, int count) {
            if (start1 < 0) throw new ArgumentOutOfRangeException("start1", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (start2 < 0) throw new ArgumentOutOfRangeException("start2", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if ((start1+count) > rgbKey.Length) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((start2+count) > rgbKey.Length) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            for (int i = 0; i < count; i++) {
                if (rgbKey[start1+i] != rgbKey[start2+i]) return(false);
            }
            return(true);
        }

        private static byte[] FixupKeyParity (byte[] rgbKey) {
            byte[] rgbOddParityKey = new byte[rgbKey.Length];
            for (int index=0; index < rgbKey.Length; index++) {
                // Get the bits we are interested in
                rgbOddParityKey[index] = (byte) (rgbKey[index] & 0xfe);
                // Get the parity of the sum of the previous bits
                byte tmp1 = (byte)((rgbOddParityKey[index] & 0xF) ^ (rgbOddParityKey[index] >> 4));
                byte tmp2 = (byte)((tmp1 & 0x3) ^ (tmp1 >> 2));
                byte sumBitsMod2 = (byte)((tmp2 & 0x1) ^ (tmp2 >> 1));
                // We need to set the last bit in rgbOddParityKey[index] to the negation
                // of the last bit in sumBitsMod2
                if (sumBitsMod2 == 0)
                    rgbOddParityKey[index] |= 1;
            }
            return rgbOddParityKey;
        }

        private static bool IsLegalKeySize(byte[] rgbKey) {
            if ((rgbKey.Length == 16) || (rgbKey.Length == 24)) return(true);
            return(false);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\isolatedstoragepermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// IsolatedStoragePermission.cool
// 
// Author : Loren Kohnfelder
// 

namespace System.Security.Permissions {
    
    using System;
    using System.IO;
    using System.Security;
    using System.Security.Util;

    /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment"]/*' />
	[Serializable]
    public enum IsolatedStorageContainment {
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment.None"]/*' />
        None                                    = 0x00,
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment.DomainIsolationByUser"]/*' />
        DomainIsolationByUser                   = 0x10,
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment.AssemblyIsolationByUser"]/*' />
        AssemblyIsolationByUser                 = 0x20,
        //DomainIsolationByMachine                = 0x30,
        //AssemblyIsolationByMachine              = 0x40,

        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment.DomainIsolationByRoamingUser"]/*' />
        DomainIsolationByRoamingUser            = 0x50,

        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment.AssemblyIsolationByRoamingUser"]/*' />
        AssemblyIsolationByRoamingUser          = 0x60,
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment.AdministerIsolatedStorageByUser"]/*' />
        AdministerIsolatedStorageByUser         = 0x70,
        //AdministerIsolatedStorageByMachine      = 0x80,
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStorageContainment.UnrestrictedIsolatedStorage"]/*' />
        UnrestrictedIsolatedStorage             = 0xF0
    };

    
    /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission"]/*' />
    [Serializable, SecurityPermissionAttribute( SecurityAction.InheritanceDemand, ControlEvidence = true, ControlPolicy = true )]
    abstract public class IsolatedStoragePermission
           : CodeAccessPermission, IUnrestrictedPermission
    {

        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.m_userQuota"]/*' />
        /// <internalonly/>
        internal long m_userQuota;
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.m_machineQuota"]/*' />
        /// <internalonly/>
        internal long m_machineQuota;
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.m_expirationDays"]/*' />
        /// <internalonly/>
        internal long m_expirationDays;
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.m_permanentData"]/*' />
        /// <internalonly/>
        internal bool m_permanentData;
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.m_allowed"]/*' />
        /// <internalonly/>
        internal IsolatedStorageContainment m_allowed;
    
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.IsolatedStoragePermission"]/*' />
        public IsolatedStoragePermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                m_userQuota = Int64.MaxValue;
                m_machineQuota = Int64.MaxValue;
                m_expirationDays = Int64.MaxValue ;
                m_permanentData = true;
                m_allowed = IsolatedStorageContainment.UnrestrictedIsolatedStorage;
            }
            else if (state == PermissionState.None)
            {
                m_userQuota = 0;
                m_machineQuota = 0;
                m_expirationDays = 0;
                m_permanentData = false;
                m_allowed = IsolatedStorageContainment.None;
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
    
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.IsolatedStoragePermission1"]/*' />
        internal IsolatedStoragePermission(IsolatedStorageContainment UsageAllowed, 
            long ExpirationDays, bool PermanentData)

        {
                m_userQuota = 0;    // typical demand won't include quota
                m_machineQuota = 0; // typical demand won't include quota
                m_expirationDays = ExpirationDays;
                m_permanentData = PermanentData;
                m_allowed = UsageAllowed;
        }
    
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.IsolatedStoragePermission2"]/*' />
        internal IsolatedStoragePermission(IsolatedStorageContainment UsageAllowed, 
            long ExpirationDays, bool PermanentData, long UserQuota)

        {
                m_machineQuota = 0;
                m_userQuota = UserQuota;
                m_expirationDays = ExpirationDays;
                m_permanentData = PermanentData;
                m_allowed = UsageAllowed;
        }
    
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
        
        // properties
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.UserQuota"]/*' />
        public long UserQuota {
            set{
                m_userQuota = value;
            }
            get{
                return m_userQuota;
            }
        }

#if FALSE
        internal long MachineQuota {
            set{
                m_machineQuota = value;
            }
            get{
                return m_machineQuota;
            }
        }
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.ExpirationDays"]/*' />
        internal long ExpirationDays {
            set{
                m_expirationDays = value;
            }
            get{
                return m_expirationDays;
            }
        }
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.PermanentData"]/*' />
        internal bool PermanentData {
            set{
                m_permanentData = value;
            }
            get{
                return m_permanentData;
            }
        }
#endif

        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.UsageAllowed"]/*' />
        public IsolatedStorageContainment UsageAllowed {
            set{
                m_allowed = value;
            }
            get{
                return m_allowed;
            }
        }

    
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            return m_allowed == IsolatedStorageContainment.UnrestrictedIsolatedStorage;
        }
        
    
        //------------------------------------------------------
        //
        // INTERNAL METHODS
        //
        //------------------------------------------------------
        internal static long min(long x,long y) {return x>y?y:x;}
        internal static long max(long x,long y) {return x<y?y:x;}
        //------------------------------------------------------
        //
        // PUBLIC ENCODING METHODS
        //
        //------------------------------------------------------
        
        private const String _strUserQuota   = "UserQuota";
        private const String _strMachineQuota   = "MachineQuota";
        private const String _strExpiry  = "Expiry";
        private const String _strPermDat = "Permanent";

        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (!IsUnrestricted())
            {
                esd.AddAttribute( "Allowed", Enum.GetName( typeof( IsolatedStorageContainment ), m_allowed ) );
                if (m_userQuota>0)
                {
                    esd.AddAttribute(_strUserQuota, (m_userQuota).ToString()) ;
                }
                if (m_machineQuota>0)
                {
                    esd.AddAttribute(_strMachineQuota, (m_machineQuota).ToString()) ;
                }
                if (m_expirationDays>0)
                {
                    esd.AddAttribute( _strExpiry, (m_expirationDays).ToString()) ;
                }
                if (m_permanentData)
                {
                    esd.AddAttribute(_strPermDat, (m_permanentData).ToString()) ;
                }
            }
            else
            {
                esd.AddAttribute( "Unrestricted", "true" );
            }
            return esd;
        }
    

        /// <include file='doc\IsolatedStoragePermission.uex' path='docs/doc[@for="IsolatedStoragePermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );

            m_allowed = IsolatedStorageContainment.None;    // default if no match

            if (XMLUtil.IsUnrestricted(esd))
            {
                m_allowed = IsolatedStorageContainment.UnrestrictedIsolatedStorage;
            }
            else
            {
                String allowed = esd.Attribute( "Allowed" );

                if (allowed != null)
                    m_allowed = (IsolatedStorageContainment)Enum.Parse( typeof( IsolatedStorageContainment ), allowed );
            }
                    
            if (m_allowed == IsolatedStorageContainment.UnrestrictedIsolatedStorage)
            {
                m_userQuota = Int64.MaxValue;
                m_machineQuota = Int64.MaxValue;
                m_expirationDays = Int64.MaxValue ;
                m_permanentData = true;
            }
            else 
            {
                String param;
                param = esd.Attribute (_strUserQuota) ;
                m_userQuota = param != null ? Int64.Parse(param) : 0 ;
                param = esd.Attribute (_strMachineQuota) ;
                m_machineQuota = param != null ? Int64.Parse(param) : 0 ;
                param = esd.Attribute (_strExpiry) ;
                m_expirationDays = param != null ? Int64.Parse(param) : 0 ;
                param = esd.Attribute (_strPermDat) ;
                m_permanentData = param != null ? (Boolean.Parse(param)) : false ;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\x509certificates\x509certificate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// X509Certificate
//

namespace System.Security.Cryptography.X509Certificates {
    
    using System;
    using System.Text;
    using System.Runtime.Remoting;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using Microsoft.Win32;
	using System.Runtime.CompilerServices;
    
    /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate"]/*' />
    [Serializable()]
    public class X509Certificate 
    {
        private const String format = "X509";

        private String name;
        private String caName;
        private byte[] serialNumber;
        private String keyAlgorithm;
        private byte[] keyAlgorithmParameters;
        private byte[] publicKey;
        private byte[] rawCertData;
        private byte[] certHash;
        
        private long effectiveDate = 0;
        private long expirationDate = 0;
    
        // ************************ CONSTRUCTORS ************************
    
        //
        internal X509Certificate()
        {
        }
    
        //   X509Certificate(ubyte[] data)
        //
        //   Initializes itself from a byte array of data.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.X509Certificate1"]/*' />
        public X509Certificate(byte[] data)
        {
            if( (null != data) && (data.Length != 0) )
            {
                    SetX509Certificate(data);
            }
        }
    
    
        // 
        // Package protected constructor for creating a certificate
        // from a CAPI cert context
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.X509Certificate2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public X509Certificate(IntPtr handle)
        {
            if(handle != Win32Native.NULL)
                BuildFromContext(handle);
            
        }
    
        //   X509Certificate(X509Certificate Cert)
        //
        //   Copy constructor.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.X509Certificate3"]/*' />
        public X509Certificate(X509Certificate cert)
        {
            // Create an empty certificate when a null is passed in.
            if(cert == null) return;
    
            name = cert.GetName();
    
            caName = cert.GetIssuerName();
    
            serialNumber = new byte[cert.GetSerialNumber().Length];
            Buffer.InternalBlockCopy(cert.GetSerialNumber(), 0,
                             serialNumber, 0,
                             cert.GetSerialNumber().Length);
    
            keyAlgorithm = cert.GetKeyAlgorithm();
    
            keyAlgorithmParameters = 
                                 new byte[cert.GetKeyAlgorithmParameters().Length];
            Buffer.InternalBlockCopy(cert.GetKeyAlgorithmParameters(), 0,
                             keyAlgorithmParameters, 0,
                             cert.GetKeyAlgorithmParameters().Length);
    
            publicKey = new byte[cert.GetPublicKey().Length];
            Buffer.InternalBlockCopy(cert.GetPublicKey(), 0,
                             publicKey, 0,
                             cert.GetPublicKey().Length);
    
            rawCertData = new byte[cert.GetRawCertData().Length];
            Buffer.InternalBlockCopy(cert.GetRawCertData(), 0,
                             rawCertData, 0,
                             cert.GetRawCertData().Length);
    
            certHash = new byte[cert.GetCertHash().Length];
            Buffer.InternalBlockCopy(cert.GetCertHash(), 0,
                             certHash, 0,
                             cert.GetCertHash().Length);
        }
    
        /******************* Factories ******************************/
        
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.CreateFromCertFile"]/*' />
        public static X509Certificate CreateFromCertFile( String filename )
        {
            FileStream f = new FileStream(filename, FileMode.Open, FileAccess.Read);
            int size = (int) f.Length;
            byte[] data = new byte[size];
            size = f.Read(data, 0, size);
            f.Close();

            if (size == 0) {
                throw new ArgumentException( String.Format( Environment.GetResourceString( "IO.FileNotFound_FileName" ), filename ) );
            }

            return new X509Certificate( data );
        }
        
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.CreateFromSignedFile"]/*' />
        public static X509Certificate CreateFromSignedFile( String filename )
        {
            String fullpath = Path.GetFullPathInternal(filename);
            new FileIOPermission( FileIOPermissionAccess.Read, fullpath ).Demand();
            return new X509Certificate( _GetPublisher( filename ) );
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern byte[] _GetPublisher( String filename );
    
        /******************** IPrincipal Methods ********************/
    
        //  String GetName()
        //
        //  Returns the name of this principal.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetName"]/*' />
        public virtual String GetName()
        {
            return name;
        }
    
    
        //  String ToString()
        //
        //  Returns a String representation of the Principal.
        //
        //  This falls through to the non-verbose version of the 
        //  ToString() method from the ICertificate interface.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.ToString"]/*' />
        public override String ToString()
        {
            return ToString(false);
        }
    
    
        /******************** ICertificate Methods ********************/
    
        //  String GetFormat()
        // 
        //  Returns the name of the format of the certifciate, e.g. "X.509"
        //  "PGP", etc.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetFormat"]/*' />
        public virtual String GetFormat()
        {
            return format;
        }
    
    
        //
        //  String GetIssuerName()
        // 
        //  Returns the name of the CA that issued the certificate.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetIssuerName"]/*' />
        public virtual String GetIssuerName()
        {
            return caName;
        }
    
    
        //
        //  byte[] GetSerialNumber()
        //
        //  Returns a byte array corresponding to the serial number.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetSerialNumber"]/*' />
        public virtual byte[] GetSerialNumber()
        {
            if(serialNumber == null)
                return null;
            else {
                byte[] dup = new byte[serialNumber.Length];
                Buffer.InternalBlockCopy(serialNumber, 0, dup, 0, serialNumber.Length);
                return dup;
            }
        }
    
    
        //
        //  String GetSerialNumberString()
        //
        //  Returns a String representation of the serial number.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetSerialNumberString"]/*' />
        public virtual String GetSerialNumberString()
        {
            return CreateHexString(serialNumber);
        }
    
    
        //
        //  String GetKeyAlgorithm()
        //
        //  Returns A String identifying the algorithm with which the key
        //  is intended to be used.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetKeyAlgorithm"]/*' />
        public virtual String GetKeyAlgorithm()
        {
            return keyAlgorithm;
        }
    
    
        //
        //  byte[] GetKeyAlgorithmParameters
        //
        //  Returns raw byte data for the key algorithm information.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetKeyAlgorithmParameters"]/*' />
        public virtual byte[] GetKeyAlgorithmParameters()
        {
            return keyAlgorithmParameters;
        }
    
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetKeyAlgorithmParametersString"]/*' />
        public virtual String GetKeyAlgorithmParametersString()
        {
            return CreateHexString(keyAlgorithmParameters);
        }
    
        //  ubyte[] GetPublicKey()
        //
        //  Returns a raw byte data representation of the public key.
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetPublicKey"]/*' />
        public virtual byte[] GetPublicKey()
        {
            return publicKey;
        }
    
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetPublicKeyString"]/*' />
        public virtual String GetPublicKeyString()
        {
            return CreateHexString(publicKey);
        }
    
        //  ubyte[] GetRawCertData()
        //
        //  Returns the raw data for the entire certificate.
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetRawCertData"]/*' />
        public virtual byte[] GetRawCertData()
        {
            return rawCertData;
        }
        
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetRawCertDataString"]/*' />
        public virtual String GetRawCertDataString()
        {
            return CreateHexString(rawCertData);
        }
    
        //  ubyte[] GetCertHash()
        // 
        //  Returns the hash for the certificate.
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetCertHash"]/*' />
        public virtual byte[] GetCertHash()
        {
            return certHash;
        }
    
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetCertHashString"]/*' />
        public virtual String GetCertHashString()
        {
            return CreateHexString(certHash);
        }
    
        //
        //
        //
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetEffectiveDateString"]/*' />
        public virtual String GetEffectiveDateString()
        {
            if(effectiveDate == 0)
                return null;
            else
                return (new DateTime(effectiveDate)).ToString();
        }
    
    
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetExpirationDateString"]/*' />
        public virtual String GetExpirationDateString()
        {
            if(expirationDate == 0)
                return null;
            else
                return (new DateTime(expirationDate)).ToString();
        }
    
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.Equals"]/*' />
        public virtual bool Equals(X509Certificate other)
        {
            if(other == null) 
                return false;
    
            if(caName == null) {
                if(other.caName != null)
                    return false;
            }
            else if(other.caName == null)
                return false;
            else {
                if(!caName.Equals(other.caName))
                    return false;
            }
    
            if(serialNumber == null) {
                if(other.serialNumber != null)
                    return false;
            }
            else if(other.serialNumber == null)
                return false;
            else {
                if(serialNumber.Length != other.serialNumber.Length)
                    return false;
                for(int i = 0; i < serialNumber.Length; i++)
                    if(serialNumber[i] != other.serialNumber[i])
                        return false;
            }
            return true;
        }
                
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            byte[] hash = this.GetCertHash();
            // by definition, a null cert hash returns a hash code of 0
            if (hash == null) return(0);

            int value = 0;

            for (int i = 0; i < hash.Length && i < 4; ++i)
            {
                value = value << 8 | hash[i];
            }

            return value;
        }

               
        
        //  String ToString()
        //
        //  Returns a string form for the contents of the certificate.
        //  A flag is given as argument to specify the desired level of
        //  verbosity in the output.
        //
        /// <include file='doc\X509Certificate.uex' path='docs/doc[@for="X509Certificate.ToString1"]/*' />
        public virtual String ToString(bool fVerbose)
        {
            if(!fVerbose)
            {
                return "System.Security.Cryptography.X509Certificates.X509Certificate";
            }
            else
            {
                StringBuilder sb = new StringBuilder();
                String str = null;
                sb.Append("CERTIFICATE:" + System.Environment.NewLine);
    
                sb.Append("\tFormat:  ");
                sb.Append(GetFormat());
                sb.Append(System.Environment.NewLine);
    
                str = GetName();
                if( null != str )
                {
                    sb.Append("\tName:  ");
                    sb.Append(str);
                    sb.Append(System.Environment.NewLine);
                }
    
                str = GetIssuerName();
                if( null != str )
                {
                    sb.Append("\tIssuing CA:  ");
                    sb.Append(str);
                    sb.Append(System.Environment.NewLine);
                }
    
                str = GetKeyAlgorithm();
                if( null != str )
                {
                    sb.Append("\tKey Algorithm:  ");
                    sb.Append(str);
                    sb.Append(System.Environment.NewLine);
                }
                
                str = GetSerialNumberString();
                if( null != str )
                {
                    sb.Append("\tSerial Number:  ");
                    sb.Append(str);
                    sb.Append(System.Environment.NewLine);
                }
    
                str = GetKeyAlgorithmParametersString();
                if( null != str )
                {
                    sb.Append("\tKey Alogrithm Parameters:  ");
                    sb.Append(str);
                    sb.Append(System.Environment.NewLine);
                }
    
    
                str = GetPublicKeyString();
                if( null != str )
                {
                    sb.Append("\tPublic Key:  ");
                    sb.Append(str);
                    sb.Append(System.Environment.NewLine);
                }
    
    
                sb.Append(System.Environment.NewLine);
    
                return sb.ToString();
            }
        }
    
        static private char[]  hexValues = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        private String CreateHexString(byte[] sArray) 
        {
            String result = null;
    #if _DEBUG
            if(debug) {
                if(sArray != null) 
                    Console.WriteLine("Array length = " + (sArray.Length).ToString());
                else
                    Console.WriteLine("Array = null??");
            }
    #endif
            if(sArray != null) {
                char[] hexOrder = new char[sArray.Length * 2];
            
                int digit;
                for(int i = 0, j = 0; i < sArray.Length; i++) {
                    digit = (sArray[i] & 0xf0) >> 4;
                    hexOrder[j++] = hexValues[digit];
                    digit = sArray[i] & 0x0f;
                    hexOrder[j++] = hexValues[digit];
                }
                result = new String(hexOrder);
            }
            return result;
        }
    
        /******************** PRIVATE METHODS ********************/
    
        //
        //  SetX509Certificate(ubyte[] data)
        //
        //  Private helper method for calling down to native to construct
        //  an X509 certificate from an array of byte data.
        //  
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int SetX509Certificate(byte[] data);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int BuildFromContext(IntPtr handle);
    
    #if _DEBUG
        internal readonly static bool debug = false;
    #endif    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\fileiopermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  FileIOPermission.cool
//

namespace System.Security.Permissions {
    using System;
    using System.Runtime.CompilerServices;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Util;
    using System.IO;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermissionAccess"]/*' />
    [Flags,Serializable]
    public enum FileIOPermissionAccess
    {
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermissionAccess.NoAccess"]/*' />
        NoAccess = 0x00,
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermissionAccess.Read"]/*' />
        Read = 0x01,
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermissionAccess.Write"]/*' />
        Write = 0x02,
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermissionAccess.Append"]/*' />
        Append = 0x04,
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermissionAccess.PathDiscovery"]/*' />
        PathDiscovery = 0x08,
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermissionAccess.AllAccess"]/*' />
        AllAccess = 0x0F,
    }
    
    
    /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission"]/*' />
    [Serializable()] sealed public class FileIOPermission : CodeAccessPermission, IUnrestrictedPermission, IBuiltInPermission
    {
        private FileIOAccess m_read;
        private FileIOAccess m_write;
        private FileIOAccess m_append;
        private FileIOAccess m_pathDiscovery;
        private bool m_unrestricted;
        
        private static char[] m_illegalCharacters = { '?', '*' };
       
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.FileIOPermission"]/*' />
        public FileIOPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                m_unrestricted = true;
            }
            else if (state == PermissionState.None)
            {
                m_unrestricted = false;
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.FileIOPermission1"]/*' />
        public FileIOPermission( FileIOPermissionAccess access, String path )
        {
            VerifyAccess( access );
        
            String[] pathList = new String[] { path };
            AddPathList( access, pathList, false, true, false );
        }
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.FileIOPermission2"]/*' />
        public FileIOPermission( FileIOPermissionAccess access, String[] pathList )
            : this( access, pathList, true, true )
        {
        }

        internal FileIOPermission( FileIOPermissionAccess access, String[] pathList, bool checkForDuplicates, bool needFullPath )
        {
            VerifyAccess( access );
        
            AddPathList( access, pathList, checkForDuplicates, needFullPath, true );
        }

        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.SetPathList"]/*' />
        public void SetPathList( FileIOPermissionAccess access, String path )
        {
            SetPathList( access, new String[] { path }, false );
        }
            
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.SetPathList1"]/*' />
        public void SetPathList( FileIOPermissionAccess access, String[] pathList )
        {
            SetPathList( access, pathList, true );
        }

        internal void SetPathList( FileIOPermissionAccess access, String[] pathList, bool checkForDuplicates )
        {
            VerifyAccess( access );
            
            if ((access & FileIOPermissionAccess.Read) != 0)
                m_read = null;
            
            if ((access & FileIOPermissionAccess.Write) != 0)
                m_write = null;
    
            if ((access & FileIOPermissionAccess.Append) != 0)
                m_append = null;

            if ((access & FileIOPermissionAccess.PathDiscovery) != 0)
                m_pathDiscovery = null;
            
            AddPathList( access, pathList, checkForDuplicates, true, true );
        }

        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.AddPathList"]/*' />
        public void AddPathList( FileIOPermissionAccess access, String path )
        {
            AddPathList( access, new String[] { path }, false, true, false );
        }

        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.AddPathList1"]/*' />
        public void AddPathList( FileIOPermissionAccess access, String[] pathList )
        {
            AddPathList( access, pathList, true, true, true );
        }

        internal void AddPathList( FileIOPermissionAccess access, String[] pathListOrig, bool checkForDuplicates, bool needFullPath, bool copyPathList )
        {
            VerifyAccess( access );
            
            if (pathListOrig == null)
            {
                throw new ArgumentNullException( "pathList" );    
            }
            if (pathListOrig.Length == 0)
            {
                throw new ArgumentException( Environment.GetResourceString("Argument_EmptyPath" ));    
            }
            
            String[] pathList = pathListOrig;
            if(copyPathList)
            {
                // Make a copy of pathList (in case its value changes after we check for illegal chars)
                pathList = new String[pathListOrig.Length];
                Array.Copy(pathListOrig, pathList, pathListOrig.Length);
            }

            HasIllegalCharacters( pathList );
            
            m_unrestricted = false;
            
            if ((access & FileIOPermissionAccess.Read) != 0)
            {
                if (m_read == null)
                {
                    m_read = new FileIOAccess();
                }
                m_read.AddExpressions( pathList, checkForDuplicates, needFullPath );
            }
            
            if ((access & FileIOPermissionAccess.Write) != 0)
            {
                if (m_write == null)
                {
                    m_write = new FileIOAccess();
                }
                m_write.AddExpressions( pathList, checkForDuplicates, needFullPath );
            }
    
            if ((access & FileIOPermissionAccess.Append) != 0)
            {
                if (m_append == null)
                {
                    m_append = new FileIOAccess();
                }
                m_append.AddExpressions( pathList, checkForDuplicates, needFullPath );
            }

            if ((access & FileIOPermissionAccess.PathDiscovery) != 0)
            {
                if (m_pathDiscovery == null)
                {
                    m_pathDiscovery = new FileIOAccess( true );
                }
                m_pathDiscovery.AddExpressions( pathList, checkForDuplicates, needFullPath );
            }

        }
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.GetPathList"]/*' />
        public String[] GetPathList( FileIOPermissionAccess access )
        {
            VerifyAccess( access );
            ExclusiveAccess( access );
    
            if (AccessIsSet( access, FileIOPermissionAccess.Read ))
            {
                if (m_read == null)
                {
                    return null;
                }
                return m_read.ToStringArray();
            }
            
            if (AccessIsSet( access, FileIOPermissionAccess.Write ))
            {
                if (m_write == null)
                {
                    return null;
                }
                return m_write.ToStringArray();
            }
    
            if (AccessIsSet( access, FileIOPermissionAccess.Append ))
            {
                if (m_append == null)
                {
                    return null;
                }
                return m_append.ToStringArray();
            }
            
            if (AccessIsSet( access, FileIOPermissionAccess.PathDiscovery ))
            {
                if (m_pathDiscovery == null)
                {
                    return null;
                }
                return m_pathDiscovery.ToStringArray();
            }

            // not reached
            
            return null;
        }
        

        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.AllLocalFiles"]/*' />
        public FileIOPermissionAccess AllLocalFiles
        {
            get
            {
                if (m_unrestricted)
                    return FileIOPermissionAccess.AllAccess;
            
                FileIOPermissionAccess access = FileIOPermissionAccess.NoAccess;
                
                if (m_read != null && m_read.AllLocalFiles)
                {
                    access |= FileIOPermissionAccess.Read;
                }
                
                if (m_write != null && m_write.AllLocalFiles)
                {
                    access |= FileIOPermissionAccess.Write;
                }
                
                if (m_append != null && m_append.AllLocalFiles)
                {
                    access |= FileIOPermissionAccess.Append;
                }

                if (m_pathDiscovery != null && m_pathDiscovery.AllLocalFiles)
                {
                    access |= FileIOPermissionAccess.PathDiscovery;
                }
                
                return access;
            }
            
            set
            {
                if ((value & FileIOPermissionAccess.Read) != 0)
                {
                    if (m_read == null)
                        m_read = new FileIOAccess();
                        
                    m_read.AllLocalFiles = true;
                }
                else
                {
                    if (m_read != null)
                        m_read.AllLocalFiles = false;
                }
                
                if ((value & FileIOPermissionAccess.Write) != 0)
                {
                    if (m_write == null)
                        m_write = new FileIOAccess();
                        
                    m_write.AllLocalFiles = true;
                }
                else
                {
                    if (m_write != null)
                        m_write.AllLocalFiles = false;
                }
                
                if ((value & FileIOPermissionAccess.Append) != 0)
                {
                    if (m_append == null)
                        m_append = new FileIOAccess();
                        
                    m_append.AllLocalFiles = true;
                }
                else
                {
                    if (m_append != null)
                        m_append.AllLocalFiles = false;
                }

                if ((value & FileIOPermissionAccess.PathDiscovery) != 0)
                {
                    if (m_pathDiscovery == null)
                        m_pathDiscovery = new FileIOAccess( true );
                        
                    m_pathDiscovery.AllLocalFiles = true;
                }
                else
                {
                    if (m_pathDiscovery != null)
                        m_pathDiscovery.AllLocalFiles = false;
                }

            }
        }
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.AllFiles"]/*' />
        public FileIOPermissionAccess AllFiles
        {
            get
            {
                if (m_unrestricted)
                    return FileIOPermissionAccess.AllAccess;
            
                FileIOPermissionAccess access = FileIOPermissionAccess.NoAccess;
                
                if (m_read != null && m_read.AllFiles)
                {
                    access |= FileIOPermissionAccess.Read;
                }
                
                if (m_write != null && m_write.AllFiles)
                {
                    access |= FileIOPermissionAccess.Write;
                }
                
                if (m_append != null && m_append.AllFiles)
                {
                    access |= FileIOPermissionAccess.Append;
                }
                
                if (m_pathDiscovery != null && m_pathDiscovery.AllFiles)
                {
                    access |= FileIOPermissionAccess.PathDiscovery;
                }

                return access;
            }
            
            set
            {
                if (value == FileIOPermissionAccess.AllAccess)
                {
                    m_unrestricted = true;
                    return;
                }
            
                if ((value & FileIOPermissionAccess.Read) != 0)
                {
                    if (m_read == null)
                        m_read = new FileIOAccess();
                        
                    m_read.AllFiles = true;
                }
                else
                {
                    if (m_read != null)
                        m_read.AllFiles = false;
                }
                
                if ((value & FileIOPermissionAccess.Write) != 0)
                {
                    if (m_write == null)
                        m_write = new FileIOAccess();
                        
                    m_write.AllFiles = true;
                }
                else
                {
                    if (m_write != null)
                        m_write.AllFiles = false;
                }
                
                if ((value & FileIOPermissionAccess.Append) != 0)
                {
                    if (m_append == null)
                        m_append = new FileIOAccess();
                        
                    m_append.AllFiles = true;
                }
                else
                {
                    if (m_append != null)
                        m_append.AllFiles = false;
                }

                if ((value & FileIOPermissionAccess.PathDiscovery) != 0)
                {
                    if (m_pathDiscovery == null)
                        m_pathDiscovery = new FileIOAccess( true );
                        
                    m_pathDiscovery.AllFiles = true;
                }
                else
                {
                    if (m_pathDiscovery != null)
                        m_pathDiscovery.AllFiles = false;
                }

            }
        }        
                                            
        private void VerifyAccess( FileIOPermissionAccess access )
        {
            if ((access & ~FileIOPermissionAccess.AllAccess) != 0)
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)access));
        }
        
        private void ExclusiveAccess( FileIOPermissionAccess access )
        {
            if (access == FileIOPermissionAccess.NoAccess)
            {
                throw new ArgumentException( Environment.GetResourceString("Arg_EnumNotSingleFlag") ); 
            }
    
            if (((int) access & ((int)access-1)) != 0)
            {
                throw new ArgumentException( Environment.GetResourceString("Arg_EnumNotSingleFlag") ); 
            }
        }
                
        private static void HasIllegalCharacters( String[] str )
        {
            for (int i = 0; i < str.Length; ++i)
            {
                if (str[i] == null)
                    throw new ArgumentNullException( "str" );    

                Path.CheckInvalidPathChars( str[i] );

                if (str[i].IndexOfAny( m_illegalCharacters ) != -1)
                    throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidPathChars" ) );
            }
        }
        
        private bool AccessIsSet( FileIOPermissionAccess access, FileIOPermissionAccess question )
        {
            return (access & question) != 0;
        }
        
        private bool IsEmpty()
        {
            return (!m_unrestricted &&
                    (this.m_read == null || this.m_read.IsEmpty()) &&
                    (this.m_write == null || this.m_write.IsEmpty()) &&
                    (this.m_append == null || this.m_append.IsEmpty()) &&
                    (this.m_pathDiscovery == null || this.m_pathDiscovery.IsEmpty()));
        }
        
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            return m_unrestricted;
        }
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.IsEmpty();
            }
            
            try
            {
                FileIOPermission operand = (FileIOPermission)target;
                if (operand.IsUnrestricted())
                    return true;
                else if (this.IsUnrestricted())
                    return false;
                else
                    return ((this.m_read == null || this.m_read.IsSubsetOf( operand.m_read )) &&
                            (this.m_write == null || this.m_write.IsSubsetOf( operand.m_write )) &&
                            (this.m_append == null || this.m_append.IsSubsetOf( operand.m_append )) &&
                            (this.m_pathDiscovery == null || this.m_pathDiscovery.IsSubsetOf( operand.m_pathDiscovery )));
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
                
        }
      
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            else if (this.IsUnrestricted())
            {
                return target.Copy();
            }
    
            FileIOPermission operand = (FileIOPermission)target;
    
            if (operand.IsUnrestricted())
            {
                return this.Copy();
            }
            
            FileIOAccess intersectRead = this.m_read == null ? null : this.m_read.Intersect( operand.m_read );
            FileIOAccess intersectWrite = this.m_write == null ? null : this.m_write.Intersect( operand.m_write );
            FileIOAccess intersectAppend = this.m_append == null ? null : this.m_append.Intersect( operand.m_append );
            FileIOAccess intersectPathDiscovery = this.m_pathDiscovery == null ? null : this.m_pathDiscovery.Intersect( operand.m_pathDiscovery );

            if ((intersectRead == null || intersectRead.IsEmpty()) &&
                (intersectWrite == null || intersectWrite.IsEmpty()) &&
                (intersectAppend == null || intersectAppend.IsEmpty()) &&
                (intersectPathDiscovery == null || intersectPathDiscovery.IsEmpty()))
            {
                return null;
            }
            
            FileIOPermission intersectPermission = new FileIOPermission(PermissionState.None);
            intersectPermission.m_unrestricted = false;
            intersectPermission.m_read = intersectRead;
            intersectPermission.m_write = intersectWrite;
            intersectPermission.m_append = intersectAppend;
            intersectPermission.m_pathDiscovery = intersectPathDiscovery;
            
            return intersectPermission;
        }
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.Union"]/*' />
        public override IPermission Union(IPermission other)
        {
            if (other == null)
            {
                return this.Copy();
            }
            else if (!VerifyType(other))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            FileIOPermission operand = (FileIOPermission)other;
    
            if (this.IsUnrestricted() || operand.IsUnrestricted())
            {
                return new FileIOPermission( PermissionState.Unrestricted );
            }
    
            FileIOAccess unionRead = this.m_read == null ? operand.m_read : this.m_read.Union( operand.m_read );
            FileIOAccess unionWrite = this.m_write == null ? operand.m_write : this.m_write.Union( operand.m_write );
            FileIOAccess unionAppend = this.m_append == null ? operand.m_append : this.m_append.Union( operand.m_append );
            FileIOAccess unionPathDiscovery = this.m_pathDiscovery == null ? operand.m_pathDiscovery : this.m_pathDiscovery.Union( operand.m_pathDiscovery );
            
            if ((unionRead == null || unionRead.IsEmpty()) &&
                (unionWrite == null || unionWrite.IsEmpty()) &&
                (unionAppend == null || unionAppend.IsEmpty()) &&
                (unionPathDiscovery == null || unionPathDiscovery.IsEmpty()))
            {
                return null;
            }
            
            FileIOPermission unionPermission = new FileIOPermission(PermissionState.None);
            unionPermission.m_unrestricted = false;
            unionPermission.m_read = unionRead;
            unionPermission.m_write = unionWrite;
            unionPermission.m_append = unionAppend;
            unionPermission.m_pathDiscovery = unionPathDiscovery;

            return unionPermission;    
        }
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            FileIOPermission copy = new FileIOPermission(PermissionState.None);
            if (this.m_unrestricted)
            {
                copy.m_unrestricted = true;
            }
            else
            {
                copy.m_unrestricted = false;
                if (this.m_read != null)
                {
                    copy.m_read = this.m_read.Copy();
                }
                if (this.m_write != null)
                {
                    copy.m_write = this.m_write.Copy();
                }
                if (this.m_append != null)
                {
                    copy.m_append = this.m_append.Copy();
                }
                if (this.m_pathDiscovery != null)
                {
                    copy.m_pathDiscovery = this.m_pathDiscovery.Copy();
                }
            }
            return copy;   
        }
   
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (!IsUnrestricted())
            {
                if (this.m_read != null && !this.m_read.IsEmpty())
                {
                    esd.AddAttribute( "Read", SecurityElement.Escape( m_read.ToString() ) );
                }
                if (this.m_write != null && !this.m_write.IsEmpty())
                {
                    esd.AddAttribute( "Write", SecurityElement.Escape( m_write.ToString() ) );
                }
                if (this.m_append != null && !this.m_append.IsEmpty())
                {
                    esd.AddAttribute( "Append", SecurityElement.Escape( m_append.ToString() ) );
                }
                if (this.m_pathDiscovery != null && !this.m_pathDiscovery.IsEmpty())
                {
                    esd.AddAttribute( "PathDiscovery", SecurityElement.Escape( m_pathDiscovery.ToString() ) );
                }
            }
            else
            {
                esd.AddAttribute( "Unrestricted", "true" );
            }
            return esd;
        }
        
        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            String et;
            
            if (XMLUtil.IsUnrestricted(esd))
            {
                m_unrestricted = true;
                return;
            }
    
            
            m_unrestricted = false;
            
            et = esd.Attribute( "Read" );
            if (et != null)
            {
                m_read = new FileIOAccess( et );
            }
            else
            {
                m_read = null;
            }
            
            et = esd.Attribute( "Write" );
            if (et != null)
            {
                m_write = new FileIOAccess( et );
            }
            else
            {
                m_write = null;
            }
    
            et = esd.Attribute( "Append" );
            if (et != null)
            {
                m_append = new FileIOAccess( et );
            }
            else
            {
                m_append = null;
            }

            et = esd.Attribute( "PathDiscovery" );
            if (et != null)
            {
                m_pathDiscovery = new FileIOAccess( et );
                m_pathDiscovery.PathDiscovery = true;
            }
            else
            {
                m_pathDiscovery = null;
            }
        }

        /// <include file='doc\FileIOPermission.uex' path='docs/doc[@for="FileIOPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return FileIOPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.FileIOPermissionIndex;
        }

        
    }
    
    [Serializable]
    internal class FileIOAccess
    {
        private bool m_ignoreCase = true;
        
        private StringExpressionSet m_set;
        private bool m_allFiles;
        private bool m_allLocalFiles;
        private bool m_pathDiscovery;
    
        private static readonly String m_strAllFiles = "*AllFiles*";
        private static readonly String m_strAllLocalFiles = "*AllLocalFiles*";
        
        public FileIOAccess()
        {
            m_set = new StringExpressionSet( m_ignoreCase, true );
            m_allFiles = false;
            m_allLocalFiles = false;
            m_pathDiscovery = false;
        }

        public FileIOAccess( bool pathDiscovery )
        {
            m_set = new StringExpressionSet( m_ignoreCase, true );
            m_allFiles = false;
            m_allLocalFiles = false;
            m_pathDiscovery = pathDiscovery;
        }
        
        public FileIOAccess( String value )
        {
            if (value == null)
            {
                m_set = new StringExpressionSet( m_ignoreCase, true );
                m_allFiles = false;
                m_allLocalFiles = false;
            }
            else if (value.Length >= m_strAllFiles.Length && String.Compare( m_strAllFiles, value, false, CultureInfo.InvariantCulture) == 0)
            {
                m_set = new StringExpressionSet( m_ignoreCase, true );
                m_allFiles = true;
                m_allLocalFiles = false;
            }
            else if (value.Length >= m_strAllLocalFiles.Length && String.Compare( m_strAllLocalFiles, 0, value, 0, m_strAllLocalFiles.Length, false, CultureInfo.InvariantCulture) == 0)
            {
                m_set = new StringExpressionSet( m_ignoreCase, value.Substring( m_strAllLocalFiles.Length ), true );
                m_allFiles = false;
                m_allLocalFiles = true;
            }
            else
            {
                m_set = new StringExpressionSet( m_ignoreCase, value, true );
                m_allFiles = false;
                m_allLocalFiles = false;
            }
            m_pathDiscovery = false;
        }
        
        public FileIOAccess( bool allFiles, bool allLocalFiles, bool pathDiscovery )
        {
            m_set = new StringExpressionSet( m_ignoreCase, true );
            m_allFiles = allFiles;
            m_allLocalFiles = allLocalFiles;
            m_pathDiscovery = pathDiscovery;
        }
        
        public FileIOAccess( StringExpressionSet set, bool allFiles, bool allLocalFiles, bool pathDiscovery )
        {
            m_set = set;
            m_set.SetThrowOnRelative( true );
            m_allFiles = allFiles;
            m_allLocalFiles = allLocalFiles;
            m_pathDiscovery = pathDiscovery;
        }
        
        private FileIOAccess( FileIOAccess operand )
        {
            m_set = operand.m_set.Copy();
            m_allFiles = operand.m_allFiles;
            m_allLocalFiles = operand.m_allLocalFiles;
            m_pathDiscovery = operand.m_pathDiscovery;
        }
        
        public void AddExpressions( String value )
        {
            m_allFiles = false;
            m_set.AddExpressions( value );
        }

        public void AddExpressions( String[] value, bool checkForDuplicates, bool needFullPath )
        {
            m_allFiles = false;
            m_set.AddExpressions( value, checkForDuplicates, needFullPath );
        }

        
        public bool AllFiles
        {
            get
            {
                return m_allFiles;
            }
            
            set
            {
                m_allFiles = value;
            }
        }
        
        public bool AllLocalFiles
        {
            get
            {
                return m_allLocalFiles;
            }
            
            set
            {
                m_allLocalFiles = value;
            }
        }

        public bool PathDiscovery
        {
            get
            {
                return m_pathDiscovery;
            }
            
            set
            {
                m_pathDiscovery = value;
            }
        }
        
        public bool IsEmpty()
        {
            return !m_allFiles && !m_allLocalFiles && (m_set == null || m_set.IsEmpty());
        }
        
        public FileIOAccess Copy()
        {
            return new FileIOAccess( this );
        }
        
        public FileIOAccess Union( FileIOAccess operand )
        {
            if (operand == null)
            {
                return this.IsEmpty() ? null : this.Copy();
            }
            
            BCLDebug.Assert( this.m_pathDiscovery == operand.m_pathDiscovery, "Path discovery settings must match" );

            if (this.m_allFiles || operand.m_allFiles)
            {
                return new FileIOAccess( true, false, this.m_pathDiscovery );
            }

            return new FileIOAccess( this.m_set.Union( operand.m_set ), false, this.m_allLocalFiles || operand.m_allLocalFiles, this.m_pathDiscovery );
        }
        
        public FileIOAccess Intersect( FileIOAccess operand )
        {
            if (operand == null)
            {
                return null;
            }
            
            BCLDebug.Assert( this.m_pathDiscovery == operand.m_pathDiscovery, "Path discovery settings must match" );

            if (this.m_allFiles)
            {
                if (operand.m_allFiles)
                {
                    return new FileIOAccess( true, false, this.m_pathDiscovery );
                }
                else
                {
                    return new FileIOAccess( operand.m_set.Copy(), false, operand.m_allLocalFiles, this.m_pathDiscovery );
                }
            }
            else if (operand.m_allFiles)
            {
                return new FileIOAccess( this.m_set.Copy(), false, this.m_allLocalFiles, this.m_pathDiscovery );
            }

            StringExpressionSet intersectionSet = new StringExpressionSet( m_ignoreCase, true );

            if (this.m_allLocalFiles)
            {
                String[] expressions = operand.m_set.ToStringArray();
            
                for (int i = 0; i < expressions.Length; ++i)
                {
                    String root = GetRoot( expressions[i] );
                    if (root != null && _LocalDrive( GetRoot( root ) ) != 0)
                    {
                        intersectionSet.AddExpressions( new String[] { expressions[i] }, true, false );
                    }
                }
            }

            if (operand.m_allLocalFiles)
            {
                String[] expressions = this.m_set.ToStringArray();
            
                for (int i = 0; i < expressions.Length; ++i)
                {
                    String root = GetRoot( expressions[i] );
                    if (root != null && _LocalDrive( GetRoot( root ) ) != 0)
                    {
                        intersectionSet.AddExpressions( new String[] { expressions[i] }, true, false );
                    }
                }
            }

            String[] regularIntersection = this.m_set.Intersect( operand.m_set ).ToStringArray();

            if (regularIntersection != null)
                intersectionSet.AddExpressions( regularIntersection, !intersectionSet.IsEmpty(), false );

            return new FileIOAccess( intersectionSet, false, this.m_allLocalFiles && operand.m_allLocalFiles, this.m_pathDiscovery );
        }
    
        public bool IsSubsetOf( FileIOAccess operand )
        {
            if (operand == null)
            {
                return this.IsEmpty();
            }
            
            if (operand.m_allFiles)
            {
                return true;
            }
            
            BCLDebug.Assert( this.m_pathDiscovery == operand.m_pathDiscovery, "Path discovery settings must match" );

            if (!((m_pathDiscovery && this.m_set.IsSubsetOfPathDiscovery( operand.m_set )) || this.m_set.IsSubsetOf( operand.m_set )))
            {
                if (operand.m_allLocalFiles)
                {
                    String[] expressions = m_set.ToStringArray();
                
                    for (int i = 0; i < expressions.Length; ++i)
                    {
                        String root = GetRoot( expressions[i] );
                        if (root == null || _LocalDrive( GetRoot( root ) ) != 0)
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    return false;
                }
            }
            
            return true;
        }
        
        private static String GetRoot( String path )
        {
            String str = path.Substring( 0, 3 );
            
            if (str.EndsWith( ":\\"))
            {
                return str;
            }
            else
            {
                return null;
            }
        }
        
        public override String ToString()
        {
            if (m_allFiles)
            {
                return m_strAllFiles;
            }
            else
            {
                if (m_allLocalFiles)
                {
                    String retstr = m_strAllLocalFiles;

                    String tempStr = m_set.ToString();

                    if (tempStr != null && tempStr.Length > 0)
                        retstr += ";" + tempStr;

                    return retstr;
                }
                else
                {
                    return m_set.ToString();
                }
            }
        }

        public String[] ToStringArray()
        {
            return m_set.ToStringArray();
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int _LocalDrive( String path );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\permissionstate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PermissionState.cool
//
//  The Runtime policy manager.  Maintains a set of IdentityMapper objects that map 
//  inbound evidence to groups.  Resolves an identity into a set of permissions
//

namespace System.Security.Permissions {
    
	using System;
    /// <include file='doc\PermissionState.uex' path='docs/doc[@for="PermissionState"]/*' />
	[Serializable]
    public enum PermissionState
    {
        /// <include file='doc\PermissionState.uex' path='docs/doc[@for="PermissionState.Unrestricted"]/*' />
        Unrestricted = 1,
        /// <include file='doc\PermissionState.uex' path='docs/doc[@for="PermissionState.None"]/*' />
        None = 0,
    } 
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\iunrestrictedpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// IUnrestrictedPermission.cool
//

namespace System.Security.Permissions {
    
	using System;
    /// <include file='doc\IUnrestrictedPermission.uex' path='docs/doc[@for="IUnrestrictedPermission"]/*' />
    public interface IUnrestrictedPermission
    {
        /// <include file='doc\IUnrestrictedPermission.uex' path='docs/doc[@for="IUnrestrictedPermission.IsUnrestricted"]/*' />
        bool IsUnrestricted();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\publisheridentitypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// PublisherIdentityPermission.cool
// 
// author: gregfee
// 

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using X509Certificate = System.Security.Cryptography.X509Certificates.X509Certificate;
    using System.Security.Util;
    using System.IO;

    /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission"]/*' />
    [Serializable()] sealed public class PublisherIdentityPermission : CodeAccessPermission, IBuiltInPermission
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private X509Certificate m_certificate;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
        
       
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.PublisherIdentityPermission"]/*' />
        public PublisherIdentityPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else if (state == PermissionState.None)
            {
                m_certificate = null;
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.PublisherIdentityPermission1"]/*' />
        public PublisherIdentityPermission( X509Certificate certificate )
        {
            CheckCertificate( certificate );
            this.Certificate = certificate;
        }
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
        
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.Certificate"]/*' />
        public X509Certificate Certificate
        {
            set
            {
                CheckCertificate( value );
                m_certificate = new X509Certificate( value );
            }
            
            get
            {
                if (m_certificate != null)
                {
                    return new X509Certificate( m_certificate );
                }
                else
                {
                    return null;
                }
            }
        }
    
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED HELPERS FOR ACCESSORS AND CONSTRUCTORS
        //
        //------------------------------------------------------
    
        private static void CheckCertificate( X509Certificate certificate )
        {
            if (certificate == null)
            {
                throw new ArgumentNullException( "certificate" );
            }
            if (certificate.GetRawCertData() == null) {
                throw new ArgumentException(Environment.GetResourceString("Argument_UninitializedCertificate"));
            }
        }
        
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            return m_certificate == null ? new PublisherIdentityPermission( PermissionState.None ) : new PublisherIdentityPermission( m_certificate );
        }
        
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.m_certificate == null;
            }
           
            try
            {
                PublisherIdentityPermission operand = (PublisherIdentityPermission)target;
            
                if (this.m_certificate == null)
                {
                    return true;
                }
                else if (operand.m_certificate == null)
                {
                    return false;
                }
                else
                {
                    return this.m_certificate.Equals(operand.m_certificate);
                }
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }                

        }
        
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null || this.m_certificate == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            PublisherIdentityPermission operand = (PublisherIdentityPermission)target;
            
            if (operand.m_certificate == null)
            {
                return null;
            }
            else if (this.m_certificate.Equals(operand.m_certificate))
            {
                return this.Copy();
            }
            else
            {
                return null;
            }
        }
    
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.Union"]/*' />
        public override IPermission Union(IPermission target)
        {
            if (target == null)
            {
                return this.m_certificate != null ? this.Copy() : null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            PublisherIdentityPermission operand = (PublisherIdentityPermission)target;
            
            if (this.m_certificate == null)
            {
                return operand.m_certificate != null ? target.Copy() : null;
            }
            else if (operand.m_certificate == null || this.m_certificate.Equals(((PublisherIdentityPermission)target).m_certificate))
            {
                return this.Copy();
            }
            else
            {
                return null;
            }
        }
               
        
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            String elem = esd.Attribute( "X509v3Certificate" );
            m_certificate = elem == null ? null : new X509Certificate( System.Security.Util.Hex.DecodeHexString( elem ) );
            
        }
        
        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (m_certificate != null)
            {
                esd.AddAttribute( "X509v3Certificate", m_certificate.GetRawCertDataString() );
            }
            return esd;
        }

        /// <include file='doc\PublisherIdentityPermission.uex' path='docs/doc[@for="PublisherIdentityPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return PublisherIdentityPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.PublisherIdentityPermissionIndex;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\reflectionpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ReflectionPermission.cool
//

namespace System.Security.Permissions
{
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Security;
    using System.Reflection;

    /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermissionFlag"]/*' />
    [Flags,Serializable]
    public enum ReflectionPermissionFlag
    {
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermissionFlag.NoFlags"]/*' />
        NoFlags = 0x00,
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermissionFlag.TypeInformation"]/*' />
        TypeInformation = 0x01,
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermissionFlag.MemberAccess"]/*' />
        MemberAccess = 0x02,
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermissionFlag.ReflectionEmit"]/*' />
        ReflectionEmit = 0x04,
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermissionFlag.AllFlags"]/*' />
        AllFlags = 0x07
    }

    /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission"]/*' />
    [Serializable()] sealed public class ReflectionPermission
           : CodeAccessPermission, IUnrestrictedPermission, IBuiltInPermission
    {

        private ReflectionPermissionFlag m_flags;

        //
        // Public Constructors
        //
        
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.ReflectionPermission"]/*' />
        public ReflectionPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                SetUnrestricted( true );
            }
            else if (state == PermissionState.None)
            {
                SetUnrestricted( false );
                Reset();
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }    
        
         // Parameters:
         //
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.ReflectionPermission1"]/*' />
        public ReflectionPermission(ReflectionPermissionFlag flag)
        {
            VerifyAccess(flag);
            
            SetUnrestricted(false);
            m_flags = flag;
        }
    
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED MODIFIERS 
        //
        //------------------------------------------------------
        
        
        private void SetUnrestricted(bool unrestricted)
        {
            if (unrestricted)
            {
                m_flags = ReflectionPermissionFlag.AllFlags;
            }
            else
            {
                Reset();
            }
        }
        
        
        private void Reset()
        {
            m_flags = ReflectionPermissionFlag.NoFlags;
        }    
        
     
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.Flags"]/*' />
        public ReflectionPermissionFlag Flags
        {
            set
            {
                VerifyAccess(value);
            
                m_flags = value;
            }
            
            get
            {
                return m_flags;
            }
        }
        
            
    #if ZERO   // Do not remove this code, usefull for debugging
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.ToString"]/*' />
        public override String ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("ReflectionPermission(");
            if (IsUnrestricted())
            {
                sb.Append("Unrestricted");
            }
            else
            {
                if (GetFlag(ReflectionPermissionFlag.TypeInformation))
                    sb.Append("TypeInformation; ");
                if (GetFlag(ReflectionPermissionFlag.MemberAccess))
                    sb.Append("MemberAccess; ");
                if (GetFlag(ReflectionPermissionFlag.ReflectionEmit))
                    sb.Append("ReflectionEmit; ");
            }
            
            sb.Append(")");
            return sb.ToString();
        }
    #endif
    
    
        //
        // CodeAccessPermission implementation
        //
        
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            return m_flags == ReflectionPermissionFlag.AllFlags;
        }
        
        //
        // IPermission implementation
        //
        
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.Union"]/*' />
        public override IPermission Union(IPermission other)
        {
            if (other == null)
            {
                return this.Copy();
            }
            else if (!VerifyType(other))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            ReflectionPermission operand = (ReflectionPermission)other;
    
            if (this.IsUnrestricted() || operand.IsUnrestricted())
            {
                return new ReflectionPermission( PermissionState.Unrestricted );
            }
            else
            {
                ReflectionPermissionFlag flag_union = (ReflectionPermissionFlag)(m_flags | operand.m_flags);
                return(new ReflectionPermission(flag_union));
            }
        }  
        
        
        
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return m_flags == ReflectionPermissionFlag.NoFlags;
            }

            try
            {
                ReflectionPermission operand = (ReflectionPermission)target;
                if (operand.IsUnrestricted())
                    return true;
                else if (this.IsUnrestricted())
                    return false;
                else
                    return (((int)this.m_flags) & ~((int)operand.m_flags)) == 0;
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }                

        }
        
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
                return null;
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }

            ReflectionPermission operand = (ReflectionPermission)target;

            ReflectionPermissionFlag newFlags = operand.m_flags & this.m_flags;
            
            if (newFlags == ReflectionPermissionFlag.NoFlags)
                return null;
            else
                return new ReflectionPermission( newFlags );
        }
    
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            if (this.IsUnrestricted())
            {
                return new ReflectionPermission(PermissionState.Unrestricted);
            }
            else
            {
                return new ReflectionPermission((ReflectionPermissionFlag)m_flags);
            }
        }
        
        
        //
        // IEncodable Interface 
    
        private
        void VerifyAccess(ReflectionPermissionFlag type)
        {
            if ((type & ~ReflectionPermissionFlag.AllFlags) != 0)
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)type));
        }
        
    
        //------------------------------------------------------
        //
        // PUBLIC ENCODING METHODS
        //
        //------------------------------------------------------
        
        private const String _strHeaderTypeInformation  = "TypeInformation";
        private const String _strHeaderMemberAccess  = "MemberAccess";
        private const String _strHeaderReflectionEmit  = "ReflectionEmit";
    
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (!IsUnrestricted())
            {
                esd.AddAttribute( "Flags", XMLUtil.BitFieldEnumToString( typeof( ReflectionPermissionFlag ), m_flags ) );
                }
            else
            {
                esd.AddAttribute( "Unrestricted", "true" );
            }
            return esd;
        }
    
        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            if (XMLUtil.IsUnrestricted( esd ))
            {
                m_flags = ReflectionPermissionFlag.AllFlags;
                return;
            }
           
            Reset () ;
            SetUnrestricted (false) ;
    
            String flags = esd.Attribute( "Flags" );
            if (flags != null)
                m_flags = (ReflectionPermissionFlag)Enum.Parse( typeof( ReflectionPermissionFlag ), flags );
        }

        /// <include file='doc\ReflectionPermission.uex' path='docs/doc[@for="ReflectionPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return ReflectionPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.ReflectionPermissionIndex;
        }

       
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\principalpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PrincipalPermission.cool
//

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Util;
    using System.IO;
    using System.Collections;
    using System.Security.Principal;
    using System.Text;
    using System.Threading;    
    using System.Globalization;

    [Serializable()] internal class IDRole
    {
        internal bool m_authenticated;
        internal String m_id;
        internal String m_role;
        
        internal SecurityElement ToXml()
        {
            SecurityElement root = new SecurityElement( "Identity" );
            
            if (m_authenticated)
                root.AddAttribute( "Authenticated", "true" );
                
            if (m_id != null)
            {
                root.AddAttribute( "ID", SecurityElement.Escape( m_id ) );
            }
               
            if (m_role != null)
            {
                root.AddAttribute( "Role", SecurityElement.Escape( m_role ) );
            }
                            
            return root;
        }
        
        internal void FromXml( SecurityElement e )
        {
            String elAuth = e.Attribute( "Authenticated" );
            if (elAuth != null)
            {
                m_authenticated = String.Compare( elAuth, "true", true, CultureInfo.InvariantCulture) == 0;
            }
            else
            {
                m_authenticated = false;
            }
           
            String elID = e.Attribute( "ID" );
            if (elID != null)
            {
                m_id = elID;
            }
            else
            {
                m_id = null;
            }
            
            String elRole = e.Attribute( "Role" );
            if (elRole != null)
            {
                m_role = elRole;
            }
            else
            {
                m_role = null;
            }
        }
    }
    
    /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission"]/*' />
    [Serializable()] sealed public class PrincipalPermission : IPermission, IUnrestrictedPermission, ISecurityEncodable, IBuiltInPermission
    {
        private IDRole[] m_array;
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.PrincipalPermission"]/*' />
        public PrincipalPermission( PermissionState state )
        {
            if (state == PermissionState.Unrestricted)
            {
                m_array = new IDRole[1];
                m_array[0] = new IDRole();
                m_array[0].m_authenticated = true;
                m_array[0].m_id = null;
                m_array[0].m_role = null;
            }
            else if (state == PermissionState.None)
            {
                m_array = new IDRole[1];
                m_array[0] = new IDRole();
                m_array[0].m_authenticated = false;
                m_array[0].m_id = "";
                m_array[0].m_role = "";
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.PrincipalPermission1"]/*' />
        public PrincipalPermission( String name, String role )
        {
            m_array = new IDRole[1];
            m_array[0] = new IDRole();
            m_array[0].m_authenticated = true;
            m_array[0].m_id = name;
            m_array[0].m_role = role;
        }
    
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.PrincipalPermission2"]/*' />
        public PrincipalPermission( String name, String role, bool isAuthenticated )
        {
            m_array = new IDRole[1];
            m_array[0] = new IDRole();
            m_array[0].m_authenticated = isAuthenticated;
            m_array[0].m_id = name;
            m_array[0].m_role = role;
        }        
    
        private PrincipalPermission( IDRole[] array )
        {
            m_array = array;
        }
    
        private bool IsEmpty()
        {
            for (int i = 0; i < m_array.Length; ++i)
            {
                if ((m_array[i].m_id == null || !m_array[i].m_id.Equals( "" )) ||
                    (m_array[i].m_role == null || !m_array[i].m_role.Equals( "" )) ||
                    m_array[i].m_authenticated)
                {
                    return false;
                }
            }
            return true;
        }
        
        private bool VerifyType(IPermission perm)
        {
            // if perm is null, then obviously not of the same type
            if ((perm == null) || (perm.GetType() != this.GetType())) {
                return(false);
            } else {
                return(true);
            }
        }
         
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            for (int i = 0; i < m_array.Length; ++i)
            {
                if (m_array[i].m_id != null || m_array[i].m_role != null || !m_array[i].m_authenticated)
                {
                    return false;
                }
            }
            return true;
        }

        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.IsSubsetOf"]/*' />
        public bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.IsEmpty();
            }
        
            try
            {
                PrincipalPermission operand = (PrincipalPermission)target;
            
                if (operand.IsUnrestricted())
                    return true;
                else if (this.IsUnrestricted())
                    return false;
                else
                {
                    for (int i = 0; i < this.m_array.Length; ++i)
                    {
                        bool foundMatch = false;
                
                        for (int j = 0; j < operand.m_array.Length; ++j)
                        {
                            if (operand.m_array[j].m_authenticated == this.m_array[i].m_authenticated &&
                                (operand.m_array[j].m_id == null ||
                                 (this.m_array[i].m_id != null && this.m_array[i].m_id.Equals( operand.m_array[j].m_id ))) &&
                                (operand.m_array[j].m_role == null ||
                                 (this.m_array[i].m_role != null && this.m_array[i].m_role.Equals( operand.m_array[j].m_role ))))
                            {
                                foundMatch = true;
                                break;
                            }
                        }
                    
                        if (!foundMatch)
                            return false;
                    }
                                            
                    return true;
                }
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }                

            
        }
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.Intersect"]/*' />
        public IPermission Intersect(IPermission target)
        {
            if (target == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            else if (this.IsUnrestricted())
            {
                return target.Copy();
            }
    
            PrincipalPermission operand = (PrincipalPermission)target;
    
            if (operand.IsUnrestricted())
            {
                return this.Copy();
            }
            
            ArrayList idroles = null;
            
            for (int i = 0; i < this.m_array.Length; ++i)
            {
                for (int j = 0; j < operand.m_array.Length; ++j)
                {
                    if (operand.m_array[j].m_authenticated == this.m_array[i].m_authenticated)
                    {
                        if (operand.m_array[j].m_id == null ||
                            this.m_array[i].m_id == null ||
                            this.m_array[i].m_id.Equals( operand.m_array[j].m_id ))
                        {
                            if (idroles == null)
                            {
                                idroles = new ArrayList();
                            }
                    
                            IDRole idrole = new IDRole();
                            
                            idrole.m_id = operand.m_array[j].m_id == null ? this.m_array[i].m_id : operand.m_array[j].m_id;
                            
                            if (operand.m_array[j].m_role == null ||
                                this.m_array[i].m_role == null ||
                                this.m_array[i].m_role.Equals( operand.m_array[j].m_role))
                            {
                                idrole.m_role = operand.m_array[j].m_role == null ? this.m_array[i].m_role : operand.m_array[j].m_role;
                            }
                            else
                            {
                                idrole.m_role = "";
                            }
                            
                            idrole.m_authenticated = operand.m_array[j].m_authenticated;
                            
                            idroles.Add( idrole );
                        }
                        else if (operand.m_array[j].m_role == null ||
                                 this.m_array[i].m_role == null ||
                                 this.m_array[i].m_role.Equals( operand.m_array[j].m_role))
                        {
                            if (idroles == null)
                            {
                                idroles = new ArrayList();
                            }

                            IDRole idrole = new IDRole();
                            
                            idrole.m_id = "";
                            idrole.m_role = operand.m_array[j].m_role == null ? this.m_array[i].m_role : operand.m_array[j].m_role;
                            idrole.m_authenticated = operand.m_array[j].m_authenticated;
                            
                            idroles.Add( idrole );
                        }
                    }
                }
            }
            
            if (idroles == null)
            {
                return null;
            }
            else
            {
                IDRole[] idrolesArray = new IDRole[idroles.Count];
                
                IEnumerator idrolesEnumerator = idroles.GetEnumerator();
                int index = 0;
                
                while (idrolesEnumerator.MoveNext())
                {
                    idrolesArray[index++] = (IDRole)idrolesEnumerator.Current;
                }
                                                                
                return new PrincipalPermission( idrolesArray );
            }
        }                                                    
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.Union"]/*' />
        public IPermission Union(IPermission other)
        {
            if (other == null)
            {
                return this.Copy();
            }
            else if (!VerifyType(other))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
    
            PrincipalPermission operand = (PrincipalPermission)other;
           
            if (this.IsUnrestricted() || operand.IsUnrestricted())
            {
                return new PrincipalPermission( PermissionState.Unrestricted );
            }
    
            // Now we have to do a real union
            
            int combinedLength = this.m_array.Length + operand.m_array.Length;
            IDRole[] idrolesArray = new IDRole[combinedLength];
            
            int i, j;
            for (i = 0; i < this.m_array.Length; ++i)
            {
                idrolesArray[i] = this.m_array[i];
            }
            
            for (j = 0; j < operand.m_array.Length; ++j)
            {
                idrolesArray[i+j] = operand.m_array[j];
            }
            
            return new PrincipalPermission( idrolesArray );

        }    
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.Copy"]/*' />
        public IPermission Copy()
        {
            return new PrincipalPermission( m_array );  
        }
       
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.Demand"]/*' />
        public void Demand()
        {
            IPrincipal principal = Thread.CurrentPrincipal;
            
            if (principal == null)
                throw new SecurityException(Environment.GetResourceString("Security_PrincipalPermission"), this.GetType(), this.ToXml().ToString());
            
            if (m_array == null)
                return;
            
            // A demand passes when the grant satisfies all entries.
            
            int count = this.m_array.Length;
            bool foundMatch = false;
            for (int i = 0; i < count; ++i)
            {
                // If the demand is authenticated, we need to check the identity and role
            
                if (m_array[i].m_authenticated)
                {
                    IIdentity identity = principal.Identity;

                    if ((identity.IsAuthenticated &&
                         (m_array[i].m_role == null || principal.IsInRole( m_array[i].m_role )) &&
                         (m_array[i].m_id == null || String.Compare( identity.Name, m_array[i].m_id, true, CultureInfo.InvariantCulture) == 0)))
                    {
                        foundMatch = true;
                        break;
                    }
                }
                else
                {
                    foundMatch = true;
                    break;
                }
            }

            if (!foundMatch)
                throw new SecurityException(Environment.GetResourceString("Security_PrincipalPermission"), typeof( PrincipalPermission ) );
        }
        
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            SecurityElement root = new SecurityElement( "Permission" );
            
            XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            int count = m_array.Length;
            for (int i = 0; i < count; ++i)
            {
                root.AddChild( m_array[i].ToXml() );
            }
            
            return root;
        }
            
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.FromXml"]/*' />
        public void FromXml(SecurityElement elem)
        {
            CodeAccessPermission.ValidateElement( elem, this );
               
            m_array = null;   
               
            if (elem.m_lChildren != null && elem.m_lChildren.Count != 0)
            { 
                int numChildren = elem.m_lChildren.Count;
                int count = 0;
                
                m_array = new IDRole[numChildren];
            
                IEnumerator enumerator = elem.m_lChildren.GetEnumerator();
            
                while (enumerator.MoveNext())  
                {
                    IDRole idrole = new IDRole();
                    
                    idrole.FromXml( (SecurityElement)enumerator.Current );
                    
                    m_array[count++] = idrole;
                }
            }
        }
                 
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.ToString"]/*' />
        public override String ToString()
        {
            return ToXml().ToString();
        }
     
        /// <include file='doc\PrincipalPermission.uex' path='docs/doc[@for="PrincipalPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return PrincipalPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.PrincipalPermissionIndex;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\registrypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  RegistryPermission.cool
//

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Util;
    using System.IO;

    /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermissionAccess"]/*' />
    [Flags,Serializable]
    public enum RegistryPermissionAccess
    {
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermissionAccess.NoAccess"]/*' />
        NoAccess = 0x00,
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermissionAccess.Read"]/*' />
        Read = 0x01,
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermissionAccess.Write"]/*' />
        Write = 0x02,
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermissionAccess.Create"]/*' />
        Create = 0x04,
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermissionAccess.AllAccess"]/*' />
        AllAccess = 0x07,
    }
    
    /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission"]/*' />
    [Serializable()] sealed public class RegistryPermission : CodeAccessPermission, IUnrestrictedPermission, IBuiltInPermission
    {
        private StringExpressionSet m_read;
        private StringExpressionSet m_write;
        private StringExpressionSet m_create;
        private bool m_unrestricted;
    
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.RegistryPermission"]/*' />
        public RegistryPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                m_unrestricted = true;
            }
            else if (state == PermissionState.None)
            {
                m_unrestricted = false;
                m_read = new StringExpressionSet();
                m_write = new StringExpressionSet();
                m_create = new StringExpressionSet();
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.RegistryPermission1"]/*' />
        public RegistryPermission( RegistryPermissionAccess access, String pathList )
        {
            VerifyAccess( access );
        
            AddPathList( access, pathList );
        }
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.SetPathList"]/*' />
        public void SetPathList( RegistryPermissionAccess access, String pathList )
        {
            VerifyAccess( access );
            
            if ((access & RegistryPermissionAccess.Read) != 0)
                m_read = null;
            
            if ((access & RegistryPermissionAccess.Write) != 0)
                m_write = null;
    
            if ((access & RegistryPermissionAccess.Create) != 0)
                m_create = null;
            
            AddPathList( access, pathList );
        }
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.AddPathList"]/*' />
        public void AddPathList( RegistryPermissionAccess access, String pathList )
        {
            VerifyAccess( access );
            
            m_unrestricted = false;
            
            if ((access & RegistryPermissionAccess.Read) != 0)
            {
                if (m_read == null)
                {
                    m_read = new StringExpressionSet();
                }
                m_read.AddExpressions( pathList );
            }
            
            if ((access & RegistryPermissionAccess.Write) != 0)
            {
                if (m_write == null)
                {
                    m_write = new StringExpressionSet();
                }
                m_write.AddExpressions( pathList );
            }
    
            if ((access & RegistryPermissionAccess.Create) != 0)
            {
                if (m_create == null)
                {
                    m_create = new StringExpressionSet();
                }
                m_create.AddExpressions( pathList );
            }
        }
    
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.GetPathList"]/*' />
        public String GetPathList( RegistryPermissionAccess access )
        {
            VerifyAccess( access );
            ExclusiveAccess( access );
    
            if ((access & RegistryPermissionAccess.Read) != 0)
            {
                if (m_read == null)
                {
                    return "";
                }
                return m_read.ToString();
            }
            
            if ((access & RegistryPermissionAccess.Write) != 0)
            {
                if (m_write == null)
                {
                    return "";
                }
                return m_write.ToString();
            }
    
            if ((access & RegistryPermissionAccess.Create) != 0)
            {
                if (m_create == null)
                {
                    return "";
                }
                return m_create.ToString();
            }
            
            /* not reached */
            
            return "";
        }     
        
        private void VerifyAccess( RegistryPermissionAccess access )
        {
            if ((access & ~RegistryPermissionAccess.AllAccess) != 0)
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)access));
        }
        
        private void ExclusiveAccess( RegistryPermissionAccess access )
        {
            if (access == RegistryPermissionAccess.NoAccess)
            {
                throw new ArgumentException( Environment.GetResourceString("Arg_EnumNotSingleFlag") ); 
            }
    
            if (((int) access & ((int)access-1)) != 0)
            {
                throw new ArgumentException( Environment.GetResourceString("Arg_EnumNotSingleFlag") ); 
            }
        }
        
        private bool IsEmpty()
        {
            return (!m_unrestricted &&
                    (this.m_read == null || this.m_read.IsEmpty()) &&
                    (this.m_write == null || this.m_write.IsEmpty()) &&
                    (this.m_create == null || this.m_create.IsEmpty()));
        }
        
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            return m_unrestricted;
        }
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.IsEmpty();
            }

            try
            {
                RegistryPermission operand = (RegistryPermission)target;
                if (operand.IsUnrestricted())
                    return true;
                else if (this.IsUnrestricted())
                    return false;
                else
                    return ((this.m_read == null || this.m_read.IsSubsetOf( operand.m_read )) &&
                            (this.m_write == null || this.m_write.IsSubsetOf( operand.m_write )) &&
                            (this.m_create == null || this.m_create.IsSubsetOf( operand.m_create )));
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }                
           
        }
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            else if (this.IsUnrestricted())
            {
                return target.Copy();
            }
            
            RegistryPermission operand = (RegistryPermission)target;
            if (operand.IsUnrestricted())
            {
                return this.Copy();
            }
            
            
            StringExpressionSet intersectRead = this.m_read == null ? null : this.m_read.Intersect( operand.m_read );
            StringExpressionSet intersectWrite = this.m_write == null ? null : this.m_write.Intersect( operand.m_write );
            StringExpressionSet intersectCreate = this.m_create == null ? null : this.m_create.Intersect( operand.m_create );
            
            if ((intersectRead == null || intersectRead.IsEmpty()) &&
                (intersectWrite == null || intersectWrite.IsEmpty()) &&
                (intersectCreate == null || intersectCreate.IsEmpty()))
            {
                return null;
            }
            
            RegistryPermission intersectPermission = new RegistryPermission(PermissionState.None);
            intersectPermission.m_unrestricted = false;
            intersectPermission.m_read = intersectRead;
            intersectPermission.m_write = intersectWrite;
            intersectPermission.m_create = intersectCreate;
            
            return intersectPermission;
        }
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.Union"]/*' />
        public override IPermission Union(IPermission other)
        {
            if (other == null)
            {
                return this.Copy();
            }
            else if (!VerifyType(other))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            RegistryPermission operand = (RegistryPermission)other;
            
            if (this.IsUnrestricted() || operand.IsUnrestricted())
            {
                return new RegistryPermission( PermissionState.Unrestricted );
            }
    
            StringExpressionSet unionRead = this.m_read == null ? operand.m_read : this.m_read.Union( operand.m_read );
            StringExpressionSet unionWrite = this.m_write == null ? operand.m_write : this.m_write.Union( operand.m_write );
            StringExpressionSet unionCreate = this.m_create == null ? operand.m_create : this.m_create.Union( operand.m_create );
            
            if ((unionRead == null || unionRead.IsEmpty()) &&
                (unionWrite == null || unionWrite.IsEmpty()) &&
                (unionCreate == null || unionCreate.IsEmpty()))
            {
                return null;
            }
            
            RegistryPermission unionPermission = new RegistryPermission(PermissionState.None);
            unionPermission.m_unrestricted = false;
            unionPermission.m_read = unionRead;
            unionPermission.m_write = unionWrite;
            unionPermission.m_create = unionCreate;
            
            return unionPermission;
        }
            
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            RegistryPermission copy = new RegistryPermission(PermissionState.None);
            if (this.m_unrestricted)
            {
                copy.m_unrestricted = true;
            }
            else
            {
                copy.m_unrestricted = false;
                if (this.m_read != null)
                {
                    copy.m_read = this.m_read.Copy();
                }
                if (this.m_write != null)
                {
                    copy.m_write = this.m_write.Copy();
                }
                if (this.m_create != null)
                {
                    copy.m_create = this.m_create.Copy();
                }
            }
            return copy;   
        }
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (!IsUnrestricted())
            {
                if (this.m_read != null && !this.m_read.IsEmpty())
                {
                    esd.AddAttribute( "Read", SecurityElement.Escape( m_read.ToString() ) );
                }
                if (this.m_write != null && !this.m_write.IsEmpty())
                {
                    esd.AddAttribute( "Write", SecurityElement.Escape( m_write.ToString() ) );
                }
                if (this.m_create != null && !this.m_create.IsEmpty())
                {
                    esd.AddAttribute( "Create", SecurityElement.Escape( m_create.ToString() ) );
                }
            }
            else
            {
                esd.AddAttribute( "Unrestricted", "true" );
            }
            return esd;
        }
        
        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            String et;
            
            if (XMLUtil.IsUnrestricted( esd ))
            {
                m_unrestricted = true;
                return;
            }
            
            
            m_unrestricted = false;
            
            et = esd.Attribute( "Read" );
            if (et != null)
            {
                m_read = new StringExpressionSet( et );
            }
            
            et = esd.Attribute( "Write" );
            if (et != null)
            {
                m_write = new StringExpressionSet( et );
            }
    
            et = esd.Attribute( "Create" );
            if (et != null)
            {
                m_create = new StringExpressionSet( et );
            }
            
        }

        /// <include file='doc\RegistryPermission.uex' path='docs/doc[@for="RegistryPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return RegistryPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.RegistryPermissionIndex;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\securitypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// SecurityPermission.cool
//

namespace System.Security.Permissions
{
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Text;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Security;
    using System.Runtime.Serialization;
    using System.Reflection;

    /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag"]/*' />
    [Flags, Serializable]
    public enum SecurityPermissionFlag
    {
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.NoFlags"]/*' />
        NoFlags = 0x00,
        /* The following enum value is used in the EE (ASSERT_PERMISSION in security.cpp)
         * Should this value change, make corresponding changes there
         */ 
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.Assertion"]/*' />
        Assertion = 0x01,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.UnmanagedCode"]/*' />
        UnmanagedCode = 0x02,       // Update vm\Security.h if you change this !
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.SkipVerification"]/*' />
        SkipVerification = 0x04,    // Update vm\Security.h if you change this !
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.Execution"]/*' />
        Execution = 0x08,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.ControlThread"]/*' />
        ControlThread = 0x10,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.ControlEvidence"]/*' />
        ControlEvidence = 0x20,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.ControlPolicy"]/*' />
        ControlPolicy = 0x40,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.SerializationFormatter"]/*' />
        SerializationFormatter = 0x80,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.ControlDomainPolicy"]/*' />
        ControlDomainPolicy = 0x100,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.ControlPrincipal"]/*' />
        ControlPrincipal = 0x200,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.ControlAppDomain"]/*' />
        ControlAppDomain = 0x400,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.RemotingConfiguration"]/*' />
        RemotingConfiguration = 0x800,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.Infrastructure"]/*' />
        Infrastructure = 0x1000,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.BindingRedirects"]/*' />
        BindingRedirects = 0x2000,
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermissionFlag.AllFlags"]/*' />
        AllFlags = 0x3fff,
    }

    /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission"]/*' />
    [Serializable()] sealed public class SecurityPermission 
           : CodeAccessPermission, IUnrestrictedPermission, IBuiltInPermission
    {
        private SecurityPermissionFlag m_flags;
        
        //
        // Public Constructors
        //
    
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.SecurityPermission"]/*' />
        public SecurityPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                SetUnrestricted( true );
            }
            else if (state == PermissionState.None)
            {
                SetUnrestricted( false );
                Reset();
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        
        // SecurityPermission
        //
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.SecurityPermission1"]/*' />
        public SecurityPermission(SecurityPermissionFlag flag)
        {
            VerifyAccess(flag);
            
            SetUnrestricted(false);
            m_flags = flag;
        }
    
    
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED MODIFIERS 
        //
        //------------------------------------------------------
        
        
        private void SetUnrestricted(bool unrestricted)
        {
            if (unrestricted)
            {
                m_flags = SecurityPermissionFlag.AllFlags;
            }
        }
    
        private void Reset()
        {
            m_flags = SecurityPermissionFlag.NoFlags;
        }
        
        
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.Flags"]/*' />
        public SecurityPermissionFlag Flags
        {
            set
            {
                VerifyAccess(value);
            
                m_flags = value;
            }
            
            get
            {
                return m_flags;
            }
        }
        
        //
        // CodeAccessPermission methods
        // 
        
        /*
         * IPermission interface implementation
         */
         
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return m_flags == 0;
            }
        
            try
            {
                SecurityPermission operand = (SecurityPermission)target;
                if (operand.IsUnrestricted())
                    return true;
                else if (this.IsUnrestricted())
                    return false;
                else
                    return (((int)this.m_flags) & ~((int)operand.m_flags)) == 0;
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }

        }
        
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.Union"]/*' />
        public override IPermission Union(IPermission target) {
            if (target == null) return(this.Copy());
            if (!VerifyType(target)) {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            SecurityPermission sp_target = (SecurityPermission) target;
            if (sp_target.IsUnrestricted() || IsUnrestricted()) {
                return(new SecurityPermission(PermissionState.Unrestricted));
            }
            SecurityPermissionFlag flag_union = (SecurityPermissionFlag)(m_flags | sp_target.m_flags);
            return(new SecurityPermission(flag_union));
        }
    
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
                return null;
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            SecurityPermission operand = (SecurityPermission)target;
            SecurityPermissionFlag isectFlags = SecurityPermissionFlag.NoFlags;
           
            if (operand.IsUnrestricted())
            {
                if (this.IsUnrestricted())
                    return new SecurityPermission(PermissionState.Unrestricted);
                else
                    isectFlags = (SecurityPermissionFlag)this.m_flags;
            }
            else if (this.IsUnrestricted())
            {
                isectFlags = (SecurityPermissionFlag)operand.m_flags;
            }
            else
            {
                isectFlags = (SecurityPermissionFlag)m_flags & (SecurityPermissionFlag)operand.m_flags;
            }
            
            if (isectFlags == 0)
                return null;
            else
                return new SecurityPermission(isectFlags);
        }
    
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            if (IsUnrestricted())
                return new SecurityPermission(PermissionState.Unrestricted);
            else
                return new SecurityPermission((SecurityPermissionFlag)m_flags);
        }
    
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            return m_flags == SecurityPermissionFlag.AllFlags;
        }
        
        //
        // IEncodable Interface 
        private
        void setFlag(SecurityPermissionFlag nFlag, bool fAllow)
        {
            if (fAllow)
            {
                m_flags = m_flags | nFlag;
            }
            else
            {
                m_flags = m_flags & ~nFlag;
            }
        }
    
        private
        void VerifyAccess(SecurityPermissionFlag type)
        {
            if ((type & ~SecurityPermissionFlag.AllFlags) != 0)
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)type));
        }
        
        private
        void VerifySingleFlag(SecurityPermissionFlag type)
        {
            // This little piece of magic checks to make sure EXACTLY ONE bit is set.
            // Note: The result of X & (X-1) is the equivalent of zeroing the least significant
            // set bit (i.e.  if X = 0x0F10, than X & (X-1) = 0x0F00).
            if (type == (SecurityPermissionFlag) 0 || ((int)type & ((int)type - 1)) != 0)
            {
                throw new ArgumentException( Environment.GetResourceString("Arg_EnumNotSingleFlag") ); 
            }
        }
    
    
        //------------------------------------------------------
        //
        // PUBLIC ENCODING METHODS
        //
        //------------------------------------------------------
        
        private const String _strHeaderAssertion  = "Assertion";
        private const String _strHeaderUnmanagedCode = "UnmanagedCode";
        private const String _strHeaderExecution = "Execution";
        private const String _strHeaderSkipVerification = "SkipVerification";
        private const String _strHeaderControlThread = "ControlThread";
        private const String _strHeaderControlEvidence = "ControlEvidence";
        private const String _strHeaderControlPolicy = "ControlPolicy";
        private const String _strHeaderSerializationFormatter = "SerializationFormatter";
        private const String _strHeaderControlDomainPolicy = "ControlDomainPolicy";
        private const String _strHeaderControlPrincipal = "ControlPrincipal";
        private const String _strHeaderControlAppDomain = "ControlAppDomain";
    
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (!IsUnrestricted())
            {
                esd.AddAttribute( "Flags", XMLUtil.BitFieldEnumToString( typeof( SecurityPermissionFlag ), m_flags ) );
            }
            else
            {
                esd.AddAttribute( "Unrestricted", "true" );
            }
            return esd;
        }
    
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            if (XMLUtil.IsUnrestricted( esd ))
            {
                m_flags = SecurityPermissionFlag.AllFlags;
                return;
            }
           
            Reset () ;
            SetUnrestricted (false) ;
    
            String flags = esd.Attribute( "Flags" );
    
            if (flags != null)
                m_flags = (SecurityPermissionFlag)Enum.Parse( typeof( SecurityPermissionFlag ), flags );
        }
       
        //
        // Object Overrides
        //
        
    #if ZERO   // Do not remove this code, usefull for debugging
        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.ToString"]/*' />
        public override String ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("SecurityPermission(");
            if (IsUnrestricted())
            {
                sb.Append("Unrestricted");
            }
            else
            {
                if (GetFlag(SecurityPermissionFlag.Assertion))
                    sb.Append("Assertion; ");
                if (GetFlag(SecurityPermissionFlag.UnmanagedCode))
                    sb.Append("UnmangedCode; ");
                if (GetFlag(SecurityPermissionFlag.SkipVerification))
                    sb.Append("SkipVerification; ");
                if (GetFlag(SecurityPermissionFlag.Execution))
                    sb.Append("Execution; ");
                if (GetFlag(SecurityPermissionFlag.ControlThread))
                    sb.Append("ControlThread; ");
                if (GetFlag(SecurityPermissionFlag.ControlEvidence))
                    sb.Append("ControlEvidence; ");
                if (GetFlag(SecurityPermissionFlag.ControlPolicy))
                    sb.Append("ControlPolicy; ");
                if (GetFlag(SecurityPermissionFlag.SerializationFormatter))
                    sb.Append("SerializationFormatter; ");
                if (GetFlag(SecurityPermissionFlag.ControlDomainPolicy))
                    sb.Append("ControlDomainPolicy; ");
                if (GetFlag(SecurityPermissionFlag.ControlPrincipal))
                    sb.Append("ControlPrincipal; ");
            }
            
            sb.Append(")");
            return sb.ToString();
        }
    #endif

        /// <include file='doc\SecurityPermission.uex' path='docs/doc[@for="SecurityPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return SecurityPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.SecurityPermissionIndex;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\permissionattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security.Permissions
{

    //using System.Attributes;
    using System.Security.Util;
    using System.IO;
    using System.Security.Policy;
    using System.Runtime.Remoting.Activation;
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Security.Cryptography.X509Certificates;
    
    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction"]/*' />
	[Serializable]
    public enum SecurityAction
    {
        // Demand permission of all caller
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.Demand"]/*' />
        Demand = 2,

        // Assert permission so callers don't need
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.Assert"]/*' />
        Assert = 3,

        // Deny permissions so checks will fail
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.Deny"]/*' />
        Deny = 4,

        // Reduce permissions so check will fail
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.PermitOnly"]/*' />
        PermitOnly = 5,

        // Demand permission of caller
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.LinkDemand"]/*' />
        LinkDemand = 6,
    
        // Demand permission of a subclass
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.InheritanceDemand"]/*' />
        InheritanceDemand = 7,

        // Request minimum permissions to run
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.RequestMinimum"]/*' />
        RequestMinimum = 8,

        // Request optional additional permissions
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.RequestOptional"]/*' />
        RequestOptional = 9,

        // Refuse to be granted these permissions
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAction.RequestRefuse"]/*' />
        RequestRefuse = 10

    }


    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAttribute"]/*' />
    [Serializable(), AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    public abstract class SecurityAttribute : System.Attribute
    {
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAttribute.m_action"]/*' />
        /// <internalonly/>
        internal SecurityAction m_action;
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAttribute.m_unrestricted"]/*' />
        /// <internalonly/>
        internal bool m_unrestricted;

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAttribute.SecurityAttribute"]/*' />
        public SecurityAttribute( SecurityAction action ) 
        {
            m_action = action;
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAttribute.Action"]/*' />
        public SecurityAction Action
        {
            get { return m_action; }
            set { m_action = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAttribute.Unrestricted"]/*' />
        public bool Unrestricted
        {
            get { return m_unrestricted; }
            set { m_unrestricted = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityAttribute.CreatePermission"]/*' />
        abstract public IPermission CreatePermission();
    }
    
    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="CodeAccessSecurityAttribute"]/*' />
    [Serializable(), AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    public abstract class CodeAccessSecurityAttribute : SecurityAttribute
    {
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="CodeAccessSecurityAttribute.CodeAccessSecurityAttribute"]/*' />
        public CodeAccessSecurityAttribute( SecurityAction action )
            : base( action )
        {
        }
    }
    
    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="EnvironmentPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class EnvironmentPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_read = null;
        private String m_write = null;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="EnvironmentPermissionAttribute.EnvironmentPermissionAttribute"]/*' />
        public EnvironmentPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="EnvironmentPermissionAttribute.Read"]/*' />
        public String Read {
            get { return m_read; }
            set { m_read = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="EnvironmentPermissionAttribute.Write"]/*' />
        public String Write {
            get { return m_write; }
            set { m_write = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="EnvironmentPermissionAttribute.All"]/*' />
        public String All {
            set { m_write = value; m_read = value; }
            get { throw new NotSupportedException( Environment.GetResourceString( "NotSupported_GetMethod" ) ); }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="EnvironmentPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new EnvironmentPermission(PermissionState.Unrestricted);
            }
            else
            {
                EnvironmentPermission perm = new EnvironmentPermission(PermissionState.None);
                if (m_read != null)
                    perm.SetPathList( EnvironmentPermissionAccess.Read, m_read );
                if (m_write != null)
                    perm.SetPathList( EnvironmentPermissionAccess.Write, m_write );
                return perm;
            }
        }
    }


    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileDialogPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class FileDialogPermissionAttribute : CodeAccessSecurityAttribute
    {
        private FileDialogPermissionAccess m_access;

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileDialogPermissionAttribute.FileDialogPermissionAttribute"]/*' />
        public FileDialogPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileDialogPermissionAttribute.Open"]/*' />
        public bool Open
        {
            get { return (m_access & FileDialogPermissionAccess.Open) != 0; }
            set { m_access = value ? m_access | FileDialogPermissionAccess.Open : m_access & ~FileDialogPermissionAccess.Open; }
        }
            
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileDialogPermissionAttribute.Save"]/*' />
        public bool Save
        {
            get { return (m_access & FileDialogPermissionAccess.Save) != 0; }
            set { m_access = value ? m_access | FileDialogPermissionAccess.Save : m_access & ~FileDialogPermissionAccess.Save; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileDialogPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new FileDialogPermission( PermissionState.Unrestricted );
            }
            else
            {
                return new FileDialogPermission( m_access );
            }
        }
    }


    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class FileIOPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_read = null;
        private String m_write = null;
        private String m_append = null;
        private String m_pathDiscovery = null;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute.FileIOPermissionAttribute"]/*' />
        public FileIOPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute.Read"]/*' />
        public String Read {
            get { return m_read; }
            set { m_read = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute.Write"]/*' />
        public String Write {
            get { return m_write; }
            set { m_write = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute.Append"]/*' />
        public String Append {
            get { return m_append; }
            set { m_append = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute.PathDiscovery"]/*' />
        public String PathDiscovery {
            get { return m_pathDiscovery; }
            set { m_pathDiscovery = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute.All"]/*' />
        public String All {
            set { m_read = value; m_write = value; m_append = value; m_pathDiscovery = value; }
            get { throw new NotSupportedException( Environment.GetResourceString( "NotSupported_GetMethod" ) ); }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="FileIOPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new FileIOPermission(PermissionState.Unrestricted);
            }
            else
            {
                FileIOPermission perm = new FileIOPermission(PermissionState.None);
                if (m_read != null)
                    perm.SetPathList( FileIOPermissionAccess.Read, m_read );
                if (m_write != null)
                    perm.SetPathList( FileIOPermissionAccess.Write, m_write );
                if (m_append != null)
                    perm.SetPathList( FileIOPermissionAccess.Append, m_append );
                if (m_pathDiscovery != null)
                    perm.SetPathList( FileIOPermissionAccess.PathDiscovery, m_pathDiscovery );
                return perm;
            }
        }
    }

    // Note: PrincipalPermissionAttribute currently derives from
    // CodeAccessSecurityAttribute, even though it's not related to code access
    // security. This is because compilers are currently looking for
    // CodeAccessSecurityAttribute as a direct parent class rather than
    // SecurityAttribute as the root class.
    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PrincipalPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class PrincipalPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_name = null;
        private String m_role = null;
        private bool m_authenticated = true;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PrincipalPermissionAttribute.PrincipalPermissionAttribute"]/*' />
        public PrincipalPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PrincipalPermissionAttribute.Name"]/*' />
        public String Name
        {
            get { return m_name; }
            set { m_name = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PrincipalPermissionAttribute.Role"]/*' />
        public String Role
        {
            get { return m_role; }
            set { m_role = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PrincipalPermissionAttribute.Authenticated"]/*' />
        public bool Authenticated
        {
            get { return m_authenticated; }
            set { m_authenticated = value; }
        }
        
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PrincipalPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new PrincipalPermission( PermissionState.Unrestricted );
            }
            else
            {
                return new PrincipalPermission( m_name, m_role, m_authenticated );
            }
        }
    }
                


    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ReflectionPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class ReflectionPermissionAttribute : CodeAccessSecurityAttribute
    {
        private ReflectionPermissionFlag m_flag = ReflectionPermissionFlag.NoFlags;

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ReflectionPermissionAttribute.ReflectionPermissionAttribute"]/*' />
        public ReflectionPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ReflectionPermissionAttribute.Flags"]/*' />
        public ReflectionPermissionFlag Flags {
            get { return m_flag; }
            set { m_flag = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ReflectionPermissionAttribute.TypeInformation"]/*' />
        public bool TypeInformation {
            get { return (m_flag & ReflectionPermissionFlag.TypeInformation) != 0; }
            set { m_flag = value ? m_flag | ReflectionPermissionFlag.TypeInformation : m_flag & ~ReflectionPermissionFlag.TypeInformation; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ReflectionPermissionAttribute.MemberAccess"]/*' />
        public bool MemberAccess {
            get { return (m_flag & ReflectionPermissionFlag.MemberAccess) != 0; }
            set { m_flag = value ? m_flag | ReflectionPermissionFlag.MemberAccess : m_flag & ~ReflectionPermissionFlag.MemberAccess; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ReflectionPermissionAttribute.ReflectionEmit"]/*' />
        public bool ReflectionEmit {
            get { return (m_flag & ReflectionPermissionFlag.ReflectionEmit) != 0; }
            set { m_flag = value ? m_flag | ReflectionPermissionFlag.ReflectionEmit : m_flag & ~ReflectionPermissionFlag.ReflectionEmit; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ReflectionPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new ReflectionPermission( PermissionState.Unrestricted );
            }
            else
            {
                return new ReflectionPermission( m_flag );
            }
        }
    }

   
    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="RegistryPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class RegistryPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_read = null;
        private String m_write = null;
        private String m_create = null;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="RegistryPermissionAttribute.RegistryPermissionAttribute"]/*' />
        public RegistryPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="RegistryPermissionAttribute.Read"]/*' />
        public String Read {
            get { return m_read; }
            set { m_read = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="RegistryPermissionAttribute.Write"]/*' />
        public String Write {
            get { return m_write; }
            set { m_write = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="RegistryPermissionAttribute.Create"]/*' />
        public String Create {
            get { return m_create; }
            set { m_create = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="RegistryPermissionAttribute.All"]/*' />
        public String All {
            set { m_read = value; m_write = value; m_create = value; }
            get { throw new NotSupportedException( Environment.GetResourceString( "NotSupported_GetMethod" ) ); }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="RegistryPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new RegistryPermission( PermissionState.Unrestricted );
            }
            else
            {
                RegistryPermission perm = new RegistryPermission(PermissionState.None);
                if (m_read != null)
                    perm.SetPathList( RegistryPermissionAccess.Read, m_read );
                if (m_write != null)
                    perm.SetPathList( RegistryPermissionAccess.Write, m_write );
                if (m_create != null)
                    perm.SetPathList( RegistryPermissionAccess.Create, m_create );
                return perm;
            }
        }
    }


    
    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class SecurityPermissionAttribute : CodeAccessSecurityAttribute
    {
        private SecurityPermissionFlag m_flag = SecurityPermissionFlag.NoFlags;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.SecurityPermissionAttribute"]/*' />
        public SecurityPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.Flags"]/*' />
        public SecurityPermissionFlag Flags {
            get { return m_flag; }
            set { m_flag = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.Assertion"]/*' />
        public bool Assertion {
            get { return (m_flag & SecurityPermissionFlag.Assertion) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.Assertion : m_flag & ~SecurityPermissionFlag.Assertion; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.UnmanagedCode"]/*' />
        public bool UnmanagedCode {
            get { return (m_flag & SecurityPermissionFlag.UnmanagedCode) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.UnmanagedCode : m_flag & ~SecurityPermissionFlag.UnmanagedCode; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.Execution"]/*' />
        public bool Execution {
            get { return (m_flag & SecurityPermissionFlag.Execution) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.Execution : m_flag & ~SecurityPermissionFlag.Execution; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.SkipVerification"]/*' />
        public bool SkipVerification {
            get { return (m_flag & SecurityPermissionFlag.SkipVerification) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.SkipVerification : m_flag & ~SecurityPermissionFlag.SkipVerification; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.ControlThread"]/*' />
        public bool ControlThread {
            get { return (m_flag & SecurityPermissionFlag.ControlThread) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.ControlThread : m_flag & ~SecurityPermissionFlag.ControlThread; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.ControlEvidence"]/*' />
        public bool ControlEvidence {
            get { return (m_flag & SecurityPermissionFlag.ControlEvidence) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.ControlEvidence : m_flag & ~SecurityPermissionFlag.ControlEvidence; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.ControlPolicy"]/*' />
        public bool ControlPolicy {
            get { return (m_flag & SecurityPermissionFlag.ControlPolicy) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.ControlPolicy : m_flag & ~SecurityPermissionFlag.ControlPolicy; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.ControlDomainPolicy"]/*' />
        public bool ControlDomainPolicy {
            get { return (m_flag & SecurityPermissionFlag.ControlDomainPolicy) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.ControlDomainPolicy : m_flag & ~SecurityPermissionFlag.ControlDomainPolicy; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.ControlPrincipal"]/*' />
        public bool ControlPrincipal {
            get { return (m_flag & SecurityPermissionFlag.ControlPrincipal) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.ControlPrincipal : m_flag & ~SecurityPermissionFlag.ControlPrincipal; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.ControlAppDomain"]/*' />
        public bool ControlAppDomain {
            get { return (m_flag & SecurityPermissionFlag.ControlAppDomain) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.ControlAppDomain : m_flag & ~SecurityPermissionFlag.ControlAppDomain; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.SerializationFormatter"]/*' />
        public bool SerializationFormatter {
            get { return (m_flag & SecurityPermissionFlag.SerializationFormatter) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.SerializationFormatter : m_flag & ~SecurityPermissionFlag.SerializationFormatter; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.RemotingConfiguration"]/*' />
        public bool RemotingConfiguration {
            get { return (m_flag & SecurityPermissionFlag.RemotingConfiguration) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.RemotingConfiguration : m_flag & ~SecurityPermissionFlag.RemotingConfiguration; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.Infrastructure"]/*' />
        public bool Infrastructure {
            get { return (m_flag & SecurityPermissionFlag.Infrastructure) != 0; }
            set { m_flag = value ? m_flag | SecurityPermissionFlag.Infrastructure : m_flag & ~SecurityPermissionFlag.Infrastructure; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SecurityPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new SecurityPermission( PermissionState.Unrestricted );
            }
            else
            {
                return new SecurityPermission( m_flag );
            }
        }
    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UIPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class UIPermissionAttribute : CodeAccessSecurityAttribute
    {
        private UIPermissionWindow m_windowFlag = UIPermissionWindow.NoWindows;
        private UIPermissionClipboard m_clipboardFlag = UIPermissionClipboard.NoClipboard;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UIPermissionAttribute.UIPermissionAttribute"]/*' />
        public UIPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UIPermissionAttribute.Window"]/*' />
        public UIPermissionWindow Window {
            get { return m_windowFlag; }
            set { m_windowFlag = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UIPermissionAttribute.Clipboard"]/*' />
        public UIPermissionClipboard Clipboard {
            get { return m_clipboardFlag; }
            set { m_clipboardFlag = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UIPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                return new UIPermission( PermissionState.Unrestricted );
            }
            else
            {
                return new UIPermission( m_windowFlag, m_clipboardFlag );
            }
        }
    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ZoneIdentityPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute
    {
        private SecurityZone m_flag = SecurityZone.NoZone;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ZoneIdentityPermissionAttribute.ZoneIdentityPermissionAttribute"]/*' />
        public ZoneIdentityPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ZoneIdentityPermissionAttribute.Zone"]/*' />
        public SecurityZone Zone {
            get { return m_flag; }
            set { m_flag = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="ZoneIdentityPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else
            {
                return new ZoneIdentityPermission( m_flag );
            }
        }
    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="StrongNameIdentityPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_name = null;
        private String m_version = null;
        private String m_blob = null;

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="StrongNameIdentityPermissionAttribute.StrongNameIdentityPermissionAttribute"]/*' />
        public StrongNameIdentityPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="StrongNameIdentityPermissionAttribute.Name"]/*' />
        public String Name
        {
            get { return m_name; }
            set { m_name = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="StrongNameIdentityPermissionAttribute.Version"]/*' />
        public String Version
        {
            get { return m_version; }
            set { m_version = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="StrongNameIdentityPermissionAttribute.PublicKey"]/*' />
        public String PublicKey
        {
            get { return m_blob; }
            set { m_blob = value; }
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="StrongNameIdentityPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else
            {
                if (m_blob == null && m_name == null && m_version == null)
                    return new StrongNameIdentityPermission( PermissionState.None );
            
                if (m_blob == null)
                    throw new ArgumentException( Environment.GetResourceString("ArgumentNull_Key"));
                    
                StrongNamePublicKeyBlob blob = new StrongNamePublicKeyBlob( Hex.DecodeHexString( m_blob ) );
                
                if (m_version == null || m_version.Equals(String.Empty))
                    return new StrongNameIdentityPermission( blob, m_name, null );
                else	
                    return new StrongNameIdentityPermission( blob, m_name, new Version( m_version ) );
            }
        }
    }


    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SiteIdentityPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_site = null;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SiteIdentityPermissionAttribute.SiteIdentityPermissionAttribute"]/*' />
        public SiteIdentityPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SiteIdentityPermissionAttribute.Site"]/*' />
        public String Site {
            get { return m_site; }
            set { m_site = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="SiteIdentityPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else
            {
                if (m_site == null)
                    return new SiteIdentityPermission( PermissionState.None );
            
                return new SiteIdentityPermission( m_site );
            }
        }
    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UrlIdentityPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable] sealed public class UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_url = null;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UrlIdentityPermissionAttribute.UrlIdentityPermissionAttribute"]/*' />
        public UrlIdentityPermissionAttribute( SecurityAction action )
            : base( action )
        {
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UrlIdentityPermissionAttribute.Url"]/*' />
        public String Url {
            get { return m_url; }
            set { m_url = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="UrlIdentityPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else
            {
                if (m_url == null)
                    return new UrlIdentityPermission( PermissionState.None );
                    
                return new UrlIdentityPermission( m_url );
            }
        }
    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PublisherIdentityPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute
    {
        private String m_x509cert = null;
        private String m_certFile = null;
        private String m_signedFile = null;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PublisherIdentityPermissionAttribute.PublisherIdentityPermissionAttribute"]/*' />
        public PublisherIdentityPermissionAttribute( SecurityAction action )
            : base( action )
        {
            m_x509cert = null;
            m_certFile = null;
            m_signedFile = null;
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PublisherIdentityPermissionAttribute.X509Certificate"]/*' />
        public String X509Certificate {
            get { return m_x509cert; }
            set { m_x509cert = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PublisherIdentityPermissionAttribute.CertFile"]/*' />
        public String CertFile {
            get { return m_certFile; }
            set { m_certFile = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PublisherIdentityPermissionAttribute.SignedFile"]/*' />
        public String SignedFile {
            get { return m_signedFile; }
            set { m_signedFile = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PublisherIdentityPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (m_unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else
            {
                if (m_x509cert != null)
                {
                    return new PublisherIdentityPermission( new X509Certificate( System.Security.Util.Hex.DecodeHexString( m_x509cert ) ) );
                }
                else if (m_certFile != null)
                {
                    return new PublisherIdentityPermission( System.Security.Cryptography.X509Certificates.X509Certificate.CreateFromCertFile( m_certFile ) );
                }
                else if (m_signedFile != null)
                {
                    return new PublisherIdentityPermission( System.Security.Cryptography.X509Certificates.X509Certificate.CreateFromSignedFile( m_signedFile ) );
                }
                else
                {
                    return new PublisherIdentityPermission( PermissionState.None );
                }
            }
        }
    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute"]/*' />
    [Serializable(), AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor
     | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly,
    AllowMultiple=true, Inherited=false)]
    public abstract class IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute
    {
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.m_userQuota"]/*' />
        /// <internalonly/>
        internal long m_userQuota;
#if FALSE
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.m_machineQuota"]/*' />
        /// <internalonly/>
        internal long m_machineQuota;
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.m_expirationDays"]/*' />
        /// <internalonly/>
        internal long m_expirationDays;
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.m_permanentData"]/*' />
        /// <internalonly/>
        internal bool m_permanentData;
#endif
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.m_allowed"]/*' />
        /// <internalonly/>
        internal IsolatedStorageContainment m_allowed;
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.IsolatedStoragePermissionAttribute"]/*' />
        public IsolatedStoragePermissionAttribute(SecurityAction action) : base(action)
        {
        }

        // properties
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.UserQuota"]/*' />
        public long UserQuota {
            set{
                m_userQuota = value;
            }
            get{
                return m_userQuota;
            }
        }
#if FALSE
        internal long MachineQuota {
            set{
                m_machineQuota = value;
            }
            get{
                return m_machineQuota;
            }
        }
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.ExpirationDays"]/*' />
        internal long ExpirationDays {
            set{
                m_expirationDays = value;
            }
            get{
                return m_expirationDays;
            }
        }
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.PermanentData"]/*' />
        internal bool PermanentData {
            set{
                m_permanentData = value;
            }
            get{
                return m_permanentData;
            }
        }
#endif
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStoragePermissionAttribute.UsageAllowed"]/*' />
        public IsolatedStorageContainment UsageAllowed {
            set{
                m_allowed = value;
            }
            get{
                return m_allowed;
            }
        }

    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStorageFilePermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor
     | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly,
    AllowMultiple=true, Inherited=false)]
    [Serializable()] sealed public class IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute
    {
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStorageFilePermissionAttribute.IsolatedStorageFilePermissionAttribute"]/*' />
        public IsolatedStorageFilePermissionAttribute(SecurityAction action) : base(action)
        {

        }
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="IsolatedStorageFilePermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            IsolatedStorageFilePermission p;
            if (m_unrestricted) {
                p = new IsolatedStorageFilePermission
                        (PermissionState.Unrestricted);
            } else {
                p = new IsolatedStorageFilePermission(PermissionState.None);
                p.UserQuota      = m_userQuota;
                p.UsageAllowed   = m_allowed;
#if FALSE
                p.PermanentData  = m_permanentData;
                p.MachineQuota   = m_machineQuota;
                p.ExpirationDays = m_expirationDays;
#endif
            }
            return p;
        }
    }

    /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class PermissionSetAttribute : CodeAccessSecurityAttribute
    {
        private String m_file;
        private String m_name;
        private bool m_unicode;
        private String m_xml;
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute.PermissionSetAttribute"]/*' />
        public PermissionSetAttribute( SecurityAction action )
            : base( action )
        {
            m_unicode = false;
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute.File"]/*' />
        public String File {
            get { return m_file; }
            set { m_file = value; }
        }
    
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute.UnicodeEncoded"]/*' />
        public bool UnicodeEncoded {
            get { return m_unicode; }
            set { m_unicode = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute.Name"]/*' />
        public String Name {
            get { return m_name; }
            set { m_name = value; }
        }
        
        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute.XML"]/*' />
        public String XML {
            get { return m_xml; }
            set { m_xml = value; }
        }       

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            return null;
        }

        /// <include file='doc\PermissionAttributes.uex' path='docs/doc[@for="PermissionSetAttribute.CreatePermissionSet"]/*' />
        public PermissionSet CreatePermissionSet()
        {
            if (m_unrestricted)
            {
                return new PermissionSet( PermissionState.Unrestricted );
            }
            if (m_name != null)
            {
                return PolicyLevel.GetBuiltInSet( m_name );
            }
            else if (m_file != null || m_xml != null)
            {
                Parser parser = null;
                
                if (m_file != null)
                {
                    Encoding[] encodings = new Encoding[] { null, Encoding.UTF8, Encoding.ASCII, Encoding.Unicode };

                    bool success = false;
                    Exception exception = null;
                    FileStream f = new FileStream( m_file, FileMode.Open, FileAccess.Read );

                    for (int i = 0; !success && i < encodings.Length; ++i)
                    {

                        try
                        {
                            f.Position = 0;

                            StreamReader reader;
                            if (encodings[i] != null)
                                reader = new StreamReader( f, encodings[i] );
                            else
                                reader = new StreamReader( f );

                            parser = new Parser( reader );
                            success = true;
                        }
                        catch (Exception e1)
                        {
                            if (exception == null)
                                exception = e1;
                        }
                    }

                    if (!success && exception != null)
                        throw exception;
                }
                else
                {
                    // Since we have a unicode string, we have to copy the bytes
                    // into a byte array and create a data reader.
                   
                    parser = new Parser( m_xml.ToCharArray() );
                }
            
                SecurityElement e = parser.GetTopElement();

                // Note: we can just assume this is a regular permission set because
                // the name and description are not used in declarative security.

                PermissionSet permSet = new PermissionSet( PermissionState.None );

                permSet.FromXml( e );

                return permSet;
            }
            else
            {
                return new PermissionSet( PermissionState.None );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\siteidentitypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// SiteIdentityPermission.cool
// 
// author: gregfee
// 

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using SiteString = System.Security.Util.SiteString;
    
    
    /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission"]/*' />
    [Serializable()] sealed public class SiteIdentityPermission : CodeAccessPermission, IBuiltInPermission
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private SiteString m_site;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
        
       
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.SiteIdentityPermission"]/*' />
        public SiteIdentityPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else if (state == PermissionState.None)
            {
                m_site = null;
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.SiteIdentityPermission1"]/*' />
        public SiteIdentityPermission( String site )
        {
            m_site = new SiteString( site );
        }
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
        
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.Site"]/*' />
        public String Site
        {
            set
            {
                m_site = new SiteString( value );
            }
            
            get
            {
                return m_site.ToString();
            }
        } 
        
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED HELPERS FOR ACCESSORS AND CONSTRUCTORS
        //
        //------------------------------------------------------
    
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            if (m_site == null)
            {
                return new SiteIdentityPermission( PermissionState.None );
            }
            else
            {
                return new SiteIdentityPermission( m_site.ToString() );
            }
        }
        
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.m_site == null;
            }
            
            try
            {
                if (this.m_site == null)
                {
                    return true;
                }
            
                return this.m_site.IsSubsetOf(((SiteIdentityPermission)target).m_site);
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
        }
        
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null || this.m_site == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            SiteString intersectString = this.m_site.Intersect(((SiteIdentityPermission)target).m_site);
            
            if (intersectString == null)
            {
                return null;
            }
            else
            {
                return new SiteIdentityPermission(intersectString.ToString());
            }
        }
        
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.Union"]/*' />
        public override IPermission Union(IPermission target)
        {
            if (target == null)
            {
                return this.m_site != null ? this.Copy() : null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            SiteIdentityPermission operand = (SiteIdentityPermission)target;
            
            if (this.m_site == null || this.m_site.IsSubsetOf( operand.m_site ))
            {
                return operand.Copy();
            }
            else if (operand.m_site == null || operand.m_site.IsSubsetOf( this.m_site ))
            {
                return this.Copy();
            }
            else
            {
                return null;
            }
        }
               
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            String elem = esd.Attribute( "Site" );
            m_site = elem == null ? null : new SiteString( elem );
            
        }
        
        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (m_site != null)
                esd.AddAttribute( "Site", m_site.ToString() );
            return esd;
        }

        /// <include file='doc\SiteIdentityPermission.uex' path='docs/doc[@for="SiteIdentityPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return SiteIdentityPermission.GetTokenIndex();
        }
        
        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.SiteIdentityPermissionIndex;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\strongnameidentitypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// StrongNameIdentityPermission.cool
// 
// author: gregfee
// 

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Util;
    using System.IO;
    using String = System.String;
    using Version = System.Version;
    using System.Security.Policy;

    /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission"]/*' />
    [Serializable()] sealed public class StrongNameIdentityPermission : CodeAccessPermission, IBuiltInPermission
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private StrongNamePublicKeyBlob m_publicKeyBlob;
        private String m_name;
        private Version m_version;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
        
       
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.StrongNameIdentityPermission"]/*' />
        public StrongNameIdentityPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else if (state == PermissionState.None)
            {
                m_publicKeyBlob = null;
                m_name = "";
                m_version = new Version();
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.StrongNameIdentityPermission1"]/*' />
        public StrongNameIdentityPermission( StrongNamePublicKeyBlob blob, String name, Version version )
        {
            if (blob == null)
                throw new ArgumentNullException( "blob" );

            // Add this in Whidbey
            // if (name != null && name.Equals( "" ))
            //     throw new ArgumentException( Environment.GetResourceString( "Argument_EmptyStrongName" ) );      
        
            m_publicKeyBlob = blob;
            m_name = name;
            m_version = version;
        }
        
      
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
        
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.PublicKey"]/*' />
        public StrongNamePublicKeyBlob PublicKey
        {
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "PublicKey" );
            
                m_publicKeyBlob = value;
            }

            get
            {
                return m_publicKeyBlob;
            }
        }
                
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.Name"]/*' />
        public String Name
        {
            set
            {
                m_name = value;
            }                    
               
            get
            {
                return m_name;
            }
        }
        
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.Version"]/*' />
        public Version Version
        {
            set
            {
                m_version = value;
            }
            
            get
            {
                return m_version;
            }
        }
    
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED HELPERS FOR ACCESSORS AND CONSTRUCTORS
        //
        //------------------------------------------------------
    
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            return m_publicKeyBlob == null ? new StrongNameIdentityPermission( PermissionState.None ) : new StrongNameIdentityPermission( m_publicKeyBlob, m_name, m_version );
        }
        
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return m_publicKeyBlob == null;
            }

            try
            {            
                StrongNameIdentityPermission operand = (StrongNameIdentityPermission)target;
            
                // This blob is a subset of the target is it's public key blob is null no matter what
            
                if (this.m_publicKeyBlob == null)
                {
                    return true;
                }
            
                // Subsets are always false is the public key blobs do not match
            
                if (this.m_publicKeyBlob.Equals( operand.m_publicKeyBlob ))
                {
                    // We use null in strings to represent the "Anything" state.
                    // Therefore, the logic to detect an individual subset is:
                    //
                    // 1. If the this string is null ("Anything" is a subset of any other).
                    // 2. If the this string and operand string are the same (equality is sufficient for a subset).
                    //
                    // The logic is reversed here to discover things that are not subsets.
                
                    if (this.m_name != null)
                    {
                        if (operand.m_name == null || !System.Security.Policy.StrongName.CompareNames( operand.m_name, this.m_name ))
                        {
                            return false;
                        }
                    }
                
                    if ((Object) this.m_version != null)
                    {
                        if ((Object) operand.m_version == null ||
                            operand.m_version.CompareTo( this.m_version ) != 0)
                        {
                            return false;
                        }
                    }
                
                    return true;
                }
                else
                {
                    return false;
                }
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }

            
        }
    
        
        
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null || this.m_publicKeyBlob == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            StrongNameIdentityPermission operand = (StrongNameIdentityPermission)target;
            
            // Intersect is only defined on permissions where one is a subset of the other.
            // For intersection, simply return a copy of whichever is a subset of the other.
            
            if (operand.IsSubsetOf( this ))
                return operand.Copy();
            else if (this.IsSubsetOf( operand ))
                return this.Copy();
            else
                return null;
        }
    
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.Union"]/*' />
        public override IPermission Union(IPermission target)
        {
            if (target == null)
            {
                return this.m_publicKeyBlob != null ? this.Copy() : null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            StrongNameIdentityPermission operand = (StrongNameIdentityPermission)target;
            
            // Union is only defined on permissions where one is a subset of the other.
            // For Union, simply return a copy of whichever contains the other.
            
            if (operand.IsSubsetOf( this ))
                return this.Copy();
            else if (this.IsSubsetOf( operand ))
                return operand.Copy();
            else
                return null;

        }

        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement e)
        {
            CodeAccessPermission.ValidateElement( e, this );
            if (e == null) 
                throw new ArgumentNullException( "e" );

            String elBlob = e.Attribute( "PublicKeyBlob" );
            if (elBlob != null)
            {
                m_publicKeyBlob = new StrongNamePublicKeyBlob( Hex.DecodeHexString( elBlob ) );
            }
            else
            {  
                m_publicKeyBlob = null;
            }
            
            String elName = e.Attribute( "Name" );
            m_name = elName == null ? null : elName;
            
            String elVersion = e.Attribute( "AssemblyVersion" );
            m_version = elVersion == null ? null : new Version( elVersion );
        }
        
        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (m_publicKeyBlob != null)
                esd.AddAttribute( "PublicKeyBlob", Hex.EncodeHexString( m_publicKeyBlob.PublicKey ) );

            if (m_name != null)
                esd.AddAttribute( "Name", m_name );
            
            if ((Object) m_version != null)
                esd.AddAttribute( "AssemblyVersion", m_version.ToString() );
            return esd;
        }

        /// <include file='doc\StrongNameIdentityPermission.uex' path='docs/doc[@for="StrongNameIdentityPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return StrongNameIdentityPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.StrongNameIdentityPermissionIndex;
        }
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\strongnamepublickeyblob.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// StrongNamePublicKeyBlob.cool
// 
// author: gregfee
// 

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Util;

    /// <include file='doc\StrongNamePublicKeyBlob.uex' path='docs/doc[@for="StrongNamePublicKeyBlob"]/*' />
    [Serializable] sealed public class StrongNamePublicKeyBlob
    {
        internal byte[] PublicKey;
        
        internal StrongNamePublicKeyBlob()
        {
        }
        
        /// <include file='doc\StrongNamePublicKeyBlob.uex' path='docs/doc[@for="StrongNamePublicKeyBlob.StrongNamePublicKeyBlob"]/*' />
        public StrongNamePublicKeyBlob( byte[] publicKey )
        {
            if (publicKey == null)
                throw new ArgumentNullException( "PublicKey" );
        
            if (publicKey.Length == 0)
                throw new ArgumentException( Environment.GetResourceString( "Argument_StrongNameMustHaveSize" ) );

            this.PublicKey = new byte[publicKey.Length];
            Array.Copy( publicKey, 0, this.PublicKey, 0, publicKey.Length );
        }
        
        internal StrongNamePublicKeyBlob( StrongNamePublicKeyBlob blob )
        {
            this.PublicKey = new byte[blob.PublicKey.Length];
            Array.Copy( blob.PublicKey, 0, this.PublicKey, 0, blob.PublicKey.Length );
        }
        
        
        internal SecurityElement ToXml()
        {
            SecurityElement e = new SecurityElement( "PublicKeyBlob" );
            e.AddChild( new SecurityElement( "Key", Hex.EncodeHexString( PublicKey ) ) );
            return e;
        }
        
        internal void FromXml( SecurityElement e )
        {
            SecurityElement elem;
            elem = e.SearchForChildByTag( "Key" );
            if (elem == null || elem.Text == null || elem.Text.Length == 0)
            {
                PublicKey = new byte[0];
            }
            else
            {
                try
                {
                    PublicKey = Hex.DecodeHexString( elem.Text );
                }
                catch (Exception)
                {
                    PublicKey = new byte[0];
                }
            }
        }
        
        private static bool CompareArrays( byte[] first, byte[] second )
        {
            if (first.Length != second.Length)
            {
                return false;
            }
            
            int count = first.Length;
            for (int i = 0; i < count; ++i)
            {
                if (first[i] != second[i])
                    return false;
            }
            
            return true;
        }
                
        
        internal bool Equals( StrongNamePublicKeyBlob blob )
        {
            if (blob == null)
                return false;
            else 
                return CompareArrays( this.PublicKey, blob.PublicKey );
        }

        /// <include file='doc\StrongNamePublicKeyBlob.uex' path='docs/doc[@for="StrongNamePublicKeyBlob.Equals"]/*' />
        public override bool Equals( Object obj )
        {
            if (obj == null || !(obj is StrongNamePublicKeyBlob))
                return false;

            return this.Equals( (StrongNamePublicKeyBlob)obj );
        }

        /// <include file='doc\StrongNamePublicKeyBlob.uex' path='docs/doc[@for="StrongNamePublicKeyBlob.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (PublicKey == null) return(0);

            int value = 0;

            for (int i = 0; i < PublicKey.Length && i < 4; ++i)
            {
                value = value << 8 | PublicKey[i];
            }

            return value;
        }

        /// <include file='doc\StrongNamePublicKeyBlob.uex' path='docs/doc[@for="StrongNamePublicKeyBlob.ToString"]/*' />
        public override String ToString()
        {
            return Hex.EncodeHexString( PublicKey );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\zoneidentitypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ZoneIdentityPermission.cool
// 
// author: gregfee
// 

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;


    /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission"]/*' />
    [Serializable()] sealed public class ZoneIdentityPermission : CodeAccessPermission, IBuiltInPermission
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private SecurityZone m_zone;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
        
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.ZoneIdentityPermission"]/*' />
        public ZoneIdentityPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else if (state == PermissionState.None)
            {
                m_zone = SecurityZone.NoZone;
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.ZoneIdentityPermission1"]/*' />
        public ZoneIdentityPermission( SecurityZone zone )
        {
            this.SecurityZone = zone;
        }
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
    
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.SecurityZone"]/*' />
        public SecurityZone SecurityZone
        {
            set
            {
                VerifyZone( value );
            
                m_zone = value;
            }
            
            get
            {
                return m_zone;
            }
        }
                
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED HELPERS FOR ACCESSORS AND CONSTRUCTORS
        //
        //------------------------------------------------------
    
        private static void VerifyZone( SecurityZone zone )
        {
            if (zone < SecurityZone.NoZone || zone > SecurityZone.Untrusted)
            {
                throw new ArgumentException( Environment.GetResourceString("Argument_IllegalZone") );
            }
        }
        
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            return new ZoneIdentityPermission(this.m_zone);
        }
        
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.m_zone == SecurityZone.NoZone;
            }

            try
            {
                return this.m_zone == ((ZoneIdentityPermission)target).m_zone || this.m_zone == SecurityZone.NoZone;
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
        }
        
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            if (this.m_zone == SecurityZone.NoZone)
            {
                return null;
            }
            else if (this.m_zone == ((ZoneIdentityPermission)target).m_zone)
            {
                return this.Copy();
            }
            else
            {
                return null;
            }
            
        }
        
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.Union"]/*' />
        public override IPermission Union(IPermission target)
        {
            if (target == null)
            {
                return this.m_zone != SecurityZone.NoZone ? this.Copy() : null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            ZoneIdentityPermission operand = (ZoneIdentityPermission)target;
            
            if (this.m_zone == operand.m_zone || operand.m_zone == SecurityZone.NoZone)
            {
                return this.Copy();
            }
            else if (this.m_zone == SecurityZone.NoZone)
            {
                return operand.Copy();
            }
            else
            {
                return null;
            }
        }
               
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (m_zone != SecurityZone.NoZone)
            {
                esd.AddAttribute( "Zone", Enum.GetName( typeof( SecurityZone ), this.m_zone ) );
            }
            return esd;    
        }
    
        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            String eZone = esd.Attribute( "Zone" );
            if (eZone == null)
            {
                m_zone = SecurityZone.NoZone;
            }
            else
            {
                m_zone = (SecurityZone)Enum.Parse( typeof( SecurityZone ), eZone );
            }
        }

        /// <include file='doc\ZoneIdentityPermission.uex' path='docs/doc[@for="ZoneIdentityPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return ZoneIdentityPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.ZoneIdentityPermissionIndex;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\uipermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// UIPermission.cool
//

namespace System.Security.Permissions
{
    using System;
    using System.Security;
    using System.Security.Util;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Reflection;
    using System.Collections;
    
    /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionWindow"]/*' />
    [Serializable]
    public enum UIPermissionWindow
    {
        // No window use allowed at all.
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionWindow.NoWindows"]/*' />
        NoWindows = 0x0,
    
        // Only allow safe subwindow use (for embedded components).
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionWindow.SafeSubWindows"]/*' />
        SafeSubWindows = 0x01,
    
        // Safe top-level window use only (see specification for details).
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionWindow.SafeTopLevelWindows"]/*' />
        SafeTopLevelWindows = 0x02,
    
        // All windows and all event may be used.
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionWindow.AllWindows"]/*' />
        AllWindows = 0x03,
    
    }
    
    /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionClipboard"]/*' />
    [Serializable]
    public enum UIPermissionClipboard
    {
        // No clipboard access is allowed.
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionClipboard.NoClipboard"]/*' />
        NoClipboard = 0x0,
    
        // Paste from the same app domain only.
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionClipboard.OwnClipboard"]/*' />
        OwnClipboard = 0x1,
    
        // Any clipboard access is allowed.
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermissionClipboard.AllClipboard"]/*' />
        AllClipboard = 0x2,
    
    }
    
    
    /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission"]/*' />
    [Serializable()] sealed public class UIPermission 
           : CodeAccessPermission, IUnrestrictedPermission, IBuiltInPermission
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private UIPermissionWindow m_windowFlag;
        private UIPermissionClipboard m_clipboardFlag;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.UIPermission"]/*' />
        public UIPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                SetUnrestricted( true );
            }
            else if (state == PermissionState.None)
            {
                SetUnrestricted( false );
                Reset();
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }    
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.UIPermission1"]/*' />
        public UIPermission(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag )
        {
            VerifyWindowFlag( windowFlag );
            VerifyClipboardFlag( clipboardFlag );
            
            m_windowFlag = windowFlag;
            m_clipboardFlag = clipboardFlag;
        }
    
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.UIPermission2"]/*' />
        public UIPermission(UIPermissionWindow windowFlag )
        {
            VerifyWindowFlag( windowFlag );
            
            m_windowFlag = windowFlag;
        }
    
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.UIPermission3"]/*' />
        public UIPermission(UIPermissionClipboard clipboardFlag )
        {
            VerifyClipboardFlag( clipboardFlag );
            
            m_clipboardFlag = clipboardFlag;
        }
        
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.Window"]/*' />
        public UIPermissionWindow Window
        {
            set
            {
                VerifyWindowFlag(value);
            
                m_windowFlag = value;
            }
            
            get
            {
                return m_windowFlag;
            }
        }
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.Clipboard"]/*' />
        public UIPermissionClipboard Clipboard
        {
            set
            {
                VerifyClipboardFlag(value);
            
                m_clipboardFlag = value;
            }
            
            get
            {
                return m_clipboardFlag;
            }
        }
    
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED HELPERS FOR ACCESSORS AND CONSTRUCTORS
        //
        //------------------------------------------------------
        
        private static void VerifyWindowFlag(UIPermissionWindow flag)
        {
            if (flag < UIPermissionWindow.NoWindows || flag > UIPermissionWindow.AllWindows)
            {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)flag));
            }
        }
        
        private static void VerifyClipboardFlag(UIPermissionClipboard flag)
        {
            if (flag < UIPermissionClipboard.NoClipboard || flag > UIPermissionClipboard.AllClipboard)
            {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)flag));
            }
        }
        
        private void Reset()
        {
            m_windowFlag = UIPermissionWindow.NoWindows;
            m_clipboardFlag = UIPermissionClipboard.NoClipboard;
        }
        
        private void SetUnrestricted( bool unrestricted )
        {
            if (unrestricted)
            {
                m_windowFlag = UIPermissionWindow.AllWindows;
                m_clipboardFlag = UIPermissionClipboard.AllClipboard;
            }
        }
    
        //------------------------------------------------------
        //
        // OBJECT METHOD OVERRIDES
        //
        //------------------------------------------------------
    /*
        public String ToString()
        {
    #ifdef _DEBUG
            StringBuilder sb = new StringBuilder();
            sb.Append("UIPermission(");
            if (IsUnrestricted())
            {
                sb.Append("Unrestricted");
            }
            else
            {
                sb.Append(m_stateNameTableWindow[m_windowFlag]);
                sb.Append(", ");
                sb.Append(m_stateNameTableClipboard[m_clipboardFlag]);
            }
            
            sb.Append(")");
            return sb.ToString();
    #else
            return super.ToString();
    #endif
        }
    */
        
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            return m_windowFlag == UIPermissionWindow.AllWindows && m_clipboardFlag == UIPermissionClipboard.AllClipboard;
        }
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                // Only safe subset if this is empty
                return m_windowFlag == UIPermissionWindow.NoWindows && m_clipboardFlag == UIPermissionClipboard.NoClipboard;
            }

            try
            {
                UIPermission operand = (UIPermission)target;
                if (operand.IsUnrestricted())
                    return true;
                else if (this.IsUnrestricted())
                    return false;
                else 
                    return this.m_windowFlag <= operand.m_windowFlag && this.m_clipboardFlag <= operand.m_clipboardFlag;
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
        }
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            UIPermission operand = (UIPermission)target;
            UIPermissionWindow isectWindowFlags = m_windowFlag < operand.m_windowFlag ? m_windowFlag : operand.m_windowFlag;
            UIPermissionClipboard isectClipboardFlags = m_clipboardFlag < operand.m_clipboardFlag ? m_clipboardFlag : operand.m_clipboardFlag;
            if (isectWindowFlags == UIPermissionWindow.NoWindows && isectClipboardFlags == UIPermissionClipboard.NoClipboard)
                return null;
            else
                return new UIPermission(isectWindowFlags, isectClipboardFlags);
        }
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.Union"]/*' />
        public override IPermission Union(IPermission target)
        {
            if (target == null)
            {
                return this.Copy();
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            UIPermission operand = (UIPermission)target;
            UIPermissionWindow isectWindowFlags = m_windowFlag > operand.m_windowFlag ? m_windowFlag : operand.m_windowFlag;
            UIPermissionClipboard isectClipboardFlags = m_clipboardFlag > operand.m_clipboardFlag ? m_clipboardFlag : operand.m_clipboardFlag;
            if (isectWindowFlags == UIPermissionWindow.NoWindows && isectClipboardFlags == UIPermissionClipboard.NoClipboard)
                return null;
            else
                return new UIPermission(isectWindowFlags, isectClipboardFlags);
        }        
        
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            return new UIPermission(this.m_windowFlag, this.m_clipboardFlag);
        }
    
       
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (!IsUnrestricted())
            {
                if (m_windowFlag != UIPermissionWindow.NoWindows)
                {
                    esd.AddAttribute( "Window", Enum.GetName( typeof( UIPermissionWindow ), m_windowFlag ) );
                }
                if (m_clipboardFlag != UIPermissionClipboard.NoClipboard)
                {
                    esd.AddAttribute( "Clipboard", Enum.GetName( typeof( UIPermissionClipboard ), m_clipboardFlag ) );
                }
            }
            else
            {
                esd.AddAttribute( "Unrestricted", "true" );
            }
            return esd;
        }
            
        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            if (XMLUtil.IsUnrestricted( esd ))
            {
                SetUnrestricted( true );
                return;
            }
            
			m_windowFlag = UIPermissionWindow.NoWindows;
			m_clipboardFlag = UIPermissionClipboard.NoClipboard;

            String window = esd.Attribute( "Window" );
            if (window != null)
                m_windowFlag = (UIPermissionWindow)Enum.Parse( typeof( UIPermissionWindow ), window );

            String clipboard = esd.Attribute( "Clipboard" );
            if (clipboard != null)
                m_clipboardFlag = (UIPermissionClipboard)Enum.Parse( typeof( UIPermissionClipboard ), clipboard );
        }

        /// <include file='doc\UIPermission.uex' path='docs/doc[@for="UIPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return UIPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.UIPermissionIndex;
        }
            
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\unrestrictedpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// UnrestrictedPermissionBase.cool
//

namespace System.Security.Permissions {
	using System.Security;
	using System;
	using System.IO;
	using System.Security.Util;
    internal class UnrestrictedPermission
    {
        // Returns true if OK to return from check, or false if
        // permission-specific information must be checked.
        internal static bool CheckUnrestricted(IUnrestrictedPermission grant, CodeAccessPermission demand)
        {
            // We return true here because we're defining a demand of null to
            // automatically pass.
            if (demand == null)
                return true;
    
            if (demand.GetType() != grant.GetType())
                return false;
            if (grant.IsUnrestricted())
                return true;
            if (((IUnrestrictedPermission)demand).IsUnrestricted())
                throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().FullName), demand.GetType(), demand.ToXml().ToString());
            return false;
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\urlidentitypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// UrlIdentityPermission.cool
// 
// author: gregfee
// 

namespace System.Security.Permissions
{
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Util;
    using System.IO;

    /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission"]/*' />
    [Serializable] sealed public class UrlIdentityPermission : CodeAccessPermission, IBuiltInPermission
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private URLString m_url;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
        
       
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.UrlIdentityPermission"]/*' />
        public UrlIdentityPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnrestrictedIdentityPermission"));
            }
            else if (state == PermissionState.None)
            {
                m_url = null;
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.UrlIdentityPermission1"]/*' />
        public UrlIdentityPermission( String site )
        {
            if (site == null)
                throw new ArgumentNullException( "site" );
                
            m_url = new URLString( site );
        }
        
        internal UrlIdentityPermission( URLString site )
        {
            m_url = site;
        }
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
        
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.Url"]/*' />
        public String Url
        {
            set
            {
                m_url = new URLString( value );
            }
            
            get
            {
                return m_url.ToString();
            }
        }
            
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED HELPERS FOR ACCESSORS AND CONSTRUCTORS
        //
        //------------------------------------------------------
    
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
       
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            return new UrlIdentityPermission( new URLString( m_url.ToString(), true ) );
        }
        
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.m_url == null;
            }
            
            try
            {
                UrlIdentityPermission operand = (UrlIdentityPermission)target;
            
                if (this.m_url == null)
                {
                    return true;
                }
            
                return this.m_url.IsSubsetOf(operand.m_url);
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }

        }
        
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null || this.m_url == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            UrlIdentityPermission operand = (UrlIdentityPermission)target;
            
            if (operand.m_url == null || this.m_url == null)
            {
                return null;
            }
            
            URLString url = (URLString)this.m_url.Intersect(operand.m_url);
            
            if (url == null)
            {
                return null;
            }
            else
            {
                return new UrlIdentityPermission( url );
            }
        }
    
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.Union"]/*' />
        public override IPermission Union(IPermission target)
        {
            if (target == null)
            {
                return this.m_url != null ? this.Copy() : null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            
            UrlIdentityPermission operand = (UrlIdentityPermission)target;

            if (this.m_url == null)
            {
                return operand.m_url != null ? target.Copy() : null;
            }
            else if (operand.m_url == null)
            {
                return this.Copy();
            }
            
            URLString url = (URLString)operand.m_url.Union( this.m_url );
            
            if (url == null)
            {
                return null;
            }
            else
            {
                return new UrlIdentityPermission( url );
            }
        }
           
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );
            String elem = esd.Attribute( "Url" );
            m_url = elem == null ? null : new URLString( elem, true );
            
        }
        
        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (m_url != null)        
                esd.AddAttribute( "Url", m_url.ToString() );
            return esd;
        }

        /// <include file='doc\URLIdentityPermission.uex' path='docs/doc[@for="UrlIdentityPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return UrlIdentityPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.UrlIdentityPermissionIndex;
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\allmembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  AllMembershipCondition.cool
//
//  Simple IMembershipCondition implementation that always passes
//

namespace System.Security.Policy {
    
    using System;
    using System.Security;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.Collections;
    
    /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition"]/*' />
    [Serializable]
    sealed public class AllMembershipCondition : IMembershipCondition, IConstantMembershipCondition
    {
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.AllMembershipCondition"]/*' />
        public AllMembershipCondition()
        {
        }
        
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            return true;
        }
        
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            return new AllMembershipCondition();
        }
        
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            return Environment.GetResourceString( "All_ToString" );
        }
        
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            return root;
        }
    
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");
        
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
            
        }
        
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            return (o is AllMembershipCondition);
        }
        
        /// <include file='doc\AllMembershipCondition.uex' path='docs/doc[@for="AllMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return typeof( AllMembershipCondition ).GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\applicationdirectorymembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  ApplicationDirectoryMembershipCondition.cool
//
//  Implementation of membership condition for "application directories"
//

namespace System.Security.Policy {   
	using System;
	using SecurityElement = System.Security.SecurityElement;
	using System.Security.Policy;
	using URLString = System.Security.Util.URLString;
    using System.Collections;

    /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition"]/*' />
    [Serializable]
    sealed public class ApplicationDirectoryMembershipCondition : IMembershipCondition, IConstantMembershipCondition
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.ApplicationDirectoryMembershipCondition"]/*' />
        public ApplicationDirectoryMembershipCondition()
        {
        }
        
        //------------------------------------------------------
        //
        // IMEMBERSHIPCONDITION IMPLEMENTATION
        //
        //------------------------------------------------------
    
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            if (evidence == null)
                return false;
        
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                Object obj = enumerator.Current;
            
                if (obj is ApplicationDirectory)
                {
                    ApplicationDirectory dir = (ApplicationDirectory)obj;
                
                    IEnumerator innerEnumerator = evidence.GetHostEnumerator();
                    
                    while (innerEnumerator.MoveNext())
                    {
                        Object innerObj = innerEnumerator.Current;
                        
                        if (innerObj is Url)
                        {
                            // We need to add a wildcard at the end because IsSubsetOf
                            // keys off of it.
                            
                            String appDir = dir.Directory;
                            
                            if (appDir != null && appDir.Length > 1)
                            {
                                if (appDir[appDir.Length-1] == '/')
                                    appDir += "*";
                                else
                                    appDir += "/*";
                                
                                URLString appDirString = new URLString( appDir );
                            
                                if (((Url)innerObj).GetURLString().IsSubsetOf( appDirString ))
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            
            return false;
        }
        
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            return new ApplicationDirectoryMembershipCondition();
        }
        
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            return root;
        }
    
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");
        
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
        }
        
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            return (o is ApplicationDirectoryMembershipCondition);
        }
        
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return typeof( ApplicationDirectoryMembershipCondition ).GetHashCode();
        }
        
        /// <include file='doc\ApplicationDirectoryMembershipCondition.uex' path='docs/doc[@for="ApplicationDirectoryMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            return Environment.GetResourceString( "ApplicationDirectory_ToString" );
        }   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\codegroup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  CodeGroup.cool
//
//  Representation for code groups used for the policy mechanism
//

namespace System.Security.Policy {
    
    using System;
    using System.Security.Util;
    using System.Security;
    using System.Collections;
    
    /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup"]/*' />
    [Serializable]
    abstract public class CodeGroup
    {
        private IMembershipCondition m_membershipCondition;
        private IList m_children;
        private PolicyStatement m_policy;
        private SecurityElement m_element;
        private PolicyLevel m_parentLevel;
        private String m_name;
        private String m_description;
        
        internal CodeGroup()
        {
            m_membershipCondition = null;
            m_children = null;
            m_policy = null;
            m_element = null;
            m_parentLevel = null;
        }
        
        internal CodeGroup( IMembershipCondition membershipCondition, PermissionSet permSet )
        {
            BCLDebug.Assert( membershipCondition != null, "membershipCondition != null" );
            BCLDebug.Assert( permSet != null, "permSet != null" );

            m_membershipCondition = membershipCondition;
            m_policy = new PolicyStatement();
            m_policy.SetPermissionSetNoCopy( permSet );
            m_children = ArrayList.Synchronized( new ArrayList() );
            m_element = null;
            m_parentLevel = null;
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.CodeGroup"]/*' />
        public CodeGroup( IMembershipCondition membershipCondition, PolicyStatement policy )
        {
            if (membershipCondition == null)
                throw new ArgumentNullException( "membershipCondition" );

            if (policy == null)
                m_policy = null;
            else
                m_policy = policy.Copy();
        
            m_membershipCondition = membershipCondition.Copy();
            m_children = ArrayList.Synchronized( new ArrayList() );
            m_element = null;
            m_parentLevel = null;
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.AddChild"]/*' />
        public void AddChild( CodeGroup group )
        {
            if (group == null)
                throw new ArgumentNullException("group");
                
            if (m_children == null)
                ParseChildren();
            
            lock (this)
            {
                m_children.Add( group.Copy() );
            }
        }

        internal void AddChildInternal( CodeGroup group )
        {
            if (group == null)
                throw new ArgumentNullException("group");
                
            if (m_children == null)
                ParseChildren();

            lock (this)
            {
                m_children.Add( group );
            }
        }            
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.RemoveChild"]/*' />
        public void RemoveChild( CodeGroup group )
        {
            if (group == null)
                return;
        
            if (m_children == null)
                ParseChildren();
            
            lock (this )
            {
                int index = m_children.IndexOf( group );
            
                if (index != -1)
                {
                    m_children.RemoveAt( index );
                }
            }
        }        
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.Children"]/*' />
        public IList Children
        {
            get
            {
                if (m_children == null)
                    ParseChildren();
        
                lock (this)
                {
                    IList newList = new ArrayList( m_children.Count );

                    IEnumerator enumerator = m_children.GetEnumerator();

                    while (enumerator.MoveNext())
                    {
                        newList.Add( ((CodeGroup)enumerator.Current).Copy() );
                    }

                    return newList;
                }
            }

            set
            {
                if (value == null)
                    throw new ArgumentNullException( "Children" );

                ArrayList children = ArrayList.Synchronized( new ArrayList( value.Count ) );

                IEnumerator enumerator = value.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    CodeGroup group = enumerator.Current as CodeGroup;

                    if (group == null)
                        throw new ArgumentException( Environment.GetResourceString( "Argument_CodeGroupChildrenMustBeCodeGroups" ) );

                    children.Add( group.Copy() );
                }

                m_children = children;
            }
        }
        
        internal IList GetChildrenInternal()
        {
            if (m_children == null)
                ParseChildren();
        
            return m_children;
        }
                
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.MembershipCondition"]/*' />
        public IMembershipCondition MembershipCondition
        {
            get
            {
                if (m_membershipCondition == null && m_element != null)
                    ParseMembershipCondition();
        
                return m_membershipCondition.Copy();
            }
            
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "MembershipCondition" );

                m_membershipCondition = value.Copy();
            }
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.PolicyStatement"]/*' />
        public PolicyStatement PolicyStatement
        {
            get
            {
                if (m_policy == null && m_element != null)
                    ParsePolicy();

                if (m_policy != null)
                    return m_policy.Copy();
                else
                    return null;
            }
            
            set
            {
                if (value != null)
                    m_policy = value.Copy();
                else
                    m_policy = null;
            }
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.Name"]/*' />
        public String Name
        {
            get
            {
                return m_name;
            }

            set
            {
                m_name = value;
            }
        }

        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.Description"]/*' />
        public String Description
        {
            get
            {
                return m_description;
            }

            set
            {
                m_description = value;
            }
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.Resolve"]/*' />
        public abstract PolicyStatement Resolve( Evidence evidence );

        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.ResolveMatchingCodeGroups"]/*' />
        public abstract CodeGroup ResolveMatchingCodeGroups( Evidence evidence );
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.Copy"]/*' />
        public abstract CodeGroup Copy();
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.PermissionSetName"]/*' />
        public virtual String PermissionSetName
        {
            get
            {
                if (m_policy == null && m_element != null)
                    ParsePolicy();

                if (m_policy == null)
                    return null;
                    
                NamedPermissionSet permSet = m_policy.GetPermissionSetNoCopy() as NamedPermissionSet;
            
                if (permSet != null)
                {
                    return permSet.Name;
                }
                else
                {
                    return null;
                }
            }
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.AttributeString"]/*' />
        public virtual String AttributeString
        {
            get
            {
                if (m_policy == null && m_element != null)
                    ParsePolicy();
                    
                if (m_policy != null)
                    return m_policy.AttributeString;
                else
                    return null;
            }
        }  
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.MergeLogic"]/*' />
        public abstract String MergeLogic
        {
            get;
        }
              
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            if (m_membershipCondition == null && m_element != null)
                ParseMembershipCondition();
                
            if (m_children == null)
                ParseChildren();
                
            if (m_policy == null && m_element != null)
                ParsePolicy();
        
            SecurityElement e = new SecurityElement( "CodeGroup" );
            System.Security.Util.XMLUtil.AddClassAttribute( e, this.GetType() );
            e.AddAttribute( "version", "1" );

            e.AddChild( m_membershipCondition.ToXml( level ) );

            // Grab the inerts of the policy statement's xml and just stick it
            // into the code group xml directly. We do this to hide the policy statement from
            // users in the config file.
            
            if (m_policy != null)
            {
                PermissionSet permSet = m_policy.GetPermissionSetNoCopy();
                NamedPermissionSet namedPermSet = permSet as NamedPermissionSet;

                if (namedPermSet != null && level != null && level.GetNamedPermissionSetInternal( namedPermSet.Name ) != null)
                {
                    e.AddAttribute( "PermissionSetName", namedPermSet.Name );
                }
                else
                {
                    if (!permSet.IsEmpty())
                        e.AddChild( permSet.ToXml() );
                }

                if (m_policy.Attributes != PolicyStatementAttribute.Nothing)
                    e.AddAttribute( "Attributes", XMLUtil.BitFieldEnumToString( typeof( PolicyStatementAttribute ), m_policy.Attributes ) );
                }
            
                if (m_children.Count > 0)
                {
                    lock (this)
                    {
                        IEnumerator enumerator = m_children.GetEnumerator();
            
                        while (enumerator.MoveNext())
                        {
                            e.AddChild( ((CodeGroup)enumerator.Current).ToXml( level ) );
                        }
                    }
                }

            if (m_name != null)
            {
                e.AddAttribute( "Name", SecurityElement.Escape( m_name ) );
            }

            if (m_description != null)
            {
                e.AddAttribute( "Description", SecurityElement.Escape( m_description ) );
            }

			CreateXml( e, level );
            
            return e;
        }

        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.CreateXml"]/*' />
        protected virtual void CreateXml( SecurityElement element, PolicyLevel level )
        {
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");

            lock (this)
            {
                m_element = e;
                m_parentLevel = level;
                m_children = null;
                m_membershipCondition = null;
                m_policy = null;

                m_name = e.Attribute( "Name" );
                m_description = e.Attribute( "Description" );

                ParseXml( e, level );
            }
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.ParseXml"]/*' />
        protected virtual void ParseXml( SecurityElement e, PolicyLevel level )
        {
        } 
            
        private bool ParseMembershipCondition( bool safeLoad )
        {
            lock (this)
            {
                IMembershipCondition membershipCondition = null;
                SecurityElement elMembershipCondition = m_element.SearchForChildByTag( "IMembershipCondition" );
                if (elMembershipCondition != null)
                {
                    try
                    {
                        membershipCondition = System.Security.Util.XMLUtil.CreateMembershipCondition( elMembershipCondition, safeLoad );

                        if (membershipCondition == null)
                            return false;
                    }
                    catch (Exception ex)
                    {
                        throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ), ex );
                    }
                    membershipCondition.FromXml( elMembershipCondition, m_parentLevel );
                }
                else
                {
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidXMLElement" ),  "IMembershipCondition", this.GetType().FullName ) );
                }
                
                m_membershipCondition = membershipCondition;
                return true;
            }
        }

        private void ParseMembershipCondition()
        {
            ParseMembershipCondition( false );
        }
        
        internal void ParseChildren()
        {
            lock (this)
            {
                ArrayList childrenList = ArrayList.Synchronized( new ArrayList() );
        
                if (m_element != null && m_element.m_lChildren != null)
                {    
                    ArrayList children = m_element.m_lChildren;

                    if (children != null)
                    {
                        // We set the elements childrenList to a list that contains no code groups that are in
                        // assemblies that have not yet been loaded.  This guarantees that if 
                        // we recurse while loading the child code groups or their membership conditions
                        // that we won't get back to this point to create an infinite recursion.

                        m_element.m_lChildren = (ArrayList)m_element.m_lChildren.Clone();

                        // We need to keep track of which children are not parsed and created in our
                        // first pass through the list of children, including what position they were
                        // at originally so that we can add them back in as we do parse them.

                        ArrayList unparsedChildren = ArrayList.Synchronized( new ArrayList() );

                        Evidence evidence = new Evidence();

                        int childCount = m_element.m_lChildren.Count;
                        int i = 0;
                        while (i < childCount)
                        {
                            SecurityElement elGroup = (SecurityElement)m_element.m_lChildren[i];
                
                            if (elGroup.Tag.Equals( "CodeGroup" ))
                            {
                                // Using safe load here to guarantee that we don't load any assemblies that aren't
                                // already loaded.  If we find a code group or membership condition that is defined
                                // in an assembly that is not yet loaded, we will remove the corresponding element
                                // from the list of child elements as to avoid the infinite recursion, and then
                                // add them back in later.

                                CodeGroup group = System.Security.Util.XMLUtil.CreateCodeGroup( elGroup, true );
                    
                                if (group != null)
                                {
                                    group.FromXml( elGroup, m_parentLevel );

                                    // We want to touch the membership condition to make sure it is loaded
                                    // before we put the code group in a place where Resolve will touch it.
                                    // This is critical in negotiating our recursive resolve scenario.

                                    if (ParseMembershipCondition( true ))
                                    {
                                        // In addition, we need to touch several methods to make sure they are jitted previous
                                        // to a Resolve happening with this code gropu in the hierarchy.  We can run into
                                        // recursive cases where if you have a method that touchs an assembly that does
                                        // a resolve at load time (permission request, execution checking) that you recurse around
                                        // and end up trying to jit the same method again.
                                
                                        group.Resolve( evidence );
                                        group.MembershipCondition.Check( evidence );

                                        // Now it should be ok to add the group to the hierarchy.

                                        childrenList.Add( group );

                                        // Increment the count since we are done with this child

                                        ++i;
                                    }
                                    else
                                    {
                                        // Assembly that holds the membership condition is not loaded, remove
                                        // the child from the list.

                                        m_element.m_lChildren.RemoveAt( i );

                                        // Note: we do not increment the counter since the value at 'i' should
                                        // now be what was at 'i+1' previous to the RemoveAt( i ) above.  However,
                                        // we do need to update the count of children in the list

                                        childCount = m_element.m_lChildren.Count;

                                        // Add this child to the unparsed child list.

                                        unparsedChildren.Add( new CodeGroupPositionMarker( i, childrenList.Count, elGroup ) );
                                    }
                                }
                                else
                                {
                                    // Assembly that holds the code group is not loaded, remove
                                    // the child from the list.

                                    m_element.m_lChildren.RemoveAt( i );

                                    // Note: we do not increment the counter since the value at 'i' should
                                    // now be what was at 'i+1' previous to the RemoveAt( i ) above.  However,
                                    // we do need to update the count of children in the list

                                    childCount = m_element.m_lChildren.Count;

                                    // Add this child to the unparsed child list.

                                    unparsedChildren.Add( new CodeGroupPositionMarker( i, childrenList.Count, elGroup ) );
                                }
                            }
                            else
                            {
                                // The current tag is not an <CodeGroup> tag, so we just skip it.

                                ++i;
                            }
                        }

                        // Now we have parsed all the children that only use classes in already loaded
                        // assemblies.  Now go through the process of loading the needed classes (and
                        // therefore assemblies) and building the objects in the order that they
                        // appear in the list of children (which is the same as they now appear in the
                        // list of unparsed children since we always added to the back of the list).
                        // As each is parsed, add that child back into the list of children since they
                        // can now be parsed without loading any additional assemblies.

                        IEnumerator enumerator = unparsedChildren.GetEnumerator();

                        while (enumerator.MoveNext())
                        {
                            CodeGroupPositionMarker marker = (CodeGroupPositionMarker)enumerator.Current;

                            CodeGroup group = System.Security.Util.XMLUtil.CreateCodeGroup( marker.element, false );
                
                            if (group != null)
                            {
                                group.FromXml( marker.element, m_parentLevel );

                                // We want to touch the membership condition to make sure it is loaded
                                // before we put the code group in a place where Resolve will touch it.
                                // This is critical in negotiating our recursive resolve scenario.

                                group.Resolve( evidence );
                                group.MembershipCondition.Check( evidence );

                                // Now it should be ok to add the group to the hierarchy.

                                childrenList.Insert( marker.groupIndex, group );

                                // Add the element back into the child list in the proper spot.

                                m_element.m_lChildren.Insert( marker.elementIndex, marker.element );
                            }
                            else
                            {
                                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_FailedCodeGroup" ), marker.element.Attribute( "class" ) ) );
                            }
                        }

                    }

                }
                m_children = childrenList;
            }

        }
        
        private void ParsePolicy()
        {
            // There is a potential deadlock situation here
            // since the PolicyStatement.FromXml method calls
            // into PolicyLevel and we are holding this CodeGroup's lock.
            // We solve this by releasing the lock for the duration of
            // the FromXml call, but this leads us into some race conditions
            // with other threads trying to alter the state of this object.
            // The trickiest of these is the case from FromXml gets called on
            // this object, in which case we will loop and try the decode again.

            while (true)
            {
                PolicyStatement policy = new PolicyStatement();
                bool needToParse = false;

                SecurityElement elPolicy = new SecurityElement( "PolicyStatement" );
                elPolicy.AddAttribute( "version", "1" );

                SecurityElement localRef = m_element;

                lock (this)
                {

                    // We sorta cook up an xml representation of a policy statement from the
                    // xml for a code group.  We do this to hide the policy statement from
                    // users in the config file.

                    if (m_element != null)
                    {
                        String permSetName = m_element.Attribute( "PermissionSetName" );

                        if (permSetName != null)
                        {
                            elPolicy.AddAttribute( "PermissionSetName", permSetName );
                            needToParse = true;
                        }
                        else
                        {
                            SecurityElement elPermSet = m_element.SearchForChildByTag( "PermissionSet" );

                            if (elPermSet != null)
                            {
                                elPolicy.AddChild( elPermSet );
                                needToParse = true;
                            }
                            else
                            {
                                elPolicy.AddChild( new PermissionSet( false ).ToXml() );
                                needToParse = true;
                            }
                        }

                        String attributes = m_element.Attribute( "Attributes" );

                        if (attributes != null)
                        {
                            elPolicy.AddAttribute( "Attributes", attributes );
                            needToParse = true;
                        }
                    }
                }

                if (needToParse)
                    policy.FromXml( elPolicy, m_parentLevel );
                else
                    policy.PermissionSet = null;

                lock (this)
                {
                    if (localRef == m_element && m_policy == null)
                    {
                        m_policy = policy;
                        break;
                    }
                    else if (m_policy != null)
                    {
                        break;
                    }
                }
            }

            if (m_policy != null && m_children != null && m_membershipCondition != null)
            {
                //m_element = null;
                //m_parentLevel = null;
            }

        }

        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.Equals"]/*' />
        public override bool Equals( Object o)
        {
            CodeGroup that = (o as CodeGroup);

            if (that != null && this.GetType().Equals( that.GetType() ))
            {
                if (Equals( this.m_name, that.m_name ) &&
                    Equals( this.m_description, that.m_description ))
                {
                    if (this.m_membershipCondition == null && this.m_element != null)
                        this.ParseMembershipCondition();
                    if (that.m_membershipCondition == null && that.m_element != null)
                        that.ParseMembershipCondition();

                    if (Equals( this.m_membershipCondition, that.m_membershipCondition ))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.Equals1"]/*' />
        public bool Equals( CodeGroup cg, bool compareChildren)
        {
            if (!this.Equals( cg )) return false;
            
            if (compareChildren)
            {
                if (this.m_children == null)
                    this.ParseChildren();
                if (cg.m_children == null)
                    cg.ParseChildren();

                ArrayList list1 = new ArrayList(this.m_children);
                ArrayList list2 = new ArrayList(cg.m_children);
                
                if (list1.Count != list2.Count) return false;
                
                for (int i = 0; i < list1.Count; i++)
                {
                    if (!((CodeGroup) list1[i]).Equals( (CodeGroup) list2[i], true ))
                    {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        /// <include file='doc\CodeGroup.uex' path='docs/doc[@for="CodeGroup.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (m_membershipCondition == null && m_element != null)
                ParseMembershipCondition();

            if (m_name != null || m_membershipCondition != null)
            {
                return (m_name == null ? 0 : m_name.GetHashCode())
                     + (m_membershipCondition == null ? 0 : m_membershipCondition.GetHashCode());
            }
            else
            {
                return GetType().GetHashCode();
            }
        }
    }

    internal class CodeGroupPositionMarker
    {
        internal int elementIndex;
        internal int groupIndex;
        internal SecurityElement element;

        internal CodeGroupPositionMarker( int elementIndex, int groupIndex, SecurityElement element )
        {
            this.elementIndex = elementIndex;
            this.groupIndex = groupIndex;
            this.element = element;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\applicationdirectory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  ApplicationDirectory.cs
//
//  ApplicationDirectory is an evidence type representing the directory the assembly
//  was loaded from.
//

namespace System.Security.Policy {
    
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Collections;
    
    /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory"]/*' />
    [Serializable]
    sealed public class ApplicationDirectory : IBuiltInEvidence
    {
        private URLString m_appDirectory;
    
        internal ApplicationDirectory()
        {
            m_appDirectory = null;
        }
    
        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.ApplicationDirectory"]/*' />
        public ApplicationDirectory( String name )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
        
            m_appDirectory = new URLString( name );
        }
    
        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.Directory"]/*' />
        public String Directory
        {
            get
            {
                return m_appDirectory.ToString();
            }
        }
        
        internal URLString GetDirectoryString()
        {
            return m_appDirectory;
        }
        
        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.Equals"]/*' />
        public override bool Equals(Object o)
        {
            if (o == null)
                return false;
        
            if (o is ApplicationDirectory)
            {
                ApplicationDirectory appDir = (ApplicationDirectory) o;
                
                if (this.m_appDirectory == null)
                {
                    return appDir.m_appDirectory == null;
                }
                else if (appDir.m_appDirectory == null)
                {
                    return false;
                }
                else
                {
                    return this.m_appDirectory.IsSubsetOf( appDir.m_appDirectory ) && appDir.m_appDirectory.IsSubsetOf( this.m_appDirectory );
                }
            }
            return false;
        }
    
        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return this.Directory.GetHashCode();
        } 
    
        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.Copy"]/*' />
        public Object Copy()
        {
            ApplicationDirectory appDir = new ApplicationDirectory();
    
            appDir.m_appDirectory = this.m_appDirectory;
    
            return appDir;
        }
    
        internal SecurityElement ToXml()
        {
            SecurityElement root = new SecurityElement( this.GetType().FullName );
            root.AddAttribute( "version", "1" );
            
            if (m_appDirectory != null)
                root.AddChild( new SecurityElement( "Directory", m_appDirectory.ToString() ) );
            
            return root;
        }
    
        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            buffer[position++] = BuiltInEvidenceHelper.idApplicationDirectory;
            String directory = this.Directory;
            int length = directory.Length;

            if (verbose)
            {
                BuiltInEvidenceHelper.CopyIntToCharArray(length, buffer, position);
                position += 2;
            }
            directory.CopyTo( 0, buffer, position, length );
            return length + position;
        }

        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position)
        {
            int length = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;

            m_appDirectory = new URLString( new String(buffer, position, length ));

            return position + length;
        }

        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose)
        {
            if (verbose)
                return this.Directory.Length + 3; // Directory + identifier + length
            else
                return this.Directory.Length + 1; // Directory + identifier
        }
        
        /// <include file='doc\ApplicationDirectory.uex' path='docs/doc[@for="ApplicationDirectory.ToString"]/*' />
        public override String ToString()
		{
			return ToXml().ToString();
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\evidence.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  Evidence.cool
//
//  Use this class to keep a list of evidence associated with an Assembly
//

namespace System.Security.Policy {
 
	using System;
	using System.Collections;
	using System.IO;
	using System.Configuration.Assemblies;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System.Security.Util;
	using System.Security.Permissions;
    using System.Runtime.Serialization.Formatters.Binary;
    
    /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence"]/*' />
    [Serializable]
    public sealed class Evidence : ICollection
    {
        private IList m_hostList;
        private IList m_assemblyList;
        private bool m_locked;
    
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.Evidence"]/*' />
        public Evidence()
        {
            m_hostList = null;
            m_assemblyList = null;
            m_locked = false;
        }
    
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.Evidence1"]/*' />
        public Evidence(Evidence evidence)
        {
            if (evidence == null)
                return;

            m_locked = false;
    
            Merge( evidence );
        }

        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.Evidence2"]/*' />
        public Evidence( Object[] hostEvidence, Object[] assemblyEvidence )
        {
            m_locked = false;
            
            if (hostEvidence != null)
            {
                this.m_hostList = ArrayList.Synchronized( new ArrayList( hostEvidence ) );
            }
            
            if (assemblyEvidence != null)
            {
                this.m_assemblyList = ArrayList.Synchronized( new ArrayList( assemblyEvidence ) );
            }
        }   
    
        internal Evidence(char[] buffer)
        {
            int position = 0;
            while (position < buffer.Length)
            {
                switch (buffer[position++])
                {
                    case BuiltInEvidenceHelper.idApplicationDirectory:
                    {
                        IBuiltInEvidence ad = new ApplicationDirectory();
                        position = ad.InitFromBuffer(buffer, position);
                        AddAssembly(ad);
                        break;
                    }
                    case BuiltInEvidenceHelper.idPublisher:
                    {
                        IBuiltInEvidence p = new Publisher();
                        position = p.InitFromBuffer(buffer, position);
                        AddHost(p);
                        break;
                    }
                    case BuiltInEvidenceHelper.idStrongName:
                    {
                        IBuiltInEvidence sn = new StrongName();
                        position = sn.InitFromBuffer(buffer, position);
                        AddHost(sn);
                        break;
                    }
                    case BuiltInEvidenceHelper.idZone:
                    {
                        IBuiltInEvidence z = new Zone();
                        position = z.InitFromBuffer(buffer, position);
                        AddHost(z);
                        break;
                    }
                    case BuiltInEvidenceHelper.idUrl:
                    {
                        IBuiltInEvidence u = new Url();
                        position = u.InitFromBuffer(buffer, position);
                        AddHost(u);
                        break;
                    }
                    case BuiltInEvidenceHelper.idSite:
                    {
                        IBuiltInEvidence s = new Site();
                        position = s.InitFromBuffer(buffer, position);
                        AddHost(s);
                        break;
                    }
                    case BuiltInEvidenceHelper.idPermissionRequestEvidence:
                    {
                        IBuiltInEvidence pre = new PermissionRequestEvidence();
                        position = pre.InitFromBuffer(buffer, position);
                        AddHost(pre);
                        break;
                    }
                    case BuiltInEvidenceHelper.idHash:
                    {
                        IBuiltInEvidence h = new Hash();
                        position = h.InitFromBuffer(buffer, position);
                        AddHost(h);
                        break;
                    }
                    default:
                        throw new SerializationException(Environment.GetResourceString("Serialization_UnableToFixup"));

                } // switch
            } // while
        }


        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.AddHost"]/*' />
        public void AddHost(Object id)
        {
            if (m_hostList == null)
                m_hostList = ArrayList.Synchronized( new ArrayList() );
                
            if (m_locked)
                new SecurityPermission( SecurityPermissionFlag.ControlEvidence ).Demand();

            m_hostList.Add( id );
        }
        
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.AddAssembly"]/*' />
        public void AddAssembly(Object id)
        {
            if (m_assemblyList == null)
                m_assemblyList = ArrayList.Synchronized( new ArrayList() );
                
            m_assemblyList.Add( id );
        }


        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.Locked"]/*' />
        public bool Locked
        {
            get
            {
                return m_locked;
            }

            set
            {
                if (!value)
                {
                    new SecurityPermission( SecurityPermissionFlag.ControlEvidence ).Demand();

                    m_locked = false;
                }
                else
                {
                    m_locked = true;
                }
            }
        }
        
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.Merge"]/*' />
        public void Merge( Evidence evidence )
        {
            IEnumerator enumerator;
        
            if (evidence == null)
                return;
                
            if (evidence.m_hostList != null)                
            {
                if (m_hostList == null)
                    m_hostList = ArrayList.Synchronized( new ArrayList() );

                if (evidence.m_hostList.Count != 0 && this.m_locked)
                    new SecurityPermission( SecurityPermissionFlag.ControlEvidence ).Demand();
                    
                enumerator = evidence.m_hostList.GetEnumerator();
                
                while (enumerator.MoveNext())
                {
                    m_hostList.Add( enumerator.Current );
                }
            }
             
            if (evidence.m_assemblyList != null)
            {    
                if (m_assemblyList == null)
                    m_assemblyList = ArrayList.Synchronized( new ArrayList() );
            
                enumerator = evidence.m_assemblyList.GetEnumerator();
                
                while (enumerator.MoveNext())
                {
                    m_assemblyList.Add( enumerator.Current );
                }
                
            }
        }

        // Same as merge, except only one instance of any one evidence type is
        // allowed. When duplicates are found, the evidence in the input
        // argument will have priority.
        internal void MergeWithNoDuplicates( Evidence evidence )
        {
            IEnumerator oldEnumerator, newEnumerator;
        
            if (evidence == null)
                return;
                
            if (evidence.m_hostList != null)                
            {
                if (m_hostList == null)
                    m_hostList = ArrayList.Synchronized( new ArrayList() );
                    
                newEnumerator = evidence.m_hostList.GetEnumerator();
                
                while (newEnumerator.MoveNext())
                {
                    Type newItemType = newEnumerator.Current.GetType();
                    oldEnumerator = m_hostList.GetEnumerator();
                    while (oldEnumerator.MoveNext())
                    {
                        if (oldEnumerator.Current.GetType() == newItemType)
                        {
                            m_hostList.Remove(oldEnumerator.Current);
                            break;
                        }
                    }
                    m_hostList.Add( newEnumerator.Current );
                }
            }
             
            if (evidence.m_assemblyList != null)
            {    
                if (m_assemblyList == null)
                    m_assemblyList = ArrayList.Synchronized( new ArrayList() );
            
                newEnumerator = evidence.m_assemblyList.GetEnumerator();
                
                while (newEnumerator.MoveNext())
                {
                    Type newItemType = newEnumerator.Current.GetType();
                    oldEnumerator = m_assemblyList.GetEnumerator();
                    while (oldEnumerator.MoveNext())
                    {
                        if (oldEnumerator.Current.GetType() == newItemType)
                        {
                            m_assemblyList.Remove(oldEnumerator.Current);
                            break;
                        }
                    }
                    m_assemblyList.Add( newEnumerator.Current );
                }
                
            }
        }

        // ICollection implementation
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.CopyTo"]/*' />
        public void CopyTo(Array array, int index)
        {
            int currentIndex = index;
        
            if (m_hostList != null)
            {
                m_hostList.CopyTo( array, currentIndex );
                currentIndex += m_hostList.Count;
            }
            
            if (m_assemblyList != null)
            {
                m_assemblyList.CopyTo( array, currentIndex );
            }
        }

        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.GetHostEnumerator"]/*' />
        public IEnumerator GetHostEnumerator()
        {
            if  (m_hostList == null)
                m_hostList = ArrayList.Synchronized( new ArrayList() );
            
            return m_hostList.GetEnumerator();
        }
        
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.GetAssemblyEnumerator"]/*' />
        public IEnumerator GetAssemblyEnumerator()
        {
            if (m_assemblyList == null)
                m_assemblyList = ArrayList.Synchronized( new ArrayList() );
                
            return m_assemblyList.GetEnumerator();
        }
        
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator()
        {
            return new EvidenceEnumerator( this );
        }
        
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.Count"]/*' />
        public int Count
        { 
            get { return (m_hostList != null ? m_hostList.Count : 0) + (m_assemblyList != null ? m_assemblyList.Count : 0); }
        }
         
        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.SyncRoot"]/*' />
        public Object SyncRoot
        {
            get { return this; }
        }

        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.IsSynchronized"]/*' />
        public bool IsSynchronized
        {
            get { return true; }
        }

        /// <include file='doc\Evidence.uex' path='docs/doc[@for="Evidence.IsReadOnly"]/*' />
        public bool IsReadOnly
        {
            get { return false; }
        }
        
        internal Evidence Copy()
        {
            new PermissionSet( true ).Assert();

            MemoryStream stream = new MemoryStream();

            BinaryFormatter formatter = new BinaryFormatter();

            formatter.Serialize( stream, this );

            stream.Position = 0;

            return (Evidence)formatter.Deserialize( stream );
        }

        internal Evidence ShallowCopy()
        {
            Evidence evidence = new Evidence();
            
            IEnumerator enumerator;
            
            enumerator = this.GetHostEnumerator();
            
            while (enumerator.MoveNext())
            {
                evidence.AddHost( enumerator.Current );
            }
            
            enumerator = this.GetAssemblyEnumerator();
            
            while (enumerator.MoveNext())
            {
                evidence.AddAssembly( enumerator.Current );
            }
            
            return evidence;
        }            
    }
    
    sealed class EvidenceEnumerator : IEnumerator
    {
        private bool m_first;
        private Evidence m_evidence;
        private IEnumerator m_enumerator;
        
        public EvidenceEnumerator( Evidence evidence )
        {
            this.m_evidence = evidence;
            Reset();
        }
    
        public bool MoveNext()
        {
            if (m_enumerator == null)
            {
                return false;
            }
        
            if (!m_enumerator.MoveNext())
            {
                if (m_first)
                {
                    m_enumerator = m_evidence.GetAssemblyEnumerator();
                    m_first = false;
                    if (m_enumerator != null)
                        return m_enumerator.MoveNext();
                    else
                        return false;
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
        
        public Object Current 
        {
            get {
                if (m_enumerator == null)
                    return null;
                else
                    return m_enumerator.Current;
            }
        }

        public void Reset() {
            this.m_first = true;
            
            if (m_evidence != null)
            {
                m_enumerator = m_evidence.GetHostEnumerator();
            }
            else
            {
                m_enumerator = null;
            }
        }

    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\filecodegroup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  FileCodeGroup.cs
//
//  Representation for code groups used for the policy mechanism
//

namespace System.Security.Policy {
    
    using System;
    using System.Security.Util;
    using System.Security;
    using System.Collections;
	using System.Reflection;
    using System.Security.Permissions;
    using System.Globalization;
    
    /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup"]/*' />
    [Serializable]
    sealed public class FileCodeGroup : CodeGroup
    {
        [System.Diagnostics.Conditional( "_DEBUG" )]
        private static void DEBUG_OUT( String str )
        {
#if _DEBUG        
            if (debug)
            {
                if (to_file)
                {
                    System.Text.StringBuilder sb = new System.Text.StringBuilder();
                    sb.Append( str );
                    sb.Append ((char)13) ;
                    sb.Append ((char)10) ;
                    PolicyManager._DebugOut( file, sb.ToString() );
                }
                else
                    Console.WriteLine( str );
             }
#endif             
        }
        
#if _DEBUG
        private static bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "c:\\com99\\src\\bcl\\debug.txt";
#endif  

        private FileIOPermissionAccess m_access;

        internal FileCodeGroup()
            : base()
        {
        }

        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.FileCodeGroup"]/*' />
        public FileCodeGroup( IMembershipCondition membershipCondition, FileIOPermissionAccess access )
            : base( membershipCondition, (PolicyStatement)null )
        {
            m_access = access;
        }

        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.Resolve"]/*' />
        public override PolicyStatement Resolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");
                
            if (this.MembershipCondition.Check( evidence ))
            {
                PolicyStatement thisPolicy = null;
                
                IEnumerator evidenceEnumerator = evidence.GetHostEnumerator();

                while (evidenceEnumerator.MoveNext())
                {
                    Url url = evidenceEnumerator.Current as Url;

                    if (url != null)
                    {
                        thisPolicy = CalculatePolicy( url );
                    }
                }

                if (thisPolicy == null)
                    thisPolicy = new PolicyStatement( new PermissionSet( false ), PolicyStatementAttribute.Nothing );

                IEnumerator enumerator = this.Children.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    PolicyStatement childPolicy = ((CodeGroup)enumerator.Current).Resolve( evidence );

                    if (childPolicy != null)
                    {
                        if (((thisPolicy.Attributes & childPolicy.Attributes) & PolicyStatementAttribute.Exclusive) == PolicyStatementAttribute.Exclusive)
                        {
                            throw new PolicyException( Environment.GetResourceString( "Policy_MultipleExclusive" ) );
                        }

                        thisPolicy.GetPermissionSetNoCopy().InplaceUnion( childPolicy.GetPermissionSetNoCopy() );
                        thisPolicy.Attributes = thisPolicy.Attributes | childPolicy.Attributes;
                    }
                }

                return thisPolicy;
            }           
            else
            {
                return null;
            }
        }        

        internal PolicyStatement InternalResolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");
            

            if (this.MembershipCondition.Check( evidence ))
            {
                IEnumerator evidenceEnumerator = evidence.GetHostEnumerator();

                while (evidenceEnumerator.MoveNext())
                {
                    Url url = evidenceEnumerator.Current as Url;

                    if (url != null)
                    {
                        return CalculatePolicy( url );
                    }
                }
            }

            return null;
        }

        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.ResolveMatchingCodeGroups"]/*' />
        public override CodeGroup ResolveMatchingCodeGroups( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");

            if (this.MembershipCondition.Check( evidence ))
            {
                CodeGroup retGroup = this.Copy();

                retGroup.Children = new ArrayList();

                IEnumerator enumerator = this.Children.GetEnumerator();
                
                while (enumerator.MoveNext())
                {
                    CodeGroup matchingGroups = ((CodeGroup)enumerator.Current).ResolveMatchingCodeGroups( evidence );
                    
                    // If the child has a policy, we are done.
                    
                    if (matchingGroups != null)
                    {
                        retGroup.AddChild( matchingGroups );
                    }
                }

                return retGroup;
                
            }
            else
            {
                return null;
            }
        }

        private PolicyStatement CalculatePolicy( Url url )
        {
            URLString urlString = url.GetURLString();

            if (String.Compare( urlString.Scheme, "file", true, CultureInfo.InvariantCulture) != 0)
                return null;

            String directory = urlString.GetDirectoryName();
            
            PermissionSet permSet = new PermissionSet( PermissionState.None );
            permSet.SetPermission( new FileIOPermission( m_access, directory ) );

            return new PolicyStatement( permSet, PolicyStatementAttribute.Nothing );
        }
        
        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.Copy"]/*' />
        public override CodeGroup Copy()
        {
            FileCodeGroup group = new FileCodeGroup( this.MembershipCondition, this.m_access );
            
            group.Name = this.Name;
            group.Description = this.Description;

            IEnumerator enumerator = this.Children.GetEnumerator();

            while (enumerator.MoveNext())
            {
                group.AddChild( (CodeGroup)enumerator.Current );
            }
            
            return group;
        }
        
        
        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.MergeLogic"]/*' />
        public override String MergeLogic
        {
            get
            {
                return Environment.GetResourceString( "MergeLogic_Union" );
            }
        }
        
        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.PermissionSetName"]/*' />
        public override String PermissionSetName
        {
            get
            {
                return String.Format( Environment.GetResourceString( "FileCodeGroup_PermissionSet" ), XMLUtil.BitFieldEnumToString( typeof( FileIOPermissionAccess ), m_access ) );
            }
        }

        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.AttributeString"]/*' />
        public override String AttributeString
        {
            get
            {
                return null;
            }
        }  

        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.CreateXml"]/*' />
        protected override void CreateXml( SecurityElement element, PolicyLevel level )
        {
            element.AddAttribute( "Access", XMLUtil.BitFieldEnumToString( typeof( FileIOPermissionAccess ), m_access ) );
        }
        
        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.ParseXml"]/*' />
        protected override void ParseXml( SecurityElement e, PolicyLevel level )
        {
            String access = e.Attribute( "Access" );

            if (access != null)
                m_access = (FileIOPermissionAccess) Enum.Parse( typeof( FileIOPermissionAccess ), access );
            else
                m_access = FileIOPermissionAccess.NoAccess;
        }
 
        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.Equals"]/*' />
        public override bool Equals( Object o)
        {
            FileCodeGroup that = (o as FileCodeGroup);
            
            if (that != null && base.Equals( that ))
            {
                if (this.m_access == that.m_access)
                    return true;
            }
            return false;
        }
            
        /// <include file='doc\FileCodeGroup.uex' path='docs/doc[@for="FileCodeGroup.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return base.GetHashCode() + m_access.GetHashCode();
        }
    }   

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\firstmatchcodegroup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  FirstMatchCodeGroup.cool
//
//  Representation for code groups used for the policy mechanism
//

namespace System.Security.Policy {
    
    using System;
    using System.Security.Util;
    using System.Security;
    using System.Collections;
    
    /// <include file='doc\FirstMatchCodeGroup.uex' path='docs/doc[@for="FirstMatchCodeGroup"]/*' />
    [Serializable]
    sealed public class FirstMatchCodeGroup : CodeGroup
    {
        internal FirstMatchCodeGroup()
            : base()
        {
        }
        
        /// <include file='doc\FirstMatchCodeGroup.uex' path='docs/doc[@for="FirstMatchCodeGroup.FirstMatchCodeGroup"]/*' />
        public FirstMatchCodeGroup( IMembershipCondition membershipCondition, PolicyStatement policy )
            : base( membershipCondition, policy )
        {
        }
        
        
        /// <include file='doc\FirstMatchCodeGroup.uex' path='docs/doc[@for="FirstMatchCodeGroup.Resolve"]/*' />
        public override PolicyStatement Resolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");
                
            if (this.MembershipCondition.Check( evidence ))
            {
                PolicyStatement childPolicy = null;

                IEnumerator enumerator = this.Children.GetEnumerator();
                
                while (enumerator.MoveNext())
                {
                    childPolicy = ((CodeGroup)enumerator.Current).Resolve( evidence );
                    
                    // If the child has a policy, we are done.
                    
                    if (childPolicy != null)
                        break;
                }
                
                PolicyStatement thisPolicy = this.PolicyStatement;

                if (thisPolicy == null)
                {
                    return childPolicy;
                }
                else if (childPolicy != null)
                {
                    // Combine the child and this policy and return it.
                
                    PolicyStatement combined = new PolicyStatement();

                    combined.SetPermissionSetNoCopy( thisPolicy.GetPermissionSetNoCopy().Union( childPolicy.GetPermissionSetNoCopy() ) );
                    
                    // if both this group and matching child group are exclusive we need to throw an exception
                    
                    if (((thisPolicy.Attributes & childPolicy.Attributes) & PolicyStatementAttribute.Exclusive) == PolicyStatementAttribute.Exclusive)
                        throw new PolicyException( Environment.GetResourceString( "Policy_MultipleExclusive" ) );
                        
                    combined.Attributes = thisPolicy.Attributes | childPolicy.Attributes;
                    
                    return combined;
                }
                else
                {  
                    // Otherwise we just copy the this policy.
                
                    return this.PolicyStatement;
                }
            }
            else
            {
                return null;
            }        
        }
        
        /// <include file='doc\FirstMatchCodeGroup.uex' path='docs/doc[@for="FirstMatchCodeGroup.ResolveMatchingCodeGroups"]/*' />
        public override CodeGroup ResolveMatchingCodeGroups( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");

            if (this.MembershipCondition.Check( evidence ))
            {
                CodeGroup retGroup = this.Copy();

                retGroup.Children = new ArrayList();

                IEnumerator enumerator = this.Children.GetEnumerator();
                
                while (enumerator.MoveNext())
                {
                    CodeGroup matchingGroups = ((CodeGroup)enumerator.Current).ResolveMatchingCodeGroups( evidence );
                    
                    // If the child has a policy, we are done.
                    
                    if (matchingGroups != null)
                    {
                        retGroup.AddChild( matchingGroups );
                        break;
                    }
                }

                return retGroup;
                
            }
            else
            {
                return null;
            }
        }
        
        /// <include file='doc\FirstMatchCodeGroup.uex' path='docs/doc[@for="FirstMatchCodeGroup.Copy"]/*' />
        public override CodeGroup Copy()
        {
            FirstMatchCodeGroup group = new FirstMatchCodeGroup();
            
            group.MembershipCondition = this.MembershipCondition;
            group.PolicyStatement = this.PolicyStatement;
            group.Name = this.Name;
            group.Description = this.Description;

            IEnumerator enumerator = this.Children.GetEnumerator();

            while (enumerator.MoveNext())
            {
                group.AddChild( (CodeGroup)enumerator.Current );
            }
           
            return group;
        }
        
        
        /// <include file='doc\FirstMatchCodeGroup.uex' path='docs/doc[@for="FirstMatchCodeGroup.MergeLogic"]/*' />
        public override String MergeLogic
        {
            get
            {
                return Environment.GetResourceString( "MergeLogic_FirstMatch" );
            }
        }     
    }   
        

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\hash.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Hash
//
// Evidence corresponding to a hash of the assembly bits.
//

namespace System.Security.Policy
{

    using System;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Cryptography;
    using System.Security.Util;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Runtime.Serialization;

    /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash"]/*' />
    [Serializable]
    sealed public class Hash : ISerializable, IBuiltInEvidence
    {
        private Assembly m_assembly;
        private byte[] m_sha1;
        private byte[] m_md5;
        private byte[] m_rawData;
        
        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.Hash"]/*' />
        public Hash( Assembly assembly )
        {
            if (assembly == null)
                throw new ArgumentNullException( "assembly" );
        
            m_assembly = assembly;
            m_sha1 = null;
            m_md5 = null;
            m_rawData = null;
        }

        internal Hash( SerializationInfo info, StreamingContext context )
        {
            m_rawData = (byte[])info.GetValue( "RawData", typeof( byte[] ) );
        }

        internal Hash()
        {
        }

        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.GetObjectData"]/*' />
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (m_rawData == null) {
                if (m_assembly == null)
                    throw new ArgumentException(Environment.GetResourceString("ArgumentNull_Assembly"));

                m_rawData = _GetRawData( m_assembly );
            }

            new System.Security.Permissions.SecurityPermission( System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode ).Demand();
            info.AddValue( "RawData", m_rawData );
        }

        
        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.SHA1"]/*' />
        public byte[] SHA1
        {
            get
            {
                if (m_sha1 == null)
                {
                    if (m_rawData == null)
                    {
                        m_rawData = _GetRawData( m_assembly );
                    
                        if (m_rawData == null)
                        {
                            m_rawData = new byte[1];
                            m_rawData[0] = 0;
                        }
                    }

                    System.Security.Cryptography.SHA1 hashAlg = new System.Security.Cryptography.SHA1Managed();
                    m_sha1 = hashAlg.ComputeHash(m_rawData);

                }
                
                byte[] retval = new byte[m_sha1.Length];
                Array.Copy( m_sha1, retval, m_sha1.Length );
                return retval;
            }
        }
        

        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.MD5"]/*' />
        public byte[] MD5
        {
            get
            {
                if (m_md5 == null)
                {
                    if (m_rawData == null)
                    {
                        m_rawData = _GetRawData( m_assembly );
                    
                        if (m_rawData == null)
                        {
                            m_rawData = new byte[1];
                            m_rawData[0] = 0;
                        }
                    }

                    System.Security.Cryptography.MD5 hashAlg = new MD5CryptoServiceProvider();
                    m_md5 = hashAlg.ComputeHash(m_rawData);

                }
                
                byte[] retval = new byte[m_md5.Length];
                Array.Copy( m_md5, retval, m_md5.Length );
                return retval;
            }
        }

        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.GenerateHash"]/*' />
        public byte[] GenerateHash( HashAlgorithm hashAlg )
        {
            if (hashAlg == null)
                throw new ArgumentNullException( "hashAlg" );
        
            if (m_rawData == null)
            {
                m_rawData = _GetRawData( m_assembly );
                    
                if (m_rawData == null)
                {
                    throw new SecurityException( Environment.GetResourceString( "Security_CannotGenerateHash" ) );
                }
            }

            // Each hash algorithm object can only be used once.  Therefore, if we
            // have used the hash algorithm, make a new one and use it instead.
            // Note: we detect having used one before by it throwing an exception.

            try
            {
                hashAlg.ComputeHash( m_rawData );
            }
            catch (System.Security.Cryptography.CryptographicUnexpectedOperationException)
            {
                hashAlg = HashAlgorithm.Create( hashAlg.GetType().FullName );
                hashAlg.ComputeHash( m_rawData );
            }

            return hashAlg.Hash;
        }

        internal SecurityElement ToXml()
        {
            SecurityElement root = new SecurityElement( this.GetType().FullName );
            root.AddAttribute( "version", "1" );
            
            if (m_rawData == null)
            {
                m_rawData = _GetRawData( m_assembly );
            }
            
            root.AddChild( new SecurityElement( "RawData", Hex.EncodeHexString( m_rawData ) ) );
            
            return root;
        }
    
        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            if (!verbose)
                return position;

            buffer[position++] = BuiltInEvidenceHelper.idHash;

            if (m_rawData == null)
                m_rawData = _GetRawData( m_assembly );
            int length = ((m_rawData.Length - 1) / 2) + 1;

            BuiltInEvidenceHelper.CopyIntToCharArray(m_rawData.Length, buffer, position);
            position += 2;

            Buffer.InternalBlockCopy(m_rawData, 0, buffer, position * 2, m_rawData.Length);

            return position + length;
        }

        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose)
        {
            if (verbose)
            {
                if (m_rawData == null) {
                    m_rawData = _GetRawData( m_assembly );

                    if (m_rawData == null)
                        return 0;
                }
                int length = ((m_rawData.Length - 1) / 2) + 1;
                return (1 + 2 + length);    // identifier + length + blob
            }
            else
                return 0;
        }

        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position )
        {
            int length = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;
            m_rawData = new byte[length];

            int lengthInChars = ((length - 1) / 2) + 1;
            Buffer.InternalBlockCopy(buffer, position * 2, m_rawData, 0, length);

            return position + lengthInChars;
        }

        internal bool HasBeenAccessed
        {
            get
            {
                return m_rawData != null;
            }
        }
        
        /// <include file='doc\Hash.uex' path='docs/doc[@for="Hash.ToString"]/*' />
        public override String ToString()
        {
            return ToXml().ToString();
        }


        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern byte[] _GetRawData( Assembly assembly );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\ibuiltinevidence.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IBuiltInEvidence.cs
//

namespace System.Security.Policy
{
	using System;
	using System.IO;

    internal interface IBuiltInEvidence
    {
        int OutputToBuffer( char[] buffer, int position, bool verbose );

        // Initializes a class according to data in the buffer. Returns new position within buffer
        int InitFromBuffer( char[] buffer, int position);

        int GetRequiredSize(bool verbose);

    }

    internal class BuiltInEvidenceHelper
    {
        internal const char idApplicationDirectory = (char)0;
        internal const char idPublisher = (char)1;
        internal const char idStrongName = (char)2;
        internal const char idZone = (char)3;
        internal const char idUrl = (char)4;
        internal const char idWebPage = (char)5;
        internal const char idSite = (char)6;
        internal const char idPermissionRequestEvidence = (char)7;
        internal const char idHash = (char)8;

        internal static void CopyIntToCharArray( int value, char[] buffer, int position )
        {
            buffer[position    ] = (char)((value >> 16) & 0x0000FFFF);
            buffer[position + 1] = (char)((value      ) & 0x0000FFFF);
        }

        internal static int GetIntFromCharArray(char[] buffer, int position )
        {
            int value = (int)buffer[position];
            value = value << 16;
            value += (int)buffer[position + 1];
            return value;
        }
    }
            

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\iidentitypermissionfactory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IIdentityPermissionFactory.cool
//
//  All Identities will implement this interface.
//

namespace System.Security.Policy {
	using System.Runtime.Remoting;
	using System;
	using System.Security.Util;
    /// <include file='doc\IIdentityPermissionFactory.uex' path='docs/doc[@for="IIdentityPermissionFactory"]/*' />
    public interface IIdentityPermissionFactory
    {
        /// <include file='doc\IIdentityPermissionFactory.uex' path='docs/doc[@for="IIdentityPermissionFactory.CreateIdentityPermission"]/*' />
        IPermission CreateIdentityPermission( Evidence evidence );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\iconstantmembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IConstantMembershipCondition.cool
//
//  Interface that all constant membership conditions must implement
//

namespace System.Security.Policy {
    
    using System;
    
    internal interface IConstantMembershipCondition
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\hashmembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  HashMembershipCondition.cool
//
//  Implementation of membership condition for hashes of assemblies.
//

namespace System.Security.Policy {
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Policy;
    using System.Security.Cryptography;
    using System.Collections;

    /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition"]/*' />
    [Serializable]
    sealed public class HashMembershipCondition : IMembershipCondition
    {
        // Note: this is not a constant membership condition because
        // we don't want to generate the hash to store in the cache.

        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private byte[] m_value;
        private HashAlgorithm m_hashAlg;
        private SecurityElement m_element;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        internal HashMembershipCondition()
        {
            m_element = null;
            m_value = null;
        }
        
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.HashMembershipCondition"]/*' />
        public HashMembershipCondition( HashAlgorithm hashAlg, byte[] value )
        {
            if (value == null)
                throw new ArgumentNullException( "value" );
                
            if (hashAlg == null)
                throw new ArgumentNullException( "hashAlg" );

            m_value = new byte[value.Length];
            Array.Copy( value, m_value, value.Length );
            m_hashAlg = hashAlg;
        }
    
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
    
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.HashAlgorithm"]/*' />
        public System.Security.Cryptography.HashAlgorithm HashAlgorithm
        {
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "HashAlgorithm" );
            
                m_hashAlg = value;
            }
            
            get
            {
                if (m_hashAlg == null && m_element != null)
                    ParseHashAlgorithm();
                    
                return m_hashAlg;
            }
        }
    
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.HashValue"]/*' />
        public byte[] HashValue
        {
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "value" );

                m_value = new byte[value.Length];
                Array.Copy( value, m_value, value.Length );
            }

            get
            {
                if (m_value == null && m_element != null)
                    ParseHashValue();
            
                if (m_value != null)
                {
                    byte[] value = new byte[m_value.Length];
                    Array.Copy( m_value, value, m_value.Length );
                    return value;
                }                
                else
                    return null;
            }
        }
        
        //------------------------------------------------------
        //
        // IMEMBERSHIPCONDITION IMPLEMENTATION
        //
        //------------------------------------------------------
    
        private static bool CompareArrays( byte[] first, byte[] second )
        {
            if (first.Length != second.Length)
                return false;
            
            int count = first.Length;
            for (int i = 0; i < count; ++i)
            {
                if (first[i] != second[i])
                    return false;
            }
            
            return true;
        }            
    
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            if (evidence == null)
                return false;
        
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                Object obj = enumerator.Current;
            
                if (obj is Hash)
                {
                    if (m_value == null && m_element != null)
                        ParseHashValue();
                        
                    if (m_hashAlg == null && m_element != null)
                        ParseHashAlgorithm();

                    byte[] asmHash = null;
                    asmHash = ((Hash)obj).GenerateHash( m_hashAlg );
                
                    if (asmHash != null && CompareArrays( asmHash, m_value ))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            if (m_value == null && m_element != null)
                ParseHashValue();
                    
            if (m_hashAlg == null && m_element != null)
                ParseHashAlgorithm();
                    
            return new HashMembershipCondition( m_hashAlg, m_value );
        }
       
        private const String s_tagHashValue = "HashValue";
        private const String s_tagHashAlgorithm = "HashAlgorithm";
        
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            if (m_value == null && m_element != null)
                ParseHashValue();

            if (m_hashAlg == null && m_element != null)
                ParseHashAlgorithm();
        
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            if (m_value != null)
                root.AddAttribute( s_tagHashValue, System.Security.Util.Hex.EncodeHexString( HashValue ) );

            if (m_hashAlg != null)
                root.AddAttribute( s_tagHashAlgorithm, HashAlgorithm.GetType().FullName );
            
            return root;
        }
    
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");
        
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
            
            lock (this)
            {
                m_element = e;
                m_value = null;
                m_hashAlg = null;
            }
        }
        
        private void ParseHashValue()
        {
            lock (this)
            {
                if (m_element == null)
                    return;

                String elHash = m_element.Attribute( s_tagHashValue );
            
                if (elHash != null)
                    m_value = System.Security.Util.Hex.DecodeHexString( elHash );
                else
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidXMLElement" ), s_tagHashValue, this.GetType().FullName ) );
                
                if (m_value != null && m_hashAlg != null)
                {
                    m_element = null;
                }
            }    
        }    
            
        private void ParseHashAlgorithm()
        {
            lock (this)
            {
                if (m_element == null)
                    return;
                
                String elHashAlg = m_element.Attribute( s_tagHashAlgorithm );
            
                if (elHashAlg != null)
                    m_hashAlg = System.Security.Cryptography.HashAlgorithm.Create( elHashAlg );
                else
                    m_hashAlg = new SHA1Managed();
                
                if (m_value != null && m_hashAlg != null)
                {
                    m_element = null;
                }
            }
        }
        
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            HashMembershipCondition that = (o as HashMembershipCondition);
            
            if (that != null)
            {
                if (this.m_hashAlg == null && this.m_element != null)
                    this.ParseHashAlgorithm();
                if (that.m_hashAlg == null && that.m_element != null)
                    that.ParseHashAlgorithm();
                
                if (Equals( this.m_hashAlg, that.m_hashAlg ))
                {
                    if (this.m_value == null && this.m_element != null)
                        this.ParseHashValue();
                    if (that.m_value == null && that.m_element != null)
                        that.ParseHashValue();
                    
                    if (this.m_value.Length != that.m_value.Length)
                        return false;
                    
                    for (int i = 0; i < m_value.Length; i++)
                    {
                        if (this.m_value[i] != that.m_value[i])
                            return false;
                    }
                    
                    return true;
                }
            }
            return false;
        }
        
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (m_value == null && m_element != null)
                ParseHashValue();
            
            if (m_value != null)
            {
                int valueHash = 0;
                for (int i = 0; i < 4 && i < m_value.Length; i++)
                    valueHash = (valueHash << 8) + m_value[i];
                return valueHash;
            }
            else
            {
                return typeof( HashMembershipCondition ).GetHashCode();
            }
        }
        
        /// <include file='doc\HashMembershipCondition.uex' path='docs/doc[@for="HashMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            if (m_hashAlg == null)
                ParseHashAlgorithm();
        
            return String.Format( Environment.GetResourceString( "Hash_ToString" ), m_hashAlg.GetType().AssemblyQualifiedName, System.Security.Util.Hex.EncodeHexString( HashValue ) );
        }                   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\imembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IMembershipCondition.cool
//
//  Interface that all MembershipConditions must implement
//

namespace System.Security.Policy {
    
	using System;
    /// <include file='doc\IMembershipCondition.uex' path='docs/doc[@for="IMembershipCondition"]/*' />
    public interface IMembershipCondition : ISecurityEncodable, ISecurityPolicyEncodable
    {
        /// <include file='doc\IMembershipCondition.uex' path='docs/doc[@for="IMembershipCondition.Check"]/*' />
        bool Check( Evidence evidence );
        /// <include file='doc\IMembershipCondition.uex' path='docs/doc[@for="IMembershipCondition.Copy"]/*' />
    
        IMembershipCondition Copy();
        /// <include file='doc\IMembershipCondition.uex' path='docs/doc[@for="IMembershipCondition.ToString"]/*' />
        
        String ToString();
        /// <include file='doc\IMembershipCondition.uex' path='docs/doc[@for="IMembershipCondition.Equals"]/*' />

        bool Equals( Object obj );
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\permissionrequestevidence.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PermissionRequestEvidence.cs
//
//  Encapsulation of permission request as an evidence type.
//

namespace System.Security.Policy {
	using System.Runtime.Remoting;
	using System;
	using System.IO;
	using System.Security.Util;
	using System.Collections;
    using System.Runtime.Serialization;

    /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence"]/*' />
    [Serializable]
    sealed public class PermissionRequestEvidence : IBuiltInEvidence
    {
        private PermissionSet m_request;
        private PermissionSet m_optional;
        private PermissionSet m_denied;
        private String m_strRequest;
        private String m_strOptional;
        private String m_strDenied;
        private const char idRequest = (char)0;
        private const char idOptional = (char)1;
        private const char idDenied = (char)2;
    
        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.PermissionRequestEvidence"]/*' />
        public PermissionRequestEvidence(PermissionSet request, PermissionSet optional, PermissionSet denied)
        {
            if (request == null)
                m_request = null;
            else
                m_request = request.Copy();
                
            if (optional == null)
                m_optional = null;
            else
                m_optional = optional.Copy();
                
            if (denied == null)
                m_denied = null;
            else
                m_denied = denied.Copy();
        }
    
        internal PermissionRequestEvidence()
        {
        }

        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.RequestedPermissions"]/*' />
        public PermissionSet RequestedPermissions
        {
            get
            {
                return m_request;
            }
        }
        
        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.OptionalPermissions"]/*' />
        public PermissionSet OptionalPermissions
        {
            get
            {
                return m_optional;
            }
        }
        
        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.DeniedPermissions"]/*' />
        public PermissionSet DeniedPermissions
        {
            get
            {
                return m_denied;
            }
        }
    
        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.Copy"]/*' />
        public PermissionRequestEvidence Copy()
        {
            return new PermissionRequestEvidence(m_request, m_optional, m_denied);
        }
    
        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.ToXml"]/*' />
        internal SecurityElement ToXml() {
            SecurityElement root = new SecurityElement( this.GetType().FullName );
            root.AddAttribute( "version", "1" );
            
            SecurityElement elem;
            
            if (m_request != null)
            {
                elem = new SecurityElement( "Request" );
                elem.AddChild( m_request.ToXml() );
                root.AddChild( elem );
            }
                
            if (m_optional != null)
            {
                elem = new SecurityElement( "Optional" );
                elem.AddChild( m_optional.ToXml() );
                root.AddChild( elem );
            }
                
            if (m_denied != null)
            {
                elem = new SecurityElement( "Denied" );
                elem.AddChild( m_denied.ToXml() );
                root.AddChild( elem );
            }
            
            return root;
        }
    

        internal void CreateStrings()
        {
            if (m_strRequest == null && m_request != null)
                m_strRequest = m_request.ToXml().ToString();

            if (m_strOptional == null && m_optional != null)
                m_strOptional = m_optional.ToXml().ToString();

            if (m_strDenied == null && m_denied != null)
                m_strDenied = m_denied.ToXml().ToString();
        }

        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            CreateStrings();

            int currentPosition = position;
            int numPermSetsPos = 0, numPermSets = 0;
            int tempLength;

            buffer[currentPosition++] = BuiltInEvidenceHelper.idPermissionRequestEvidence;

            if (verbose)
            {
                // Reserve some space to store the number of permission sets added
                numPermSetsPos = currentPosition;
                currentPosition += 2;
            }

            if (m_strRequest != null)
            {
                tempLength = m_strRequest.Length;
                if (verbose)
                {
                    buffer[currentPosition++] = idRequest;
                    BuiltInEvidenceHelper.CopyIntToCharArray(tempLength, buffer, currentPosition);
                    currentPosition += 2;
                    numPermSets++;
                }
                m_strRequest.CopyTo( 0, buffer, currentPosition, tempLength );
                currentPosition += tempLength;
            }

            if (m_strOptional != null)
            {
                tempLength = m_strOptional.Length;
                if (verbose)
                {
                    buffer[currentPosition++] = idOptional;
                    BuiltInEvidenceHelper.CopyIntToCharArray(tempLength, buffer, currentPosition);
                    currentPosition += 2;
                    numPermSets++;
                }
                m_strOptional.CopyTo( 0, buffer, currentPosition, tempLength );
                currentPosition += tempLength;
            }

            if (m_strDenied != null)
            {
                tempLength = m_strDenied.Length;
                if (verbose)
                {
                    buffer[currentPosition++] = idDenied;
                    BuiltInEvidenceHelper.CopyIntToCharArray(tempLength, buffer, currentPosition);
                    currentPosition += 2;
                    numPermSets++;
                }
                m_strDenied.CopyTo( 0, buffer, currentPosition, tempLength );
                currentPosition += tempLength;
            }

            if (verbose)
                    BuiltInEvidenceHelper.CopyIntToCharArray(numPermSets, buffer, numPermSetsPos);

            return currentPosition;
        }

        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose )
        {
            CreateStrings();

            int currentPosition = 1;

            if (m_strRequest != null)
            {
                if (verbose)
                    currentPosition += 3;   // identifier + length
                currentPosition += m_strRequest.Length;
            }

            if (m_strOptional != null)
            {
                if (verbose)
                    currentPosition += 3;
                currentPosition += m_strOptional.Length;
            }

            if (m_strDenied != null)
            {
                if (verbose)
                    currentPosition += 3;
                currentPosition += m_strDenied.Length;
            }

            if (verbose)
                currentPosition += 2;   // Number of permission sets in the evidence

            return currentPosition;
        }

        /// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position )
        {
            int numPermSets = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;

            int tempLength;
            for (int i = 0; i < numPermSets; i++)
            {
                char psKind = buffer[position++];

                tempLength = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
                position += 2;

                String tempStr = new String(buffer, position, tempLength);
                position += tempLength;
                Parser p = new Parser( tempStr );

                PermissionSet psTemp = new PermissionSet();
                psTemp.FromXml(p.GetTopElement());

                switch(psKind)
                {
                    case idRequest:
                        m_strRequest = tempStr;
                        m_request = psTemp;
                        break;

                    case idOptional:
                        m_strOptional = tempStr;
                        m_optional = psTemp;
                        break;

                    case idDenied:
                        m_strDenied = tempStr;
                        m_denied = psTemp;
                        break;

                    default:
                        throw new SerializationException(Environment.GetResourceString("Serialization_UnableToFixup"));
                }
            }

            return position;
        }

		/// <include file='doc\PermissionRequestEvidence.uex' path='docs/doc[@for="PermissionRequestEvidence.ToString"]/*' />
		public override String ToString()
		{
			return ToXml().ToString();
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\netcodegroup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  NetCodeGroup.cs
//
//  Representation for code groups used for the policy mechanism
//

namespace System.Security.Policy {
    
    using System;
    using System.Security.Util;
    using System.Security;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;
    
    /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup"]/*' />
    [Serializable]
    sealed public class NetCodeGroup : CodeGroup
    {
        [System.Diagnostics.Conditional( "_DEBUG" )]
        private static void DEBUG_OUT( String str )
        {
#if _DEBUG        
            if (debug)
            {
                if (to_file)
                {
                    System.Text.StringBuilder sb = new System.Text.StringBuilder();
                    sb.Append( str );
                    sb.Append ((char)13) ;
                    sb.Append ((char)10) ;
                    PolicyManager._DebugOut( file, sb.ToString() );
                }
                else
                    Console.WriteLine( str );
             }
#endif             
        }
        
#if _DEBUG
        private static bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "c:\\com99\\src\\bcl\\debug.txt";
#endif  

        internal NetCodeGroup()
            : base()
        {
        }

        /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup.NetCodeGroup"]/*' />
        public NetCodeGroup( IMembershipCondition membershipCondition )
            : base( membershipCondition, (PolicyStatement)null )
        {
        }
       
        
        /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup.Resolve"]/*' />
        public override PolicyStatement Resolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");
            
            if (this.MembershipCondition.Check( evidence ))
            {
                PolicyStatement thisPolicy = null;
                
                IEnumerator evidenceEnumerator = evidence.GetHostEnumerator();

                Site site = null;

                while (evidenceEnumerator.MoveNext())
                {
                    Url url = evidenceEnumerator.Current as Url;

                    if (url != null)
                    {
                        thisPolicy = CalculatePolicy( url.GetURLString().Host, url.GetURLString().Scheme, url.GetURLString().Port );
                    }
                    else
                    {
                        if (site == null)
                            site = evidenceEnumerator.Current as Site;
                    }
                }

                if (thisPolicy == null && site != null)
                    thisPolicy = CalculatePolicy( site.Name, null, -1 );

                if (thisPolicy == null)
                    thisPolicy = new PolicyStatement( new PermissionSet( false ), PolicyStatementAttribute.Nothing );

                IEnumerator enumerator = this.Children.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    PolicyStatement childPolicy = ((CodeGroup)enumerator.Current).Resolve( evidence );

                    if (childPolicy != null)
                    {
                        if (((thisPolicy.Attributes & childPolicy.Attributes) & PolicyStatementAttribute.Exclusive) == PolicyStatementAttribute.Exclusive)
                        {
                            throw new PolicyException( Environment.GetResourceString( "Policy_MultipleExclusive" ) );
                        }

                        thisPolicy.GetPermissionSetNoCopy().InplaceUnion( childPolicy.GetPermissionSetNoCopy() );
                        thisPolicy.Attributes = thisPolicy.Attributes | childPolicy.Attributes;
                    }
                }

                return thisPolicy;
            }           
            else
            {
                return null;
            }
        }        

        internal PolicyStatement InternalResolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");
            

            if (this.MembershipCondition.Check( evidence ))
            {
                IEnumerator evidenceEnumerator = evidence.GetHostEnumerator();

                PolicyStatement thisPolicy = null;

                Site site = null;

                while (evidenceEnumerator.MoveNext())
                {
                    Url url = evidenceEnumerator.Current as Url;

                    if (url != null)
                    {
                        thisPolicy = CalculatePolicy( url.GetURLString().Host, url.GetURLString().Scheme, url.GetURLString().Port );
                    }
                    else
                    {
                        if (site == null)
                            site = evidenceEnumerator.Current as Site;
                    }
                }

                if (thisPolicy == null && site != null)
                    thisPolicy = CalculatePolicy( site.Name, null, -1 );

                if (thisPolicy == null)
                    thisPolicy = new PolicyStatement( new PermissionSet( false ), PolicyStatementAttribute.Nothing );

                return thisPolicy;

            }

            return null;
        }

        /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup.ResolveMatchingCodeGroups"]/*' />
        public override CodeGroup ResolveMatchingCodeGroups( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");

            if (this.MembershipCondition.Check( evidence ))
            {
                CodeGroup retGroup = this.Copy();

                retGroup.Children = new ArrayList();

                IEnumerator enumerator = this.Children.GetEnumerator();
                
                while (enumerator.MoveNext())
                {
                    CodeGroup matchingGroups = ((CodeGroup)enumerator.Current).ResolveMatchingCodeGroups( evidence );
                    
                    // If the child has a policy, we are done.
                    
                    if (matchingGroups != null)
                    {
                        retGroup.AddChild( matchingGroups );
                    }
                }

                return retGroup;
                
            }
            else
            {
                return null;
            }
        }

        private String EscapeSiteString( String site )
        {
            String[] separatedSite = site.Split( '.' );

            BCLDebug.Assert( separatedSite != null && separatedSite.Length > 0, "separatedSite generated in unexpected form" );

            String escapedSite = separatedSite[0];

            for (int i = 1; i < separatedSite.Length; ++i)
            {
                escapedSite += "\\." + separatedSite[i];
            }

            return escapedSite;
        }


        private SecurityElement CreateSocketPermission( String host, String scheme, int port )
        {
            // Note: this code currently does nothing with the port

            SecurityElement root = new SecurityElement( "IPermission" );

            root.AddAttribute( "class", "System.Net.SocketPermission, System, Version=" + Assembly.GetExecutingAssembly().GetVersion().ToString() + ", Culture=neutral, PublicKeyToken=b77a5c561934e089" );
            root.AddAttribute( "version", "1" );

            SecurityElement connectAccess = new SecurityElement( "ConnectAccess" );
            SecurityElement uri1 = new SecurityElement( "ENDPOINT" );
            uri1.AddAttribute( "host", host );
            uri1.AddAttribute( "transport", "All" );
            uri1.AddAttribute( "port", "All" );
            connectAccess.AddChild( uri1 );

            SecurityElement acceptAccess = new SecurityElement( "AcceptAccess" );
            SecurityElement uri2 = new SecurityElement( "ENDPOINT" );
            uri2.AddAttribute( "host", host );
            uri2.AddAttribute( "transport", "All" );
            uri2.AddAttribute( "port", "All" );
            acceptAccess.AddChild( uri2 );

            root.AddChild( connectAccess );
            root.AddChild( acceptAccess );


            return root;
        }

        private SecurityElement CreateWebPermission( String host, String scheme, int port )
        {
            if (scheme != null && String.Compare( scheme, "file", true, CultureInfo.InvariantCulture) == 0)
                return null;

            SecurityElement root = new SecurityElement( "IPermission" );

            root.AddAttribute( "class", "System.Net.WebPermission, System, Version=" + Assembly.GetExecutingAssembly().GetVersion().ToString() + ", Culture=neutral, PublicKeyToken=b77a5c561934e089" );
            root.AddAttribute( "version", "1" );

            SecurityElement connectAccess = new SecurityElement( "ConnectAccess" );

            String uriStr;
            String escapedHostPlusPort = EscapeSiteString( host );

            if (port != -1)
                escapedHostPlusPort += ":" + port;

            if (scheme != null && String.Compare( scheme, "http", true, CultureInfo.InvariantCulture) == 0)
                uriStr = "(https|http)://" + escapedHostPlusPort + "/.*";
            else if (scheme != null)
                uriStr = scheme + "://" + escapedHostPlusPort + "/.*";
            else
                uriStr = ".*://" + escapedHostPlusPort + "/.*";
                
            SecurityElement uri = new SecurityElement( "URI" );
            uri.AddAttribute( "uri", uriStr );

            connectAccess.AddChild( uri );
            root.AddChild( connectAccess );

            return root;
        }


        private PolicyStatement CalculatePolicy( String host, String scheme, int port )
        {
            // Note: this gets a little stupid since the web and socket permissions are
            // outside of mscorlib we have to load them dynamically, so I do it in
            // separate functions.

            // For now we set it null while the Net dudes decide whether
            // they want socketPerm granted or not.  The socket code
            // currently does nothing with the port.
            // SecurityElement socketPerm = CreateSocketPermission( host, scheme, port );
            SecurityElement socketPerm = null;

            SecurityElement webPerm = CreateWebPermission( host, scheme, port );

            // Now build the policy statement

            SecurityElement root = new SecurityElement( "PolicyStatement" );
            SecurityElement permSet = new SecurityElement( "PermissionSet" );
            permSet.AddAttribute( "class", "System.Security.PermissionSet" );
            permSet.AddAttribute( "version", "1" );

            if (webPerm != null)
                permSet.AddChild( webPerm );

            if (socketPerm != null)
                permSet.AddChild( socketPerm );

            root.AddChild( permSet );

            PolicyStatement policy = new PolicyStatement();

            policy.FromXml( root );

            return policy;
        }
        
        /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup.Copy"]/*' />
        public override CodeGroup Copy()
        {
            NetCodeGroup group = new NetCodeGroup( this.MembershipCondition );
            
            group.Name = this.Name;
            group.Description = this.Description;

            IEnumerator enumerator = this.Children.GetEnumerator();

            while (enumerator.MoveNext())
            {
                group.AddChild( (CodeGroup)enumerator.Current );
            }

            
            return group;
        }
        
        
        /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup.MergeLogic"]/*' />
        public override String MergeLogic
        {
            get
            {
                return Environment.GetResourceString( "MergeLogic_Union" );
            }
        }
        
        /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup.PermissionSetName"]/*' />
        public override String PermissionSetName
        {
            get
            {
                return Environment.GetResourceString( "NetCodeGroup_PermissionSet" );
            }
        }

        /// <include file='doc\NetCodeGroup.uex' path='docs/doc[@for="NetCodeGroup.AttributeString"]/*' />
        public override String AttributeString
        {
            get
            {
                return null;
            }
        }  

             
    }   
        

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\publisher.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  Publisher.cs
//
//  Publisher is an IIdentity representing internet sites.
//

namespace System.Security.Policy {
    using System.Runtime.Remoting;
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Collections;
    using PublisherIdentityPermission = System.Security.Permissions.PublisherIdentityPermission;
    using System.Security.Cryptography.X509Certificates;

    /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher"]/*' />
    [Serializable]
    sealed public class Publisher : IIdentityPermissionFactory, IBuiltInEvidence
    {
        private X509Certificate m_cert;
    
        internal Publisher() { }
    
        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.Publisher"]/*' />
        public Publisher(X509Certificate cert)
        {
            if (cert == null)
                throw new ArgumentNullException("cert");
    
            m_cert = cert;
        }
    
        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.CreateIdentityPermission"]/*' />
        public IPermission CreateIdentityPermission( Evidence evidence )
        {
            return new PublisherIdentityPermission( m_cert );
        }

        // Two Publisher objects are equal if the public keys contained within their certificates
        // are equal.  The certs themselves may be different...

        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.Equals"]/*' />
        public override bool Equals(Object o)
        {
            Publisher that = (o as Publisher);

            return (that != null && PublicKeyEquals( this.m_cert, that.m_cert ));
        }

        // Checks if two certificates have the same public key, keyalg, and keyparam.
        internal static bool PublicKeyEquals( X509Certificate cert1, X509Certificate cert2 )
        {
            if (cert1 == null)
            {
                return (cert2 == null);
            }
            else if (cert2 == null)
            {
                return false;
            }

            byte[] publicKey1 = cert1.GetPublicKey();
            String keyAlg1 = cert1.GetKeyAlgorithm();
            byte[] keyAlgParam1 = cert1.GetKeyAlgorithmParameters();
            byte[] publicKey2 = cert2.GetPublicKey();
            String keyAlg2 = cert2.GetKeyAlgorithm();
            byte[] keyAlgParam2 = cert2.GetKeyAlgorithmParameters();

            // Keys are most likely to be different of the three components,
            // so check them first

            int len = publicKey1.Length;
            if (len != publicKey2.Length) return(false);
            for (int i = 0; i < len; i++) {
                if (publicKey1[i] != publicKey2[i]) return(false);
            }
            if (!(keyAlg1.Equals(keyAlg2))) return(false);
            len = keyAlgParam1.Length;
            if (keyAlgParam2.Length != len) return(false);
            for (int i = 0; i < len; i++) {
                if (keyAlgParam1[i] != keyAlgParam2[i]) return(false);
            }

            return true;
        }

        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return m_cert.GetHashCode();
        }

   
        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.Certificate"]/*' />
        public X509Certificate Certificate
        {
            get
            {
                if (m_cert == null)
                    return null;
                else
                    return new X509Certificate( m_cert );
            }
        }
    
        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.Copy"]/*' />
        public Object Copy()
        {
            Publisher p = new Publisher();
    
            if (m_cert != null)
                p.m_cert = new X509Certificate(m_cert);
    
            return p;
        }
        
        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.ToXml"]/*' />
        internal SecurityElement ToXml()
        {
            SecurityElement elem = new SecurityElement( this.GetType().FullName );
            elem.AddAttribute( "version", "1" );
            elem.AddChild( new SecurityElement( "X509v3Certificate", m_cert != null ? m_cert.GetRawCertDataString() : "" ) );
            return elem;
        }
        
        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            buffer[position++] = BuiltInEvidenceHelper.idPublisher;
            byte[] certData = this.Certificate.GetRawCertData();
            int length = certData.Length;

            if (verbose)
            {
                BuiltInEvidenceHelper.CopyIntToCharArray(length, buffer, position);
                position += 2;
            }
                
            Buffer.InternalBlockCopy(certData, 0, buffer, position * 2, length);
            return ((length - 1) / 2) + 1 + position;
        }

        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose)
        {
            // We need to return the size of the byte array converted to chars
            // (which can be one byte larger than is actually needed) plus
            // one char for the identifier.

            // Note: the formula (NumBytes - 1) / 2 + 1 will always calculate
            // the proper number of chars needed.

            int length = ((this.Certificate.GetRawCertData().Length - 1) / 2) + 1;
            if (verbose)
                return length + 3;
            else
                return length + 1;
        }
        
        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position )
        {
            int length = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;
            byte[] certData = new byte[length];

            int lengthInChars = ((length - 1) / 2) + 1;
            Buffer.InternalBlockCopy(buffer, position * 2, certData, 0, length);
            m_cert = new X509Certificate( certData );

            return position + lengthInChars;
        }

        /// <include file='doc\Publisher.uex' path='docs/doc[@for="Publisher.ToString"]/*' />
        public override String ToString()
		{
			return ToXml().ToString();
		}

        // INormalizeForIsolatedStorage is not implemented for startup perf
        // equivalent to INormalizeForIsolatedStorage.Normalize()
        internal Object Normalize()
        {
            MemoryStream ms = new MemoryStream(m_cert.GetRawCertData());
            ms.Position = 0;
            return ms;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\policystatement.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PolicyStatement.cool
//
//  Represents the policy associated with some piece of evidence
//

namespace System.Security.Policy {
    
	using System;
	using System.Security;
	using System.Security.Util;
	using Math = System.Math;
	using System.Collections;
	using System.Security.Permissions;
	using System.Text;
	using System.Runtime.Remoting.Activation;
    /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatementAttribute"]/*' />
    [Flags, Serializable]
    public enum PolicyStatementAttribute
    {
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatementAttribute.Nothing"]/*' />
        Nothing = 0x0,
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatementAttribute.Exclusive"]/*' />
        Exclusive = 0x01,
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatementAttribute.LevelFinal"]/*' />
        LevelFinal = 0x02,
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatementAttribute.All"]/*' />
        All = 0x03,
    }
    
    /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement"]/*' />
    [Serializable]
    sealed public class PolicyStatement : ISecurityEncodable, ISecurityPolicyEncodable
    {
        // The PermissionSet associated with this policy
        internal PermissionSet m_permSet;
        
        // The bitfield of inheritance properties associated with this policy
        internal PolicyStatementAttribute m_attributes;
        
        internal PolicyStatement()
        {
            m_permSet = null;
            m_attributes = PolicyStatementAttribute.Nothing;
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.PolicyStatement"]/*' />
        public PolicyStatement( PermissionSet permSet )
            : this( permSet, PolicyStatementAttribute.Nothing )
        {
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.PolicyStatement1"]/*' />
        public PolicyStatement( PermissionSet permSet, PolicyStatementAttribute attributes )
        {
            if (permSet == null)
            {
                m_permSet = new PermissionSet( false );
            }
            else
            {
                m_permSet = permSet.Copy();
            }
            if (ValidProperties( attributes ))
            {
                m_attributes = attributes;
            }
        }
        
        private PolicyStatement( PermissionSet permSet, PolicyStatementAttribute attributes, bool copy )
        {
            if (permSet != null)
            {
                if (copy)
                    m_permSet = permSet.Copy();
                else
                    m_permSet = permSet;
            }
            else
            {
                m_permSet = new PermissionSet( false );
            }
                
            m_attributes = attributes;
        }
        
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.PermissionSet"]/*' />
        public PermissionSet PermissionSet
        {
            get
            {
                lock (this)
                {
                if (!m_permSet.IsFullyLoaded())
                    m_permSet.LoadPostponedPermissions();

                return m_permSet.Copy();
            }
            }
            
            set
            {
                lock (this)
                {
                if (value == null)
                {
                    m_permSet = new PermissionSet( false );
                }
                else
                {
                    m_permSet = value.Copy();
                }
            }
        }
        }
        
        internal void SetPermissionSetNoCopy( PermissionSet permSet )
        {
            m_permSet = permSet;
        }
        
        internal PermissionSet GetPermissionSetNoCopy()
        {
            lock (this)
            {
            if (!m_permSet.IsFullyLoaded())
                m_permSet.LoadPostponedPermissions();

            return m_permSet;
        }
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.Attributes"]/*' />
        public PolicyStatementAttribute Attributes
        {
            get
            {
                return m_attributes;
            }
            
            set
            {
                if (ValidProperties( value ))
                {
                    m_attributes = value;
                }
            }
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.Copy"]/*' />
        public PolicyStatement Copy()
        {
            return new PolicyStatement( m_permSet, m_attributes, true );
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.AttributeString"]/*' />
        public String AttributeString
        {
            get
            {
                StringBuilder sb = new StringBuilder();
            
                bool first = true;
            
                if (GetFlag((int) PolicyStatementAttribute.Exclusive ))
                {
                    sb.Append( "Exclusive" );
                    first = false;
                }
                if (GetFlag((int) PolicyStatementAttribute.LevelFinal ))
                {
                    if (!first)
                        sb.Append( " " );
                    sb.Append( "LevelFinal" );
                }
            
                return sb.ToString();
            }
        }        
        
        private static bool ValidProperties( PolicyStatementAttribute attributes )
        {
            if ((attributes & ~(PolicyStatementAttribute.All)) == 0)
            {
                return true;
            }
            else
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidFlag" ) );
            }
        }
        
        private bool GetFlag( int flag )
        {
            return (flag & (int)m_attributes) != 0;
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.FromXml"]/*' />
        public void FromXml( SecurityElement et )
        {
            FromXml( et, null );
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            SecurityElement e = new SecurityElement( "PolicyStatement" );
            e.AddAttribute( "version", "1" );
            if (m_attributes != PolicyStatementAttribute.Nothing)
                e.AddAttribute( "Attributes", XMLUtil.BitFieldEnumToString( typeof( PolicyStatementAttribute ), m_attributes ) );            
            
            lock (this)
            {
                if (m_permSet != null)
                {
                    if (!m_permSet.IsFullyLoaded())
                    {
                        m_permSet.LoadPostponedPermissions();
                    }

                    if (m_permSet is NamedPermissionSet)
                    {
                        // If the named permission set exists in the parent level of this
                        // policy struct, then just save the name of the permission set.
                        // Otherwise, serialize it like normal.
                
                        NamedPermissionSet namedPermSet = (NamedPermissionSet)m_permSet;
                        if (level != null && level.GetNamedPermissionSet( namedPermSet.Name ) != null)
                        {
                            e.AddAttribute( "PermissionSetName", namedPermSet.Name );
                        }
                        else
                        {
                            e.AddChild( namedPermSet.ToXml() );
                        }
                    }
                    else
                    {
                        e.AddChild( m_permSet.ToXml() );
                    }
                }
            }
            
            return e;
        }
        
        /// <include file='doc\PolicyStatement.uex' path='docs/doc[@for="PolicyStatement.FromXml1"]/*' />
        public void FromXml( SecurityElement et, PolicyLevel level )
        {
            if (et == null)
                throw new ArgumentNullException( "et" );

            if (!et.Tag.Equals( "PolicyStatement" ))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidXMLElement" ),  "PolicyStatement", this.GetType().FullName ) );
        
            m_attributes = (PolicyStatementAttribute) 0;

            String strAttributes = et.Attribute( "Attributes" );

            if (strAttributes != null)
                m_attributes = (PolicyStatementAttribute)Enum.Parse( typeof( PolicyStatementAttribute ), strAttributes );

            lock (this)
            {
                m_permSet = null;

                if (level != null)
                {
                    String permSetName = et.Attribute( "PermissionSetName" );
    
                    if (permSetName != null)
                    {
                        m_permSet = level.GetNamedPermissionSetInternal( permSetName );

                        if (m_permSet == null)
                            m_permSet = new PermissionSet( PermissionState.None );
                    }
                }


                if (m_permSet == null)
                {
                    // There is no provided level, it is not a named permission set, or
                    // the named permission set doesn't exist in the provided level,
                    // so just create the class through reflection and decode normally.
        
                    SecurityElement e = et.SearchForChildByTag( "PermissionSet" );

                    if (e != null)
                    {
                        String className = e.Attribute( "class" );

                        if (className != null && (className.Equals( "NamedPermissionSet" ) ||
                                                  className.Equals( "System.Security.NamedPermissionSet" )))
                            m_permSet = new NamedPermissionSet( "DefaultName", PermissionState.None );
                        else
                            m_permSet = new PermissionSet( PermissionState.None );
                
                        try
                        {
                            // We play it conservative here and just say that we are loading policy
                            // anytime we have to decode a permission set.
                            bool fullyLoaded;
                            m_permSet.FromXml( e, true, out fullyLoaded );
                        }
                        catch (Exception)
                        {
                            // ignore any exceptions from the decode process.
                            // Note: we go ahead and use the permission set anyway.  This should be safe since
                            // the decode process should never give permission beyond what a proper decode would have
                            // given.
                        }
                    }
                    else
                    {
                        throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidXML" ) );
                    }
                }

                if (m_permSet == null) 
                    m_permSet = new PermissionSet( PermissionState.None );
            }	
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\policyexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PolicyException.cool
//
//  Use this class to throw a PolicyException
//

namespace System.Security.Policy {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\PolicyException.uex' path='docs/doc[@for="PolicyException"]/*' />
    [Serializable]
    public class PolicyException : SystemException
    {
        /// <include file='doc\PolicyException.uex' path='docs/doc[@for="PolicyException.PolicyException"]/*' />
        public PolicyException()
        
            : base(Environment.GetResourceString( "Policy_Default" )) {
            HResult = __HResults.CORSEC_E_POLICY_EXCEPTION;
        }
    
        /// <include file='doc\PolicyException.uex' path='docs/doc[@for="PolicyException.PolicyException1"]/*' />
        public PolicyException(String message)
        
            : base(message) {
            HResult = __HResults.CORSEC_E_POLICY_EXCEPTION;
        }
        
        /// <include file='doc\PolicyException.uex' path='docs/doc[@for="PolicyException.PolicyException2"]/*' />
        public PolicyException(String message, Exception exception)
        
            : base(message, exception) {
            HResult = __HResults.CORSEC_E_POLICY_EXCEPTION;
        }

        /// <include file='doc\PolicyException.uex' path='docs/doc[@for="PolicyException.PolicyException3"]/*' />
        protected PolicyException(SerializationInfo info, StreamingContext context) : base (info, context) {}

        internal PolicyException(String message, int hresult) : base (message)
        {
            HResult = hresult;
        }

        internal PolicyException(String message, int hresult, Exception exception) : base (message, exception)
        {
            HResult = hresult;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\site.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  Site.cs
//
//  Site is an IIdentity representing internet sites.
//

namespace System.Security.Policy {
    using System.Text;
    using System.Runtime.Remoting;
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Collections;
    using UnicodeEncoding = System.Text.UnicodeEncoding;
    using SiteIdentityPermission = System.Security.Permissions.SiteIdentityPermission;
    using System.Globalization;    

    /// <include file='doc\Site.uex' path='docs/doc[@for="Site"]/*' />
    [Serializable]
    sealed public class Site : IIdentityPermissionFactory, IBuiltInEvidence
    {
        private SiteString m_name;
    
        internal Site()
        {
            m_name = null;
        }
    
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.Site"]/*' />
        public Site(String name)
        {
            if (name == null)
                throw new ArgumentNullException("name");
    
            m_name = new SiteString( name );
        }
    
        internal Site( byte[] id, String name )
        {
            m_name = ParseSiteFromUrl( name );
        }
    
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.CreateFromUrl"]/*' />
        public static Site CreateFromUrl( String url )
        {
            Site site = new Site();

            site.m_name = ParseSiteFromUrl( url );
    
            return site;
        }
        
        private static SiteString ParseSiteFromUrl( String name )
        {
            URLString urlString = new URLString( name );

            // Add this in Whidbey
            // if (String.Compare( urlString.Scheme, "file", true, CultureInfo.InvariantCulture ) == 0)
            //     throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidSite" ) );

            return new SiteString( new URLString( name ).Host );
        }       
    
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.Name"]/*' />
        public String Name
        {
            get
            {
                if (m_name != null)
                    return m_name.ToString();
                else
                    return null;
            }
        }
        
        internal SiteString GetSiteString()
        {
                return m_name;
        }
    
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.CreateIdentityPermission"]/*' />
        public IPermission CreateIdentityPermission( Evidence evidence )
        {
            return new SiteIdentityPermission( Name );
        }
        
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.Equals"]/*' />
        public override bool Equals(Object o)
        {
            if (o is Site)
            {
                Site s = (Site) o;
                    if (Name == null)
                        return (s.Name == null);
    
                return String.Compare( Name, s.Name, true, CultureInfo.InvariantCulture) == 0;
            }
    
            return false;
        }
    
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            String name = this.Name;

            if (name == null)
                return 0;
            else
                return name.GetHashCode();
        }

        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.Copy"]/*' />
        public Object Copy()
        {
            return new Site(this.Name);
        }
    
        internal SecurityElement ToXml()
        {
            SecurityElement elem = new SecurityElement( this.GetType().FullName );
            elem.AddAttribute( "version", "1" );
            
            if(m_name != null)
                elem.AddChild( new SecurityElement( "Name", m_name.ToString() ) );
                
            return elem;
        }
        
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            buffer[position++] = BuiltInEvidenceHelper.idSite;
            String name = this.Name;
            int length = name.Length;

            if (verbose)
            {
                BuiltInEvidenceHelper.CopyIntToCharArray(length, buffer, position);
                position += 2;
            }
            name.CopyTo( 0, buffer, position, length );
            return length + position;
        }

        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose)
        {
            if (verbose)
                return this.Name.Length + 3;
            else
                return this.Name.Length + 1;
        }
        
        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position)
        {
            int length = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;

            m_name = new SiteString( new String(buffer, position, length ));

            return position + length;
        }

        /// <include file='doc\Site.uex' path='docs/doc[@for="Site.ToString"]/*' />
        public override String ToString()
		{
			return ToXml().ToString();
		}

        // INormalizeForIsolatedStorage is not implemented for startup perf
        // equivalent to INormalizeForIsolatedStorage.Normalize()
        internal Object Normalize()
        {
            return m_name.ToString().ToUpper(CultureInfo.InvariantCulture);
		}

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\publishermembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PublisherMembershipCondition.cool
//
//  Implementation of membership condition for X509 certificate based publishers
//

namespace System.Security.Policy {
    using System;
    using X509Certificate = System.Security.Cryptography.X509Certificates.X509Certificate;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Policy;
    using System.Collections;

    /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition"]/*' />
    [Serializable]
    sealed public class PublisherMembershipCondition : IMembershipCondition, IConstantMembershipCondition
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private X509Certificate m_certificate;
        private SecurityElement m_element;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        internal PublisherMembershipCondition()
        {
            m_element = null;
            m_certificate = null;
        }
        
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.PublisherMembershipCondition"]/*' />
        public PublisherMembershipCondition( X509Certificate certificate )
        {
            CheckCertificate( certificate );
            m_certificate = new X509Certificate( certificate );
        }
    
        private static void CheckCertificate( X509Certificate certificate )
        {
            if (certificate == null)
            {
                throw new ArgumentNullException( "certificate" );
            }
        }
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
    
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.Certificate"]/*' />
        public X509Certificate Certificate
        {
            set
            {
                CheckCertificate( value );
                m_certificate = new X509Certificate( value );
            }

            get
            {
                if (m_certificate == null && m_element != null)
                    ParseCertificate();
            
                if (m_certificate != null)
                    return new X509Certificate( m_certificate );
                else
                    return null;
            }
        }
        
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            if (m_certificate == null && m_element != null)
                ParseCertificate();
        
            if (m_certificate == null)
                return Environment.GetResourceString( "Publisher_ToString" );
            else
            {
                String name = m_certificate.GetName();
                if (name != null)
                    return String.Format( Environment.GetResourceString( "Publisher_ToStringArg" ), System.Security.Util.Hex.EncodeHexString( m_certificate.GetPublicKey() ) );
                else
                    return Environment.GetResourceString( "Publisher_ToString" );
            }
        }
        
        //------------------------------------------------------
        //
        // IMEMBERSHIPCONDITION IMPLEMENTATION
        //
        //------------------------------------------------------
    
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            if (evidence == null)
                return false;
        
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                Object obj = enumerator.Current;
            
                if (obj is Publisher)
                {
                    if (m_certificate == null && m_element != null)
                        ParseCertificate();

                    // We can't just compare certs directly here because Publisher equality
                    // depends only on the keys inside the certs.
                    if (((Publisher)obj).Equals(new Publisher(m_certificate)))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            if (m_certificate == null && m_element != null)
                ParseCertificate();
                    
            return new PublisherMembershipCondition( m_certificate );
        }
        
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            if (m_certificate == null && m_element != null)
                ParseCertificate();
                    
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            if (m_certificate != null)
                root.AddAttribute( "X509Certificate", m_certificate.GetRawCertDataString() );
            
            return root;
        }
    
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");
        
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
            
            lock (this)
            {
                m_element = e;
                m_certificate = null;
            }
        }
        
        
        private void ParseCertificate()
        {
            lock (this)
            {
                if (m_element == null)
                    return;

                String elCert = m_element.Attribute( "X509Certificate" );
                m_certificate = elCert == null ? null : new X509Certificate( System.Security.Util.Hex.DecodeHexString( elCert ) );
                CheckCertificate( m_certificate );
                m_element = null;
            }
        }    
        
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            PublisherMembershipCondition that = (o as PublisherMembershipCondition);
            
            if (that != null)
            {
                if (this.m_certificate == null && this.m_element != null)
                    this.ParseCertificate();
                if (that.m_certificate == null && that.m_element != null)
                    that.ParseCertificate();
                
                if ( Publisher.PublicKeyEquals( this.m_certificate, that.m_certificate ))
                {
                    return true;
                }
            }
            return false;
        }
        
        /// <include file='doc\PublisherMembershipCondition.uex' path='docs/doc[@for="PublisherMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (m_certificate == null && m_element != null)
                ParseCertificate();
            
            if (m_certificate != null)
            {
                return m_certificate.GetHashCode();
            }
            else
            {
                return typeof( PublisherMembershipCondition ).GetHashCode();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\strongname.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  StrongName.cool
//
//  StrongName is an IIdentity representing strong names.
//

namespace System.Security.Policy {
    using System.Configuration.Assemblies;
    using System.Runtime.Remoting;
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Collections;
    using System.Security.Permissions;
    using CultureInfo = System.Globalization.CultureInfo;
    

    /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName"]/*' />
    [Serializable]
    sealed public class StrongName : IIdentityPermissionFactory, IBuiltInEvidence
    {
        private StrongNamePublicKeyBlob m_publicKeyBlob;
        private String m_name;
        private Version m_version;
 
        private static readonly char[] s_separators = { '.' };
    
        internal StrongName() { }
    
        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.StrongName1"]/*' />
        public StrongName( StrongNamePublicKeyBlob blob, String name, Version version )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );

            // Add this in Whidbey
            // if (name.Equals( "" ))
            //     throw new ArgumentException( Environment.GetResourceString( "Argument_EmptyStrongName" ) );      
                
            if (blob == null)
                throw new ArgumentNullException( "blob" );
                
            if ((Object) version == null)
                throw new ArgumentNullException( "version" );
                
            m_publicKeyBlob = blob;
            m_name = name;
            m_version = version;
        }
    
        internal StrongName( StrongNamePublicKeyBlob blob, String name, Version version, bool trash )
        {
            m_publicKeyBlob = blob;
            m_name = name;
            m_version = version;
        }

        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.PublicKey"]/*' />
        public StrongNamePublicKeyBlob PublicKey
        {
            get
            {
                return m_publicKeyBlob;
            }
        }
        
        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.Name"]/*' />
        public String Name
        {
            get
            {
                return m_name;
            }
        }
        
        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.Version"]/*' />
        public Version Version
        {
            get
            {
                return m_version;
            }
        }
        
        internal static bool CompareNames( String asmName, String mcName )
        {
            if (mcName.Length > 0 && mcName[mcName.Length-1] == '*' && mcName.Length - 1 <= asmName.Length)
                return String.Compare( mcName, 0, asmName, 0, mcName.Length - 1, true, CultureInfo.InvariantCulture) == 0;
            else
                return String.Compare( mcName, asmName, true, CultureInfo.InvariantCulture) == 0;
        }        
        
        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.CreateIdentityPermission"]/*' />
        public IPermission CreateIdentityPermission( Evidence evidence )
        {
            return new StrongNameIdentityPermission( m_publicKeyBlob, m_name, m_version );
        }
        
        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.Copy"]/*' />
        public Object Copy()
        {
            return new StrongName( m_publicKeyBlob, m_name, m_version );
        }
    
        internal SecurityElement ToXml()
        {
            SecurityElement root = new SecurityElement( "StrongName" );
            root.AddAttribute( "version", "1" );
            
            if (m_publicKeyBlob != null)
                root.AddAttribute( "Key", System.Security.Util.Hex.EncodeHexString( m_publicKeyBlob.PublicKey ) );
            
            if (m_name != null)
                root.AddAttribute( "Name", m_name );
            
            if (m_version != null)
                root.AddAttribute( "Version", m_version.ToString() );
            
            return root;
        }
    
        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.ToString"]/*' />
        public override String ToString()
        {
            return ToXml().ToString();
        }

        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.Equals"]/*' />
        public override bool Equals( Object o )
        {
            StrongName that = (o as StrongName);
            
            return (that != null) &&
                   Equals( this.m_publicKeyBlob, that.m_publicKeyBlob ) &&
                   Equals( this.m_name, that.m_name ) &&
                   Equals( this.m_version, that.m_version );
        }
        
        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (m_publicKeyBlob != null)
            {
                return m_publicKeyBlob.GetHashCode();
            }
            else if (m_name != null || m_version != null)
            {
                return (m_name == null ? 0 : m_name.GetHashCode()) + (m_version == null ? 0 : m_version.GetHashCode());
            }
            else
            {
                return typeof( StrongName ).GetHashCode();
            }
        }
        
        internal bool IsSupersetOf( StrongName sn )
        {
            return (( this.PublicKey != null && this.PublicKey.Equals( sn.PublicKey ) ) &&
                    ( this.Name == null || (sn.Name != null && CompareNames( sn.Name, this.Name ) )) &&
                    ( (Object) this.Version == null || ((Object) sn.Version != null &&
                                                        sn.Version.CompareTo( this.Version ) == 0 )));
        }

        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            // StrongNames have a byte[], a string, and a Version (4 ints).
            // Copy in the id, the byte[], the four ints, and then the string.

            buffer[position++] = BuiltInEvidenceHelper.idStrongName;
            int lengthPK = m_publicKeyBlob.PublicKey.Length;
            if (verbose)
            {
                BuiltInEvidenceHelper.CopyIntToCharArray(lengthPK, buffer, position);
                position += 2;
            }
            Buffer.InternalBlockCopy(m_publicKeyBlob.PublicKey, 0, buffer, position * 2, lengthPK);
            position += ((lengthPK - 1) / 2) + 1;

            BuiltInEvidenceHelper.CopyIntToCharArray( m_version.Major,    buffer, position     );
            BuiltInEvidenceHelper.CopyIntToCharArray( m_version.Minor,    buffer, position + 2 );
            BuiltInEvidenceHelper.CopyIntToCharArray( m_version.Build,    buffer, position + 4 );
            BuiltInEvidenceHelper.CopyIntToCharArray( m_version.Revision, buffer, position + 6 );
            
            position += 8;
            int lengthName = m_name.Length;
            if (verbose)
            {
                BuiltInEvidenceHelper.CopyIntToCharArray(lengthName, buffer, position);
                position += 2;
            }
            m_name.CopyTo( 0, buffer, position, lengthName );

            return lengthName + position;
        }

        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose )
        {
            int length = ((m_publicKeyBlob.PublicKey.Length - 1) / 2) + 1; // blob
            if (verbose)
                length += 2;        // length of blob

            length += 8;            // version 

            length += m_name.Length;// Name
            if (verbose)
                length += 2;        // length of name

            length += 1;            // identifier
                            
            return length;
        }

        /// <include file='doc\StrongName.uex' path='docs/doc[@for="StrongName.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position )
        {
            int length = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;
            m_publicKeyBlob = new StrongNamePublicKeyBlob();
            m_publicKeyBlob.PublicKey = new byte[length];

            int lengthInChars = ((length - 1) / 2) + 1;
            Buffer.InternalBlockCopy(buffer, position * 2, m_publicKeyBlob.PublicKey, 0, length);
            position += lengthInChars;

            int major = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            int minor = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position + 2);
            int build = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position + 4);
            int revision = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position + 6);
            m_version = new Version(major, minor, build, revision);
            position += 8;

            length = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;

            m_name = new String(buffer, position, length );

            return position + length;
        }

        // INormalizeForIsolatedStorage is not implemented for startup perf
        // equivalent to INormalizeForIsolatedStorage.Normalize()
        internal Object Normalize()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            bw.Write(m_publicKeyBlob.PublicKey);
            bw.Write(m_version.Major);
            bw.Write(m_name);

            ms.Position = 0;

            return ms;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\policylevel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PolicyLevel.cool
//
//  Abstraction for a level of policy (e.g. Enterprise, Machine, User)
//

namespace System.Security.Policy {    
    using System.Threading;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System;
    using System.Collections;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.IO;
    using System.Text;
    using System.Reflection;

    internal class PolicyLevelData
    {
        // Note: any changes to the default permission sets means that you
        // must recontemplate the default quick cache settings below.

        internal static readonly String s_defaultPermissionSets =
           "<NamedPermissionSets>" + 
               "<PermissionSet class=\"System.Security.NamedPermissionSet\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\" " +
                              "Name=\"FullTrust\" " +
                              "Description=\"{Policy_PS_FullTrust}\"/>" +
               "<PermissionSet class=\"System.Security.NamedPermissionSet\"" +
                              "version=\"1\" " +
                              "Name=\"Everything\" " +
                              "Description=\"{Policy_PS_Everything}\">" +
                  "<Permission class=\"System.Security.Permissions.IsolatedStorageFilePermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.EnvironmentPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.FileIOPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.FileDialogPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.ReflectionPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.RegistryPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.SecurityPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Flags=\"Assertion, UnmanagedCode, Execution, ControlThread, ControlEvidence, ControlPolicy, ControlAppDomain, SerializationFormatter, ControlDomainPolicy, ControlPrincipal, RemotingConfiguration, Infrastructure, BindingRedirects\"/>" +
                  "<Permission class=\"System.Security.Permissions.UIPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Net.SocketPermission, System, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " + 
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Net.WebPermission, System, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " + 
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Net.DnsPermission, System, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " + 
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Drawing.Printing.PrintingPermission, System.Drawing, Version={VERSION}, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Diagnostics.EventLogPermission, System, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Diagnostics.PerformanceCounterPermission, System, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.DirectoryServices.DirectoryServicesPermission, System.DirectoryServices, Version={VERSION}, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Messaging.MessageQueuePermission, System.Messaging, Version={VERSION}, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.ServiceProcess.ServiceControllerPermission, System.ServiceProcess, Version={VERSION}, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Data.OleDb.OleDbPermission, System.Data, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\" " +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Data.SqlClient.SqlClientPermission, System.Data, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\" " +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
               "</PermissionSet>" +
               "<PermissionSet class=\"System.Security.NamedPermissionSet\"" +
                              "version=\"1\" " +
                              "Name=\"Nothing\" " +
                              "Description=\"{Policy_PS_Nothing}\"/>" +
               "<PermissionSet class=\"System.Security.NamedPermissionSet\"" +
                              "version=\"1\" " +
                              "Name=\"Execution\" " +
                              "Description=\"{Policy_PS_Execution}\">" +
                  "<Permission class=\"System.Security.Permissions.SecurityPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Flags=\"Execution\"/>" +
               "</PermissionSet>" +
               "<PermissionSet class=\"System.Security.NamedPermissionSet\"" +
                              "version=\"1\" " +
                              "Name=\"SkipVerification\" " +
                              "Description=\"{Policy_PS_SkipVerification}\">" +
                  "<Permission class=\"System.Security.Permissions.SecurityPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Flags=\"SkipVerification\"/>" +
               "</PermissionSet>" +
            "</NamedPermissionSets>";

        internal static readonly byte[] s_microsoftPublicKey = 
        {
            0,  36,   0,   0,   4, 128,   0,   0, 148,   0,   0,   0,   6,   2,   0,
            0,   0,  36,   0,   0,  82,  83,  65,  49,   0,   4,   0,   0,   1,   0,
            1,   0,   7, 209, 250,  87, 196, 174, 217, 240, 163,  46, 132, 170,  15,
          174, 253,  13, 233, 232, 253, 106, 236, 143, 135, 251,   3, 118, 108, 131,
           76, 153, 146,  30, 178,  59, 231, 154, 217, 213, 220, 193, 221, 154, 210,
           54,  19,  33,   2, 144,  11, 114,  60, 249, 128, 149, 127, 196, 225, 119,
           16, 143, 198,   7, 119,  79,  41, 232,  50,  14, 146, 234,   5, 236, 228,
          232,  33, 192, 165, 239, 232, 241, 100,  92,  76,  12, 147, 193, 171, 153,
           40,  93,  98,  44, 170, 101,  44,  29, 250, 214,  61, 116,  93, 111,  45,
          229, 241, 126,  94, 175,  15, 196, 150,  61,  38,  28, 138,  18,  67, 101,
           24,  32, 109, 192, 147,  52,  77,  90, 210, 147
        };

        internal static readonly byte[] s_ecmaPublicKey = 
        {
            0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0
        };

        
        internal static readonly QuickCacheEntryType s_quickCacheUnrestricted =
                QuickCacheEntryType.ExecutionZoneMyComputer |
                QuickCacheEntryType.ExecutionZoneIntranet |
                QuickCacheEntryType.ExecutionZoneInternet |
                QuickCacheEntryType.ExecutionZoneTrusted |
                QuickCacheEntryType.ExecutionZoneUntrusted |
                QuickCacheEntryType.BindingRedirectsZoneMyComputer |
                QuickCacheEntryType.BindingRedirectsZoneIntranet |
                QuickCacheEntryType.BindingRedirectsZoneInternet |
                QuickCacheEntryType.BindingRedirectsZoneTrusted |
                QuickCacheEntryType.BindingRedirectsZoneUntrusted |
                QuickCacheEntryType.UnmanagedZoneMyComputer |
                QuickCacheEntryType.UnmanagedZoneIntranet |
                QuickCacheEntryType.UnmanagedZoneInternet |
                QuickCacheEntryType.UnmanagedZoneTrusted |
                QuickCacheEntryType.UnmanagedZoneUntrusted |
                QuickCacheEntryType.ExecutionAll |
                QuickCacheEntryType.BindingRedirectsAll |
                QuickCacheEntryType.UnmanagedAll |
                QuickCacheEntryType.SkipVerificationZoneMyComputer |
                QuickCacheEntryType.SkipVerificationZoneIntranet |
                QuickCacheEntryType.SkipVerificationZoneInternet |
                QuickCacheEntryType.SkipVerificationZoneTrusted |
                QuickCacheEntryType.SkipVerificationZoneUntrusted |
                QuickCacheEntryType.SkipVerificationAll |
                QuickCacheEntryType.FullTrustZoneMyComputer |
                QuickCacheEntryType.FullTrustZoneIntranet |
                QuickCacheEntryType.FullTrustZoneInternet |
                QuickCacheEntryType.FullTrustZoneTrusted |
                QuickCacheEntryType.FullTrustZoneUntrusted |
                QuickCacheEntryType.FullTrustAll;
        internal static readonly QuickCacheEntryType s_quickCacheDefaultCodeGroups =
                QuickCacheEntryType.ExecutionZoneMyComputer |
                QuickCacheEntryType.ExecutionZoneIntranet |
                QuickCacheEntryType.ExecutionZoneInternet |
                QuickCacheEntryType.ExecutionZoneTrusted |
                QuickCacheEntryType.BindingRedirectsZoneMyComputer |
                QuickCacheEntryType.UnmanagedZoneMyComputer |
                QuickCacheEntryType.SkipVerificationZoneMyComputer |
                QuickCacheEntryType.FullTrustZoneMyComputer;
    }


    /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel"]/*' />
    [Serializable]
    sealed public class PolicyLevel
    {
        private void DEBUG_OUT( String str )
        {
#if _DEBUG
            if (debug)
            {
                if (to_file)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append( str );
                    sb.Append ((char)13) ;
                    sb.Append ((char)10) ;
                    PolicyManager._DebugOut( file, sb.ToString() );
                }
                else
                    Console.WriteLine( str );
             }
#endif             
        }
        
#if _DEBUG
        private static readonly bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "c:\\tests\\debug2.txt";
#endif        
        private ArrayList m_fullTrustAssemblies;
        private ArrayList m_namedPermissionSets;
        private CodeGroup m_rootCodeGroup; 
        private String m_label;
        
        private ConfigId m_configId;        
        
        private bool m_useDefaultCodeGroupsOnReset;
        private bool m_generateQuickCacheOnLoad;
        private bool m_loaded;
        private bool m_throwOnLoadError = false;
        private SecurityElement m_permSetElement;
        private Encoding m_encoding;

        private static PolicyLevel s_waitingLevel = null;
        private static Thread s_waitingThread = null;
        private static readonly int s_maxLoopCount = 100;

        private static StrongNameMembershipCondition s_ecmaMscorlibResource = null;

        private static readonly byte[] s_ecmaPublicKey = 
        {
            0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0
        };

        
#if _DEBUG
        private static int s_currentSequenceNumber = 0;
        private int m_sequenceNumber = s_currentSequenceNumber++;
#endif
        
        // We use the XML representation to load our default permission sets.  This
        // allows us to load permissions that are not defined in mscorlib

        internal static readonly String s_internetPermissionSet =
               "<PermissionSet class=\"System.Security.NamedPermissionSet\"" +
                              "version=\"1\" " +
                              "Name=\"Internet\" " +
                              "Description=\"{Policy_PS_Internet}\">" +
                  "<Permission class=\"System.Security.Permissions.FileDialogPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Access=\"Open\"/>" +
                  "<Permission class=\"System.Security.Permissions.IsolatedStorageFilePermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "UserQuota=\"10240\" " +
                              "Allowed=\"DomainIsolationByUser\"/>" +
                  "<Permission class=\"System.Security.Permissions.SecurityPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Flags=\"Execution\"/>" +
                  "<Permission class=\"System.Security.Permissions.UIPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Window=\"SafeTopLevelWindows\" " +
                              "Clipboard=\"OwnClipboard\"/>" +
                  "<IPermission class=\"System.Drawing.Printing.PrintingPermission, System.Drawing, Version={VERSION}, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\"" +
                              "version=\"1\"" +
                              "Level=\"SafePrinting\"/>" +
               "</PermissionSet>";

        internal static readonly String s_localIntranetPermissionSet =
               "<PermissionSet class=\"System.Security.NamedPermissionSet\"" +
                              "version=\"1\" " +
                              "Name=\"LocalIntranet\" " +
                              "Description=\"{Policy_PS_LocalIntranet}\">" +
                  "<Permission class=\"System.Security.Permissions.EnvironmentPermission, mscorlib, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Read=\"USERNAME\"/>" +
                  "<Permission class=\"System.Security.Permissions.FileDialogPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.IsolatedStorageFilePermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Allowed=\"AssemblyIsolationByUser\" " +
                              "UserQuota=\"9223372036854775807\" " +
                              "Expiry=\"9223372036854775807\" " +
                              "Permanent=\"true\"/>" +
                  "<Permission class=\"System.Security.Permissions.ReflectionPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Flags=\"ReflectionEmit\"/>" +
                  "<Permission class=\"System.Security.Permissions.SecurityPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Flags=\"Execution, Assertion, BindingRedirects\"/>" +
                  "<Permission class=\"System.Security.Permissions.UIPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Net.DnsPermission, System, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " + 
                              "Unrestricted=\"true\"/>" +
                  "<IPermission class=\"System.Drawing.Printing.PrintingPermission, System.Drawing, Version={VERSION}, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\"" +
                              "version=\"1\"" +
                              "Level=\"DefaultPrinting\"/>" +
                  "<IPermission class=\"System.Diagnostics.EventLogPermission, System, Version={VERSION}, Culture=neutral, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\">" +
                      "<Machine name=\".\" " +
                               "access=\"Instrument\"/>" +
                  "</IPermission>" +
               "</PermissionSet>";

        internal static readonly Version s_mscorlibVersion = Assembly.GetExecutingAssembly().GetVersion();
        internal static readonly String s_mscorlibVersionString = Assembly.GetExecutingAssembly().GetVersion().ToString();
        internal static readonly ZoneMembershipCondition s_zoneMembershipCondition = new ZoneMembershipCondition( SecurityZone.MyComputer );

        internal static readonly String[] m_reservedPermissionSets =  
        {
            "FullTrust",
            "Nothing",
            "Execution",
            "SkipVerification",
            "Internet",
            "LocalIntranet"
        };
    
        internal bool m_caching;
        
        internal PolicyLevel()
        {
            m_rootCodeGroup = null;
            m_loaded = true;
            m_caching = false;
            m_useDefaultCodeGroupsOnReset = false;
            m_generateQuickCacheOnLoad = false;
        }
        
        internal PolicyLevel( String label )
        {
            m_configId = ConfigId.None;
            SetFactoryPermissionSets();
            SetDefaultFullTrustAssemblies();
            m_loaded = true;
            m_rootCodeGroup = CreateDefaultAllGroup();
            m_label = label;
            m_caching = false;
            m_useDefaultCodeGroupsOnReset = false;
            m_generateQuickCacheOnLoad = false;
        }
        
        internal PolicyLevel( String label, ConfigId id, bool useDefaultCodeGroupOnReset )
            : this( label, id, useDefaultCodeGroupOnReset, false )
        {
        }

        internal PolicyLevel( String label, ConfigId id, bool useDefaultCodeGroupOnReset, bool generateQuickCacheOnLoad )
        {
            m_configId = id;
            m_label = label;
            m_rootCodeGroup = null;
            m_loaded = false;
            m_caching = (id != ConfigId.None);
            m_useDefaultCodeGroupsOnReset = useDefaultCodeGroupOnReset;
            m_generateQuickCacheOnLoad = generateQuickCacheOnLoad;
        }
        
        internal PolicyLevel( PolicyLevel level )
        {
            m_configId = level.m_configId;
            m_label = level.m_label;
            m_rootCodeGroup = level.RootCodeGroup;
            m_loaded = true;
            m_caching = level.m_caching;
            m_useDefaultCodeGroupsOnReset = level.m_useDefaultCodeGroupsOnReset;
            m_namedPermissionSets = (ArrayList)level.NamedPermissionSets;
            m_fullTrustAssemblies = (ArrayList)level.FullTrustAssemblies;
            m_encoding = level.m_encoding;
            m_generateQuickCacheOnLoad = false;
        }
        
        private void TurnCachingOff()
        {
            m_caching = false;
            StackCrawlMark marker = StackCrawlMark.LookForMe;
            Config.TurnCacheOff( ref marker );
        }

        internal void CheckLoaded( bool quickCacheOk )
        {
            if (!this.m_loaded)
            {
                Type type = typeof( PolicyLevel );

                lock (type)
                {
                    if (!this.m_loaded)
                    {
                        CodeAccessPermission.AssertAllPossible();

                        // We loop here to make sure that is any
                        // alterations are made to the list of
                        // policy levels that we detect that and
                        // try again until we have loaded all of
                        // them.

                        bool done = false;

                        while (!done)
                        {
                            try
                            {
                                IEnumerator enumerator = SecurityManager.InternalPolicyHierarchy();

                                while (enumerator.MoveNext())
                                {
                                    ((PolicyLevel)enumerator.Current).IndividualCheckLoaded( quickCacheOk );
                                }

                                done = true;
                            }
                            catch (InvalidOperationException)
                            {
                            }
                        }
                    }

                    if (!this.m_loaded)
                    {
                        this.IndividualCheckLoaded( quickCacheOk );
                    }
                }
            }
        }

        internal void IndividualCheckLoaded( bool quickCacheOk )
        {
            if (!m_loaded)
            {
                lock(this)
                {
                    if (!m_loaded)
                    {
                        Load( quickCacheOk );
                    }
                }

                // Here we wait around and hope that the threadpool
                // thread in charge of generating the quick cache
                // or the config file will complete in some reasonable
                // amount of time.  However, there is an intrinsic
                // deadlock condition where the current thread can be
                // holding a lock that the threadpool thread needs
                // in order to achieve its duties.  In that case, this
                // wait will time out and we'll continue processing
                // normally.  Note that the threadpool thread will then
                // continue once this thread has unwound out enough as
                // to release the lock.

                if (s_waitingThread == Thread.CurrentThread)
                {
                    int count = 0;

                    while (s_waitingLevel == this && count++ < s_maxLoopCount)
                        Thread.Sleep( 1 );
                }
            }
        }

        private Exception LoadError( String message )
        {
            if (m_throwOnLoadError)
            {
                return new ArgumentException( message );
            }
            else
            {
                Config.WriteToEventLog( message );
                return null;
            }
        }
        
        private void Load( bool quickCacheOk )
        {
            // Load the appropriate security.cfg file from disk, parse it into
            // SecurityElements and pass it to the FromXml method.
            // Note: we do all sorts of lazy parsing and creation of objects
            // even after we supposedly "load" everything using this method.
        
            // Note: we could have given back some cache results before doing
            // a load, but the load may decide that the file is incorrectly
            // formatted, reset the policy level and turn caching off.  This
            // should be ok since we will only have a valid cache file when
            // the config file has not changed and is known to be correctly
            // formatted.  This goes without saying, but screwing around with
            // the system clock can do very, very bad things to the cache
            // system. -gregfee 9/20/2000
        
            Parser parser;
            byte[] fileArray = Config.GetData( m_configId );
            SecurityElement elRoot;
            Exception exception = null;
            bool noConfig = false;

            if (fileArray == null)
            {
#if _DEBUG
                LoadError( String.Format( Environment.GetResourceString( "Error_NoConfigFile" ), m_label ) );
#endif
                noConfig = true;
                goto SETDEFAULT;
            }
            else
            {
                MemoryStream stream = new MemoryStream( fileArray );
                StreamReader reader = new StreamReader( stream );

                try
                {
                    parser = new Parser( reader );
                }
                catch (Exception ex)
                {
                    String message;

                    if (ex.Message != null && !ex.Message.Equals( "" ))
                    {
                        message = ex.Message;
                    }
                    else
                    {
                        message = ex.GetType().AssemblyQualifiedName;
                    }

                    exception = LoadError( String.Format( Environment.GetResourceString( "Error_SecurityPolicyFileParseEx" ), m_label, message ) );
                    goto SETDEFAULT;
                }
            }

            elRoot = parser.GetTopElement();
            
            if (elRoot == null)
            {
                exception = LoadError( String.Format( Environment.GetResourceString( "Error_SecurityPolicyFileParse" ), m_label ) );
                goto SETDEFAULT;
            }

            SecurityElement elMscorlib = elRoot.SearchForChildByTag( "mscorlib" );

            if (elMscorlib == null)
            {
                exception = LoadError( String.Format( Environment.GetResourceString( "Error_SecurityPolicyFileParse" ), m_label ) );
                goto SETDEFAULT;
            }
            
            SecurityElement elSecurity = elMscorlib.SearchForChildByTag( "security" );
            
            if (elSecurity == null)
            {
                exception = LoadError( String.Format( Environment.GetResourceString( "Error_SecurityPolicyFileParse" ), m_label ) );
                goto SETDEFAULT;
            }
            
            SecurityElement elPolicy = elSecurity.SearchForChildByTag( "policy" );

            if (elPolicy == null)
            {
                exception = LoadError( String.Format( Environment.GetResourceString( "Error_SecurityPolicyFileParse" ), m_label ) );
                goto SETDEFAULT;
            }

            SecurityElement elPolicyLevel = elPolicy.SearchForChildByTag( "PolicyLevel" );
            
            if (elPolicyLevel != null)
            {
                try
                {
                    this.FromXml( elPolicyLevel );
                }
                catch (Exception)
                {
                    exception = LoadError( String.Format( Environment.GetResourceString( "Error_SecurityPolicyFileParse" ), m_label ) );
                    goto SETDEFAULT;
                }
            }
            else
            {
                exception = LoadError( String.Format( Environment.GetResourceString( "Error_SecurityPolicyFileParse" ), m_label ) );
                goto SETDEFAULT;
            }

            this.m_encoding = parser.GetEncoding();

            // Here we'll queue a work item to generate the quick cache if we've
            // discovered that we need to do that.  The reason we do this on another
            // thread is to avoid the recursive load situation that can come up if
            // we are currently loading an assembly that is referenced in policy.
            // We have the additional caveat that if we try this during a prejit
            // we end up making all these unnecessary references to the assemblies
            // referenced in policy, and therefore if we are in the compilation domain
            // we'll just not generate the cache.

            m_loaded = true;

            if (m_generateQuickCacheOnLoad && Config.GenerateFilesAutomatically() && SecurityManager.SecurityEnabled)
            {
                Monitor.Enter( SecurityManager.GetCodeAccessSecurityEngine() );

                if (s_waitingLevel == null)
                {
                    s_waitingLevel = this;
                    s_waitingThread = Thread.CurrentThread;
                    ThreadPool.UnsafeQueueUserWorkItem( new WaitCallback( GenerateQuickCache ), this );
                }   

                Monitor.Exit( SecurityManager.GetCodeAccessSecurityEngine() );
            }

            return;

        SETDEFAULT:
            bool caching = this.m_caching;

            Reset();

            if (caching)
            {
                this.m_caching = true;
                if (m_useDefaultCodeGroupsOnReset)
                    Config.SetQuickCache( this.m_configId, PolicyLevelData.s_quickCacheDefaultCodeGroups );
                else
                    Config.SetQuickCache( this.m_configId, PolicyLevelData.s_quickCacheUnrestricted );
            }

            m_loaded = true;

            if (noConfig && Config.GenerateFilesAutomatically() && SecurityManager.SecurityEnabled)
            {
                Monitor.Enter( SecurityManager.GetCodeAccessSecurityEngine() );

                if (s_waitingLevel == null)
                {
                    s_waitingLevel = this;
                    s_waitingThread = Thread.CurrentThread;
                    ThreadPool.UnsafeQueueUserWorkItem( new WaitCallback( GenerateConfigFile ), this );
                }

                Monitor.Exit( SecurityManager.GetCodeAccessSecurityEngine() );
            }

            if (exception != null)
                throw exception;
        }
            
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.CreateAppDomainLevel"]/*' />
        public static PolicyLevel CreateAppDomainLevel()
        {
            return new PolicyLevel( "AppDomain" );
        }
        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.Label"]/*' />
        public String Label
        {
            get
            {
                return m_label;
            }
        }
        
        internal void SetLabel( String label )
        {
            m_label = label;
        }
        
        internal ConfigId ConfigId
        {
            get
            {
                return m_configId;
            }
        }

        internal bool ThrowOnLoadError
        {
            get
            {
                return m_throwOnLoadError;
            }

            set
            {
                m_throwOnLoadError = value;
            }
        }

        internal bool Loaded
        {
            get
            {
                return m_loaded;
            }

            set
            {
                m_loaded = value;
            }
        }

        internal Encoding Encoding
        {
            get
            {
                CheckLoaded( true );

                return m_encoding;
            }
        }

        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.StoreLocation"]/*' />
        public String StoreLocation
        {
            get
            {
                return Config.GetStoreLocation( ConfigId );
            }
        }
        
       
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.RootCodeGroup"]/*' />
        public CodeGroup RootCodeGroup
        {
            get
            {
                CheckLoaded( true );
                TurnCachingOff();
                
                //return m_rootCodeGroup.Copy();
                return m_rootCodeGroup;
            }
            
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "RootCodeGroup" );
            
                CheckLoaded( true );
                TurnCachingOff();
                
                m_rootCodeGroup = value.Copy();
            }
        }
        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.NamedPermissionSets"]/*' />
        public IList NamedPermissionSets
        {
            get
            {
                CheckLoaded( true );
                LoadAllPermissionSets();
        
                IEnumerator enumerator = m_namedPermissionSets.GetEnumerator();

                ArrayList newList = new ArrayList( m_namedPermissionSets.Count );

                while (enumerator.MoveNext())
                {
                    newList.Add( ((NamedPermissionSet)enumerator.Current).Copy() );
                }

                return newList;
            }
        }

        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.AddFullTrustAssembly"]/*' />
        public void AddFullTrustAssembly( StrongName sn )
        {
            if (sn == null)
                throw new ArgumentNullException( "sn" );

            AddFullTrustAssembly( new StrongNameMembershipCondition( sn.PublicKey, sn.Name, sn.Version ) );
        }

        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.AddFullTrustAssembly1"]/*' />
        public void AddFullTrustAssembly( StrongNameMembershipCondition snMC )
        {
            if (snMC == null)
                throw new ArgumentNullException( "snMC" );

            CheckLoaded( true );

            IEnumerator enumerator = m_fullTrustAssemblies.GetEnumerator();

            while (enumerator.MoveNext())
            {
                if (((StrongNameMembershipCondition)enumerator.Current).Equals( snMC ))
                {
                    throw new ArgumentException( Environment.GetResourceString( "Argument_AssemblyAlreadyFullTrust" ) );
                }
            }

            lock (m_fullTrustAssemblies)
            {
                m_fullTrustAssemblies.Add( snMC );
            }
        }

        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.RemoveFullTrustAssembly"]/*' />
        public void RemoveFullTrustAssembly( StrongName sn )
        {
            if (sn == null)
                throw new ArgumentNullException( "assembly" );

            RemoveFullTrustAssembly( new StrongNameMembershipCondition( sn.PublicKey, sn.Name, sn.Version ) );
        }

        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.RemoveFullTrustAssembly1"]/*' />
        public void RemoveFullTrustAssembly( StrongNameMembershipCondition snMC )
        {
            if (snMC == null)
                throw new ArgumentNullException( "snMC" );
                
            CheckLoaded( true );

            Object toRemove = null;

            IEnumerator enumerator = m_fullTrustAssemblies.GetEnumerator();

            while (enumerator.MoveNext())
            {
                if (((StrongNameMembershipCondition)enumerator.Current).Equals( snMC ))
                {
                    toRemove = enumerator.Current;
                    break;
                }
            }

            if (toRemove != null)
            {
                lock (m_fullTrustAssemblies)
                {
                    m_fullTrustAssemblies.Remove( toRemove );
                }
            }
            else
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_AssemblyNotFullTrust" ) );
            }
        }

        internal bool IsFullTrustAssembly( ArrayList fullTrustAssemblies, Evidence evidence )
        {
            CheckLoaded( true );

            if (fullTrustAssemblies.Count == 0)
                return false;

            if (evidence != null)
            {
                lock (fullTrustAssemblies)
                {
                    IEnumerator enumerator = fullTrustAssemblies.GetEnumerator();

                    while (enumerator.MoveNext())
                    {
                        StrongNameMembershipCondition snMC = (StrongNameMembershipCondition)enumerator.Current;

                        if (snMC.Check( evidence ) && s_zoneMembershipCondition.Check( evidence ))
                            return true;
                    }
                }
            }

            return false;
        }

        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.FullTrustAssemblies"]/*' />
        public IList FullTrustAssemblies
        {
            get
            {
                CheckLoaded( true );

                return new ArrayList( m_fullTrustAssemblies );
            }
        }
        
        internal static NamedPermissionSet CreateFullTrustSet()
        {
            NamedPermissionSet permSet;
            
            permSet = new NamedPermissionSet( "FullTrust", PermissionState.Unrestricted );
            permSet.Description = Environment.GetResourceString("Policy_PS_FullTrust");
            
            return permSet;
        }            

        internal static NamedPermissionSet CreateNothingSet()
        {
            NamedPermissionSet permSet;
            
            permSet = new NamedPermissionSet( "Nothing", PermissionState.None );
            permSet.Description = Environment.GetResourceString("Policy_PS_Nothing");
                        
            return permSet;
        }            
  
        internal static NamedPermissionSet CreateExecutionSet()
        {
            NamedPermissionSet permSet;
            
            permSet = new NamedPermissionSet( "Execution", PermissionState.None );
            permSet.Description = Environment.GetResourceString("Policy_PS_Execution");
            permSet.AddPermission( new SecurityPermission( SecurityPermissionFlag.Execution ) );
                        
            return permSet;
        }            
        
        internal static NamedPermissionSet CreateSkipVerificationSet()
        {
            NamedPermissionSet permSet;
            
            permSet = new NamedPermissionSet( "SkipVerification", PermissionState.None );
            permSet.Description = Environment.GetResourceString("Policy_PS_SkipVerification");
            permSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.SkipVerification));

            return permSet;
        }
        
        internal static NamedPermissionSet CreateInternetSet()
        {
            PolicyLevel level = new PolicyLevel( "Temp" );
            
            return level.GetNamedPermissionSet( "Internet" );
        }            

        internal static NamedPermissionSet CreateLocalIntranetSet()
        {
            PolicyLevel level = new PolicyLevel( "Temp" );
            
            return level.GetNamedPermissionSet( "LocalIntranet" );
        }            


        internal void SetFactoryPermissionSets()
        {
            lock (this)
            {
                m_namedPermissionSets = new ArrayList();

                String defaultPermissionSets = PolicyLevelData.s_defaultPermissionSets.Replace( "{VERSION}", s_mscorlibVersionString );
                defaultPermissionSets = defaultPermissionSets.Replace( "{Policy_PS_FullTrust}", Environment.GetResourceString( "Policy_PS_FullTrust" ) );
                defaultPermissionSets = defaultPermissionSets.Replace( "{Policy_PS_Everything}", Environment.GetResourceString( "Policy_PS_Everything" ) );
                defaultPermissionSets = defaultPermissionSets.Replace( "{Policy_PS_Nothing}", Environment.GetResourceString( "Policy_PS_Nothing" ) );
                defaultPermissionSets = defaultPermissionSets.Replace( "{Policy_PS_SkipVerification}", Environment.GetResourceString( "Policy_PS_SkipVerification" ) );
                defaultPermissionSets = defaultPermissionSets.Replace( "{Policy_PS_Execution}", Environment.GetResourceString( "Policy_PS_Execution" ) );

                m_permSetElement = new Parser( defaultPermissionSets ).GetTopElement();

                m_permSetElement.AddChild( GetInternetElement() );
                m_permSetElement.AddChild( GetLocalIntranetElement() );
            }
        }

        internal SecurityElement GetInternetElement()
        {
            return new Parser( s_internetPermissionSet.Replace( "{VERSION}", s_mscorlibVersionString ).Replace( "{Policy_PS_Internet}", Environment.GetResourceString( "Policy_PS_Internet" ) ) ).GetTopElement();
        }

        internal SecurityElement GetLocalIntranetElement()
        {
            return new Parser( s_localIntranetPermissionSet.Replace( "{VERSION}", s_mscorlibVersionString ).Replace( "{Policy_PS_LocalIntranet}", Environment.GetResourceString( "Policy_PS_LocalIntranet" ) ) ).GetTopElement();
        }
        
        internal void SetDefaultCodeGroups()
        {
            // NOTE: if you are going to add references to any permission set
            // that references permissions outside of mscorlib, DO NOT
            // CALL GetNamedPermissionSetInternal().  You need to use
            // CreateCodeGroupElement() and AddChildInternal().

            // NOTE: any changes to this will require that you recontemplate
            // the quick cache data found in PolicyLevelData.

            // Before we call GetNamedPermissionSetInternal, make sure that we are "loaded"
            m_loaded = true;
            UnionCodeGroup root = new UnionCodeGroup();
            root.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "Nothing", new AllMembershipCondition().ToXml() ), this );
            root.Name = Environment.GetResourceString( "Policy_AllCode_Name" );
            root.Description = Environment.GetResourceString( "Policy_AllCode_DescriptionNothing" );

            UnionCodeGroup myComputerCodeGroup = new UnionCodeGroup();
            myComputerCodeGroup.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "FullTrust", new ZoneMembershipCondition( SecurityZone.MyComputer ).ToXml() ), this );
            myComputerCodeGroup.Name = Environment.GetResourceString( "Policy_MyComputer_Name" );
            myComputerCodeGroup.Description = Environment.GetResourceString( "Policy_MyComputer_Description" );

            // This code give trust to anything StrongName signed by Microsoft.
            StrongNamePublicKeyBlob blob = new StrongNamePublicKeyBlob( PolicyLevelData.s_microsoftPublicKey );
            UnionCodeGroup microsoft = new UnionCodeGroup();
            microsoft.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "FullTrust", new StrongNameMembershipCondition( blob, null, null ).ToXml() ), this );
            microsoft.Name = Environment.GetResourceString( "Policy_Microsoft_Name" );
            microsoft.Description = Environment.GetResourceString( "Policy_Microsoft_Description" );
            myComputerCodeGroup.AddChildInternal( microsoft );

            // This code give trust to anything StrongName signed using the ECMA
            // public key (core system assemblies).
            blob = new StrongNamePublicKeyBlob( PolicyLevelData.s_ecmaPublicKey );
            UnionCodeGroup ecma = new UnionCodeGroup();
            ecma.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "FullTrust", new StrongNameMembershipCondition( blob, null, null ).ToXml() ), this );
            ecma.Name = Environment.GetResourceString( "Policy_Ecma_Name" );
            ecma.Description = Environment.GetResourceString( "Policy_Ecma_Description" );
            myComputerCodeGroup.AddChildInternal( ecma );

            root.AddChildInternal(myComputerCodeGroup);
            
            // do the rest of the zones
            CodeGroup intranet = new UnionCodeGroup();
            intranet.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "LocalIntranet", new ZoneMembershipCondition( SecurityZone.Intranet ).ToXml() ), this );
            intranet.Name = Environment.GetResourceString( "Policy_Intranet_Name" );
            intranet.Description = Environment.GetResourceString( "Policy_Intranet_Description" );

            CodeGroup intranetNetCode = new NetCodeGroup( new AllMembershipCondition() );
            intranetNetCode.Name = Environment.GetResourceString( "Policy_IntranetNet_Name" );
            intranetNetCode.Description = Environment.GetResourceString( "Policy_IntranetNet_Description" );
            intranet.AddChildInternal( intranetNetCode );

            CodeGroup intranetFileCode = new FileCodeGroup( new AllMembershipCondition(), FileIOPermissionAccess.Read | FileIOPermissionAccess.PathDiscovery );
            intranetFileCode.Name = Environment.GetResourceString( "Policy_IntranetFile_Name" );
            intranetFileCode.Description = Environment.GetResourceString( "Policy_IntranetFile_Description" );
            intranet.AddChildInternal( intranetFileCode );

            root.AddChildInternal( intranet );

            CodeGroup internet = new UnionCodeGroup();
            internet.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "Internet", new ZoneMembershipCondition( SecurityZone.Internet ).ToXml() ), this );
            internet.Name = Environment.GetResourceString( "Policy_Internet_Name" );
            internet.Description = Environment.GetResourceString( "Policy_Internet_Description" );

            CodeGroup internetNet = new NetCodeGroup( new AllMembershipCondition() );
            internetNet.Name = Environment.GetResourceString( "Policy_InternetNet_Name" );
            internetNet.Description = Environment.GetResourceString( "Policy_InternetNet_Description" );
            internet.AddChildInternal( internetNet );

            root.AddChildInternal( internet );

            CodeGroup untrusted = new UnionCodeGroup();
            untrusted.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "Nothing", new ZoneMembershipCondition( SecurityZone.Untrusted ).ToXml() ), this );
            untrusted.Name = Environment.GetResourceString( "Policy_Untrusted_Name" );
            untrusted.Description = Environment.GetResourceString( "Policy_Untrusted_Description" );
            root.AddChildInternal( untrusted );

            CodeGroup trusted = new UnionCodeGroup();
            trusted.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "Internet", new ZoneMembershipCondition( SecurityZone.Trusted ).ToXml() ), this );
            trusted.Name = Environment.GetResourceString( "Policy_Trusted_Name" );
            trusted.Description = Environment.GetResourceString( "Policy_Trusted_Description" );
            CodeGroup trustedNet = new NetCodeGroup( new AllMembershipCondition() );
            trustedNet.Name = Environment.GetResourceString( "Policy_TrustedNet_Name" );
            trustedNet.Description = Environment.GetResourceString( "Policy_TrustedNet_Description" );
            trusted.AddChildInternal( trustedNet );

            root.AddChildInternal( trusted );
            m_rootCodeGroup = root;
        }

        internal static SecurityElement CreateCodeGroupElement( String codeGroupType, String permissionSetName, SecurityElement mshipElement )
        {
            SecurityElement root = new SecurityElement( "CodeGroup" );
            root.AddAttribute( "class", "System.Security." + codeGroupType + ", mscorlib, PublicKeyToken=b77a5c561934e089" );
            root.AddAttribute( "version", "1" );
            root.AddAttribute( "PermissionSetName", permissionSetName );

            root.AddChild( mshipElement );

            return root;
        }

        internal void SetDefaultFullTrustAssemblies()
        {
            m_fullTrustAssemblies = new ArrayList();

            lock (m_fullTrustAssemblies)
            {
                StrongNamePublicKeyBlob ecmaBlob = new StrongNamePublicKeyBlob( s_ecmaPublicKey );

                if (s_ecmaMscorlibResource == null)
                {
                    s_ecmaMscorlibResource = new StrongNameMembershipCondition( ecmaBlob,
                                                                                "mscorlib.resources",
                                                                                s_mscorlibVersion );
                }
                m_fullTrustAssemblies.Add( s_ecmaMscorlibResource );

                StrongNameMembershipCondition ecmaSystem = new StrongNameMembershipCondition( ecmaBlob,
                                                       "System",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( ecmaSystem );

                StrongNameMembershipCondition ecmaSystemResources = new StrongNameMembershipCondition( ecmaBlob,
                                                       "System.resources",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( ecmaSystemResources );

                StrongNameMembershipCondition ecmaSystemData = new StrongNameMembershipCondition( ecmaBlob,
                                                       "System.Data",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( ecmaSystemData );

                StrongNameMembershipCondition ecmaSystemDataResources = new StrongNameMembershipCondition( ecmaBlob,
                                                       "System.Data.resources",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( ecmaSystemDataResources );

                StrongNamePublicKeyBlob microsoftBlob = new StrongNamePublicKeyBlob( PolicyLevelData.s_microsoftPublicKey );

                StrongNameMembershipCondition microsoftSystemDrawing = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.Drawing",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemDrawing );

                StrongNameMembershipCondition microsoftSystemDrawingResources = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.Drawing.resources",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemDrawingResources );


                StrongNameMembershipCondition microsoftSystemMessaging = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.Messaging",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemMessaging );

                StrongNameMembershipCondition microsoftSystemMessagingResources = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.Messaging.resources",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemMessagingResources );

                StrongNameMembershipCondition microsoftSystemServiceProcess = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.ServiceProcess",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemServiceProcess );

                StrongNameMembershipCondition microsoftSystemServiceProcessResources = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.ServiceProcess.resources",
                                                       s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemServiceProcessResources );


                StrongNameMembershipCondition microsoftSystemDirectoryServices = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.DirectoryServices",
                                                          s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemDirectoryServices );

                StrongNameMembershipCondition microsoftSystemDirectoryServicesResources = new StrongNameMembershipCondition( microsoftBlob,
                                                       "System.DirectoryServices.resources",
                                                          s_mscorlibVersion );

                m_fullTrustAssemblies.Add( microsoftSystemDirectoryServicesResources );
            }
        }

            
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.Recover"]/*' />
        public void Recover()
        {
            if (m_configId == ConfigId.None)
                throw new PolicyException( Environment.GetResourceString( "Policy_RecoverNotFileBased" ) );
                
            lock (this)
            {
                // This call will safely swap the files.

                if (!Config.RecoverData( m_configId ))
                    throw new PolicyException( Environment.GetResourceString( "Policy_RecoverNoConfigFile" ) );
                
                // Now we need to blank out the level
            
                m_loaded = false;
                m_rootCodeGroup = null;
                m_namedPermissionSets = null;
                m_fullTrustAssemblies = new ArrayList();
            }
        }    
        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.Reset"]/*' />
        public void Reset()
        {
            lock (this)
            {
                m_loaded = false;
                TurnCachingOff();
                m_namedPermissionSets = null;
                m_rootCodeGroup = null;
                m_permSetElement = null;
            
                SetFactoryPermissionSets();
                SetDefaultFullTrustAssemblies();
            
                if (m_useDefaultCodeGroupsOnReset)
                {
                    SetDefaultCodeGroups();
                }
                else
                {
                    m_rootCodeGroup = CreateDefaultAllGroup();
                }
                m_loaded = true;
            }
        }    
            
        private CodeGroup CreateDefaultAllGroup()
        {
            UnionCodeGroup group = new UnionCodeGroup();
            group.FromXml( CreateCodeGroupElement( "UnionCodeGroup", "FullTrust", new AllMembershipCondition().ToXml() ), this );
            group.Name = Environment.GetResourceString( "Policy_AllCode_Name" );
            group.Description = Environment.GetResourceString( "Policy_AllCode_DescriptionFullTrust" );
            return group;
        }

        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.AddNamedPermissionSet"]/*' />
        public void AddNamedPermissionSet( NamedPermissionSet permSet )
        {
            CheckLoaded( true );
            LoadAllPermissionSets();
        
            lock (this)
            {
                if (permSet == null)
                    throw new ArgumentNullException("permSet");

                IEnumerator enumerator = m_namedPermissionSets.GetEnumerator();
            
                while (enumerator.MoveNext())
                {
                    if (((NamedPermissionSet)enumerator.Current).Name.Equals( permSet.Name ))
                    {
                        throw new ArgumentException( Environment.GetResourceString( "Argument_DuplicateName" ) );
                    }
                }
            
                m_namedPermissionSets.Add( permSet.Copy() );
            }
        }
        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.RemoveNamedPermissionSet"]/*' />
        public NamedPermissionSet RemoveNamedPermissionSet( NamedPermissionSet permSet )
        {
            CheckLoaded( true );
        
            if (permSet == null)
                throw new ArgumentNullException( "permSet" );
        
            return RemoveNamedPermissionSet( permSet.Name );
        }
        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.RemoveNamedPermissionSet1"]/*' />
        public NamedPermissionSet RemoveNamedPermissionSet( String name )
        {
            CheckLoaded( true );
            LoadAllPermissionSets();
        
            if (name == null)
                throw new ArgumentNullException( "name" );
        
            int permSetIndex = -1;
            
            // First, make sure it's not a reserved permission set.
            
            for (int index = 0; index < m_reservedPermissionSets.Length; ++index)
            {
                if (m_reservedPermissionSets[index].Equals( name ))
                {
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_ReservedNPMS" ), name ) );
                }
            }
            
            // Then, find out if a named permission set of that name exists
            // and remember its index;
            
            ArrayList namedPermissionSets = m_namedPermissionSets;

            for (int index = 0; index < namedPermissionSets.Count; ++index)
            {
                if (((NamedPermissionSet)namedPermissionSets[index]).Name.Equals( name ))
                {
                    permSetIndex = index;
                    break;
                }
            }
            
            if (permSetIndex == -1)
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_NoNPMS" ) );
            }
            
            // Now, as best as we can in the face of custom CodeGroups figure
            // out if the permission set is in use.  If it is we don't allow
            // it to be removed.
            
            ArrayList groups = new ArrayList();
            groups.Add( this.m_rootCodeGroup );
            
            for (int index = 0; index < groups.Count; ++index)
            {
                CodeGroup group = (CodeGroup)groups[index];
                
                if (group.PermissionSetName != null && group.PermissionSetName.Equals( name ))
                {
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_NPMSInUse" ), name ) );
                }
                
                IEnumerator childEnumerator = group.Children.GetEnumerator();
                
                if (childEnumerator != null)
                {
                    while (childEnumerator.MoveNext())
                    {
                        groups.Add( childEnumerator.Current );
                    }
                }
            }
            
            TurnCachingOff();
            
            NamedPermissionSet permSet = (NamedPermissionSet)namedPermissionSets[permSetIndex];
            
            namedPermissionSets.RemoveAt( permSetIndex );
            
            return permSet;
        }
        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.ChangeNamedPermissionSet"]/*' />
        public NamedPermissionSet ChangeNamedPermissionSet( String name, PermissionSet pSet )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
                
            if (pSet == null)
                throw new ArgumentNullException( "pSet" );
        
            // First, make sure it's not a reserved permission set.
            
            for (int index = 0; index < m_reservedPermissionSets.Length; ++index)
            {
                if (m_reservedPermissionSets[index].Equals( name ))
                {
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_ReservedNPMS" ), name ) );
                }
            }
        
            // Turn caching off for this level.

            TurnCachingOff();
        
            // Get the current permission set (don't copy it).
        
            NamedPermissionSet currentPSet = GetNamedPermissionSetInternal( name );
            
            // If the permission set doesn't exist, throw an argument exception
            
            if (currentPSet == null)
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_NoNPMS" ) );
            }           
            
            // Copy the current permission set so that we can return it.
            
            NamedPermissionSet retval = (NamedPermissionSet)currentPSet.Copy();
            
            // Reset the permission set to simply unrestricted.
            
            currentPSet.Reset();
            currentPSet.SetUnrestricted( pSet.IsUnrestricted() );
            
            IEnumerator enumerator = pSet.GetEnumerator();
            
            while (enumerator.MoveNext())
            {
                currentPSet.SetPermission( ((IPermission)enumerator.Current).Copy() );
            }

            if (pSet is NamedPermissionSet)
            {
                currentPSet.Description = ((NamedPermissionSet)pSet).Description;
            }
            
            return retval;
        }
    
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.GetNamedPermissionSet"]/*' />
        public NamedPermissionSet GetNamedPermissionSet( String name )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
        
            NamedPermissionSet permSet = GetNamedPermissionSetInternal( name );
            
            // Copy it so that no corruption can occur.
            
            if (permSet != null)
                return new NamedPermissionSet( permSet );
            else
                return null;
        }
        
        internal NamedPermissionSet GetNamedPermissionSetInternal( String name )
        {
            CheckLoaded( true );

            Type type = typeof( PolicyLevel );

            lock (type)
            {
                // First, try to find it in the list.
        
                IEnumerator enumerator = m_namedPermissionSets.GetEnumerator();
            
                while (enumerator.MoveNext())
                {
                    NamedPermissionSet current = (NamedPermissionSet)enumerator.Current;
                    if (current.Name.Equals( name ))
                    {
                        if (!current.IsFullyLoaded())
                            current.LoadPostponedPermissions();

                        // don't copy because we know we're not going to be stupid.
                    
                        return current;                    
                    }
                }
            
                // We didn't find it in the list, so if we have a stored element
                // see if it is there.
            
                if (m_permSetElement != null)
                {
                    SecurityElement elem = FindElement( name );
                
                    if (elem != null)
                    {
                        bool fullyLoaded;
                        NamedPermissionSet permSet = new NamedPermissionSet();
                        permSet.Name = name;
                        m_namedPermissionSets.Add( permSet );
                        try
                        {
                            // We play it conservative here and just say that we are loading policy
                            // anytime we have to decode a permission set.
                            permSet.FromXml( elem, true, out fullyLoaded );
                        }
                        catch (Exception)
                        {
                            m_namedPermissionSets.Remove( permSet );
                            return null;
                        }
                    
                        if (permSet.Name != null)
                        {
                            if (!fullyLoaded)
                            {
                                m_namedPermissionSets.Remove( permSet );
                                InsertElement( elem );
                            }
                            return permSet;
                        }
                        else
                        {
                            m_namedPermissionSets.Remove( permSet );
                            return null;
                        }
                    }
                }
     
                return null;
            }
        }
        
        private SecurityElement FindElement( String name )
        {
            SecurityElement element = FindElement( m_permSetElement, name );

            if (m_permSetElement.m_lChildren.Count == 0)
                m_permSetElement = null;

            return element;
        }

        private SecurityElement FindElement( SecurityElement element, String name )
        {
            // This method searches through the children of the saved element
            // for a named permission set that matches the input name.
            // If it finds a matching set, the appropriate xml element is
            // removed from as a child of the parent and then returned.
        
            IEnumerator elemEnumerator = element.Children.GetEnumerator();
        
            while (elemEnumerator.MoveNext())
            {
                SecurityElement elPermSet = (SecurityElement)elemEnumerator.Current;
            
                if (elPermSet.Tag.Equals( "PermissionSet" ))
                {
                    String elName = elPermSet.Attribute( "Name" );
            
                    if (elName != null && elName.Equals( name ))
                    {
                        element.m_lChildren.Remove( elPermSet );
                        return elPermSet;
                    }
                }
            }
            
            return null;
        }

        private void InsertElement( SecurityElement element )
        {
            if (m_permSetElement == null)
            {
                m_permSetElement = new SecurityElement();
            }

            m_permSetElement.AddChild( element );
        }

        private void LoadAllPermissionSets()
        {
            // This function loads all the permission sets held in the m_permSetElement member.
            // This is useful when you know that an arbitrary permission set loaded from
            // the config file could be accessed so you just want to forego the lazy load
            // and play it safe.
        
            if (m_permSetElement != null && m_permSetElement.m_lChildren != null)
            {
                Type type = typeof( PolicyLevel );

                lock (type)
                {
                    while (m_permSetElement != null && m_permSetElement.m_lChildren.Count != 0)
                    {
                        SecurityElement elPermSet = (SecurityElement)m_permSetElement.m_lChildren[m_permSetElement.m_lChildren.Count-1];
                        m_permSetElement.m_lChildren.RemoveAt( m_permSetElement.m_lChildren.Count-1 );
                
                        if (elPermSet.Tag.Equals( "PermissionSet" ) && elPermSet.Attribute( "class" ).Equals( "System.Security.NamedPermissionSet" ))
                        {
                            NamedPermissionSet permSet = new NamedPermissionSet();
                            permSet.FromXmlNameOnly( elPermSet );

                            if (permSet.Name != null)
                            {
                                m_namedPermissionSets.Add( permSet );
                                try
                                {
                                    // We play it conservative here and just say that we are loading policy
                                    // anytime we have to decode a permission set.
                                    bool fullyLoaded;
                                    permSet.FromXml( elPermSet, true, out fullyLoaded );
                                }
                                catch (Exception)
                                {
                                    m_namedPermissionSets.Remove( permSet );
                                }
                            }
                        }
                    }
        
                    m_permSetElement = null;
                }
            }
        }
        
        static internal PermissionSet GetBuiltInSet( String name )
        {   
            // Used by PermissionSetAttribute to create one of the built-in,
            // immutable permission sets.
        
            if (name == null)
                return null;
            else if (name.Equals( "FullTrust" ))
                return CreateFullTrustSet();
            else if (name.Equals( "Nothing" ))
                return CreateNothingSet();
            else if (name.Equals( "Execution" ))
                return CreateExecutionSet();
            else if (name.Equals( "SkipVerification" ))
                return CreateSkipVerificationSet();
            else if (name.Equals( "Internet" ))
                return CreateInternetSet();
            else if (name.Equals( "LocalIntranet" ))
                return CreateLocalIntranetSet();
            else
                return null;
        }
        
        private void CombinePolicy( PolicyStatement left, PolicyStatement right )
        {
#if _DEBUG
            if (debug)
            {
                DEBUG_OUT( "left = \n" + (left == null ? "<null>" : left.ToXml().ToString() ) );
                DEBUG_OUT( "right = \n" + (right == null ? "<null>" : right.ToXml().ToString() ) );
            } 
#endif
            if (right == null)
            {
                return;
            }
            else
            {
                // An exception somewhere in here means that a permission
                // failed some operation.  This simply means that it will be
                // dropped from the grant set which is safe operation that
                // can be ignored.
                
                try
                {
                    left.GetPermissionSetNoCopy().InplaceUnion( right.GetPermissionSetNoCopy() );
                }
                catch (Exception)
                {
                }
                left.Attributes = left.Attributes | right.Attributes;
            }

#if _DEBUG
            if (debug)          
                DEBUG_OUT( "outcome =\n" + left.ToXml().ToString() );
#endif
        }
            
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.Resolve"]/*' />
        public PolicyStatement Resolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException( "evidence" );
        
            return Resolve( evidence, 0, null );
        }

        internal PolicyStatement Resolve( Evidence evidence, int count, char[] serializedEvidence )
        {
            PolicyStatement policy;
            bool xmlError = false;

            if (m_caching && serializedEvidence != null)
                policy = CheckCache( count, serializedEvidence, out xmlError );
            else
                policy = null;
                
            if (policy == null)
            {
                // Build up the membership condition to check for mscorlib resource assemblies       
                if (s_ecmaMscorlibResource == null)
                {
                    StrongNamePublicKeyBlob ecmaBlob = new StrongNamePublicKeyBlob( s_ecmaPublicKey );
                    s_ecmaMscorlibResource = new StrongNameMembershipCondition( ecmaBlob,
                                                                                "mscorlib.resources",
                                                                                null );
                }
                // If this is a resource assembly, then skip the resolve
                if (s_ecmaMscorlibResource.Check( evidence ))
                {
                    policy = new PolicyStatement( new PermissionSet( true ), PolicyStatementAttribute.Nothing );
                }
                else // We need to do the resolve
                {
                    CheckLoaded( false );
                
                    bool allConst;
                    bool isFullTrust;
    
                    ArrayList fullTrustAssemblies = m_fullTrustAssemblies;

                    isFullTrust = fullTrustAssemblies != null && IsFullTrustAssembly( fullTrustAssemblies, evidence );

                    if (isFullTrust)
                    {
                        policy = new PolicyStatement( new PermissionSet( true ), PolicyStatementAttribute.Nothing );
                        allConst = true;
                    }
                    else
                    {
                        ArrayList list = GenericResolve( evidence, out allConst ); 
                        policy = new PolicyStatement();
                        // This will set the permission set to the empty set.
                        policy.PermissionSet = null;

                        IEnumerator enumerator = list.GetEnumerator();
        
                        while (enumerator.MoveNext())
                        {
                            CombinePolicy( policy, ((CodeGroupStackFrame)enumerator.Current).policy );
                        }
                    }
                
                
                    if (m_caching && allConst && serializedEvidence != null && !xmlError)
                    {
                            Cache( count, serializedEvidence, policy );
                    }
                } 
            }
    
            return policy;
        }
                    
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.ResolveMatchingCodeGroups"]/*' />
        public CodeGroup ResolveMatchingCodeGroups( Evidence evidence )
        {
            CheckLoaded( true );
            
            if (evidence == null)
                throw new ArgumentNullException( "evidence" );
                
            return this.RootCodeGroup.ResolveMatchingCodeGroups( evidence );
        }
                
        private ArrayList GenericResolve( Evidence evidence, out bool allConst )
        {
            CodeGroupStack stack = new CodeGroupStack();
            
            // Note: if m_rootCodeGroup is null it means that we've
            // hit a recursive load case and ended up needing to
            // do a resolve on an assembly used in policy but is
            // not covered by the full trust assemblies list.  We'll
            // throw a policy exception to cover this case.

            CodeGroupStackFrame frame;
            CodeGroup rootCodeGroupRef = m_rootCodeGroup;

            if (rootCodeGroupRef == null)
                throw new PolicyException( Environment.GetResourceString( "Policy_NonFullTrustAssembly" ) );

            frame = new CodeGroupStackFrame();
            frame.current = rootCodeGroupRef;
            frame.parent = null;

            stack.Push( frame );
            
            ArrayList accumulator = new ArrayList();
            
            bool foundExclusive = false;
            
            allConst = true;

            Exception storedException = null;
            
            while (!stack.IsEmpty())
            {
                frame = stack.Pop();
                
#if _DEBUG
                if (debug)          
                    DEBUG_OUT( "Current frame =\n" + frame.current.ToXml().ToString() );
#endif
                
                UnionCodeGroup unionGroup = frame.current as UnionCodeGroup;
                NetCodeGroup netGroup = frame.current as NetCodeGroup;
                FileCodeGroup fileGroup = frame.current as FileCodeGroup;

                if (!(frame.current.MembershipCondition is IConstantMembershipCondition) || !(unionGroup != null || netGroup != null || fileGroup != null))
                {
                    allConst = false;
                }
         
                try
                {
                    if (unionGroup != null)
                        frame.policy = unionGroup.InternalResolve( evidence );
                    else if (netGroup != null)
                        frame.policy = netGroup.InternalResolve( evidence );
                    else if (fileGroup != null)
                        frame.policy = fileGroup.InternalResolve( evidence );
                    else
                        frame.policy = frame.current.Resolve( evidence );
                }
                catch (Exception e)
                {
                    // If any exception occurs while attempting a resolve, we catch it here and
                    // set the equivalent of the resolve not matching to the evidence.
                    //frame.policy = null;

                    if (storedException == null)
                        storedException = e;
                }
    
#if _DEBUG
                if (debug)          
                    DEBUG_OUT( "Check gives =\n" + (frame.policy == null ? "<null>" : frame.policy.ToXml().ToString() ) );
#endif
                    
                if (frame.policy != null)
                {
                    if ((frame.policy.Attributes & PolicyStatementAttribute.Exclusive) != 0)
                    {
#if _DEBUG
                        if (debug)          
                            DEBUG_OUT( "Discovered exclusive group" );
#endif
                        
                        if (foundExclusive)
                        {
                            throw new PolicyException( Environment.GetResourceString( "Policy_MultipleExclusive" ) );
                        }
                        else
                        {
                            accumulator.RemoveRange( 0, accumulator.Count );
                        
                            accumulator.Add( frame );
                       
                            foundExclusive = true;
                        }
                    }
                    
                    // We unroll the recursion in the case where we have UnionCodeGroups or NetCodeGroups.  

                    

                    if (unionGroup != null || netGroup != null || fileGroup != null)
                    {
                        IList children = ((CodeGroup)frame.current).GetChildrenInternal();
                   
                        if (children != null && children.Count > 0)
                        {
                            IEnumerator enumerator = children.GetEnumerator();
                                
                            while (enumerator.MoveNext())
                            {
#if _DEBUG
                                if (debug)          
                                    DEBUG_OUT( "Pushing =\n" + ((CodeGroup)enumerator.Current).ToXml().ToString());
#endif
                                    
                                CodeGroupStackFrame newFrame = new CodeGroupStackFrame();
                                    
                                newFrame.current = (CodeGroup)enumerator.Current;
                                newFrame.parent = frame;
                                    
                                stack.Push( newFrame );
                            }
                        }
                    }
                    
                    if (!foundExclusive)
                    {
                        accumulator.Add( frame );
                    }
                }
            }

            if (storedException != null)
                throw storedException;
        
            return accumulator;    
        }
                    
        private static String GenerateFriendlyName( String className, Hashtable classes )
        {
            if (classes.ContainsKey( className ))
                return (String)classes[className];

            Type type = RuntimeType.GetTypeInternal( className, false, false, true );

            if (type == null)
            {
                return className;
            }

            if (!classes.ContainsValue( type.Name ))
            {
                classes.Add( className, type.Name );
                return type.Name;
            }
            else if (!classes.ContainsValue( type.FullName ))
            {
                classes.Add( className, type.FullName );
                return type.FullName;
            }
            else
            {
                classes.Add( className, type.AssemblyQualifiedName );
                return type.AssemblyQualifiedName;
            }
        }

        private SecurityElement NormalizeClassDeep( SecurityElement elem, Hashtable classes )
        {
            NormalizeClass( elem, classes );

            if (elem.m_lChildren != null && elem.m_lChildren.Count > 0)
            {
                IEnumerator enumerator = elem.m_lChildren.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    NormalizeClassDeep( (SecurityElement)enumerator.Current, classes );
                }
            }

            return elem;
        }

        private SecurityElement NormalizeClass( SecurityElement elem, Hashtable classes )
        {
            if (elem.m_lAttributes == null || elem.m_lAttributes.Count == 0)
                return elem;

            IEnumerator enumerator = elem.m_lAttributes.GetEnumerator();

            while (enumerator.MoveNext())
            {
                SecurityStringPair current = (SecurityStringPair)enumerator.Current;

                if (current.m_strAttributeName.Equals( "class" ))
                {
                    current.m_strAttributeValue = GenerateFriendlyName( current.m_strAttributeValue, classes );
                    break;
                }
            }

            return elem;
        }

        private SecurityElement UnnormalizeClassDeep( SecurityElement elem, Hashtable classes )
        {
            UnnormalizeClass( elem, classes );

            if (elem.m_lChildren != null && elem.m_lChildren.Count > 0)
            {
                IEnumerator enumerator = elem.m_lChildren.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    UnnormalizeClassDeep( (SecurityElement)enumerator.Current, classes );
                }
            }

            return elem;
        }

        private SecurityElement UnnormalizeClass( SecurityElement elem, Hashtable classes )
        {
            if (classes == null || elem.m_lAttributes == null || elem.m_lAttributes.Count == 0)
                return elem;

            IEnumerator enumerator = elem.m_lAttributes.GetEnumerator();

            while (enumerator.MoveNext())
            {
                SecurityStringPair current = (SecurityStringPair)enumerator.Current;

                if (current.m_strAttributeName.Equals( "class" ))
                {
                    String className = (String)classes[current.m_strAttributeValue];

                    if (className != null)
                    {
                        current.m_strAttributeValue = className;
                    }
                    break;
                }
            }

            return elem;
        }

                    
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            // Make sure we have loaded everything and that all the
            // permission sets are loaded.
            // Note: we could probably just reuse the m_element
            // member (if it's not null) for the "NamedPermissionSets"
            // element.  I haven't thought that through in depth, though.
            // -gregfee 3/6/2000
        
            CheckLoaded( true );
            LoadAllPermissionSets();
        
            IEnumerator enumerator;
            SecurityElement e = new SecurityElement( "PolicyLevel" );
            e.AddAttribute( "version", "1" );

            Hashtable classes = new Hashtable();

            lock (this)
            {            
                SecurityElement elPermSets = new SecurityElement( "NamedPermissionSets" );
            
                enumerator = m_namedPermissionSets.GetEnumerator();
            
                while (enumerator.MoveNext())
                {
                    elPermSets.AddChild( NormalizeClassDeep( ((NamedPermissionSet)enumerator.Current).ToXml(), classes ) );
                }
            
                SecurityElement elCodeGroup = NormalizeClassDeep( m_rootCodeGroup.ToXml( this ), classes );

                SecurityElement elFullTrust = new SecurityElement( "FullTrustAssemblies" );

                enumerator = m_fullTrustAssemblies.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    elFullTrust.AddChild( NormalizeClassDeep( ((StrongNameMembershipCondition)enumerator.Current).ToXml(), classes ) );
                }
                
                SecurityElement elClasses = new SecurityElement( "SecurityClasses" );

                IDictionaryEnumerator dicEnumerator = classes.GetEnumerator();

                while (dicEnumerator.MoveNext())
                {
                    SecurityElement elClass = new SecurityElement( "SecurityClass" );
                    elClass.AddAttribute( "Name", (String)dicEnumerator.Value );
                    elClass.AddAttribute( "Description", (String)dicEnumerator.Key );
                    elClasses.AddChild( elClass );
                }

                e.AddChild( elClasses );
                e.AddChild( elPermSets );
                e.AddChild( elCodeGroup );
                e.AddChild( elFullTrust );

            }                 
            
            return e;
        }
        
        /// <include file='doc\PolicyLevel.uex' path='docs/doc[@for="PolicyLevel.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            if (e == null)
                throw new ArgumentNullException( "e" );
        
            Hashtable classes;

            lock (this)
            {
                ArrayList fullTrustAssemblies = new ArrayList();
            
                SecurityElement eClasses = e.SearchForChildByTag( "SecurityClasses" );

                if (eClasses != null)
                {
                    classes = new Hashtable();

                    IEnumerator enumerator = eClasses.m_lChildren.GetEnumerator();

                    while (enumerator.MoveNext())
                    {
                        SecurityElement current = (SecurityElement)enumerator.Current;

                        if (current.Tag.Equals( "SecurityClass" ))
                        {
                            String name = current.Attribute( "Name" );
                            String description = current.Attribute( "Description" );

                            if (name != null && description != null)
                                classes.Add( name, description );
                        }
                    }
                }
                else
                {
                    classes = null;
                }

                SecurityElement elFullTrust = e.SearchForChildByTag( "FullTrustAssemblies" );

                if (elFullTrust != null && elFullTrust.m_lChildren != null)
                {
                    IEnumerator enumerator = elFullTrust.m_lChildren.GetEnumerator();

                    String className = typeof( System.Security.Policy.StrongNameMembershipCondition ).AssemblyQualifiedName;

                    while (enumerator.MoveNext())
                    {
                        StrongNameMembershipCondition sn = new StrongNameMembershipCondition();

                        try
                        {
                            sn.FromXml( (SecurityElement)enumerator.Current );
                            fullTrustAssemblies.Add( sn );
                        }
                        catch (Exception)
                        {
                        }
                    }
                }

                m_fullTrustAssemblies = fullTrustAssemblies;
                      
                ArrayList namedPermissionSets = new ArrayList();
                            
                SecurityElement elPermSets = e.SearchForChildByTag( "NamedPermissionSets" );
                SecurityElement permSetElement = null;

                // Here we just find the parent element for the named permission sets and
                // store it so that we can lazily load them later.            
            
                if (elPermSets != null && elPermSets.m_lChildren != null)
                {
                    permSetElement = UnnormalizeClassDeep( elPermSets, classes );

                    // Call FindElement for each of the reserved sets (this removes their xml from
                    // permSetElement).

                    FindElement( permSetElement, "FullTrust" );
                    FindElement( permSetElement, "SkipVerification" );
                    FindElement( permSetElement, "Execution" );
                    FindElement( permSetElement, "Nothing" );
                    FindElement( permSetElement, "Internet" );
                    FindElement( permSetElement, "LocalIntranet" );
                }

                if (permSetElement == null)
                {
                    permSetElement = new SecurityElement( "NamedPermissionSets" );
                }

                // Then we add in the immutable permission sets (this prevents any alterations
                // to them in the XML file from existing the runtime versions).

                namedPermissionSets.Add( CreateFullTrustSet() );
                namedPermissionSets.Add( CreateSkipVerificationSet() );
                namedPermissionSets.Add( CreateExecutionSet() );
                namedPermissionSets.Add( CreateNothingSet() );

                permSetElement.AddChild( GetInternetElement() );
                permSetElement.AddChild( GetLocalIntranetElement() );

                m_namedPermissionSets = namedPermissionSets;
                m_permSetElement = permSetElement;

                // Parse the root code group.
            
                SecurityElement elCodeGroup = e.SearchForChildByTag( "CodeGroup" );
                
                if (elCodeGroup == null)
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidXMLElement" ),  "CodeGroup", this.GetType().FullName ) );
                
                CodeGroup rootCodeGroup = System.Security.Util.XMLUtil.CreateCodeGroup( UnnormalizeClassDeep( elCodeGroup, classes ) );
            
                if (rootCodeGroup == null)
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidXMLElement" ),  "CodeGroup", this.GetType().FullName ) );
                
                rootCodeGroup.FromXml( elCodeGroup, this );

                m_rootCodeGroup = rootCodeGroup;

            }
           
        }
        
        private void Cache( int count, char[] serializedEvidence, PolicyStatement policy )
        {
            BCLDebug.Assert( m_configId != ConfigId.None, "PolicyLevels must have a vliad config id to save to the cache" );
        
            char[] policyArray = policy.ToXml().ToString().ToCharArray();
            
            Config.AddCacheEntry( m_configId, count, serializedEvidence, policyArray );
        }
       
        private PolicyStatement CheckCache( int count, char[] serializedEvidence, out bool xmlError )
        {
            BCLDebug.Assert( m_configId != ConfigId.None, "PolicyLevels must have a valid config id to check the cache" );
        
            char[] cachedValue;
            PolicyStatement cachedSet = null;
            
            xmlError = false;
 
            if (!Config.GetCacheEntry( m_configId, count, serializedEvidence, out cachedValue ))
            {
                return null;
            }
            else
            {
                BCLDebug.Assert( cachedValue != null, "GetCacheData returned success but cached value is null" );
                                          
                cachedSet = new PolicyStatement();
                Parser parser = null;
                try
                {
                    parser = new Parser( cachedValue );
                    cachedSet.FromXml( parser.GetTopElement() );
                    return cachedSet;
                }
                catch (XmlSyntaxException)
                {
                    BCLDebug.Assert( false, "XmlSyntaxException in CheckCache" );
                    xmlError = true;
                    return null;
                }
            }
        }

        private static void GenerateQuickCache( Object obj )
        {
            PolicyLevel level = (PolicyLevel)obj;

            try
            {
                if (PolicyManager.CanUseQuickCache( level.RootCodeGroup ))
                {
                    Config.SetQuickCache( level.ConfigId, PolicyManager.GenerateQuickCache( level ) );
                }
            }
            catch (Exception)
            {
            }

            s_waitingLevel = null;
            s_waitingThread = null;
        }

        private static void GenerateConfigFile( Object obj )
        {
            PolicyLevel level = (PolicyLevel)obj;

            try
            {
                PolicyManager.EncodeLevel( level );
            }
            catch (Exception)
            {
            }

            s_waitingLevel = null;
            s_waitingThread = null;
        }
        
    }
    
    
    internal class CodeGroupStackFrame
    {
        internal CodeGroup current;
        internal PolicyStatement policy;
        internal CodeGroupStackFrame parent;
    }
    
    
    sealed internal class CodeGroupStack
    {
        private ArrayList m_array;
        
        public CodeGroupStack()
        {
            m_array = new ArrayList();
        }
        
        public void Push( CodeGroupStackFrame element )
        {
            m_array.Add( element );
        }
        
        public CodeGroupStackFrame Pop()
        {
            if (!IsEmpty())
            {
                int count = m_array.Count;
                CodeGroupStackFrame temp = (CodeGroupStackFrame) m_array[count-1];
                m_array.RemoveAt(count-1);
                return temp;
            }
            else
            {
                throw new InvalidOperationException( Environment.GetResourceString( "InvalidOperation_EmptyStack" ) );
            }
        }
        
        public bool IsEmpty()
        {
            return m_array.Count == 0;
        }
        
        public int GetCount()
        {
            return m_array.Count;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\strongnamemembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  StrongNameMembershipCondition.cool
//
//  Implementation of membership condition for zones
//

namespace System.Security.Policy {
    using System.Text;
    using System.Configuration.Assemblies;
    using System;
    using SecurityManager = System.Security.SecurityManager;
    using StrongNamePublicKeyBlob = System.Security.Permissions.StrongNamePublicKeyBlob;
    using PermissionSet = System.Security.PermissionSet;
    using SecurityElement = System.Security.SecurityElement;
    using System.Collections;
    

    /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition"]/*' />
    [Serializable]
    sealed public class StrongNameMembershipCondition : IMembershipCondition, IConstantMembershipCondition
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private StrongNamePublicKeyBlob m_publicKeyBlob;
        private String m_name;
        private Version m_version;
        private SecurityElement m_element;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        internal StrongNameMembershipCondition()
        {
        }
        
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.StrongNameMembershipCondition"]/*' />
        public StrongNameMembershipCondition( StrongNamePublicKeyBlob blob,
                                              String name,
                                              Version version )
        {
            if (blob == null)
                throw new ArgumentNullException( "blob" );

            // Add this in Whidbey
            // if (name != null && name.Equals( "" ))
            //     throw new ArgumentException( Environment.GetResourceString( "Argument_EmptyStrongName" ) );      

            m_publicKeyBlob = blob;
            m_name = name;
            m_version = version;
        }
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
    
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.PublicKey"]/*' />
        public StrongNamePublicKeyBlob PublicKey
        {
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "PublicKey" );
            
                m_publicKeyBlob = value;
            }

            get
            {
                if (m_publicKeyBlob == null && m_element != null)
                    ParseKeyBlob();
            
                return m_publicKeyBlob;
            }
        }
                
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.Name"]/*' />
        public String Name
        {
            set
            {
                if (value == null)
                {
                    if (m_publicKeyBlob == null && m_element != null)
                        ParseKeyBlob();
                        
                    if ((Object) m_version == null && m_element != null)
                        ParseVersion();
                        
                    m_element = null;
                }
            
                m_name = value;
            }                    
               
            get
            {
                if (m_name == null && m_element != null)
                    ParseName();
            
                return m_name;
            }
        }

        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.Version"]/*' />
        public Version Version
        {
            set
            {
                if (value == null)
                {
                    if (m_name == null && m_element != null)
                        ParseName();
                        
                    if (m_publicKeyBlob == null && m_element != null)
                        ParseKeyBlob();
                        
                    m_element = null;
                }
            
                m_version = value;
            }                    
               
            get
            {
                if ((Object) m_version == null && m_element != null)
                    ParseVersion();
            
                return m_version;
            }
        }

        //------------------------------------------------------
        //
        // IMEMBERSHIPCONDITION IMPLEMENTATION
        //
        //------------------------------------------------------
    
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            if (evidence == null)
                return false;
        
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                if (enumerator.Current is StrongName)
                {
                    StrongName name = (StrongName)enumerator.Current;
                
                    if (( this.PublicKey != null && this.PublicKey.Equals( name.PublicKey ) ) &&
                        ( this.Name == null || (name.Name != null && StrongName.CompareNames( name.Name, this.Name ) )) &&
                        ( (Object) this.Version == null || ((Object) name.Version != null && name.Version.CompareTo( this.Version ) == 0 )))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            return new StrongNameMembershipCondition( PublicKey,
                                                      Name,
                                                      Version);
        }
        
        private const String s_tagName = "Name";
        private const String s_tagVersion = "AssemblyVersion";
        private const String s_tagPublicKeyBlob = "PublicKeyBlob";
        
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            if (PublicKey != null)
                root.AddAttribute( s_tagPublicKeyBlob, System.Security.Util.Hex.EncodeHexString( PublicKey.PublicKey ) );

            if (Name != null)
                root.AddAttribute( s_tagName, Name );

            if ((Object) Version != null)
                root.AddAttribute( s_tagVersion, Version.ToString() );

            return root;

        }
    
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");
        
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
            
            lock (this)
            {
                m_name = null;
                m_publicKeyBlob = null;
                m_version = null;
                m_element = e;
            }
        }
        
       
        private void ParseName()
        {
            lock (this)
            {
                if (m_element == null)
                    return;

                String elSite = m_element.Attribute( s_tagName );
                m_name = elSite == null ? null : elSite;

                if ((Object) m_version != null && m_name != null && m_publicKeyBlob != null)
                {
                    m_element = null;
                }
            }
        }
        
        private void ParseKeyBlob()
        {
            lock (this)
            {
                if (m_element == null)
                    return;

                String elBlob = m_element.Attribute( s_tagPublicKeyBlob );
                StrongNamePublicKeyBlob publicKeyBlob = new StrongNamePublicKeyBlob();
            
                if (elBlob != null)
                    publicKeyBlob.PublicKey = System.Security.Util.Hex.DecodeHexString( elBlob );
                else
                    throw new ArgumentException( Environment.GetResourceString( "Argument_BlobCannotBeNull" ) );

                m_publicKeyBlob = publicKeyBlob;

                if ((Object) m_version != null && m_name != null && m_publicKeyBlob != null)
                {
                    m_element = null;
                }
            }    
        }    

        private void ParseVersion()
        {
            lock (this)
            {
                if (m_element == null)
                    return;

                String elVersion = m_element.Attribute( s_tagVersion );
                m_version = elVersion == null ? null : new Version( elVersion );

                if ((Object) m_version != null && m_name != null && m_publicKeyBlob != null)
                {
                    m_element = null;
                }
            }
        }
        
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            String sName = "";
            String sVersion = "";

            if (Name != null)
                sName = " " + String.Format( Environment.GetResourceString( "StrongName_Name" ), Name );

            if ((Object) Version != null)
                sVersion = " " + String.Format( Environment.GetResourceString( "StrongName_Version" ), Version );

            return String.Format( Environment.GetResourceString( "StrongName_ToString" ), System.Security.Util.Hex.EncodeHexString( PublicKey.PublicKey ), sName, sVersion );
        }
            
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            StrongNameMembershipCondition that = (o as StrongNameMembershipCondition);
            
            if (that != null)
            {
                if (this.m_publicKeyBlob == null && this.m_element != null)
                    this.ParseKeyBlob();
                if (that.m_publicKeyBlob == null && that.m_element != null)
                    that.ParseKeyBlob();
                
                if (Equals( this.m_publicKeyBlob, that.m_publicKeyBlob ))
                {
                    if (this.m_name == null && this.m_element != null)
                        this.ParseName();
                    if (that.m_name == null && that.m_element != null)
                        that.ParseName();
                    
                    if (Equals( this.m_name, that.m_name ))
                    {
                        if (this.m_version == null && this.m_element != null)
                            this.ParseVersion();
                        if (that.m_version == null && that.m_element != null)
                            that.ParseVersion();
                        
                        if ( Equals( this.m_version, that.m_version ))
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\StrongNameMembershipCondition.uex' path='docs/doc[@for="StrongNameMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (m_publicKeyBlob == null && m_element != null)
                ParseKeyBlob();
            
            if (m_publicKeyBlob != null)
            {
                return m_publicKeyBlob.GetHashCode();
            }
            else
            {
                if (m_name == null && m_element != null)
                    ParseName();
                if (m_version == null && m_element != null)
                    ParseVersion();
                
                if (m_name != null || m_version != null)
                {
                    return (m_name == null ? 0 : m_name.GetHashCode()) + (m_version == null ? 0 : m_version.GetHashCode());
                }
                else
                {
                    return typeof( StrongNameMembershipCondition ).GetHashCode();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\zone.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  Zone.cs
//
//  Zone is an IIdentity representing Internet/Intranet/MyComputer etc.
//

namespace System.Security.Policy {
	using System.Runtime.Remoting;
	using System;
	using System.Security;
	using System.Security.Util;
	using System.IO;
	using System.Collections;
	using ZoneIdentityPermission = System.Security.Permissions.ZoneIdentityPermission;
	using System.Runtime.CompilerServices;

    /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone"]/*' />
    [Serializable]
    sealed public class Zone : IIdentityPermissionFactory, IBuiltInEvidence
    {
        internal SecurityZone m_zone;
    
        private static readonly String[] s_names =
            {"MyComputer", "Intranet", "Trusted", "Internet", "Untrusted", "NoZone"};
            
    
        internal Zone() 
        { 
            m_zone = SecurityZone.NoZone; 
        }
    
        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.Zone"]/*' />
        public Zone(SecurityZone zone)
        {
            if (zone < SecurityZone.NoZone || zone > SecurityZone.Untrusted)
                throw new ArgumentException( Environment.GetResourceString( "Argument_IllegalZone" ) );
    
            m_zone = zone;
        }
    
        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.CreateFromUrl"]/*' />
        public static Zone CreateFromUrl( String url )
        {
            if (url == null)
                throw new ArgumentNullException( "url" );
            
            return new Zone( _CreateFromUrl( url ) );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static SecurityZone _CreateFromUrl( String url );

        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.CreateIdentityPermission"]/*' />
        public IPermission CreateIdentityPermission( Evidence evidence )
        {
            return new ZoneIdentityPermission( m_zone );
        }
    
        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.SecurityZone"]/*' />
        public SecurityZone SecurityZone
        {
            get
            {
                return m_zone;
            }
        }
    
        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.Equals"]/*' />
        public override bool Equals(Object o)
        {
            if (o is Zone)
            {
                Zone z = (Zone) o;
                return m_zone == z.m_zone;
            }
            return false;
        }

        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return (int)m_zone;
        }
    
        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.Copy"]/*' />
        public Object Copy()
        {
            Zone z = new Zone();
    
            z.m_zone = m_zone;
    
            return z;
        }
    
        internal SecurityElement ToXml()
        {
            SecurityElement elem = new SecurityElement( this.GetType().FullName );
            elem.AddAttribute( "version", "1" );
            if (m_zone != SecurityZone.NoZone)
                elem.AddChild( new SecurityElement( "Zone", s_names[(int)m_zone] ) );
            else
                elem.AddChild( new SecurityElement( "Zone", s_names[s_names.Length-1] ) );
            return elem;
        }
        
        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            buffer[position] = BuiltInEvidenceHelper.idZone;
            BuiltInEvidenceHelper.CopyIntToCharArray( (int)m_zone, buffer, position + 1 );
            return position + 3;
        }

        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose)
        {
            return 3;
        }

        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position )
        {
            m_zone = (SecurityZone)BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            return position + 2;
        }
    
        /// <include file='doc\Zone.uex' path='docs/doc[@for="Zone.ToString"]/*' />
        public override String ToString()
		{
			return ToXml().ToString();
		}

        // INormalizeForIsolatedStorage is not implemented for startup perf
        // equivalent to INormalizeForIsolatedStorage.Normalize()
        internal Object Normalize()
        {
            return s_names[(int)m_zone];
		}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\sitemembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  SiteMembershipCondition.cool
//
//  Implementation of membership condition for zones
//

namespace System.Security.Policy {
    
	using System;
	using SecurityManager = System.Security.SecurityManager;
	using SiteString = System.Security.Util.SiteString;
	using PermissionSet = System.Security.PermissionSet;
	using SecurityElement = System.Security.SecurityElement;
	using System.Collections;

    /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition"]/*' />
    [Serializable]
    sealed public class SiteMembershipCondition : IMembershipCondition, IConstantMembershipCondition
    {
        
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private SiteString m_site;
        private SecurityElement m_element;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        internal SiteMembershipCondition()
        {
            m_site = null;
        }
        
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.SiteMembershipCondition"]/*' />
        public SiteMembershipCondition( String site )
        {
            if (site == null)
                throw new ArgumentNullException( "site" );
        
            m_site = new SiteString( site );
        }
      
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
    
        internal SiteString GetSiteString()
        {
            if (m_site == null && m_element != null)
                ParseSite();
        
            return m_site;
        }
        

        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.Site"]/*' />
        public String Site
        {
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "value" );
            
                m_site = new SiteString( value );
            }
        
            get
            {
                if (m_site == null && m_element != null)
                    ParseSite();

                if (m_site != null)
                    return m_site.ToString();
                else
                    return "";
            }
        }
               
        //------------------------------------------------------
        //
        // IMEMBERSHIPCONDITION IMPLEMENTATION
        //
        //------------------------------------------------------
    
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            if (evidence == null)
                return false;
        
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                Object obj = enumerator.Current;
                if (obj is Site)
                {
                    if (m_site == null && m_element != null)
                        ParseSite();
                        
                    if (((Site)obj).GetSiteString().IsSubsetOf( this.m_site ))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            if (m_site == null && m_element != null)
                ParseSite();
                        
            return new SiteMembershipCondition( m_site.ToString() );
        }
        
        
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            if (m_site == null && m_element != null)
                ParseSite();
                        
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            if (m_site != null)
                root.AddAttribute( "Site", m_site.ToString() );
            
            return root;
        }
    
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level  )
        {
            if (e == null)
                throw new ArgumentNullException("e");
        
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
            
            lock (this)
            {
                m_site = null;
                m_element = e;
            }
        }
            
        private void ParseSite()
        {   
            lock (this)
            {
                if (m_element == null)
                    return;

                String elSite = m_element.Attribute( "Site" );
                if (elSite == null)
                    throw new ArgumentException( Environment.GetResourceString( "Argument_SiteCannotBeNull" ) );
                else
                    m_site = new SiteString( elSite );
                m_element = null;
            }
        }
        
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            SiteMembershipCondition that = (o as SiteMembershipCondition);
            
            if (that != null)
            {
                if (this.m_site == null && this.m_element != null)
                    this.ParseSite();
                if (that.m_site == null && that.m_element != null)
                    that.ParseSite();
                
                if( Equals (this.m_site, that.m_site ))
                {
                    return true;
                }
            }
            return false;
        }
        
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (m_site == null && m_element != null)
                ParseSite();
            
            if (m_site != null)
            {
                return m_site.GetHashCode();
            }
            else
            {
                return typeof( SiteMembershipCondition ).GetHashCode();
            }
        }
        
        /// <include file='doc\SiteMembershipCondition.uex' path='docs/doc[@for="SiteMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            if (m_site == null && m_element != null)
                ParseSite();
        
            if (m_site != null)
                return String.Format( Environment.GetResourceString( "Site_ToStringArg" ), m_site );
            else
                return Environment.GetResourceString( "Site_ToString" );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\unioncodegroup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  UnionCodeGroup.cool
//
//  Representation for code groups used for the policy mechanism
//

namespace System.Security.Policy {
    
    using System;
    using System.Security.Util;
    using System.Security;
    using System.Collections;
    
    /// <include file='doc\UnionCodeGroup.uex' path='docs/doc[@for="UnionCodeGroup"]/*' />
    [Serializable]
    sealed public class UnionCodeGroup : CodeGroup
    {
        internal UnionCodeGroup()
            : base()
        {
        }
        
        internal UnionCodeGroup( IMembershipCondition membershipCondition, PermissionSet permSet )
            : base( membershipCondition, permSet )
        {
        }
        
        /// <include file='doc\UnionCodeGroup.uex' path='docs/doc[@for="UnionCodeGroup.UnionCodeGroup"]/*' />
        public UnionCodeGroup( IMembershipCondition membershipCondition, PolicyStatement policy )
            : base( membershipCondition, policy )
        {
        }
        
        
        /// <include file='doc\UnionCodeGroup.uex' path='docs/doc[@for="UnionCodeGroup.Resolve"]/*' />
        public override PolicyStatement Resolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");
                
            if (this.MembershipCondition.Check( evidence ))
            {
                PolicyStatement thisPolicy = this.PolicyStatement;

                IEnumerator enumerator = this.Children.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    PolicyStatement childPolicy = ((CodeGroup)enumerator.Current).Resolve( evidence );

                    if (childPolicy != null)
                    {
                        if (((thisPolicy.Attributes & childPolicy.Attributes) & PolicyStatementAttribute.Exclusive) == PolicyStatementAttribute.Exclusive)
                        {
                            throw new PolicyException( Environment.GetResourceString( "Policy_MultipleExclusive" ) );
                        }

                        thisPolicy.GetPermissionSetNoCopy().InplaceUnion( childPolicy.GetPermissionSetNoCopy() );
                        thisPolicy.Attributes = thisPolicy.Attributes | childPolicy.Attributes;
                    }
                }

                return thisPolicy;
            }           
            else
            {
                return null;
            }
        }        

        internal PolicyStatement InternalResolve( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");
                
            if (this.MembershipCondition.Check( evidence ))
            {
                return this.PolicyStatement;
            }
            else
            {
                return null;
            }        
        }
        
        /// <include file='doc\UnionCodeGroup.uex' path='docs/doc[@for="UnionCodeGroup.ResolveMatchingCodeGroups"]/*' />
        public override CodeGroup ResolveMatchingCodeGroups( Evidence evidence )
        {
            if (evidence == null)
                throw new ArgumentNullException("evidence");

            if (this.MembershipCondition.Check( evidence ))
            {
                CodeGroup retGroup = this.Copy();

                retGroup.Children = new ArrayList();

                IEnumerator enumerator = this.Children.GetEnumerator();
                
                while (enumerator.MoveNext())
                {
                    CodeGroup matchingGroups = ((CodeGroup)enumerator.Current).ResolveMatchingCodeGroups( evidence );
                    
                    // If the child has a policy, we are done.
                    
                    if (matchingGroups != null)
                    {
                        retGroup.AddChild( matchingGroups );
                    }
                }

                return retGroup;
                
            }
            else
            {
                return null;
            }
        }

        
        /// <include file='doc\UnionCodeGroup.uex' path='docs/doc[@for="UnionCodeGroup.Copy"]/*' />
        public override CodeGroup Copy()
        {
            UnionCodeGroup group = new UnionCodeGroup();
            
            group.MembershipCondition = this.MembershipCondition;
            group.PolicyStatement = this.PolicyStatement;
            group.Name = this.Name;
            group.Description = this.Description;

            IEnumerator enumerator = this.Children.GetEnumerator();

            while (enumerator.MoveNext())
            {
                group.AddChild( (CodeGroup)enumerator.Current );
            }

            
            return group;
        }
        
        /// <include file='doc\UnionCodeGroup.uex' path='docs/doc[@for="UnionCodeGroup.MergeLogic"]/*' />
        public override String MergeLogic
        {
            get
            {
                return Environment.GetResourceString( "MergeLogic_Union" );
            }
        }
    }                

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\url.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  Url.cs
//
//  Url is an IIdentity representing url internet sites.
//

namespace System.Security.Policy {
	using System.Runtime.Remoting;
	using System;
	using System.IO;
	using System.Security.Util;
	using System.Collections;
	using UrlIdentityPermission = System.Security.Permissions.UrlIdentityPermission;
    using System.Runtime.Serialization;

    /// <include file='doc\URL.uex' path='docs/doc[@for="Url"]/*' />
    [Serializable]
    sealed public class Url : IIdentityPermissionFactory, IBuiltInEvidence
       //, ISerializable   --  Url should implement ISerializable in Beta 2
    {
        private URLString m_url;
    
        internal Url()
        {
            m_url = null;
        }

        internal Url( SerializationInfo info, StreamingContext context )
        {
            m_url = new URLString( (String)info.GetValue( "Url", typeof( String ) ) );
        }
    
        internal Url( String name, bool parsed )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
        
            m_url = new URLString( name, parsed );
        }

        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.Url"]/*' />
        public Url( String name )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
        
            m_url = new URLString( name );
        }
    
        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.Value"]/*' />
        public String Value
        {
            get
            {
                if (m_url == null) return null;
                return m_url.ToString();
            }
        }
        
        internal URLString GetURLString()
        {
            return m_url;
        }
        
        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.CreateIdentityPermission"]/*' />
        public IPermission CreateIdentityPermission( Evidence evidence )
        {
            return new UrlIdentityPermission( m_url );
        }
        
        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.Equals"]/*' />
        public override bool Equals(Object o)
        {
            if (o == null)
                return false;
        
            if (o is Url)
            {
                Url url = (Url) o;
                
                if (this.m_url == null)
                {
                    return url.m_url == null;
                }
                else if (url.m_url == null)
                {
                    return false;
                }
                else
                {
                    return this.m_url.Equals( url.m_url );
                }
            }
            return false;
        }
    
        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (this.m_url == null)
                return 0;
            else
                return this.m_url.GetHashCode();
        }

    
        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.Copy"]/*' />
        public Object Copy()
        {
            Url url = new Url();
    
            url.m_url = this.m_url;
    
            return url;
        }
    
        internal SecurityElement ToXml()
        {
            SecurityElement root = new SecurityElement( this.GetType().FullName );
            root.AddAttribute( "version", "1" );
            
            if (m_url != null)
                root.AddChild( new SecurityElement( "Url", m_url.ToString() ) );
            
            return root;
        }
    
        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.ToString"]/*' />
        public override String ToString()
		{
			return ToXml().ToString();
		}

        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.char"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.OutputToBuffer( char[] buffer, int position, bool verbose )
        {
            buffer[position++] = BuiltInEvidenceHelper.idUrl;
            String value = this.Value;
            int length = value.Length;
            if (verbose)
            {
                BuiltInEvidenceHelper.CopyIntToCharArray(length, buffer, position);
                position += 2;
            }

            value.CopyTo( 0, buffer, position, length );
            return length + position;
        }

        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.IBuiltInEvidence.GetRequiredSize"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.GetRequiredSize(bool verbose )
        {
            if (verbose)
                return this.Value.Length + 3;
            else
                return this.Value.Length + 1;
		}

        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.char1"]/*' />
        /// <internalonly/>
        int IBuiltInEvidence.InitFromBuffer( char[] buffer, int position)
        {
            int length = BuiltInEvidenceHelper.GetIntFromCharArray(buffer, position);
            position += 2;

            m_url = new URLString( new String(buffer, position, length ));

            return position + length;
        }

/*
        /// <include file='doc\URL.uex' path='docs/doc[@for="Url.GetObjectData"]/*' />
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            String normalizedUrl = m_url.NormalizeUrl();

            info.AddValue( "Url", normalizedUrl );
        }
*/        
        // INormalizeForIsolatedStorage is not implemented for startup perf
        // equivalent to INormalizeForIsolatedStorage.Normalize()
        internal Object Normalize()
        {
            return m_url.NormalizeUrl();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\urlmembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  UrlMembershipCondition.cool
//
//  Implementation of membership condition for urls
//

namespace System.Security.Policy {    
	using System;
	using URLString = System.Security.Util.URLString;
	using SecurityElement = System.Security.SecurityElement;
	using System.Security.Policy;
    using System.Collections;

    /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition"]/*' />
    [Serializable]
    sealed public class UrlMembershipCondition : IMembershipCondition, IConstantMembershipCondition
    {
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private URLString m_url;
        private SecurityElement m_element;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        internal UrlMembershipCondition()
        {
            m_url = null;
        }
        
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.UrlMembershipCondition"]/*' />
        public UrlMembershipCondition( String url )
        {
            if (url == null)
                throw new ArgumentNullException( "url" );
        
            m_url = new URLString( url );
        }
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
    
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.Url"]/*' />
        public String Url
        {
            set
            {
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                m_url = new URLString( value );
            }
            
            get
            {
                if (m_url == null && m_element != null)
                    ParseURL();
           
                return m_url.ToString();
            }
        }
        
        //------------------------------------------------------
        //
        // IMEMBERSHIPCONDITION IMPLEMENTATION
        //
        //------------------------------------------------------
    
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            if (evidence == null)
                return false;
        
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                if (enumerator.Current is Url)
                {
                    if (m_url == null && m_element != null)
                        ParseURL();
                        
                    if (((Url)enumerator.Current).GetURLString().IsSubsetOf( m_url ))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            if (m_url == null && m_element != null)
                ParseURL();
        
            UrlMembershipCondition mc = new UrlMembershipCondition();
            mc.m_url = new URLString( m_url.ToString(), true );
            return mc;
        }    
       
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            if (m_url == null && m_element != null)
                ParseURL();
                
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            if (m_url != null)
                root.AddAttribute( "Url", m_url.ToString() );
            
            return root;
        }
    
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");
        
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
            
            lock (this)
            {
                m_element = e;
                m_url = null;
            }
        }
         
        private void ParseURL()
        {
            lock (this)
            {
                if (m_element == null)
                    return;

                String elurl = m_element.Attribute( "Url" );
                if (elurl == null)
                    throw new ArgumentException( Environment.GetResourceString( "Argument_UrlCannotBeNull" ) );
                else
                    m_url = new URLString( elurl, true );

                m_element = null;
            }
        }    
        
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            UrlMembershipCondition that = (o as UrlMembershipCondition);
            
            if (that != null)
            {
                if (this.m_url == null && this.m_element != null)
                    this.ParseURL();
                if (that.m_url == null && that.m_element != null)
                    that.ParseURL();
                
                if (Equals( this.m_url, that.m_url ))
                {
                    return true;
                }
            }
            return false;
        }
        
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (m_url == null && m_element != null)
                ParseURL();
            
            if (m_url != null)
            {
                return m_url.GetHashCode();
            }
            else
            {
                return typeof( UrlMembershipCondition ).GetHashCode();
            }
        }
        
        /// <include file='doc\URLMembershipCondition.uex' path='docs/doc[@for="UrlMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            if (m_url == null && m_element != null)
                ParseURL();
        
            if (m_url != null)
                return String.Format( Environment.GetResourceString( "Url_ToStringArg" ), m_url.ToString() );
            else
                return Environment.GetResourceString( "Url_ToString" );
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\genericidentity.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  GenericIdentity.cool
//
//  A generic identity
//

namespace System.Security.Principal
{
	using System.Runtime.Remoting;
	using System;
	using System.Security.Util;
    /// <include file='doc\GenericIdentity.uex' path='docs/doc[@for="GenericIdentity"]/*' />
    [Serializable]
    public class GenericIdentity : IIdentity
    {
        private String m_name;
        private String m_type;
    
        /// <include file='doc\GenericIdentity.uex' path='docs/doc[@for="GenericIdentity.GenericIdentity"]/*' />
        public GenericIdentity( String name )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
        
            m_name = name;
            m_type = "";
        }
        
        /// <include file='doc\GenericIdentity.uex' path='docs/doc[@for="GenericIdentity.GenericIdentity1"]/*' />
        public GenericIdentity( String name, String type )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
                
            if (type == null)
                throw new ArgumentNullException( "type" );
        
            m_name = name;
            m_type = type;
        }
    
        /// <include file='doc\GenericIdentity.uex' path='docs/doc[@for="GenericIdentity.Name"]/*' />
        public virtual String Name
        {
            get
            {
                return m_name;
            }
        }
        
        /// <include file='doc\GenericIdentity.uex' path='docs/doc[@for="GenericIdentity.AuthenticationType"]/*' />
        public virtual String AuthenticationType
        {
            get
            {
                return m_type;
            }
        }
        
        /// <include file='doc\GenericIdentity.uex' path='docs/doc[@for="GenericIdentity.IsAuthenticated"]/*' />
        public virtual bool IsAuthenticated
        {
            get
            {
                return !m_name.Equals( "" );
            } 
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policy\zonemembershipcondition.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  ZoneMembershipCondition.cool
//
//  Implementation of membership condition for zones
//

namespace System.Security.Policy {
    
	using System;
	using SecurityManager = System.Security.SecurityManager;
	using PermissionSet = System.Security.PermissionSet;
	using SecurityElement = System.Security.SecurityElement;
	using System.Collections;

    /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition"]/*' />
    [Serializable]
    sealed public class ZoneMembershipCondition : IMembershipCondition, IConstantMembershipCondition
    {
        //------------------------------------------------------
        //
        // PRIVATE CONSTANTS
        //
        //------------------------------------------------------
        
        private static readonly String[] s_names =
            {"MyComputer", "Intranet", "Trusted", "Internet", "Untrusted"};
        
        //------------------------------------------------------
        //
        // PRIVATE STATE DATA
        //
        //------------------------------------------------------
        
        private SecurityZone m_zone;
        private SecurityElement m_element;
        
        //------------------------------------------------------
        //
        // PUBLIC CONSTRUCTORS
        //
        //------------------------------------------------------
    
        internal ZoneMembershipCondition()
        {
            m_zone = SecurityZone.NoZone;
        }
        
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.ZoneMembershipCondition"]/*' />
        public ZoneMembershipCondition( SecurityZone zone )
        {
            VerifyZone( zone );
        
            this.SecurityZone = zone;
        }
        
        
        //------------------------------------------------------
        //
        // PUBLIC ACCESSOR METHODS
        //
        //------------------------------------------------------
    
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.SecurityZone"]/*' />
        public SecurityZone SecurityZone
        {
            set
            {
                VerifyZone( value );
            
                m_zone = value;
            }
            
            get
            {
                if (m_zone == SecurityZone.NoZone && m_element != null)
                    ParseZone();
            
                return m_zone;
            }
        }
        
        //------------------------------------------------------
        //
        // PRIVATE AND PROTECTED HELPERS FOR ACCESSORS AND CONSTRUCTORS
        //
        //------------------------------------------------------
    
        private static void VerifyZone( SecurityZone zone )
        {
            if (zone < SecurityZone.MyComputer || zone > SecurityZone.Untrusted)
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_IllegalZone" ) );
            }
        }
        
        //------------------------------------------------------
        //
        // IMEMBERSHIPCONDITION IMPLEMENTATION
        //
        //------------------------------------------------------
    
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.Check"]/*' />
        public bool Check( Evidence evidence )
        {
            if (evidence == null)
                return false;
        
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                Object obj = enumerator.Current;
            
                if (obj is Zone)
                {
                    if (m_zone == SecurityZone.NoZone && m_element != null)
                        ParseZone();
                        
                    if (((Zone)obj).SecurityZone == m_zone)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.Copy"]/*' />
        public IMembershipCondition Copy()
        {
            if (m_zone == SecurityZone.NoZone && m_element != null)
                ParseZone();
        
            return new ZoneMembershipCondition( m_zone );
        }    
       
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.ToXml"]/*' />
        public SecurityElement ToXml()
        {
            return ToXml( null );
        }
    
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.FromXml"]/*' />
        public void FromXml( SecurityElement e )
        {
            FromXml( e, null );
        }
        
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.ToXml1"]/*' />
        public SecurityElement ToXml( PolicyLevel level )
        {
            if (m_zone == SecurityZone.NoZone && m_element != null)
                ParseZone();
                
            SecurityElement root = new SecurityElement( "IMembershipCondition" );
            System.Security.Util.XMLUtil.AddClassAttribute( root, this.GetType() );
            root.AddAttribute( "version", "1" );
            
            if (m_zone != SecurityZone.NoZone)
                root.AddAttribute( "Zone", Enum.GetName( typeof( SecurityZone ), m_zone ) );
            
            return root;
        }
          
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.FromXml1"]/*' />
        public void FromXml( SecurityElement e, PolicyLevel level )
        {
            if (e == null)
                throw new ArgumentNullException("e");
                
            if (!e.Tag.Equals( "IMembershipCondition" ))
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_MembershipConditionElement" ) );
            }
            
            lock (this)
            {
                m_zone = SecurityZone.NoZone;
                m_element = e;
            }
        }
        
        private void ParseZone()
        {
            lock (this)
            {
                if (m_element == null)
                    return;

                String eZone = m_element.Attribute( "Zone" );
            
                m_zone = SecurityZone.NoZone;
                if (eZone != null)
                {
                    m_zone = (SecurityZone)Enum.Parse( typeof( SecurityZone ), eZone );
                }
                else
                {
                    throw new ArgumentException( Environment.GetResourceString( "Argument_ZoneCannotBeNull" ) );
                }
            
                m_element = null;
            }
        }
        
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.Equals"]/*' />
        public override bool Equals( Object o )
        {
            ZoneMembershipCondition that = (o as ZoneMembershipCondition);
            
            if (that != null)
            {
                if (this.m_zone == SecurityZone.NoZone && this.m_element != null)
                    this.ParseZone();
                if (that.m_zone == SecurityZone.NoZone && that.m_element != null)
                    that.ParseZone();
                
                if(this.m_zone == that.m_zone)
                {
                    return true;
                }
            }
            return false;
        }
        
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return typeof( ZoneMembershipCondition ).GetHashCode() + m_zone.GetHashCode();
        }
        
        /// <include file='doc\ZoneMembershipCondition.uex' path='docs/doc[@for="ZoneMembershipCondition.ToString"]/*' />
        public override String ToString()
        {
            if (m_zone == SecurityZone.NoZone && m_element != null)
                ParseZone();
        
            return String.Format( Environment.GetResourceString( "Zone_ToString" ), s_names[(int)m_zone] );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\genericprincipal.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  GenericPrincipal.cool
//
//  All roles will implement this interface
//

namespace System.Security.Principal
{
	using System.Runtime.Remoting;
	using System;
	using System.Security.Util;
    using System.Globalization;
    /// <include file='doc\GenericPrincipal.uex' path='docs/doc[@for="GenericPrincipal"]/*' />
    [Serializable]
    public class GenericPrincipal : IPrincipal
    {
        private IIdentity m_identity;
        private String[] m_roles;
        
        /// <include file='doc\GenericPrincipal.uex' path='docs/doc[@for="GenericPrincipal.GenericPrincipal"]/*' />
        public GenericPrincipal( IIdentity identity, String[] roles )
        {
            if (identity == null)
                throw new ArgumentNullException( "identity" );
            
            m_identity = identity;
            
			if (roles != null)
			{
				m_roles = new String[roles.Length];
            
				for (int i = 0; i < roles.Length; ++i)
				{
					m_roles[i] = roles[i];
				}
			}
			else
			{
				m_roles = null;
			}
        }
        
        /// <include file='doc\GenericPrincipal.uex' path='docs/doc[@for="GenericPrincipal.Identity"]/*' />
        public virtual IIdentity Identity
        {
            get
            {
                return m_identity;
            }
        }
            
        /// <include file='doc\GenericPrincipal.uex' path='docs/doc[@for="GenericPrincipal.IsInRole"]/*' />
        public virtual bool IsInRole( String role )
        {
            if (role == null || m_roles == null)
                return false;
                
            for (int i = 0; i < m_roles.Length; ++i)
            {
                if (m_roles[i] != null && String.Compare( m_roles[i], role, true, CultureInfo.InvariantCulture) == 0)
                    return true;
            }
                        
            return false;
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\iidentity.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IIdentity.cool
//
//  All identities will implement this interface
//

namespace System.Security.Principal
{
	using System.Runtime.Remoting;
	using System;
	using System.Security.Util;
    /// <include file='doc\IIdentity.uex' path='docs/doc[@for="IIdentity"]/*' />
    public interface IIdentity
    {
        /// <include file='doc\IIdentity.uex' path='docs/doc[@for="IIdentity.Name"]/*' />
        // Access to the name string
        String Name { get; }
        /// <include file='doc\IIdentity.uex' path='docs/doc[@for="IIdentity.AuthenticationType"]/*' />

        // Access to Authentication 'type' info
        String AuthenticationType { get; }
        /// <include file='doc\IIdentity.uex' path='docs/doc[@for="IIdentity.IsAuthenticated"]/*' />
        
        // Determine if this represents the unauthenticated identity
        bool IsAuthenticated { get; }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\iprincipal.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IPrincipal.cool
//
//  All roles will implement this interface
//

namespace System.Security.Principal
{
	using System.Runtime.Remoting;
	using System;
	using System.Security.Util;
    /// <include file='doc\IPrincipal.uex' path='docs/doc[@for="IPrincipal"]/*' />
    public interface IPrincipal
    {
        /// <include file='doc\IPrincipal.uex' path='docs/doc[@for="IPrincipal.Identity"]/*' />
        // Retrieve the identity object
        IIdentity Identity { get; }
        /// <include file='doc\IPrincipal.uex' path='docs/doc[@for="IPrincipal.IsInRole"]/*' />
        
        // Perform a check for a specific role
        bool IsInRole( String role );
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\hex.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Hex.cool
 *
 * Operations to convert to and from Hex
 *
 */

namespace System.Security.Util
{
    using System;
    using System.Security;
    internal class Hex
    {
        static private char[]  hexValues = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        
        public  static String EncodeHexString(byte[] sArray) 
        {
            String result = null;
    
            if(sArray != null) {
                char[] hexOrder = new char[sArray.Length * 2];
            
                int digit;
                for(int i = 0, j = 0; i < sArray.Length; i++) {
                    digit = (int)((sArray[i] & 0xf0) >> 4);
                    hexOrder[j++] = hexValues[digit];
                    digit = (int)(sArray[i] & 0x0f);
                    hexOrder[j++] = hexValues[digit];
                }
                result = new String(hexOrder);
            }
            return result;
        }
        
        public static int ConvertHexDigit(Char val) {
            int retval;
            if (val <= '9')
                retval = (val - '0');
            else if (val >= 'a')
                retval = ((val - 'a') + 10);
            else
                retval = ((val - 'A') + 10);
            return retval;
                    
        }
    
        
        public static byte[] DecodeHexString(String hexString)
        {
            if (hexString == null)
                throw new ArgumentNullException( "hexString" );
                    
            bool spaceSkippingMode = false;    
                    
            int i = 0;
            int length = hexString.Length;
            
            if ((length >= 2) &&
                (hexString[0] == '0') &&
                ( (hexString[1] == 'x') ||  (hexString[1] == 'X') ))
            {
                length = hexString.Length - 2;
                i = 2;
            }
            
            // Hex strings must always have 2N or (3N - 1) entries.
            
            if (length % 2 != 0 && length % 3 != 2)
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidHexFormat" ) );
            }                
                
            byte[] sArray;
                
            if (length >=3 && hexString[i + 2] == ' ')
            {
                spaceSkippingMode = true;
                    
                // Each hex digit will take three spaces, except the first (hence the plus 1).
                sArray = new byte[length / 3 + 1];
            }
            else
            {
                // Each hex digit will take two spaces
                sArray = new byte[length / 2];
            }
                
            int digit;
            int rawdigit;
            for (int j = 0; i < hexString.Length; i += 2, j++) {
                rawdigit = ConvertHexDigit(hexString[i]);
                digit = ConvertHexDigit(hexString[i+1]);
                sArray[j] = (byte) (digit | (rawdigit << 4));
                if (spaceSkippingMode)
                    i++;
            }
            return(sArray);    
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\windowsprincipal.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  WindowsPrincipal.cool
//
//  Representation of a Windows role
//

namespace System.Security.Principal
{
    using System.Runtime.Remoting;
    using System;
    using System.Security.Util;
    using System.Runtime.CompilerServices;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole"]/*' />
	[Serializable]
    public enum WindowsBuiltInRole
    {
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.Administrator"]/*' />
        Administrator = 0x220,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.User"]/*' />
        User = 0x221,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.Guest"]/*' />
        Guest = 0x222,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.PowerUser"]/*' />
        PowerUser = 0x223,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.AccountOperator"]/*' />
        AccountOperator = 0x224,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.SystemOperator"]/*' />
        SystemOperator = 0x225,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.PrintOperator"]/*' />
        PrintOperator = 0x226,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.BackupOperator"]/*' />
        BackupOperator = 0x227,
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsBuiltInRole.Replicator"]/*' />
        Replicator = 0x228
    }

                

    /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsPrincipal"]/*' />
    [Serializable()]
    public class WindowsPrincipal : IPrincipal
    {
        private WindowsIdentity m_identity;
        private String[] m_roles;
        private Hashtable m_rolesTable;
        private bool m_rolesLoaded;

        private static readonly int MAGIC_NUMBER = 23;
        private static readonly IComparer s_comparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);
        private static readonly IHashCodeProvider s_provider = new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture);
    
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsPrincipal.WindowsPrincipal"]/*' />
        public WindowsPrincipal( WindowsIdentity ntIdentity )
        {
            if (ntIdentity == null)
                throw new ArgumentNullException( "ntIdentity" );
        
            m_identity = ntIdentity;
            m_rolesLoaded = false;
            m_roles = null;
        }
        
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsPrincipal.Identity"]/*' />
        public virtual IIdentity Identity
        {
            get
            {
                return m_identity;
            }
        }
                
        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsPrincipal.IsInRole"]/*' />
        public virtual bool IsInRole( String role )
        {
            if (role == null)
                return false;

            if (!m_rolesLoaded)
            {
                lock (this)
                {
                    if (!m_rolesLoaded)
                    {
                        m_roles = m_identity.GetRoles();

                        if (m_roles != null && m_roles.Length > MAGIC_NUMBER)
                        {
                            m_rolesTable = new Hashtable( m_roles.Length, 1.0f, s_provider, s_comparer );

                            for (int i = 0; i < m_roles.Length; ++i)
                            {
                                try
                                {
                                    if (m_roles[i] != null)
                                        m_rolesTable.Add( m_roles[i], m_roles[i] );
                                }
                                catch (ArgumentException)
                                {
                                }
                            }

                            m_roles = null;
                        }

                        m_rolesLoaded = true;
                    }
                }
            }

            if (m_rolesLoaded && m_roles == null && m_rolesTable == null)
                return false;

            if (m_rolesTable != null)
                return m_rolesTable.Contains( role );

            for (int i = 0; i < m_roles.Length; ++i)
            {
                if (m_roles[i] != null && String.Compare( m_roles[i], role, true, CultureInfo.InvariantCulture) == 0)
                    return true;
            }
                        
            return false;
        }

        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsPrincipal.IsInRole1"]/*' />
        public virtual bool IsInRole( int rid )
        {
            String role = _GetRole( rid );

            if (role == null)
                throw new ArgumentException( Environment.GetResourceString( "Argument_BadRid" ) );

            return IsInRole( role );
        }

        /// <include file='doc\WindowsPrincipal.uex' path='docs/doc[@for="WindowsPrincipal.IsInRole2"]/*' />
        public virtual bool IsInRole( WindowsBuiltInRole role )
        {
            return IsInRole( (int)role );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String _GetRole( int rid );

        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\config.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  Config.cool
//
//  The Runtime policy manager.  Maintains a set of IdentityMapper objects that map 
//  inbound evidence to groups.  Resolves an identity into a set of permissions
//

namespace System.Security.Util {
    using System;
    using System.Security.Util;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Globalization;
    using System.Text;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Threading;
        using System.Runtime.CompilerServices;
    
    // Duplicated in vm\COMSecurityConfig.h
        [Serializable]
    internal enum ConfigId
    {
        // Note: the ConfigId is never persisted all the values in here
        // can change without breaking anything.
        None = 0,
        MachinePolicyLevel = 1,
        UserPolicyLevel = 2,
        EnterprisePolicyLevel = 3,
        Reserved = 1000
    }

    // Duplicated in vm\COMSecurityConfig.h
        [Serializable,Flags]
    internal enum QuickCacheEntryType
    {
        ExecutionZoneMyComputer = 0x1,
        ExecutionZoneIntranet = 0x2,
        ExecutionZoneInternet = 0x4,
        ExecutionZoneTrusted = 0x8,
        ExecutionZoneUntrusted = 0x10,
        BindingRedirectsZoneMyComputer = 0x20,
        BindingRedirectsZoneIntranet = 0x40,
        BindingRedirectsZoneInternet = 0x80,
        BindingRedirectsZoneTrusted = 0x100,
        BindingRedirectsZoneUntrusted = 0x200,
        UnmanagedZoneMyComputer = 0x400,
        UnmanagedZoneIntranet = 0x800,
        UnmanagedZoneInternet = 0x1000,
        UnmanagedZoneTrusted = 0x2000,
        UnmanagedZoneUntrusted = 0x4000,
        ExecutionAll = 0x8000,
        BindingRedirectsAll = 0x10000,
        UnmanagedAll = 0x20000,
        SkipVerificationZoneMyComputer = 0x40000,
        SkipVerificationZoneIntranet = 0x80000,
        SkipVerificationZoneInternet = 0x100000,
        SkipVerificationZoneTrusted = 0x200000,
        SkipVerificationZoneUntrusted = 0x400000,
        SkipVerificationAll = 0x800000,
        FullTrustZoneMyComputer = 0x1000000,
        FullTrustZoneIntranet = 0x2000000,
        FullTrustZoneInternet = 0x4000000,
        FullTrustZoneTrusted = 0x8000000,
        FullTrustZoneUntrusted = 0x10000000,
        FullTrustAll = 0x20000000,
    }

    // Duplicated in vm\COMSecurityConfig.h
    [Serializable,Flags]
    internal enum ConfigRetval
    {
        NoFiles = 0x0,
        ConfigFile = 0x1,
        CacheFile = 0x2
    }

    internal class Config
    {
        private static String m_machineConfig = null;
        private static String m_userConfig = null;
        
        private static void GetFileLocales()
        {
            if (m_machineConfig == null)
                m_machineConfig = _GetMachineDirectory();

            if (m_userConfig == null)
                m_userConfig = _GetUserDirectory();
        }
        
        internal static String MachineDirectory
        {
            get
            {
                GetFileLocales();

                return m_machineConfig;
            }
        }

        internal static String UserDirectory
        {
            get
            {
                GetFileLocales();

                return m_userConfig;
            }
        }

        internal static ConfigRetval InitData( ConfigId id , String configFile )
        {
            return _InitData( id, configFile );
        }

        internal static ConfigRetval InitData( ConfigId id, String configFile, String cacheFile )
        {
            return _InitDataEx( id, configFile, cacheFile );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern ConfigRetval _InitData( ConfigId id, String configFile );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern ConfigRetval _InitDataEx( ConfigId id, String configFile, String cacheFile );

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void SaveCacheData( ConfigId id );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void ResetCacheData( ConfigId id );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void ClearCacheData( ConfigId id );

        internal static bool SaveData( ConfigId id, String data )
        {
            return _SaveDataString( id, data );
        }

        internal static bool SaveData( ConfigId id, byte[] data )
        {
            return _SaveDataByte( id, data, 0, data.Length );
        }

        internal static bool SaveData( ConfigId id, byte[] data, int offset, int length )
        {
            return _SaveDataByte( id, data, offset, length );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _SaveDataString( ConfigId id, String data );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _SaveDataByte( ConfigId id, byte[] data, int offset, int length );

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool RecoverData( ConfigId id );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern byte[] GetData( ConfigId id );

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern QuickCacheEntryType GetQuickCacheEntry( ConfigId id );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void SetQuickCache( ConfigId id, QuickCacheEntryType cache );

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool GetCacheEntry( ConfigId id, int numKey, char[] key, out char[] data );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void AddCacheEntry( ConfigId id, int numKey, char[] key, char[] data );

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String _GetMachineDirectory();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String _GetUserDirectory();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool GenerateFilesAutomatically();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool WriteToEventLog( String message );

        internal static String GetStoreLocation( ConfigId configId )
        {
            if (configId == ConfigId.None)
            {
                return null;
            }

            return _GetStoreLocation( configId );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String _GetStoreLocation( ConfigId configId );

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void TurnCacheOff( ref StackCrawlMark stackMark );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\principalpolicy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PrincipalPolicy.cool
//
//  Enum describing what type of principal to create by default (assuming no
//  principal has been set on the AppDomain).
//

namespace System.Security.Principal
{
    /// <include file='doc\PrincipalPolicy.uex' path='docs/doc[@for="PrincipalPolicy"]/*' />
	[Serializable]
    public enum PrincipalPolicy
    {
        // Note: it's important that the default policy has the value 0.
        /// <include file='doc\PrincipalPolicy.uex' path='docs/doc[@for="PrincipalPolicy.UnauthenticatedPrincipal"]/*' />
        UnauthenticatedPrincipal = 0,
        /// <include file='doc\PrincipalPolicy.uex' path='docs/doc[@for="PrincipalPolicy.NoPrincipal"]/*' />
        NoPrincipal = 1,
        /// <include file='doc\PrincipalPolicy.uex' path='docs/doc[@for="PrincipalPolicy.WindowsPrincipal"]/*' />
        WindowsPrincipal = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\sitestring.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// SiteString
// 
// author: gregfee
// 

namespace System.Security.Util {
    using System;
    using System.Collections;
    using System.Globalization;
    
    [Serializable]
    internal class SiteString
    {
        protected String m_site;
        protected ArrayList m_separatedSite;
        
        protected static char[] m_separators = { '.' };
        
        protected SiteString()
        {
            // Only call this in derived classes when you know what you're doing.
        }
        
        public SiteString( String site )
        {
            m_separatedSite = CreateSeparatedSite( site );
            m_site = site;
        }
        
        private SiteString( String site, ArrayList separatedSite )
        {
            m_separatedSite = separatedSite;
            m_site = site;
        }
        
        private static ArrayList CreateSeparatedSite( String site )
        {
            ArrayList list = new ArrayList();
            
            if (site == null || site.Length == 0)
            {
                throw new ArgumentException( Environment.GetResourceString("Argument_InvalidSite" ));
            }
            
            String[] separatedArray = site.Split( m_separators );
            
            for (int index = separatedArray.Length-1; index > -1; --index)
            {
                if (separatedArray[index] == null || separatedArray[index].Equals( "" ))
                {
                    throw new ArgumentException( Environment.GetResourceString("Argument_InvalidSite" ));
                }
                else if (separatedArray[index].Equals( "*" ))
                {
                    if (index != 0)
                    {
                        throw new ArgumentException( Environment.GetResourceString("Argument_InvalidSite" ));
                    }
                    list.Add( separatedArray[index] );
                }
                else if (!AllLegalCharacters( separatedArray[index] ))
                {
                    throw new ArgumentException( Environment.GetResourceString("Argument_InvalidSite" ));
                }
                else
                {
                    list.Add( separatedArray[index] );
                }
            }
            
            return list;
        }

        private static bool AllLegalCharacters( String str )
        {
            for (int i = 0; i < str.Length; ++i)
            {
                char c = str[i];

                if ((c >= 'a' && c <= 'z') ||
                    (c >= 'A' && c <= 'Z') ||
                    (c >= '/' && c <= '9') ||
                    (c == '-') ||
                    (c == '_') ||
                    (c == '@'))
                {
                    continue;
                }
                else
                {
                    return false;
                }
            }

            return true;
        }
                
        public override String ToString()
        {
            return m_site;
        }
        
        public override bool Equals(Object o)
        {
            if (o == null || !(o is SiteString))
                return false;
            else
                return this.Equals( (SiteString)o, true );
        }

        public override int GetHashCode()
        {
            return this.m_site.GetHashCode();
        }

        internal bool Equals( SiteString ss, bool ignoreCase )
        {
            if (this.m_site == null)
                return ss.m_site == null;
            if (ss.m_site == null)
                return false;
            return this.IsSubsetOf(ss, ignoreCase) && ss.IsSubsetOf(this, ignoreCase);
        }
            
        
        public virtual SiteString Copy()
        {
            return new SiteString( m_site, m_separatedSite );
        }

        public virtual bool IsSubsetOf( SiteString operand )
        {
            return this.IsSubsetOf( operand, true );
        }

        public virtual bool IsSubsetOf( SiteString operand, bool ignoreCase )
        {
            if (operand == null)
            {
                return false;
            }
            else if (this.m_separatedSite.Count == operand.m_separatedSite.Count &&
                     this.m_separatedSite.Count == 0)
            {
                return true;
            }
            else if (this.m_separatedSite.Count < operand.m_separatedSite.Count - 1)
            {
                return false;
            }
            else if (this.m_separatedSite.Count > operand.m_separatedSite.Count &&
                     operand.m_separatedSite.Count > 0 &&
                     !operand.m_separatedSite[operand.m_separatedSite.Count-1].Equals( "*" ))
            {
                return false;
            }
            else if (String.Compare( this.m_site, operand.m_site, ignoreCase, CultureInfo.InvariantCulture) == 0)
            {
                return true;
            }
    
            for (int index = 0; index < operand.m_separatedSite.Count - 1; ++index)
            {
                if (String.Compare( (String)this.m_separatedSite[index], (String)operand.m_separatedSite[index], ignoreCase, CultureInfo.InvariantCulture) != 0 )
                {
                    return false;
                }
            }
            
            if (this.m_separatedSite.Count <= operand.m_separatedSite.Count)
            {
                return operand.m_separatedSite[operand.m_separatedSite.Count-1].Equals( "*" );
            }
            else
            {
                return true;
            }
        }
                
        
    
        public virtual SiteString Intersect( SiteString operand )
        {
            if (operand == null)
            {
                return null;
            }
            else if (this.IsSubsetOf( operand ))
            {
                return this.Copy();
            }
            else if (operand.IsSubsetOf( this ))
            {
                return operand.Copy();
            }
            else
            {
                return null;
            }
        }
        
        public virtual SiteString Union( SiteString operand )
        {
            if (operand == null)
            {
                return this;
            }
            else if (this.IsSubsetOf( operand ))
            {
                return operand.Copy();
            }
            else if (operand.IsSubsetOf( this ))
            {
                return this.Copy();
            }
            else
            {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\windowsimpersonationcontext.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  WindowsImpersonationContext.cool
//
//  Representation of context needs to revert in a thread safe manner.
//

namespace System.Security.Principal
{
    using System;
    using System.Security;
    using System.Security.Permissions;
	using System.Runtime.CompilerServices;
    

    /// <include file='doc\WindowsImpersonationContext.uex' path='docs/doc[@for="WindowsImpersonationContext"]/*' />
    public class WindowsImpersonationContext
    {
        private IntPtr m_userToken;

        private static readonly IntPtr ZeroHandle = IntPtr.Zero;

        // keep only one instance of impersonation from system (empty revert) for perf reasons
        internal static WindowsImpersonationContext FromSystem = new WindowsImpersonationContext(ZeroHandle);

        internal WindowsImpersonationContext(IntPtr token)
        {
            if (token == ZeroHandle)
            {
                m_userToken = ZeroHandle;
            }
            else
            {
                m_userToken = WindowsIdentity._DuplicateHandle( token, false );

                if (m_userToken == ZeroHandle)
                    throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidToken" ) );
            }
        }

        // Revert to previous impersonation (the only public method)
        /// <include file='doc\WindowsImpersonationContext.uex' path='docs/doc[@for="WindowsImpersonationContext.Undo"]/*' />
        public void Undo()
        {
            if (m_userToken == ZeroHandle)
            {
                if (!_RevertToSelf())
                    throw new SecurityException(Environment.GetResourceString("Argument_RevertSystem"));
            }
            else
            {
                lock (this)
                {
                    if (!_SetThreadToken( m_userToken ))
                    {
                        // We need to assert ControlPrincipal because WindowsIdentity.GetCurrent()
                        // requires it.
                
                        new SecurityPermission( SecurityPermissionFlag.ControlPrincipal ).Assert();
                
                        WindowsIdentity userId = new WindowsIdentity( m_userToken );
                        WindowsIdentity currentId = WindowsIdentity.GetCurrent();
                    
                        if (!_RevertToSelf())
                            throw new SecurityException(Environment.GetResourceString("Argument_ImpersonateUser"));
                        
                        WindowsIdentity newCurrentId = WindowsIdentity.GetCurrent();
                    
                        if (!newCurrentId.Name.Equals( userId.Name ))
                        {
                            currentId.Impersonate();
                            throw new SecurityException(Environment.GetResourceString("Argument_ImpersonateUser"));
                        }
                    }
                }
            }
        }
        
        /// <include file='doc\WindowsImpersonationContext.uex' path='docs/doc[@for="WindowsImpersonationContext.Finalize"]/*' />
        /// <internalonly/>
        ~WindowsImpersonationContext()
        {
            // If we allocated the handle, make sure we close it.
        
            // Note: we lock the object here, which is probably
            // not necessary since this is only called when
            // there are no more references, but I'm not
            // bold enough to do it.

            if (m_userToken != ZeroHandle)
            {
                lock (this)
                {
                    if (m_userToken != ZeroHandle)
                    {
                        WindowsIdentity._CloseHandle(m_userToken);
                        m_userToken = ZeroHandle;
                    }
                }
            }
        }        


        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _SetThreadToken( IntPtr userToken );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _RevertToSelf();        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\parser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** CLASS:    Parser
**
** AUTHOR:   Brian Beckman (brianbec)
**
** PURPOSE:  Parse "Elementary XML", that is, XML without 
**           attributes or DTDs, in other words, XML with 
**           elements only.
** 
** DATE:     25 Jun 1998
** 
===========================================================*/
namespace System.Security.Util {
	using System.Text;
	using System.Runtime.InteropServices;
	using System;
	using BinaryReader = System.IO.BinaryReader ;
	using ArrayList = System.Collections.ArrayList;
	using Stream = System.IO.Stream;
	using StreamReader = System.IO.StreamReader;
    using Encoding = System.Text.Encoding;

    sealed internal class Parser
    {
        private SecurityElement   _ecurr = null ;
        private Tokenizer _t     = null ;
    
        internal SecurityElement GetTopElement()
        {
            BCLDebug.Assert( _ecurr != null, "This can't be null" );
            BCLDebug.Assert( _ecurr.m_lChildren != null && _ecurr.m_lChildren.Count > 0, "Children are messed up" );

            return (SecurityElement)_ecurr.m_lChildren[0];
        }

        internal Encoding GetEncoding()
        {
            return _t.GetEncoding();
        }
    
        private void ParseContents (SecurityElement e, bool restarted)
        {
            //
            // Iteratively collect stuff up until the next end-tag.
            // We've already seen the open-tag.
            //
            ParserStack stack = new ParserStack();
            ParserStackFrame firstFrame = new ParserStackFrame();
            firstFrame.element = e;
            firstFrame.intag = false;
            stack.Push( firstFrame );
            
            bool needToBreak = false;
            bool needToPop = false;
            bool createdNode = false;
            
            int i;

            do
            {
                ParserStackFrame locFrame = stack.Peek();
                
                for (i = _t.NextTokenType () ; i != -1 ; i = _t.NextTokenType ())
                {
                    switch (i)
                    {
                    case Tokenizer.cstr:
                        {
                            if (locFrame.intag)
                            {
                                if (locFrame.element.m_type == SecurityElementType.Comment)
                                {
                                    String appendString;

                                    if (locFrame.sawEquals)
                                    {
                                        appendString = "=\"" + _t.GetStringToken() + "\"";
                                        locFrame.sawEquals = false;
                                    }
                                    else
                                    {
                                        appendString = " " + _t.GetStringToken();
                                    }

                                    // Always set this directly since comments are not subjected
                                    // to the same restraints as other element types.  The strings
                                    // are all escaped so this shouldn't be a problem.

                                    locFrame.element.m_strTag += appendString;
                                }
                                else
                                {
                                    // We're in a regular tag, so we've found an attribute/value pair.
                                
                                    if (locFrame.strValue == null)
                                    {
                                        // Found attribute name, save it for later.
                                    
                                        locFrame.strValue = _t.GetStringToken ();
                                    }
                                    else
                                    {
                                        // Found attribute text, add the pair to the current element.

                                        if (!locFrame.sawEquals)
                                            throw new XmlSyntaxException( _t.LineNo );
    #if _DEBUG
                                        locFrame.element.AddAttribute( locFrame.strValue, _t.GetStringToken() );
    #else                                    
                                        locFrame.element.AddAttributeSafe( locFrame.strValue, _t.GetStringToken () );
    #endif
                                        locFrame.strValue = null;
                                    }
                                }
                            }
                            else
                            {
                                // We're not in a tag, so we've found text between tags.
                                
                                if (locFrame.element.m_strText == null)
                                    locFrame.element.m_strText = "" ;
    
                                StringBuilder sb = new StringBuilder (locFrame.element.m_strText) ;
    
                                //
                                // Separate tokens with single spaces, collapsing whitespace
                                //
                                if (!locFrame.element.m_strText.Equals (""))
                                    sb.Append (" ") ;
                            
                                sb.Append (_t.GetStringToken ()) ;
                                locFrame.element.m_strText =  sb.ToString ();
                            }
                        }
                        break ;
        
                    case Tokenizer.bra:
                        locFrame.intag = true;
                        i = _t.NextTokenType () ;
    
                        if (i == Tokenizer.slash)
                        {
                            while (true)
                            {
                                // spin; don't care what's in here
                                i = _t.NextTokenType();
                                if (i == Tokenizer.cstr)
                                    continue;
                                else if (i == -1)
                                    throw new XmlSyntaxException (_t.LineNo, Environment.GetResourceString( "XMLSyntax_UnexpectedEndOfFile" ));
                                else
                                    break;
                            }
        
                            if (i != Tokenizer.ket)
                            {
                                    throw new XmlSyntaxException (_t.LineNo, Environment.GetResourceString( "XMLSyntax_ExpectedCloseBracket" ));
                            }
         
                            locFrame.intag = false;
         
                            // Found the end of this element
                            stack.Pop();
                            
                            needToBreak = true;

                        }
                        else if (i == Tokenizer.cstr)
                        {
                            // Found a child
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            createdNode = true;

                            newFrame.element = new SecurityElement ();
                            
    #if _DEBUG
                            newFrame.element.Tag = _t.GetStringToken();
    #else
                            newFrame.element.m_strTag = _t.GetStringToken();
    #endif                            
                            
                            if (locFrame.element.m_type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.bang)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            ParserStackFrame newFrame = new ParserStackFrame();
        
                            newFrame.status = 1;

                            do
                            {
                                i = _t.NextTokenType();

                                if (newFrame.status < 3)
                                {
                                    if (i != Tokenizer.dash)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        newFrame.status++;
                                }
                                else
                                {
                                    if (i != Tokenizer.cstr)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        break;
                                }
                            }
                            while (true);                                    

                            createdNode = true;

                            newFrame.element = new SecurityElement ();

                            newFrame.element.m_type = SecurityElementType.Comment;
                            
    #if _DEBUG
                            newFrame.element.Tag = _t.GetStringToken();
    #else
                            newFrame.element.m_strTag = _t.GetStringToken();
    #endif                            
                            
                            if (locFrame.element.m_type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.quest)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            i = _t.NextTokenType();

                            if (i != Tokenizer.cstr)
                                throw new XmlSyntaxException( _t.LineNo );
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            createdNode = true;

                            newFrame.element = new SecurityElement ();

                            newFrame.element.m_type = SecurityElementType.Format;
                            
    #if _DEBUG
                            newFrame.element.Tag = _t.GetStringToken();
    #else
                            newFrame.element.m_strTag = _t.GetStringToken();
    #endif                            
                            
                            if (locFrame.element.m_type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            newFrame.status = 1;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else   
                        {
                            throw new XmlSyntaxException (_t.LineNo, Environment.GetResourceString( "XMLSyntax_ExpectedSlashOrString" ));
                        }
                        break ;
        
                    case Tokenizer.equals:
                        locFrame.sawEquals = true;
                        break;
                        
                    case Tokenizer.ket:
                        if (locFrame.intag)
                        {
                            locFrame.intag = false;
                            continue;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo, Environment.GetResourceString( "XMLSyntax_UnexpectedCloseBracket" ));
                        }
                        // not reachable
                        
                    case Tokenizer.slash:
                        locFrame.element.m_strText = null;
                        
                        i = _t.NextTokenType ();
                        
                        if (i == Tokenizer.ket)
                        {
                            // Found the end of this element
                            stack.Pop();
                            
                            needToBreak = true;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo, Environment.GetResourceString( "XMLSyntax_ExpectedCloseBracket" ));
                        }
                        break;
                        
                    case Tokenizer.quest:
                        if (locFrame.intag && locFrame.element.m_type == SecurityElementType.Format && locFrame.status == 1)
                        {
                            i = _t.NextTokenType ();

                            if (i == Tokenizer.ket)
                            {
                                stack.Pop();

                                needToBreak = true;
                            }
                            else
                            {
                                throw new XmlSyntaxException (_t.LineNo, Environment.GetResourceString( "XMLSyntax_ExpectedCloseBracket" ));
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    case Tokenizer.dash:
                        if (locFrame.intag && (locFrame.status > 0 && locFrame.status < 5) && locFrame.element.m_type == SecurityElementType.Comment)
                        {
                            locFrame.status++;

                            if (locFrame.status == 5)
                            {
                                i = _t.NextTokenType ();

                                if (i == Tokenizer.ket)
                                {
                                    stack.Pop();

                                    needToBreak = true;
                                }
                                else
                                {
                                    throw new XmlSyntaxException (_t.LineNo, Environment.GetResourceString( "XMLSyntax_ExpectedCloseBracket" ));
                                }
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    default:
                        throw new XmlSyntaxException (_t.LineNo) ;
                    }
                    
                    if (needToBreak)
                    {
                        needToBreak = false;
                        needToPop = false;
                        break;
                    }
                    else
                    {
                        needToPop = true;
                    }
                }

                if (needToPop)
                {
                    stack.Pop();
                }
                else if (i == -1 && (stack.GetCount() != 1 || !createdNode))
                {
                    // This means that we still have items on the stack, but the end of our
                    // stream has been reached.

                    throw new XmlSyntaxException( _t.LineNo, Environment.GetResourceString( "XMLSyntax_UnexpectedEndOfFile" ));
                }
            }
            while (stack.GetCount() > 1);

            SecurityElement topElement = this.GetTopElement();

            if (this.GetTopElement().m_type == SecurityElementType.Format)
            {
                if (restarted)
                    throw new XmlSyntaxException( _t.LineNo );

                String format = topElement.Attribute( "encoding" );

                if (format != null)
                {
                    _t.ChangeFormat( System.Text.Encoding.GetEncoding( format ) );
                }

                _ecurr = new SecurityElement();
                ParseContents( _ecurr, true );
            }

            
        }
    
        private Parser(Tokenizer t)
        {
            _t = t;
            _ecurr       = new SecurityElement();

            ParseContents (_ecurr, false) ;
        }
        
        internal Parser (String input)
            : this (new Tokenizer (input))
        {
        }
    
        internal Parser (BinaryReader input)
            : this (new Tokenizer (input))
        {
        }
       
        internal Parser( byte[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
        internal Parser( StreamReader input )
            : this (new Tokenizer( input ) )
        {
        }
        
        internal Parser( Stream input )
            : this (new Tokenizer( input ) )
        {
        }
        
        internal Parser( char[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
    }                                              
    
    
    internal class ParserStackFrame
    {
        internal SecurityElement element = null;
        internal bool intag = true;
        internal String strValue = null;
        internal int status = 0;
        internal bool sawEquals = false;
    }
    
    
    internal class ParserStack
    {
        private ArrayList m_array;
        
        internal ParserStack()
        {
            m_array = new ArrayList();
        }
        
        internal void Push( ParserStackFrame element )
        {
            m_array.Add( element );
        }
        
        internal ParserStackFrame Pop()
        {
            if (!IsEmpty())
            {
                int count = m_array.Count;
                ParserStackFrame temp = (ParserStackFrame) m_array[count-1];
                m_array.RemoveAt( count-1 );
                return temp;
            }
            else
            {
                throw new InvalidOperationException( Environment.GetResourceString( "InvalidOperation_EmptyStack" ) );
            }
        }
        
        internal ParserStackFrame Peek()
        {
            if (!IsEmpty())
            {
                return (ParserStackFrame) m_array[m_array.Count-1];
            }
            else
            {
                throw new InvalidOperationException( Environment.GetResourceString( "InvalidOperation_EmptyStack" ) );
            }
        }
        
        internal bool IsEmpty()
        {
            return m_array.Count == 0;
        }
        
        internal int GetCount()
        {
            return m_array.Count;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\principal\windowsidentity.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  WindowsIdentity.cool
//
//  Representation of a Windows identity
//

namespace System.Security.Principal
{
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Security;
    using System;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.Runtime.CompilerServices;
    using System.Runtime.Serialization;

    // NOTE: WindowsAccountType is mirrored in vm\COMPrincipal.cpp
    // If you make any changes/additions to this enum you must
    // update the adjoining unmanaged enum.

    /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsAccountType"]/*' />
    [Serializable]
    public enum WindowsAccountType
    {
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsAccountType.Normal"]/*' />
        Normal = 0,
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsAccountType.Guest"]/*' />
        Guest = 1,
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsAccountType.System"]/*' />
        System = 2,
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsAccountType.Anonymous"]/*' />
        Anonymous = 3
    }
    
    /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity"]/*' />
    [Serializable()]
    public class WindowsIdentity : IIdentity, ISerializable, IDeserializationCallback
    {
        private String m_name;
        private String m_type;
        private WindowsAccountType m_acctType;
        private bool m_isAuthenticated;
        private IntPtr m_userToken = IntPtr.Zero;
        
        private static readonly IntPtr ZeroHandle = new IntPtr( 0 );
     
        private WindowsIdentity(bool isWin9X) 
        {
            if (isWin9X) {
                // Create a junk identity
                m_acctType = WindowsAccountType.System;
            } else {
                // Create an anonymous identity
                m_acctType = WindowsAccountType.Anonymous;
            }
            m_name = "";
            m_type = "";
            m_userToken = ZeroHandle;
            m_isAuthenticated = false;
        }

        private WindowsIdentity(IntPtr userToken, WindowsAccountType type, bool isAuthenticated)
        {
            m_isAuthenticated = isAuthenticated;
            m_acctType = type;
            CreateFromToken(userToken, "NTLM", true);
        }
    
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.WindowsIdentity"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public WindowsIdentity( IntPtr userToken )
        {
            CreateFromToken( userToken, "NTLM", false );
            m_acctType = WindowsAccountType.Normal;
            m_isAuthenticated = false;
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.WindowsIdentity4"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public WindowsIdentity( String sUserPrincipalName )
        {
            IntPtr userToken = _S4ULogon(sUserPrincipalName);
            if(userToken == ZeroHandle)
                throw new ArgumentException(Environment.GetResourceString("Argument_UnableToLogOn"));
            CreateFromToken( userToken, "NTLM", true );
            m_acctType = WindowsAccountType.Normal;
            m_isAuthenticated = false;
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.WindowsIdentity1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public WindowsIdentity( IntPtr userToken, String type )
        {
            CreateFromToken( userToken, type, false );
            m_acctType = WindowsAccountType.Normal;
            m_isAuthenticated = false;
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.WindowsIdentity5"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public WindowsIdentity( String sUserPrincipalName, String type )
        {
            IntPtr userToken = _S4ULogon(sUserPrincipalName);
            if(userToken == ZeroHandle)
                throw new ArgumentException(Environment.GetResourceString("Argument_UnableToLogOn"));
            CreateFromToken( userToken, type, true );
            m_acctType = WindowsAccountType.Normal;
            m_isAuthenticated = false;
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.WindowsIdentity2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public WindowsIdentity( IntPtr userToken, String type, WindowsAccountType acctType )
        {
            CreateFromToken( userToken, type, false );
            m_acctType = acctType;
            m_isAuthenticated = false;
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.WindowsIdentity3"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public WindowsIdentity( IntPtr userToken, String type, WindowsAccountType acctType, bool isAuthenticated )
        {
            CreateFromToken( userToken, type, false );
            m_acctType = acctType;
            m_isAuthenticated = isAuthenticated;
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.WindowsIdentity6"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public WindowsIdentity( SerializationInfo info, StreamingContext context )
        {
            m_userToken = (IntPtr)info.GetValue( "m_userToken", typeof( IntPtr ) );
            m_name = (String)info.GetValue( "m_name", typeof( String ) );
            m_type = (String)info.GetValue( "m_type", typeof( String ) );
            m_acctType = (WindowsAccountType)info.GetValue( "m_acctType", typeof( WindowsAccountType ) );
            m_isAuthenticated = (bool)info.GetValue( "m_isAuthenticated", typeof( bool ) );

            if (m_userToken != ZeroHandle)
            {
                if (m_name == null)
                {
                    ResolveIdentity();
                }
                else if (!m_name.Equals( _ResolveIdentity( m_userToken ) ))
                {
                    throw new NotSupportedException( Environment.GetResourceString( "NotSupported_CrossProcessWindowsIdentitySerialization" ) );
                }

                CreateFromToken( m_userToken, m_type, false );
            }
        }
            

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.GetCurrent"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public static WindowsIdentity GetCurrent()
        {
            IntPtr userToken = _GetCurrentToken();

            if (userToken != ZeroHandle) {
                // _GetCurrentToken succeeded, try to get the user identity
                return new WindowsIdentity(userToken, _GetAccountType( userToken ), true);
            } else {
                // _GetCurrentToken failed (this is always the case in Win9x for example)
                // Try to fail silently
                return new WindowsIdentity(true);
            }
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.GetAnonymous"]/*' />
        public static WindowsIdentity GetAnonymous()
        {
            return new WindowsIdentity(false);
        }

        private void CreateFromToken(IntPtr userToken, String type, bool bClose)
        {
            m_type = type;

            if (userToken == ZeroHandle)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_TokenZero")); 
            }

            m_userToken = _DuplicateHandle( userToken, bClose );

            if (m_userToken == ZeroHandle)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidToken"));
            }
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.Name"]/*' />
        public virtual String Name
        { 
            get
            {
                if (m_name == null)
                {
                    lock (this)
                    {
                        if (m_name == null)
                        {
                            if (!ResolveIdentity())
                            {
                                throw new ArgumentException(Environment.GetResourceString("Argument_TokenUnableToGetName"));
                            }
                        }
                    }
                }

                return m_name;
            }
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.AuthenticationType"]/*' />
        public virtual String AuthenticationType
        {
            get
            {
                return m_type;
            }
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.IsAuthenticated"]/*' />
        public virtual bool IsAuthenticated
        {
            get
            {
                return m_isAuthenticated;
            }
        }
                
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.Token"]/*' />
        public  virtual IntPtr Token
        {
            get
            {
                return m_userToken;
            }
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.IsGuest"]/*' />
        public virtual bool IsGuest
        {
            get
            {
                return m_acctType == WindowsAccountType.Guest;
            }
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.IsSystem"]/*' />
        public virtual bool IsSystem
        {
            get
            {
                return m_acctType == WindowsAccountType.System;
            }
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.IsAnonymous"]/*' />
        public virtual bool IsAnonymous
        {
            get
            {
                return m_acctType == WindowsAccountType.Anonymous;
            }
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.Impersonate"]/*' />
        public virtual WindowsImpersonationContext Impersonate()
        {
            return Impersonate( m_userToken, m_acctType );
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.Impersonate1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public static WindowsImpersonationContext Impersonate( IntPtr userToken )
        {
            return Impersonate( userToken, WindowsAccountType.Normal );
        }

        private static WindowsImpersonationContext Impersonate( IntPtr userToken, WindowsAccountType acctType )
        {
            // We grab the current user token and save it so we can revert to it later.
    
            WindowsImpersonationContext context = null;
            
            if (acctType == WindowsAccountType.Anonymous)
                throw new InvalidOperationException( Environment.GetResourceString( "InvalidOperation_AnonymousCannotImpersonate" ) );

            IntPtr token = _GetCurrentToken();
            
            try
            {
                if (token != ZeroHandle)
                    context = new WindowsImpersonationContext( token );
                else
                    context = WindowsImpersonationContext.FromSystem;
            }
            finally
            {
                if (token != ZeroHandle)
                    _CloseHandle( token );
            }
                
            if (userToken == ZeroHandle)
            {
                if (!_RevertToSelf())
                    throw new SecurityException(Environment.GetResourceString("Argument_ImpersonateSystem"));
            }
            else
            {
                if (!_ImpersonateLoggedOnUser( userToken ))
                    throw new SecurityException(Environment.GetResourceString("Argument_ImpersonateUser"));
            }
            
            return context;
        }
        
        private bool ResolveIdentity()
        {
            // call down to native and use LookupAccountSID to get identity info.
            // return false is badness happens.
            m_name = _ResolveIdentity( m_userToken );
            
            return m_name != null;
        }
        
        internal String[] GetRoles()
        {
            // call down to native and lookup what roles this identity belongs to
            // return null is badness happens.
            
            return _GetRoles( m_userToken );
        }
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.Finalize"]/*' />
        ~WindowsIdentity()
        {
            // If we allocated the handle, make sure we close it.
        
            if (m_userToken != ZeroHandle)
            {
                _CloseHandle(m_userToken);
                m_userToken = ZeroHandle;
            }
        }   
        
        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue( "m_userToken", m_userToken );
            info.AddValue( "m_name", m_name );
            info.AddValue( "m_type", m_type );
            info.AddValue( "m_acctType", m_acctType );
            info.AddValue( "m_isAuthenticated", m_isAuthenticated );
        }

        /// <include file='doc\WindowsIdentity.uex' path='docs/doc[@for="WindowsIdentity.IDeserializationCallback.OnDeserialization"]/*' />
        /// <internalonly/>
        void IDeserializationCallback.OnDeserialization(Object sender)        
        {
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String _ResolveIdentity( IntPtr userToken );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern IntPtr _DuplicateHandle( IntPtr userToken, bool bClose );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void _CloseHandle( IntPtr userToken );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String[] _GetRoles( IntPtr userToken );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern IntPtr _GetCurrentToken();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _SetThreadToken( IntPtr userToken );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _ImpersonateLoggedOnUser( IntPtr userToken );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _RevertToSelf();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern WindowsAccountType _GetAccountType( IntPtr userToken );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern IntPtr _S4ULogon( String sUserPrincipalName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\tokenizer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** CLASS:    Tokenizer.cool
**
** AUTHOR:   Brian Beckman (brianbec)
**
** PURPOSE:  Tokenize "Elementary XML", that is, XML without 
**           attributes or DTDs, in other words, XML with 
**           elements only.
** 
** DATE:     25 Jun 1998
** 
===========================================================*/
namespace System.Security.Util {
    using System.Text;
    using System;
    using System.IO;

    internal class Tokenizer 
    {
        private ITokenReader         _input;
        private bool             _fintag;
        private StringBuilder       _cstr;
        private char[]              _sbarray;
        private int                 _sbindex;
        private const int          _sbmaxsize = 128;
    
        // There are five externally knowable token types: bras, kets,
        // slashes, cstrs, and equals.  
    
        internal const int bra     = 0;
        internal const int ket     = 1;
        internal const int slash   = 2;
        internal const int cstr    = 3;
        internal const int equals  = 4;
        internal const int quest   = 5;
        internal const int bang    = 6;
        internal const int dash    = 7;

        internal const int intOpenBracket = (int) '<';
        internal const int intCloseBracket = (int) '>';
        internal const int intSlash = (int) '/';
        internal const int intEquals = (int) '=';
        internal const int intQuote = (int) '\"';
        internal const int intQuest = (int) '?';
        internal const int intBang = (int) '!';
        internal const int intDash = (int) '-';
    
        public int  LineNo;
    
        //================================================================
        // Constructor uses given ICharInputStream
        //

        internal Tokenizer (String input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StringTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        

        internal Tokenizer (BinaryReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new TokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (byte[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new ByteTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (char[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new CharTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        
        
        internal Tokenizer (StreamReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }
    
        internal Tokenizer (Stream input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(new StreamReader( input )) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }


        internal void ChangeFormat( System.Text.Encoding encoding )
        {
            if (encoding == null)
            {
                return;
            }

            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return;
            }

            Stream stream = reader._in.BaseStream;

            BCLDebug.Assert( reader._in.CurrentEncoding != null, "Tokenizer's StreamReader does not have an encoding" );

            String fakeReadString = new String( new char[reader.NumCharEncountered] );

            stream.Position = reader._in.CurrentEncoding.GetByteCount( fakeReadString );

            _input = new StreamTokenReader( new StreamReader( stream, encoding ) );
        }

        internal System.Text.Encoding GetEncoding()
        {
            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return null;
            }
            
            return reader._in.CurrentEncoding;
        }

   
        //================================================================
        // 
        //
        private bool FIsWhite (int j)
        {
            if ((j == 10) && (_input.Peek() != -1))
                LineNo ++ ;
    
            bool retval =  (j == 32) || (j ==  9)  // Space and tab
                        || (j == 13) || (j == 10); // CR and LF
         
            return retval;
                
        }
    
        //================================================================
        // Parser needs to know types of tokens
        //
        private void SBArrayAppend(char c) {
            // this is the common case
            if (_sbindex != _sbmaxsize) {
                _sbarray[_sbindex] = c;
                _sbindex++;
                return;
            } 
            // OK, first check if we have to init the StringBuilder
            if (_cstr == null) {
                _cstr = new StringBuilder();
            }
            // OK, copy from _sbarray to _cstr
            _cstr.Append(_sbarray,0,_sbmaxsize);
            // reset _sbarray pointer
            _sbarray[0] = c;
            _sbindex = 1;
            return;
        }
        
        internal int NextTokenType()
        {
            _cstr = null;
            _sbindex = 0;
            int i;
            
            i = _input.Read();
        BEGINNING_AFTER_READ:            
        
            switch (i)
            {
            case -1:
                return -1;
                
            case intOpenBracket:
                _fintag = true;
                return bra;
                
            case intCloseBracket:
                _fintag = false;
                return ket;
                
            case intEquals:
                return equals;
                
            case intSlash:
                if (_fintag) return slash;
                goto default;

            case intQuest:
                if (_fintag) return quest;
                goto default;

            case intBang:
                if (_fintag) return bang;
                goto default;

            case intDash:
                if (_fintag) return dash;
                goto default;
                
            default:
                // We either have a string or whitespace.
                if (FIsWhite( i ))
                {
                    do
                    {
                        i = _input.Read();
                    } while (FIsWhite( i ));
                    
                    goto BEGINNING_AFTER_READ;
                }
                else
                {
                    // The first and last characters in a string can be quotes.
                    
                    bool inQuotedString = false;

                    if (i == intQuote)
                    {
                        inQuotedString = true;
                        i = _input.Read();

                        if (i == intQuote)
                            return cstr;
                    }

                    do
                    {
                        SBArrayAppend( (char)i );
                        i = _input.Peek();
                        if (!inQuotedString && (FIsWhite( i ) || i == intOpenBracket || (_fintag && (i == intCloseBracket || i == intEquals || i == intSlash))))
                            break;
                        _input.Read();
                        if (i == intQuote && inQuotedString)
                            break;
                        if (i == -1)
                            return -1;
                    } while (true);
                    
                    return cstr;
                }
            }
            
        }
        

        //================================================================
        //
        //
        
        internal String GetStringToken ()
        {
            // OK, easy case first, _cstr == null
            if (_cstr == null) {
                // degenerate case
                if (_sbindex == 0) return("");
                return(String.CreateFromCharArray(_sbarray,0,_sbindex));
            }
            // OK, now we know we have a StringBuilder already, so just append chars
            _cstr.Append(_sbarray,0,_sbindex);
            return(_cstr.ToString());
        }
    
        internal interface ITokenReader
        {
            int Peek();
            int Read();
        }
    
        internal class ByteTokenReader : ITokenReader {
            private byte[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal ByteTokenReader( byte[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }

        internal class StringTokenReader : ITokenReader {
            private String _input;
            private int _currentIndex;
            private int _inputSize;
            
            internal StringTokenReader( String input )
            {
                _input = input;
                _currentIndex = 0;
                _inputSize = input.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex++];
                }
            }
        } 
        
        internal class CharTokenReader : ITokenReader {
            private char[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal CharTokenReader( char[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }        
                
        internal class TokenReader : ITokenReader {
    
            private BinaryReader _in;
    
            internal TokenReader(BinaryReader input) {
                _in = input;
            }
    
            public virtual int Peek() {
                return _in.PeekChar();
            }
    
            public virtual int Read() {
                return _in.Read();
            }
        }
        
        internal class StreamTokenReader : ITokenReader {
            
            internal StreamReader _in;
            internal int _numCharRead;
            
            internal StreamTokenReader(StreamReader input) {
                _in = input;
                _numCharRead = 0;
            }
            
            public virtual int Peek() {
                return _in.Peek();
            }
            
            public virtual int Read() {
                int value = _in.Read();
                if (value != -1)
                    _numCharRead++;
                return value;
            }

            internal int NumCharEncountered
            {
                get
                {
                    return _numCharRead;
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\asciiencoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System.Text;

    //Marking this class serializable has no effect because it has no state, however,
    //it prevents attempts to serialize a graph containing an ASCII encoding from failing.
    using System;
    /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding"]/*' />
    [Serializable()] public class ASCIIEncoding : Encoding
    {
        private const int ASCII_CODEPAGE=20127;
        
        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.ASCIIEncoding"]/*' />
        public ASCIIEncoding() : base(ASCII_CODEPAGE) {
        }

        // YSLin Make this internal for now until we decide the final spec of EncodingFallback
        //ENCODINGFALLBACK
        /*
        internal ASCIIEncoding(EncodingFallback encodingFallback) 
            : base(ASCII_CODEPAGE, encodingFallback) {
        }
        */
        

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetByteCount"]/*' />
        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }

            return (count);
            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback == null) {
                return count;
            }

            int byteCount = 0;
            int endCharIndex = index + count;   // This is the end of index plus one.
            for (int i = index; i < endCharIndex; i++) {
                if (chars[i] >= (char)0x0080) {
                    int offset = 1;
                    while (i+offset < endCharIndex && chars[i+offset] >= (char)0x0080) {
                        offset++;
                    }
                    char[] fallbackChars = m_encodingFallback.Fallback(chars, index, offset);
                    byteCount += fallbackChars.Length;
                    i += offset;
                }
                else
                    byteCount++;
            }
            return (byteCount);
            */
        }

	    /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetByteCount1"]/*' />
	    public override int GetByteCount(String chars) {
            if (chars == null) {
                throw new ArgumentNullException("chars", Environment.GetResourceString("ArgumentNull_Array"));
            }
            return chars.Length;
        }

         /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetBytes"]/*' />
        public override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }    
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
                throw new ArgumentOutOfRangeException("byteIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (bytes.Length - byteIndex < charCount) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
            int charEnd = charIndex + charCount;

            while (charIndex < charEnd) {
                char ch = chars[charIndex++];
                if (ch >= 0x0080) ch = '?';
                bytes[byteIndex++] = (byte)ch;
            }
            return charCount;

            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback == null) {
                while (charIndex < charEnd) {
                    char ch = chars[charIndex++];
                    if (ch >= 0x0080) ch = '?';
                    bytes[byteIndex++] = (byte)ch;
                }
                return charCount;
            } 
            
            int currByteIndex = byteIndex;
            while (charIndex < charEnd) {
                char ch = chars[charIndex];
                if (ch >= (char)0x0080) {
                    int offset = 1;
                    while (charIndex + offset < charEnd && chars[charIndex + offset] >= (char)0x0080) {
                        offset++;
                    }
                    
                    //int byteCount = m_encodingFallback.GetBytes(chars, charIndex, offset, bytes, currByteIndex);
                    char[] fallback = m_encodingFallback.Fallback(chars, charIndex, offset);
                    for (int i = 0; i < fallback.Length; i++) {
                        bytes[currByteIndex++] = (byte)(fallback[i]);
                    }
                    charIndex += offset;
                } else {
                    bytes[currByteIndex++] = (byte)ch;
                }
                charIndex++;
            }
            return (currByteIndex - byteIndex);
            */
        }

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetBytes1"]/*' />
        public override int GetBytes(String chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }    
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
                throw new ArgumentOutOfRangeException("byteIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (bytes.Length - byteIndex < charCount) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
            int charEnd = charIndex + charCount;

            //if (m_encodingFallback == null) {
                while (charIndex < charEnd) {
                    char ch = chars[charIndex++];
                    if (ch >= 0x0080) ch = '?';
                    bytes[byteIndex++] = (byte)ch;
                }
                return charCount;
                //} 
            
            /*
            int currByteIndex = byteIndex;
            while (charIndex < charEnd) {
                char ch = chars[charIndex];
                if (ch >= (char)0x0080) {
                    int offset = 1;
                    while (charIndex + offset < charEnd && chars[charIndex + offset] >= (char)0x0080) {
                        offset++;
                    }
                    
                    //int byteCount = m_encodingFallback.GetBytes(chars, charIndex, offset, bytes, currByteIndex);
                    char[] fallback = m_encodingFallback.Fallback(chars, charIndex, offset);
                    for (int i = 0; i < fallback.Length; i++) {
                        bytes[currByteIndex++] = (byte)(fallback[i]);
                    }
                    charIndex += offset;
                } else {
                    bytes[currByteIndex++] = (byte)ch;
                }
                charIndex++;
            }
            return (currByteIndex - byteIndex);
            */
        }

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetCharCount"]/*' />
        public override int GetCharCount(byte[] bytes, int index, int count) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }                                                         
            if (bytes.Length - index < count) {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            return (count);

        }

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetChars"]/*' />
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex) {
            if (bytes == null || chars == null) {
                throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }    
            if ( bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (charIndex < 0 || charIndex > chars.Length) {
                throw new ArgumentOutOfRangeException("charIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (chars.Length - charIndex < byteCount) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
            int byteEnd = byteIndex + byteCount;
            while (byteIndex < byteEnd) {
                byte b = bytes[byteIndex++];
                if (b > 0x7f) {
                    // This is an invalid byte in the ASCII encoding.
                    chars[charIndex++] = '?';
                } else {
                    chars[charIndex++] = (char)b;
                }
            }
            return (byteCount);

        }

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetString"]/*' />
        public override String GetString(byte[] bytes)
        {
            if (bytes == null)
                throw new ArgumentNullException("bytes", Environment.GetResourceString("ArgumentNull_Array"));
            return String.CreateStringFromASCII(bytes, 0, bytes.Length);
        }

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetString1"]/*' />
        public override String GetString(byte[] bytes, int byteIndex, int byteCount)
        {
            if (bytes == null)
                throw new ArgumentNullException("bytes", Environment.GetResourceString("ArgumentNull_Array"));                
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }    
            if (bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            return String.CreateStringFromASCII(bytes, byteIndex, byteCount);
        }

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetMaxByteCount"]/*' />
        public override int GetMaxByteCount(int charCount) {
            if (charCount < 0) {
               throw new ArgumentOutOfRangeException("charCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }

            return (charCount);
            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback == null) {
                return charCount;
            }

            int fallbackMaxChars = m_encodingFallback.GetMaxCharCount();
            if (fallbackMaxChars == 0)
                return charCount;
            else
                return charCount * fallbackMaxChars;
            */                
        }

        /// <include file='doc\ASCIIEncoding.uex' path='docs/doc[@for="ASCIIEncoding.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount(int byteCount) {
            if (byteCount < 0) {
               throw new ArgumentOutOfRangeException("byteCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            return byteCount;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\tokenbasedsetenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// TokenBasedSetEnumerator.cool
//
namespace System.Security.Util {
        
    using System;
    using System.Collections;
    
    internal class TokenBasedSetEnumerator : IEnumerator
    {
        protected TokenBasedSet   m_set;
        protected int             m_currentIndex;
        
        public TokenBasedSetEnumerator(TokenBasedSet set)
        {
            SetData(set);
        }
        
        protected void SetData(TokenBasedSet set)
        {
            m_set = set;
            m_currentIndex = -1;
        }
        
        private bool EndConditionReached()
        {
           return m_set == null || (m_currentIndex > m_set.GetMaxUsedIndex());
        }
        
        // Advances the enumerator to the next element of the enumeration and
        // returns a boolean indicating whether an element is available. Upon
        // creation, an enumerator is conceptually positioned before the first
        // element of the enumeration, and the first call to GetNext brings
        // the first element of the enumeration into view.
        // 
        public virtual bool MoveNext()
        {
            Object perm = null;
            
            while (!EndConditionReached())
            {
                ++m_currentIndex;
                perm = m_set.GetItem(m_currentIndex);
                if (perm != null)
                    return true;
            }
                    
            return false;
        }
        
        // Returns the current element of the enumeration. The returned value is
        // undefined before the first call to GetNext and following a call
        // to GetNext that returned false. Multiple calls to
        // GetObject with no intervening calls to GetNext will return
        // the same object.
        // 
        public virtual Object Current {
            get {
                if (m_currentIndex==-1)
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumNotStarted"));
                if (EndConditionReached())
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumEnded"));
                
                return m_set.GetItem(m_currentIndex);
            }
        }
        
        // Removes the current element from the underlying set of objects. This
        // method will throw a NotSupportedException if the underlying set of
        // objects cannot be modified.
        // 
        public virtual void Remove()
        {
            if (m_currentIndex==-1)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumNotStarted"));
            if (EndConditionReached())
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumEnded"));
            
            m_set.SetItem(m_currentIndex, null);
        }
        
        public int GetCurrentIndex()
        {
            return m_currentIndex;
        }

        public virtual void Reset() {
            m_currentIndex = -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\codepageencoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System;
	using System.Security;
    using System.Collections;
	using System.Runtime.CompilerServices;

    //
    // These are the delegates used by the internal GetByteCountFallback() and GetBytesFallback() to provide
    // the fallback support.
    //
    /*
    //ENCODINGFALLBACK
    internal delegate int UnicodeToBytesDelegate(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount); //, out bool usedDefaultChar);
    internal delegate int BytesToUnicodeDelegate(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount);
    */

    /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding"]/*' />
    [Serializable()] internal class CodePageEncoding : Encoding
    {
        private int maxCharSize;
    
        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.CodePageEncoding"]/*' />
        public CodePageEncoding(int codepage) : base(codepage == 0? Microsoft.Win32.Win32Native.GetACP(): codepage) {
            maxCharSize = GetCPMaxCharSizeNative(codepage);
        }

        /*
        //ENCODINGFALLBACK
        // YSLin Make this internal for now until we decide the final spec of EncodingFallback
        internal CodePageEncoding(int codepage, EncodingFallback encodingFallback) 
            //The call to super will set our dataItem.
            : base(codepage == 0? Microsoft.Win32.Win32Native.GetACP(): codepage, encodingFallback) {
            
            maxCharSize = GetCPMaxCharSizeNative(codepage);
        }
        */
    
        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.GetByteCount"]/*' />
        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }

            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback != null) {
                UnicodeToBytesDelegate unicodeToBytes = new UnicodeToBytesDelegate(CallUnicodeToBytes);
                BytesToUnicodeDelegate bytesToUnicode = new BytesToUnicodeDelegate(CallBytesToUnicode);                
                return (GetByteCountFallback(unicodeToBytes, bytesToUnicode, m_encodingFallback, chars, index, count));
            }
            */
            if (maxCharSize == 1) return count;
            //bool useDefaultChar;
            int byteCount = UnicodeToBytesNative(m_codePage, chars, index, count, null, 0, 0);

            // Check for overflows.
            if (byteCount < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return byteCount;
        }

        /*=================================GetByteCountFallback==========================
        **Action: To get the byte count according to the selected fallback handler.
        **Returns:  The number of bytes needed to encode the specified Unicode characters. 
        **Arguments: 
        **  unicodeToBytes  delegate to a method which converts unicode characters to bytes.
        **  bytesToUnicode  delegate to a method which converts bytes to unicode characters.
        **  fallback    the encoding fallback handler.
        **  chars       the source Unicode characters.
        **  index       the beginning index of Unicode characters.
        **  count       the count of Unicode characters.
        **Notes:
        **  The way that we find characters needed to be fallback are:
        **  1. Convert Unicode characters to bytes.
        **  2. Convert bytes back to Unicode characters.
        **  3. Do a char by char comparison between the Unicode characters in step 1 and step 2.
        **  4. If an Unicode character is different, scan forward to see how many characters are invalid.        
        **  5. Pass the beginning index of invalid characters and the count to fallback handler.
        ============================================================================*/

        /*
        //ENCODINGFALLBACK
        internal static int GetByteCountFallback(
            UnicodeToBytesDelegate unicodeToBytes, 
            BytesToUnicodeDelegate bytesToUnicode,
            EncodingFallback fallback,
            char[] chars,
            int index,
            int count) {

            //
            // Convert chars to bytes.
            //
            bool useDefaultChar = true;
            int result = unicodeToBytes(chars, index, count, null, 0, 0, out useDefaultChar);
            if (!useDefaultChar && fallback.GetType() != typeof(NoBestFitFallback)) {
                return (result);
            }
            
            byte[] bytes = new byte[result];
            result = unicodeToBytes(chars, index, count, bytes, 0, result, out useDefaultChar);

            char[] roundtripChars = new char[count];
            int unicodeResult = bytesToUnicode(bytes, 0, result, roundtripChars, 0, count);

            //
            // Scan characters to see if there is need to do fallback;
            //
            int[] charOffsets = new int[chars.Length];
            int charOffsetCount = 0;
            int i;

            int startIndex = index;
            int endCharIndex = index + count;   // This is the end of index plus one.
            bool fallbackAtFirstChar = chars[startIndex] != roundtripChars[0];
            
            for (i = index; i < endCharIndex; i++) {
                if (chars[i] != roundtripChars[i - index]) {
                    if (!fallbackAtFirstChar) {
                        charOffsets[charOffsetCount++] = i - startIndex;
                    }
                    int offset = 1;
                    while ((i+1 < endCharIndex) && (chars[i+1] != roundtripChars[i - index +1])) {
                        offset++;
                        i++;
                    }
                    charOffsets[charOffsetCount++] = offset;
                    startIndex = i + 1;
                }
            }

            if (charOffsetCount == 0) {
                //
                // There is no fallback character.
                //
                return (result);
            }

            if (startIndex < endCharIndex) {
                charOffsets[charOffsetCount++] = endCharIndex - startIndex;
            }

            startIndex = index;
            int byteCount;
            result = 0;

            bool isFallback = fallbackAtFirstChar;
            
            for (i = 0; i < charOffsetCount; i++) {

                if (isFallback) {                
                    char[] fallbackChars = fallback.Fallback(chars, startIndex, charOffsets[i]);
                    byteCount = unicodeToBytes(fallbackChars, 0, fallbackChars.Length, null, 0, 0, out useDefaultChar);
                } else {                    
                    byteCount = unicodeToBytes(chars, startIndex, charOffsets[i], null, 0, 0, out useDefaultChar);
                }                        
                
                result += byteCount;                    
                startIndex += charOffsets[i];

                isFallback = !isFallback;
            }        
            return (result);
        }
        */
        
        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.GetBytes"]/*' />
        public override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (charCount == 0) return 0;
            if (byteIndex == bytes.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));

            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback != null) {
                UnicodeToBytesDelegate unicodeToBytes = new UnicodeToBytesDelegate(CallUnicodeToBytes);
                BytesToUnicodeDelegate bytesToUnicode = new BytesToUnicodeDelegate(CallBytesToUnicode);                
                return (GetBytesFallback(unicodeToBytes, bytesToUnicode, m_encodingFallback, chars, charIndex, charCount, bytes, byteIndex));
            }
            */

            //bool usedDefaultChar;
            int result = UnicodeToBytesNative(m_codePage, chars, charIndex, charCount,
                                              bytes, byteIndex, bytes.Length - byteIndex);
                
            if (result == 0) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            
            return (result);
        }

        /*
        //ENCODINGFALLBACK
        internal int CallUnicodeToBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount) {
            return (UnicodeToBytesNative(m_codePage, chars, charIndex, charCount, bytes, byteIndex, byteCount));
        }

        internal int CallBytesToUnicode(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount) {
            return (BytesToUnicodeNative(m_codePage, bytes, byteIndex, byteCount, chars, charIndex, charCount));
        }
        */

        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.GetCharCount"]/*' />
        public override int GetCharCount(byte[] bytes, int index, int count) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }                                                             
            if (bytes.Length - index < count) {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (maxCharSize == 1) return count;
            return BytesToUnicodeNative(m_codePage, bytes, index, count, null, 0, 0);
        }
        
        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.GetChars"]/*' />
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex) {
            if (bytes == null || chars == null) {
                throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }        
            if ( bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (charIndex < 0 || charIndex > chars.Length) {
                throw new ArgumentOutOfRangeException("charIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (byteCount == 0) return 0;
            if (charIndex == chars.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            int result = BytesToUnicodeNative(m_codePage, bytes, byteIndex, byteCount,
                chars, charIndex, chars.Length - charIndex);
            if (result == 0) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            return result;
        }
    
        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.GetDecoder"]/*' />
        public override System.Text.Decoder GetDecoder() {
            return new Decoder(this);
        }
        
        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.GetMaxByteCount"]/*' />
        public override int GetMaxByteCount(int charCount) {
            if (charCount < 0) {
               throw new ArgumentOutOfRangeException("charCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            long byteCount = charCount * maxCharSize;
            // Check for overflows.
            if (byteCount < 0 || byteCount > Int32.MaxValue)
                throw new ArgumentOutOfRangeException("charCount", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return (int)byteCount;

            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback == null) {
                return charCount * maxCharSize;
            }
            int fallbackMaxChars = m_encodingFallback.GetMaxCharCount();

            if (fallbackMaxChars == 0) {
                return (charCount * maxCharSize);
            }

            return (fallbackMaxChars * charCount * maxCharSize);
            */
        }
    
        /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount(int byteCount) {
            if (byteCount < 0) {
               throw new ArgumentOutOfRangeException("byteCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            return byteCount;
        }

        /*
        //ENCODINGFALLBACK
        internal static int GetBytesFallback(
            UnicodeToBytesDelegate unicodeToBytes, 
            BytesToUnicodeDelegate bytesToUnicode, 
            EncodingFallback m_encodingFallback, 
            char[] chars, int charIndex, int charCount, 
            byte[] bytes, int byteIndex) {

            bool useDefaultChar = true;
            int byteCount = unicodeToBytes(chars, charIndex, charCount,
                bytes, byteIndex, bytes.Length - byteIndex, out useDefaultChar);
            if (!useDefaultChar && m_encodingFallback.GetType() != typeof(NoBestFitFallback)) {
                return (byteCount);
            }

            int unicodeResult = bytesToUnicode(bytes, byteIndex, byteCount, null, 0, 0);
            char[] roundtripChars = new char[unicodeResult];
            unicodeResult = bytesToUnicode(bytes, byteIndex, byteCount, roundtripChars, 0, unicodeResult);

            //
            // Scan characters to see if there is need to do fallback;
            //
            int[] charOffsets = new int[chars.Length];
            int charOffsetCount = 0;
            int i;

            int startIndex = charIndex;
            //
            // Flag to indicate if the first character is a fallback character.
            //
            bool fallbackAtFirstChar = (chars[startIndex] != roundtripChars[0]);
            
            int endCharIndex = charIndex + charCount;   // This is the end of index plus one.
            for (i = charIndex; i < endCharIndex; i++) {
                if (chars[i] != roundtripChars[i - charIndex]) {
                    if (!fallbackAtFirstChar) {
                        charOffsets[charOffsetCount++] = i - startIndex;
                    }
                    int offset = 1;
                    while ((i+1 < endCharIndex) && (chars[i+1] != roundtripChars[i - charIndex +1])) {
                        offset++;
                        i++;
                    }
                    charOffsets[charOffsetCount++] = offset; 
                    startIndex = i + 1;
                }
            }

            if (charOffsetCount == 0) {
                //
                // There is no fallback character.
                //
                return (byteCount);
            }

            if (startIndex < endCharIndex) {
                charOffsets[charOffsetCount++] = endCharIndex - startIndex;
            }

            startIndex = charIndex;
            int count;
            int result = 0;
            bool isFallback = fallbackAtFirstChar;
            
            for (i = 0; i < charOffsetCount; i++) {

                if (isFallback) {
                    char[] fallbackChars = m_encodingFallback.Fallback(chars, startIndex, charOffsets[i]);                    
                    count = unicodeToBytes(fallbackChars, 0, fallbackChars.Length, 
                        bytes, byteIndex, bytes.Length - byteIndex, out useDefaultChar);
                } else {                    
                    count = unicodeToBytes(chars, startIndex, charOffsets[i], 
                        bytes, byteIndex, bytes.Length - byteIndex, out useDefaultChar);
                } 
                
                if (count == 0) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                } 
                
                result += count;                    
                byteIndex += count;                
                startIndex += charOffsets[i];
                isFallback = !isFallback;
            } 
            return (result);
        }
        */
            
        [Serializable]
        private class Decoder : System.Text.Decoder
        {
            private CodePageEncoding encoding;
            private int lastByte;
            private byte[] temp;
    
            public Decoder(CodePageEncoding encoding) {
                if (encoding.CodePage==50229) {
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_CodePage50229"));
                }

                this.encoding = encoding;
                lastByte = -1;
                temp = new byte[2];
            }
    
            /// <include file='doc\CodePageEncoding.uex' path='docs/doc[@for="CodePageEncoding.Decoder.GetCharCount"]/*' />
        public override int GetCharCount(byte[] bytes, int index, int count) {
                if (bytes == null) {
                    throw new ArgumentNullException("bytes", 
                        Environment.GetResourceString("ArgumentNull_Array"));
                }
                if (index < 0 || count < 0) {
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                        Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }            
                if (bytes.Length - index < count) {
                    throw new ArgumentOutOfRangeException("bytes",
                        Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                }
                if (encoding.maxCharSize == 1 || count == 0) return count;
                int result = 0;
                if (lastByte >= 0) {
                    index++;
                    count--;
                    result = 1;
                    if (count == 0) return result;
                }
                if ((GetEndLeadByteCount(bytes, index, count) & 1) != 0) {
                    count--;
                    if (count == 0) return result;
                }
                return result + BytesToUnicodeNative(encoding.m_codePage,
                    bytes, index, count, null, 0, 0);
            }
    
            public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
                char[] chars, int charIndex) {
                if (bytes == null || chars == null) {
                    throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                        Environment.GetResourceString("ArgumentNull_Array"));
                }
                if (byteIndex < 0 || byteCount < 0) {
                    throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                        Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }        
                if ( bytes.Length - byteIndex < byteCount)
                {
                    throw new ArgumentOutOfRangeException("bytes",
                        Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                }
                if (charIndex < 0 || charIndex > chars.Length) {
                    throw new ArgumentOutOfRangeException("charIndex", 
                        Environment.GetResourceString("ArgumentOutOfRange_Index"));
                }
                int result = 0;
                if (byteCount == 0) return result;
                if (lastByte >= 0) {
                    if (charIndex == chars.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                    temp[0] = (byte)lastByte;
                    temp[1] = bytes[byteIndex];
                    BytesToUnicodeNative(encoding.m_codePage, temp, 0, 2, chars, charIndex, 1);
                    byteIndex++;
                    byteCount--;
                    charIndex++;
                    lastByte = -1;
                    result = 1;
                    if (byteCount == 0) return result;
                }
                if (encoding.maxCharSize > 1) {
                    if ((GetEndLeadByteCount(bytes, byteIndex, byteCount) & 1) != 0) {
                        lastByte = bytes[byteIndex + --byteCount] & 0xFF;
                        if (byteCount == 0) return result;
                    }
                }
                if (charIndex == chars.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                int n = BytesToUnicodeNative(encoding.m_codePage, bytes, byteIndex, byteCount,
                    chars, charIndex, chars.Length - charIndex);
                if (n == 0) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                return result + n;
            }
    
            private int GetEndLeadByteCount(byte[] bytes, int index, int count) {
                int end = index + count;
                int i = end;
                while (i > index && IsDBCSLeadByteEx(encoding.m_codePage, bytes[i - 1])) i--;
                return end - i;
            }
        }
    
        [DllImport(Microsoft.Win32.Win32Native.KERNEL32, CharSet=CharSet.Auto),
         SuppressUnmanagedCodeSecurityAttribute()]
         private static extern bool IsDBCSLeadByteEx(int codePage, byte testChar);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int BytesToUnicodeNative(int codePage,
            byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex, int charCount);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int UnicodeToBytesNative(int codePage,
            char[] chars, int charIndex, int charCount,
                                                       byte[] bytes, int byteIndex, int byteCount/*, ref bool usedDefaultChar*/);
    	
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	internal static extern int GetCPMaxCharSizeNative(int codePage);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\tokenbasedset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// TokenBasedSet.cool
//
namespace System.Security.Util {
    using System;
    using System.Collections;

    [Serializable()] internal class TokenBasedSet
    {
        private Object[] m_objSet;
        private int      m_cElt;
        private int      m_initSize;
        private int      m_increment;
        private int      m_maxIndex;
    
        private const int DefaultSize      = 24;
        private const int DefaultIncrement = 8;
    
        public TokenBasedSet()
        
            : this(DefaultSize, DefaultIncrement) {
        }
    
        public TokenBasedSet(int initSize, int increment)
        {
            Reset(initSize, increment);
        }
    
        public TokenBasedSet(TokenBasedSet tbSet)
        {
            if (tbSet == null)
            {
                Reset(DefaultSize, DefaultIncrement);
                return;
            }
            
            m_objSet = new Object[tbSet.m_objSet.Length];
            System.Array.Copy(tbSet.m_objSet, 0, m_objSet, 0, tbSet.m_objSet.Length);
            
            m_cElt      = tbSet.m_cElt;
            m_initSize  = tbSet.m_initSize;
            m_increment = tbSet.m_increment;
            m_maxIndex  = tbSet.m_maxIndex;
        }
    
        public virtual void Reset()
        {
            Reset(m_initSize, m_increment);
        }
    
        public virtual void Reset(int initSize, int increment)
        {
            // NOTE: It doesn't hurt if increment is negative. By default
            // the array will expand in size just large enough to hold the
            // largest index.
            if (initSize < 0)
            {
                throw new System.ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            
            m_objSet = new Object[initSize];
            m_initSize = initSize;
            m_increment = increment;
            m_cElt = 0;
            m_maxIndex = -1;
        }
    
        public virtual void SetItem(int index, Object item)
        {
            EnsureSize(index+1);
            if (m_objSet[index] == null)
                m_cElt++;
            if (item == null) // just in case SetItem is used to remove
                m_cElt--;
            m_objSet[index] = item;
            
            // Adjust m_maxIndex if necessary...
            // If the new index is bigger and we've actually set
            // something, then adjust m_maxIndex to the new index.
            if (index > m_maxIndex && item != null)
                m_maxIndex = index;
            // Else check if we just removed the item at
            // the maxIndex.
            else if (index == m_maxIndex && item == null)
                ResetMaxIndex();
        }
    
        public virtual Object GetItem(int index)
        {
            if (index < m_objSet.Length)
                return m_objSet[index];
            else
                return null;
        }
    
        public virtual Object RemoveItem(int index)
        {
            Object ret = null;
            if (index < m_objSet.Length)
            {
                ret = m_objSet[index];
                m_objSet[index] = null;
                if (ret != null)
                {
                    m_cElt--;
                    ResetMaxIndex();
                }
            }
            return ret;
        }
        
        private void ResetMaxIndex()
        {
            int i;
    
            // Start at the end of the array, and
            // scan backwards for the first non-null
            // slot. That is the new maxIndex.
            for (i = m_objSet.Length - 1; i >= 0; i--)
            {
                if (m_objSet[i] != null)
                {
                    m_maxIndex = i;
                    break;
                }
            }
            
            // If we go past the beginning, then there must
            // be no elements.
            if (i < 0)
            {
                //ASSERT(m_cElt == 0);
                m_maxIndex = -1;
            }
            
            // Only shrink if the new slop at the end of the
            // array is greater than m_increment.
            if (m_objSet.Length - m_maxIndex > m_increment)
                ShrinkToFit();
        }
        
        public virtual void ShrinkToFit()
        {
            int fitSize = m_maxIndex + 1;
            //ASSERT(fitSize >= 0); // need at least a size of 0
            //ASSERT(fitSize <= m_objSet.Length);
            if (fitSize == m_objSet.Length) // already shrunk to fit.
                return;
            Object[] newSet = new Object[fitSize];
            System.Array.Copy(m_objSet, 0, newSet, 0, fitSize);
            m_objSet = newSet;
        }
    
        public virtual int GetCount()
        {
            return m_cElt;
        }
    
        public virtual int GetStorageLength()
        {
            return m_objSet.Length;
        }
        
        public virtual int GetMaxUsedIndex()
        {
            return m_maxIndex;
        }
    
        public virtual bool FastIsEmpty()
        {
            return m_cElt == 0;
        }

        public virtual bool IsEmpty()
        {
            if (m_cElt == 0)
                return true;

            IEnumerator enumerator = GetEnum();

            while (enumerator.MoveNext())
            {
                IPermission perm = enumerator.Current as IPermission;

                if (perm == null && enumerator.Current != null)
                    return false;

                if (!perm.IsSubsetOf( null ))
                    return false;
            }

            return true;
        }
    
        internal virtual void EnsureSize(int size)
        {
            if (size <= m_objSet.Length)
                return;
    
            if (size - m_objSet.Length < m_increment)
                size = m_objSet.Length + m_increment;
    
            Object[] newset = new Object[size];
            System.Array.Copy(m_objSet, 0, newset, 0, m_objSet.Length);
            m_objSet = newset;
        }
        
        public virtual IEnumerator GetEnum()
        {
            return (IEnumerator) new TokenBasedSetEnumerator(this);
        }

        public virtual bool IsSubsetOf( TokenBasedSet target )
        {
            if (target == null || target.FastIsEmpty())
                return this.IsEmpty();
            else
            {
                int minIndex = this.m_maxIndex;
                // An initial sign that this class has a Permission that the
                // target doesn't have is if this has a greater Token index.
                if (minIndex > target.m_maxIndex)
                    return false;
                
                for (int i = 0; i <= minIndex; i++)
                {
                    IPermission permThis = (IPermission)this.m_objSet[i];
                    IPermission permTarg = (IPermission)target.m_objSet[i];
                    
                    if (permThis == null)
                        continue;
                    else if (!permThis.IsSubsetOf(permTarg))
                        return this.IsEmpty();
                }
    
                return true;
            }
        }
        
        private void GenericIntersect( TokenBasedSet target, TokenBasedSet other )
        {
            // Note: Assumes target set is large enough and empty.
            int thisMaxIndex = this.m_maxIndex; 
            int otherMaxIndex = other != null ? other.m_maxIndex : 0;
            int minMaxIndex = thisMaxIndex < otherMaxIndex ? thisMaxIndex : otherMaxIndex;
            
            // We want to save any exceptions that occur and throw them at the end.
            Exception savedException = null;
            
            for (int i = 0; i <= minMaxIndex; i++)
            {
                try
                {
                    IPermission p1 = other != null ? (IPermission)other.m_objSet[i] : null;
                    IPermission p2 = (IPermission)this.m_objSet[i];
                    if (p1 != null && p2 != null)
                    {
                        target.SetItem( i, p1.Intersect(p2) );
                    }
                    else
                    {
                        target.SetItem( i, null );
                    }
                }
                catch (Exception e)
                {
                    if (savedException == null)
                        savedException = e;
                        
                    // Remove the permission from the intersection set
                    
                    target.SetItem( i, null );
                }
            }
            
            if (minMaxIndex == otherMaxIndex)
            {
                for (int i = otherMaxIndex+1; i <= target.m_maxIndex; ++i)
                {
                    target.RemoveItem( i );
                }
            }
            
            if (savedException != null)
                throw savedException;
        }
        
        
        public virtual void InplaceIntersect( TokenBasedSet other )
        {
            GenericIntersect( this, other );
        }
            
        public virtual TokenBasedSet Intersect( TokenBasedSet other )
        {
            int size = (this.m_maxIndex < other.m_maxIndex) ? this.m_maxIndex : other.m_maxIndex;
            TokenBasedSet set = new TokenBasedSet( size < 0 ? 0 : size , this.m_increment );
            GenericIntersect( set, other );
            return set;
        }
        
        private void GenericUnion( TokenBasedSet target, TokenBasedSet other, bool needToCopy )
        {
            // Note: Assumes target set is large enough and empty.
            
            // Get the max indicies
            int thisMaxIndex = this.m_maxIndex;
            int otherMaxIndex = other != null ? other.m_maxIndex : 0;
            int minMaxUsedIndex;
            int maxMaxUsedIndex;
            TokenBasedSet biggerSet;
            
            // We want to save any exceptions that occur and throw them at the end.
            Exception savedException = null;
            
            if (thisMaxIndex < otherMaxIndex)
            {
                minMaxUsedIndex = thisMaxIndex;
                maxMaxUsedIndex = otherMaxIndex;
                biggerSet = other;
            }
            else
            {
                minMaxUsedIndex = otherMaxIndex;
                maxMaxUsedIndex = thisMaxIndex;
                biggerSet = this;
            }
    
            IPermission p1;
            IPermission p2;
            int i;
            
            for (i = 0; i<=minMaxUsedIndex; ++i)
            {
                try
                {
                    p2 = other != null ? (IPermission)other.m_objSet[i] : null;
                    p1 = (IPermission)this.m_objSet[i];
                    if (p2 != null)
                    {
                        // we only need to do something is the other set has something in this slot
                        if (p1 == null)
                        {
                            // nothing in this set, so insert a copy.
                            if (needToCopy)
                            target.SetItem( i, p2.Copy() );
                            else
                                target.SetItem( i, p2 );
                        }
                        else
                        {
                            // both have it, so replace this's with the union.
                            target.SetItem( i, p1.Union( p2 ) );
                        }
                    }
                    else if (needToCopy)
                    {
                        if (p1 != null)
                            target.SetItem( i, p1.Copy() );
                        else
                            target.SetItem( i, null );
                    }
                    else
                    {
                        target.SetItem( i, p1 );
                    }
                }
                catch (Exception e)
                {
                    if (savedException == null)
                        savedException = e;
                }
            }
            
            for (i = minMaxUsedIndex+1; i <= maxMaxUsedIndex; ++i)
            {
                try
                {
                    if (needToCopy && biggerSet.m_objSet[i] != null)
                        target.SetItem( i, ((IPermission)biggerSet.m_objSet[i]).Copy() );
                    else
                        target.SetItem( i, biggerSet.m_objSet[i] );
                }
                catch (Exception e)
                {
                    if (savedException == null)
                        savedException = e;
                }
            }
            
            if (savedException != null)
                throw savedException;
        }
        
        public virtual void InplaceUnion( TokenBasedSet other )
        {
            GenericUnion( this, other, false );
        }
        
        public virtual TokenBasedSet Union( TokenBasedSet other )
        {
            int size;
            if (other != null)
                size = (this.m_maxIndex > other.m_maxIndex) ? this.m_maxIndex : other.m_maxIndex;
            else
                size = this.m_maxIndex;

            TokenBasedSet set = new TokenBasedSet( size < 0 ? 0 : size , this.m_increment );
            this.GenericUnion( set, other, true );
            return set;
        }
      
        internal virtual void MergeDeniedSet( TokenBasedSet denied )
        {
            if (denied == null)
                return;

            int minMaxIndex;
            if (this.m_maxIndex < denied.m_maxIndex)
            {
                minMaxIndex = this.m_maxIndex;
                for (int i = this.m_maxIndex + 1; i <= denied.m_maxIndex; ++i)
                {
                    denied.RemoveItem(i);
                }
            }
            else
            {  
                minMaxIndex = denied.m_maxIndex;
            }
        
            IPermission p1;
            IPermission p2;
    
            for (int i = 0; i<=minMaxIndex ; i++)
            {
                p1 = (IPermission)this.GetItem(i);
                p2 = (IPermission)denied.GetItem(i);
                
                if (p1 != null)
                {
                    if (p2 != null && p1.IsSubsetOf(p2))
                    {
                        // If the permission appears in both sets, we can remove it from both
                        // (i.e. now it's not granted instead of being denied)
                        this.RemoveItem(i);
                        denied.RemoveItem(i);
                    }
                }
                else if (p2 != null)
                {
                    // If we tried to deny it and it wasn't granted, just remove it from the denied set.
                    denied.RemoveItem(i); 
                }
            }
    
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\stringexpressionset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// StringExpressionSet
//
 
namespace System.Security.Util {    
    using System.Text;
    using System;
    using System.Collections;
    using System.Runtime.CompilerServices;
    using System.Globalization;

    [Serializable]
    internal class StringExpressionSet
    {
        protected static ArrayList m_emptyList = new ArrayList( 1 );
        
        protected ArrayList m_list;
        protected bool m_ignoreCase;
        protected String m_expressions;
        protected String[] m_expressionsArray;
        protected bool m_throwOnRelative;
        
        protected static readonly char[] m_separators = { ';' };
        protected static readonly char[] m_trimChars = { ' ' };
        protected static readonly char m_directorySeparator = '\\';
        protected static readonly char m_alternateDirectorySeparator = '/';
        
        public StringExpressionSet()
            : this( true, null, false )
        {
        }
        
        public StringExpressionSet( String str )
            : this( true, str, false )
        {
        }
        
        public StringExpressionSet( bool ignoreCase )
            : this( ignoreCase, null, false )
        {
        }
        
        public StringExpressionSet( bool ignoreCase, bool throwOnRelative )
            : this( ignoreCase, null, throwOnRelative )
        {
        }
        
        public StringExpressionSet( bool ignoreCase, String str )
            : this( ignoreCase, str, false )
        {
        }

        public StringExpressionSet( bool ignoreCase, String str, bool throwOnRelative )
        {
            m_list = null;
            m_ignoreCase = ignoreCase;
            m_throwOnRelative = throwOnRelative;
            if (str == null)
                m_expressions = null;
            else
            AddExpressions( str );
        }

        protected virtual StringExpressionSet CreateNewEmpty()
        {
            return new StringExpressionSet();
        }
        
        public virtual StringExpressionSet Copy()
        {
            StringExpressionSet copy = CreateNewEmpty();
            if (this.m_list != null)
                copy.m_list = new ArrayList( this.m_list );
            copy.m_expressions = this.m_expressions;
            copy.m_ignoreCase = this.m_ignoreCase;
            copy.m_throwOnRelative = this.m_throwOnRelative;
            return copy;
        }
        
        public void SetIgnoreCase( bool ignoreCase )
        {
            this.m_ignoreCase = ignoreCase;
        }
        
        public void SetThrowOnRelative( bool throwOnRelative )
        {
            this.m_throwOnRelative = throwOnRelative;
        }

        public void SetExpressions( String str )
        {
            m_list = null;
            AddExpressions( str );
        }

        protected virtual String ProcessWholeString( String str )
        {
            return str.Replace( m_alternateDirectorySeparator, m_directorySeparator );
        }

        protected virtual String ProcessSingleString( String str )
        {
            return str.Trim( m_trimChars );
        }
        
        public void AddExpressions( String str )
        {
            if (str == null)
            {
                throw new ArgumentNullException( "str" );
            }

            str = ProcessWholeString( str );
           
            if (m_expressions == null)
            {
                m_expressions = str;
            }
            else
            {
                m_expressions = m_expressions + m_separators[0] + str;
            }

            m_expressionsArray = null;
            
            if (m_list != null || m_throwOnRelative)
            {
                String[] arystr = Split( str );
            
                m_list = new ArrayList();
            
                for (int index = 0; index < arystr.Length; ++index)
                {
                    if (arystr[index] != null && !arystr[index].Equals( "" ))
                    {
                        String temp = ProcessSingleString( arystr[index] );
                        int indexOfNull = temp.IndexOf( '\0' );

                        if (indexOfNull != -1)
                            temp = temp.Substring( 0, indexOfNull );
    
                        if (temp != null && !temp.Equals( "" ))
                        {
                            if (m_throwOnRelative)
                            {
                                if (!((temp.Length >= 3 && temp[1] == ':' && temp[2] == '\\' && 
                                       ((temp[0] >= 'a' && temp[0] <= 'z') || (temp[0] >= 'A' && temp[0] <= 'Z'))) ||
                                      (temp.Length >= 2 && temp[0] == '\\' && temp[1] == '\\')))
                                {
                                    throw new ArgumentException( Environment.GetResourceString( "Argument_AbsolutePathRequired" ) );
                                }

                                temp = CanonicalizePath( temp );
                            }

                            m_list.Add( temp );
                        }
                    }
                }
                
                Reduce();
           }
                
        }

        public void AddExpressions( String[] str )
        {
            AddExpressions( str, true, true );
        }

        public void AddExpressions( String[] str, bool checkForDuplicates, bool needFullPath )
        {
            BCLDebug.Assert( m_throwOnRelative, "This should only be called when throw on relative is set" );

            if (str == null)
            {
                throw new ArgumentNullException( "str" );
            }

            m_expressionsArray = null;
            m_expressions = null;

            String[] expressionsArray = new String[str.Length];

            if (m_list == null)
                m_list = new ArrayList();
        
            for (int index = 0; index < expressionsArray.Length; ++index)
            {
                if (str[index] == null)
                    throw new ArgumentNullException( "str" );

                expressionsArray[index] = ProcessWholeString( str[index] );

                if (expressionsArray[index] != null && !expressionsArray[index].Equals( "" ))
                {
                    String temp = ProcessSingleString( expressionsArray[index] );

                    int indexOfNull = temp.IndexOf( '\0' );

                    if (indexOfNull != -1)
                        temp = temp.Substring( 0, indexOfNull );

                    if (temp != null && !temp.Equals( "" ))
                    {
                        if (m_throwOnRelative)
                        {
                            if (!((temp.Length >= 3 && temp[1] == ':' && temp[2] == '\\' && 
                                   ((temp[0] >= 'a' && temp[0] <= 'z') || (temp[0] >= 'A' && temp[0] <= 'Z'))) ||
                                  (temp.Length >= 2 && temp[0] == '\\' && temp[1] == '\\')))
                            {
                                throw new ArgumentException( Environment.GetResourceString( "Argument_AbsolutePathRequired" ) );
                            }

                            temp = CanonicalizePath( temp, needFullPath );

                        }

                        m_list.Add( temp );
                    }
                }
            }
            
            if (checkForDuplicates)
                Reduce();
                
        }
            
        protected void CheckList()
        {
            if (m_list == null && m_expressions != null)
            {
                CreateList();
            }
        }
        
        protected String[] Split( String expressions )
        {
            if (m_throwOnRelative)
            {
                ArrayList tempList = new ArrayList();

                String[] quoteSplit = expressions.Split( '\"' );

                for (int i = 0; i < quoteSplit.Length; ++i)
                {
                    if (i % 2 == 0)
                    {
                        String[] semiSplit = quoteSplit[i].Split( ';' );

                        for (int j = 0; j < semiSplit.Length; ++j)
                        {
                            if (semiSplit[j] != null && !semiSplit[j].Equals( "" ))
                                tempList.Add( semiSplit[j] );
                        }
                    }
                    else
                    {
                        tempList.Add( quoteSplit[i] );
                    }
                }

                String[] finalArray = new String[tempList.Count];

                IEnumerator enumerator = tempList.GetEnumerator();

                int index = 0;
                while (enumerator.MoveNext())
                {
                    finalArray[index++] = (String)enumerator.Current;
                }

                return finalArray;
            }
            else
            {
                return expressions.Split( m_separators );
            }
        }

        
        protected void CreateList()
        {
            String[] expressionsArray = Split( m_expressions );
            
            m_list = new ArrayList();
            
            for (int index = 0; index < expressionsArray.Length; ++index)
            {
                if (expressionsArray[index] != null && !expressionsArray[index].Equals( "" ))
                {
                    String temp = ProcessSingleString( expressionsArray[index] );

                    int indexOfNull = temp.IndexOf( '\0' );

                    if (indexOfNull != -1)
                        temp = temp.Substring( 0, indexOfNull );

                    if (temp != null && !temp.Equals( "" ))
                    {
                        if (m_throwOnRelative)
                        {
                            if (!((temp.Length >= 3 && temp[1] == ':' && temp[2] == '\\' && 
                                   ((temp[0] >= 'a' && temp[0] <= 'z') || (temp[0] >= 'A' && temp[0] <= 'Z'))) ||
                                  (temp.Length >= 2 && temp[0] == '\\' && temp[1] == '\\')))
                            {
                                throw new ArgumentException( Environment.GetResourceString( "Argument_AbsolutePathRequired" ) );
                            }

                            temp = CanonicalizePath( temp );
                        }
                        
                        m_list.Add( temp );
                    }
                }
            }
        }
        
        public bool IsEmpty()
        {
            if (m_list == null)
            {
                return m_expressions == null;
            }
            else
            {
                return m_list.Count == 0;
            }
        }
        
        public bool IsSubsetOf( StringExpressionSet ses )
        {
            if (this.IsEmpty())
                return true;
            
            if (ses == null || ses.IsEmpty())
                return false;
            
            CheckList();
            ses.CheckList();
            
            for (int index = 0; index < this.m_list.Count; ++index)
            {
                if (!StringSubsetStringExpression( (String)this.m_list[index], ses, m_ignoreCase ))
                {
                    return false;
                }
            }
            return true;
        }
        
        public bool IsSubsetOfPathDiscovery( StringExpressionSet ses )
        {
            if (this.IsEmpty())
                return true;
            
            if (ses == null || ses.IsEmpty())
                return false;
            
            CheckList();
            ses.CheckList();
            
            for (int index = 0; index < this.m_list.Count; ++index)
            {
                if (!StringSubsetStringExpressionPathDiscovery( (String)this.m_list[index], ses, m_ignoreCase ))
                {
                    return false;
                }
            }
            return true;
        }

        
        public StringExpressionSet Union( StringExpressionSet ses )
        {
            // If either set is empty, the union represents a copy of the other.
            
            if (ses == null || ses.IsEmpty())
                return this.Copy();
    
            if (this.IsEmpty())
                return ses.Copy();
            
            CheckList();
            ses.CheckList();
            
            // Perform the union
            // note: insert smaller set into bigger set to reduce needed comparisons
            
            StringExpressionSet bigger = ses.m_list.Count > this.m_list.Count ? ses : this;
            StringExpressionSet smaller = ses.m_list.Count <= this.m_list.Count ? ses : this;
    
            StringExpressionSet unionSet = bigger.Copy();
            
            unionSet.Reduce();
            
            for (int index = 0; index < smaller.m_list.Count; ++index)
            {
                unionSet.AddSingleExpressionNoDuplicates( (String)smaller.m_list[index] );
            }
            
            unionSet.GenerateString();
            
            return unionSet;
        }
            
        
        public StringExpressionSet Intersect( StringExpressionSet ses )
        {
            // If either set is empty, the intersection is empty
            
            if (this.IsEmpty() || ses == null || ses.IsEmpty())
                return CreateNewEmpty();
            
            CheckList();
            ses.CheckList();
            
            // Do the intersection for real
            
            StringExpressionSet intersectSet = CreateNewEmpty();
            
            for (int this_index = 0; this_index < this.m_list.Count; ++this_index)
            {
                for (int ses_index = 0; ses_index < ses.m_list.Count; ++ses_index)
                {
                    if (StringSubsetString( (String)this.m_list[this_index], (String)ses.m_list[ses_index], m_ignoreCase ))
                    {
                        if (intersectSet.m_list == null)
                        {
                            intersectSet.m_list = new ArrayList();
                        }
                        intersectSet.AddSingleExpressionNoDuplicates( (String)this.m_list[this_index] );
                    }
                    else if (StringSubsetString( (String)ses.m_list[ses_index], (String)this.m_list[this_index], m_ignoreCase ))
                    {
                        if (intersectSet.m_list == null)
                        {
                            intersectSet.m_list = new ArrayList();
                        }
                        intersectSet.AddSingleExpressionNoDuplicates( (String)ses.m_list[ses_index] );
                    }
                }
            }
            
            intersectSet.GenerateString();
            
            return intersectSet;
        }
        
        protected void GenerateString()
        {
            if (m_list != null)
            {
                StringBuilder sb = new StringBuilder();
            
                IEnumerator enumerator = this.m_list.GetEnumerator();
                bool first = true;
            
                while (enumerator.MoveNext())
                {
                    if (!first)
                        sb.Append( m_separators[0] );
                    else
                        first = false;
                            
                    String currentString = (String)enumerator.Current;
                    int indexOfSeparator = currentString.IndexOf( m_separators[0] );

                    if (indexOfSeparator != -1)
                        sb.Append( '\"' );

                    sb.Append( currentString );

                    if (indexOfSeparator != -1)
                        sb.Append( '\"' );
                }
            
                m_expressions = sb.ToString();
            }
            else
            {
                m_expressions = null;
            }
        }            
        
        public override String ToString()
        {
            CheckList();
        
            Reduce();
        
            GenerateString();
                            
            return m_expressions;
        }

        public String[] ToStringArray()
        {
            if (m_expressionsArray == null && m_list != null)
            {
                m_expressionsArray = new String[m_list.Count];

                IEnumerator enumerator = m_list.GetEnumerator();

                int count = 0;
                while (enumerator.MoveNext())
                {
                    m_expressionsArray[count++] = (String)enumerator.Current;
                }
            }

            return m_expressionsArray;
        }
                
        
        //-------------------------------
        // protected static helper functions
        //-------------------------------
        
        
        protected bool StringSubsetStringExpression( String left, StringExpressionSet right, bool ignoreCase )
        {
            for (int index = 0; index < right.m_list.Count; ++index)
            {
                if (StringSubsetString( left, (String)right.m_list[index], ignoreCase ))
                {
                    return true;
                }
            }
            return false;
        }
        
        protected static bool StringSubsetStringExpressionPathDiscovery( String left, StringExpressionSet right, bool ignoreCase )
        {
            for (int index = 0; index < right.m_list.Count; ++index)
            {
                if (StringSubsetStringPathDiscovery( left, (String)right.m_list[index], ignoreCase ))
                {
                    return true;
                }
            }
            return false;
        }

        
        protected virtual bool StringSubsetString( String left, String right, bool ignoreCase )
        {
            if (right == null || left == null || right.Length == 0 || left.Length == 0 ||
                right.Length > left.Length)
            {
                return false;
            }
            else if (right.Length == left.Length)
            {
                // if they are equal in length, just do a normal compare
                return String.Compare( right, left, ignoreCase, CultureInfo.InvariantCulture) == 0;
            }
            else if (left.Length - right.Length == 1 && left[left.Length-1] == m_directorySeparator)
            {
                return String.Compare( left, 0, right, 0, right.Length, ignoreCase, CultureInfo.InvariantCulture) == 0;
            }
            else if (right[right.Length-1] == m_directorySeparator)
            {
                // right is definitely a directory, just do a substring compare
                return String.Compare( right, 0, left, 0, right.Length-1, ignoreCase, CultureInfo.InvariantCulture) == 0;
            }
            else if (left[right.Length] == m_directorySeparator)
            {
                // left is hinting at being a subdirectory on right, do substring compare to make find out
                return String.Compare( right, 0, left, 0, right.Length, ignoreCase, CultureInfo.InvariantCulture ) == 0;
            }
            else
            {
                return false;
            }
        }

        protected static bool StringSubsetStringPathDiscovery( String left, String right, bool ignoreCase )
        {
            if (right == null || left == null || right.Length == 0 || left.Length == 0)
            {
                return false;
            }
            else if (right.Length == left.Length)
            {
                // if they are equal in length, just do a normal compare
                return String.Compare( right, left, ignoreCase, CultureInfo.InvariantCulture) == 0;
            }
            else
            {
                String shortString, longString;

                if (right.Length < left.Length)
                {
                    shortString = right;
                    longString = left;
                }
                else
                {
                    shortString = left;
                    longString = right;
                }

                if (String.Compare( shortString, 0, longString, 0, shortString.Length, ignoreCase, CultureInfo.InvariantCulture) != 0)
                {
                    return false;
                }

                if (shortString.Length == 3 &&
                    shortString.EndsWith( ":\\" ) &&
                    ((shortString[0] >= 'A' && shortString[0] <= 'Z') ||
                     (shortString[0] >= 'a' && shortString[0] <= 'z')))
                     return true;

                return longString[shortString.Length] == m_directorySeparator;
            }
        }

        
        //-------------------------------
        // protected helper functions
        //-------------------------------
        
        protected void AddSingleExpressionNoDuplicates( String expression )
        {
            int index = 0;
            
            m_expressionsArray = null;
            m_expressions = null;

            if (this.m_list == null)
                this.m_list = new ArrayList();

            while (index < this.m_list.Count)
            {
                if (StringSubsetString( (String)this.m_list[index], expression, m_ignoreCase ))
                {
                    this.m_list.RemoveAt( index );
                }
                else if (StringSubsetString( expression, (String)this.m_list[index], m_ignoreCase ))
                {
                    return;
                }
                else
                {
                    index++;
                }
            }
            this.m_list.Add( expression );
        }
    
        protected void Reduce()
        {
            CheckList();
            
            if (this.m_list == null)
                return;
            
            int j;

            for (int i = 0; i < this.m_list.Count - 1; i++)
            {
                j = i + 1;
                
                while (j < this.m_list.Count)
                {
                    if (StringSubsetString( (String)this.m_list[j], (String)this.m_list[i], m_ignoreCase ))
                    {
                        this.m_list.RemoveAt( j );
                    }
                    else if (StringSubsetString( (String)this.m_list[i], (String)this.m_list[j], m_ignoreCase ))
                    {
                        // write the value at j into position i, delete the value at position j and keep going.
                        this.m_list[i] = this.m_list[j];
                        this.m_list.RemoveAt( j );
                        j = i + 1;
                    }
                    else
                    {
                        j++;
                    }
                }
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetLongPathName( String path );

        internal static String CanonicalizePath( String path )
        {
            return CanonicalizePath( path, true );
        }

        internal static String CanonicalizePath( String path, bool needFullPath )
        {
            if (path.IndexOf( '~' ) != -1)
                path = GetLongPathName( path );

            if (path.IndexOf( ':', 2 ) != -1)
                throw new NotSupportedException( Environment.GetResourceString( "Argument_PathFormatNotSupported" ) );

            if (needFullPath)
            {
                String newPath = System.IO.Path.GetFullPathInternal( path );
                if (path.EndsWith( "\\." ))
                {
                    if (newPath.EndsWith( "\\" ))
                    {
                        newPath += ".";
                    }
                    else
                    {
                        newPath += "\\.";
                    }
                }
                return newPath;
            }
            else
                return path;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\xmlutil.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** CLASS:    XMLUtil
**
** AUTHOR:   Brian Beckman (brianbec)
**
** PURPOSE:  Helpers for XML input & output
**
** SYNOPSIS: XMLTree NewPermissionTypeTree (IPermission that )
**           Element ElmAddStateDataToTree  (XMLTree     eTree)
**           void    AddParamToStateData    (Element eStateData,
**                                           String  parmName,
**                                           Object  parmValue)
** DATE:     19 Sep 1998
** 
===========================================================*/
namespace System.Security.Util  {
    
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Policy;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Activation;
    using System.IO;
    using System.Text;
    using System.Runtime.CompilerServices;
    using PermissionState = System.Security.Permissions.PermissionState;
    using BindingFlags = System.Reflection.BindingFlags;
    using Assembly = System.Reflection.Assembly;
    using System.Threading;

    internal class XMLUtil
    {
        //
        // Warning: Element constructors have side-effects on their
        //          third argument.
        //
        
        private const String BuiltInPermission = "System.Security.Permissions.";
        private const int BuiltInPermissionLength = 28;
        private const String BuiltInMembershipCondition = "System.Security.Policy.";
        private const int BuiltInMembershipConditionLength = 23;
        private const String BuiltInCodeGroup = "System.Security.Policy.";
        private const int BuiltInCodeGroupLength = 23;
        
        private static String s_mscorlibName = null;
  
        public static SecurityElement
        NewPermissionElement (IPermission ip)
        {
            return NewPermissionElement (ip.GetType ().FullName) ;
        }
        
        public static SecurityElement
        NewPermissionElement (String name)
        {
            SecurityElement ecr = new SecurityElement( "Permission" );
            ecr.AddAttribute( "class", name );
            return ecr;
        }
        
        public static void
        AddClassAttribute( SecurityElement element, Type type )
        {
            // Replace any quotes with apostrophes so that we can include quoted materials
            // within classnames.  Notably the assembly name member 'loc' uses a quoted string.
        
            // NOTE: this makes assumptions as to what reflection is expecting for a type string
            // it will need to be updated if reflection changes what it wants.
        
            element.AddAttribute( "class", type.FullName + ", " + type.Module.Assembly.FullName.Replace( '\"', '\'' ) );
        }
        
        private static void CreateMscorlibName()
        {
            // NOTE: this makes certain assumptions about how AssemblyName.ToString() formats
            // it's output.  If AssemblyName.ToString() changes, this will have to as well.
            
            Assembly mscorlibAssembly = Assembly.GetExecutingAssembly();
                
            s_mscorlibName = mscorlibAssembly.nGetSimpleName();
            
#if _DEBUG
            String mscorlibAssemblyName = mscorlibAssembly.FullName;
            BCLDebug.Assert( mscorlibAssemblyName != null &&
                             mscorlibAssemblyName.Length >= s_mscorlibName.Length &&
                             mscorlibAssemblyName.Substring( 0, s_mscorlibName.Length ).Equals( s_mscorlibName ),
                             "AssemblyName.ToString() changed format" );
#endif                                         
        }
        
        
        private static bool
        ParseElementForObjectCreation( SecurityElement el,
                                       String requiredNamespace,
                                       int requiredNamespaceLength,
                                       String requiredAssembly,
                                       out String className,
                                       out int classNameLength )
        {
            className = null;
            classNameLength = 0;

            String fullClassName = el.Attribute( "class" );
            
            if (fullClassName == null)
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_NoClass" ) );
            }
            
            fullClassName = fullClassName.Replace( '\'', '\"' );
            
            int commaIndex = fullClassName.IndexOf( ',' );
            int namespaceClassNameLength;
            
            // If the classname is tagged with assembly information, find where
            // the assembly information begins.
            
            if (commaIndex == -1)
            {
                namespaceClassNameLength = fullClassName.Length;
            }
            else
            {
                namespaceClassNameLength = commaIndex;
            }
            

            // Only if the length of the class name is greater than the namespace info
            // on our requiredNamespace do we continue
            // with our check.
            
            if (namespaceClassNameLength > requiredNamespaceLength)
            {
                // If we have assembly info, make sure it is in the required assembly
            
                int requiredAssemblyLength = requiredAssembly.Length;
            
                if (commaIndex != -1 && fullClassName.Length > (namespaceClassNameLength + 2 + requiredAssemblyLength))
                {
                    if (!fullClassName.Substring( namespaceClassNameLength + 2, requiredAssemblyLength ).Equals( requiredAssembly ))
                    {
                        return false;
                    }
                }
            
                // Make sure we are in the required namespace.
            
                String classNameHeader = fullClassName.Substring( 0, requiredNamespaceLength );
                
                if (classNameHeader.Equals( requiredNamespace ))
                {
                    classNameLength = namespaceClassNameLength - requiredNamespaceLength;
                    className = fullClassName.Substring( requiredNamespaceLength, classNameLength );
                    return true;
                }
            }
            
            return false;
        }
        
        public static IPermission
        CreatePermission (SecurityElement el)
        {
            return CreatePermission( el, false );
        }

        public static IPermission
        CreatePermission (SecurityElement el, bool safeLoad)
        {
            bool assemblyIsLoading;

            return CreatePermission( el, safeLoad, false, out assemblyIsLoading );
        }

        public static IPermission
        CreatePermission (SecurityElement el, bool safeLoad, bool policyLoad, out bool assemblyIsLoading)
        {
            assemblyIsLoading = false;

            if (el == null || !(el.Tag.Equals("Permission") || el.Tag.Equals("IPermission")) )
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_WrongElementType" ), "<Permission>" ) ) ;
    
            String className;
            int classNameLength;
            
            if (s_mscorlibName == null)
            {
                CreateMscorlibName();
            }
            
            if (!ParseElementForObjectCreation( el,
                                                BuiltInPermission,
                                                BuiltInPermissionLength,
                                                s_mscorlibName,
                                                out className,
                                                out classNameLength ))
            {
                goto USEREFLECTION;
            }
                                              
            // We have a built in permission, figure out which it is.
                    
            // Here's the list of built in permissions as of 1/28/2000
            // UIPermission
            // FileIOPermission
            // RegistryPermission
            // SecurityPermission
            // PrincipalPermission
            // ReflectionPermission
            // FileDialogPermission
            // EnvironmentPermission
            // SiteIdentityPermission
            // ZoneIdentityPermission
            // PublisherIdentityPermission
            // StrongNameIdentityPermission
            // IsolatedStorageFilePermission
                    
            switch (classNameLength)
            {
                case 12:
                    // UIPermission
                    if (className.Equals( "UIPermission" ))
                        return new UIPermission( PermissionState.None );
                    else
                        goto USEREFLECTION;
                                
                case 16:
                    // FileIOPermission
                    if (className.Equals( "FileIOPermission" ))
                        return new FileIOPermission( PermissionState.None );
                    else
                        goto USEREFLECTION;
                            
                case 18:
                    // RegistryPermission
                    // SecurityPermission
                    if (className[0] == 'R')
                    {
                        if (className.Equals( "RegistryPermission" ))
                            return new RegistryPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }
                    else
                    {
                        if (className.Equals( "SecurityPermission" ))
                            return new SecurityPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }
                            
                case 19:
                    // PrincipalPermission
                    if (className.Equals( "PrincipalPermission" ))
                        return new PrincipalPermission( PermissionState.None );
                    else
                        goto USEREFLECTION;
                            
                case 20:
                    // ReflectionPermission
                    // FileDialogPermission
                    if (className[0] == 'R')
                    {
                        if (className.Equals( "ReflectionPermission" ))
                            return new ReflectionPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }
                    else
                    {
                        if (className.Equals( "FileDialogPermission" ))
                            return new FileDialogPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }

                case 21:
                    // EnvironmentPermission
                    // UrlIdentityPermission
                    if (className[0] == 'E')
                    {
                        if (className.Equals( "EnvironmentPermission" ))
                            return new EnvironmentPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }
                    else
                    {
                        if (className.Equals( "UrlIdentityPermission" ))
                            return new UrlIdentityPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }
                            
                case 22:
                    // SiteIdentityPermission
                    // ZoneIdentityPermission
                    if (className[0] == 'S')
                    {
                        if (className.Equals( "SiteIdentityPermission" ))
                            return new SiteIdentityPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }
                    else
                    {
                        if (className.Equals( "ZoneIdentityPermission" ))
                            return new ZoneIdentityPermission( PermissionState.None );
                        else
                            goto USEREFLECTION;
                    }
                            
                case 27:
                    // PublisherIdentityPermission
                    if (className.Equals( "PublisherIdentityPermission" ))
                        return new PublisherIdentityPermission( PermissionState.None );
                    else
                        goto USEREFLECTION;
                            
                case 28:
                    // StrongNameIdentityPermission
                    if (className.Equals( "StrongNameIdentityPermission" ))
                        return new StrongNameIdentityPermission( PermissionState.None );
                    else
                        goto USEREFLECTION;
                            
                case 29:
                    // IsolatedStorageFilePermission
                    if (className.Equals( "IsolatedStorageFilePermission" ))
                        return new IsolatedStorageFilePermission( PermissionState.None );
                    else
                        goto USEREFLECTION;
                            
                default:
                    goto USEREFLECTION;
            }
    
USEREFLECTION:
            PermissionSet.s_fullTrust.Assert();
            Object[] objs = new Object[1];
            objs[0] = PermissionState.None;

            Type permClass = null;
            IPermission perm = null;

            permClass = GetClassFromElement (el, safeLoad, policyLoad, out assemblyIsLoading) ;
            if (permClass == null)
                return null;

            if (permClass.GetInterface( "System.Security.IPermission" ) == null)
                return null;

            perm = (IPermission) Activator.CreateInstance(permClass, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public, null, objs, null );
            //permClass.Module.Assembly.nForceResolve();

            return perm;
        }
        
        public static CodeGroup
        CreateCodeGroup (SecurityElement el)
        {
            return CreateCodeGroup( el, false );
        }

        public static CodeGroup
        CreateCodeGroup (SecurityElement el, bool safeLoad)
        {
            if (el == null || !el.Tag.Equals("CodeGroup"))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_WrongElementType" ), "<CodeGroup>" ) ) ;
    
            String className;
            int classNameLength;
            
            if (s_mscorlibName == null)
            {
                CreateMscorlibName();
            }
            
            if (!ParseElementForObjectCreation( el,
                                                BuiltInCodeGroup,
                                                BuiltInCodeGroupLength,
                                                s_mscorlibName,
                                                out className,
                                                out classNameLength ))
            {
                goto USEREFLECTION;
            }
    
            switch (classNameLength)
            {
                case 12:
                    // NetCodeGroup
                    if (className.Equals( "NetCodeGroup" ))
                        return new NetCodeGroup();
                    else
                        goto USEREFLECTION;

                case 13:
                    // FileCodeGroup
                    if (className.Equals( "FileCodeGroup" ))
                        return new FileCodeGroup();
                    else
                        goto USEREFLECTION;
                case 14:
                    // UnionCodeGroup
                    if (className.Equals( "UnionCodeGroup" ))
                        return new UnionCodeGroup();
                    else
                        goto USEREFLECTION;
                                
                case 19:
                    // FirstMatchCodeGroup
                    if (className.Equals( "FirstMatchCodeGroup" ))
                        return new FirstMatchCodeGroup();
                    else
                        goto USEREFLECTION;
                default:
                    goto USEREFLECTION;
            }
    
USEREFLECTION: 
            PermissionSet.s_fullTrust.Assert();
            Type groupClass = null;
            CodeGroup group = null;

            groupClass = GetClassFromElement (el, safeLoad) ;
            if (groupClass == null)
                return null;

            group = (CodeGroup) Activator.CreateInstance(groupClass);

            groupClass.Module.Assembly.nForceResolve();

            return group;

        }
        
        
        internal static IMembershipCondition
        CreateMembershipCondition( SecurityElement el )
        {
            return CreateMembershipCondition( el, false );
        }

        internal static IMembershipCondition
        CreateMembershipCondition( SecurityElement el, bool safeLoad )
        {
            if (el == null || !el.Tag.Equals("IMembershipCondition"))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_WrongElementType" ), "<IMembershipCondition>" ) ) ;
    
            String className;
            int classNameLength;
            
            if (s_mscorlibName == null)
            {
                CreateMscorlibName();
            }
            
            if (!ParseElementForObjectCreation( el,
                                                BuiltInMembershipCondition,
                                                BuiltInMembershipConditionLength,
                                                s_mscorlibName,
                                                out className,
                                                out classNameLength ))
            {
                goto USEREFLECTION;
            }

            // We have a built in membership condition, figure out which it is.
                    
            // Here's the list of built in membership conditions as of 2/16/2000
            // System.Security.Policy.AllMembershipCondition
            // System.Security.Policy.URLMembershipCondition
            // System.Security.Policy.SHA1MembershipCondition
            // System.Security.Policy.SiteMembershipCondition
            // System.Security.Policy.ZoneMembershipCondition                                                                                                                                                              
            // System.Security.Policy.PublisherMembershipCondition
            // System.Security.Policy.StrongNameMembershipCondition
            // System.Security.Policy.ApplicationDirectoryMembershipCondition
                    
            switch (classNameLength)
            {
                case 22:
                    // AllMembershipCondition
                    // URLMembershipCondition
                    if (className[0] == 'A')
                    {
                        if (className.Equals( "AllMembershipCondition" ))
                            return new AllMembershipCondition();
                        else
                            goto USEREFLECTION;
                    }
                    else
                    {
                        if (className.Equals( "UrlMembershipCondition" ))
                            return new UrlMembershipCondition();
                        else
                            goto USEREFLECTION;
                    }
                                
                case 23:
                    // HashMembershipCondition
                    // SiteMembershipCondition
                    // ZoneMembershipCondition                                                                                                                                                              
                    if (className[0] == 'H')
                    {
                        if (className.Equals( "HashMembershipCondition" ))
                            return new HashMembershipCondition();
                        else
                            goto USEREFLECTION;
                    }
                    else if (className[0] == 'S')
                    {
                        if (className.Equals( "SiteMembershipCondition" ))
                            return new SiteMembershipCondition();
                        else
                            goto USEREFLECTION;
                    }
                    else
                    {
                        if (className.Equals( "ZoneMembershipCondition" ))
                            return new ZoneMembershipCondition();
                        else
                            goto USEREFLECTION;
                    }
                            
                case 28:
                    // PublisherMembershipCondition
                    if (className.Equals( "PublisherMembershipCondition" ))
                        return new PublisherMembershipCondition();
                    else
                        goto USEREFLECTION;
                            
                case 29:
                    // StrongNameMembershipCondition
                    if (className.Equals( "StrongNameMembershipCondition" ))
                        return new StrongNameMembershipCondition();
                    else
                        goto USEREFLECTION;
                            
                case 39:
                    // ApplicationDirectoryMembershipCondition
                    if (className.Equals( "ApplicationDirectoryMembershipCondition" ))
                        return new ApplicationDirectoryMembershipCondition();
                    else
                        goto USEREFLECTION;
                            
                default:
                    goto USEREFLECTION;
            }
    
USEREFLECTION:
            PermissionSet.s_fullTrust.Assert();
            Type condClass = null;
            IMembershipCondition cond = null;
    
            condClass = GetClassFromElement (el, safeLoad) ;
            if (condClass == null)
                return null;

            cond = (IMembershipCondition) Activator.CreateInstance(condClass);
            condClass.Module.Assembly.nForceResolve();

            return cond;

        }
                    
        
        internal static Type
        GetClassFromElement (SecurityElement el)
        {
            return GetClassFromElement( el, false );
        }

        internal static Type
        GetClassFromElement (SecurityElement el, bool safeLoad )
        {
            bool assemblyIsLoading;

            return GetClassFromElement( el, safeLoad, false, out assemblyIsLoading );
        }

        internal static Type
        GetClassFromElement (SecurityElement el, bool safeLoad, bool policyLoad, out bool assemblyIsLoading )
        {
            assemblyIsLoading = false;
            String className = el.Attribute( "class" );

            if (className == null)
                return null;

            try
            {
                if (safeLoad)
                {
                    return RuntimeType.GetTypeInternal(className, false, false, true);
                }
                else if (policyLoad)
                {
                    StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;

                    assemblyIsLoading = true;
                    return RuntimeType.GetTypeImpl( className.Trim().Replace( '\'', '\"' ),
                                                    false,
                                                    false, ref stackMark,
                                                    ref assemblyIsLoading );
                }
                else
                {
                    return RuntimeType.GetTypeInternal( className.Trim().Replace( '\'', '\"' ), false, false, true );
                }
            }
            catch (SecurityException)
            {
                return null;
            }
        }

        public static bool
        IsPermissionElement (IPermission ip,
                             SecurityElement el)
        {
            if (!el.Tag.Equals ("Permission") && !el.Tag.Equals ("IPermission"))
                return false;
                
            return true;
        }
        
        public static bool
        IsUnrestricted (SecurityElement el)
        {
            String sUnrestricted = el.Attribute( "Unrestricted" );
            
            if (sUnrestricted == null)
                return false;

            return sUnrestricted.Equals( "true" ) || sUnrestricted.Equals( "TRUE" ) || sUnrestricted.Equals( "True" );
        }


        public static String BitFieldEnumToString( Type type, Object value )
        {
            int iValue = (int)value;

            if (iValue == 0)
                return Enum.GetName( type, 0 );

            StringBuilder result = new StringBuilder();
            bool first = true;
            int flag = 0x1;

            for (int i = 1; i < 32; ++i)
            {
                if ((flag & iValue) != 0)
                {
                    String sFlag = Enum.GetName( type, flag );

                    if (sFlag == null)
                        continue;

                    if (!first)
                    {
                        result.Append( ", " );
                    }

                    result.Append( sFlag );
                    first = false;
                }

                flag = flag << 1;
            }
            
            return result.ToString();
        } 

        public static void AddParamToStateData( SecurityElement esd,
                                                String tag,
                                                Object text )
        {
            if (text is String)
            {
                String strText = (String)text;
            
                if (strText.Equals( "True" ))
                {
                    esd.AddChild( new SecurityElement( tag ) );
                }
                else
                {
                    esd.AddChild( new SecurityElement( tag, strText ) );
                }
            }
            else
            {
                esd.AddChild( new SecurityElement( tag, text.ToString() ) );
            }
        }

        public static SecurityElement GetElementFromUnicodeByteArray (byte[] b)
        {
            MemoryStream ms = new MemoryStream(b);
            BinaryReader input = new BinaryReader(ms, Encoding.Unicode);
            return new Parser(input).GetTopElement();
        }
        
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\util\urlstring.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//depot/urt/main/clr/src/BCL/System/Security/Util/URLString.cs#21 - edit change 61428 (text)
//  URLString
//
//  Implementation of membership condition for zones
//

namespace System.Security.Util {
    
    using System;
    using System.Collections;
    using System.Runtime.CompilerServices;
    using System.Globalization;
    
    [Serializable]
    internal class URLString : SiteString
    {
        private String m_protocol;
        private SiteString m_siteString;
        private int m_port;
        private LocalSiteString m_localSite;
        private DirectoryString m_directory;
        private String m_fullurl;
        
        private const String m_defaultProtocol = "file";
        private static readonly char[] m_siteEnd = new char[] { ':', '/' };
        private static readonly char[] m_fileEnd = new char[] { '/', '\\' };
        
        public URLString()
        {
            m_protocol = "";
            m_siteString = new SiteString();
            m_port = -1;
            m_localSite = null;
            m_directory = new DirectoryString();
            m_fullurl = "";
        }

        public URLString( String url )
        {
            m_port = -1;
            ParseString( url, false );
        }

        public URLString( String url, bool parsed ) : base()
        {
            m_port = -1;
            ParseString( url, parsed );
        }

        void ParseString( String url, bool parsed )
        {
            if (url == null)
            {
                throw new ArgumentNullException( "url" );
            }
            
            if (url.Length == 0)
            {
                throw new FormatException(Environment.GetResourceString("Format_StringZeroLength"));
            }
            
            int index;
            String temp = url;
            String intermediate = "";

            // If there are any hex or unicode characters in the url, translate those
            // into the proper character.

            if(!parsed)
            {
                do
                {
                    index = temp.IndexOf( '%' );

                    if (index == -1)
                    {
                        intermediate += temp;
                        break;
                    }

                    if (temp.Length - index < 1)
                        throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidUrl" ) );

                    if (temp[index+1] == 'u' || temp[index+1] == 'U')
                    {
                        if (temp.Length - index < 5)
                            throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidUrl" ) );

                        // We have a unicode character specified in hex
                       
                        char c = (char)(Hex.ConvertHexDigit( temp[index+2] ) << 12 |
                                        Hex.ConvertHexDigit( temp[index+3] ) << 8  |
                                        Hex.ConvertHexDigit( temp[index+4] ) << 4  |
                                        Hex.ConvertHexDigit( temp[index+5] ));
                                        
                        intermediate += temp.Substring( 0, index ) + c;
                        temp = temp.Substring( index + 6 );
                    }
                    else
                    {
                        // we have a hex character.
                                         
                        if (temp.Length - index < 2)
                             throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidUrl" ) );

                        char c = (char)(Hex.ConvertHexDigit( temp[index+1] ) << 4 | Hex.ConvertHexDigit( temp[index+2] ));

                        intermediate += temp.Substring( 0, index ) + c;
                        temp = temp.Substring( index + 3 );
                    }  

                } while (true);

                temp = intermediate;
                url = temp;
            }

            
            // Search for the end of the protocol info and grab the actual protocol string
            // ex. http://www.microsoft.com/complus would have a protocol string of http

            index = temp.IndexOf( ':' );
                
            if (index == 0)
            {
                throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidUrl" ) );
            }
            else if (index != -1 &&
                     temp.Length > index + 1)
            {
                if (String.Compare( temp.Substring( 0, index ), "file", true, CultureInfo.InvariantCulture) == 0)
                {
                    m_protocol = "file";
                    temp = temp.Substring( index + 1 );  
                }
                else if (temp[index+1] != '\\')
                {
                    if (temp.Length > index + 2 &&
                        temp[index+1] == '/' &&
                        temp[index+2] == '/')
                    {
                        m_protocol = url.Substring( 0, index );

                        for (int i = 0; i < m_protocol.Length; ++i)
                        {
                            char c = m_protocol[i];

                            if ((c >= 'a' && c <= 'z') ||
                                (c >= 'A' && c <= 'Z'))
                            {
                                continue;
                            }
                            else
                            {
                                throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidUrl" ) );
                            }
                        }

                        temp = url.Substring( index + 3 );
                    }
                    else
                    {
                        throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidUrl" ) );
                    }
                }
                else
                {
                    m_protocol = m_defaultProtocol;
                    temp = url;
                }
            }
            else
            {
                m_protocol = m_defaultProtocol;
                temp = url;
            }
            
            // Parse out the site info.
            // In the general case we parse of the site and create a SiteString out of it
            // (which supports our wildcarding scheme).  In the case of files we don't support
            // wildcarding and furthermore SiteString doesn't like ':' and '|' which can appear
            // in file urls so we just keep that info in a separate string and set the
            // SiteString to null.
            //
            // ex. http://www.microsoft.com/complus  -> m_siteString = "www.microsoft.com" m_localSite = null
            // ex. file:///c:/complus/mscorlib.dll  -> m_siteString = null m_localSite = "c:"
            // ex. file:///c|/complus/mscorlib.dll  -> m_siteString = null m_localSite = "c:"
                    
            bool fileProtocol;

            if (String.Compare( m_protocol, "file", true, CultureInfo.InvariantCulture) == 0)
            {                       
                index = temp.IndexOfAny( m_fileEnd );
                fileProtocol = true;

                if (String.Compare( temp, 0, "\\\\?\\", 0, 4, true, CultureInfo.InvariantCulture ) == 0 ||
                    String.Compare( temp, 0, "\\\\.\\", 0, 4, true, CultureInfo.InvariantCulture ) == 0)
                {
                    temp = temp.Substring( 4 );
                }
            }
            else
            {
                index = temp.IndexOfAny( m_siteEnd );
                fileProtocol = false;
            }

            temp = temp.Replace( '\\', '/' );

            // If we find a '/' in the first character of the string and we are using the 'file'
            // protocol, just ignore it.
            
            if (fileProtocol)
            {
                // Remove any '/' before the local site information.
                // ex. file://///d:/complus
                // ex. file:///d:/complus

                temp = temp.TrimStart( new char[] { '/' } );

                index = temp.IndexOfAny( m_fileEnd, 0 );

                if (index != -1 &&
                    ((index == 2 &&
                      temp[index-1] != ':' &&
                      temp[index-1] != '|') ||
                     index != 2) &&
                    index != temp.Length - 1)
                {
                    int tempIndex = temp.Substring( index + 1 ).IndexOfAny( m_fileEnd );

                    if (tempIndex != -1)
                        index = tempIndex + index + 1;
                    else
                        index = -1;
                }
            }

            // Check if there is a port number and parse that out.

            if (index != -1 && temp[index] == ':')
            {
                int tempIndex = temp.IndexOf( '/' );

                if (tempIndex == -1)
                {
                    m_port = Int32.Parse( temp.Substring( index + 1 ) );

                    if (m_port < 0)
                        throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidUrl" ) );

                    temp = temp.Substring( 0, index );
                    index = -1;
                }
                else
                {
                    m_port = Int32.Parse( temp.Substring( index + 1, tempIndex - index - 1 ) );
                    temp = temp.Substring( 0, index ) + temp.Substring( tempIndex );
                }
            }

            if (index == -1)
            {
                if (fileProtocol)
                {
                    String localSite = temp;

                    int i;
                    bool spacesAllowed;

                    if (localSite[0] == '\\' && localSite[1] == '\\')
                    {
                        spacesAllowed = true;
                        i = 2;
                    }
                    else
                    {
                        i = 0;
                        spacesAllowed = false;
                    }

                    bool useSmallCharToUpper = true;

                    for (; i < localSite.Length; ++i)
                    {
                        char c = localSite[i];

                        if ((c >= 'A' && c <= 'Z') ||
                            (c >= 'a' && c <= 'z') ||
                            (c >= '0' && c <= '9') ||
                            (c == '-') || (c == '/') ||
                            (c == ':') || (c == '|') ||
                            (c == '.') || (c == '*') ||
                            (c == '$') || (spacesAllowed && c == ' '))
                        {
                            continue;
                        }
                        else
                        {
                            useSmallCharToUpper = false;
                            break;
                        }
                    }


                    if (useSmallCharToUpper)
                        localSite = String.SmallCharToUpper( localSite );
                    else
                        localSite = localSite.ToUpper(CultureInfo.InvariantCulture);

                    m_siteString = null;
                    m_localSite = new LocalSiteString( localSite );

                    if (localSite[localSite.Length-1] == '*')
                        m_directory = new DirectoryString( "*", false );
                    else
                        m_directory = new DirectoryString();
                }
                else
                {
                    m_localSite = null;
                    m_siteString = new SiteString( temp );
                    m_directory = new DirectoryString();
                }

            }
            else
            {
                String site = temp.Substring( 0, index );

                if (fileProtocol)
                {
                    String localSite = site;

                    int i;
                    bool spacesAllowed;

                    if (localSite[0] == '\\' && localSite[1] == '\\')
                    {
                        spacesAllowed = true;
                        i = 2;
                    }
                    else
                    {
                        i = 0;
                        spacesAllowed = false;
                    }

                    bool useSmallCharToUpper = true;

                    for (; i < localSite.Length; ++i)
                    {
                        char c = localSite[i];

                        if ((c >= 'A' && c <= 'Z') ||
                            (c >= 'a' && c <= 'z') ||
                            (c >= '-' && c <= ':') ||
                            (c == '|') || (c == '$') ||
                            (c == '_') ||
                            (spacesAllowed && c == ' '))
                        {
                            continue;
                        }
                        else
                        {
                            useSmallCharToUpper = false;
                            break;
                        }
                    }

                    if (useSmallCharToUpper)
                        localSite = String.SmallCharToUpper( localSite );
                    else
                        localSite = localSite.ToUpper(CultureInfo.InvariantCulture);

                    m_siteString = null;
                    m_localSite = new LocalSiteString( localSite );
                }
                else
                {
                    m_localSite = null;
                    m_siteString = new SiteString( site );
                }
        
                // Finally we parse out the directory string
                // ex. http://www.microsoft.com/complus -> m_directory = "complus"
        
                String directoryString = temp.Substring( index + 1 );
            
                if (directoryString.Length == 0)
                {
                    m_directory = new DirectoryString();
                }
                else
                {
                    m_directory = new DirectoryString( directoryString, fileProtocol );
                }
            }

            String builtUrl;

            if (fileProtocol)
            {
                String directory = m_directory.ToString();
                String localSite = m_localSite.ToString();

                builtUrl = "file://" + localSite;
                
                if (directory != null && !directory.Equals( "" ) && (!directory.Equals( "*" ) || localSite.IndexOf( '*' ) == -1))
                    builtUrl += "/" + directory;
            }
            else
            {
                builtUrl = m_protocol + "://" + m_siteString.ToString();

                if (m_port != -1)
                    builtUrl += ":" + m_port;

                builtUrl += "/" + m_directory.ToString();
            }

            m_fullurl = builtUrl;

        }

        public int Port
        {
            get
            {
                return m_port;
            }
        }

        public String Scheme
        {
            get
            {
                return m_protocol;
            }
        }

        public String Host
        {
            get
            {
                if (m_siteString != null)
                {
                    return m_siteString.ToString();
                }
                else
                {
                    return m_localSite.ToString();
                }
            }
        }

        public String Directory
        {
            get
            {
                return m_directory.ToString();
            }
        }

        public String GetFileName()
        {
            if (String.Compare( m_protocol, "file", true, CultureInfo.InvariantCulture) != 0)
                return null;

            String intermediateDirectory = this.Directory.Replace( '/', '\\' );

            String directory = this.Host.Replace( '/', '\\' );

            int directorySlashIndex = directory.IndexOf( '\\' );
            if (directorySlashIndex == -1)
            {
                if (directory.Length != 2 ||
                    !(directory[1] == ':' || directory[1] == '|'))
                {
                    directory = "\\\\" + directory;
                }
            }
            else if (directorySlashIndex > 2 ||
                     (directorySlashIndex == 2 && directory[1] != ':' && directory[1] != '|'))
            {
                directory = "\\\\" + directory;
            }

            directory += "\\" + intermediateDirectory;
            
            return directory;
        }


        public String GetDirectoryName()
        {
            if (String.Compare( m_protocol, "file", true, CultureInfo.InvariantCulture) != 0)
                return null;

            String intermediateDirectory = this.Directory.Replace( '/', '\\' );

            int slashIndex = 0;
            for (int i = intermediateDirectory.Length; i > 0; i--)
            {
                if (intermediateDirectory[i-1] == '\\')
                {
                    slashIndex = i;
                    break;
                }
            }

            String directory = this.Host.Replace( '/', '\\' );

            int directorySlashIndex = directory.IndexOf( '\\' );
            if (directorySlashIndex == -1)
            {
                if (directory.Length != 2 ||
                    !(directory[1] == ':' || directory[1] == '|'))
                {
                    directory = "\\\\" + directory;
                }
            }
            else if (directorySlashIndex > 2 ||
                     (directorySlashIndex == 2 && directory[1] != ':' && directory[1] != '|'))
            {
                directory = "\\\\" + directory;
            }

            directory += "\\";
            
            if (slashIndex > 0)
            {
                directory += intermediateDirectory.Substring( 0, slashIndex );
            }

            return directory;
        }

        
        public override SiteString Copy()
        {
            return new URLString( m_fullurl );
        }            
        
        public override bool IsSubsetOf( SiteString site )
        {
            if (site == null)
            {
                return false;
            }
            
            URLString url = site as URLString;
            
            if (url == null)
            {
                return false;
            }

            URLString normalUrl1 = this.SpecialNormalizeUrl();
            URLString normalUrl2 = url.SpecialNormalizeUrl();
            
            if (String.Compare( normalUrl1.m_protocol, normalUrl2.m_protocol, true, CultureInfo.InvariantCulture) == 0 &&
                normalUrl1.m_directory.IsSubsetOf( normalUrl2.m_directory ))
            {
                if (normalUrl1.m_localSite != null)
                {
                    // We do a little extra processing in here for local files since we allow
                    // both <drive_letter>: and <drive_letter>| forms of urls.
                    
                    return normalUrl1.m_localSite.IsSubsetOf( normalUrl2.m_localSite );
                }
                else
                {
                    if (normalUrl1.m_port != normalUrl2.m_port)
                        return false;

                    return normalUrl2.m_siteString != null && normalUrl1.m_siteString.IsSubsetOf( normalUrl2.m_siteString );
                }
            }
            else
            {
                return false;
            }
        }
        
        public override String ToString()
        {
            if (String.Compare(m_fullurl, 0, "file:///", 0, 8, true, CultureInfo.InvariantCulture) == 0)
                return "file://" + m_fullurl.Substring(7);
            return m_fullurl;
        }
        
        public override bool Equals(Object o)
        {
            if (o == null || !(o is URLString))
                return false;
            else
                return this.Equals( (URLString)o );
        }

        public override int GetHashCode()
        {
            return this.m_fullurl.GetHashCode();
        }    
        
        public bool Equals( URLString url )
        {
            return CompareUrls( this, url );
        }

        public static bool CompareUrls( URLString url1, URLString url2 )
        {
            if (url1 == null && url2 == null)
                return true;

            if (url1 == null || url2 == null)
                return false;

            URLString normalUrl1 = url1.SpecialNormalizeUrl();
            URLString normalUrl2 = url2.SpecialNormalizeUrl();

            // Compare protocol (case insensitive)

            if (String.Compare( normalUrl1.m_protocol, normalUrl2.m_protocol, true, CultureInfo.InvariantCulture) != 0)
                return false;

            // Do special processing for file urls

            if (String.Compare( normalUrl1.m_protocol, "file", true, CultureInfo.InvariantCulture) == 0)
            {
                return normalUrl1.m_localSite.IsSubsetOf( normalUrl2.m_localSite ) &&
                       normalUrl2.m_localSite.IsSubsetOf( normalUrl1.m_localSite );
            }
            else
            {
                if (!normalUrl1.m_siteString.IsSubsetOf( normalUrl2.m_siteString ) ||
                    !normalUrl2.m_siteString.IsSubsetOf( normalUrl1.m_siteString ))
                    return false;

                if (url1.m_port != url2.m_port)
                    return false;
            }

            if (!normalUrl1.m_directory.IsSubsetOf( normalUrl2.m_directory ) ||
                !normalUrl2.m_directory.IsSubsetOf( normalUrl1.m_directory ))
                return false;

            return true;
        }

        internal String NormalizeUrl()
        {
            String builtUrl;

            if (String.Compare( m_protocol, "file", true, CultureInfo.InvariantCulture) == 0)
            {
                builtUrl = "FILE:///" + m_localSite.ToString() + "/" + m_directory.ToString();
            }
            else
            {
                builtUrl = m_protocol + "://" + m_siteString.ToString();

                if (m_port != -1)
                    builtUrl += ":" + m_port;

                builtUrl += "/" + m_directory.ToString();
            }

            return builtUrl.ToUpper(CultureInfo.InvariantCulture);
        }
        
        internal URLString SpecialNormalizeUrl()
        {
            // Under WinXP, file protocol urls can be mapped to
            // drives that aren't actually file protocol underneath
            // due to drive mounting.  This code attempts to figure
            // out what a drive is mounted to and create the
            // url is maps to.

            if (String.Compare( m_protocol, "file", true, CultureInfo.InvariantCulture) != 0)
            {
                return this;
            }
            else
            {
                String localSite = m_localSite.ToString();

                if (localSite.Length == 2 &&
                    (localSite[1] == '|' ||
                     localSite[1] == ':'))
                {
                    String deviceName = _GetDeviceName( localSite );

                    if (deviceName != null)
                    {
                        if (deviceName.IndexOf( "://" ) != -1)
                            return new URLString( deviceName + "/" + this.m_directory.ToString() );
                        else
                            return new URLString( "file://" + deviceName + "/" + this.m_directory.ToString() );
                    }
                    else
                        return this;
                }
                else
                {
                    return this;
                }
            }
        }
                
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String _GetDeviceName( String driveLetter );
    }

    
    [Serializable]
    internal class DirectoryString : SiteString
    {
        private bool m_checkForIllegalChars;

        private new static char[] m_separators = { '/' };

        // From KB #Q177506, file/folder illegal characters are \ / : * ? " < > | 
        protected static char[] m_illegalDirectoryCharacters = { '\\', ':', '*', '?', '"', '<', '>', '|' };
        
        public DirectoryString()
        {
            m_site = "";
            m_separatedSite = new ArrayList();
        }
        
        public DirectoryString( String directory, bool checkForIllegalChars )
        {
            m_site = directory;
            m_checkForIllegalChars = checkForIllegalChars;
            m_separatedSite = CreateSeparatedString( directory );
        }
        
        private ArrayList CreateSeparatedString( String directory )
        {
            ArrayList list = new ArrayList();
            
            if (directory == null || directory.Length == 0)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidDirectoryOnUrl"));
            }
            
            String[] separatedArray = directory.Split( m_separators );
            
            for (int index = 0; index < separatedArray.Length; ++index)
            {
                if (separatedArray[index] == null || separatedArray[index].Equals( "" ))
                {
                    // this case is fine, we just ignore it the extra separators.
                }
                else if (separatedArray[index].Equals( "*" ))
                {
                    if (index != separatedArray.Length-1)
                    {
                        throw new ArgumentException(Environment.GetResourceString("Argument_InvalidDirectoryOnUrl"));
                    }
                    list.Add( separatedArray[index] );
                }
                else if (m_checkForIllegalChars && separatedArray[index].IndexOfAny( m_illegalDirectoryCharacters ) != -1)
                {
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidDirectoryOnUrl"));
                }
                else
                {
                    list.Add( separatedArray[index] );
                }
            }
            
            return list;
        }
        
        public virtual bool IsSubsetOf( DirectoryString operand )
        {
            return this.IsSubsetOf( operand, true );
        }

        public virtual bool IsSubsetOf( DirectoryString operand, bool ignoreCase )
        {
            if (operand == null)
            {
                return false;
            }
            else if (operand.m_separatedSite.Count == 0)
            {
                return this.m_separatedSite.Count == 0 || this.m_separatedSite.Count > 0 && String.Compare( (String)this.m_separatedSite[0], "*", false, CultureInfo.InvariantCulture) == 0;
            }
            else if (this.m_separatedSite.Count == 0)
            {
                return String.Compare( (String)operand.m_separatedSite[0], "*", false, CultureInfo.InvariantCulture) == 0;
            }
            else
            {
                return base.IsSubsetOf( operand, ignoreCase );
            }
        }
    }

    [Serializable]
    internal class LocalSiteString : SiteString
    {
        private new static char[] m_separators = { '/' };

        public LocalSiteString( String site )
        {
            m_site = site.Replace( '|', ':');

            if (m_site.Length > 2 && m_site.IndexOf( ':' ) != -1)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidDirectoryOnUrl"));
                
            m_separatedSite = CreateSeparatedString( m_site );
        }
        
        private ArrayList CreateSeparatedString( String directory )
        {
            ArrayList list = new ArrayList();
            
            if (directory == null || directory.Length == 0)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidDirectoryOnUrl"));
            }
            
            String[] separatedArray = directory.Split( m_separators );
            
            for (int index = 0; index < separatedArray.Length; ++index)
            {
                if (separatedArray[index] == null || separatedArray[index].Equals( "" ))
                {
                    if (index < 2 &&
                        directory[index] == '/')
                    {
                        list.Add( '/' );
                    }
                    else if (index != separatedArray.Length-1)
                    {
                        throw new ArgumentException(Environment.GetResourceString("Argument_InvalidDirectoryOnUrl"));
                    }
                }
                else if (separatedArray[index].Equals( "*" ))
                {
                    if (index != separatedArray.Length-1)
                    {
                        throw new ArgumentException(Environment.GetResourceString("Argument_InvalidDirectoryOnUrl"));
                    }
                    list.Add( separatedArray[index] );
                }
                else
                {
                    list.Add( separatedArray[index] );
                }
            }
            
            return list;
        }
        
        public virtual bool IsSubsetOf( LocalSiteString operand )
        {
            return this.IsSubsetOf( operand, true );
        }

        public virtual bool IsSubsetOf( LocalSiteString operand, bool ignoreCase )
        {
            if (operand == null)
            {
                return false;
            }
            else if (operand.m_separatedSite.Count == 0)
            {
                return this.m_separatedSite.Count == 0 || this.m_separatedSite.Count > 0 && String.Compare( (String)this.m_separatedSite[0], "*", false, CultureInfo.InvariantCulture) == 0;
            }
            else if (this.m_separatedSite.Count == 0)
            {
                return String.Compare( (String)operand.m_separatedSite[0], "*", false, CultureInfo.InvariantCulture) == 0;
            }
            else
            {
                return base.IsSubsetOf( operand, ignoreCase );
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\gb18030encoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System.Text;
    using System.Runtime.InteropServices;
    using System;
    using System.Security;
    using System.Runtime.CompilerServices;
    
    /*=================================GB18030Encoding============================
    **
    ** This is used to support GB18030-2000 encoding (code page 54936).
    **
    ==============================================================================*/

    [Serializable()] 
    internal class GB18030Encoding : Encoding {
        private const int GB18030       = 54936;
        private const int MaxCharSize   = 4;
    
        internal GB18030Encoding() {
            m_codePage = GB18030;
            if (!nativeLoadGB18030DLL()) {
                throw new ArgumentException(
                    String.Format(Environment.GetResourceString("Argument_CodepageNotSupported"), GB18030), "codepage");                
            }
        }

        ~GB18030Encoding() {
            nativeUnloadGB18030DLL();
        }

        public override int CodePage {
            get {
                return (GB18030);
            }
        }
        
        public unsafe override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
        
            return (nativeUnicodeToBytes(chars, index, count, null, 0, 0));
            
        }

        public unsafe override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (charCount == 0) return 0;

            // When charCount is not zero, we will definitely generate some chars back.  So if byteIndex == bytes.Length,
            // there will be conversion overflow.
            if (byteIndex == bytes.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));

            int result = nativeUnicodeToBytes(chars, charIndex, charCount, bytes, byteIndex, bytes.Length-byteIndex);
            if (result == 0) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));            
            }
            return (result);
        }

        public unsafe override int GetCharCount(byte[] bytes, int index, int count) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }            
            if (bytes.Length - index < count) {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
        
            return (nativeBytesToUnicode(bytes, index, count, null, null, 0, 0));
        }

        public unsafe override int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex) {
            if (bytes == null || chars == null) {
                throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }        
            if ( bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (charIndex < 0 || charIndex > chars.Length) {
                throw new ArgumentOutOfRangeException("charIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            
            if (byteCount == 0) return 0;
            if (charIndex == chars.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));

            int result = nativeBytesToUnicode(bytes, byteIndex, byteCount, null, chars, charIndex, chars.Length - charIndex);
            if (result == 0) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));            
            }
            return (result);            
        }

        public override int GetMaxByteCount(int charCount) {
            if (charCount < 0) {
               throw new ArgumentOutOfRangeException("charCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            int byteCount = charCount * MaxCharSize;
            // Check for overflows.
            if (byteCount < 0)
                throw new ArgumentOutOfRangeException("charCount", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return (byteCount);
            
        }

        public override int GetMaxCharCount(int byteCount) {
            if (byteCount < 0) {
               throw new ArgumentOutOfRangeException("byteCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            return (byteCount);
        }

        public override Decoder GetDecoder() {
            return (new GB18030Decoder());
        }

        public override Encoder GetEncoder() {
            return (new SurrogateEncoder(this));
        }

        [Serializable]
        internal class GB18030Decoder : System.Text.Decoder
        {
            private int m_leftOverBytes = 0;
            private byte[] leftOver = new byte[8];
            
            internal GB18030Decoder() {
            }

            public unsafe override int GetCharCount(byte[] bytes, int index, int count) {
                if (bytes == null) {
                    throw new ArgumentNullException("bytes", 
                        Environment.GetResourceString("ArgumentNull_Array"));
                }
                if (index < 0 || count < 0) {
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                        Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }            
                if (bytes.Length - index < count) {
                    throw new ArgumentOutOfRangeException("bytes",
                        Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                }
                int result = 0;
                if (m_leftOverBytes > 0) {
                    byte[] sourceBytes = new byte[m_leftOverBytes + count];
                    Array.Copy(leftOver, 0, sourceBytes, 0, m_leftOverBytes);
                    Array.Copy(bytes, index, sourceBytes, m_leftOverBytes, count);
                    fixed(int* p = &m_leftOverBytes) {
                        result = nativeBytesToUnicode(
                            sourceBytes, 0, sourceBytes.Length, p, 
                            null, 0, 0);
                    }
                } else
                {
                    fixed(int* p = &m_leftOverBytes) {
                        result = nativeBytesToUnicode(
                            bytes, index, count, p, 
                            null, 0, 0);
                    }
                }
                
                return (result);
            }

            public unsafe override int GetChars(
                byte[] bytes, int byteIndex, int byteCount,
                char[] chars, int charIndex) {

                if (bytes == null || chars == null) {
                    throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                        Environment.GetResourceString("ArgumentNull_Array"));
                }
                if (byteIndex < 0 || byteCount < 0) {
                    throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                        Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }        
                if ( bytes.Length - byteIndex < byteCount)
                {
                    throw new ArgumentOutOfRangeException("bytes",
                        Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                }
                if (charIndex < 0 || charIndex > chars.Length) {
                    throw new ArgumentOutOfRangeException("charIndex", 
                        Environment.GetResourceString("ArgumentOutOfRange_Index"));
                }

                if (byteCount == 0) {
                    return (0);
                }
                
                int result;
                int newLeftOverBytes = 0;			// We have to clear this because if the .dll counts it won't clear it
                if (m_leftOverBytes > 0) {         
                    byte[] sourceBytes = new byte[m_leftOverBytes + byteCount];
                    Array.Copy(leftOver, 0, sourceBytes, 0, m_leftOverBytes);
                    Array.Copy(bytes, byteIndex, sourceBytes, m_leftOverBytes, byteCount);

                    // Note:  We're "unsafe" and newLeftOverBytes is on the stack, so we don't
                    // have to worry about fixed here.  (We get an error if we try to make newLeftOverBytes fixed)
                    result = nativeBytesToUnicode(
                    	sourceBytes, 0, sourceBytes.Length, &newLeftOverBytes,
                        chars, charIndex, chars.Length - charIndex);
                } else
                {
                    // Note:  We're "unsafe" and newLeftOverBytes is on the stack, so we don't
                    // have to worry about fixed here.  (We get an error if we try to make newLeftOverBytes fixed)
                    result = nativeBytesToUnicode(
                        bytes, byteIndex, byteCount, &newLeftOverBytes,
                        chars, charIndex, chars.Length - charIndex);
				}
                // If we had a result, we may not have had a place to put it.
                if (result > 0 && charIndex == chars.Length)
                {
                	throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                }
				// We may have had some left over bytes
                if (newLeftOverBytes > 0)
                {
					if (result == 0)
            		{
						// Any previously left-over bytes are still left over because we have no new characters
            			Array.Copy(bytes, byteIndex + byteCount - newLeftOverBytes + m_leftOverBytes, leftOver, m_leftOverBytes, newLeftOverBytes - m_leftOverBytes);
            		}
					else
					{
						// Our left over bytes only come from the new string
						Array.Copy(bytes, byteIndex + byteCount - newLeftOverBytes, leftOver, 0, newLeftOverBytes);
					}

					m_leftOverBytes = newLeftOverBytes;
                } else {
                    // There are no left-over bytes or there was no output buffer provided. If the result is zero, there may be a buffer overflow.
                    if (result == 0) {
                    	// If we had a buffer then this is an error or if we had real characters this is an error
                    	// If we have a 0 length buffer then result is the count, so result would be > 0 if the buffer is too small.
                    	if (chars.Length > 0)
                    	{
                        	throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));            
                    	}
                    	else
                    	{
                    		// We didn't have a buffer and there weren't any real characters, so fix the m_leftOverBytes
                    		Array.Copy(bytes, byteIndex, leftOver, m_leftOverBytes, byteCount);
                    		m_leftOverBytes += byteCount;
                    	}
                    }
                    else
                	{
                		// We really don't have any left over bytes
                		m_leftOverBytes = 0;
                	}
                }
        
                return (result);
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern bool nativeLoadGB18030DLL();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern bool nativeUnloadGB18030DLL();
        
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int nativeUnicodeToBytes(
            char[] chars, int charIndex, int charCount, 
            byte[] bytes, int byteIndex, int byteCount);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int nativeGetBytesCount(
            char[] chars, int charIndex, int charCount);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int nativeBytesToUnicode(
            byte[] bytes, int byteIndex, int byteCount, int* pLeftOverBytes,
            char[] chars, int charIndex, int charCount);            

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int nativeGetCharCount(
            byte[] bytes, int byteIndex, int byteCount);            
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\encodingexceptionfallback.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System;

    /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingExceptionFallback"]/*' />
    public class EncodingExceptionFallback : EncodingFallback {       
        /*
        public EncodingExceptionFallback(int codepage) : base(codepage) {
        }
        
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetR                    //
                    // We subtract one here because we will add the count of characters when we bail out the loop.
                    //
esourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }            
            
            if (byteIndex == bytes.Length) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
        
            throw new EncodingFallbackException(Environment.GetResourceString("Encoding_Fallback"),
                chars, charIndex, charCount);
        }

        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException(
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }

            return (0);
        }
        */   
        /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingExceptionFallback.Fallback"]/*' />
        public override char[] Fallback(char[] chars, int charIndex, int charCount) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            throw new EncodingFallbackException(Environment.GetResourceString("Encoding_Fallback"),
                chars, charIndex, charCount);
        }

        /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingExceptionFallback.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount() {
            return (0);
        }

    }

    /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingFallbackException"]/*' />
    public class EncodingFallbackException : SystemException {
        char[] chars;
        int charIndex;
        int charCount;
        
        /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingFallbackException.EncodingFallbackException"]/*' />
        public EncodingFallbackException(String message, char[] chars, int charIndex, int charCount) : base(message) {
            this.chars = chars;
            this.charIndex = charIndex;
            this.charCount = charCount;
        }

        /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingFallbackException.Chars"]/*' />
        public char[] Chars {
            get {
                return (chars);
            }
        }

        /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingFallbackException.Index"]/*' />
        public int Index {
            get {
                return (charIndex);
            }
        }

        /// <include file='doc\EncodingExceptionFallback.uex' path='docs/doc[@for="EncodingFallbackException.Count"]/*' />
        public int Count {
            get {
                return (charCount);
            }
        }

    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\decoder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
	using System.Text;
	using System;
    // A Decoder is used to decode a sequence of blocks of bytes into a
    // sequence of blocks of characters. Following instantiation of a decoder,
    // sequential blocks of bytes are converted into blocks of characters through
    // calls to the GetChars method. The decoder maintains state between the
    // conversions, allowing it to correctly decode byte sequences that span
    // adjacent blocks.
    // 
    // Instances of specific implementations of the Decoder abstract base
    // class are typically obtained through calls to the GetDecoder method
    // of Encoding objects.
    // 
    /// <include file='doc\Decoder.uex' path='docs/doc[@for="Decoder"]/*' />
    [Serializable()] public abstract class Decoder
    {
    
        /// <include file='doc\Decoder.uex' path='docs/doc[@for="Decoder.Decoder"]/*' />
        protected Decoder() {
        }
    
        // Returns the number of characters the next call to GetChars will
        // produce if presented with the given range of bytes. The returned value
        // takes into account the state in which the decoder was left following the
        // last call to GetChars. The state of the decoder is not affected
        // by a call to this method.
        // 
        /// <include file='doc\Decoder.uex' path='docs/doc[@for="Decoder.GetCharCount"]/*' />
        public abstract int GetCharCount(byte[] bytes, int index, int count);
    
        // Decodes a range of bytes in a byte array into a range of characters
        // in a character array. The method decodes byteCount bytes from
        // bytes starting at index byteIndex, storing the resulting
        // characters in chars starting at index charIndex. The
        // decoding takes into account the state in which the decoder was left
        // following the last call to this method.
        //
        // An exception occurs if the character array is not large enough to
        // hold the complete decoding of the bytes. The GetCharCount method
        // can be used to determine the exact number of characters that will be
        // produced for a given range of bytes. Alternatively, the
        // GetMaxCharCount method of the Encoding that produced this
        // decoder can be used to determine the maximum number of characters that
        // will be produced for a given number of bytes, regardless of the actual
        // byte values.
        // 
        /// <include file='doc\Decoder.uex' path='docs/doc[@for="Decoder.GetChars"]/*' />
        public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\encodingfallback.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System;
    
    /// <include file='doc\EncodingFallback.uex' path='docs/doc[@for="EncodingFallback"]/*' />
    public abstract class EncodingFallback {
        /*
        internal int codepage;

        public EncodingFallback(Encoding enc) {
            this.codepage = codepage;
        }

        
        public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        public abstract int GetByteCount(char[] chars, int index, int count);
        */
        /// <include file='doc\EncodingFallback.uex' path='docs/doc[@for="EncodingFallback.Fallback"]/*' />
        public abstract char[] Fallback(char[] chars, int charIndex, int charCount);

        // Note GetMaxCharCount may be 0!
        /// <include file='doc\EncodingFallback.uex' path='docs/doc[@for="EncodingFallback.GetMaxCharCount"]/*' />
        public abstract int GetMaxCharCount();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\encoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    
    using System;
    using System.Collections;
    using System.Runtime.Remoting;
    using System.Globalization;
    using Win32Native = Microsoft.Win32.Win32Native;

    // Note YSLin:
    // Want the implementation of EncodingFallback back?
    // Search for "//ENCODINGFALLBACK" in all of the encoding classes.
    //
    
    // This abstract base class represents a character encoding. The class provides
    // methods to convert arrays and strings of Unicode characters to and from
    // arrays of bytes. A number of Encoding implementations are provided in
    // the System.Text package, including:
    // 
    // ASCIIEncoding, which encodes Unicode characters as single 7-bit
    // ASCII characters. This encoding only supports character values between 0x00
    // and 0x7F.
    // CodePageEncoding, which encapsulates a Windows code page. Any
    // installed code page can be accessed through this encoding, and conversions
    // are performed using the WideCharToMultiByte and
    // MultiByteToWideChar Windows API functions.
    // UnicodeEncoding, which encodes each Unicode character as two
    // consecutive bytes. Both little-endian (code page 1200) and big-endian (code
    // page 1201) encodings are supported.
    // UTF7Encoding, which encodes Unicode characters using the UTF-7
    // encoding (UTF-7 stands for UCS Transformation Format, 7-bit form). This
    // encoding supports all Unicode character values, and can also be accessed
    // as code page 65000.
    // UTF8Encoding, which encodes Unicode characters using the UTF-8
    // encoding (UTF-8 stands for UCS Transformation Format, 8-bit form). This
    // encoding supports all Unicode character values, and can also be accessed
    // as code page 65001.
    // 
    // In addition to directly instantiating Encoding objects, an
    // application can use the ForCodePage, GetASCII,
    // GetDefault, GetUnicode, GetUTF7, and GetUTF8
    // methods in this class to obtain encodings.
    // 
    // Through an encoding, the GetBytes method is used to convert arrays
    // of characters to arrays of bytes, and the GetChars method is used to
    // convert arrays of bytes to arrays of characters. The GetBytes and
    // GetChars methods maintain no state between conversions, and are
    // generally intended for conversions of complete blocks of bytes and
    // characters in one operation. When the data to be converted is only available
    // in sequential blocks (such as data read from a stream) or when the amount of
    // data is so large that it needs to be divided into smaller blocks, an
    // application may choose to use a Decoder or an Encoder to
    // perform the conversion. Decoders and encoders allow sequential blocks of
    // data to be converted and they maintain the state required to support
    // conversions of data that spans adjacent blocks. Decoders and encoders are
    // obtained using the GetDecoder and GetEncoder methods.
    // 
    // The core GetBytes and GetChars methods require the caller
    // to provide the destination buffer and ensure that the buffer is large enough
    // to hold the entire result of the conversion. When using these methods,
    // either directly on an Encoding object or on an associated
    // Decoder or Encoder, an application can use one of two methods
    // to allocate destination buffers.
    // 
    // The GetByteCount and GetCharCount methods can be used to
    // compute the exact size of the result of a particular conversion, and an
    // appropriately sized buffer for that conversion can then be allocated.
    // The GetMaxByteCount and GetMaxCharCount methods can be
    // be used to compute the maximum possible size of a conversion of a given
    // number of bytes or characters, and a buffer of that size can then be reused
    // for multiple conversions.
    // 
    // The first method generally uses less memory, whereas the second method
    // generally executes faster.
    // 
    /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding"]/*' />
    [Serializable()] public abstract class Encoding
    {
        private static Encoding defaultEncoding;
        private static Encoding unicodeEncoding;
        private static Encoding bigEndianUnicode;
        private static Encoding utf7Encoding;
        private static Encoding utf8Encoding;
        private static Encoding asciiEncoding;
        private static Encoding latin1Encoding;
        private static Hashtable encodings;

        //
        // The following values are from mlang.idl.  These values
        // should be in sync with those in mlang.idl.
        //
        private const int MIMECONTF_MAILNEWS          = 0x00000001;
        private const int MIMECONTF_BROWSER           = 0x00000002;
        private const int MIMECONTF_SAVABLE_MAILNEWS  = 0x00000100;
        private const int MIMECONTF_SAVABLE_BROWSER   = 0x00000200;

        private const int ISO_8859_1  = 28591;
        private const int ISO_8859_1_SIZE  = 1;
        private const int EUCJP       = 51932;
        private const int EUCJP_SIZE       = 3;
        private const int EUCCN       = 51936;
        private const int EUCCN_SIZE       = 3;
        private const int ISO2022JP   = 50220;
        // MLang always shifts back to ASCII at the end of every call.  So the approimate max byte
        // is 3 byte shift-in + 2 byte Shift-JIS + 3 byte shift-out.  The number will cause
        // GetMaxByteCount() to return bigger value than needed, but it is a safe approximation.
        private const int ISO2022JP_SIZE   = 8;
        private const int ENC50221    = 50221;
        private const int ENC50221_SIZE    = 8;
        private const int ENC50222    = 50222;
        private const int ENC50222_SIZE    = 8;
        private const int ISOKorean   = 50225;
        private const int ISOKorean_SIZE   = 8;        
        private const int ENC50227    = 50227;
        private const int ENC50227_SIZE  = 5;
        private const int ChineseSimp = 52936;
        private const int ChineseSimp_SIZE = 5;
        private const int ISCIIAsseme = 57006;
        private const int ISCIIBengali = 57003;
        private const int ISCIIDevanagari = 57002;
        private const int ISCIIGujarathi  = 57010;
        private const int ISCIIKannada    = 57008;
        private const int ISCIIMalayalam  = 57009;
        private const int ISCIIOriya      = 57007;
        private const int ISCIIPanjabi    = 57011;
        private const int ISCIITamil      = 57004;
        private const int ISCIITelugu     = 57005;
        private const int ISCII_SIZE=4; //All of these are the same size
        private const int GB18030         = 54936;
        private const int ENC50229        = 50229;
        
        internal CodePageDataItem dataItem = null;
        internal int m_codePage; 
        //ENCODINGFALLBACK
        //internal EncodingFallback m_encodingFallback = null;

        // Useful for Encodings whose GetPreamble method must return an
        // empty byte array.
        internal static readonly byte[] emptyByteArray = new byte[0];
        
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.Encoding"]/*' />
        protected Encoding() : this(0) {
        }
    
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.Encoding1"]/*' />
        protected Encoding(int codePage) {
            if (codePage<0) {
                throw new ArgumentOutOfRangeException("codePage");
            }
            m_codePage = codePage;
        }

        /*
        //ENCODINGFALLBACK
        protected Encoding(int codePage, EncodingFallback encodingFallback) {
            if (codePage<0) {
                throw new ArgumentOutOfRangeException("codePage");
            }
            m_codePage = codePage;
            m_encodingFallback = encodingFallback;
            //Don't get the data item for right now.
            //        dataItem = EncodingTable.GetDataItem(codePage);
        }
        */
    
        // Converts a byte array from one encoding to another. The bytes in the
        // bytes array are converted from srcEncoding to
        // dstEncoding, and the returned value is a new byte array
        // containing the result of the conversion.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.Convert"]/*' />
        public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding,
            byte[] bytes) {
            if (bytes==null)
                throw new ArgumentNullException("bytes");
            return Convert(srcEncoding, dstEncoding, bytes, 0, bytes.Length);
        }
    
        // Converts a range of bytes in a byte array from one encoding to another.
        // This method converts count bytes from bytes starting at
        // index index from srcEncoding to dstEncoding, and
        // returns a new byte array containing the result of the conversion.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.Convert1"]/*' />
        public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding,
            byte[] bytes, int index, int count) {
            if (srcEncoding == null || dstEncoding == null) {
                throw new ArgumentNullException((srcEncoding == null ? "srcEncoding" : "dstEncoding"), 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (bytes == null) {
                throw new ArgumentNullException("bytes",
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            return dstEncoding.GetBytes(srcEncoding.GetChars(bytes, index, count));
        }
        
        // Returns an Encoding object for a given code page.
        // 
        // YSLin Make this internal for now until we decide the final spec of EncodingFallback
        /*
        //ENCODINGFALLBACK
        internal static Encoding GetEncoding(int codepage, EncodingFallback encodingFallback)
        {
            //
            // NOTENOTE: If you add a new encoding that can be get by codepage, be sure to
            // add the corresponding item in EncodingTable.
            // Otherwise, the code below will throw exception when trying to call 
            // EncodingTable.GetDataItem().
            //
            if (codepage < 0 || codepage > 65535) {
                throw new ArgumentOutOfRangeException(
                    "codepage", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    0, 65535));
            }
            Encoding result = null;
            if (encodings != null)
                result = (Encoding)encodings[codepage];
            if (result == null) {
                lock (typeof(Encoding)) {
                    if (encodings == null) encodings = new Hashtable();
                    if ((result = (Encoding)encodings[codepage])!=null) {
                        return result;
                    }
                    switch (codepage) {
                    case 0:
                        if (encodingFallback != null) {
                            return (CreateDefaultEncoding(encodingFallback));
                        }
                        result = Default;
                        break;
                    case 1:
                    case 2:
                    case 3:
                    case 42:
                        // NOTENOTE YSLin:
                        // Win32 also allows the following special code page values.  We won't allow them except in the 
                        // CP_ACP case.
                        // #define CP_ACP                    0           // default to ANSI code page
                        // #define CP_OEMCP                  1           // default to OEM  code page
                        // #define CP_MACCP                  2           // default to MAC  code page
                        // #define CP_THREAD_ACP             3           // current thread's ANSI code page
                        // #define CP_SYMBOL                 42          // SYMBOL translations
                        throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_CodepageNotSupported"), codepage), "codepage");
                     case 1200:
                        result = Unicode;
                        break;
                    case 1201:
                        result = BigEndianUnicode;
                        break;
                    case 65000:
                        result = UTF7;
                        break;
                    case 65001:
                        result = UTF8;
                        break;
                    case 20127:
                        result = ASCII;
                        break;
                    case ISOKorean:
                    case ChineseSimp:
                    case ISCIIAsseme:
                    case ISCIIBengali:
                    case ISCIIDevanagari:
                    case ISCIIGujarathi:
                    case ISCIIKannada:
                    case ISCIIMalayalam:
                    case ISCIIOriya:
                    case ISCIIPanjabi:
                    case ISCIITamil:
                    case ISCIITelugu:
                    case ISO2022JP:
                        if (encodingFallback != null) {
                            return (new MLangCodePageEncoding(codepage, encodingFallback));
                        }
                        result = new MLangCodePageEncoding(codepage);
                        break;
                    case EUCJP:
                        result = new EUCJPEncoding();
                        break;
                    default:
                        if (encodingFallback != null) {
                            return (new CodePageEncoding(codepage, encodingFallback));
                        }
                        result = new CodePageEncoding(codepage);
            break;
                    }
                    encodings.Add(codepage, result);
                }
                
            }
            return result;
        }
        */
        

        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetEncoding1"]/*' />
        public static Encoding GetEncoding(int codepage)
        {
            //
            // NOTENOTE: If you add a new encoding that can be get by codepage, be sure to
            // add the corresponding item in EncodingTable.
            // Otherwise, the code below will throw exception when trying to call 
            // EncodingTable.GetDataItem().
            //
            if (codepage < 0 || codepage > 65535) {
                throw new ArgumentOutOfRangeException(
                    "codepage", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    0, 65535));
            }
            Encoding result = null;
            if (encodings != null)
                result = (Encoding)encodings[codepage];
            if (result == null) {
                lock (typeof(Encoding)) {
                    if (encodings == null) encodings = new Hashtable();
                    if ((result = (Encoding)encodings[codepage])!=null) {
                        return result;
                    }
                    // Special case the commonly used Encoding classes here, then call
                    // GetEncodingRare to avoid loading classes like MLangCodePageEncoding
                    // and ASCIIEncoding.  ASP.NET uses UTF-8 & ISO-8859-1.
                    switch (codepage) {
                    case 0:
                        result = CreateDefaultEncoding();
                        break;
                    case 1200:
                        result = Unicode;
                        break;
                    case 1201:
                        result = BigEndianUnicode;
                        break;
                    case 1252:
                        result = new CodePageEncoding(codepage);
                        break;
                    case 65001:
                        result = UTF8;
                        break;
                    default:
                        result = GetEncodingRare(codepage);
                        break;
                    }
                    encodings.Add(codepage, result);
                }
                
            }
            return result;
        }


        private static Encoding GetEncodingRare(int codepage)
        {
            BCLDebug.Assert(codepage != 0 && codepage != 1200 && codepage != 1201 && codepage != 65001, "This code page ("+codepage+" isn't supported by GetEncodingRare!");
            Encoding result;
            switch (codepage) {
            case 1:
            case 2:
            case 3:
            case 42:
                // NOTENOTE YSLin:
                // Win32 also allows the following special code page values.  We won't allow them except in the 
                // CP_ACP case.
                // #define CP_ACP                    0           // default to ANSI code page
                // #define CP_OEMCP                  1           // default to OEM  code page
                // #define CP_MACCP                  2           // default to MAC  code page
                // #define CP_THREAD_ACP             3           // current thread's ANSI code page
                // #define CP_SYMBOL                 42          // SYMBOL translations
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_CodepageNotSupported"), codepage), "codepage");
            case 65000:
                result = UTF7;
                break;
            case 20127:
                result = ASCII;
                break;
            case ISO_8859_1:
            	result = Latin1;
            	break;
            case ISOKorean:
                result = new MLangCodePageEncoding(ISOKorean, ISOKorean_SIZE);
                break;
            case ChineseSimp:
                result = new MLangCodePageEncoding(ChineseSimp, ChineseSimp_SIZE);
                break;
            case ISCIIAsseme:
            case ISCIIBengali:
            case ISCIIDevanagari:
            case ISCIIGujarathi:
            case ISCIIKannada:
            case ISCIIMalayalam:
            case ISCIIOriya:
            case ISCIIPanjabi:
            case ISCIITamil:
            case ISCIITelugu:
                result = new MLangCodePageEncoding(codepage, ISCII_SIZE);
                break;
            case ISO2022JP:
                result = new MLangCodePageEncoding(ISO2022JP,ISO2022JP_SIZE);
                break;
            case ENC50221:
                result = new MLangCodePageEncoding(ENC50221,ENC50221_SIZE);
                break;
            case ENC50222:
                result = new MLangCodePageEncoding(ENC50222,ENC50222_SIZE);
                break;
            case ENC50227:
                result = new MLangCodePageEncoding(ENC50227,ENC50227_SIZE);
                break;
            case EUCJP:
                result = new MLangCodePageEncoding(EUCJP,EUCJP_SIZE);
                break;
            case GB18030:
                result = new GB18030Encoding();
                break;
            case EUCCN:
                result = new MLangCodePageEncoding(EUCCN, EUCCN_SIZE);
                break;
            case ENC50229:
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_CodePage50229"));
            default:
                result = new CodePageEncoding(codepage);
                break;
            }
            return result;
        }

        // Returns an Encoding object for a given name or a given code page value.  
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetEncoding"]/*' />
        public static Encoding GetEncoding(String name)
        {
            //
            // NOTENOTE: If you add a new encoding that can be get by name, be sure to
            // add the corresponding item in EncodingTable.
            // Otherwise, the code below will throw exception when trying to call 
            // EncodingTable.GetCodePageFromName().
            //
            return (GetEncoding(EncodingTable.GetCodePageFromName(name)));
        }

        // YSLin Make this internal for now until we decide the final spec of EncodingFallback
        /*
        //ENCODINGFALLBACK
        internal static Encoding GetEncoding(String name, EncodingFallback encodingFallback)
        {
            //
            // NOTENOTE: If you add a new encoding that can be get by name, be sure to
            // add the corresponding item in EncodingTable.
            // Otherwise, the code below will throw exception when trying to call 
            // EncodingTable.GetCodePageFromName().
            //
            return (GetEncoding(EncodingTable.GetCodePageFromName(name), encodingFallback));
        }
        */

        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetPreamble"]/*' />
        public virtual byte[] GetPreamble()
        {
            return emptyByteArray;
        }

        private void GetDataItem() {
            if (dataItem==null) {
                dataItem = EncodingTable.GetCodePageDataItem(m_codePage);
                if(dataItem==null) {
                    throw new NotSupportedException(String.Format(Environment.GetResourceString("NotSupported_NoCodepageData"), m_codePage));
                }
            }
        }

        // Returns the name for this encoding that can be used with mail agent body tags.
        // If the encoding may not be used, the string is empty.
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.BodyName"]/*' />
        public virtual String BodyName
        {
            get
            {
                if (dataItem==null) {
                    GetDataItem();
                }
                return (dataItem.BodyName);
            }
        }
    
        // Returns the human-readable description of the encoding ( e.g. Hebrew (DOS)).
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.EncodingName"]/*' />
        public virtual String EncodingName
        {
            get
            {
                return (Environment.GetResourceString("Globalization.cp_"+m_codePage));
            }
        }
    
        // Returns the name for this encoding that can be used with mail agent header 
        // tags.  If the encoding may not be used, the string is empty.
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.HeaderName"]/*' />
        public virtual String HeaderName
        {
            get
            {
                if (dataItem==null) {
                    GetDataItem();
                }
                return (dataItem.HeaderName);
            }
        }
    
        // Returns the array of IANA-registered names for this encoding.  If there is an 
        // IANA preferred name, it is the first name in the array.
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.WebName"]/*' />
        public virtual String WebName
        {
            get
            {
                if (dataItem==null) {
                    GetDataItem();
                }
                return (dataItem.WebName);
            }
        }
    
        // Returns the windows code page that most closely corresponds to this encoding.
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.WindowsCodePage"]/*' />
        public virtual int WindowsCodePage
        {
            get
            {
                if (dataItem==null) {
                    GetDataItem();
                }
                return (dataItem.UIFamilyCodePage);
            }
        }
    

        // True if and only if the encoding is used for display by browsers clients.
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.IsBrowserDisplay"]/*' />
        public virtual bool IsBrowserDisplay {
            get {
                if (dataItem==null) {
                    GetDataItem();
                }
                return ((dataItem.Flags & MIMECONTF_BROWSER) != 0);
            }
        }
    
        // True if and only if the encoding is used for saving by browsers clients.
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.IsBrowserSave"]/*' />
        public virtual bool IsBrowserSave {
            get {
                if (dataItem==null) {
                    GetDataItem();
                }
                return ((dataItem.Flags & MIMECONTF_SAVABLE_BROWSER) != 0);
            }
        }
    
        // True if and only if the encoding is used for display by mail and news clients.
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.IsMailNewsDisplay"]/*' />
        public virtual bool IsMailNewsDisplay {
            get {
                if (dataItem==null) {
                    GetDataItem();
                }
                return ((dataItem.Flags & MIMECONTF_MAILNEWS) != 0);
            }
        }
    
    
        // True if and only if the encoding is used for saving documents by mail and 
        // news clients    
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.IsMailNewsSave"]/*' />
        public virtual bool IsMailNewsSave {
            get {
                if (dataItem==null) {
                    GetDataItem();
                }
                return ((dataItem.Flags & MIMECONTF_SAVABLE_MAILNEWS) != 0);
            }
        }
        
        // YSLin Make this internal for now until we decide the final spec of EncodingFallback
        /*
        //ENCODINGFALLBACK
        internal virtual EncodingFallback EncodingFallback {
            get {
                return (m_encodingFallback);
            }
        }
        */
    
        // Returns an encoding for the ASCII character set. The returned encoding
        // will be an instance of the ASCIIEncoding class.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.ASCII"]/*' />
        public static Encoding ASCII {
           get {
                if (asciiEncoding == null) asciiEncoding = new ASCIIEncoding();
                return asciiEncoding;
            }
        }

        // Returns an encoding for the Latin1 character set. The returned encoding
        // will be an instance of the Latin1Encoding class.
        //
        // This is for our optimizations
        private static Encoding Latin1 {
           get {
                if (latin1Encoding == null) latin1Encoding = new Latin1Encoding();
                return latin1Encoding;
            }
        }        
    
        // Returns the number of bytes required to encode the given character
        // array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetByteCount"]/*' />
        public virtual int GetByteCount(char[] chars) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            return GetByteCount(chars, 0, chars.Length);
        }
        
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetByteCount2"]/*' />
        public virtual int GetByteCount(String s)
        {
            if (s==null)
                throw new ArgumentNullException("s");
            char[] chars = s.ToCharArray();
            return GetByteCount(chars, 0, chars.Length);
        }

        // Returns the number of bytes required to encode a range of characters in
        // a character array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetByteCount1"]/*' />
        public abstract int GetByteCount(char[] chars, int index, int count);
    
        // Returns a byte array containing the encoded representation of the given
        // character array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetBytes"]/*' />
        public virtual byte[] GetBytes(char[] chars) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            return GetBytes(chars, 0, chars.Length);
        }
    
        // Returns a byte array containing the encoded representation of a range
        // of characters in a character array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetBytes1"]/*' />
        public virtual byte[] GetBytes(char[] chars, int index, int count) {
            byte[] result = new byte[GetByteCount(chars, index, count)];
            GetBytes(chars, index, count, result, 0);
            return result;
        }
    
        // Encodes a range of characters in a character array into a range of bytes
        // in a byte array. An exception occurs if the byte array is not large
        // enough to hold the complete encoding of the characters. The
        // GetByteCount method can be used to determine the exact number of
        // bytes that will be produced for a given range of characters.
        // Alternatively, the GetMaxByteCount method can be used to
        // determine the maximum number of bytes that will be produced for a given
        // number of characters, regardless of the actual character values.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetBytes2"]/*' />
        public abstract int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex);
        
        // Returns a byte array containing the encoded representation of the given
        // string.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetBytes3"]/*' />
        public virtual byte[] GetBytes(String s) {
            if (s == null) {
                throw new ArgumentNullException("s",
                    Environment.GetResourceString("ArgumentNull_String"));
            }
            char[] chars = s.ToCharArray();
            return GetBytes(chars, 0, chars.Length);
        }

        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetBytes4"]/*' />
        public virtual int GetBytes(String s, int charIndex, int charCount,
            byte[] bytes, int byteIndex)
        {
            if (s==null)
                throw new ArgumentNullException("s");
            return GetBytes(s.ToCharArray(), charIndex, charCount, bytes, byteIndex);
        }
    
        // Returns the number of characters produced by decoding the given byte
        // array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetCharCount"]/*' />
        public virtual int GetCharCount(byte[] bytes) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            return GetCharCount(bytes, 0, bytes.Length);
        }
        
        // Returns the number of characters produced by decoding a range of bytes
        // in a byte array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetCharCount1"]/*' />
        public abstract int GetCharCount(byte[] bytes, int index, int count);
    
        // Returns a character array containing the decoded representation of a
        // given byte array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetChars"]/*' />
        public virtual char[] GetChars(byte[] bytes) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            return GetChars(bytes, 0, bytes.Length);
        }
        
        // Returns a character array containing the decoded representation of a
        // range of bytes in a byte array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetChars1"]/*' />
        public virtual char[] GetChars(byte[] bytes, int index, int count) {
            char[] result = new char[GetCharCount(bytes, index, count)];
            GetChars(bytes, index, count, result, 0);
            return result;
        }
        
        // Decodes a range of bytes in a byte array into a range of characters in a
        // character array. An exception occurs if the character array is not large
        // enough to hold the complete decoding of the bytes. The
        // GetCharCount method can be used to determine the exact number of
        // characters that will be produced for a given range of bytes.
        // Alternatively, the GetMaxCharCount method can be used to
        // determine the maximum number of characterss that will be produced for a
        // given number of bytes, regardless of the actual byte values.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetChars2"]/*' />
        public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex);
    
        // Returns the code page identifier of this encoding. The returned value is
        // an integer between 0 and 65535 if the encoding has a code page
        // identifier, or -1 if the encoding does not represent a code page.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.CodePage"]/*' />
        public virtual int CodePage {
            get {
                return m_codePage;
            }
        }
    
        // Returns a Decoder object for this encoding. The returned object
        // can be used to decode a sequence of bytes into a sequence of characters.
        // Contrary to the GetChars family of methods, a Decoder can
        // convert partial sequences of bytes into partial sequences of characters
        // by maintaining the appropriate state between the conversions.
        // 
        // This default implementation returns a Decoder that simply
        // forwards calls to the GetCharCount and GetChars methods to
        // the corresponding methods of this encoding. Encodings that require state
        // to be maintained between successive conversions should override this
        // method and return an instance of an appropriate Decoder
        // implementation.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetDecoder"]/*' />
        public virtual Decoder GetDecoder() {
            return new DefaultDecoder(this);
        }

        /*
        //ENCODINGFALLBACK
        internal static Encoding CreateDefaultEncoding(EncodingFallback encodingFallback) {
            Encoding enc;
            int codePage = Win32Native.GetACP();
            
            // For US English, we can save some startup working set by not calling
            // GetEncoding(int codePage) since JITting GetEncoding will force us to load
            // all the Encoding classes for ASCII, UTF7 & UTF8, & UnicodeEncoding.
            if (codePage == 1252) {
                enc = new CodePageEncoding(codePage, encodingFallback);
            }
            else
                enc = GetEncoding(codePage);
            return (enc);
        }
        */
        internal static Encoding CreateDefaultEncoding() {
            Encoding enc;
            int codePage = Win32Native.GetACP();
            
            // For US English, we can save some startup working set by not calling
            // GetEncoding(int codePage) since JITting GetEncoding will force us to load
            // all the Encoding classes for ASCII, UTF7 & UTF8, & UnicodeEncoding.
            if (codePage == 1252) {
                enc = new CodePageEncoding(codePage);
            }
            else
                enc = GetEncoding(codePage);
            return (enc);
        }
        
        // Returns an encoding for the system's current ANSI code page.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.Default"]/*' />
        public static Encoding Default {
            get {
                if (defaultEncoding == null) {
                    defaultEncoding = CreateDefaultEncoding();
                }
                return defaultEncoding;
            }
        }
    
        // Returns an Encoder object for this encoding. The returned object
        // can be used to encode a sequence of characters into a sequence of bytes.
        // Contrary to the GetBytes family of methods, an Encoder can
        // convert partial sequences of characters into partial sequences of bytes
        // by maintaining the appropriate state between the conversions.
        // 
        // This default implementation returns an Encoder that simply
        // forwards calls to the GetByteCount and GetBytes methods to
        // the corresponding methods of this encoding. Encodings that require state
        // to be maintained between successive conversions should override this
        // method and return an instance of an appropriate Encoder
        // implementation.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetEncoder"]/*' />
        public virtual Encoder GetEncoder() {
            return new DefaultEncoder(this);
        }
    
        // Returns the maximum number of bytes required to encode a given number of
        // characters. This method can be used to determine an appropriate buffer
        // size for byte arrays passed to the GetBytes method of this
        // encoding or the GetBytes method of an Encoder for this
        // encoding. All encodings must guarantee that no buffer overflow
        // exceptions will occur if buffers are sized according to the results of
        // this method.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetMaxByteCount"]/*' />
        public abstract int GetMaxByteCount(int charCount);
    
        // Returns the maximum number of characters produced by decoding a given
        // number of bytes. This method can be used to determine an appropriate
        // buffer size for character arrays passed to the GetChars method of
        // this encoding or the GetChars method of a Decoder for this
        // encoding. All encodings must guarantee that no buffer overflow
        // exceptions will occur if buffers are sized according to the results of
        // this method.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetMaxCharCount"]/*' />
        public abstract int GetMaxCharCount(int byteCount);
    
        // Returns a string containing the decoded representation of a given byte
        // array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetString"]/*' />
        public virtual String GetString(byte[] bytes) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            return new String(GetChars(bytes));
        }
    
        // Returns a string containing the decoded representation of a range of
        // bytes in a byte array.
        // 
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetString1"]/*' />
        public virtual String GetString(byte[] bytes, int index, int count) {
            return new String(GetChars(bytes, index, count));
        }
    
        // Returns an encoding for Unicode format. The returned encoding will be
        // an instance of the UnicodeEncoding class. 
        // 
        // It will use little endian byte order, but will detect 
        // input in big endian if it finds a byte order mark 
        // (see Unicode 2.0 spec).
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.Unicode"]/*' />
        public static Encoding Unicode {
            get {
                if (unicodeEncoding == null) unicodeEncoding = new UnicodeEncoding(false, true);
                return unicodeEncoding;
            }
        }
    
        // Returns an encoding for Unicode format. The returned encoding will be
        // an instance of the UnicodeEncoding class.
        // 
        // It will use big endian byte order, but will detect 
        // input in little endian if it finds a byte order mark 
        // (see Unicode 2.0 spec).
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.BigEndianUnicode"]/*' />
        public static Encoding BigEndianUnicode {
            get {
                if (bigEndianUnicode == null) bigEndianUnicode = new UnicodeEncoding(true, true);
                return bigEndianUnicode;
            }
        }
    
        // Returns an encoding for the UTF-7 format. The returned encoding will be
        // an instance of the UTF7Encoding class.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.UTF7"]/*' />
        public static Encoding UTF7 {
            get {
                if (utf7Encoding == null) utf7Encoding = new UTF7Encoding();
                return utf7Encoding;
            }
        }
    
        // Returns an encoding for the UTF-8 format. The returned encoding will be
        // an instance of the UTF8Encoding class.
        //
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.UTF8"]/*' />
        public static Encoding UTF8 {
            get {
                if (utf8Encoding == null) utf8Encoding = new UTF8Encoding(true);
                return utf8Encoding;
            }
        }

        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.Equals"]/*' />
        public override bool Equals(Object value) {
            Encoding enc = value as Encoding;
            if (enc != null)
                return (m_codePage == enc.m_codePage);
            return (false);
        }
    
        /// <include file='doc\Encoding.uex' path='docs/doc[@for="Encoding.GetHashCode"]/*' />
        public override int GetHashCode() {
            return m_codePage;
        }

        // Default decoder implementation. The GetCharCount and
        // GetChars methods simply forward to the corresponding methods of
        // the encoding. This implementation is appropriate for encodings that do
        // not require state to be maintained between successive conversions.
        [Serializable()]
        private class DefaultDecoder : Decoder
        {
            private Encoding encoding;
    
            public DefaultDecoder(Encoding encoding) {
                this.encoding = encoding;
            }
    
            public override int GetCharCount(byte[] bytes, int index, int count) {
                return encoding.GetCharCount(bytes, index, count);
            }
    
            public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
                char[] chars, int charIndex) {
                return encoding.GetChars(bytes, byteIndex, byteCount,
                    chars, charIndex);
            }
        }
    
        // Default encoder implementation. The GetByteCount and
        // GetBytes methods simply forward to the corresponding methods of
        // the encoding. This implementation is appropriate for encodings that do
        // not require state to be maintained between successive conversions.
        [Serializable()]
        private class DefaultEncoder : Encoder
        {
            private Encoding encoding;
    
            public DefaultEncoder(Encoding encoding) {
                this.encoding = encoding;
            }
    
            public override int GetByteCount(char[] chars, int index, int count, bool flush) {
                return encoding.GetByteCount(chars, index, count);
            }
    
            public override int GetBytes(char[] chars, int charIndex, int charCount,
                byte[] bytes, int byteIndex, bool flush) {
                return encoding.GetBytes(chars, charIndex, charCount,
                    bytes, byteIndex);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\encoder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
	using System.Text;
	using System;
    // An Encoder is used to encode a sequence of blocks of characters into
    // a sequence of blocks of bytes. Following instantiation of an encoder,
    // sequential blocks of characters are converted into blocks of bytes through
    // calls to the GetBytes method. The encoder maintains state between the
    // conversions, allowing it to correctly encode character sequences that span
    // adjacent blocks.
    // 
    // Instances of specific implementations of the Encoder abstract base
    // class are typically obtained through calls to the GetEncoder method
    // of Encoding objects.
    // 
    /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder"]/*' />
    [Serializable()] public abstract class Encoder
    {
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.Encoder"]/*' />
        protected Encoder() {
            //A do-nothing constructor.
        }
    
        // Returns the number of bytes the next call to GetBytes will
        // produce if presented with the given range of characters and the given
        // value of the flush parameter. The returned value takes into
        // account the state in which the encoder was left following the last call
        // to GetBytes. The state of the encoder is not affected by a call
        // to this method.
        // 
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.GetByteCount"]/*' />
        public abstract int GetByteCount(char[] chars, int index, int count,
            bool flush);
    
        // Encodes a range of characters in a character array into a range of bytes
        // in a byte array. The method encodes charCount characters from
        // chars starting at index charIndex, storing the resulting
        // bytes in bytes starting at index byteIndex. The encoding
        // takes into account the state in which the encoder was left following the
        // last call to this method. The flush parameter indicates whether
        // the encoder should flush any shift-states and partial characters at the
        // end of the conversion. To ensure correct termination of a sequence of
        // blocks of encoded bytes, the last call to GetBytes should specify
        // a value of true for the flush parameter.
        //
        // An exception occurs if the byte array is not large enough to hold the
        // complete encoding of the characters. The GetByteCount method can
        // be used to determine the exact number of bytes that will be produced for
        // a given range of characters. Alternatively, the GetMaxByteCount
        // method of the Encoding that produced this encoder can be used to
        // determine the maximum number of bytes that will be produced for a given
        // number of characters, regardless of the actual character values.
        // 
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.GetBytes"]/*' />
        public abstract int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex, bool flush);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\latin1encoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System;
	using System.Security;
    using System.Collections;
	using System.Runtime.CompilerServices;


	//
	// Latin1Encoding is a simple override to optimize the GetString version of Latin1Encoding.
	// because of the best fit cases we can't do this when encoding the string, only when decoding
	//
    [Serializable()] internal class Latin1Encoding : CodePageEncoding
    {
        public Latin1Encoding() : base(28591)
        {
        }

        public override String GetString(byte[] bytes)
        {
            if (bytes == null)
                throw new ArgumentNullException("bytes", Environment.GetResourceString("ArgumentNull_Array"));
            return String.CreateStringFromLatin1(bytes, 0, bytes.Length);
        }

        public override String GetString(byte[] bytes, int byteIndex, int byteCount)
        {
            if (bytes == null)
                throw new ArgumentNullException("bytes", Environment.GetResourceString("ArgumentNull_Array"));                
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }    
            if (bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            return String.CreateStringFromLatin1(bytes, byteIndex, byteCount);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\mlangcodepageencoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System.Text;
    using System.Runtime.InteropServices;
    using System;
    using System.Security;
    using System.Runtime.CompilerServices;
    
    /*=================================MLangCodePageEncoding==================================
    ** This is used to support code pages which are supported by MLang.
    ** For example, euc-jp (code page 51932) is supported in MLang, but not in Windows.  So we use this
    ** class to support euc-jp.
    ** To use this class, override MLangCodePageEncoding, and set the proper m_maxByteSize, and override
    ** GetDecoder() method.
    ==============================================================================*/

    [Serializable()] 
    internal class MLangCodePageEncoding : Encoding {
    
        protected int m_maxByteSize;    // The max encoding size for a character.

        internal MLangCodePageEncoding(int codePage, int byteSize) : base(codePage) {
            bool bResult=false;
            lock(typeof(MLangCodePageEncoding)) {
                // Note: these native calls are not thread safe, hence the lock
                bResult = nativeCreateIMultiLanguage();
            }

            if (!bResult) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_CodepageNotSupported"), codePage), "codePage");
            }            
            
            if (!nativeIsValidMLangCodePage(codePage)) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_CodepageNotSupported"), codePage), "codePage");
            }            
            m_maxByteSize = byteSize;
        }

        /*
        //ENCODINGFALLBACK
        unsafe internal MLangCodePageEncoding(int codepage, EncodingFallback encodingFallback) 
            : base(codepage, encodingFallback) {
            InitializeLangConvertCharset(codepage);
            m_maxByteSize = CodePageEncoding.GetCPMaxCharSizeNative(codepage);
        }

        //This constructor is provided for the use of the EUCJPEncoding, which can't call
        //GetCPMaxCharSizeNative because Windows doesn't natively support EUC-JP.
        unsafe internal MLangCodePageEncoding(int codepage, int maxByteSize, EncodingFallback encodingFallback) : base (codepage, encodingFallback) {
            InitializeLangConvertCharset(codepage);
            m_maxByteSize = maxByteSize;
        }

        private unsafe void InitializeLangConvertCharset(int codePage) {
            nativeCreateIMLangConvertCharset(codePage, out m_pIMLangConvertCharsetFromUnicode, out m_pIMLangConvertCharsetToUnicode);
            if (m_pIMLangConvertCharsetFromUnicode == null || m_pIMLangConvertCharsetToUnicode == null) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_CodepageNotSupported"), codePage), "codepage");
            }
        }
        */
        
        ~MLangCodePageEncoding() {
        	lock(typeof(MLangCodePageEncoding)) {
                // Note: these native calls are not thread safe, hence the lock
            	nativeReleaseIMultiLanguage();
        	}
        }
        
        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback != null) {
                UnicodeToBytesDelegate unicodeToBytes = new UnicodeToBytesDelegate(CallUnicodeToBytes);
                BytesToUnicodeDelegate bytesToUnicode = new BytesToUnicodeDelegate(CallBytesToUnicode);
                return (CodePageEncoding.GetByteCountFallback(unicodeToBytes, bytesToUnicode, m_encodingFallback, chars, index, count));
            }
            */
            int byteCount = nativeUnicodeToBytes(CodePage, chars, index, count, null, 0, 0);

            // Check for overflow
            if (byteCount < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return byteCount;
        }

        public override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (charCount == 0) return (0);
            if (byteIndex == bytes.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));

            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback != null) {
                UnicodeToBytesDelegate unicodeToBytes = new UnicodeToBytesDelegate(CallUnicodeToBytes);
                BytesToUnicodeDelegate bytesToUnicode = new BytesToUnicodeDelegate(CallBytesToUnicode);                
                return (CodePageEncoding.GetBytesFallback(unicodeToBytes, bytesToUnicode, m_encodingFallback, chars, charIndex, charCount, bytes, byteIndex));
            }
            */
            
            int result;
            result = nativeUnicodeToBytes(
                CodePage, 
                chars, charIndex, charCount,
                bytes, byteIndex, bytes.Length - byteIndex);
            if (result == 0) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            return (result);
        }

        /*
        //ENCODINGFALLBACK
        internal unsafe int CallUnicodeToBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, out bool usedDefaultChar) {
            //
            // For MLang, there is no way to detect if default characters are used during the conversion.
            // So always set used default char to true.
            //
            usedDefaultChar = true;
            return (nativeUnicodeToBytes(m_pIMLangConvertCharsetFromUnicode, chars, charIndex, charCount, bytes, byteIndex, byteCount));
        }

        internal unsafe int CallBytesToUnicode(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount) {
            return (nativeBytesToUnicode(m_pIMLangConvertCharsetToUnicode, bytes, byteIndex, out byteCount, chars, charIndex, charCount));
        }
        */

        public override int GetCharCount(byte[] bytes, int index, int count) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }                                                             
            if (bytes.Length - index < count) {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }

            int charCount = 0;
            int result;
            int dwMode = 0;
            
            if (count < 3 && IsISCIICodePage(CodePage)) {
                // Because of the way that MLang handles DLL-based code page, we will always fail (and get AgrumentException as a result)
                // when the byteCount is less than 3.
                // Therfore, let's call Win32 to convert these bytes directly.
                result = CodePageEncoding.BytesToUnicodeNative(CodePage, bytes, index, count, null, 0, 0);
            } else {
                result = nativeBytesToUnicode(CodePage, bytes, index, out count, null, 0, charCount, ref dwMode);
            }
            
            return (result);
        }

        //
        //  Actions: Check if the codepage is in ISCII range.
        //
        internal bool IsISCIICodePage(int codepage) {
            return (codepage >= 57002 && codepage <= 57011);
        }
        
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex) {
            if (bytes == null || chars == null) {
                throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }        
            if ( bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (charIndex < 0 || charIndex > chars.Length) {
                throw new ArgumentOutOfRangeException("charIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (byteCount == 0) return (0);
            // There are cases that a call to nativeBytesToUnicode() may generate an empty string.  For example, if
            // bytes only contain a lead byte.
            // Therefore, we should allow charIndex to be equal to chars.Length.

            int charCount = chars.Length - charIndex;
            
            int result;
            int dwMode = 0;
            if (byteCount < 3 && IsISCIICodePage(CodePage)) {
                if (charIndex == chars.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                // Because of the way that MLang handles DLL-based code page, we will always fail (and get AgrumentException as a result)
                // when the byteCount is less than 3.
                // Therfore, let's call Win32 to convert these bytes directly.
                result = CodePageEncoding.BytesToUnicodeNative(CodePage, bytes, byteIndex, byteCount,
                    chars, charIndex, chars.Length - charIndex);
                if (result == 0) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));                
                }
            } else {
                result = nativeBytesToUnicode(
                    CodePage, 
                    bytes, byteIndex, out byteCount,
                    chars, charIndex, charCount, ref dwMode);
            }
            
            return (result);
        }
         
        public override int GetMaxByteCount(int charCount) {
            if (charCount < 0) {
               throw new ArgumentOutOfRangeException("charCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            long byteCount = (long)charCount * m_maxByteSize;
            // Check for overflows.
            if (byteCount > 0x7FFFFFFF)
                throw new ArgumentOutOfRangeException("charCount", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return ((int)byteCount);

            /*
            //ENCODINGFALLBACK
            if (m_encodingFallback == null) {            
                return charCount * m_maxByteSize;
            }
            int fallbackMaxChars = m_encodingFallback.GetMaxCharCount();

            if (fallbackMaxChars == 0) {
                return (charCount * m_maxByteSize);
            }
            return (fallbackMaxChars * charCount * m_maxByteSize);
            */
        }

        public override int GetMaxCharCount(int byteCount) {
            if (byteCount < 0) {
               throw new ArgumentOutOfRangeException("byteCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            return (byteCount);
        }

        public override Decoder GetDecoder() {
            return new MLangDecoder(this);
        }

        public override Encoder GetEncoder() {
            return new MLangEncoder(this);
        }

        class MLangDecoder : Decoder {

            private byte[] m_buffer;
            private int    m_bufferCount;
            private int    m_codePage;
            private uint   m_context;
            private MLangCodePageEncoding m_encoding;
            private int dwMode = 0;
            

            internal MLangDecoder(MLangCodePageEncoding enc) : base() {
                m_encoding = enc;
                m_codePage = enc.CodePage;
                m_buffer = new byte[enc.m_maxByteSize];
                m_bufferCount=0;
                m_context = 0;
            } 

            private byte[] GetNewBuffer(byte[] input, ref int index, ref int count) {
                if (m_bufferCount == 0) {
                    return input;
                }
                byte[] buffer = new byte[count + m_bufferCount];
                Buffer.InternalBlockCopy(m_buffer, 0, buffer, 0, m_bufferCount);
                Buffer.InternalBlockCopy(input, index, buffer, m_bufferCount, count);
                index = 0;
                count = count + m_bufferCount;
                return buffer;
            }

            public unsafe override int GetCharCount(byte[] bytes, int index, int count) {
                if (bytes==null) 
                    throw new ArgumentNullException("bytes", Environment.GetResourceString("ArgumentNull_Array"));
                if (index < 0 || count < 0) {
                    throw new ArgumentOutOfRangeException(index < 0 ? "index" : "count", 
                                                          Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }
                if (index > bytes.Length - count)
                    throw new ArgumentOutOfRangeException("bytes", Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                
                int bytesConverted;
                bytes = GetNewBuffer(bytes, ref index, ref count);
                bytesConverted = count;
                return nativeBytesToUnicode(m_codePage, bytes, index, out bytesConverted,
                                            null, 0, 0, ref dwMode);
            }

            public unsafe override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex) {
                int bytesConverted = 0;
                if (bytes==null)
                    throw new ArgumentNullException("bytes", Environment.GetResourceString("ArgumentNull_Array"));
                if (chars==null) 
                    throw new ArgumentNullException("chars", Environment.GetResourceString("ArgumentNull_Array"));
                if (byteIndex < 0 || byteCount < 0)
                    throw new ArgumentOutOfRangeException((byteIndex < 0) ? "byteIndex" : "byteCount",
                                                          Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (byteIndex > bytes.Length - byteCount)
                    throw new ArgumentOutOfRangeException("bytes", Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                if (charIndex < 0 || charIndex > chars.Length) {
                    throw new ArgumentOutOfRangeException("charIndex", 
                                                          Environment.GetResourceString("ArgumentOutOfRange_Index"));
                }

                bytes = GetNewBuffer(bytes, ref byteIndex, ref byteCount);

                int result = 0;
                bytesConverted = byteCount;
                
                result = nativeBytesToUnicode(m_codePage, bytes, byteIndex, out bytesConverted,
                                                      chars, charIndex, (chars.Length - charIndex), ref dwMode);

                m_bufferCount = (byteCount - bytesConverted);   // The total number of bytes that are not converted                
                if (m_bufferCount > 0) {
                    byteIndex += bytesConverted;    // The first byte that is not converted.
                    
                    for (int i = 0; i < m_bufferCount; i++) {
                        m_buffer[i] = bytes[byteIndex++];
                    }                    
                }
                return result;
            }
        }
        

        internal class MLangEncoder : Encoder {

            private int                   m_codePage;
            private MLangCodePageEncoding m_encoding;

            internal MLangEncoder(MLangCodePageEncoding enc) : base() {
                m_encoding = enc;
                m_codePage = enc.CodePage;
            } 

            public unsafe override int GetByteCount(char[] chars, int index, int count, bool flush) {
                if (chars==null) 
                    throw new ArgumentNullException("chars", Environment.GetResourceString("ArgumentNull_Array"));
                if (index < 0 || count < 0) {
                    throw new ArgumentOutOfRangeException(index < 0 ? "index" : "count", 
                                                          Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }
                if (index > chars.Length - count)
                    throw new ArgumentOutOfRangeException("chars", Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));

                return nativeUnicodeToBytes(m_codePage, chars, index, count,
                                            null, 0, 0);
            }

            public unsafe override int GetBytes(char[] chars, int charIndex, int charCount,
                                         byte[] bytes, int byteIndex, bool flush) {

                if (bytes==null)
                    throw new ArgumentNullException("bytes", Environment.GetResourceString("ArgumentNull_Array"));
                if (chars==null) 
                    throw new ArgumentNullException("chars", Environment.GetResourceString("ArgumentNull_Array"));
                if (charIndex < 0 || charCount < 0)
                    throw new ArgumentOutOfRangeException((charIndex < 0) ? "charIndex" : "charCount",
                                                          Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (charIndex > chars.Length - charCount)
                    throw new ArgumentOutOfRangeException("chars", Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                if (byteIndex < 0 || byteIndex > bytes.Length) {
                    throw new ArgumentOutOfRangeException("byteIndex", 
                                                          Environment.GetResourceString("ArgumentOutOfRange_Index"));
                }
                if (charCount == 0) return (0);
                if (byteIndex == bytes.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                return nativeUnicodeToBytes(m_codePage, chars, charIndex, charCount,
                                            bytes, byteIndex, (bytes.Length - byteIndex));
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern bool nativeCreateIMultiLanguage();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern void nativeReleaseIMultiLanguage();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern bool nativeIsValidMLangCodePage(int codepage);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe protected static extern int nativeBytesToUnicode(
            int codePage,
            byte[] bytes, int byteIndex, out int byteCount,
            char[] chars, int charIndex, int charCount, ref int dwMode);    
            
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe protected static extern int nativeUnicodeToBytes(
            int codePage,
            char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex, int byteCount);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\nobestfitfallback.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System;
    /// <include file='doc\NoBestFitFallback.uex' path='docs/doc[@for="NoBestFitFallback"]/*' />
    public class NoBestFitFallback : EncodingFallback {
        
        String defaultStr;
        char[] defaultChars;
        int defaultCharsCount;
        
        /*
        Encoding srcEncoding;
        byte[] defaultBytes;
        int byteCount;
        
        public NoBestFitFallback(int codepage) : this(codepage, "?") {            
        }

        public NoBestFitFallback(int codepage, String defaultStr) : base(codepage) {
            if (defaultStr == null) {
                throw new ArgumentNullException("defaultStr");
            }

            srcEncoding = Encoding.GetEncoding(codepage);
            this.defaultStr = defaultStr;

            defaultBytes = srcEncoding.GetBytes(defaultStr.ToCharArray());
            byteCount = defaultBytes.Length;
        }
        
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }            
            
            if (byteIndex == bytes.Length) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }

            if (charCount == 0) return 0;

            for (int i = 0; i < charCount; i++) {
                if (byteIndex + byteCount > bytes.Length) {
                    Array.Copy(bytes, byteIndex, defaultBytes, 0, bytes.Length - byteIndex);
                    new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
                }
                Array.Copy(defaultBytes, 0, bytes, byteIndex, byteCount);
                byteIndex += byteCount;
            }
            return (byteCount * charCount);
        }

        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars");
            }

            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException(
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            
            return (byteCount * count);
        }
        */

        /// <include file='doc\NoBestFitFallback.uex' path='docs/doc[@for="NoBestFitFallback.NoBestFitFallback"]/*' />
        public NoBestFitFallback() : this("?") {
        }

        /// <include file='doc\NoBestFitFallback.uex' path='docs/doc[@for="NoBestFitFallback.NoBestFitFallback1"]/*' />
        public NoBestFitFallback(String defaultStr) {
            if (defaultStr == null) {
                throw new ArgumentNullException("defaultStr");
            }

            this.defaultStr = defaultStr;
            defaultChars = defaultStr.ToCharArray();
            defaultCharsCount = defaultChars.Length;
        }
        
        /// <include file='doc\NoBestFitFallback.uex' path='docs/doc[@for="NoBestFitFallback.Fallback"]/*' />
        public override char[] Fallback(char[] chars, int charIndex, int charCount) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }

            if (charCount == 0) return (null);

            char[] result = new char[charCount * defaultCharsCount];
            for (int i = 0; i < charCount; i++) {
                Array.Copy(defaultChars, 0, result, i * defaultStr.Length, defaultCharsCount);
            }
            return (result);
        }

        /// <include file='doc\NoBestFitFallback.uex' path='docs/doc[@for="NoBestFitFallback.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount() {
            return (defaultStr.Length);
        }

        
        /// <include file='doc\NoBestFitFallback.uex' path='docs/doc[@for="NoBestFitFallback.DefaultString"]/*' />
        public String DefaultString {
            get {
                return (defaultStr);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\namedentitiesfallback.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System;    

    /// <include file='doc\NamedEntitiesFallback.uex' path='docs/doc[@for="NamedEntitiesFallback"]/*' />
    public class NamedEntitiesFallback : EncodingFallback {
        Encoding srcEncoding;

        const int NAME_ENTITY_OFFSET  = 0x00A0;
        const int NAME_ENTITY_MAX       = 0x00FF;

        //
        // Unicode range from 0x00a0 - 0x00ff has named entity.
        //
        // Note that the data here will affect the return value
        // of GetMaxCharCount().
        // Currently, GetMaxCharCount() return 8. If you update
        // the data in this array, be sure to update
        // GetMaxCharCount() if necessary.
        // 
        static String[] nameEntity = {
            "&nbsp;",   // "&#160;" -- no-break space = non-breaking space,
            "&iexcl;",  // "&#161;" -- inverted exclamation mark, U+00A1 ISOnum -->
            "&cent;",   // "&#162;" -- cent sign, U+00A2 ISOnum -->
            "&pound;",  // "&#163;" -- pound sign, U+00A3 ISOnum -->
            "&curren;", // "&#164;" -- currency sign, U+00A4 ISOnum -->
            "&yen;",    // "&#165;" -- yen sign = yuan sign, U+00A5 ISOnum -->
            "&brvbar;", // "&#166;" -- broken bar = broken vertical bar,
            "&sect;",   // "&#167;" -- section sign, U+00A7 ISOnum -->
            "&uml;",    // "&#168;" -- diaeresis = spacing diaeresis,
            "&copy;",   // "&#169;" -- copyright sign, U+00A9 ISOnum -->
            "&ordf;",   // "&#170;" -- feminine ordinal indicator, U+00AA ISOnum -->
            "&laquo;",  // "&#171;" -- left-pointing double angle quotation mark
            "&not;",    // "&#172;" -- not sign = discretionary hyphen,
            "&shy;",    // "&#173;" -- soft hyphen = discretionary hyphen,
            "&reg;",    // "&#174;" -- registered sign = registered trade mark sign,
            "&macr;",   // "&#175;" -- macron = spacing macron = overline
            "&deg;",    // "&#176;" -- degree sign, U+00B0 ISOnum -->
            "&plusmn;", // "&#177;" -- plus-minus sign = plus-or-minus sign,
            "&sup2;",   // "&#178;" -- superscript two = superscript digit two
            "&sup3;",   // "&#179;" -- superscript three = superscript digit three
            "&acute;",  // "&#180;" -- acute accent = spacing acute,
            "&micro;",  // "&#181;" -- micro sign, U+00B5 ISOnum -->
            "&para;",   // "&#182;" -- pilcrow sign = paragraph sign,
            "&middot;", // "&#183;" -- middle dot = Georgian comma
            "&cedil;",  // "&#184;" -- cedilla = spacing cedilla, U+00B8 ISOdia -->
            "&sup1;",   // "&#185;" -- superscript one = superscript digit one,
            "&ordm;",   // "&#186;" -- masculine ordinal indicator,
            "&raquo;",  // "&#187;" -- right-pointing double angle quotation mark
            "&frac14;", // "&#188;" -- vulgar fraction one quarter
            "&frac12;", // "&#189;" -- vulgar fraction one half
            "&frac34;", // "&#190;" -- vulgar fraction three quarters
            "&iquest;", // "&#191;" -- inverted question mark
            "&Agrave;", // "&#192;" -- latin capital letter A with grave
            "&Aacute;", // "&#193;" -- latin capital letter A with acute,
            "&Acirc;",  // "&#194;" -- latin capital letter A with circumflex,
            "&Atilde;", // "&#195;" -- latin capital letter A with tilde,
            "&Auml;",   // "&#196;" -- latin capital letter A with diaeresis,
            "&Aring;",  // "&#197;" -- latin capital letter A with ring above
            "&AElig;",  // "&#198;" -- latin capital letter AE
            "&Ccedil;", // "&#199;" -- latin capital letter C with cedilla,
            "&Egrave;", // "&#200;" -- latin capital letter E with grave,
            "&Eacute;", // "&#201;" -- latin capital letter E with acute,
            "&Ecirc;",  // "&#202;" -- latin capital letter E with circumflex,
            "&Euml;",   // "&#203;" -- latin capital letter E with diaeresis,
            "&Igrave;", // "&#204;" -- latin capital letter I with grave,
            "&Iacute;", // "&#205;" -- latin capital letter I with acute,
            "&Icirc;",  // "&#206;" -- latin capital letter I with circumflex,
            "&Iuml;",   // "&#207;" -- latin capital letter I with diaeresis,
            "&ETH;",    // "&#208;" -- latin capital letter ETH, U+00D0 ISOlat1 -->
            "&Ntilde;", // "&#209;" -- latin capital letter N with tilde,
            "&Ograve;", // "&#210;" -- latin capital letter O with grave,
            "&Oacute;", // "&#211;" -- latin capital letter O with acute,
            "&Ocirc;",  // "&#212;" -- latin capital letter O with circumflex,
            "&Otilde;", // "&#213;" -- latin capital letter O with tilde,
            "&Ouml;",   // "&#214;" -- latin capital letter O with diaeresis,
            "&times;",  // "&#215;" -- multiplication sign, U+00D7 ISOnum -->
            "&Oslash;", // "&#216;" -- latin capital letter O with stroke
            "&Ugrave;", // "&#217;" -- latin capital letter U with grave,
            "&Uacute;", // "&#218;" -- latin capital letter U with acute,
            "&Ucirc;",  // "&#219;" -- latin capital letter U with circumflex,
            "&Uuml;",   // "&#220;" -- latin capital letter U with diaeresis,
            "&Yacute;", // "&#221;" -- latin capital letter Y with acute,
            "&THORN;",  // "&#222;" -- latin capital letter THORN,
            "&szlig;",  // "&#223;" -- latin small letter sharp s = ess-zed,
            "&agrave;", // "&#224;" -- latin small letter a with grave
            "&aacute;", // "&#225;" -- latin small letter a with acute,
            "&acirc;",  // "&#226;" -- latin small letter a with circumflex,
            "&atilde;", // "&#227;" -- latin small letter a with tilde,
            "&auml;",   // "&#228;" -- latin small letter a with diaeresis,
            "&aring;",  // "&#229;" -- latin small letter a with ring above
            "&aelig;",  // "&#230;" -- latin small letter ae
            "&ccedil;", // "&#231;" -- latin small letter c with cedilla,
            "&egrave;", // "&#232;" -- latin small letter e with grave,
            "&eacute;", // "&#233;" -- latin small letter e with acute,
            "&ecirc;",  // "&#234;" -- latin small letter e with circumflex,
            "&euml;",   // "&#235;" -- latin small letter e with diaeresis,
            "&igrave;", // "&#236;" -- latin small letter i with grave,
            "&iacute;", // "&#237;" -- latin small letter i with acute,
            "&icirc;",  // "&#238;" -- latin small letter i with circumflex,
            "&iuml;",   // "&#239;" -- latin small letter i with diaeresis,
            "&eth;",    // "&#240;" -- latin small letter eth, U+00F0 ISOlat1 -->
            "&ntilde;", // "&#241;" -- latin small letter n with tilde,
            "&ograve;", // "&#242;" -- latin small letter o with grave,
            "&oacute;", // "&#243;" -- latin small letter o with acute,
            "&ocirc;",  // "&#244;" -- latin small letter o with circumflex,
            "&otilde;", // "&#245;" -- latin small letter o with tilde,
            "&ouml;",   // "&#246;" -- latin small letter o with diaeresis,
            "&divide;", // "&#247;" -- division sign, U+00F7 ISOnum -->
            "&oslash;", // "&#248;" -- latin small letter o with stroke,
            "&ugrave;", // "&#249;" -- latin small letter u with grave,
            "&uacute;", // "&#250;" -- latin small letter u with acute,
            "&ucirc;",  // "&#251;" -- latin small letter u with circumflex,
            "&uuml;",   // "&#252;" -- latin small letter u with diaeresis,
            "&yacute;", // "&#253;" -- latin small letter y with acute,
            "&thorn;",  // "&#254;" -- latin small letter thorn with,
            "&yuml;",   // "&#255;" -- latin small letter y with diaeresis,
        };

        /*
        public NamedEntitiesFallback(int codepage) : base(codepage) {
            srcEncoding = Encoding.GetEncoding(codepage);
        }
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }            
            
            if (byteIndex == bytes.Length) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }

        
            String str = GetNamedEntity(chars, charIndex, charCount);
            char[] strChars = str.ToCharArray();
            return (srcEncoding.GetBytes(strChars, 0, strChars.Length, bytes, byteIndex));
        }

        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException(
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }

            String str = GetNamedEntity(chars, index, count);
            char[] strChars = str.ToCharArray();
            return (srcEncoding.GetByteCount(strChars, 0, strChars.Length));
        }
        */
        /// <include file='doc\NamedEntitiesFallback.uex' path='docs/doc[@for="NamedEntitiesFallback.NamedEntitiesFallback"]/*' />
        public NamedEntitiesFallback()  {
        }

        /// <include file='doc\NamedEntitiesFallback.uex' path='docs/doc[@for="NamedEntitiesFallback.Fallback"]/*' />
        public override char[] Fallback(char[] chars, int charIndex, int charCount) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
        
            String str = GetNamedEntity(chars, charIndex, charCount);
            return (str.ToCharArray());
        }

        /// <include file='doc\NamedEntitiesFallback.uex' path='docs/doc[@for="NamedEntitiesFallback.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount() {
            //
            // This value is from the longest string in nameEntity array.
            //
            return (8);
        }
        
        internal static String GetNamedEntity(char[] chars, int charIndex, int charCount) {
            String str = "";
            for (int i = 0; i < charCount; i++) {
                char ch = chars[charIndex + i];
                if (ch >= (char)NAME_ENTITY_OFFSET && ch <= (char)NAME_ENTITY_MAX) {
                    str += nameEntity[(int)ch - NAME_ENTITY_OFFSET];
                } else {
                    str += NumericEntitiesFallback.GetNumericEntity(chars, charIndex + i, 1);
                }
            }
            return (str);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\numericentitiesfallback.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    using System;
    

    /// <include file='doc\NumericEntitiesFallback.uex' path='docs/doc[@for="NumericEntitiesFallback"]/*' />
    public class NumericEntitiesFallback : EncodingFallback {       
        /*
        Encoding srcEncoding;
        public NumericEntitiesFallback(int codepage) : base(codepage) {
            srcEncoding = Encoding.GetEncoding(codepage);
        }
        
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }            
            
            if (byteIndex == bytes.Length) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }

            String str = GetNumericEntity(chars, charIndex, charCount);
            char[] strChars = str.ToCharArray();
            return (srcEncoding.GetBytes(strChars, 0, strChars.Length, bytes, byteIndex));
        }

        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException(
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
        
            String str = GetNumericEntity(chars, index, count);
            char[] strChars = str.ToCharArray();
            return (srcEncoding.GetByteCount(strChars, 0, strChars.Length));
        }
        */

        /// <include file='doc\NumericEntitiesFallback.uex' path='docs/doc[@for="NumericEntitiesFallback.Fallback"]/*' />
        public override char[] Fallback(char[] chars, int charIndex, int charCount) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            String str = GetNumericEntity(chars, charIndex, charCount);
            return (str.ToCharArray());
        }

        /// <include file='doc\NumericEntitiesFallback.uex' path='docs/doc[@for="NumericEntitiesFallback.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount() {
            //
            // The max fallback string has the form like "&#12345;", so
            // the max char count is 8.
            // If we support surrogate, we need to increase this.
            return (8);
        }

        internal static String GetNumericEntity(char[] chars, int charIndex, int charCount) {
            String str = "";
            //
            // BUGBUG YSLin: Need to support surrogate here.
            // 
            for (int i = 0; i < charCount; i++) {                
                str += "&#";
                str += (int)chars[charIndex + i];
                str += ";";
            }
            return (str);
        }     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\surrogateencoder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {    
    using System;
    using System.Globalization;

    /*=================================SurrogateEncoder============================
    **
    ** This is used to support encoder operation which recognizes surrogate pair.
    **
    ==============================================================================*/
    
    [Serializable()]
    internal class SurrogateEncoder : Encoder
    {
        private Encoding m_encoding;
        private char m_highSurrogate = '\x0000';

        public SurrogateEncoder(Encoding encoding) {
            this.m_encoding = encoding;
        }

        public override int GetByteCount(char[] chars, int index, int count, bool flush) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (count == 0) return 0;
        
            char[] sourceChars = chars;
            if (m_highSurrogate != '\x0000') {
                sourceChars = new char[count+1];
                sourceChars[0] = m_highSurrogate;
                Array.Copy(chars, index, sourceChars, 1, count);
                index = 0;
                count++;    // Add the high surrogate
            }

            if (StringInfo.IsHighSurrogate(sourceChars[index + count - 1])) {
                return (m_encoding.GetByteCount(sourceChars, index, count-1));
            }
            return (m_encoding.GetByteCount(sourceChars, index, count));            
        }

        public override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex, bool flush) {
            
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (charCount == 0) return 0;
            
            if (byteIndex == bytes.Length) throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));

            
            int result;
            char[] sourceChars = chars;
            if (m_highSurrogate != '\x0000') {
                sourceChars = new char[charCount+1];
                sourceChars[0] = m_highSurrogate;
                Array.Copy(chars, charIndex, sourceChars, 1, charCount);
                charIndex = 0;
                charCount++;    // Add the high surrogate
            }
            
            if (StringInfo.IsHighSurrogate(sourceChars[charIndex + charCount - 1])) {
                m_highSurrogate = chars[charIndex + charCount - 1];
                result = m_encoding.GetBytes(sourceChars, charIndex, charCount-1, bytes, byteIndex);
            } else {
                m_highSurrogate = '\x0000';
                result = m_encoding.GetBytes(sourceChars, charIndex, charCount, bytes, byteIndex);
            }
            return (result);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\unicodeencoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
	using System;
    /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding"]/*' />
    [Serializable] public class UnicodeEncoding : Encoding
    {
        internal bool bigEndian;
        internal bool byteOrderMark;
    
    	// Unicode version 2.0 character size in bytes
    	/// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.CharSize"]/*' />
    	public const int CharSize = 2;


        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.UnicodeEncoding"]/*' />
        public UnicodeEncoding() 
            : this(false, true) {
        }
    
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.UnicodeEncoding1"]/*' />
        public UnicodeEncoding(bool bigEndian, bool byteOrderMark) 
            : base(bigEndian? 1201 : 1200) { //Set the data item.
            this.bigEndian = bigEndian;
            this.byteOrderMark = byteOrderMark;
        }
    
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetByteCount"]/*' />
        public override int GetByteCount(char[] chars, int index, int count) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }

            int byteCount = count * CharSize;
            // check for overflow
            if (byteCount < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return byteCount;
        }

        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetByteCount1"]/*' />
        public override int GetByteCount(String s)
        {
            if (s==null)
                throw new ArgumentNullException("s");

            int byteCount = s.Length * CharSize;
            // check for overflow
            if (byteCount < 0)
                throw new ArgumentOutOfRangeException("s", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));

            return byteCount;
        }

        
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetBytes"]/*' />
        public override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            int byteCount = charCount * CharSize;
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
                throw new ArgumentOutOfRangeException("byteIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (bytes.Length - byteIndex < byteCount) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));            
            }
            if (bigEndian) {
                int charEnd = charIndex + charCount;
                while (charIndex < charEnd) {
                    char ch = chars[charIndex++];
                    bytes[byteIndex++] = (byte)(ch >> 8);
                    bytes[byteIndex++] = (byte)ch;
                }
            }
            else {
                Buffer.InternalBlockCopy(chars, charIndex * CharSize, bytes, byteIndex, byteCount);
            }
            return byteCount;
        }

        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetBytes2"]/*' />
        public override byte[] GetBytes(String s) {
            if (s == null) {
                throw new ArgumentNullException("s",
                    Environment.GetResourceString("ArgumentNull_String"));
            }
            int byteLen = GetByteCount(s);
            byte[] bytes = new byte[byteLen];
            GetBytes(s, 0, s.Length, bytes, 0);
            return bytes;
        }

        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetBytes1"]/*' />
        public override int GetBytes(String s, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            int byteCount = charCount * CharSize;
            if (s == null || bytes == null) {
                throw new ArgumentNullException((s == null ? "s" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (s.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("s",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
                throw new ArgumentOutOfRangeException("byteIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (bytes.Length - byteIndex < byteCount) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
    		if (bigEndian) {
                int charEnd = charIndex + charCount;
                while (charIndex < charEnd) {
                    char ch = s[charIndex++];
                    bytes[byteIndex++] = (byte)(ch >> 8);
                    bytes[byteIndex++] = (byte)ch;
                }
            }
            else {
                // @TODO: Consider pinning the String here and then using a managed
                // memcpy implementation (see __UnmanagedMemoryStream).  This would
                // require a C# compiler that can get an interior pointer to a 
                // String, probably via the fixed statement.  -- BrianGru, 12/6/2000
                s.CopyToByteArray(charIndex, bytes, byteIndex, charCount);
            }
            return byteCount;
        }
    
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetCharCount"]/*' />
        public override int GetCharCount(byte[] bytes, int index, int count) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }        
            if ( bytes.Length - index < count)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }            
            return (count / CharSize);
        }
        
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetChars"]/*' />
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex) {
            int charCount = byteCount / CharSize;
            if (bytes == null || chars == null) {
                throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }        
            if ( bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (charIndex < 0 || charIndex > chars.Length) {
                throw new ArgumentOutOfRangeException("charIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));            
            }
            
            byteCount = charCount * CharSize;
            if (bigEndian) {
                int byteEnd = byteIndex + byteCount;
                while (byteIndex < byteEnd) {
                    int hi = bytes[byteIndex++];
                    int lo = bytes[byteIndex++];
                    chars[charIndex++] = (char)(hi << 8 | lo);
                }
            }
            else {
                Buffer.InternalBlockCopy(bytes, byteIndex, chars, charIndex * CharSize, byteCount);
            }
            return charCount;
        }
    
        /*
        // @TODO: Uncomment this in V1.1.  It works, but we can't do perf work 
        // this late in the game.  -- BrianGru, 7/17/2001
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetString1"]/*' />
        public unsafe override String GetString(byte[] bytes) {
            if (bytes == null)
                throw new ArgumentNullException("bytes");
            if ((bytes.Length & 1) != 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_OddByteCountUnicode"));

            if (bigEndian)
                return base.GetString(bytes);

            fixed(byte* pBytes = bytes)
                return new String((char*) pBytes, 0, bytes.Length >> 1);
        }
        */

        /*
        // @TODO: Uncomment this in V1.1.  It works, but we can't do perf work 
        // this late in the game.  -- BrianGru, 7/17/2001
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetString2"]/*' />
        public unsafe override String GetString(byte[] bytes, int index, int count) {
            if (bytes == null)
                throw new ArgumentNullException("bytes");
            if ((count & 1) != 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_OddByteCountUnicode"));

            if (bigEndian)
                return base.GetString(bytes, index, count);

            fixed(byte* pBytes = bytes)
                return new String((char*) (pBytes + index), 0, count >> 1);
        }
        */

        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetDecoder"]/*' />
        public override System.Text.Decoder GetDecoder() {
            return new Decoder(this);
        }
    
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetPreamble"]/*' />
        public override byte[] GetPreamble()
        {
            if (byteOrderMark) {
                // Note - we must allocate new byte[]'s here to prevent someone
                // from modifying a cached byte[].
                if (bigEndian) 
                    return new byte[2] { 0xfe, 0xff };
                else
                    return new byte[2] { 0xff, 0xfe };
            }
            return emptyByteArray;
        }
    
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetMaxByteCount"]/*' />
        public override int GetMaxByteCount(int charCount) {
            if (charCount < 0) {
               throw new ArgumentOutOfRangeException("charCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            long byteCount = (long)charCount * CharSize;
            if (byteCount > 0x7fffffff)
                throw new ArgumentOutOfRangeException("charCount", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return (int)byteCount;
        }
    
        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount(int byteCount) {
            if (byteCount < 0) {
               throw new ArgumentOutOfRangeException("byteCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            long result = ((long)byteCount + 1) / CharSize;
            if (result > 0x7fffffff) {
                throw new ArgumentOutOfRangeException("byteCount", Environment.GetResourceString("ArgumentOutOfRange_GetCharCountOverflow"));
            }
            return (int)result;
        }

        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.Equals"]/*' />
        public override bool Equals(Object value) {
            UnicodeEncoding uenc = value as UnicodeEncoding;
            if (uenc != null) {
                //
                // Big Endian Unicode has different code page (1201) than small Endian one (1200),
                // so we still have to check m_codePage here.
                //
                return (m_codePage == uenc.m_codePage &&
                        byteOrderMark == uenc.byteOrderMark);
            }
            return (false);
        }

        /// <include file='doc\UnicodeEncoding.uex' path='docs/doc[@for="UnicodeEncoding.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return m_codePage;
        }

        [Serializable]
        private class Decoder : System.Text.Decoder
        {
            private bool bigEndian;
            private int lastByte;
            
            public Decoder(UnicodeEncoding encoding) {
                bigEndian = encoding.bigEndian;
                lastByte = -1;
            }
    
        public override int GetCharCount(byte[] bytes, int index, int count) {
                if (bytes == null) {
                    throw new ArgumentNullException("bytes", 
                        Environment.GetResourceString("ArgumentNull_Array"));
                }
                if (index < 0 || count < 0) {
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                        Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }            
                if (bytes.Length - index < count) {
                    throw new ArgumentOutOfRangeException("bytes",
                        Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                }
                if (lastByte >= 0) count++;
                return count / CharSize;
            }
        
            public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
                char[] chars, int charIndex) {                
                if (bytes == null || chars == null) {
                    throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                        Environment.GetResourceString("ArgumentNull_Array"));
                }
                if (byteIndex < 0 || byteCount < 0) {
                    throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                        Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }        
                if (bytes.Length - byteIndex < byteCount)
                {
                    throw new ArgumentOutOfRangeException("bytes",
                        Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
                }
                if (charIndex < 0 || charIndex > chars.Length) {
                    throw new ArgumentOutOfRangeException("charIndex", 
                        Environment.GetResourceString("ArgumentOutOfRange_Index"));
                }
                int charCount = GetCharCount(bytes, byteIndex, byteCount);
                if (chars.Length - charIndex < charCount) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));            
                }
                
                if (lastByte >= 0) {
                    if (byteCount == 0) return charCount;
                    int nextByte = bytes[byteIndex++];
                    byteCount--;
                    if (bigEndian) {
                        chars[charIndex++] = (char)(lastByte << 8 | nextByte);
                    }
                    else {
                        chars[charIndex++] = (char)(nextByte << 8 | lastByte);
                    }
                    lastByte = -1;
                }
                if ((byteCount & 1) != 0) {
                    lastByte = bytes[byteIndex + --byteCount];
                }
                if (bigEndian) {
                    int byteEnd = byteIndex + byteCount;
                    while (byteIndex < byteEnd) {
                        ushort hi = bytes[byteIndex++];
                        byte lo = bytes[byteIndex++];
                        chars[charIndex++] = (char)(hi << 8 | lo);
                    }
                }
                else {
                    Buffer.InternalBlockCopy(bytes, byteIndex, chars, charIndex * CharSize, byteCount);
                }
                return charCount;
            }
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\utf7encoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {

	using System;
    /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding"]/*' />
    [Serializable()] public class UTF7Encoding : Encoding
    {
        private const String base64Chars =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        // These are the characters that can be directly encoded in UTF7.
        private const String directChars =
            "\t\n\r '(),-./0123456789:?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

        // These are the characters that can be optionally directly encoded in UTF7.
        private const String optionalChars =
            "!\"#$%&*;<=>@[]^_`{|}";

        // The set of base 64 characters.
        private byte[] base64Bytes;
        // The decoded bits for every base64 values. This array has a size of 128 elements.
        // The index is the code point value of the base 64 characters.  The value is -1 if 
        // the code point is not a valid base 64 character.  Otherwise, the value is a value
        // from 0 ~ 63.
        private sbyte[] base64Values;
        // The array to decide if a Unicode code point below 0x80 can be directly encoded in UTF7.
        // This array has a size of 128.
        private bool[] directEncode;

        
    
        private const int UTF7_CODEPAGE=65000;

        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.UTF7Encoding"]/*' />
        public UTF7Encoding() 
            : this(false) {
        }
    
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.UTF7Encoding1"]/*' />
        public UTF7Encoding(bool allowOptionals) 
            : base(UTF7_CODEPAGE) { //Set the data item.
    
            base64Bytes = new byte[64];
            for (int i = 0; i < 64; i++) base64Bytes[i] = (byte)base64Chars[i];
            base64Values = new sbyte[128];
            for (int i = 0; i < 128; i++) base64Values[i] = -1;
            for (int i = 0; i < 64; i++) base64Values[base64Bytes[i]] = (sbyte)i;
            directEncode = new bool[128];
            int count = directChars.Length;
            for (int i = 0; i < count; i++) {
                directEncode[directChars[i]] = true;
            }
            if (allowOptionals) {
                count = optionalChars.Length;
                for (int i = 0; i < count; i++) {
                    directEncode[optionalChars[i]] = true;
                }
            }
        }
    
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetByteCount"]/*' />
        public override int GetByteCount(char[] chars, int index, int count) {
            return GetByteCount(chars, index, count, true, null);
        }
        
        private int GetByteCount(char[] chars, int index, int count,
            bool flush, Encoder encoder) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            int bitCount = -1;
            if (encoder != null) bitCount = encoder.bitCount;
            int end = index + count;
            int byteCount = 0;
            while (index < end && byteCount >= 0) {
                int c = chars[index++];
                if (c < 0x80 && directEncode[c]) {
                    if (bitCount >= 0) {
                        if (bitCount > 0) byteCount++;
                        byteCount++;
                        bitCount = -1;
                    }
                    byteCount++;
                }
                else if (bitCount < 0 && c == '+') {
                    byteCount += 2;
                }
                else {
                    if (bitCount < 0) {
                        byteCount++;
                        bitCount = 0;
                    }
                    bitCount += 16;
                    while (bitCount >= 6) {
                        bitCount -= 6;
                        byteCount++;
                    }
                }
            }
            if (flush && bitCount >= 0) {
                if (bitCount > 0) byteCount++;
                byteCount++;
            }

            // Check for overflows.
            if (byteCount < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));

            return byteCount;
        }
        
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetBytes"]/*' />
        public override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) {
            return GetBytes(chars, charIndex, charCount, bytes, byteIndex, true, null);
        }
    
        private int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex, bool flush, Encoder encoder) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
               throw new ArgumentOutOfRangeException("byteIndex", 
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            int bits = 0;
            int bitCount = -1;
            if (encoder != null) {
                bits = encoder.bits;
                bitCount = encoder.bitCount;
            }
            int charEnd = charIndex + charCount;
            int byteStart = byteIndex;
            try {
                while (charIndex < charEnd) {
                    int c = chars[charIndex++];
                    if (c < 0x80 && directEncode[c]) {
                        if (bitCount >= 0) {
                            if (bitCount > 0) {
                                bytes[byteIndex++] = base64Bytes[bits << 6 - bitCount & 0x3F];
                            }
                            bytes[byteIndex++] = (byte)'-';
                            bitCount = -1;
                        }
                        bytes[byteIndex++] = (byte)c;
                    }
                    else if (bitCount < 0 && c == '+') {
                        bytes[byteIndex++] = (byte)'+';
                        bytes[byteIndex++] = (byte)'-';
                    }
                    else {
                        if (bitCount < 0) {
                            bytes[byteIndex++] = (byte)'+';
                            bitCount = 0;
                        }
                        bits = bits << 16 | c;
                        bitCount += 16;
                        while (bitCount >= 6) {
                            bitCount -= 6;
                            bytes[byteIndex++] = base64Bytes[bits >> bitCount & 0x3F];
                        }
                    }
                }
                if (flush && bitCount >= 0) {
                    if (bitCount > 0) {
                        bytes[byteIndex++] = base64Bytes[bits << 6 - bitCount & 0x3F];
                    }
                    bytes[byteIndex++] = (byte)'-';
                    bitCount = -1;
                }
            }
            catch (IndexOutOfRangeException) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
            if (encoder != null) {
                encoder.bits = bits;
                encoder.bitCount = bitCount;
            }
            return byteIndex - byteStart;
        }
    
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetCharCount"]/*' />
        public override int GetCharCount(byte[] bytes, int index, int count) {
            return GetCharCount(bytes, index, count, null);
        }
        
        private int GetCharCount(byte[] bytes, int index, int count, Decoder decoder) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }                                                             
            if (bytes.Length - index < count) {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            int bitCount = -1;
            bool firstByte = false;
            if (decoder != null) {
                bitCount = decoder.bitCount;
                firstByte = decoder.firstByte;
            }
            int end = index + count;
            int charCount = 0;
            while (index < end) {
                int b = bytes[index++];
                if (bitCount >= 0) {
                    // We are in modified base 64 encoding.
                    if (b >= 0x80) {
                        // This is not a valid base 64 byte. 
                        // Terminate shifted-sequence and emit this byte.
                        charCount++;
                        bitCount = -1;
                    } else if (base64Values[b] >= 0) { 
                        firstByte = false;
                        bitCount += 6;
                        if (bitCount >= 16) {
                            charCount++;
                            bitCount -= 16;
                        }
                    }
                    else {
                        // When we are here, b is uder 0x80, and not a valid base 64 byte.
                        // If b is '-', decode as '-'. Otherwise, zero-extend the byte and
                        // terminate the shift sequence.
                        if (b == '-') {
                            if (firstByte) { 
                                charCount++;
                            }
                            // Absorb the shift-out mark at the end of the shifted-sequence.
                        } else {
                            charCount++;
                        }
                        
                        bitCount = -1;
                    }
                }
                else if (b == '+') {
                    bitCount = 0;
                    firstByte = true;
                }
                else {
                    charCount++;
                }
            }
            return charCount;
        }
    
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetChars"]/*' />
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex) {
            return GetChars(bytes, byteIndex, byteCount, chars, charIndex, null);
        }
    
        private int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex, Decoder decoder) {
            if (bytes == null || chars == null) {
                throw new ArgumentNullException((bytes == null ? "bytes" : "chars"), 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }        
            if ( bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (charIndex < 0 || charIndex > chars.Length) {
                throw new ArgumentOutOfRangeException("charIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            int bits = 0;
            int bitCount = -1;
            bool firstByte = false;
            if (decoder != null) {
                bits = decoder.bits;
                bitCount = decoder.bitCount;
                firstByte = decoder.firstByte;
            }
            int byteEnd = byteIndex + byteCount;
            int charStart = charIndex;
            try {
                while (byteIndex < byteEnd) {
                    int b = bytes[byteIndex++];
                    int c = -1;
                    if (bitCount >= 0) {
                        //
                        // Modified base 64 encoding.
                        //
                        sbyte v;
                        if (b >= 0x80) {
                            // We need this check since the base64Values[b] check below need b <= 0x7f.
                            // This is not a valid base 64 byte.  Terminate the shifted-sequence and
                            // emit this byte.
                            c = b;
                            bitCount = -1;
                        } else if ((v = base64Values[b]) >=0) {
                            firstByte = false;
                            bits = bits << 6 | ((byte)v);
                            bitCount += 6;
                            if (bitCount >= 16) {
                                c = (bits >> (bitCount - 16)) & 0xFFFF;
                                bitCount -= 16;
                            }
                        } else {
                            if (b == '-') {
                                //
                                // The encoding for '+' is "+-".
                                //
                                if (firstByte) c = '+';
                            }
                            else {
                                // According to the RFC 1642 and the example code of UTF-7
                                // in Unicode 2.0, we should just zero-extend the invalid UTF7 byte
                                c = b;
                            }
                            //
                            // End of modified base 64 encoding block.
                            //
                            bitCount = -1;
                        }
                    }
                    else if (b == '+') {
                        //
                        // Found the start of a modified base 64 encoding block or a plus sign.
                        //
                        bitCount = 0;
                        firstByte = true;
                    } else {
                        c = b;
                    }
                    if (c >= 0) {
                        chars[charIndex++] = (char)c;
                    }
                    
                }
            }
            catch (IndexOutOfRangeException) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
            if (decoder != null) {
                decoder.bits = bits;
                decoder.bitCount = bitCount;
                decoder.firstByte = firstByte;
            }
            return charIndex - charStart;
        }
    
        //        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.CodePage"]/*' />
//          public override int CodePage {
//              get {
//                  return (UTF7_CODEPAGE);
//              }
//          }
    
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetDecoder"]/*' />
        public override System.Text.Decoder GetDecoder() {
            return new Decoder(this);
        }
    
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetEncoder"]/*' />
        public override System.Text.Encoder GetEncoder() {
            return new Encoder(this);
        }
        
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetMaxByteCount"]/*' />
        public override int GetMaxByteCount(int charCount) {
            if (charCount < 0) {
               throw new ArgumentOutOfRangeException("charCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            if (charCount == 0) {
                return (0);
            }
            // Suppose that every char can not be direct-encoded, we know that
            // a byte can encode 6 bits of the Unicode character.  And we will
            // also need two extra bytes for the shift-in ('+') and shift-out ('-') mark.
            // Therefore, the max byte should be:
            // byteCount = 2 + Math.Ceiling((double)charCount * 16 / 6);
            long byteCount = 2 + (((long)charCount) * 8 + 2) /3;
            
            // check for overflow
            if (byteCount > 0x7fffffff)
                throw new ArgumentOutOfRangeException("charCount", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return (int)byteCount;
        }
    
        /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount(int byteCount) {
            if (byteCount < 0) {
               throw new ArgumentOutOfRangeException("byteCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            return byteCount;
        }
    
        [Serializable()]
        private class Decoder : System.Text.Decoder
        {
            private UTF7Encoding encoding;
            /*private*/ internal int bits;
            /*private*/ internal int bitCount;
            /*private*/ internal bool firstByte;
    
            public Decoder(UTF7Encoding encoding) {
                this.encoding = encoding;
                bitCount = -1;
            }
    
            /// <include file='doc\UTF7Encoding.uex' path='docs/doc[@for="UTF7Encoding.Decoder.GetCharCount"]/*' />
        public override int GetCharCount(byte[] bytes, int index, int count) {
                return encoding.GetCharCount(bytes, index, count, this);
            }
    
            public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
                char[] chars, int charIndex) {
                return encoding.GetChars(bytes, byteIndex, byteCount,
                    chars, charIndex, this);
            }
        }
    
        [Serializable()] 
        private class Encoder : System.Text.Encoder
        {
            private UTF7Encoding encoding;
            /*private*/ internal int bits;
            /*private*/ internal int bitCount;
    
            public Encoder(UTF7Encoding encoding) {
                this.encoding = encoding;
                bitCount = -1;
            }
    
            public override int GetByteCount(char[] chars, int index, int count, bool flush) {
                return encoding.GetByteCount(chars, index, count, flush, this);
            }
    
            public override int GetBytes(char[] chars, int charIndex, int charCount,
                byte[] bytes, int byteIndex, bool flush) {
                return encoding.GetBytes(chars, charIndex, charCount,
                    bytes, byteIndex, flush, this);
            }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\utf8encoding.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Text {
    
    using System;
    using System.Globalization;
    // Encodes text into and out of UTF-8.  UTF-8 is a way of writing
    // Unicode characters with variable numbers of bytes per character, 
    // optimized for the lower 127 ASCII characters.  It's an efficient way
    // of encoding US English in an internationalizable way.
    // 
    // The UTF-8 byte order mark is simply the Unicode byte order mark
    // (0xFEFF) written in UTF-8 (0xEF 0xBB 0xBF).  The byte order mark is
    // used mostly to distinguish UTF-8 text from other encodings, and doesn't
    // switch the byte orderings.
    /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding"]/*' />
    [Serializable()]
    public class UTF8Encoding : Encoding {
        /*
            bytes   bits    UTF-8 representation
            -----   ----    -----------------------------------
            1        7      0vvvvvvv
            2       11      110vvvvv 10vvvvvv
            3       16      1110vvvv 10vvvvvv 10vvvvvv
            4       21      11110vvv 10vvvvvv 10vvvvvv 10vvvvvv
            -----   ----    -----------------------------------
    
            Surrogate:
            Real Unicode value = (HighSurrogate - 0xD800) * 0x400 + (LowSurrogate - 0xDC00) + 0x10000
         */
    
        private const int UTF8_CODEPAGE=65001;

        // Yes, the idea of emitting U+FEFF as a UTF-8 identifier has made it into
        // the standard.
        private bool emitUTF8Identifier;

        private bool isThrowException = false;

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.UTF8Encoding"]/*' />
        public UTF8Encoding(): this(false) {
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.UTF8Encoding1"]/*' />
        public UTF8Encoding(bool encoderShouldEmitUTF8Identifier): 
            this(encoderShouldEmitUTF8Identifier, false) {
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.UTF8Encoding2"]/*' />
        public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes): 
            base(UTF8_CODEPAGE) {
            this.emitUTF8Identifier = encoderShouldEmitUTF8Identifier;
            this.isThrowException = throwOnInvalidBytes;
        }
        
        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetByteCount"]/*' />
        public override int GetByteCount(char[] chars, int index, int count) {
            return (GetByteCount(chars, index, count, null));
        }
        
        internal unsafe int GetByteCount(char[] chars, int index, int count, UTF8Encoder encoder) {
            if (chars == null) {
                throw new ArgumentNullException("chars", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"),
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - index < count) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            
            int retVal = -1;
            if (chars.Length == 0) {
                return 0;
            }

            fixed (char *p = chars) {
                retVal = GetByteCount(p, index, count, encoder);
            }
            BCLDebug.Assert(retVal!=-1, "[UTF8Encoding.GetByteCount]retVal!=-1");
            return retVal;
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetByteCount1"]/*' />
        public unsafe override int GetByteCount(String chars) {
            if (chars==null)
                throw new ArgumentNullException("chars");
            int retVal = -1;
            fixed (char *p = chars) {
                retVal = GetByteCount(p, 0, chars.Length, null);
            }

            BCLDebug.Assert(retVal!=-1, "[UTF8Encoding.GetByteCount]retVal!=-1");
            return retVal;
        }
       
        internal unsafe int GetByteCount(char *chars, int index, int count, UTF8Encoder encoder) {

            BCLDebug.Assert(chars!=null, "[UTF8Encoding.GetByteCount]chars!=null");

            int end = index + count;
            int byteCount = 0;
    
            bool inSurrogate;

            if (encoder == null || !encoder.storedSurrogate) {
                inSurrogate = false;
            }
            else {
                inSurrogate = true;
            }
    
            while (index < end && byteCount >= 0) {
                char ch = chars[index++];

                if (inSurrogate) {
                    //
                    // In previous char, we encounter a high surrogate, so we are expecting a low surrogate here.
                    //
                    if (StringInfo.IsLowSurrogate(ch)) {
                        inSurrogate = false;
                        //
                        // One surrogate pair will be translated into 4 bytes UTF8.
                        //
                        byteCount += 4;
                    } 
                    else if (StringInfo.IsHighSurrogate(ch)) {
                        // We have two high surrogates.
                        if (isThrowException) {
                            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidHighSurrogate", (index - 1)), 
                                                        "chars");                                                        
                        }
                        // Encode the previous high-surrogate char.
                        byteCount += 3;
                        // The isSurrogate is still true, because this could be the start of another valid surrogate pair.
                    } else {
                        if (isThrowException) {
                            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidHighSurrogate", (index - 1)), 
                                                        "chars");                                                        
                        }
                        // Encode the previous high-surrogate char.
                        byteCount += 3;
                        // Not a surrogate. Put the char back so that we can restart the encoding.
                        inSurrogate = false;
                        index--;
                    }
                } else if (ch < 0x0080)
                    byteCount++;
                else if (ch < 0x0800) {
                    byteCount += 2;
                } else {
                    if (StringInfo.IsHighSurrogate(ch)) {
                        //
                        // Found the start of a surrogate.
                        //
                        inSurrogate = true;
                    }
                    else if (StringInfo.IsLowSurrogate(ch) && isThrowException) {
                        //
                        // Found a low surrogate without encountering a high surrogate first.
                        //
                        throw new ArgumentException( 
                                                    String.Format(Environment.GetResourceString("Argument_InvalidLowSurrogate"), (index - 1)), "chars");
                    }
                    else {
                        byteCount += 3;
                    }
                }
            }

            // Check for overflows.
            if (byteCount < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));

            if (inSurrogate) {
                if (encoder == null || encoder.mustFlush) {
                    if (isThrowException) {
                        throw new ArgumentException( 
                            String.Format(Environment.GetResourceString("Argument_InvalidHighSurrogate"), (index - 1)), "chars");
                    }
                    byteCount += 3;
                }
            }
            return byteCount;
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetBytes"]/*' />
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex) {
            return GetBytes(chars, charIndex, charCount, bytes, byteIndex, null);
        }

        private void EncodeThreeBytes(int ch, byte[] bytes, ref int byteIndex) {
            bytes[byteIndex++] = (byte)(0xE0 | ch >> 12 & 0x0F);
            bytes[byteIndex++] = (byte)(0x80 | ch >> 6 & 0x3F);
            bytes[byteIndex++] = (byte)(0x80 | ch & 0x3F);
        }       
        
        private unsafe int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, UTF8Encoder encoder) {
            if (chars == null || bytes == null) {
                throw new ArgumentNullException((chars == null ? "chars" : "bytes"), 
                      Environment.GetResourceString("ArgumentNull_Array"));
            }        
            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (chars.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("chars",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
                throw new ArgumentOutOfRangeException("byteIndex",
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }

            int retVal = -1;
            if (chars.Length==0) {
                return 0;
            }
            fixed (char *p = chars) {
                retVal = GetBytes(p, charIndex, charCount, bytes, byteIndex, encoder);
            }
            BCLDebug.Assert(retVal!=-1, "[UTF8Encoding.GetByteCount]retVal!=-1");
            return retVal;
        }


        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetBytes2"]/*' />
        public override byte[] GetBytes(String s) {
            if (s == null) {
                throw new ArgumentNullException("s",
                    Environment.GetResourceString("ArgumentNull_String"));
            }
            int byteLen = GetByteCount(s);
            byte[] bytes = new byte[byteLen];
            GetBytes(s, 0, s.Length, bytes, 0);
            return bytes;
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetBytes1"]/*' />
        public unsafe override int GetBytes(String s, int charIndex, int charCount, byte[] bytes, int byteIndex) {
            if (s == null || bytes == null) {
                throw new ArgumentNullException((s == null ? "s" : "bytes"),
                    Environment.GetResourceString("ArgumentNull_String"));
            }

            if (charIndex < 0 || charCount < 0) {
                throw new ArgumentOutOfRangeException((charIndex<0 ? "charIndex" : "charCount"), 
                      Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (s.Length - charIndex < charCount) {
                throw new ArgumentOutOfRangeException("s",
                      Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
            }
            if (byteIndex < 0 || byteIndex > bytes.Length) {
                throw new ArgumentOutOfRangeException("byteIndex",
                     Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            
            int retVal = -1;
            fixed (char *p = s) {
                retVal = GetBytes(p, charIndex, charCount, bytes, byteIndex, null);
            }
            BCLDebug.Assert(retVal!=-1, "[UTF8Encoding.GetByteCount]retVal!=-1");
            return retVal;
        }
    
        private unsafe int GetBytes(char *chars, int charIndex, int charCount, byte[] bytes, int byteIndex, UTF8Encoder encoder) {
            BCLDebug.Assert(chars!=null, "[UTF8Encoding.GetBytes]chars!=null");

            int charEnd = charIndex + charCount;
            int byteStart = byteIndex;

            int surrogateChar;
            if (encoder == null || !encoder.storedSurrogate) {
                surrogateChar = -1;
            }
            else {
                surrogateChar = encoder.surrogateChar;
                encoder.storedSurrogate = false;
            }

            try {
                while (charIndex < charEnd) {
                    char ch = chars[charIndex++];
                    //
                    // In previous byte, we encounter a high surrogate, so we are expecting a low surrogate here.
                    //
                    if (surrogateChar > 0) {
                        if (StringInfo.IsLowSurrogate(ch)) {
                            // We have a complete surrogate pair.
                            surrogateChar = (surrogateChar - CharacterInfo.HIGH_SURROGATE_START) << 10;    // (ch - 0xd800) * 0x400
                            surrogateChar += (ch - CharacterInfo.LOW_SURROGATE_START);
                            surrogateChar += 0x10000;
                            bytes[byteIndex++] = (byte)(0xF0 | (surrogateChar >> 18) & 0x07);    
                            bytes[byteIndex++] = (byte)(0x80 | (surrogateChar >> 12) & 0x3F);    
                            bytes[byteIndex++] = (byte)(0x80 | (surrogateChar >> 6) & 0x3F);     
                            bytes[byteIndex++] = (byte)(0x80 | surrogateChar & 0x3F);                                      
                            surrogateChar = -1;
                        } else if (StringInfo.IsHighSurrogate(ch)) {
                            // We have two high surrogate.
                            if (isThrowException) {
                                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidHighSurrogate", (charIndex - 1)), 
                                                            "chars"); 
                            }
                            // Encode the previous high-surrogate char.
                            EncodeThreeBytes(surrogateChar, bytes, ref byteIndex);
                            surrogateChar = ch;
                        } else {
                            if (isThrowException) {
                                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidHighSurrogate", (charIndex - 1)), 
                                                            "chars"); 
                            }

                            // Encode the previous high-surrogate char.
                            EncodeThreeBytes(surrogateChar, bytes, ref byteIndex);
                            // Not a surrogate. Put the char back so that we can restart the encoding.
                            surrogateChar = -1;
                            charIndex--;
                        }                        
                    } else if (ch < 0x0080) {
                        bytes[byteIndex++] = (byte)ch;
                    } else if (ch < 0x0800) {
                        bytes[byteIndex++] = (byte)(0xC0 | ch >> 6 & 0x1F);
                        bytes[byteIndex++] = (byte)(0x80 | ch & 0x3F);
                    } else if (StringInfo.IsHighSurrogate(ch)) {
                        //
                        // Found the start of a surrogate.
                        //
                        surrogateChar = ch;
                    } else if (StringInfo.IsLowSurrogate(ch) && isThrowException) {
                        throw new ArgumentException( 
                            String.Format(Environment.GetResourceString("Argument_InvalidLowSurrogate"), (charIndex - 1)), "chars"); 
                    } else { //we now know that the char is >=0x0800 and isn't a high surrogate
                        bytes[byteIndex++] = (byte)(0xE0 | ch >> 12 & 0x0F);
                        bytes[byteIndex++] = (byte)(0x80 | ch >> 6 & 0x3F);
                        bytes[byteIndex++] = (byte)(0x80 | ch & 0x3F);
                    }
                }
                if (surrogateChar > 0) {
                    if (encoder != null && !encoder.mustFlush) {
                        encoder.surrogateChar = surrogateChar;
                        encoder.storedSurrogate = true;
                    }
                    else {
                        if (isThrowException) {
                            throw new ArgumentException(
                                                    String.Format(Environment.GetResourceString("Argument_InvalidHighSurrogate"), (charIndex - 1)), "chars");
                        }
                        EncodeThreeBytes(surrogateChar, bytes, ref byteIndex);
                    }
                }                
            } catch (IndexOutOfRangeException) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }

            return byteIndex - byteStart;
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetCharCount"]/*' />
        public override int GetCharCount(byte[] bytes, int index, int count) {
            return GetCharCount(bytes, index, count, null);
        }
        
        internal virtual int GetCharCount(byte[] bytes, int index, int count, UTF8Decoder decoder) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes", 
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (index < 0 || count < 0) {
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }                                                             
            if (bytes.Length - index < count) {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            int charCount = 0;
            int trailCount = 0;
            
            // Indicate the current chunk of bytes is a 2-byte, 3-byte or 4-byte UTF8 sequence.
            // This is used to detect non-shortest form.
            // It will be reset to 0 when the 2nd byte of the UTF8 sequence is read, so that
            // we don't check for non-shortest form again.
            int byteSequence = 0;   
            bool isSurrogate = false;
            int bits = 0;
            if (decoder != null) {
                trailCount = decoder.trailCount;
                isSurrogate = decoder.isSurrogate;
                byteSequence = decoder.byteSequence;
                bits = decoder.bits;
            }

            int end = index + count;
            while (index < end) {
                byte b = bytes[index++];
                if (trailCount == 0) {
                    if ((b & 0x80) == 0) {
                        // This is an ASCII.
                        charCount++;
                    } else {
                        byte temp = b;
                        while ((temp & 0x80) != 0) {
                            temp <<= 1;
                            trailCount++;
                        }
                        switch (trailCount) {
                            case 1:
                                trailCount = 0;
                                break;
                            case 2:
                                // Make sure that bit 8 ~ bit 11 is not all zero.
                                // 110XXXXx 10xxxxxx
                                if ((b & 0x1e) == 0) {
                                    trailCount = 0;
                                }
                                break;
                            case 3:
                                byteSequence = 3;
                                break;
                            case 4:
                                isSurrogate = true;
                                byteSequence = 4;
                                break;
                            default:
                                trailCount = 0;
                                break;
                        }
                        if (trailCount == 0) {
                            if (isThrowException) {
                                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), index-1));
                            }
                        } else {
                            bits = temp >> trailCount;
                            trailCount--;
                        } 
                    }                   
                } else {
                    // We are expecting to see trailing bytes like 10vvvvvv
                    if ((b & 0xC0) != 0x80) {
                        // If not, this is NOT a valid sequence.
                        if (isThrowException) {
                            throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), index-1));
                        }
                        index--;
                        trailCount = 0;
                        isSurrogate = false;
                    } else {
                        switch (byteSequence) {
                            case 3:
                                // Check 3-byte sequence for non-shortest form.
                                // 1110XXXX 10Xxxxxx 10xxxxxx                                    
                                if (bits == 0 && (b & 0x20) == 0) {
                                    if (isThrowException) {
                                        throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), index-1));
                                    }
                                    trailCount = -1;
                                }
                                // We are done checking the non-shortest form, reset byteSequence to 0, so that we don't
                                // do the extra check for the remaining byte of the 3-byte chunk.
                                byteSequence = 0;
                                break;
                            case 4:
                                // Check 4-byte sequence for non-shortest form.
                                // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx
                                if (bits == 0) {
                                    if ((b & 0x30) == 0) {
                                        if (isThrowException) {
                                            throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), index-1));
                                        }
                                        trailCount = -1;
                                    }
                                } else if ((bits & 0x04) != 0) {
                                    // Make sure that the resulting Unicode is within the valid surrogate range.
                                    // The 4 byte code sequence can hold up to 21 bits, and the maximum valid code point ragne
                                    // that Unicode (with surrogate) could represent are from U+000000 ~ U+10FFFF.
                                    // Therefore, if the 21 bit (the most significant bit) is 1, we should verify that the 17 ~ 20
                                    // bit are all zero.
                                    // I.e., in 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx,
                                    // XXXXX can only be 10000.
                                    if ((bits & 0x03) != 0 || (b & 0x30) != 0) {
                                        if (isThrowException) {
                                            throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), index-1));
                                        }
                                        trailCount = -1;
                                    }
                                }
                                byteSequence = 0;
                                break;
                        }
                    
                        if (--trailCount == 0) {
                            charCount++;
                            if (isSurrogate) {
                                charCount++;
                                isSurrogate = false;
                            }
                        }
                    }
                }
            }
            return charCount;
        }
        
        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetChars"]/*' />
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex) {
            return GetChars(bytes, byteIndex, byteCount, chars, charIndex, null);
        }
    

        internal virtual int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, UTF8Decoder decoder) {
            if (bytes == null || chars == null) {
                throw new ArgumentNullException(bytes == null ? "bytes" : "chars",
                    Environment.GetResourceString("ArgumentNull_Array"));
            }
            if (byteIndex < 0 || byteCount < 0) {
                throw new ArgumentOutOfRangeException((byteIndex<0 ? "byteIndex" : "byteCount"), 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }        
            if ( bytes.Length - byteIndex < byteCount)
            {
                throw new ArgumentOutOfRangeException("bytes",
                    Environment.GetResourceString("ArgumentOutOfRange_IndexCountBuffer"));
            }
            if (charIndex < 0 || charIndex > chars.Length) {
                throw new ArgumentOutOfRangeException("charIndex", 
                    Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            int bits = 0;
            int trailCount = 0;
            bool isSurrogate = false;
            
            // Indicate the current chunk of bytes is a 2-byte, 3-byte or 4-byte UTF8 sequence.
            // This is used to detect non-shortest form.
            // It will be reset to 0 when the 2nd byte of the UTF8 sequence is read, so that
            // we don't check for non-shortest form again.            
            int byteSequence = 0;
            if (decoder != null) {
                bits = decoder.bits;
                trailCount = decoder.trailCount;
                isSurrogate = decoder.isSurrogate;
                byteSequence = decoder.byteSequence;
            }
            int byteEnd = byteIndex + byteCount;
            int charStart = charIndex;
            try {
                while (byteIndex < byteEnd) {
                    byte b = bytes[byteIndex++];
                    if (trailCount == 0) {
                        //
                        // We are not at a trailing byte.
                        //
                        if ((b & 0x80) == 0) {
                            // This is the ASCII case.
                            //   1        7      0vvvvvvv
                            //
                            // Found an ASCII character.
                            //
                            chars[charIndex++] = (char)b;
                        } else {
                            // Check if this is a valid starting byte.
                            byte temp = (byte)b;
                            while ((temp & 0x80) != 0) {
                                temp <<= 1;
                                trailCount++;
                            }
                            switch (trailCount) {
                                case 1:
                                    trailCount = 0;
                                    break;
                                case 2:
                                    // Make sure that bit 8 ~ bit 11 is not all zero.
                                    // 110XXXXx 10xxxxxx
                                    if ((b & 0x1e) == 0) {
                                        trailCount = 0;
                                    }
                                    break;
                                case 3:
                                    byteSequence = 3;
                                    break;
                                case 4:
                                    //
                                    // This is a surrogate unicode pair
                                    //
                                    byteSequence = 4;
                                    break;
                                default:
                                    trailCount = 0;
                                    break;
                            }
                            if (trailCount == 0) {
                                if (isThrowException) {
                                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), byteIndex-1));
                                }
                            } else {
                                isSurrogate = (trailCount == 4);
                                bits = temp >> trailCount;
                                trailCount--;
                        }                        
                    }
                    } else {
                        // We are expecting to see bytes like 10vvvvvv
                        if ((b & 0xC0) != 0x80) {
                            // If not, this is NOT a valid sequence.
                            if (isThrowException) {
                                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), byteIndex-1));
                            }
                            // At this point, we are seeing an invalid trailing byte.
                            // However, this can be a valid starting byte for another UTF8 byte sequence (e.g.
                            // this character could be under 0x7f, or a valid leading byte like 110xxxxx).
                            // So let's put the current byte back, and try to see if this is a valid byte
                            // for another UTF8 byte sequence.
                            byteIndex--;
                            bits = 0;
                            trailCount = 0;
                        } else {                            
                            switch (byteSequence) {
                                case 3:
                                    // Check 3-byte sequence for non-shortest form.
                                    // 1110XXXX 10Xxxxxx 10xxxxxx                                    
                                    if (bits == 0 && (b & 0x20) == 0) {
                                        if (isThrowException) {
                                            throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), byteIndex-1));
                                        }
                                        trailCount = -1;
                                    }
                                    // Rest byteSequence to zero since we are done with non-shortest form check.
                                    byteSequence = 0;
                                    break;
                                case 4:                                        
                                    // Check 4-byte sequence for non-shortest form.
                                    // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx
                                    if (bits == 0) {
                                        if ((b & 0x30) == 0) {
                                            if (isThrowException) {
                                                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), byteIndex-1));
                                            }
                                            trailCount = -1;
                                        }
                                    } else if ((bits & 0x04) != 0) {
                                        // Make sure that the resulting Unicode is within the valid surrogate range.
                                        // The 4 byte code sequence can hold up to 21 bits, and the maximum valid code point ragne
                                        // that Unicode (with surrogate) could represent are from U+000000 ~ U+10FFFF.
                                        // Therefore, if the 21 bit (the most significant bit) is 1, we should verify that the 17 ~ 20
                                        // bit are all zero.
                                        // I.e., in 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx,
                                        // XXXXX can only be 10000.
                                        if ((bits & 0x03) != 0 || (b & 0x30) != 0) {
                                            if (isThrowException) {
                                                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidByteSequence"), byteIndex-1));
                                            }
                                            trailCount = -1;
                                        }
                                    }
                                    byteSequence = 0;
                                    break;
                            }
                            if (--trailCount >= 0) {
                                bits = bits << 6 | (b & 0x3F);
                                if (trailCount == 0) {
                                    if (!isSurrogate) {
                                        chars[charIndex++] = (char)bits;
                                    }
                                    else {
                                        //
                                        // bits >= 0x10000, use surrogate.
                                        //
                                        chars[charIndex++] = (char)(0xD7C0 + (bits >> 10));
                                        chars[charIndex++] = (char)(CharacterInfo.LOW_SURROGATE_START + (bits & 0x3FF));
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (IndexOutOfRangeException) {
                throw new ArgumentException(Environment.GetResourceString("Argument_ConversionOverflow"));
            }
            if (decoder != null) {
                decoder.bits = bits;
                decoder.trailCount = trailCount;
                decoder.isSurrogate = isSurrogate;
                decoder.byteSequence = byteSequence;
            }
            return charIndex - charStart;
        }
                
        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetDecoder"]/*' />
        public override Decoder GetDecoder() {
            return new UTF8Decoder(this);
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetEncoder"]/*' />
        public override Encoder GetEncoder() {
            return new UTF8Encoder(this);
        }
    
        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetMaxByteCount"]/*' />
        public override int GetMaxByteCount(int charCount) {
            if (charCount < 0) {
               throw new ArgumentOutOfRangeException("charCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            long byteCount = (long)charCount * 4;
            if (byteCount > 0x7fffffff)
                throw new ArgumentOutOfRangeException("charCount", Environment.GetResourceString("ArgumentOutOfRange_GetByteCountOverflow"));
            return (int)byteCount;
        }
    
        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetMaxCharCount"]/*' />
        public override int GetMaxCharCount(int byteCount) {
            if (byteCount < 0) {
               throw new ArgumentOutOfRangeException("byteCount", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }
            return byteCount;
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetPreamble"]/*' />
        public override byte[] GetPreamble()
        {
            if (emitUTF8Identifier) {
                // Allocate new array to prevent users from modifying it.
                return new byte[3] { 0xEF, 0xBB, 0xBF };
            }
            else
                return Encoding.emptyByteArray;
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.Equals"]/*' />
        public override bool Equals(Object value) {
            UTF8Encoding that = value as UTF8Encoding;
            if (that != null) {
                return (emitUTF8Identifier == that.emitUTF8Identifier);
            }
            return (false);
        }

        /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.GetHashCode"]/*' />
        public override int GetHashCode() {
            //Not great distribution, but this is relatively unlikely to be used as the key in a hashtable.
            return UTF8_CODEPAGE + (isThrowException?1:0) + (emitUTF8Identifier?1:0);
        }

        [Serializable]
        internal class UTF8Encoder : Encoder
        {
            private UTF8Encoding encoding;
            // We must save a high surrogate value until the next call, looking
            // for a low surrogate value.  surrogateChar is the bitshifted value,
            // which can validly be 0.  Since it can be 0, we need storedSurrogate.
            internal int surrogateChar;
            internal bool storedSurrogate;
            // The mustFlush parameter means whether we should throw for a dangling
            // high surrogate at the end of the char[].  It is only true when
            // the user of this encoding is writing the last block.
            internal bool mustFlush;

            public UTF8Encoder(UTF8Encoding encoding) {
                this.encoding = encoding;
                surrogateChar = 0;
                storedSurrogate = false;
            }
    
            public override int GetByteCount(char[] chars, int index, int count, bool flush) {
                mustFlush = flush;
                return encoding.GetByteCount(chars, index, count, this);
            }
    
            public override int GetBytes(char[] chars, int charIndex, int charCount,
                byte[] bytes, int byteIndex, bool flush) {
                mustFlush = flush;
                return encoding.GetBytes(chars, charIndex, charCount, bytes, byteIndex, this);
            }
        }
    
        [Serializable()]
        internal class UTF8Decoder : Decoder
        {
            private UTF8Encoding encoding;
            internal int bits;
            internal int trailCount;
            // We need to maintain the status that if we are decoding a surrogate (which has 4-byte UTF8), so
            // that GetCharCount() can generate correct char count.
            // The flag is needed because GetCharCount(), unlike GetChars(), does not really calculate the bits, so it has no way
            // to know if the decoder bytes is a surrogate or not.
            internal bool isSurrogate;
            internal int byteSequence;
    
            public UTF8Decoder(UTF8Encoding encoding) {
                this.encoding = encoding;
            }
    
            /// <include file='doc\UTF8Encoding.uex' path='docs/doc[@for="UTF8Encoding.UTF8Decoder.GetCharCount"]/*' />
            public override int GetCharCount(byte[] bytes, int index, int count) {
                return encoding.GetCharCount(bytes, index, count, this);
            }
        
            public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
                char[] chars, int charIndex) {
                return encoding.GetChars(bytes, byteIndex, byteCount, chars,
                    charIndex, this);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\autoresetevent.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: AutoResetEvent	
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: An example of a WaitHandle class
**
** Date: August, 1999
**
=============================================================================*/
namespace System.Threading {
    
	using System;
	using System.Runtime.CompilerServices;
    /// <include file='doc\AutoResetEvent.uex' path='docs/doc[@for="AutoResetEvent"]/*' />
    public sealed class AutoResetEvent : WaitHandle
    {
        /// <include file='doc\AutoResetEvent.uex' path='docs/doc[@for="AutoResetEvent.AutoResetEvent"]/*' />
        public AutoResetEvent(bool initialState)
    	{
    		IntPtr eventHandle = CreateAutoResetEventNative(initialState);	// throws an exception if failed to create an event
    	    SetHandleInternal(eventHandle);
    	}
    	/// <include file='doc\AutoResetEvent.uex' path='docs/doc[@for="AutoResetEvent.Reset"]/*' />
    	public bool Reset()
    	{
            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                {
    	  	        bool res = ResetAutoResetEventNative(Handle);
    		        return res;
                }
                else
                {
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }
    	}
    
    	/// <include file='doc\AutoResetEvent.uex' path='docs/doc[@for="AutoResetEvent.Set"]/*' />
    	public bool Set()
    	{
            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                {
      	 	        return SetAutoResetEventNative(Handle);
                }
                else
                {
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }
    	}
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern private static  IntPtr CreateAutoResetEventNative(bool initialState);

		[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	extern private static   bool  ResetAutoResetEventNative(IntPtr handle);

		[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	extern private static   bool  SetAutoResetEventNative(IntPtr handle);
    }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\iobjecthandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  IObjectHandle
**
** Author: 
**
** IObjectHandle defines the interface for unwrapping objects.
** Objects that are marshal by value object can be returned through 
** an indirection allowing the caller to control when the
** object is loaded into their domain. The caller can unwrap
** the object from the indirection through this interface.
**
** Date:  January 24, 2000
** 
===========================================================*/
namespace System.Runtime.Remoting {

	using System;
	using System.Runtime.InteropServices;

    /// <include file='doc\IObjectHandle.uex' path='docs/doc[@for="IObjectHandle"]/*' />
	[ InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
      GuidAttribute("C460E2B4-E199-412a-8456-84DC3E4838C3") ]
    public interface IObjectHandle {
        /// <include file='doc\IObjectHandle.uex' path='docs/doc[@for="IObjectHandle.Unwrap"]/*' />
        // Unwrap the object. Implementers of this interface
        // typically have an indirect referece to another object.
        Object Unwrap();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\text\stringbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  StringBuilder
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A prototype implementation of the StringBuilder
** class.
**
** Date:  December 8, 1997
** Last Updated:  March 31, 1998
** 
===========================================================*/
namespace System.Text {
    using System.Text;
    using System.Runtime.Serialization;
    using System;
    using System.Runtime.CompilerServices;

    // This class represents a mutable string.  It is convenient for situations in
    // which it is desirable to modify a string, perhaps by removing, replacing, or 
    // inserting characters, without creating a new String subsequent to
    // each modification. 
    // 
    // The methods contained within this class do not return a new StringBuilder
    // object unless specified otherwise.  This class may be used in conjunction with the String
    // class to carry out modifications upon strings.
    // 
    // When passing null into a constructor in VJ and VC, the null
    // should be explicitly type cast.
    // For Example:
    // StringBuilder sb1 = new StringBuilder((StringBuilder)null);
    // StringBuilder sb2 = new StringBuilder((String)null);
    // Console.WriteLine(sb1);
    // Console.WriteLine(sb2);
    // 
    /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder"]/*' />
    [Serializable()] public sealed class StringBuilder {


        //
        //
        //  CLASS VARIABLES
        //
        //
        internal int m_currentThread = InternalGetCurrentThread();
        internal int m_MaxCapacity = 0;
        internal String m_StringValue = null;


        //
        //
        // STATIC CONSTANTS
        //
        //
        internal const int DefaultCapacity = 16;


        //
        //
        //CONSTRUCTORS
        //
        //
    
        // Creates a new empty string builder (i.e., it represents String.Empty)
        // with the default capacity (16 characters).
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.StringBuilder"]/*' />
        public StringBuilder() 
            : this(DefaultCapacity) {
        }
        
        // Create a new empty string builder (i.e., it represents String.Empty)
        // with the specified capacity.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.StringBuilder1"]/*' />
        public StringBuilder(int capacity) {
            if (capacity<0) {
                throw new ArgumentOutOfRangeException("capacity", 
                                                      String.Format(Environment.GetResourceString("ArgumentOutOfRange_MustBePositive"), "capacity"));
            }

            if (capacity == 0) { // MakeFromString enforces this
                capacity = DefaultCapacity;
            }

            m_StringValue = String.GetStringForStringBuilder(String.Empty, capacity);
            m_MaxCapacity = Int32.MaxValue;
        }
      
    
        // Creates a new string builder from the specified string.  If value
        // is a null String (i.e., if it represents String.NullString)
        // then the new string builder will also be null (i.e., it will also represent
        //  String.NullString).
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.StringBuilder2"]/*' />
        public StringBuilder(String value){
            MakeFromString(value, 0, -1, -1);
        }
    
        // Creates a new string builder from the specified string with the specified 
        // capacity.  If value is a null String (i.e., if it represents 
        // String.NullString) then the new string builder will also be null 
        // (i.e., it will also represent String.NullString).
        // The maximum number of characters this string may contain is set by capacity.
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.StringBuilder3"]/*' />
        public StringBuilder(String value, int capacity) {
            if (capacity<0) {
                throw new ArgumentOutOfRangeException("capacity", 
                                                      String.Format(Environment.GetResourceString("ArgumentOutOfRange_MustBePositive"), "capacity"));
            }
 
            MakeFromString(value, 0, -1, capacity);
        }
        // Creates a new string builder from the specifed substring with the specified
        // capacity.  The maximum number of characters is set by capacity.
        // 
        
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.StringBuilder4"]/*' />
        public StringBuilder(String value, int startIndex, int length, int capacity) {
            if (capacity<0) {
                throw new ArgumentOutOfRangeException("capacity", 
                                                      String.Format(Environment.GetResourceString("ArgumentOutOfRange_MustBePositive"), "capacity"));
            }
            if (length<0) {
                throw new ArgumentOutOfRangeException("length", 
                                                      String.Format(Environment.GetResourceString("ArgumentOutOfRange_MustBeNonNegNum"), "length"));
            }
 
            MakeFromString(value, startIndex, length, capacity);
        }
    
        // Creates an empty StringBuilder with a minimum capacity of capacity
        // and a maximum capacity of maxCapacity.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.StringBuilder5"]/*' />
        public StringBuilder(int capacity, int maxCapacity) {
            if (capacity>maxCapacity) {
                throw new ArgumentOutOfRangeException("capacity", Environment.GetResourceString("ArgumentOutOfRange_Capacity"));
            }
            if (maxCapacity<1) {
                throw new ArgumentOutOfRangeException("maxCapacity", Environment.GetResourceString("ArgumentOutOfRange_SmallMaxCapacity"));
            }
    
            if (capacity<0) {
                throw new ArgumentOutOfRangeException("capacity", 
                                                      String.Format(Environment.GetResourceString("ArgumentOutOfRange_MustBePositive"), "capacity"));
            }
            if (capacity == 0) {
                capacity = DefaultCapacity;
            }
   	         
            m_StringValue = String.GetStringForStringBuilder(String.Empty, capacity);
            m_MaxCapacity = maxCapacity;

        }
    
        private String GetThreadSafeString(out int tid) {
             String temp = m_StringValue;
             tid = InternalGetCurrentThread();
	         if (m_currentThread == tid)
		        return temp;
	         return String.GetStringForStringBuilder(temp, temp.Capacity);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static int InternalGetCurrentThread();
        
        //
        // Private native functions
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void MakeFromString(String value, int startIndex, int length, int capacity);

         /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Capacity"]/*' />
         public int Capacity {
             get {return m_StringValue.Capacity;} //-1 to account for terminating null.
             set {InternalSetCapacity(value);}
        }

    
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.MaxCapacity"]/*' />
        public int MaxCapacity {
            get { return m_MaxCapacity; }

        }
    
        // Read-Only Property 
        // Ensures that the capacity of this string builder is at least the specified value.  
        // If capacity is greater than the capacity of this string builder, then the capacity
        // is set to capacity; otherwise the capacity is unchanged.
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.EnsureCapacity"]/*' />
        public int EnsureCapacity(int capacity) {
            if (capacity<0) {
                throw new ArgumentOutOfRangeException("capacity", Environment.GetResourceString("ArgumentOutOfRange_NeedPosCapacity")); 
            }

            int tid;
            String currentString =  GetThreadSafeString(out tid);

            //If we need more space or the COW bit is set, copy the buffer.
            if (!NeedsAllocation(currentString,capacity)) {
                return currentString.Capacity;
            }

            String newString = GetNewString(currentString,capacity);
            ReplaceString(tid,newString);
            return newString.Capacity;
        }
    
        //Sets the capacity to be capacity.  If capacity is less than the current
        //instance an ArgumentException is thrown.  If capacity is greater than the current
        //instance, memory is allocated to allow the StringBuilder to grow.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalSetCapacity(int capacity);


        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.ToString"]/*' />
        public override String ToString() { 
            String currentString =  m_StringValue;
            int currentThread = m_currentThread;
            if (currentThread != 0 && currentThread != InternalGetCurrentThread()) {
                return String.InternalCopy(currentString);
            }

            if ((2 *  currentString.Length) <  currentString.ArrayLength) {
                return String.InternalCopy(currentString);
            }

            currentString.ClearPostNullChar();
            m_currentThread = 0;
            return  currentString;
        }
    
        // Converts a substring of this string builder to a String.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.ToString1"]/*' />
        public String ToString(int startIndex, int length) { 
            return  m_StringValue.Substring(startIndex, length);
        }
    
        // Sets the length of the String in this buffer.  If length is less than the current
        // instance, the StringBuilder is truncated.  If length is greater than the current 
        // instance, nulls are appended.  The capacity is adjusted to be the same as the length.
        
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Length"]/*' />
        public int Length {
            get { 
               return  m_StringValue.Length; 
            }
            set {
                int tid;
                String currentString =  GetThreadSafeString(out tid);

                if (value==0) { //the user is trying to clear the string
                     currentString.SetLength(0);
                     ReplaceString(tid,currentString);
                     return;
                }
                             
                int currentLength = currentString.Length;
                int newlength = value;
                //If our length is less than 0 or greater than our Maximum capacity, bail.
                if (newlength<0) {
                    throw new ArgumentOutOfRangeException("newlength", Environment.GetResourceString("ArgumentOutOfRange_NegativeLength"));
                }

                if (newlength>MaxCapacity) {
                    throw new ArgumentOutOfRangeException("capacity", Environment.GetResourceString("ArgumentOutOfRange_SmallCapacity"));
                }

                //Jump out early if our requested length our currentlength.
                //This will be a pretty rare branch.
                if (newlength == currentLength) {
                    return;
                }

            
                //If the StringBuilder has never been converted to a string, simply set the length
                //without allocating a new string.
                if (newlength <= currentString.Capacity) {
                        if (newlength > currentLength) {
                            for (int i = currentLength ; i < newlength; i++) // This is a rare case anyway.
                                currentString.InternalSetCharNoBoundsCheck(i,'\0');
                        }

                        currentString.InternalSetCharNoBoundsCheck(newlength,'\0'); //Null terminate.
                        currentString.SetLength(newlength); 
                        ReplaceString(tid,currentString);
                   
                        return;
                }

                // CopyOnWrite set we need to allocate a String
                int newCapacity = (newlength>currentString.Capacity)?newlength:currentString.Capacity;
                String newString = String.GetStringForStringBuilder(currentString, newCapacity);
            
                //We know exactly how many characters we need, so embed that knowledge in the String.
                newString.SetLength(newlength);
                ReplaceString(tid,newString);
            }
        }
    
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.this"]/*' />
        [System.Runtime.CompilerServices.IndexerName("Chars")]
        public char this[int index] {
            get { 
                return  m_StringValue[index]; 
            }
            set { 
                int tid;
                String currentString =  GetThreadSafeString(out tid);
                currentString.SetChar(index, value); 
                ReplaceString(tid,currentString);
            }
        }

        // Appends a character at the end of this string builder. The capacity is adjusted as needed.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append"]/*' />
        public StringBuilder Append(char value, int repeatCount) {
            if (repeatCount==0) {
                return this;
            }
            if (repeatCount<0) {
                throw new ArgumentOutOfRangeException("repeatCount", Environment.GetResourceString("ArgumentOutOfRange_NegativeCount"));
            }

             
            int tid;
            String currentString =  GetThreadSafeString(out tid);
            
            int currentLength = currentString.Length;
            int requiredLength = currentLength + repeatCount;

            if (requiredLength < 0)
                throw new OutOfMemoryException();

            if (!NeedsAllocation(currentString,requiredLength)) {
                currentString.AppendInPlace(value, repeatCount,currentLength);
                ReplaceString(tid,currentString);
                return this;
            } 

            String newString = GetNewString(currentString,requiredLength);
            newString.AppendInPlace(value, repeatCount,currentLength);
            ReplaceString(tid,newString);
            return this;
        }
    
        // Appends an array of characters at the end of this string builder. The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append1"]/*' />
        public StringBuilder Append(char[] value, int startIndex, int charCount) {
            int requiredLength;

            if (value==null) {
                if (startIndex==0 && charCount==0) {
                    return this;
                }
                throw new ArgumentNullException("value");
            }

            if (charCount==0) {
                return this;
            }

            if (startIndex<0) {
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
            }
            if (charCount<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
            }
            if (charCount>value.Length-startIndex) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
             
            int tid;
            String currentString =  GetThreadSafeString(out tid);
            
            int currentLength = currentString.Length;
            requiredLength = currentLength + charCount;
            if (NeedsAllocation(currentString,requiredLength)) {
                String newString = GetNewString(currentString,requiredLength);
                newString.AppendInPlace(value, startIndex, charCount,currentLength);
                ReplaceString(tid,newString);
            } else {
                currentString.AppendInPlace(value, startIndex, charCount,currentLength);
                ReplaceString(tid,currentString);
            }

            return this;
        }
    
        // Appends a copy of this string at the end of this string builder.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append2"]/*' />
        public StringBuilder Append(String value) {
            //If the value being added is null, eat the null
            //and return.
            if (value==null) {
                return this;
            }

            int tid;
		    // hand inlining of GetThreadSafeString
            String currentString = m_StringValue;
            tid = InternalGetCurrentThread();
	        if (m_currentThread != tid) 
		        currentString = String.GetStringForStringBuilder(currentString, currentString.Capacity);

            int currentLength = currentString.Length;
          
            int requiredLength = currentLength + value.Length;
            
            if (NeedsAllocation(currentString,requiredLength)) {
                String newString = GetNewString(currentString,requiredLength);
                newString.AppendInPlace(value,currentLength);
                ReplaceString(tid,newString);
            } else {
                currentString.AppendInPlace(value,currentLength);
                ReplaceString(tid,currentString);
            }

            return this;
        }

        internal unsafe StringBuilder Append(char *value, int count) {
            //If the value being added is null, eat the null
            //and return.
            if (value==null) {
                return this;
            }

             
            int tid;
            String currentString =  GetThreadSafeString(out tid);
            int currentLength = currentString.Length;
            
            int requiredLength = currentLength + count;
            
            if (NeedsAllocation(currentString,requiredLength)) {
                String newString = GetNewString(currentString,requiredLength);
                newString.AppendInPlace(value, count,currentLength);
                ReplaceString(tid,newString);
            } else {
                currentString.AppendInPlace(value,count,currentLength);
                ReplaceString(tid,currentString);
            }

            return this;
        }

        private bool NeedsAllocation(String currentString,int requiredLength) {
            //<= accounts for the terminating 0 which we require on strings.
            return (currentString.ArrayLength<=requiredLength);
        }

        private String GetNewString(String currentString, int requiredLength) {
            int newCapacity;

            requiredLength++; //Include the terminating null.

            if (requiredLength < 0) {
                throw new OutOfMemoryException();
            }

            if (requiredLength >  m_MaxCapacity) {
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NegativeCapacity"),
                                                      "requiredLength");
            }
          
            newCapacity = ( currentString.Capacity)*2; // To force a predicatable growth of 160,320 etc. for testing purposes

            if (newCapacity<requiredLength) {
                newCapacity = requiredLength;
            }

            if (newCapacity> m_MaxCapacity) {
                newCapacity =  m_MaxCapacity;
            }

            if (newCapacity<=0) {
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NegativeCapacity"));
            }

            return String.GetStringForStringBuilder( currentString, newCapacity);
        }

        private void ReplaceString(int tid, String value) {
            BCLDebug.Assert(value!=null, "[StringBuilder.ReplaceString]value!=null");
            
            m_currentThread = tid; // new owner
            m_StringValue = value;
        }
    
        // Appends a copy of the characters in value from startIndex to startIndex +
        // count at the end of this string builder.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append3"]/*' />
        public StringBuilder Append (String value, int startIndex, int count) { 
            //If the value being added is null, eat the null
            //and return.
            if (value==null) {
                if (startIndex==0 && count==0) {
                    return this;
                }
                throw new ArgumentNullException("value");
            }

            if (count<=0) {
                if (count==0) {
                    return this;
                }
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
            }

            if (startIndex<0 || (startIndex>value.Length - count)) {
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }

            int tid;
            String currentString =  GetThreadSafeString(out tid);
            int currentLength = currentString.Length;
      
            int requiredLength = currentLength + count;
            
            if (NeedsAllocation(currentString,requiredLength)) {
                String newString = GetNewString(currentString,requiredLength);
                newString.AppendInPlace(value, startIndex, count, currentLength);
                ReplaceString(tid,newString);
            } else {
                currentString.AppendInPlace(value, startIndex, count, currentLength);
                ReplaceString(tid,currentString);
            }

            return this;
        }
      
        // Inserts multiple copies of a string into this string builder at the specified position.
        // Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, this
        // string builder is not changed. Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert"]/*' />
        public unsafe StringBuilder Insert(int index, String value, int count) {
              int tid;
              String currentString =  GetThreadSafeString(out tid);
              int currentLength = currentString.Length;
              
              //If value isn't null, get all of our required values.
              if (value == null) {
                    if (index == 0 && count == 0) {
                         return this;
                    }
                    throw new ArgumentNullException(Environment.GetResourceString("ArgumentNull_String"));
              }

              //Range check the index.
              if (index < 0 || index > currentLength) {
                  throw new ArgumentOutOfRangeException("index",Environment.GetResourceString("ArgumentOutOfRange_Index"));
              }

              if (count < 1) {
                  throw new ArgumentOutOfRangeException("count",Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
              }

               //Calculate the new length, ensure that we have the space and set the space variable for this buffer
               int requiredLength;
                try {
                   requiredLength = checked(currentLength + (value.Length * count));
                }
                catch (Exception) {
                   throw new OutOfMemoryException();
                }

               if (NeedsAllocation(currentString,requiredLength)) {
                    String newString = GetNewString(currentString,requiredLength);
                    newString.InsertInPlace(index, value, count, currentLength, requiredLength);
                    ReplaceString(tid,newString);
               } 
               else {
                    currentString.InsertInPlace(index, value, count, currentLength, requiredLength);
                    ReplaceString(tid,currentString);
               }
               return this;
         }

       
    
        // Property.
        // Removes the specified characters from this string builder.
        // The length of this string builder is reduced by 
        // length, but the capacity is unaffected.
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Remove"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern StringBuilder Remove(int startIndex, int length);
            
        //
        //
        // PUBLIC INSTANCE FUNCTIONS
        //
        //
    
        /*====================================Append====================================
        **
        ==============================================================================*/
        // Appends a boolean to the end of this string builder.
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append4"]/*' />
        public StringBuilder Append(bool value) {
            return Append(value.ToString());
        }
      
        // Appends an sbyte to this string builder.
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append5"]/*' />
        [CLSCompliant(false)]
        public StringBuilder Append(sbyte value) {
            return Append(value.ToString());
        }
    
        // Appends a ubyte to this string builder.
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append6"]/*' />
        public StringBuilder Append(byte value) {
            return Append(value.ToString());
        }
    
        // Appends a character at the end of this string builder. The capacity is adjusted as needed.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append7"]/*' />
        public StringBuilder Append(char value) {
            int tid;

		    // hand inlining of GetThreadSafeString
            String currentString = m_StringValue;
            tid = InternalGetCurrentThread();
	        if (m_currentThread != tid) 
		        currentString = String.GetStringForStringBuilder(currentString, currentString.Capacity);

            int currentLength = currentString.Length;
            if (!NeedsAllocation(currentString,currentLength+1)) {
                currentString.AppendInPlace(value,currentLength);
                ReplaceString(tid,currentString);
                return this;
            } 

            String newString = GetNewString(currentString,currentLength+1);
            newString.AppendInPlace(value,currentLength);
            ReplaceString(tid,newString);
            return this;
        }
      
        // Appends a short to this string builder.
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append8"]/*' />
        public StringBuilder Append(short value) {
            return Append(value.ToString());
        }
      
        // Appends an int to this string builder.
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append9"]/*' />
        public StringBuilder Append(int value) {
            return Append(value.ToString());
        }
      
        // Appends a long to this string builder. 
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append10"]/*' />
        public StringBuilder Append(long value) {
            return Append(value.ToString());
        }
      
        // Appends a float to this string builder. 
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append11"]/*' />
        public StringBuilder Append(float value) {
            return Append(value.ToString());
        }
      
        // Appends a double to this string builder. 
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append12"]/*' />
        public StringBuilder Append(double value) {
            return Append(value.ToString());
        }

        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append13"]/*' />
        public StringBuilder Append(decimal value) {
            return Append(value.ToString());
        }
    
        // Appends an ushort to this string builder. 
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append14"]/*' />
         [CLSCompliant(false)]
        public StringBuilder Append(ushort value) {
            return Append(value.ToString());
        }
    
        // Appends an uint to this string builder. 
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append15"]/*' />
         [CLSCompliant(false)]
        public StringBuilder Append(uint value) {
            return Append(value.ToString());
        }
    
        // Appends an unsigned long to this string builder. 
        // The capacity is adjusted as needed. 
    
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append16"]/*' />
         [CLSCompliant(false)]
        public StringBuilder Append(ulong value) {
            return Append(value.ToString());
        }
      
        // Appends an Object to this string builder. 
        // The capacity is adjusted as needed. 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append17"]/*' />
        public StringBuilder Append(Object value) {
            if (null==value) {
                //Appending null is now a no-op.
                return this; 
            }
            return Append(value.ToString());
        }
    
        // Appends all of the characters in value to the current instance.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Append18"]/*' />
        public StringBuilder Append(char[] value) { 
            if (null==value) {
                return this;
            }

            int valueLength = value.Length;
             
            int tid;
            String currentString =  GetThreadSafeString(out tid);

            int currentLength = currentString.Length;
            int requiredLength = currentLength + value.Length;
            if (NeedsAllocation(currentString,requiredLength)) {
                String newString = GetNewString(currentString,requiredLength);
                newString.AppendInPlace(value, 0, valueLength,currentLength);
                ReplaceString(tid,newString);
            } else {
                currentString.AppendInPlace(value, 0, valueLength, currentLength);
                ReplaceString(tid,currentString);
            }
            return this;
        }
      
        /*====================================Insert====================================
        **
        ==============================================================================*/
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert1"]/*' />
        public StringBuilder Insert(int index, String value) {
            if (value == null) // This is to do the index validation
                return Insert(index,value,0);
            else
                return Insert(index,value,1);
        }
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert2"]/*' />
        public StringBuilder Insert( int index, bool value) {
            return Insert(index,value.ToString(),1);
        }
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert3"]/*' />
         [CLSCompliant(false)]
        public StringBuilder Insert(int index, sbyte value) {
            return Insert(index,value.ToString(),1);
        }
    
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert4"]/*' />
        public StringBuilder Insert(int index, byte value) {
            return Insert(index,value.ToString(),1);
        }
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert5"]/*' />
        public StringBuilder Insert(int index, short value) {
            return Insert(index,value.ToString(),1);
        }
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert6"]/*' />
        public StringBuilder Insert(int index, char value) {
            return Insert(index,Char.ToString(value),1);
        }
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert7"]/*' />
        public StringBuilder Insert(int index, char[] value) {
            if (null==value) {
                return Insert(index, value, 0, 0);
            }
            return Insert(index, value, 0, value.Length);
        }
    
        // Returns a reference to the StringBuilder with charCount characters from 
        // value inserted into the buffer at index.  Existing characters are shifted
        // to make room for the new text and capacity is adjusted as required.  If value is null, the StringBuilder
        // is unchanged.  Characters are taken from value starting at position startIndex.
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert8"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern StringBuilder Insert (int index, char []value, int startIndex, int charCount);           
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert9"]/*' />
        public StringBuilder Insert(int index, int value){
            return Insert(index,value.ToString(),1);
        }
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert10"]/*' />
        public StringBuilder Insert(int index, long value) {
            return Insert(index,value.ToString(),1);
        }
      
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert11"]/*' />
        public StringBuilder Insert(int index, float value) {
            return Insert(index,value.ToString(),1);
        }
    
     
        // Returns a reference to the StringBuilder with ; value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. ; Inserts ";<;no object>;"; if value
        // is null. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert12"]/*' />
        public StringBuilder Insert(int index, double value) {
            return Insert(index,value.ToString(),1);
        }

        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert13"]/*' />
        public StringBuilder Insert(int index, decimal value) {
            return Insert(index,value.ToString(),1);
        }
    
        // Returns a reference to the StringBuilder with value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert14"]/*' />
         [CLSCompliant(false)]
        public StringBuilder Insert(int index, ushort value) {
            return Insert(index, value.ToString(),1);
        }
    
       
        // Returns a reference to the StringBuilder with value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert15"]/*' />
         [CLSCompliant(false)]
        public StringBuilder Insert(int index, uint value) {
            return Insert(index, value.ToString(), 1);
        }
    
        // Returns a reference to the StringBuilder with value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the new text.
        // The capacity is adjusted as needed. 
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert16"]/*' />
         [CLSCompliant(false)]
        public StringBuilder Insert(int index, ulong value) {
            return Insert(index, value.ToString(), 1);
        }
      
        // Returns a reference to this string builder with value inserted into 
        // the buffer at index. Existing characters are shifted to make room for the
        // new text.  The capacity is adjusted as needed. If value equals String.Empty, the
        // StringBuilder is not changed. No changes are made if value is null.
        // 
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Insert17"]/*' />
        public StringBuilder Insert(int index, Object value) {
            //If we get a null 
            if (null==value) {
                return this;
            }
            return Insert(index,value.ToString(),1);
        }
    
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.AppendFormat"]/*' />
        public StringBuilder AppendFormat(String format, Object arg0) {
            return AppendFormat( null,format, new Object[] {arg0});
        }
    
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.AppendFormat1"]/*' />
        public StringBuilder AppendFormat(String format, Object arg0, Object arg1) {
            return AppendFormat(null, format, new Object[] {arg0, arg1});
        }
    
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.AppendFormat2"]/*' />
        public StringBuilder AppendFormat(String format, Object arg0, Object arg1, Object arg2) {
            return AppendFormat(null, format, new Object[] {arg0, arg1, arg2});
        }
            
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.AppendFormat3"]/*' />
        public StringBuilder AppendFormat(String format, params Object[] args) {
            return AppendFormat(null, format, args);
        }
    
        private static void FormatError() {
            throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
        }
    
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.AppendFormat4"]/*' />
        public StringBuilder AppendFormat(IFormatProvider provider, String format, params Object[] args) {
            if (format == null || args == null) {
                throw new ArgumentNullException((format==null)?"format":"args");
            }
            char[] chars = format.ToCharArray(0, format.Length);
            int pos = 0;
            int len = chars.Length;
            char ch = '\x0';

            ICustomFormatter cf = null;
            if (provider!=null) {
                   cf=(ICustomFormatter)provider.GetFormat(typeof(ICustomFormatter));
                } 

            while (true) {
                int p = pos;
                int i = pos;
                while (pos < len) {
                    ch = chars[pos];
                
                    pos++;
                    if (ch == '}') 
                    {
                        if(pos < len && chars[pos]=='}') // Treat as escape character for }}
                            pos++;
                        else
                            FormatError();
                    }

                    if (ch == '{') 
                    {
                        if(pos < len && chars[pos]=='{') // Treat as escape character for {{
                            pos++;
                        else
                        {
                            pos--;
                            break;
                        }
                    }

                    chars[i++] = ch;
                }
                if (i > p) Append(chars, p, i - p);
                if (pos == len) break;
                pos++;
                if (pos == len || (ch = chars[pos]) < '0' || ch > '9') FormatError();
                int index = 0;
                do {
                    index = index * 10 + ch - '0';
                    pos++;
                    if (pos == len) FormatError();
                    ch = chars[pos];
                } while (ch >= '0' && ch <= '9' && index < 1000000);
                if (index >= args.Length) throw new FormatException(Environment.GetResourceString("Format_IndexOutOfRange"));
                while (pos < len && (ch=chars[pos]) == ' ') pos++;
                bool leftJustify = false;
                int width = 0;
                if (ch == ',') {
                    pos++;
                    while (pos < len && chars[pos] == ' ') pos++;

                    if (pos == len) FormatError();
                    ch = chars[pos];
                    if (ch == '-') {
                        leftJustify = true;
                        pos++;
                        if (pos == len) FormatError();
                        ch = chars[pos];
                    }
                    if (ch < '0' || ch > '9') FormatError();
                    do {
                        width = width * 10 + ch - '0';
                        pos++;
                        if (pos == len) FormatError();
                        ch = chars[pos];
                    } while (ch >= '0' && ch <= '9' && width < 1000000);
                }

                while (pos < len && (ch=chars[pos]) == ' ') pos++;
                Object arg = args[index];
                String fmt = null;
                if (ch == ':') {
                    pos++;
                    p = pos;
                    i = pos;
                    while (true) {
                        if (pos == len) FormatError();
                        ch = chars[pos];
                        pos++;
                        if (ch == '{')
                        {
                            if(pos < len && chars[pos]=='{')  // Treat as escape character for {{
                                pos++;
                            else
                                FormatError();
                        }
                        else if (ch == '}')
                        {
                            if(pos < len && chars[pos]=='}')  // Treat as escape character for }}
                                pos++;
                            else
                            {
                                pos--;
                                break;
                            }
                        }

                        chars[i++] = ch;
                    }
                    if (i > p) fmt = new String(chars, p, i - p);
                }
                if (ch != '}') FormatError();
                pos++;
                String s = null;
                if (cf != null) {
                    s = cf.Format(fmt, arg, provider);
                }
 
                if (s==null) {
                    if (arg is IFormattable) {
                        s = ((IFormattable)arg).ToString(fmt, provider);
                    } else if (arg != null) {
                        s = arg.ToString();
                    }
                }

                if (s == null) s = String.Empty;
                int pad = width - s.Length;
                if (!leftJustify && pad > 0) Append(' ', pad);
                Append(s);
                if (leftJustify && pad > 0) Append(' ', pad);
            }
            return this;
        }
    
        // Returns a reference to the current StringBuilder with all instances of oldString 
        // replaced with newString.  If startIndex and count are specified,
        // we only replace strings completely contained in the range of startIndex to startIndex + 
        // count.  The strings to be replaced are checked on an ordinal basis (e.g. not culture aware).  If 
        // newValue is null, instances of oldValue are removed (e.g. replaced with nothing.).
        //
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Replace"]/*' />
        public StringBuilder Replace(String oldValue, String newValue) { 
            return Replace(oldValue, newValue, 0, Length);
        }
        
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Replace1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern StringBuilder Replace (String oldValue, String newValue, int startIndex, int count);

        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Equals"]/*' />
        public bool Equals(StringBuilder sb) 
        {
            if (sb == null)
                return false;
            return ((this.Capacity == sb.Capacity) && (this.MaxCapacity == sb.MaxCapacity) && (this. m_StringValue.Equals(sb. m_StringValue)));
        }
    
        // Returns a StringBuilder with all instances of oldChar replaced with 
        // newChar.  The size of the StringBuilder is unchanged because we're only
        // replacing characters.  If startIndex and count are specified, we 
        // only replace characters in the range from startIndex to startIndex+count
        //
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Replace2"]/*' />
        public StringBuilder Replace(char oldChar, char newChar) { 
            return Replace(oldChar, newChar, 0, Length);
        }
        /// <include file='doc\StringBuilder.uex' path='docs/doc[@for="StringBuilder.Replace3"]/*' />
        public StringBuilder Replace (char oldChar, char newChar, int startIndex, int count) { 
            int tid;
            String currentString =  GetThreadSafeString(out tid);
            int currentLength = currentString.Length;

            if ((uint)startIndex > (uint)currentLength) {
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }

            if (count<0 || startIndex > currentLength-count) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }

            if (!NeedsAllocation(currentString,currentLength)) {
                currentString.ReplaceCharInPlace(oldChar, newChar, startIndex, count, currentLength);
                ReplaceString(tid,currentString);
                return this;
            } 

            String newString = GetNewString(currentString,currentLength);
            newString.ReplaceCharInPlace(oldChar, newChar, startIndex, count, currentLength);
            ReplaceString(tid,newString);
            return this;
        }

        // ***************************************** NEVER ENABLE RESUSING INTERNAL BUFFER ************************************************** 
        // The fix below causes GC memory corruption if 2 threads hit a StringBuilder - rajeshc.

        // This code is ifdef'ed out so we can refer to this in V2.  We believe
        // this is an interesting idea, but probably not something we want to
        // do in V1.  Patrick was concerned about tracking down all sorts of
        // heap corruption and potential problems with the concurrent GC.
        // It helps only a little with working set on a test like ShowFormComplex.
#if MOTHBALL
        // Related to optimizing ToString by putting a fake byte[] in unused
        // memory in the String.  This "allocates" an object.  Then we shrink the
        // capacity of the String object.  This tells the GC there's an object 
        // in that free space.  If we ever change how Arrays or Strings are laid 
        // out in memory, we MUST update this code.

        /*
        // Threshold = sync block index + MethodTable* + array len + data area
#if WIN32
        internal const int FakeByteArrayOverhead = 4 + 4 + 4;
#else
        internal const int FakeByteArrayOverhead = 4 + 8 + 4;
#endif
        internal static IntPtr ByteArrayMethodTable;

        public override String ToString() {
            // Add 4 to the FakeByteArrayOverhead for alignment issues.
            if (RoundUpToNearestFour(2*(m_StringValue.ArrayLength - m_StringValue.Length)) > FakeByteArrayOverhead + 4) {
                MakeFakeByteArray();
            }
            else if ((2 * m_StringValue.Length) < m_StringValue.ArrayLength) {
                return String.Copy(m_StringValue);
            }

            m_COW=1;
            m_StringValue.ClearPostNullChar();
            return m_StringValue;
        }

        private unsafe void MakeFakeByteArray()
        {
            // @TODO PORTING: Good luck on 64 bit machines.

            // Note a 1 element byte[] looks like this in memory (bytes[0]=0xff):
            // MethodTable Length      [0] Padding
            // 6c e3 16 03 01 00 00 00 ff 00 00 00
            // We must round up to four in our length calculations
            // because the GC heap is 4-byte aligned.

            if (ByteArrayMethodTable == IntPtr.Zero) {
                // This code doesn't need to be threadsafe here - byte[]'s 
                // will always have the same MethodTable pointer.
                byte[] bytes = new byte[1];
                fixed(byte* pb = bytes) {
                    // Move back over size & MethodTable
                    byte* pMT = &pb[0];
                    pMT += -4 - IntPtr.Size;
                    if (IntPtr.Size == 4)
                        ByteArrayMethodTable = new IntPtr(*((int*)pMT));
                    else
                        ByteArrayMethodTable = new IntPtr(*((long*)pMT));
                }
            }

            fixed(char* pString = m_StringValue) {
                char* newData = pString + m_StringValue.Length + 1; // Skip \0.
                int fakeByteArrayLength = 2*(Capacity - m_StringValue.Length) - FakeByteArrayOverhead;
                // Length + 1 for term 0.  If this is odd, then round up to next even.
                if ((m_StringValue.Length & 1) == 0) {
                    newData++;
                    fakeByteArrayLength -= 2;
                }
                BCLDebug.Assert(fakeByteArrayLength >= 0, "fakeByteArrayLength was "+fakeByteArrayLength+" - expected >= 0");
                int* ptr = (int*) newData;
                // Write a sync block index (0)
                // WARNING: Note that 0 may not always be valid for the sync block!
                // With AppDomain leak checking on, we use a bit here!
                *ptr++ = 0;
                // Write the MethodTable* for a byte[].
                if (IntPtr.Size == 4)
                    *ptr++ = ByteArrayMethodTable.ToInt32();
                else {
                    *((long*)ptr) = ByteArrayMethodTable.ToInt64();
                    ptr += 2;
                }
                // Write out the fake byte[] length
                *ptr++ = fakeByteArrayLength;

#if _DEBUG
                // Write out something to this memory so I know it's been clobbered
                while((fakeByteArrayLength >> 2) > 0) {
                    *ptr++ = unchecked((int)0xdeadbeef);
                    fakeByteArrayLength -= 4;
                }
                byte* pb = (byte*) ptr;
                while (fakeByteArrayLength-- > 0)
                    *pb++ = 0xEE;
#endif

                // Shrink the String's capacity field now.
                m_StringValue.SetArrayLengthDangerousForGC(m_StringValue.Length + 1);
            }
        }
    
        // For alignment issues
        private static int RoundUpToNearestFour(int value) 
        {
            return (value + 3) & ~3;
        }
        */
#endif // MOTHBALL
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\apartmentstate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ApartmentState
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: Enum to represent the different threading models
**
** Date: Feb 2, 2000
**
=============================================================================*/

namespace System.Threading {

    /// <include file='doc\ApartmentState.uex' path='docs/doc[@for="ApartmentState"]/*' />
	[Serializable()]
    public enum ApartmentState
    {   
        /*=========================================================================
        ** Constants for thread apartment states.
        =========================================================================*/
        /// <include file='doc\ApartmentState.uex' path='docs/doc[@for="ApartmentState.STA"]/*' />
        STA = 0,
        /// <include file='doc\ApartmentState.uex' path='docs/doc[@for="ApartmentState.MTA"]/*' />
        MTA = 1,
        /// <include file='doc\ApartmentState.uex' path='docs/doc[@for="ApartmentState.Unknown"]/*' />
        Unknown = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\compressedstack.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: CompressedStack
**
** Purpose: Managed wrapper for the security stack compression implementation
**
=============================================================================*/

namespace System.Threading
{
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\CompressedStack.uex' path='docs/doc[@for="CompressedStack"]/*' />
    /// <internalonly/>
    public class CompressedStack
    {
        private IntPtr m_unmanagedCompressedStack;

        internal CompressedStack( IntPtr unmanagedCompressedStack )
        {
            m_unmanagedCompressedStack = unmanagedCompressedStack;
        }

        internal IntPtr UnmanagedCompressedStack
        {
            get
            {
                return m_unmanagedCompressedStack;
            }
        }

        /// <include file='doc\CompressedStack.uex' path='docs/doc[@for="CompressedStack.GetCompressedStack"]/*' />
        /// <internalonly/>
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x00000000000000000400000000000000"),
         SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        public static CompressedStack GetCompressedStack()
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            if (SecurityManager.SecurityEnabled)
                return new CompressedStack( CodeAccessSecurityEngine.GetDelayedCompressedStack( ref stackMark ) );
            else
                return new CompressedStack( (IntPtr)0 );
        }


        /// <include file='doc\CompressedStack.uex' path='docs/doc[@for="CompressedStack.Finalize"]/*' />
        /// <internalonly/>
        ~CompressedStack()
        {
            if (m_unmanagedCompressedStack != (IntPtr)0)
            {
                CodeAccessSecurityEngine.ReleaseDelayedCompressedStack( m_unmanagedCompressedStack );
                m_unmanagedCompressedStack = (IntPtr)0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\interlocked.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Threading {
    
    //This class has only static members and doesn't require serialization.
    using System;
	using System.Runtime.CompilerServices;
    /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked"]/*' />
    public sealed class Interlocked
    {
        private Interlocked() {
        }
        
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.Increment"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int Increment(ref int location);
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.Decrement"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int Decrement(ref int location);
                /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.Increment1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern long Increment(ref long location);
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.Decrement1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern long Decrement(ref long location);

        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.Exchange"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int Exchange(ref int location1, int value);
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.CompareExchange"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int CompareExchange(ref int location1, int value, int comparand);
    
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.Exchange1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern float Exchange(ref float location1, float value);
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.CompareExchange1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern float CompareExchange(ref float location1, float value, float comparand);
    
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.Exchange2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Object Exchange(ref Object location1, Object value);
        /// <include file='doc\Interlocked.uex' path='docs/doc[@for="Interlocked.CompareExchange2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Object CompareExchange(ref Object location1, Object value, Object comparand);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\lockcookie.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:    RWLock
**
** Author:   Gopal Kakivaya (GopalK)
**
** Purpose: Defines the lock that implements 
**          single-writer/multiple-reader semantics
**
** Date:    Feb 21, 1999
**
===========================================================*/

namespace System.Threading {

	using System;
	
	/// <include file='doc\LockCookie.uex' path='docs/doc[@for="LockCookie"]/*' />
    [Serializable()] 
	public struct LockCookie
    {
        private int _dwFlags;
        private int _dwWriterSeqNum;
        private int _wReaderAndWriterLevel;
        private int _dwThreadID;

 		// This method should never be called.  Its sole purpose is to shut up the compiler
		//	because it warns about private fields that are never used.  Most of these fields
		//	are used in unmanaged code.
#if _DEBUG
		internal int NeverCallThis()
		{
			BCLDebug.Assert(false,"NeverCallThis");
			int i = _dwFlags = _dwFlags;
			i = _dwWriterSeqNum = _dwWriterSeqNum;
			i = _wReaderAndWriterLevel = _wReaderAndWriterLevel;
			return _dwThreadID=_dwThreadID;
		}
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\mutex.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Mutex	
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: synchronization primitive that can also be used for interprocess synchronization
**
** Date: February, 2000
**
=============================================================================*/
namespace System.Threading 
{  
	using System;
	using System.Threading;
	using System.Runtime.CompilerServices;
	using System.Security.Permissions;

    /// <include file='doc\Mutex.uex' path='docs/doc[@for="Mutex"]/*' />
    public sealed class Mutex : WaitHandle
    {
        
        /// <include file='doc\Mutex.uex' path='docs/doc[@for="Mutex.Mutex"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public Mutex(bool initiallyOwned, String name, out bool createdNew)
    	{
            IntPtr mutexHandle = CreateMutexNative(initiallyOwned, name, out createdNew);	// throws a Win32 exception if failed to create a mutex
    	    SetHandleInternal(mutexHandle);
    	}
        /// <include file='doc\Mutex.uex' path='docs/doc[@for="Mutex.Mutex1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public Mutex(bool initiallyOwned, String name)
    	{
    	    bool createdNew;
            IntPtr mutexHandle = CreateMutexNative(initiallyOwned, name, out createdNew);	// throws a Win32 exception if failed to create a mutex
    	    SetHandleInternal(mutexHandle);
    	}
	/// <include file='doc\Mutex.uex' path='docs/doc[@for="Mutex.Mutex2"]/*' />
        public Mutex(bool initiallyOwned)
    	{
    	    bool createdNew;
    	    IntPtr mutexHandle = CreateMutexNative(initiallyOwned, null, out createdNew);	// throws a Win32 exception if failed to create a mutex
    	    SetHandleInternal(mutexHandle);
    	}
        /// <include file='doc\Mutex.uex' path='docs/doc[@for="Mutex.Mutex3"]/*' />
        public Mutex()
    	{
    	    bool createdNew;
    	    IntPtr mutexHandle = CreateMutexNative(false, null, out createdNew);	// throws a Win32 exception if failed to create a mutex
    	    SetHandleInternal(mutexHandle);
    	}
    
    	/// <include file='doc\Mutex.uex' path='docs/doc[@for="Mutex.ReleaseMutex"]/*' />
    	public void ReleaseMutex()
    	{
            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                    ReleaseMutexNative(Handle);
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }
    	}

	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	extern private static IntPtr CreateMutexNative(bool initialState, String name, out bool createdNew);
    
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	extern private static void  ReleaseMutexNative(IntPtr handle);
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\monitor.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Monitor
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Synchronizes access to a shared resource or region of code in a multi-threaded 
**             program.
**
** Date: January 2000
**
=============================================================================*/


namespace System.Threading {

	using System;
	using System.Runtime.Remoting;
	using System.Threading;
	using System.Runtime.CompilerServices;
	/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor"]/*' />
	public sealed class Monitor 
	{

		
		/*=========================================================================
        ** Don't expose construction of monitor objects.
        =========================================================================*/
        private Monitor() 
		{}
		
		/*=========================================================================
        ** Obtain the monitor lock of obj. Will block if another thread holds the lock
        ** Will not block if the current thread holds the lock,
        ** however the caller must ensure that the same number of Exit
        ** calls are made as there were Enter calls.
        **
        ** Exceptions: ArgumentNullException if object is null.	
		=========================================================================*/
        /// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Enter"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void Enter(Object obj);


		/*=========================================================================
        ** Release the monitor lock. If one or more threads are waiting to acquire the
        ** lock, and the current thread has executed as many Exits as
        ** Enters, one of the threads will be unblocked and allowed to proceed.
        **
        ** Exceptions: ArgumentNullException if object is null.
        **             SynchronizationLockException if the current thread does not
        **             own the lock.
        =========================================================================*/
        /// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Exit"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void Exit(Object obj);
    
        /*=========================================================================
        ** Similar to Enter, but will never block. That is, if the current thread can
        ** acquire the monitor lock without blocking, it will do so and TRUE will
        ** be returned. Otherwise FALSE will be returned.
        **
        ** Exceptions: ArgumentNullException if object is null.
        =========================================================================*/
        /// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.TryEnter"]/*' />
        public static bool TryEnter(Object obj)
        {
    		return TryEnterTimeout(obj, 0);
        }
    
        /*=========================================================================
        ** Version of TryEnter that will block, but only up to a timeout period
        ** expressed in milliseconds. If timeout == Timeout.Infinite the method
        ** becomes equivalent to Enter.
        **
        ** Exceptions: ArgumentNullException if object is null.
        **             ArgumentException if timeout < 0.
        =========================================================================*/
        /// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.TryEnter1"]/*' />
        public static bool TryEnter(Object obj, int millisecondsTimeout)
        {
    		return TryEnterTimeout(obj, millisecondsTimeout);
        }

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.TryEnter2"]/*' />
		public static bool TryEnter(Object obj, TimeSpan timeout)
        {
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));

    		return TryEnterTimeout(obj, (int)tm);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool TryEnterTimeout(Object obj, int timeout);

        /*========================================================================
		** Waits for notification from the object (via a Pulse/PulseAll). 
		** timeout indicates how long to wait before the method returns.
		** This method acquires the monitor waithandle for the object 
		** If this thread holds the monitor lock for the object, it releases it. 
		** On exit from the method, it obtains the monitor lock back. 
		** If exitContext is true then the synchronization domain for the context 
		** (if in a synchronized context) is exited before the wait and reacquired 
		** ISSUE: How to determine the order of the synchronization domain lock? 
		**
        ** Exceptions: ArgumentNullException if object is null.
		========================================================================*/
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		private static extern bool ObjWait(bool exitContext, int millisecondsTimeout,Object obj);

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Wait"]/*' />
		public static bool Wait(Object obj, int millisecondsTimeout, bool exitContext)
		{
			if (obj == null)
			    throw (new ArgumentNullException("obj"));
            return ObjWait(exitContext, millisecondsTimeout, obj);
		}

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Wait1"]/*' />
		public static bool Wait(Object obj, TimeSpan timeout, bool exitContext)
		{
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));

			return Wait(obj, (int)tm, exitContext);
		}

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Wait2"]/*' />
		public static bool Wait(Object obj, int millisecondsTimeout)
		{
		    return Wait(obj,millisecondsTimeout,false);
		}

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Wait3"]/*' />
		public static bool Wait(Object obj, TimeSpan timeout)
		{
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));

		    return Wait(obj,(int)tm,false);
		}

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Wait4"]/*' />
		public static bool Wait(Object obj)
		{
		    return Wait(obj,Timeout.Infinite,false);
		}

        /*========================================================================
		** Sends a notification to a single waiting object. 
        * @exception SynchronizationLockException if this method is not called inside
        * a synchronized block of code.
		========================================================================*/
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		private static extern void ObjPulse(Object obj);

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.Pulse"]/*' />
		public static void Pulse(Object obj)
		{
            if (obj==null) {
                throw new ArgumentNullException("obj");
            }

            ObjPulse(obj);
		}  
        /*========================================================================
		** Sends a notification to all waiting objects. 
		========================================================================*/
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		private static extern void ObjPulseAll(Object obj);

		/// <include file='doc\Monitor.uex' path='docs/doc[@for="Monitor.PulseAll"]/*' />
		public static void PulseAll(Object obj)
		{
            if (obj==null) {
                throw new ArgumentNullException("obj");
            }

			ObjPulseAll(obj);
		}
    
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\manualresetevent.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ManualResetEvent	
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: An example of a WaitHandle class
**
** Date: August, 1999
**
=============================================================================*/
namespace System.Threading {
    
	using System;
	using System.Runtime.CompilerServices;
    /// <include file='doc\ManualResetEvent.uex' path='docs/doc[@for="ManualResetEvent"]/*' />
    public sealed class ManualResetEvent : WaitHandle
    {
        
        /// <include file='doc\ManualResetEvent.uex' path='docs/doc[@for="ManualResetEvent.ManualResetEvent"]/*' />
        public ManualResetEvent(bool initialState)
    	{
    		IntPtr eventHandle = CreateManualResetEventNative(initialState);	// throws an exception if failed to create an event
    	    SetHandleInternal(eventHandle);
    	}
    
    	/// <include file='doc\ManualResetEvent.uex' path='docs/doc[@for="ManualResetEvent.Reset"]/*' />
    	public bool Reset()
    	{
            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                {
    	  	        return ResetManualResetEventNative(Handle);
                }
                else
                {
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }

    	}
    
    	/// <include file='doc\ManualResetEvent.uex' path='docs/doc[@for="ManualResetEvent.Set"]/*' />
    	public bool Set()
    	{
            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                {
    	  	        return SetManualResetEventNative(Handle);
                }
                else
                {
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }

    	}
		
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	extern private static IntPtr CreateManualResetEventNative(bool initialState);
    
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	extern private static bool  ResetManualResetEventNative(IntPtr handle);
    
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	extern private static bool  SetManualResetEventNative(IntPtr handle);
    
    }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\overlapped.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Overlapped
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Class for converting information to and from the native 
**          overlapped structure used in asynchronous file i/o
**
** Date: January, 2000
**
=============================================================================*/


namespace System.Threading 
{   
    using System;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Security;
    using System.Security.Permissions;

    // Valuetype that represents the (unmanaged) Win32 OVERLAPPED structure
    // the layout of this structure must be identical to OVERLAPPED.
    // Two additional dwords are reserved at the end
    /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped"]/*' />
    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    public struct NativeOverlapped
    {
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.InternalLow"]/*' />
        public int  InternalLow;
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.InternalHigh"]/*' />
        public int  InternalHigh;
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.OffsetLow"]/*' />
        public int  OffsetLow;
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.OffsetHigh"]/*' />
        public int  OffsetHigh;
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.EventHandle"]/*' />
        public int  EventHandle;
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.ReservedCOR1"]/*' />
        internal Int32 ReservedCOR1;
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.ReservedCOR2"]/*' />
        internal GCHandle ReservedCOR2;
        internal IntPtr ReservedCOR3;
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="NativeOverlapped.ReservedClasslib"]/*' />
        internal GCHandle ReservedClasslib;
    }

    /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped"]/*' />
    /// <internalonly/>
    public class Overlapped
    {
        private IAsyncResult asyncResult;
        private int offsetLow;
        private int offsetHigh;
        private int eventHandle;

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.Overlapped"]/*' />
        public Overlapped() { }

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.Overlapped1"]/*' />
        public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar)
        {
            OffsetLow = offsetLo;
            OffsetHigh = offsetHi;
            EventHandle = hEvent;
            asyncResult = ar;
        }

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.AsyncResult"]/*' />
        public IAsyncResult AsyncResult
        {
            get { return asyncResult; }
            set { asyncResult = value; }
        }

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.OffsetLow"]/*' />
        public int OffsetLow
        {
            get { return offsetLow; }
            set { offsetLow = value; }
        }

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.OffsetHigh"]/*' />
        public int OffsetHigh
        {
            get { return offsetHigh; }
            set { offsetHigh = value; }
        }

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.EventHandle"]/*' />
        public int EventHandle
        {
            get { return eventHandle; }
            set { eventHandle = value; }
        }

        /*====================================================================
        *  Packs a managed overlapped class into native Overlapped struct.
        *  Roots the iocb and stores it in the ReservedCOR field of native Overlapped 
        *  Pins the native Overlapped struct and returns the pinned index. 
        ====================================================================*/
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.Pack"]/*' />
        [CLSCompliant(false)]
        unsafe public NativeOverlapped* Pack(IOCompletionCallback iocb)
        {
            NativeOverlapped *nativeOverlappedPtr = AllocNativeOverlapped();
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            if (SecurityManager.SecurityEnabled)
                (*nativeOverlappedPtr).ReservedCOR3 = CodeAccessSecurityEngine.GetDelayedCompressedStack( ref stackMark );
            else
                (*nativeOverlappedPtr).ReservedCOR3 = (IntPtr)null;
            PackCore(nativeOverlappedPtr, iocb);
            return nativeOverlappedPtr;
        }

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.UnsafePack"]/*' />
        [CLSCompliant(false)]
        [SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlEvidence = true, ControlPolicy = true )]
        unsafe public NativeOverlapped* UnsafePack(IOCompletionCallback iocb)
        {
            NativeOverlapped *nativeOverlappedPtr = AllocNativeOverlapped();
            (*nativeOverlappedPtr).ReservedCOR3 = (IntPtr)null;
            PackCore(nativeOverlappedPtr, iocb);
            return nativeOverlappedPtr;
        }

        unsafe private void PackCore(NativeOverlapped *nativeOverlappedPtr, IOCompletionCallback iocb)
        {

            /* Copy managed overlapped to native overlapped */

            (*nativeOverlappedPtr).OffsetLow = offsetLow;
            (*nativeOverlappedPtr).OffsetHigh = offsetHigh;
            (*nativeOverlappedPtr).EventHandle = eventHandle;

            /* Remember what app domain we came from */

            (*nativeOverlappedPtr).ReservedCOR1 = AppDomain.CurrentDomain.GetId();

            /* Create gchandles to root the callback and asyncresult
               and stuff them in the reserved slots in native overlapped struct*/

            (*nativeOverlappedPtr).ReservedCOR2 = GCHandle.Alloc(iocb);
            (*nativeOverlappedPtr).ReservedClasslib = GCHandle.Alloc(asyncResult);

        }

        /*====================================================================
        *  Unpacks an unmanaged native Overlapped struct. 
        *  Unpins the native Overlapped struct
        ====================================================================*/
        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.Unpack"]/*' />
        [CLSCompliant(false)]
        unsafe public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr)
        {
            if (nativeOverlappedPtr == null)
                throw new ArgumentNullException("nativeOverlappedPtr");

            // Debugging aid
            if (nativeOverlappedPtr->ReservedCOR1 == unchecked((int)0xdeadbeef))
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_OverlappedFreed"));

            if (AppDomain.CurrentDomain.GetId() 
                != (*nativeOverlappedPtr).ReservedCOR1)
            {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnpackInWrongAppdomain")); 
            }
            
            Overlapped overlapped = new Overlapped();

            overlapped.offsetLow = (*nativeOverlappedPtr).OffsetLow;
            overlapped.offsetHigh = (*nativeOverlappedPtr).OffsetHigh;
            overlapped.internalLow = (*nativeOverlappedPtr).InternalLow;
            overlapped.internalHigh = (*nativeOverlappedPtr).InternalHigh;
            overlapped.eventHandle = (*nativeOverlappedPtr).EventHandle;

            GCHandle eeHandleForAr = (*nativeOverlappedPtr).ReservedClasslib;
            overlapped.asyncResult = (IAsyncResult) eeHandleForAr.__InternalTarget;
            
            return overlapped;
        }

        /// <include file='doc\Overlapped.uex' path='docs/doc[@for="Overlapped.Free"]/*' />
        [CLSCompliant(false)]
        unsafe public static void Free(NativeOverlapped* nativeOverlappedPtr)
        {
            if (nativeOverlappedPtr == null)
                throw new ArgumentNullException("nativeOverlappedPtr");

            // Debugging aid
            if (nativeOverlappedPtr->ReservedCOR1 == unchecked((int)0xdeadbeef))
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_OverlappedFreedTwice"));
            nativeOverlappedPtr->ReservedCOR1 = unchecked((int)0xdeadbeef);

#if _DEBUG
            nativeOverlappedPtr->InternalHigh = unchecked((int)0xdeadbeef);
            nativeOverlappedPtr->InternalLow = unchecked((int)0xdeadbeef);
            nativeOverlappedPtr->OffsetHigh = unchecked((int)0xdeadbeef);
            nativeOverlappedPtr->OffsetLow = unchecked((int)0xdeadbeef);
            nativeOverlappedPtr->EventHandle = unchecked((int)0xdeadbeef);
#endif

            GCHandle eeHandleForAr = (*nativeOverlappedPtr).ReservedClasslib;
            eeHandleForAr.__InternalFree();
            (*nativeOverlappedPtr).ReservedCOR2.__InternalFree();
            if (nativeOverlappedPtr->ReservedCOR3 != (IntPtr)null)
            {
#if _DEBUG
                if (nativeOverlappedPtr->ReservedCOR3 == (IntPtr)unchecked((int)0xdeadbeef))
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_OverlappedFreedTwice"));
#endif
                CodeAccessSecurityEngine.ReleaseDelayedCompressedStack( nativeOverlappedPtr->ReservedCOR3 );
            }

#if _DEBUG
            nativeOverlappedPtr->ReservedCOR3 = new IntPtr( unchecked((int)0xdeadbeef) );
#endif

            FreeNativeOverlapped(nativeOverlappedPtr);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern NativeOverlapped* AllocNativeOverlapped();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern void FreeNativeOverlapped(NativeOverlapped* nativeOverlappedPtr);

        private int internalLow;        // reserved for OS use
        private int internalHigh;       // reserved for OS use
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\readerwriterlock.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:    RWLock
**
** Author:   Gopal Kakivaya (GopalK)
**
** Purpose: Defines the lock that implements 
**          single-writer/multiple-reader semantics
**
** Date:    July 21, 1999
**
===========================================================*/

namespace System.Threading {
	using System.Threading;
	using System.Runtime.Remoting;
	using System;
	using System.Runtime.CompilerServices;

    /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock"]/*' />
    public sealed class ReaderWriterLock
    {
        /*
         * Constructor
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.ReaderWriterLock"]/*' />
        public ReaderWriterLock()
        {
            PrivateInitialize();
        }

        /*
         * Property that returns TRUE if the reader lock is held
         * by the current thread
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.IsReaderLockHeld"]/*' />
        public bool IsReaderLockHeld {
            get {
                return(PrivateGetIsReaderLockHeld());
                }
        }
         
        /*
         * Property that returns TRUE if the writer lock is held
         * by the current thread
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.IsWriterLockHeld"]/*' />
        public bool IsWriterLockHeld {
            get {
                return(PrivateGetIsWriterLockHeld());
                }
        }
        
        /*
         * Property that returns the current writer sequence number. 
         * The caller should be a reader or writer for getting 
         * meaningful results
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.WriterSeqNum"]/*' />
        public int WriterSeqNum {
            get {
                return(PrivateGetWriterSeqNum());
                }
        }
        
        /*
         * Acquires reader lock. The thread will block if a different
         * thread has writer lock.
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.AcquireReaderLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void AcquireReaderLock(int millisecondsTimeout);
		
		/// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.AcquireReaderLock1"]/*' />
		public void AcquireReaderLock(TimeSpan timeout)
		{
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			AcquireReaderLock((int)tm);
		}
        
        /*
         * Acquires writer lock. The thread will block if a different
         * thread has reader lock. It will dead lock if this thread
         * has reader lock. Use UpgardeToWriterLock when you are not
         * sure if the thread has reader lock
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.AcquireWriterLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void AcquireWriterLock(int millisecondsTimeout);

		/// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.AcquireWriterLock1"]/*' />
		public void AcquireWriterLock(TimeSpan timeout)
		{
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			AcquireWriterLock((int)tm);
		}
        
        
        /*
         * Releases reader lock. 
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.ReleaseReaderLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void ReleaseReaderLock();
        
        /*
         * Releases writer lock. 
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.ReleaseWriterLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void ReleaseWriterLock();
        
        /*
         * Upgardes the thread to a writer. If the thread has is a
         * reader, it is possible that the reader lock was 
         * released before writer lock was acquired.
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.UpgradeToWriterLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern LockCookie UpgradeToWriterLock(int millisecondsTimeout);

		/// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.UpgradeToWriterLock1"]/*' />
		public LockCookie UpgradeToWriterLock(TimeSpan timeout)
		{
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			return UpgradeToWriterLock((int)tm);
		}
        
        /*
         * Restores the lock status of the thread to the one it was
         * in when it called UpgradeToWriterLock. 
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.DowngradeFromWriterLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void DowngradeFromWriterLock(ref LockCookie lockCookie);
        
        /*
         * Releases the lock irrespective of the number of times the thread
         * acquired the lock
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.ReleaseLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern LockCookie ReleaseLock();
        
        /*
         * Restores the lock status of the thread to the one it was
         * in when it called ReleaseLock. 
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.RestoreLock"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void RestoreLock(ref LockCookie lockCookie);
    
        /*
         * Internal helper that returns TRUE if the reader lock is held
         * by the current thread
         */
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern bool PrivateGetIsReaderLockHeld();
        
        /*
         * Internal helper that returns TRUE if the writer lock is held
         * by the current thread
         */
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern bool PrivateGetIsWriterLockHeld();
        
        /*
         * Internal helper that returns the current writer sequence 
         * number. The caller should be a reader or writer for getting 
         * meaningful results
         */
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int PrivateGetWriterSeqNum();
        
        /*
         * Returns true if there were intermediate writes since the 
         * sequence number was obtained. The caller should be
         * a reader or writer for getting meaningful results
         */
        /// <include file='doc\ReaderWriterLock.uex' path='docs/doc[@for="ReaderWriterLock.AnyWritersSince"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern bool AnyWritersSince(int seqNum);
    
        // Initialize state kept inside the lock
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void PrivateInitialize();
    
        // State    
        private int _hWriterEvent = 0;
        private int _hReaderEvent = 0;
        private int _dwState = 0;
        private int _dwULockID = 0;
        private int _dwLLockID = 0;
        private int _dwWriterID = 0;
        private int _dwWriterSeqNum = 0;
        private int _wFlagsAnd_wWriterLevel = 0;
        private int _dwReaderEntryCount = 0;
        private int _dwReaderContentionCount = 0;
        private int _dwWriterEntryCount = 0;
        private int _dwWriterContentionCount = 0;
        private int _dwEventsReleasedCount = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\synchronizationlockexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: SynchronizationLockException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Wait(), Notify() or NotifyAll() was called from an unsynchronized
**          block of code.
**
** Date: March 30, 1998
**
=============================================================================*/

namespace System.Threading {

	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\SynchronizationLockException.uex' path='docs/doc[@for="SynchronizationLockException"]/*' />
    [Serializable()] public class SynchronizationLockException : SystemException {
        /// <include file='doc\SynchronizationLockException.uex' path='docs/doc[@for="SynchronizationLockException.SynchronizationLockException"]/*' />
        public SynchronizationLockException() 
            : base(Environment.GetResourceString("Arg_SynchronizationLockException")) {
    		SetErrorCode(__HResults.COR_E_SYNCHRONIZATIONLOCK);
        }
    
        /// <include file='doc\SynchronizationLockException.uex' path='docs/doc[@for="SynchronizationLockException.SynchronizationLockException1"]/*' />
        public SynchronizationLockException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_SYNCHRONIZATIONLOCK);
        }
    
    	/// <include file='doc\SynchronizationLockException.uex' path='docs/doc[@for="SynchronizationLockException.SynchronizationLockException2"]/*' />
    	public SynchronizationLockException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_SYNCHRONIZATIONLOCK);
        }

        /// <include file='doc\SynchronizationLockException.uex' path='docs/doc[@for="SynchronizationLockException.SynchronizationLockException3"]/*' />
        protected SynchronizationLockException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadinterruptedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadInterruptedException
**
** Author: Chris Brumme (cbrumme)
**
** Purpose: An exception class to indicate that the thread was interrupted
**          from a waiting state.
**
** Date: April 1, 1998
**
=============================================================================*/
namespace System.Threading {
	using System.Threading;
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\ThreadInterruptedException.uex' path='docs/doc[@for="ThreadInterruptedException"]/*' />
    [Serializable()] public class ThreadInterruptedException : SystemException {
        /// <include file='doc\ThreadInterruptedException.uex' path='docs/doc[@for="ThreadInterruptedException.ThreadInterruptedException"]/*' />
        public ThreadInterruptedException() 
	        : base(Environment.GetResourceString("Arg_ThreadInterruptedException")) {
    		SetErrorCode(__HResults.COR_E_THREADINTERRUPTED);
        }
    	
        /// <include file='doc\ThreadInterruptedException.uex' path='docs/doc[@for="ThreadInterruptedException.ThreadInterruptedException1"]/*' />
        public ThreadInterruptedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_THREADINTERRUPTED);
        }
    
        /// <include file='doc\ThreadInterruptedException.uex' path='docs/doc[@for="ThreadInterruptedException.ThreadInterruptedException2"]/*' />
        public ThreadInterruptedException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_THREADINTERRUPTED);
        }

        /// <include file='doc\ThreadInterruptedException.uex' path='docs/doc[@for="ThreadInterruptedException.ThreadInterruptedException3"]/*' />
        protected ThreadInterruptedException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadpool.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadPool
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Class for creating and managing a threadpool
**
** Date: August, 1999
**
=============================================================================*/

/*
 * Below you'll notice two sets of APIs that are separated by the
 * use of 'Unsafe' in their names.  The unsafe versions are called
 * that because they do not propagate the calling stack onto the
 * worker thread.  This allows code to lose the calling stack and 
 * thereby elevate its security privileges.  Note that this operation
 * is much akin to the combined ability to control security policy
 * and control security evidence.  With these privileges, a person 
 * can gain the right to load assemblies that are fully trusted which
 * then assert full trust and can call any code they want regardless
 * of the previous stack information.
 */

namespace System.Threading {
	using System.Threading;
	using System.Runtime.Remoting;
    using System.Security.Permissions;
	using System;
    using Microsoft.Win32;
	using System.Runtime.CompilerServices;

    /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="RegisteredWaitHandle"]/*' />
    public sealed class RegisteredWaitHandle : MarshalByRefObject
    {
    
    	private IntPtr registeredWaitHandle;
    	private static readonly IntPtr InvalidHandle = Win32Native.INVALID_HANDLE_VALUE;
        
		internal RegisteredWaitHandle()
    	{
    	   registeredWaitHandle = InvalidHandle;
    	}

    	internal IntPtr GetHandle()
    	{
    	   return registeredWaitHandle;
    	}
    
    	internal void SetHandle(IntPtr handle)
    	{
    	   registeredWaitHandle = handle;
    	}
    
    	// This is the only public method on this class
    	/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="RegisteredWaitHandle.Unregister"]/*' />
    	public bool Unregister(             
    		 WaitHandle		waitObject 		    // object to be notified when all callbacks to delegates have completed
    		 )
    	{
    		 bool result = false;
			 lock(this)
             {
			     if (ValidHandle())
    		     {
    			    result = UnregisterWaitNative(GetHandle(), waitObject != null ? waitObject.Handle : new IntPtr(0));
    			    SetHandle(InvalidHandle);
				    GC.SuppressFinalize(this);
    		     }
             }
    		 return result;  // @TODO: this should throw an exception?
    	}
    
        private bool ValidHandle()
    	{
    		return (registeredWaitHandle != InvalidHandle);
    	}
        

	    /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="RegisteredWaitHandle.Finalize"]/*' />
        ~RegisteredWaitHandle()
    	{
		     // if the app has already unregistered the wait, there is nothing to cleanup
			 // we can detect this by checking the handle. Normally, there is no race here
			 // so no need to protect reading of handle. However, if this object gets 
			 // resurrected and then someone does an unregister, it would introduce a race
    	     lock (this)
    	     {
    			if (ValidHandle())
				{
					WaitHandleCleanupNative(registeredWaitHandle);
					registeredWaitHandle = InvalidHandle;  	
				}
			}
    	}

    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern bool UnregisterWaitNative(IntPtr handle, IntPtr waitObject);

		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		private static extern void WaitHandleCleanupNative(IntPtr handle);
    		
    }
    
    /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="WaitCallback"]/*' />
    public delegate void WaitCallback(Object state);
    /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="WaitOrTimerCallback"]/*' />
    public delegate void WaitOrTimerCallback(Object state, bool timedOut);  // signalled or timed out
    /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="IOCompletionCallback"]/*' />
    [CLSCompliant(false)]
    unsafe public delegate void IOCompletionCallback(uint errorCode, // Error code
    	                               uint numBytes, // No. of bytes transferred 
                                       NativeOverlapped* pOVERLAP // ptr to OVERLAP structure
    								   );   
    /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool"]/*' />
    public sealed class ThreadPool
    {   
        //private static uint MAX_SUPPORTED_TIMEOUT = 0xfffffffe;

        private ThreadPool() {throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor));}	// never instantiate this class (there is only one managed threadpool per process)
        
        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.GetMaxThreads"]/*' />
        public static void GetMaxThreads(out int workerThreads, out int completionPortThreads)
        {
            GetMaxThreadsNative(out workerThreads, out completionPortThreads);
        }

        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.SetMinThreads"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, ControlThread = true)]
        public static bool SetMinThreads(int workerThreads, int completionPortThreads)
        {
            return SetMinThreadsNative(workerThreads, completionPortThreads);
        }

        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.GetMinThreads"]/*' />
        public static void GetMinThreads(out int workerThreads, out int completionPortThreads)
        {
            GetMinThreadsNative(out workerThreads, out completionPortThreads);
        }

        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.GetAvailableThreads"]/*' />
        public static void GetAvailableThreads(out int workerThreads, out int completionPortThreads)
        {
            GetAvailableThreadsNative(out workerThreads, out completionPortThreads);
        }

    	/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.RegisterWaitForSingleObject"]/*' />
        [CLSCompliant(false)]
    	public static RegisteredWaitHandle RegisterWaitForSingleObject(  // throws RegisterWaitException
    	     WaitHandle 			waitObject,
             WaitOrTimerCallback	callBack,
             Object					state,
    		 uint				millisecondsTimeOutInterval,
             bool				executeOnlyOnce    // NOTE: we do not allow other options that allow the callback to be queued as an APC
    		 )
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return RegisterWaitForSingleObject(waitObject,callBack,state,millisecondsTimeOutInterval,executeOnlyOnce,ref stackMark,true);
    	}

    	/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.UnsafeRegisterWaitForSingleObject"]/*' />
        [CLSCompliant(false),
         SecurityPermissionAttribute( SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
    	public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(  // throws RegisterWaitException
    	     WaitHandle 			waitObject,
             WaitOrTimerCallback	callBack,
             Object					state,
    		 uint				millisecondsTimeOutInterval,
             bool				executeOnlyOnce    // NOTE: we do not allow other options that allow the callback to be queued as an APC
    		 )
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return RegisterWaitForSingleObject(waitObject,callBack,state,millisecondsTimeOutInterval,executeOnlyOnce,ref stackMark,false);
    	}


    	private static RegisteredWaitHandle RegisterWaitForSingleObject(  // throws RegisterWaitException
    	     WaitHandle 			waitObject,
             WaitOrTimerCallback	callBack,
             Object					state,
    		 uint				millisecondsTimeOutInterval,
             bool				executeOnlyOnce,   // NOTE: we do not allow other options that allow the callback to be queued as an APC
             ref StackCrawlMark stackMark,
             bool               compressStack
    		 )
        {
            if (RemotingServices.IsTransparentProxy(waitObject))
				throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_WaitOnTransparentProxy"));
            RegisteredWaitHandle registeredWaitHandle = new RegisteredWaitHandle();
    		IntPtr nativeRegisteredWaitHandle = RegisterWaitForSingleObjectNative(waitObject,
			                                                                   callBack,
																			   state, 
																			   millisecondsTimeOutInterval,
																			   executeOnlyOnce,
																			   registeredWaitHandle,
                                                                               ref stackMark,
                                                                               compressStack);
            registeredWaitHandle.SetHandle(nativeRegisteredWaitHandle);
    		return registeredWaitHandle;
    	}


        
    	/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.RegisterWaitForSingleObject1"]/*' />
    	public static RegisteredWaitHandle RegisterWaitForSingleObject(  // throws RegisterWaitException
    	     WaitHandle 			waitObject,
             WaitOrTimerCallback	callBack,
             Object					state,
    		 int					millisecondsTimeOutInterval,
             bool				executeOnlyOnce    // NOTE: we do not allow other options that allow the callback to be queued as an APC
    		 )
    	{
    		if (millisecondsTimeOutInterval < -1)
    			throw new ArgumentOutOfRangeException("millisecondsTimeOutInterval", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    		return RegisterWaitForSingleObject(waitObject,callBack,state,(UInt32)millisecondsTimeOutInterval,executeOnlyOnce,ref stackMark,true);
    	}

    	/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.UnsafeRegisterWaitForSingleObject1"]/*' />
        [SecurityPermissionAttribute( SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
    	public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(  // throws RegisterWaitException
    	     WaitHandle 			waitObject,
             WaitOrTimerCallback	callBack,
             Object					state,
    		 int					millisecondsTimeOutInterval,
             bool				executeOnlyOnce    // NOTE: we do not allow other options that allow the callback to be queued as an APC
    		 )
    	{
    		if (millisecondsTimeOutInterval < -1)
    			throw new ArgumentOutOfRangeException("millisecondsTimeOutInterval", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    		return RegisterWaitForSingleObject(waitObject,callBack,state,(UInt32)millisecondsTimeOutInterval,executeOnlyOnce,ref stackMark,false);
    	}

		/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.RegisterWaitForSingleObject2"]/*' />
		public static RegisteredWaitHandle RegisterWaitForSingleObject(  // throws RegisterWaitException
			WaitHandle 			waitObject,
			WaitOrTimerCallback	callBack,
			Object					state,
			long				    millisecondsTimeOutInterval,
			bool				executeOnlyOnce    // NOTE: we do not allow other options that allow the callback to be queued as an APC
		)
		{
			if (millisecondsTimeOutInterval < -1)
				throw new ArgumentOutOfRangeException("millisecondsTimeOutInterval", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			// @COOLPORT: It seems like a long is always less than MAX_SUPPORTED_TYPEMOUT,
			//	and that we should be checking for a negative value.
			//if (timeOutInterval > MAX_SUPPORTED_TIMEOUT)
			//	throw new NotSupportedException(Environment.GetResourceString("NotSupported_TimeoutTooLarge"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
			return RegisterWaitForSingleObject(waitObject,callBack,state,(UInt32)millisecondsTimeOutInterval,executeOnlyOnce,ref stackMark,true);
		}

		/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.UnsafeRegisterWaitForSingleObject2"]/*' />
        [SecurityPermissionAttribute( SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
		public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(  // throws RegisterWaitException
			WaitHandle 			waitObject,
			WaitOrTimerCallback	callBack,
			Object					state,
			long				    millisecondsTimeOutInterval,
			bool				executeOnlyOnce    // NOTE: we do not allow other options that allow the callback to be queued as an APC
		)
		{
			if (millisecondsTimeOutInterval < -1)
				throw new ArgumentOutOfRangeException("millisecondsTimeOutInterval", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			// @COOLPORT: It seems like a long is always less than MAX_SUPPORTED_TYPEMOUT,
			//	and that we should be checking for a negative value.
			//if (timeOutInterval > MAX_SUPPORTED_TIMEOUT)
			//	throw new NotSupportedException(Environment.GetResourceString("NotSupported_TimeoutTooLarge"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
			return RegisterWaitForSingleObject(waitObject,callBack,state,(UInt32)millisecondsTimeOutInterval,executeOnlyOnce,ref stackMark,false);
		}

    	
		/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.RegisterWaitForSingleObject3"]/*' />
		public static RegisteredWaitHandle RegisterWaitForSingleObject(
                          WaitHandle            waitObject,
                          WaitOrTimerCallback	callBack,
                          Object                state,
                          TimeSpan              timeout,
                          bool                  executeOnlyOnce
                          )
		{
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			if (tm > (long) Int32.MaxValue)
				throw new NotSupportedException(Environment.GetResourceString("NotSupported_TimeoutTooLarge"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
			return RegisterWaitForSingleObject(waitObject,callBack,state,(UInt32)tm,executeOnlyOnce,ref stackMark,true);
		}

		/// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.UnsafeRegisterWaitForSingleObject3"]/*' />
        [SecurityPermissionAttribute( SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
		public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(
                          WaitHandle            waitObject,
                          WaitOrTimerCallback	callBack,
                          Object                state,
                          TimeSpan              timeout,
                          bool                  executeOnlyOnce
                          )
		{
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			if (tm > (long) Int32.MaxValue)
				throw new NotSupportedException(Environment.GetResourceString("NotSupported_TimeoutTooLarge"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
			return RegisterWaitForSingleObject(waitObject,callBack,state,(UInt32)tm,executeOnlyOnce,ref stackMark,false);
		}

			 
        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.QueueUserWorkItem"]/*' />
        public static bool QueueUserWorkItem(			
    	     WaitCallback			callBack,     // NOTE: we do not expose options that allow the callback to be queued as an APC
    		 Object                 state
    		 )
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return QueueUserWorkItem(callBack,state,ref stackMark,true);
        }
        
        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.QueueUserWorkItem1"]/*' />
        public static bool QueueUserWorkItem(			
    	     WaitCallback			callBack     // NOTE: we do not expose options that allow the callback to be queued as an APC
    		 )
    	{
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    		return QueueUserWorkItem(callBack,null,ref stackMark,true);
    	}
    
        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.UnsafeQueueUserWorkItem"]/*' />
        [SecurityPermissionAttribute( SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
        public static bool UnsafeQueueUserWorkItem(
             WaitCallback			callBack,     // NOTE: we do not expose options that allow the callback to be queued as an APC
    		 Object                 state
    		 )
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return QueueUserWorkItem(callBack,state,ref stackMark,false);
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool QueueUserWorkItem( WaitCallback callBack, Object state, ref StackCrawlMark stackMark, bool compressStack );

        /// <include file='doc\ThreadPool.uex' path='docs/doc[@for="ThreadPool.BindHandle"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        public static bool BindHandle(
             IntPtr osHandle
    		 )
    	{
    		return BindIOCompletionCallbackNative(osHandle);
    	}
    
    	// Native methods: 
    
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern void GetMaxThreadsNative(out int workerThreads, out int completionPortThreads);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool SetMinThreadsNative(int workerThreads, int completionPortThreads);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void GetMinThreadsNative(out int workerThreads, out int completionPortThreads);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern void GetAvailableThreadsNative(out int workerThreads, out int completionPortThreads);

    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern IntPtr RegisterWaitForSingleObjectNative(  
    	     WaitHandle				waitHandle,
             WaitOrTimerCallback	callBack,
    		 Object                 state,
    		 long					timeOutInterval,
             bool				    executeOnlyOnce,
			 RegisteredWaitHandle   registeredWaitHandle,
             ref StackCrawlMark     stackMark,
             bool                   compressStack   
    		 );
    		 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern bool BindIOCompletionCallbackNative(IntPtr fileHandle);
    
    }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadpriority.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadPriority
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: Enums for the priorities of a Thread
**
** Date: Feb 2, 2000
**
=============================================================================*/

namespace System.Threading {
	using System.Threading;

    /// <include file='doc\ThreadPriority.uex' path='docs/doc[@for="ThreadPriority"]/*' />
	[Serializable()]
    public enum ThreadPriority
    {   
        /*=========================================================================
        ** Constants for thread priorities.
        =========================================================================*/
        /// <include file='doc\ThreadPriority.uex' path='docs/doc[@for="ThreadPriority.Lowest"]/*' />
        Lowest = 0,
        /// <include file='doc\ThreadPriority.uex' path='docs/doc[@for="ThreadPriority.BelowNormal"]/*' />
        BelowNormal = 1,
        /// <include file='doc\ThreadPriority.uex' path='docs/doc[@for="ThreadPriority.Normal"]/*' />
        Normal = 2,
        /// <include file='doc\ThreadPriority.uex' path='docs/doc[@for="ThreadPriority.AboveNormal"]/*' />
        AboveNormal = 3,
        /// <include file='doc\ThreadPriority.uex' path='docs/doc[@for="ThreadPriority.Highest"]/*' />
        Highest = 4
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadstart.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadStart
**
** Author: Darylo
**
** Purpose: This class is a Delegate which defines the start method
**	for starting a thread.  That method must match this delegate.
**
** Date: August 1998
**
=============================================================================*/

namespace System.Threading {
	using System.Threading;

    // Define the delgate
    // NOTE: If you change the signature here, there is code in COMSynchronization
    //	that invokes this delegate in native.
    /// <include file='doc\ThreadStart.uex' path='docs/doc[@for="ThreadStart"]/*' />
    public delegate void ThreadStart();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadabortexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadAbortException
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: An exception class which is thrown into a thread to cause it to
**          abort. This is a special non-catchable exception and results in
**			the thread's death.  This is thrown by the VM only and can NOT be
**          thrown by any user thread, and subclassing this is useless.
**
** Date: February, 2000
**
=============================================================================*/

namespace System.Threading {
    
    
    using System;
    using System.Runtime.Serialization;

    /// <include file='doc\ThreadAbortException.uex' path='docs/doc[@for="ThreadAbortException"]/*' />
    [Serializable()] public sealed class ThreadAbortException : SystemException {
    	private ThreadAbortException() 
	        : base(Environment.GetResourceString("Arg_ThreadAbortException")) {
    		SetErrorCode(__HResults.COR_E_THREADABORTED);
        }

        //required for serialization
        internal ThreadAbortException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
   
        private ThreadAbortException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_THREADABORTED);
        }
    
        private ThreadAbortException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_THREADABORTED);
        }

		/// <include file='doc\ThreadAbortException.uex' path='docs/doc[@for="ThreadAbortException.ExceptionState"]/*' />
		public Object ExceptionState {
			get {return Thread.CurrentThread.ExceptionState;}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\thread.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Thread
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Class for creating and managing a thread.
**
** Date: April 1, 1998
**
=============================================================================*/

namespace System.Threading {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Contexts;    
    using System.Runtime.Remoting.Messaging;
    using System;
    using System.Diagnostics;
    using System.Security.Permissions;
    using System.Security.Principal;
    using System.Globalization;
    using System.Collections;
    using System.Runtime.Serialization;
	 using System.Runtime.CompilerServices;
    using System.Security;
        
    /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread"]/*' />
    // deliberately not [serializable]
    public sealed class Thread
    {   
        /*=========================================================================
        ** Data accessed from managed code that needs to be defined in 
        ** ThreadBaseObject to maintain alignment between the two classes.
        ** DON'T CHANGE THESE UNLESS YOU MODIFY ThreadBaseObject in vm\object.h
        =========================================================================*/
        private Context            m_Context;
        private LogicalCallContext m_LogicalCallContext;      // this call context follows the logical thread
        private IllogicalCallContext m_IllogicalCallContext;  // this call context follows the physical thread
        private String m_Name;
        private Object m_ExceptionStateInfo;          // Excep. Info. latched to the thread on a thread abort
        private Delegate m_Delegate;                // Delegate
        private LocalDataStoreSlot m_PrincipalSlot;
        private Object[] m_ThreadStatics;           // Holder for thread statics
        private int[] m_ThreadStaticsBits;         // Bit-markers for slot availability
        private CultureInfo        m_CurrentCulture;
        private CultureInfo        m_CurrentUICulture;

        /*=========================================================================
        ** The base implementation of Thread is all native.  The following fields
        ** should never be used in the C# code.  They are here to define the proper
        ** space so the thread object may be allocated.  DON'T CHANGE THESE UNLESS
        ** YOU MODIFY ThreadBaseObject in vm\object.h
        ** @TODO: what about architecture?
        =========================================================================*/
        private int m_Priority;                     // INT32
        private IntPtr DONT_USE_InternalThread;        // Pointer
        
        /*=========================================================================
        ** This manager is responsible for storing the global data that is 
        ** shared amongst all the thread local stores.
        =========================================================================*/
        static private LocalDataStoreMgr m_LocalDataStoreMgr = new LocalDataStoreMgr();
        private const int STATICS_START_SIZE = 32;    

        
        /*=========================================================================
        ** Creates a new Thread object which will begin execution at
        ** start.ThreadStart on a new thread when the Start method is called.
        **
        ** Exceptions: ArgumentNullException if start == null.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Thread"]/*' />
        public Thread(ThreadStart start) {
            if (start == null) {
                throw new ArgumentNullException("start");
            }
            SetStart(start);
        }
    
        /*=========================================================================
        ** Spawns off a new thread which will begin executing at the ThreadStart
        ** method on the IThreadable interface passed in the constructor. Once the
        ** thread is dead, it cannot be restarted with another call to Start.
        **
        ** Exceptions: ThreadStateException if the thread has already been started.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Start"]/*' />
        public void Start()
        {
            // Attach current thread's security principal object to the new
            // thread. Be careful not to bind the current thread to a principal
            // if it's not already bound.
            IPrincipal principal = (IPrincipal) CallContext.SecurityData.Principal;
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            StartInternal(principal, ref stackMark);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void StartInternal(IPrincipal principal, ref StackCrawlMark stackMark);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.SetCompressedStack"]/*' />
        /// <internalonly/>
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x00000000000000000400000000000000"),
         SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        public void SetCompressedStack( CompressedStack stack )
        {
            if (stack != null)
                SetCompressedStackInternal( stack.UnmanagedCompressedStack );
            else
                SetCompressedStackInternal( (IntPtr)0 );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void SetCompressedStackInternal( IntPtr unmanagedCompressedStack );

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.GetCompressedStack"]/*' />
        /// <internalonly/>
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x00000000000000000400000000000000"),
         SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        public CompressedStack GetCompressedStack()
        {
            return new CompressedStack( GetCompressedStackInternal() ); 
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr GetCompressedStackInternal();

        /*=========================================================================
        ** Raises a ThreadAbortException in the thread, which usually
        ** results in the thread's death. The ThreadAbortException is a special
        ** exception that is not catchable. The finally clauses of all try 
        ** statements will be executed before the thread dies. This includes the
        ** finally that a thread might be executing at the moment the Abort is raised.   
        ** The thread is not stopped immediately--you must Join on the
        ** thread to guarantee it has stopped. 
        ** It is possible for a thread to do an unbounded amount of computation in 
        ** the finally's and thus indefinitely delay the threads death.
        ** If Abort() is called on a thread that has not been started, the thread 
        ** will abort when Start() is called.
        ** If Abort is called twice on the same thread, a DuplicateThreadAbort 
        ** exception is thrown. 
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Abort"]/*' />

        [SecurityPermissionAttribute(SecurityAction.Demand, ControlThread=true)]
        public void Abort(Object stateInfo)
        {
            // if two aborts come at the same time, it is possible that the state info
            // gets set by one, and the actual abort gets delivered by another. But this
            // is not distinguishable by an application.
            if (ExceptionState == null)
                ExceptionState = stateInfo;

            // Note: we demand ControlThread permission, then call AbortInternal directly
            // rather than delegating to the Abort() function below. We do this to ensure
            // that only callers with ControlThread are allowed to change the ExceptionState
            // of the thread. We call AbortInternal directly to avoid demanding the same
            // permission twice.
            AbortInternal();
        }

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Abort1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, ControlThread=true)]
        public void Abort() { AbortInternal(); }

        // Internal helper (since we can't place security demands on
        // ecalls/fcalls).
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void AbortInternal();

        /*=========================================================================
        ** Resets a thread abort.
        ** Should be called by trusted code only
          =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.ResetAbort"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, ControlThread=true)]
        public static void ResetAbort()
        {
            Thread thread = Thread.CurrentThread;
            if ((thread.ThreadState & ThreadState.AbortRequested) == 0)
                throw new ThreadStateException(Environment.GetResourceString("ThreadState_NoAbortRequested"));
            thread.ResetAbortNative();
            thread.ExceptionState = null;
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void ResetAbortNative();

        /*=========================================================================
        ** Suspends the thread. If the thread is already suspended, this call has
        ** no effect.
        **
        ** Exceptions: ThreadStateException if the thread has not been started or
        **             it is dead.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Suspend"]/*' />
        [SecurityPermission(SecurityAction.Demand, ControlThread=true)]
        public void Suspend() { SuspendInternal(); }

        // Internal helper (since we can't place security demands on
        // ecalls/fcalls).
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void SuspendInternal();
    
        /*=========================================================================
        ** Resumes a thread that has been suspended.
        **
        ** Exceptions: ThreadStateException if the thread has not been started or
        **             it is dead or it isn't in the suspended state.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Resume"]/*' />
        [SecurityPermission(SecurityAction.Demand, ControlThread=true)]
        public void Resume() { ResumeInternal(); }
    
        // Internal helper (since we can't place security demands on
        // ecalls/fcalls).
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void ResumeInternal();
    
        /*=========================================================================
        ** Interrupts a thread that is inside a Wait(), Sleep() or Join().  If that
        ** thread is not currently blocked in that manner, it will be interrupted
        ** when it next begins to block.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Interrupt"]/*' />
        [SecurityPermission(SecurityAction.Demand, ControlThread=true)]
        public void Interrupt() { InterruptInternal(); }
    
        // Internal helper (since we can't place security demands on
        // ecalls/fcalls).
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void InterruptInternal();
    
        /*=========================================================================
        ** Returns the priority of the thread.
        **
        ** Exceptions: ThreadStateException if the thread is dead.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Priority"]/*' />
        public ThreadPriority Priority {
            get { return (ThreadPriority)GetPriorityNative(); }
            set { SetPriorityNative((int)value); }
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int GetPriorityNative();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void SetPriorityNative(int priority);
    
        /*=========================================================================
        ** Returns true if the thread has been started and is not dead.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.IsAlive"]/*' />
        public bool IsAlive {
            get { return IsAliveNative(); }
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern bool IsAliveNative();
    
        /*=========================================================================
        ** Returns true if the thread is a threadpool thread.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.IsThreadPoolThread"]/*' />
        public bool IsThreadPoolThread {
			get { return IsThreadpoolThreadNative();  }
		}
         
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern bool IsThreadpoolThreadNative();
       
        /*=========================================================================
        ** Waits for the thread to die.
        ** 
        ** Exceptions: ThreadInterruptedException if the thread is interrupted while waiting.
        **             ThreadStateException if the thread has not been started yet.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Join"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void Join();
    
        /*=========================================================================
        ** Waits for the thread to die or for timeout milliseconds to elapse.
        ** Returns true if the thread died, or false if the wait timed out. If
        ** Timeout.Infinite is given as the parameter, no timeout will occur.
        ** 
        ** Exceptions: ArgumentException if timeout < 0.
        **             ThreadInterruptedException if the thread is interrupted while waiting.
        **             ThreadStateException if the thread has not been started yet.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Join1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern bool Join(int millisecondsTimeout);

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Join2"]/*' />
        public bool Join(TimeSpan timeout)
        {
            long tm = (long)timeout.TotalMilliseconds;
            if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));

            return Join((int)tm);
        }
    
        /*=========================================================================
        ** Suspends the current thread for timeout milliseconds. If timeout == 0,
        ** forces the thread to give up the remainer of its timeslice.  If timeout
        ** == Timeout.Infinite, no timeout will occur.
        **
        ** Exceptions: ArgumentException if timeout < 0.
        **             ThreadInterruptedException if the thread is interrupted while sleeping.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Sleep"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void Sleep(int millisecondsTimeout);

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Sleep1"]/*' />
        public static void Sleep(TimeSpan timeout)
        {
            long tm = (long)timeout.TotalMilliseconds;
            if (tm < -1 || tm > (long) Int32.MaxValue)
                throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
            Sleep((int)tm);
        }
    

		/* wait for a length of time proportial to 'iterations'.  Each iteration is should
		   only take a few machine instructions.  Calling this API is preferable to coding 
		   a explict busy loop because the hardware can be informed that it is busy waiting. */

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.SpinWait"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void SpinWait(int iterations);


        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.CurrentThread"]/*' />
        public static Thread CurrentThread {
            get {
                Thread th;
                th = GetFastCurrentThreadNative();
                if (th == null)
                    th = GetCurrentThreadNative();
                return th;
            }
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Thread GetCurrentThreadNative();
         [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Thread GetFastCurrentThreadNative();
   
        /*=========================================================================
        ** PRIVATE Sets the IThreadable interface for the thread. Assumes that
        ** start != null.
        =========================================================================*/
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void SetStart(ThreadStart start);
    
        /*=========================================================================
        ** Clean up the thread when it goes away.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Finalize"]/*' />
        ~Thread()
        {
            // Delegate to the unmanaged portion.
            InternalFinalize();
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void InternalFinalize();
    
    
        /*=========================================================================
        ** Return whether or not this thread is a background thread.  Background
        ** threads do not affect when the Execution Engine shuts down.
        **
        ** Exceptions: ThreadStateException if the thread is dead.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.IsBackground"]/*' />
        public bool IsBackground {
            get { return IsBackgroundNative(); }
            set { SetBackgroundNative(value); }
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern bool IsBackgroundNative();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void SetBackgroundNative(bool isBackground);
        
        
        /*=========================================================================
        ** Return the thread state as a consistent set of bits.  This is more
        ** general then IsAlive or IsBackground.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.ThreadState"]/*' />
        public ThreadState ThreadState {
            get { return (ThreadState)GetThreadStateNative(); }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int GetThreadStateNative();
    
        /*=========================================================================
        ** An unstarted thread can be marked to indicate that it will host a
        ** single-threaded or multi-threaded apartment.
        **
        ** Exceptions: ArgumentException if state is not a valid apartment state
        **             (ApartmentSTA or ApartmentMTA).
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.ApartmentState"]/*' />
        public ApartmentState ApartmentState {
            get { return (ApartmentState)GetApartmentStateNative(); }
            set { SetApartmentStateNative((int)value); }
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int GetApartmentStateNative();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int SetApartmentStateNative(int state);
    
        /*=========================================================================
        ** Allocates an un-named data slot. The slot is allocated on ALL the 
        ** threads.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.AllocateDataSlot"]/*' />
        public static LocalDataStoreSlot AllocateDataSlot()
        {
            return m_LocalDataStoreMgr.AllocateDataSlot();
        }
        
        /*=========================================================================
        ** Allocates a named data slot. The slot is allocated on ALL the 
        ** threads.  Named data slots are "public" and can be manipulated by
        ** anyone.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.AllocateNamedDataSlot"]/*' />
        public static LocalDataStoreSlot AllocateNamedDataSlot(String name)
        {
            return m_LocalDataStoreMgr.AllocateNamedDataSlot(name);
        }
        
        /*=========================================================================
        ** Looks up a named data slot. If the name has not been used, a new slot is
        ** allocated.  Named data slots are "public" and can be manipulated by
        ** anyone.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.GetNamedDataSlot"]/*' />
        public static LocalDataStoreSlot GetNamedDataSlot(String name)
        {
            return m_LocalDataStoreMgr.GetNamedDataSlot(name);
        }

        /*=========================================================================
        ** Frees a named data slot. The slot is allocated on ALL the 
        ** threads.  Named data slots are "public" and can be manipulated by
        ** anyone.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.FreeNamedDataSlot"]/*' />
        public static void FreeNamedDataSlot(String name)
        {
            m_LocalDataStoreMgr.FreeNamedDataSlot(name);
        }
        
        /*=========================================================================
        ** Retrieves the value from the specified slot on the current thread, for that thread's current domain.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.GetData"]/*' />
        public static Object GetData(LocalDataStoreSlot slot)
        {
            m_LocalDataStoreMgr.ValidateSlot(slot);
    
            LocalDataStore dls = GetDomainLocalStore();
            if (dls == null)
                return null;

            return dls.GetData(slot);
        }

        /*=========================================================================
        ** Sets the data in the specified slot on the currently running thread, for that thread's current domain.
        =========================================================================*/
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.SetData"]/*' />
        public static void SetData(LocalDataStoreSlot slot, Object data)
        {   
            LocalDataStore dls = GetDomainLocalStore();

            // Create new DLS if one hasn't been created for this domain for this thread
            if (dls == null) {
                dls = m_LocalDataStoreMgr.CreateLocalDataStore();
                SetDomainLocalStore(dls);
            }

            dls.SetData(slot, data);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern private LocalDataStore GetDomainLocalStore();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern private void SetDomainLocalStore(LocalDataStore dls);
       
        /***
         * An appdomain has been unloaded - remove its DLS from the manager
         */
        static private void RemoveDomainLocalStore(LocalDataStore dls)
        {
            if (dls != null)
                m_LocalDataStoreMgr.DeleteLocalDataStore(dls);
        }

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.CurrentUICulture"]/*' />
        public CultureInfo CurrentUICulture {
            get {
                if (null==m_CurrentUICulture) {
                    return CultureInfo.UserDefaultUICulture;
                }
                return m_CurrentUICulture;
            }

            set {
                if (null==value) {
                    throw new ArgumentNullException("value");
                }

                //If they're trying to use a Culture with a name that we can't use in resource lookup,
                //don't even let them set it on the thread.
                CultureInfo.VerifyCultureName(value, true);

                m_CurrentUICulture = value;
            }
        }

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.CurrentCulture"]/*' />
        public CultureInfo CurrentCulture {
            get {
                if (null==m_CurrentCulture) {
                    return CultureInfo.UserDefaultCulture;
                }
                return m_CurrentCulture;
            }

            [SecurityPermission(SecurityAction.Demand, ControlThread=true)]
            set {
                if (null==value) {
                    throw new ArgumentNullException("value");
                }
                CultureInfo.CheckNeutral(value);
                
                //If we can't set the nativeThreadLocale, we'll just let it stay
                //at whatever value it had before.  This allows people who use
                //just managed code not to be limited by the underlying OS.
                CultureInfo.nativeSetThreadLocale(value.LCID);
                m_CurrentCulture = value;
            }
        }



        /*===============================================================
        ====================== Thread Statics ===========================
        ===============================================================*/
        private int ReserveSlot()
        {
            // This is called by the thread on itself so no need for locks
            if (m_ThreadStatics == null)
            {
                // allocate the first bucket
                m_ThreadStatics = new Object[STATICS_START_SIZE];

                m_ThreadStaticsBits = new int[STATICS_START_SIZE/32];
                // use memset!
                for (int i=0; i<m_ThreadStaticsBits.Length; i++)
                {
                    m_ThreadStaticsBits[i] = unchecked((int)0xffffffff);    
                }
                // block the 0th position, we don't want any static to have
                // slot #0 in the array.
                // also we clear the bit for slot #1 
                m_ThreadStaticsBits[0] &= ~3;
                return 1;
            }
            int slot = FindSlot();
            // slot == 0 => all slots occupied
            if (slot == 0)
            {
                //Console.WriteLine("Growing Arrays");
                int oldLength = m_ThreadStatics.Length;
                int oldLengthBits = m_ThreadStaticsBits.Length;
                Object[] newStatics = new Object[oldLength*2];
                int[] newBits = new int[oldLengthBits*2]; 

                BCLDebug.Assert(oldLength == oldLengthBits*32,"Arrays not in sync?");

                Array.Copy(m_ThreadStatics, newStatics, m_ThreadStatics.Length);
                for(int i=oldLengthBits;i<oldLengthBits*2;i++)
                {
                    newBits[i] = unchecked((int)0xffffffff);
                }
                Array.Copy(m_ThreadStaticsBits, newBits, m_ThreadStaticsBits.Length);
                m_ThreadStatics = newStatics;
                m_ThreadStaticsBits = newBits;

                // Return the first slot in the expanded area
                m_ThreadStaticsBits[oldLengthBits] &= ~1;
                return oldLength;
            }
            return slot;
        }

        int FindSlot()
        {
            int slot = 0;   // 0 is not a valid slot number
            int bits = 0;
            int i;
            bool bFound = false;
            for (i=0; i<m_ThreadStaticsBits.Length; i++)
            {
                bits = m_ThreadStaticsBits[i]; 
                if (bits != 0)
                {
                    if ( (bits&0xffff) != 0)
                    {
                        bits = bits&0xffff;
                    }
                    else
                    {
                        bits = (bits>>16)&0xffff;
                        slot+=16;
                    }
                    if ((bits & 0xff) != 0)
                    {
                        bits = bits & 0xff;
                    }
                    else
                    {
                        slot+=8;
                        bits = (bits>>8)&0xff;
                    }
                    int j;
                    for (j=0; j<8; j++)
                    {
                        if ( (bits & (1<<j)) != 0)
                        {
                            bFound = true; 
                            break;
                        }
                    }     
                    BCLDebug.Assert(j<8,"Bad bits?");
                    slot += j;
                    m_ThreadStaticsBits[i] &= ~(1<<slot);
                    break;
                }
            }
            if (bFound)
            {
                slot = slot + 32*i;
            }
            BCLDebug.Assert( bFound || slot==0, "Bad bits");
            return slot;
        }
        /*=============================================================*/

        /*======================================================================
        **  Current thread context is stored in a slot in the thread local store
        **  CurrentContext gets the Context from the slot.
        ======================================================================*/

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.CurrentContext"]/*' />
        public static Context CurrentContext
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get
            {
                return CurrentThread.GetCurrentContextInternal();
            }
        }

        internal Context GetCurrentContextInternal()
        {
            if (m_Context == null)
            {
                m_Context = Context.DefaultContext;
            }
            return m_Context;
        }
    
        internal LogicalCallContext GetLogicalCallContext()
        {
            if (m_LogicalCallContext == null)
            {
                m_LogicalCallContext = new LogicalCallContext();
            }
            return m_LogicalCallContext;
        }

        internal LogicalCallContext SetLogicalCallContext(
            LogicalCallContext callCtx)
        {
            LogicalCallContext oldCtx = m_LogicalCallContext;
            m_LogicalCallContext = callCtx;
            return oldCtx;
        }

        internal IllogicalCallContext GetIllogicalCallContext()
        {
            if (m_IllogicalCallContext == null)
            {
                m_IllogicalCallContext = new IllogicalCallContext();
            }
            return m_IllogicalCallContext;
        }
    
        // Get and set thread's current principal (for role based security).
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.CurrentPrincipal"]/*' />
        public static IPrincipal CurrentPrincipal
        {
            get
            {
                lock (CurrentThread)
                {
                    IPrincipal principal = (IPrincipal)
                        CallContext.SecurityData.Principal;
                    if (principal == null)
                    {
                        principal = GetDomain().GetThreadPrincipal();
                        CallContext.SecurityData.Principal = principal;
                    }
                    return principal;
                }
            }

            [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
            set
            {
                CallContext.SecurityData.Principal = value;
            }       
        }

        // Private routine called from unmanaged code to set an initial
        // principal for a newly created thread.
        private void SetPrincipalInternal(IPrincipal principal)
        {
            GetLogicalCallContext().SecurityData.Principal = principal;
        }

        // This returns the exposed context for a given context ID.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Context GetContextInternal(Int32 id);

        internal void EnterContext(Context newContext, ref ContextTransitionFrame frame)
        {
            EnterContextInternal(newContext, newContext.InternalContextID, 0, ref frame);
            // The newContext parameter is passed in just to keep GC from
            // collecting a new context when we are trying to enter it.
            // By the time this returns, the m_Context field in the managed
            // thread is already set to the newContext ... so from there on
            // the newContext is rooted.
            
            // EnterContextInternal is directly called by the X-AppDomain
            // channel since it only has the target context-id and not the
            // context object itself (since the latter is in another domain)
            // It is also called directly when we are bootstrapping a new
            // AppDomain w.r.t. remoting (in CreateProxyForDomain). In both
            // these cases, the newContext is null.
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool ReturnToContext(ref ContextTransitionFrame frame);

        // This does the real work of switching contexts
        // It will also switch AppDomains/push crossing frames if needed.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool EnterContextInternal(Context ctx, Int32 id, Int32 appDomainID, ref ContextTransitionFrame frame);

        /*======================================================================
        ** Returns the current domain in which current thread is running.
        ** Note!  This isn't guaranteed to work in M9.
        ** Get and set work on the hard thread not the logical thread. For that
        ** reason they are package protected and should not be available for
        ** general consumption.
        **
        ** @TODO: Change when logical threads are per app domain.
        ======================================================================*/

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern AppDomain GetDomainInternal();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern AppDomain GetFastDomainInternal();
        
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern bool IsRunningInDomain(Int32 domainId);

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.GetDomain"]/*' />
        public static AppDomain GetDomain()
        {
            if (CurrentThread.m_Context==null)
            {
                AppDomain ad;
                ad = GetFastDomainInternal();
                if (ad == null)
                    ad = GetDomainInternal();
                return ad;
            }
            else
            {
                BCLDebug.Assert( GetDomainInternal() == CurrentThread.m_Context.AppDomain, "AppDomains on the managed & unmanaged threads should match");
                return CurrentThread.m_Context.AppDomain;
            }
        }


        /*  
         *  This returns a unique id to identify an appdomain.
         */
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.GetDomainID"]/*' />
        public static int GetDomainID()
        {
            return GetDomainIDInternal();
        }

        internal static int GetDomainIDInternal()
        {
            return GetDomain().GetId();
        }
      
    
        // Retrieves the name of the thread.
        //
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.Name"]/*' />
        public  String Name {
            get {
                return m_Name;
                
            }set {
                lock(this) {
                    if (m_Name != null)
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_WriteOnce"));
                    m_Name = value;

                    if (Debugger.IsAttached)
                        InformThreadNameChange(this);
                }            
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InformThreadNameChange(Thread t);

        internal Object ExceptionState {
            get { return m_ExceptionStateInfo;}
            set { m_ExceptionStateInfo = value;}
        }

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            m_Delegate = null;  
            m_PrincipalSlot = null;
            m_Priority = 0;
            DONT_USE_InternalThread = IntPtr.Zero;
        }
#endif
        /*=========================================================================
        ** Volatile Read & Write and MemoryBarrier methods.
        ** Provides the ability to read and write values ensuring that the values
        ** are read/written each time they are accessed. 
        =========================================================================*/

        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern byte VolatileRead(ref byte address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern short VolatileRead(ref short address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int VolatileRead(ref int address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead3"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern long VolatileRead(ref long address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead4"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern sbyte VolatileRead(ref sbyte address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead5"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern ushort VolatileRead(ref ushort address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead6"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern uint VolatileRead(ref uint address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead7"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern IntPtr VolatileRead(ref IntPtr address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead8"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern UIntPtr VolatileRead(ref UIntPtr address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead9"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern ulong VolatileRead(ref ulong address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead10"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern float VolatileRead(ref float address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead11"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern double VolatileRead(ref double address);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileRead12"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Object VolatileRead(ref Object address);
        
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref byte address, byte value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref short address, short value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref int address, int value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite3"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref long address, long value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite4"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref sbyte address, sbyte value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite5"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref ushort address, ushort value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite6"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref uint address, uint value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite7"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref IntPtr address, IntPtr value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite8"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref UIntPtr address, UIntPtr value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite9"]/*' />
        [CLSCompliant(false)]
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref ulong address, ulong value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite10"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref float address, float value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite11"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref double address, double value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.VolatileWrite12"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void VolatileWrite(ref Object address, Object value);
    
        /// <include file='doc\Thread.uex' path='docs/doc[@for="Thread.MemoryBarrier"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void MemoryBarrier();
    }
 
    // declaring a local var of this enum type and passing it by ref into a function that needs to do a 
    // stack crawl will both prevent inlining of the calle and pass an ESP point to stack crawl to
	[Serializable]
    internal enum StackCrawlMark
    {
        LookForMe = 0,
        LookForMyCaller = 1,
                LookForMyCallersCaller = 2
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadstate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadState
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: Enum to represent the different thread states
**
** Date: Feb 2, 2000
**
=============================================================================*/

namespace System.Threading {

    /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState"]/*' />
	[Serializable(),Flags]
    public enum ThreadState
    {   
        /*=========================================================================
        ** Constants for thread states.
        =========================================================================*/
		/// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Running"]/*' />
		Running = 0,
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.StopRequested"]/*' />
        StopRequested = 1,
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.SuspendRequested"]/*' />
        SuspendRequested = 2,
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Background"]/*' />
        Background = 4,
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Unstarted"]/*' />
        Unstarted = 8,
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Stopped"]/*' />
        Stopped = 16,
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.WaitSleepJoin"]/*' />
        WaitSleepJoin = 32,
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Suspended"]/*' />
        Suspended = 64,
		/// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.AbortRequested"]/*' />
		AbortRequested = 128,
		/// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Aborted"]/*' />
		Aborted = 256
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\timer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: TimerQueue
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Class for creating and managing a threadpool
**
** Date: August, 1999
**
=============================================================================*/

namespace System.Threading {
	using System.Threading;
	using System;
    using Microsoft.Win32;
	using System.Runtime.CompilerServices;

    /// <include file='doc\Timer.uex' path='docs/doc[@for="TimerCallback"]/*' />
    public delegate void TimerCallback(Object state);
    

    /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer"]/*' />
    public sealed class Timer : MarshalByRefObject, IDisposable
    {
    	 private static UInt32 MAX_SUPPORTED_TIMEOUT = (uint)0xfffffffe;
    	
    	 private int		timerHandle = 0;
    	 private int		delegateInfo = 0;
    	 private int		timerDeleted;
             	 
    	 /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer"]/*' />
    	 public Timer(TimerCallback	callback, 
    				  Object		state,  
    				  int    		dueTime,
    				  int  		    period)
    	 {
    		if (dueTime < -1)
    			throw new ArgumentOutOfRangeException("dueTime", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
    		if (period < -1 )
    			throw new ArgumentOutOfRangeException("period", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    		AddTimerNative(callback,state,(UInt32)dueTime,(UInt32)period,ref stackMark);
    		timerDeleted = 0;
    	 }
		 /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer1"]/*' />
		 public Timer(TimerCallback	callback, 
    				  Object		state,  
    				  TimeSpan 		dueTime,
    				  TimeSpan	    period)
		 {
				
			long dueTm = (long)dueTime.TotalMilliseconds;
			if (dueTm < -1)
				throw new ArgumentOutOfRangeException("dueTm",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			if (dueTm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("dueTm",Environment.GetResourceString("NotSupported_TimeoutTooLarge"));

			long periodTm = (long)period.TotalMilliseconds;
			if (periodTm < -1)
				throw new ArgumentOutOfRangeException("periodTm",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			if (periodTm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("periodTm",Environment.GetResourceString("NotSupported_TimeoutTooLarge"));

            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    		AddTimerNative(callback,state,(UInt32)dueTm,(UInt32)periodTm,ref stackMark);
    		timerDeleted = 0;
		 }

    	 /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer2"]/*' />
         [CLSCompliant(false)]
    	 public Timer(TimerCallback	callback, 
    				  Object		state,  
    				  UInt32    	dueTime,
    				  UInt32		period)
    	 {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    		AddTimerNative(callback,state,dueTime,period,ref stackMark);
    		timerDeleted = 0;
    	 }
    									
    	 /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer3"]/*' />
    	 public Timer(TimerCallback	callback, 
    				  Object		state,  
    				  long    	    dueTime,
    				  long		    period)
    	 {
    		if (dueTime < -1)
    			throw new ArgumentOutOfRangeException("dueTime",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
    		if (period < -1)
    			throw new ArgumentOutOfRangeException("period",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
    		if (dueTime > MAX_SUPPORTED_TIMEOUT)
    			throw new NotSupportedException(Environment.GetResourceString("NotSupported_TimeoutTooLarge"));
    		if (period > MAX_SUPPORTED_TIMEOUT)
    			throw new NotSupportedException(Environment.GetResourceString("NotSupported_PeriodTooLarge"));
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    		AddTimerNative(callback,state,(UInt32) dueTime, (UInt32) period,ref stackMark);
    		timerDeleted = 0;
    	 }
    
         /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Change"]/*' />
         public bool Change(int dueTime, int period)
    	 {
             lock(this) {
                if (dueTime < -1 )
        			throw new ArgumentOutOfRangeException("dueTime",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
        		if (period < -1)
        			throw new ArgumentOutOfRangeException("period",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
                if (timerDeleted != 0)
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                return ChangeTimerNative((UInt32)dueTime,(UInt32)period);
        	 }
         }

		 /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Change1"]/*' />
		 public bool Change(TimeSpan dueTime, TimeSpan period)
    	 {
            if (timerDeleted != 0)
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
			return Change((long) dueTime.TotalMilliseconds, (long) period.TotalMilliseconds);
         }

         /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Change2"]/*' />
         [CLSCompliant(false)]
         public bool Change(UInt32 dueTime, UInt32 period)
    	 {
             lock(this) {
        		 if (timerDeleted != 0)
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                 return ChangeTimerNative(dueTime,period);
           	 }
         }
         /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Change3"]/*' />
         public bool Change(long dueTime, long period)
    	 {
             lock(this) {
                if (timerDeleted != 0)
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
        		if (dueTime < -1 )
        			throw new ArgumentOutOfRangeException("dueTime", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
        		if (period < -1)
        			throw new ArgumentOutOfRangeException("period", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
        		if (dueTime > MAX_SUPPORTED_TIMEOUT)
        			throw new NotSupportedException(Environment.GetResourceString("NotSupported_TimeoutTooLarge"));
        		if (period > MAX_SUPPORTED_TIMEOUT)
        			throw new NotSupportedException(Environment.GetResourceString("NotSupported_PeriodTooLarge"));
        		return ChangeTimerNative((UInt32)dueTime,(UInt32)period);
        	 }
         }
    
         /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Dispose"]/*' />
         public bool Dispose(WaitHandle notifyObject)
    	 {
             if (notifyObject==null)
                 throw new ArgumentNullException("notifyObject");
             bool status;
             lock(this) {
        		status = DeleteTimerNative(notifyObject.Handle);
        	 }
			GC.SuppressFinalize(this);
			return status;
         }
         

         /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Dispose1"]/*' />
         public void Dispose()
    	 {
            lock(this) {
				DeleteTimerNative(Win32Native.NULL);
			}
			GC.SuppressFinalize(this);
    	 }
    
         /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Finalize"]/*' />
        ~Timer()
        {
            lock(this) 
            {
				DeleteTimerNative(Win32Native.NULL);
			}
        }
    
    	 [MethodImplAttribute(MethodImplOptions.InternalCall)]
    	 private extern void AddTimerNative(TimerCallback	callback,
    									    Object			state, 
    									    UInt32    	dueTime,
    									    UInt32  		period,
                                            ref StackCrawlMark  stackMark
    									   );
    	 
    	 [MethodImplAttribute(MethodImplOptions.InternalCall)]
    	 private  extern bool ChangeTimerNative(UInt32 dueTime,UInt32 period);
    
    	 [MethodImplAttribute(MethodImplOptions.InternalCall)]
    	 private  extern bool DeleteTimerNative(IntPtr notifyObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadstateexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadStateException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: An exception class to indicate that the Thread class is in an
**          invalid state for the method.
**
** Date: April 1, 1998
**
=============================================================================*/

namespace System.Threading {
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\ThreadStateException.uex' path='docs/doc[@for="ThreadStateException"]/*' />
    [Serializable()] public class ThreadStateException : SystemException {
    	/// <include file='doc\ThreadStateException.uex' path='docs/doc[@for="ThreadStateException.ThreadStateException"]/*' />
    	public ThreadStateException() 
	        : base(Environment.GetResourceString("Arg_ThreadStateException")) {
    		SetErrorCode(__HResults.COR_E_THREADSTATE);
        }
    
        /// <include file='doc\ThreadStateException.uex' path='docs/doc[@for="ThreadStateException.ThreadStateException1"]/*' />
        public ThreadStateException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_THREADSTATE);
        }
    	
        /// <include file='doc\ThreadStateException.uex' path='docs/doc[@for="ThreadStateException.ThreadStateException2"]/*' />
        public ThreadStateException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_THREADSTATE);
        }
        
        /// <include file='doc\ThreadStateException.uex' path='docs/doc[@for="ThreadStateException.ThreadStateException3"]/*' />
        protected ThreadStateException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\timeout.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.Threading {
	using System.Threading;
	using System;
    // A constant used by methods that take a timeout (Object.Wait, Thread.Sleep
    // etc) to indicate that no timeout should occur.
    //
    // @todo: this should become an enum.
    //This class has only static members and does not require serialization.
    /// <include file='doc\Timeout.uex' path='docs/doc[@for="Timeout"]/*' />
    public sealed class Timeout
    {
        private Timeout()
        {
        }
    
        /// <include file='doc\Timeout.uex' path='docs/doc[@for="Timeout.Infinite"]/*' />
        public const int Infinite = -1;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\threadstopexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ThreadStopException
**
** Author: Chris Brumme (cbrumme)
**
** Purpose: An exception class which is thrown into a thread to cause it to
**          stop.  This exception is typically not caught and the thread
**          dies as a result.  This is thrown by the VM and should NOT be
**          thrown by any user thread, and subclassing this is useless.
**
** Date: June 1, 1998
**
=============================================================================*/

namespace System.Threading {
	using System.Threading;
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\ThreadStopException.uex' path='docs/doc[@for="ThreadStopException"]/*' />
    /// <internalonly/>
    [Serializable()] internal sealed class ThreadStopException : SystemException {
    	private ThreadStopException() 
	        : base(Environment.GetResourceString("Arg_ThreadStopException")) {
    		SetErrorCode(__HResults.COR_E_THREADSTOP);
        }
    
        private ThreadStopException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_THREADSTOP);
        }
    
        private ThreadStopException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_THREADSTOP);
        }

        internal ThreadStopException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\__handleprotector.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  __HandleProtector
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Base class to help prevent race conditions with
** OS handles.  Used to fix handle recycling bugs.
**
** Date:   December 6, 2001
**
===========================================================*/
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

/*
  What is a handle protector?
  It's a solution we've come up with for working around a class of
  handle recycling bugs.  Here's the problem.  Assume you have two
  threads, both sharing a managed class wrapping an OS handle (such
  as FileStream).  The first thread calls a method like Read
  threads.  The first thread reads the handle field, stores it on
  the stack or in a register to call a syscall (ie, ReadFile), then as 
  it is calling Read a context switch happens.  The second thread now 
  closes this object, calling CloseHandle so the handle no longer refers 
  to a valid object.  The second thread (or potentially a separate third 
  thread) now creates another instance of our wrapper class (ie FileStream) 
  with another handle.  The OS basically uses a stack to allocate new 
  handles, so if you free one handle the next handle you get could be the 
  same handle number you just freed.  Now our first thread will call 
  read/write/whatever on a handle referring to the wrong resource.  This
  can be used to circumvent a security check.

  I've written a repro demonstrating this exploit in FileStream.
  Hence the need for this class.

  What's special about this class?
  1) It's written to be threadsafe without using C#'s lock keyword.
  2) If you use this class, make sure you get the code that calls
     TryAddRef exactly correct, as described in a comment above TryAddRef.
     If you do not, your code will not be reliable.  You will leak handles 
     and will not meet SQL's reliability requirements.

  Thanks to Patrick Dussud and George Bosworth for help designing this class.
                                   -- Brian Grunkemeyer, 12/7/2001
 */

namespace System.Threading {
internal abstract class __HandleProtector
{
    private int _inUse;  // ref count
    // TODO: Make _closed volatile, when and if C# allows passing volatile fields by ref.
    private int _closed; // bool. No Interlocked::CompareExchange(bool)
    // TODO PORTING: Sorry.  Need CompareExchange on a long at the bare minimum
    // Ideally we'll get interlocked operations for IntPtr.
    private int _handle;   // The real OS handle
#if _DEBUG
    private IntPtr _debugRealHandle;  // Keep the original handle around for debugging.
#endif

    private const int InvalidHandle = -1;

    protected internal __HandleProtector(IntPtr handle)
    {
        if (handle == (IntPtr) InvalidHandle)
            throw new ArgumentException("__HandleProtector doesn't expect an invalid handle!");
        _inUse = 1;
        _closed = 0;
        _handle = handle.ToInt32();
#if _DEBUG
        _debugRealHandle = handle;
#endif        
    }

    internal IntPtr Handle {
        get { return (IntPtr) _handle; }
    }

    internal bool IsClosed {
        get { return _closed != 0; }
    }

    // Returns true if we succeeded, else false.  We're trying to write this code
    // so it won't require any changes for SQL reliability requirements in the next
    // version.  Use this coding style.
    //    bool incremented = false;
    //    try {
    //        if (_hp.TryAddRef(ref incremented)) {
    //            ... // Use handle
    //        }
    //        else
    //            throw new ObjectDisposedException("Your handle was closed.");
    //    }
    //    finally {
    //        if (incremented) _hp.Release();
    //    }
    internal bool TryAddRef(ref bool incremented)
    {
        if (_closed == 0) {
            Interlocked.Increment(ref _inUse);
            incremented = true;
            if (_closed == 0)
                return true;
            Release();
            incremented = false;
        }
        return false;
    }

    internal void Release()
    {
        // TODO: Ensure this method will run correctly with ThreadAbortExceptions for SQL
        if (Interlocked.Decrement(ref _inUse) == 0) {
            int h = _handle;
            if (h != InvalidHandle) {
                if (h == Interlocked.CompareExchange(ref _handle, InvalidHandle, h)) {
                    FreeHandle(new IntPtr(h));
                }
            }
        }
    }

    protected internal abstract void FreeHandle(IntPtr handle);

    internal void Close()
    {
        int c = _closed;
        if (c != 1) {
            if (c == Interlocked.CompareExchange(ref _closed, 1, c)) {
                Release();
            }
        }
    }

    // This should only be called for cases when you know for a fact that
    // your handle is invalid and you want to record that information.
    // An example is calling a syscall and getting back ERROR_INVALID_HANDLE.
    // This method will normally leak handles!
    internal void ForciblyMarkAsClosed()
    {
        _closed = 1;
        _handle = InvalidHandle;
    }

#if _DEBUG
    // This exists solely to eliminate a compiler warning about an unused field.
    private void DontTouchThis()
    {
        _debugRealHandle = IntPtr.Zero;
    }
#endif
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threading\waithandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: WaitHandle	(this name is NOT definitive)
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Class to represent all synchronization objects in the runtime (that allow multiple wait)
**
** Date: August, 1999
**
=============================================================================*/

namespace System.Threading {
	using System.Threading;
	using System.Runtime.Remoting;
	using System;
	using System.Security.Permissions;
	using System.Runtime.CompilerServices;
	using Win32Native = Microsoft.Win32.Win32Native;
    /// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle"]/*' />
    public abstract class WaitHandle : MarshalByRefObject, IDisposable
    {
        /// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitTimeout"]/*' />
        public const int WaitTimeout = 0x102;

    	private static int MAX_WAITHANDLES = 64;

        
    	private IntPtr waitHandle;  // !!! DO NOT MOVE THIS FIELD. (See defn of WAITHANDLEREF in object.h - has hardcoded access to this field.)

        internal __WaitHandleHandleProtector waitHandleProtector;

    	/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.InvalidHandle"]/*' />
    	protected static readonly IntPtr InvalidHandle = Win32Native.INVALID_HANDLE_VALUE;
    	private const int WAIT_OBJECT_0 = 0;
		private const int WAIT_ABANDONED = 0x80;
    
    	/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitHandle"]/*' />
    	public WaitHandle() 
    	{ waitHandleProtector = null;
          waitHandle = InvalidHandle; }
    
	    /// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.Handle"]/*' />
    
	    public virtual IntPtr Handle 
		{
		     get { return waitHandleProtector == null ? InvalidHandle : waitHandleProtector.Handle;}
    	
			 [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
			 [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
			 set { waitHandleProtector = (value == InvalidHandle) ? null : new __WaitHandleHandleProtector(value);
                   waitHandle = value; }
	    }



        // Assembly-private version that doesn't do a security check.  Reduces the
        // number of link-time security checks when reading & writing to a file,
        // and helps avoid a link time check while initializing security (If you
        // call a Serialization method that requires security before security
        // has started up, the link time check will start up security, run 
        // serialization code for some security attribute stuff, call into 
        // FileStream, which will then call Sethandle, which requires a link time
        // security check.).  While security has fixed that problem, we still
        // don't need to do a linktime check here.
		internal void SetHandleInternal(IntPtr handle) 
    	{ waitHandleProtector = new __WaitHandleHandleProtector(handle);
          waitHandle = handle; }
    
    	/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitOne"]/*' />
    	public virtual bool WaitOne (int millisecondsTimeout, bool exitContext)
    	{
            if (waitHandleProtector == null)
            {
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }

            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                {
    	  	        bool ret = WaitOneNative(waitHandleProtector.Handle,(uint) millisecondsTimeout,exitContext);
            GC.KeepAlive (this);
            return ret;
    	}
                else
                {
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }
    	}

		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitOne1"]/*' />
		public virtual bool WaitOne (TimeSpan timeout, bool exitContext)
    	{
            if (waitHandleProtector == null)
            {
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }

			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));

            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                {
            	 	bool ret = WaitOneNative(waitHandleProtector.Handle,(uint)tm, exitContext);
            GC.KeepAlive (this);
            return ret;
    	}
                else
                {
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }
    	}

    	/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitOne2"]/*' />
    	public virtual bool WaitOne ()
    	{
            if (waitHandleProtector == null)
            {
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }

            bool incremented = false;
            try {
                if (waitHandleProtector.TryAddRef(ref incremented)) 
                {
            		bool ret = WaitOneNative(waitHandleProtector.Handle,UInt32.MaxValue,false);
            GC.KeepAlive (this);
            return ret;
    	}
                else
                {
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
            }
            finally {
                if (incremented) waitHandleProtector.Release();
            }
    	}
    
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern bool WaitOneNative (IntPtr waitHandle, uint millisecondsTimeout, bool exitContext);
    
        /*========================================================================
		** Waits for signal from all the objects. 
		** timeout indicates how long to wait before the method returns.
		** This method will return either when all the object have been pulsed
		** or timeout milliseonds have elapsed.
		** If exitContext is true then the synchronization domain for the context 
		** (if in a synchronized context) is exited before the wait and reacquired 
		** ISSUE: How to determine the order of the synchronization domain lock? 
		========================================================================*/
    	
        [MethodImplAttribute(MethodImplOptions.InternalCall)] 
	    private static extern int WaitMultiple(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll);


		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitAll"]/*' />
		public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext)
		{
    		if (waitHandles==null)
                throw new ArgumentNullException("waitHandles");
			if (waitHandles.Length > MAX_WAITHANDLES)
    			throw new NotSupportedException(Environment.GetResourceString("NotSupported_MaxWaitHandles"));
            if (millisecondsTimeout < -1)
				throw new ArgumentOutOfRangeException("millisecondsTimeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));

			bool ret = (WaitMultiple(waitHandles, millisecondsTimeout, exitContext, true /* waitall*/ ) != WaitTimeout) ;
            for (int i = 0; i < waitHandles.Length; i ++)
                GC.KeepAlive (waitHandles[i]);
            return ret;
		}
		
		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitAll1"]/*' />
		public static bool WaitAll(
    								WaitHandle[] waitHandles, 
    								TimeSpan timeout,
									bool exitContext)
        {
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
    		return WaitAll(waitHandles,(int)tm, exitContext);
    	}

    
        /*========================================================================
		** Shorthand for WaitAll with timeout = Timeout.Infinite and exitContext = true
		========================================================================*/
		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitAll2"]/*' />
		public static bool WaitAll(WaitHandle[] waitHandles)
		{
		    return WaitAll(waitHandles, Timeout.Infinite, true); 
		}

        /*========================================================================
		** Waits for notification from any of the objects. 
		** timeout indicates how long to wait before the method returns.
		** This method will return either when either one of the object have been 
		** signalled or timeout milliseonds have elapsed.
		** If exitContext is true then the synchronization domain for the context 
		** (if in a synchronized context) is exited before the wait and reacquired 
		========================================================================*/
		
	    /// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitAny"]/*' />
	    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext)
		{
    		if (waitHandles==null)
                throw new ArgumentNullException("waitHandles");
    		if (waitHandles.Length > MAX_WAITHANDLES)
    			throw new NotSupportedException(Environment.GetResourceString("NotSupported_MaxWaitHandles"));
            if (millisecondsTimeout < -1)
				throw new ArgumentOutOfRangeException("millisecondsTimeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
			int ret = WaitMultiple(waitHandles, millisecondsTimeout, exitContext, false /* waitany*/ );
            for (int i = 0; i < waitHandles.Length; i ++)
                GC.KeepAlive (waitHandles[i]);
			if ((ret > WAIT_ABANDONED) && (ret < WAIT_ABANDONED+waitHandles.Length))
			{
				return (ret - WAIT_ABANDONED);
			}
			else 
				return ret;

		}

		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitAny1"]/*' />
		public static int WaitAny(
    								WaitHandle[] waitHandles, 
    								TimeSpan timeout,
									bool exitContext)
        {
			long tm = (long)timeout.TotalMilliseconds;
			if (tm < -1 || tm > (long) Int32.MaxValue)
				throw new ArgumentOutOfRangeException("timeout", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1"));
    		return WaitAny(waitHandles,(int)tm, exitContext);
    	}


        /*========================================================================
		** Shorthand for WaitAny with timeout = Timeout.Infinite and exitContext = true
		========================================================================*/
		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.WaitAny2"]/*' />
		public static int WaitAny(WaitHandle[] waitHandles)
		{
		    return WaitAny(waitHandles, Timeout.Infinite, true);
		}
      

		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.Close"]/*' />
		public virtual void Close()
        {
            Dispose(true);
            GC.nativeSuppressFinalize(this);
        }
            
		/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.Dispose"]/*' />
        protected virtual void Dispose(bool explicitDisposing)
        {
            if (waitHandleProtector != null) {
                waitHandleProtector.Close();
            }
        }

        /// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose()
        {
            Dispose(true);
            GC.nativeSuppressFinalize(this);
        }

    	/// <include file='doc\WaitHandle.uex' path='docs/doc[@for="WaitHandle.Finalize"]/*' />
        ~WaitHandle()
    	{
                 Dispose(false);
    	}



        internal sealed class __WaitHandleHandleProtector : __HandleProtector
        {
            internal __WaitHandleHandleProtector(IntPtr handle) : base(handle)
            {
            }

            protected internal override void FreeHandle(IntPtr handle)
            {
                // TODO: After RTM consider checking CloseHandle's return value.
                Win32Native.CloseHandle(handle);
            }
        }

    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\binverify\makefile.inc ===
!IF "$(LINKONLY)" == "1"

RunTheScript:
!if "$(TARGETCOMPLUS)" != ""
	checkbin.pl
!endif

!ELSE

RunTheScript:

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\binverify\updateres.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//***************************************************************
//
// This file is for compiling to UpdateRes.exe
// To rebuild UpdateRes.exe use
//      cl UpdateRes.cpp imagehlp.lib
// after setting INCLUDE=c:\env.i386\crt\inc\i386 and placing the right set of
// LIB files.
//
// UpdateRes.exe is used in UpdateRes directory to update the runtime dll
// with the checked in bin file. If the non-checked-in bin file build on
// your machine is smaller than the checked-in bin file, this program
// returns an error and doesn't attempt to update the runtime dll. 
//
//
//***************************************************************
#include <windows.h>
#include <stdio.h>
#include <imagehlp.h>

// Finding the embedded resource given a PE file loaded to pbBase
void FindBinResource(PIMAGE_NT_HEADERS      pNtHeaders,
                PBYTE                       pbBase,
                PBYTE                       pbResBase,
                PIMAGE_RESOURCE_DIRECTORY   pResDir,
                PBYTE                       *pbStart,       // [OUT] where the bin resource start
                DWORD                       *pdwSize)       // [OUT] size of the bin resource
{
    PIMAGE_RESOURCE_DIRECTORY       pSubResDir;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pSubResEntry;    
    PIMAGE_RESOURCE_DIR_STRING_U    pNameEntry;
    PIMAGE_RESOURCE_DATA_ENTRY      pDataEntry;
    DWORD                           i;

    *pbStart = NULL;
    *pdwSize = 0;

    // Resource entries immediately follow the parent directory entry, (string)
    // named entries first followed by the ID named entries.
    pResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResDir + 1);

    // The resource section that we want to find is
    // Name CLRBINFILE
    //      Name BINFILE
    //          ID 0409
    //              
    for (i = 0; i < (DWORD)(pResDir->NumberOfNamedEntries + pResDir->NumberOfIdEntries); i++, pResEntry++) 
    {        
        if (!pResEntry->NameIsString || !pResEntry->DataIsDirectory) 
            continue;

        // Named entry. The name is identified by an
        // IMAGE_RESOURCE_DIR_STRING (ANSI) or IMAGE_RESOURCE_DIR_STRING_U
        // (Unicode) structure. I've only seen the latter so far (and that's
        // all this code copes with), so I'm not sure how you're expected to
        // know which one is being used (aside from looking at the second
        // bye of the name and guessing by whether it's zero or not, which
        // seems dangerous).
        pNameEntry = (PIMAGE_RESOURCE_DIR_STRING_U)(pbResBase + pResEntry->NameOffset);
        WCHAR szName[1024];
        memcpy(szName, pNameEntry->NameString, pNameEntry->Length * sizeof(WCHAR));
        szName[pNameEntry->Length] = '\0';
        if (wcscmp(szName, L"CLRBINFILE") !=0)
        {
            // Nop! This is not the one
            continue;                
        }

        // This entry is actually a sub-directory, the payload is the offset
        // of another IMAGE_RESOURCE_DIRECTORY structure). Descend into it
        // recursively.
        pSubResDir = (PIMAGE_RESOURCE_DIRECTORY)(pbResBase + pResEntry->OffsetToDirectory);
        pSubResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pSubResDir + 1);
        if (pSubResDir->NumberOfNamedEntries != 1 || pSubResDir->NumberOfIdEntries != 0)
            continue;

        if (!pSubResEntry->NameIsString || !pResEntry->DataIsDirectory) 
            continue;

        pNameEntry = (PIMAGE_RESOURCE_DIR_STRING_U)(pbResBase + pSubResEntry->NameOffset);
        memcpy(szName, pNameEntry->NameString, pNameEntry->Length * sizeof(WCHAR));
        szName[pNameEntry->Length] = '\0';
        if (wcscmp(szName, L"BINFILE") !=0)
        {
            // Nop! This is not the one
            continue;                
        }

        // now go to the data
        pSubResDir = (PIMAGE_RESOURCE_DIRECTORY)(pbResBase + pSubResEntry->OffsetToDirectory);
        pSubResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pSubResDir + 1);

        if (pSubResEntry->DataIsDirectory)
            continue;


        // Else we must have a leaf node (actual resource data). I'm afraid
        // I don't know the format of these blobs :o(
        // Note that, unlike the other addresses we've seen so far, the data
        // payload is described by an RVA instead of a root resource
        // directory offset.
        pDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)(pbResBase + pSubResEntry->OffsetToData);


        // This is where the Bin file data start
        *pbStart = (PBYTE)ImageRvaToVa(pNtHeaders, pbBase, pDataEntry->OffsetToData, NULL);
        *pdwSize = pDataEntry->Size;   
		return;
    }
}

void GetBinResource(PBYTE pbFile,PBYTE *ppbResource,DWORD *pcbResource)
{
    PIMAGE_NT_HEADERS           pNtHeaders;
    PIMAGE_DATA_DIRECTORY       pResDataDir;
    PIMAGE_RESOURCE_DIRECTORY   pResDir;

    // Locate the standard NT file headers (this checks we actually have a PE
    // file in the process).
    pNtHeaders = ImageNtHeader(pbFile);
    if (pNtHeaders == NULL) {
        printf("The dll is not a PE file\n");
        return;
    }

    // Locate the resource directory. Note that, due to differences in the
    // header structure, we must conditionalize this code on the PE image type
    // (32 or 64 bit).
    if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
        pResDataDir = &((IMAGE_NT_HEADERS32*)pNtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];
    else
        pResDataDir = &((IMAGE_NT_HEADERS64*)pNtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];

    pResDir = (PIMAGE_RESOURCE_DIRECTORY)ImageRvaToVa(pNtHeaders, pbFile, pResDataDir->VirtualAddress, NULL);

    FindBinResource(pNtHeaders,
                pbFile,
                (PBYTE)pResDir,
                pResDir,
                ppbResource,
                pcbResource);

}


int main(int argc, char **argv)
{    
    HANDLE  hFile=INVALID_HANDLE_VALUE;
    PBYTE   pbFile=NULL;
    DWORD   cbFile=0;
    HANDLE  hMap=NULL;

    HANDLE  hFile1 = INVALID_HANDLE_VALUE;
    PBYTE   pbFile1 = NULL;
    DWORD   cbFile1=0;
    DWORD   dwBytes1=0;
    int         status = 1;

    PBYTE   pbResource = NULL;
    DWORD   cbResource = 0;

    if (argc != 3) {
        printf("usage: updateres <mscorwks.dll/mscorsvr.dll> <bin file to compare>\n");
        return 1;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Open the mscorwks/svr dll
    hFile = CreateFile(argv[1],
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("CreateFile() failed with %u\n", GetLastError());
        goto ErrExit;
    }

    // Determine its size.
    cbFile = GetFileSize(hFile, NULL);

    // Create a mapping handle for the file.
    hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
    if (hMap == NULL) {
        printf("CreateFileMapping() failed with %u\n", GetLastError());
        goto ErrExit;
    }

    // And map it into memory.
    pbFile = (BYTE*)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
    if (pbFile == NULL) {
        printf("MapViewOfFile() failed with %u\n", GetLastError());
        goto ErrExit;
    }

    GetBinResource(pbFile,&pbResource,&cbResource);    
    if(pbResource==NULL)
    {
        printf("Unable to find BIN file resource\n");
        goto ErrExit;
    }

    printf("found BIN file resource in %s\n",argv[1]);
    printf("resource size = %ld\n",cbResource);

    ///////////////////////////////////////////////////////////////////////////
    // read in the bin file
    hFile1 = CreateFile(argv[2],
                       GENERIC_READ,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if (hFile1 == INVALID_HANDLE_VALUE) {
        printf("CreateFile() on %s failed with %u\n", argv[2], GetLastError());
        goto ErrExit;
    }

    cbFile1 = GetFileSize(hFile1, NULL);    
    pbFile1 = new BYTE[cbFile1];
    if (pbFile1 == NULL)
    {
        printf("Unable to allocate memory\n");
        goto ErrExit;
    }
    
    if(ReadFile(hFile1, pbFile1, cbFile1, &dwBytes1, NULL)==0)
    {
        printf("ReadFile on %s failed with error %u\n",argv[2],GetLastError());
        goto ErrExit;
    }
    
    if(cbFile1!=dwBytes1)
    {
        printf("ReadFile returned %u bytes, expected %u. Failing.\n",dwBytes1,cbFile1);
        goto ErrExit;
    }

    printf("Opened file %s\n",argv[2]);
    printf("file size = %ld\n",cbFile1);
    
    if(cbResource < cbFile1)
    {
        printf("You must rebuild the bin files and check them into the tree.\n",argv[2]);
        goto ErrExit;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Update the resource in the mscorwks/svr dll
    //
    CopyMemory(pbResource,pbFile1,cbFile1);
    
    if(FlushViewOfFile(pbFile, 0)==0)
    {
        printf("FlushViewOfFile returned error %u\n",GetLastError());
        goto ErrExit;
    }
    
    if(UnmapViewOfFile(pbFile)==0)
    {
        printf("UnmapViewOfFile(%s) failed with error %u\n",argv[1],GetLastError());
        goto ErrExit;
    }

    printf("Successfully updated %s\n",argv[1]);
    status = 0;

ErrExit:
    if (pbFile1)
        delete pbFile1;    
    if (hFile1 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile1);
    if(hMap!=NULL)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\cfout.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*cfout.c - Encode interface for C
*
*Purpose:
*
*Revision History:
*	07-20-91  GDP	Ported to C from assembly
*	04-30-92  GDP	Added _dtold routine (moved here from ldtod.c)
*	05-14-92  GDP	NDIGITS is now 17 (instead of 16)
*	06-18-92  GDP	Use double instead of DOUBLE to remove C8 warning
*	04-06-93  SKS	Replace _CALLTYPE* with __cdecl
*	09-06-94  CFW	Replace MTHREAD with _MT.
*
*******************************************************************************/

//Put the includes in this order s.t. we get the full definition of WCHAR.
#include <COMcv.h>
#include <string.h>

#define NDIGITS 17

void __dtold(_LDOUBLE *pld, double *px);


#ifndef _MT
static struct _strflt ret;
static FOS fos;
#endif

#ifdef _MT
STRFLT __cdecl _Wfltout2(double x, STRFLT flt, WCHAR *resultstr)
{
    _LDOUBLE ld;
    FOS autofos;

    __dtold(&ld, &x);
    flt->flag =  $WI10_OUTPUT(ld,NDIGITS,0,&autofos);
    flt->sign = autofos.sign;
    flt->decpt = autofos.exp;
    wcscpy(resultstr,autofos.man);
    flt->mantissa = resultstr;

    return flt;
}

#else

STRFLT __cdecl _Wfltout(double x)
{
    _LDOUBLE ld;

    __dtold(&ld, &x);
    ret.flag = $WI10_OUTPUT(ld,NDIGITS,0,&fos);
    ret.sign = fos.sign;
    ret.decpt = fos.exp;
    ret.mantissa = fos.man;

    return &ret;
}

#endif




/***
* __dtold -	convert a double into a _LDOUBLE
*
*Purpose:  Use together with i10_output() to get string conversion
*   for double
*
*Entry: double *px
*
*Exit: the corresponding _LDOUBLE value is returned in *pld
*
*Exceptions:
*
*******************************************************************************/

void __dtold(_LDOUBLE *pld, double *px)
{
    u_short exp;
    u_short sign;
    u_long manhi, manlo;
    u_long msb = MSB_ULONG;
    u_short ldexp = 0;

    exp = (*U_SHORT4_D(px) & (u_short)0x7ff0) >> 4;
    sign = *U_SHORT4_D(px) & (u_short)0x8000;
    manhi = *UL_HI_D(px) & 0xfffff;
    manlo = *UL_LO_D(px);

    switch (exp) {
    case D_MAXEXP:
	ldexp = LD_MAXEXP;
	break;
    case 0:
	/* check for zero */
	if (manhi == 0 && manlo == 0) {
	    *UL_MANHI_LD(pld) = 0;
	    *UL_MANLO_LD(pld) = 0;
	    *U_EXP_LD(pld) = 0;
	    return;
	}
	/* we have a denormal -- we'll normalize later */
	ldexp = (u_short) ((s_short)exp - D_BIAS + LD_BIAS + 1);
	msb = 0;
	break;
    default:
	exp -= D_BIAS;
	ldexp = (u_short) ((s_short)exp + LD_BIAS);
	break;
    }

    *UL_MANHI_LD(pld) = msb | manhi << 11 | manlo >> 21;
    *UL_MANLO_LD(pld) = manlo << 11;

    /* normalize if necessary */
    while ((*UL_MANHI_LD(pld) & MSB_ULONG) == 0) {
	/* shift left */
	*UL_MANHI_LD(pld) = *UL_MANHI_LD(pld) << 1 |
			    (MSB_ULONG & *UL_MANLO_LD(pld) ? 1: 0);
	(*UL_MANLO_LD(pld)) <<= 1;
	ldexp --;
    }

    *U_EXP_LD(pld) = sign | ldexp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\comcv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*cv.h - definitions for floating point conversion
*
*Purpose:
*   define types, macros, and constants used in floating point
*   conversion routines
*
*Revision History:
*	07-17-91  GDP	initial version
*	09-21-91  GDP	restructured 'ifdef' directives
*	10-29-91  GDP	MIPS port: new defs for ALIGN and DOUBLE
*	03-03-92  GDP	removed os2 16-bit stuff
*	04-30-92  GDP	support intrncvt.c --cleanup and reorganize
*	05-13-92  XY	fixed B_END macros
*	06-16-92  GDP	merged changes from \\orville and \\vangogh trees
*	09-05-92  GDP	included fltintrn.h, new calling convention macros
*	04-06-93  SKS	Replace _CALLTYPE* with __cdecl
*	07-16-93  SRW	ALPHA Merge
*	11-17-93  GJF	Merged in NT version. Replaced _ALPHA_ with _M_ALPHA,
*			MIPS with _M_MRX000, MTHREAD with _MT, and deleted
*			M68K stuff.
*	10-02-94  BWT	PPC merge
*	02-06-95  JWM	Mac merge
*
*******************************************************************************/
#ifndef _INC_CV

#include "COMFloat.h"

#ifdef __cplusplus
extern "C" {
#endif

#include "COMFLTINTRN.h"

/* define little endian or big endian memory */

#ifdef	_M_IX86
#define L_END
#endif

#if	defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
#define L_END
#endif

typedef unsigned char	u_char;   /* should have 1 byte	*/
typedef char		s_char;   /* should have 1 byte	*/
typedef unsigned short	u_short;  /* should have 2 bytes */
typedef signed short	s_short;  /* should have 2 bytes */
typedef unsigned int	u_long;	  /* sholuld have 4 bytes */
typedef int		s_long;	  /* sholuld have 4 bytes */

/* calling conventions */
#define _CALLTYPE5


/*
 * defining _LDSUPPORT enables using long double computations
 * for string conversion. We do not do this even for i386,
 * since we want to avoid using floating point code that
 * may generate IEEE exceptions.
 *
 * Currently our string conversion routines do not conform
 * to the special requirements of the IEEE standard for
 * floating point conversions
 */


#ifndef _LDSUPPORT

#pragma pack(4)
typedef struct {
    u_char ld[10];
} _LDOUBLE;
#pragma pack()

#define PTR_LD(x) ((u_char  *)(&(x)->ld))

#else

typedef long double _LDOUBLE;

#define PTR_LD(x) ((u_char  *)(x))

#endif


#pragma pack(4)
typedef struct {
    u_char ld12[12];
} _LDBL12;
#pragma pack()

typedef struct {
    float f;
} COMFLOAT;  //A really stupid name to get around the fact that FLOAT is also defined in windef.h



/*
 * return values for internal conversion routines
 * (12-byte to long double, double, or float)
 */

typedef enum {
    INTRNCVT_OK,
    INTRNCVT_OVERFLOW,
    INTRNCVT_UNDERFLOW
} INTRNCVT_STATUS;


/*
 * return values for strgtold12 routine
 */

#define SLD_UNDERFLOW 1
#define SLD_OVERFLOW 2
#define SLD_NODIGITS 4

#define MAX_MAN_DIGITS 21


/* specifies '%f' format */

#define SO_FFORMAT 1

typedef  struct _FloatOutStruct {
		    short   exp;
		    char    sign;
		    char    ManLen;
		    WCHAR    man[MAX_MAN_DIGITS+1];
		    } FOS;



#define PTR_12(x) ((u_char  *)(&(x)->ld12))

#define MAX_USHORT  ((u_short)0xffff)
#define MSB_USHORT  ((u_short)0x8000)
#define MAX_ULONG   ((u_long)0xffffffff)
#define MSB_ULONG   ((u_long)0x80000000)

#define TMAX10 5200	  /* maximum temporary decimal exponent */
#define TMIN10 -5200	  /* minimum temporary decimal exponent */
#define LD_MAX_EXP_LEN 4  /* maximum number of decimal exponent digits */
#define LD_MAX_MAN_LEN 24  /* maximum length of mantissa (decimal)*/
#define LD_MAX_MAN_LEN1 25 /* MAX_MAN_LEN+1 */

#define LD_BIAS	0x3fff	  /* exponent bias for long double */
#define LD_BIASM1 0x3ffe  /* LD_BIAS - 1 */
#define LD_MAXEXP 0x7fff  /* maximum biased exponent */

#define D_BIAS	0x3ff	 /* exponent bias for double */
#define D_BIASM1 0x3fe	/* D_BIAS - 1 */
#define D_MAXEXP 0x7ff	/* maximum biased exponent */


/*
 * end of definitions from crt32\h\fltintrn.h
 */

#ifdef _M_M68K
#undef _cldcvt
WCHAR *_clftole(long double *, WCHAR *, int, int);
WCHAR *_clftolf(long double *, WCHAR *, int);
WCHAR * _CALLTYPE2 _clftolg(long double *, WCHAR *, int, int);
void _CALLTYPE2 _cldcvt( long double *, WCHAR *, int, int, int);
#endif


#ifndef	MTHREAD
#if defined(_M_M68K) || defined(_M_MPPC)
FLTL _CALLTYPE2 _fltinl( const WCHAR *, int, int, int);
STRFLT _CALLTYPE2 _lfltout(long double);

#define _IS_MAN_IND(signbit, manhi, manlo) \
	((signbit) && (manhi)==0xc0000000 && (manlo)==0)

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
	( (manhi)&NAN_BIT )

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
	(!( _IS_MAN_INF(signbit, manhi, manlo) || \
	   _IS_MAN_QNAN(signbit, manhi, manlo) ))

#endif
#endif

/* Recognizing special patterns in the mantissa field */
#define _EXP_SP  0x7fff
#define NAN_BIT (1<<30)

#define _IS_MAN_INF(signbit, manhi, manlo) \
	( (manhi)==MSB_ULONG && (manlo)==0x0 )


/* i386 and Alpha use same NaN format */
#if	defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)
#define _IS_MAN_IND(signbit, manhi, manlo) \
	((signbit) && (manhi)==0xc0000000 && (manlo)==0)

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
	( (manhi)&NAN_BIT )

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
	(!( _IS_MAN_INF(signbit, manhi, manlo) || \
	   _IS_MAN_QNAN(signbit, manhi, manlo) ))


#elif defined(_M_MRX000) 
#define _IS_MAN_IND(signbit, manhi, manlo) \
	(!(signbit) && (manhi)==0xbfffffff && (manlo)==0xfffff800)

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
	( (manhi)&NAN_BIT )

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
	(!( _IS_MAN_INF(signbit, manhi, manlo) || \
	   _IS_MAN_SNAN(signbit, manhi, manlo) ))
#endif



#if	defined (L_END) && !( defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) )
/* "little endian" memory */
/* Note: MIPS and Alpha have alignment requirements and have different
 * macros */
/*
 * Manipulation of a 12-byte long double number (an ordinary
 * 10-byte long double plus two extra bytes of mantissa).
 */
/*
 * byte layout:
 *
 *		+-----+--------+--------+-------+
 *		|XT(2)|MANLO(4)|MANHI(4)|EXP(2) |
 *              +-----+--------+--------+-------+
 *              |<-UL_LO->|<-UL_MED->|<-UL_HI ->|
 *                  (4)       (4)        (4)
 */

/* a pointer to the exponent/sign portion */
#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

/* a pointer to the 4 hi-order bytes of the mantissa */
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+6))

/* a pointer to the 4 lo-order bytes of the ordinary (8-byte) mantissa */
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+2))

/* a pointer to the 2 extra bytes of the mantissa */
#define U_XT_12(p) ((u_short  *)PTR_12(p))

/* a pointer to the 4 lo-order bytes of the extended (10-byte) mantissa */
#define UL_LO_12(p) ((u_long  *)PTR_12(p))

/* a pointer to the 4 mid-order bytes of the extended (10-byte) mantissa */
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))

/* a pointer to the 4 hi-order bytes of the extended long double */
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* a pointer to the byte of order i (LSB=0, MSB=9)*/
#define UCHAR_12(p,i) ((u_char	*)PTR_12(p)+(i))

/* a pointer to a u_short with offset i */
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to a u_long with offset i */
#define ULONG_12(p,i) ((u_long	*)((u_char  *)PTR_12(p)+(i)))

/* a pointer to the 10 MSBytes of a 12-byte long double */
#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+4))
#define UL_MANLO_LD(p) ((u_long  *)PTR_LD(p))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif

/* big endian */
#if defined (B_END)

/*
 * byte layout:
 *
 *		+------+-------+---------+------+
 *		|EXP(2)|MANHI(4)|MANLO(4)|XT(2) |
 *              +------+-------+---------+------+
 *              |<-UL_HI->|<-UL_MED->|<-UL_LO ->|
 *                  (4)       (4)        (4)
 */


#define U_EXP_12(p) ((u_short  *)PTR_12(p))
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+2))
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+6))
#define U_XT_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_LO_12(p) ((u_long  *)(PTR_12(p)+8))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)PTR_12(p))

#define UCHAR_12(p,i) ((u_char	*)PTR_12(p)+(11-(i)))
#define USHORT_12(p,i)	((u_short  *)((u_char  *)PTR_12(p)+10-(i)))
#define ULONG_12(p,i) ((u_long	*)((u_char  *)PTR_12(p)+8-(i)))
#define TEN_BYTE_PART(p) (u_char  *)PTR_12(p)

#define U_EXP_LD(p) ((u_short  *)PTR_LD(p))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+2))
#define UL_MANLO_LD(p) ((u_long  *)(PTR_LD(p)+6))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p))
#define UL_HI_D(p) ((u_long  *)(p))
#define UL_LO_D(p) ((u_long  *)(p) + 1)

#endif

#if	defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)

#define ALIGN(x)  ( (unsigned long  __unaligned *) (x))

#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_MANHI_12(p) ((u_long  __unaligned *) (PTR_12(p)+6) )
#define UL_MANLO_12(p) ((u_long  __unaligned *) (PTR_12(p)+2) )


#define U_XT_12(p) ((u_short  *)PTR_12(p))
#define UL_LO_12(p) ((u_long  *)PTR_12(p))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* the following 3 macros do not take care of proper alignment */
#define UCHAR_12(p,i) ((u_char	*)PTR_12(p)+(i))
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))
#define ULONG_12(p,i) ((u_long	*) ((u_char  *)PTR_12(p)+(i) ))

#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))

#define UL_MANHI_LD(p) ((u_long  *) (PTR_LD(p)+4) )
#define UL_MANLO_LD(p) ((u_long  *) PTR_LD(p) )

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif


#define PUT_INF_12(p,sign) \
		  *UL_HI_12(p) = (sign)?0xffff8000:0x7fff8000; \
		  *UL_MED_12(p) = 0; \
		  *UL_LO_12(p) = 0;

#define PUT_ZERO_12(p) *UL_HI_12(p) = 0; \
		  *UL_MED_12(p) = 0; \
		  *UL_LO_12(p) = 0;

#define ISZERO_12(p) ((*UL_HI_12(p)&0x7fffffff) == 0 && \
		      *UL_MED_12(p) == 0 && \
		      *UL_LO_12(p) == 0 )

#define PUT_INF_LD(p,sign) \
		  *U_EXP_LD(p) = (sign)?0xffff:0x7fff; \
		  *UL_MANHI_LD(p) = 0x8000; \
		  *UL_MANLO_LD(p) = 0;

#define PUT_ZERO_LD(p) *U_EXP_LD(p) = 0; \
		  *UL_MANHI_LD(p) = 0; \
		  *UL_MANLO_LD(p) = 0;

#define ISZERO_LD(p) ((*U_EXP_LD(p)&0x7fff) == 0 && \
		      *UL_MANHI_LD(p) == 0 && \
		      *UL_MANLO_LD(p) == 0 )


/*********************************************************
 *
 *   Function Prototypes
 *
 *********************************************************/

/* from mantold.c */
void _CALLTYPE5 __Wmtold12(WCHAR	*manptr, unsigned manlen,_LDBL12 *ld12);
int  _CALLTYPE5 __Waddl(u_long x, u_long y, u_long  *sum);
void _CALLTYPE5 __Wshl_12(_LDBL12  *ld12);
void _CALLTYPE5 __Wshr_12(_LDBL12  *ld12);
void _CALLTYPE5 __Wadd_12(_LDBL12  *x, _LDBL12  *y);

/* from tenpow.c */
void _CALLTYPE5 __Wmulttenpow12(_LDBL12	*pld12,int pow, unsigned mult12);
void _CALLTYPE5 __Wld12mul(_LDBL12  *px, _LDBL12  *py);

/* from strgtold.c */
unsigned int __strgtold12(_LDBL12 *pld12,
	    const WCHAR * *p_end_ptr,
	    const WCHAR * str,
	    int mult12,
	    int scale,
	    int decpt,
	    int implicit_E);

unsigned _CALLTYPE5 __STRINGTOLD(_LDOUBLE *pld,
	    const WCHAR	* *p_end_ptr,
	    const WCHAR	*str,
	    int mult12);


/* from x10fout.c */
/* this is defined as void in convert.h
 * After porting the asm files to c, we need a return value for
 * i10_output, that used to reside in reg. ax
 */
int _CALLTYPE5	$WI10_OUTPUT(_LDOUBLE ld, int ndigits,
		    unsigned output_flags, FOS	*fos);


/* for cvt.c and fltused.c */
/* The following functions are #defined as macros in fltintrn.h */
#undef _cfltcvt
#undef _cropzeros
#undef _fassign
#undef _forcdecpt
#undef _positive

void __cdecl _Wcfltcvt(double *arg, WCHAR *buffer,
			 int format, int precision,
			 int caps);
void __cdecl _Wcropzeros(char *buf);
void __cdecl _Wfassign(int flag, WCHAR  *argument, WCHAR *number);
void __cdecl _Wforcdecpt(WCHAR *buf);
int __cdecl _Wpositive(double *arg);

/* from intrncvt.c */
void _Watodbl(COMDOUBLE *d, WCHAR *str);
void _Watoldbl(_LDOUBLE *ld, WCHAR *str);
void _Watoflt(COMFLOAT *f, WCHAR *str);
INTRNCVT_STATUS _Wld12tod(_LDBL12 *ifp, COMDOUBLE *d);
INTRNCVT_STATUS _Wld12tof(_LDBL12 *ifp, COMFLOAT *f);
INTRNCVT_STATUS _Wld12told(_LDBL12 *ifp, _LDOUBLE *ld);


#ifdef _M_MPPC
//round double, store in double
double _Wfrnd(double x);

//convert double to int
int _Wdtoi(double db);

//convert double to unsigned int
unsigned int _Wdtou(double db);

//convert int to double
double _Witod(int i);

//convert unsigned int to double
double _Wutod(unsigned int u);

//convert float to unsigned int
unsigned int _Wftou(float f);

//convert int to float
float _Witof(int i);

//convert unsigned int to float
float _Wutof(unsigned int u);

//convert float to double
double _Wftod(float f);

//convert double to float
float _Wdtof(double db);
#endif

#ifdef __cplusplus
}
#endif

#define _INC_CV
#endif	/* _INC_CV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\comfloat.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <common.h>
#include <CrtWrap.h>
#include <basetsd.h> // CHANGED, VC6.0
#include <excep.h>
#include <COMCV.h>
#include <COMFloat.h>
#include "COMFloatClass.h"
#include "COMString.h"



union floatUnion {
    int i;
    float f;
};

static floatUnion posInfinity = { FLOAT_POSITIVE_INFINITY };
static floatUnion negInfinity = { FLOAT_NEGATIVE_INFINITY };


// This table is required for the Round function which can specify the number of digits to round to
#define MAX_ROUND_DBL 16  // largest power that's exact in a double

double rgdblPower10[MAX_ROUND_DBL + 1] = 
    {
      1E0, 1E1, 1E2, 1E3, 1E4, 1E5, 1E6, 1E7, 1E8,
      1E9, 1E10, 1E11, 1E12, 1E13, 1E14, 1E15
    };

void COMFloat::COMFloatingPointInitialize() {
    //int ret;
    //WCHAR decpt;

    /* Numeric data is country--not language--dependent.  NT work-around. */
    //    LCID ctryid = MAKELCID(__lc_id[LC_NUMERIC].wCountry, SORT_DEFAULT);

    //    ret = GetLocaleInfo(LC_STR_TYPE, ctryid, LOCALE_SDECIMAL, &decpt, 1);
    //    if (ret==0) {
    //        *__decimal_point = decpt;
    //    }
}

/*==============================================================================
**Floats (single precision) in IEEE754 format are represented as follows.
**  ----------------------------------------------------------------------
**  | Sign(1 bit) |  Exponent (8 bits) |   Significand (23 bits)         |
**  ----------------------------------------------------------------------
**
**NAN is indicated by setting the sign bit, all 8 exponent bits, and the high order
**bit of the significand.   This yields the key value of 0xFFC00000.
**
**Positive Infinity is indicated by setting all 8 exponent bits to 1 and all others
**to 0.  This yields a key value of 0x7F800000.
**
**Negative Infinity is the same as positive infinity except with the sign bit set.
==============================================================================*/



/*===============================IsInfinityFloat================================
**Args:    typedef struct {R4 flt;} _singleFloatArgs;
**Returns: True if args->flt is Infinity.  False otherwise.  We don't care at this
**         point if its positive or negative infinity. See above for the 
**         description of value used to determine Infinity.
**Exceptions: None.
==============================================================================*/
FCIMPL1(INT32, COMFloat::IsInfinity, float f)
    //C doesn't like casting a float directly to an Unsigned Int *, so cast it to
    //a void * first, and then to an unsigned int * and then dereference it.
    return  ((*((UINT32 *)((void *)&f)) == FLOAT_POSITIVE_INFINITY)||
            (*((UINT32 *)((void *)&f)) == FLOAT_NEGATIVE_INFINITY));
FCIMPLEND


/*===========================IsNegativeInfinityFloat============================
**Args:    typedef struct {R4 flt;} _singleFloatArgs;
**Returns: True if args->flt is Infinity.  False otherwise. See above for the 
**         description of value used to determine Negative Infinity.
**Exceptions: None
==============================================================================*/
FCIMPL1(INT32, COMFloat::IsNegativeInfinity, float f)
    //C doesn't like casting a float directly to an Unsigned Int *, so cast it to
    //a void * first, and then to an unsigned int * and then dereference it.
    return (*((UINT32 *)((void *)&f)) == FLOAT_NEGATIVE_INFINITY);
FCIMPLEND


/*===========================IsPositiveInfinityFloat============================
**Args:    typedef struct {R4 flt;} _singleFloatArgs;
**Returns: True if args->flt is Infinity.  False otherwise. See above for the 
**         description of value used to determine Positive Infinity.
**Exceptions: None
==============================================================================*/
FCIMPL1(INT32, COMFloat::IsPositiveInfinity, float f)
    //C doesn't like casting a float directly to an Unsigned Int *, so cast it to
    //a void * first, and then to an unsigned int * and then dereference it.
    return  (*((UINT32 *)((void *)&f)) == FLOAT_POSITIVE_INFINITY);
FCIMPLEND

//
//
// DOUBLE PRECISION OPERATIONS
//
//


/*===============================IsInfinityDouble===============================
**Args:    typedef struct {R8 dbl;} _singleDoubleArgs;
**Returns: True if args->flt is Infinity.  False otherwise.  We don't care at this
**         point if its positive or negative infinity. See above for the 
**         description of value used to determine Infinity.
**Exceptions: None.
==============================================================================*/
FCIMPL1(INT32, COMDouble::IsInfinity, double d)
    return  fabs(d) == posInfinity.f;
FCIMPLEND

/*===========================IsNegativeInfinityFloat============================
**Args:    typedef struct {R4 flt;} _singleFloatArgs;
**Returns: True if args->flt is Infinity.  False otherwise. See above for the 
**         description of value used to determine Negative Infinity.
**Exceptions: None
==============================================================================*/
FCIMPL1(INT32, COMDouble::IsNegativeInfinity, double d)
    return  d == negInfinity.f;
FCIMPLEND

/*===========================IsPositiveInfinityFloat============================
**Args:    typedef struct {R4 flt;} _singleFloatArgs;
**Returns: True if args->flt is Infinity.  False otherwise. See above for the 
**         description of value used to determine Positive Infinity.
**Exceptions: None
==============================================================================*/
FCIMPL1(INT32, COMDouble::IsPositiveInfinity, double d)
    return  d == posInfinity.f;
FCIMPLEND

/*====================================Floor=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Floor, double d) 
    return (R8) floor(d);
FCIMPLEND


/*====================================Ceil=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Ceil, double d) 
    return (R8) ceil(d);
FCIMPLEND

/*=====================================Sqrt=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Sqrt, double d) 
    return (R8) sqrt(d);
FCIMPLEND

/*=====================================Log======================================
**This is the natural log
==============================================================================*/
FCIMPL1(R8, COMDouble::Log, double d) 
    return (R8) log(d);
FCIMPLEND


/*====================================Log10=====================================
**This is log-10
==============================================================================*/
FCIMPL1(R8, COMDouble::Log10, double d) 
    return (R8) log10(d);
FCIMPLEND

/*=====================================Pow======================================
**This is the power function.  Simple powers are done inline, and special
  cases are sent to the CRT via the helper.  Note that the code here is based
  on the implementation of power in the CRT.
==============================================================================*/
FCIMPL2_RR(R8, COMDouble::PowHelper, double x, double y) 
{
    return (R8) pow(x, y);	
}
FCIMPLEND

#ifdef _X86_

#if defined (_DEBUG)
__declspec(naked) static R8 __fastcall PowRetail(double x, double y)
#else
__declspec(naked) R8 __fastcall COMDouble::Pow(double x, double y)
#endif
{
    // Arguments:
    // exponent: esp+4
    // base:     esp+12
    
    _asm
    {
        mov     ecx, [esp+8]           ; high dword of exponent
        mov     edx, [esp+16]          ; high dword of base
        
        and     ecx,  7ff00000H        ; check for special exponent
        cmp     ecx,  7ff00000H
        je      callHelper

        and     edx,  7ff00000H        ; check for special base
        cmp     edx,  7ff00000H
        je      callHelper

        test    edx,  7ff00000H        ; see if the base has a zero exponent
        jz      test_if_we_have_zero_base

base_is_not_zero:

        mov     cl,  [esp+19]          ; Handle negative base in the helper
        and     cl,  80H
        jnz     callHelper

        fld     qword ptr [esp+4]
        fld     qword ptr [esp+12]

        fyl2x                          ; compute y*log2(x)
        
        ; Compute the 2^TOS (based on CRT function _twoToTOS)
        fld     st(0)                  ; duplicate stack top
        frndint                        ; N = round(y)
        fsubr   st(1), st
        fxch
        fchs                           ; g = y - N where abs(g) < 1
        f2xm1                          ; 2**g - 1
        fld1
        fadd                           ; 2**g
        fscale                         ; (2**g) * (2**N) - gives 2**y
        fstp    st(1)                  ; pop extra stuff from fp stack               

        ret     16

test_if_we_have_zero_base:
            
        mov     eax, [esp+16]
        and     eax, 000fffffH
        or      eax, [esp+12]
        jnz     base_is_not_zero
        ; fall through to the helper

callHelper:

        jmp     COMDouble::PowHelper   ; The helper will return control
                                       ; directly to our caller.
    }
}
#if defined (_DEBUG)

#define EPSILON 0.0000000001

void assertDoublesWithinRange(double r1, double r2)
{
    if (_finite(r1) && _finite(r2))
    {
        // Both numbers are finite--we need to check that they are close to
        // each other.  If they are large (> 1), the error could also be large,
        // which is acceptable, so we compare the error against EPSILON*norm.

        double norm = __max(fabs(r1), fabs(r2));
        double error = fabs(r1-r2);
        
        assert((error < (EPSILON * norm)) || (error < EPSILON));
    }
    else if (!_isnan(r1) && !_isnan(r2))
    {
        // At least one of r1 and r2 is infinite, so when multiplied by
        // (1 + EPSILON) they should be the same infinity.

        assert((r1 * (1 + EPSILON)) == (r2 * (1 + EPSILON)));
    }
    else
    {
        // Otherwise at least one of r1 or r2 is a Nan.  Is that case, they better be in
        // the same class.

        assert(_fpclass(r1) == _fpclass(r2));
    }
}

FCIMPL2_RR(R8, COMDouble::Pow, double x, double y) 
{
    double r1, r2;

    // Note that PowRetail expects the argument order to be reversed
    
    r1 = (R8) PowRetail(y, x);
    
    r2 = (R8) pow(x, y);

    // Can't do a floating point compare in case r1 and r2 aren't 
    // valid fp numbers.

    assertDoublesWithinRange(r1, r2);

    return (R8) r1;	
}
FCIMPLEND

#endif

#else

FCIMPL2_RR(R8, COMDouble::Pow, double x, double y) 
{
    return (R8) pow(x, y);	
}
FCIMPLEND

#endif

/*=====================================Exp======================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Exp, double x) 

		// The C intrinsic below does not handle +- infinity properly
		// so we handle these specially here
	if (fabs(x) == posInfinity.f) {
		if (x < 0)		
			return(+0.0);
		return(x);		// Must be + infinity
	}
    return((R8) exp(x));

FCIMPLEND

/*=====================================Acos=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Acos, double d) 
    return (R8) acos(d);
FCIMPLEND


/*=====================================Asin=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Asin, double d) 
    return (R8) asin(d);
FCIMPLEND


/*=====================================AbsFlt=====================================
**
==============================================================================*/
FCIMPL1(R4, COMDouble::AbsFlt, float f) 
    return fabsf(f);
FCIMPLEND

/*=====================================AbsDbl=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::AbsDbl, double d) 
    return fabs(d);
FCIMPLEND

/*=====================================Atan=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Atan, double d) 
    return (R8) atan(d);
FCIMPLEND

/*=====================================Atan2=====================================
**
==============================================================================*/
FCIMPL2_RR(R8, COMDouble::Atan2, double x, double y) 

		// the intrinsic for Atan2 does not produce Nan for Atan2(+-inf,+-inf)
	if (fabs(x) == posInfinity.f && fabs(y) == posInfinity.f) {
		return(x / y);		// create a NaN
	}
    return (R8) atan2(x, y);
FCIMPLEND

/*=====================================Sin=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Sin, double d) 
    return (R8) sin(d);
FCIMPLEND

/*=====================================Cos=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Cos, double d) 
    return (R8) cos(d);
FCIMPLEND

/*=====================================Tan=====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Tan, double d) 
    return (R8) tan(d);
FCIMPLEND

/*=====================================Sinh====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Sinh, double d) 
    return (R8) sinh(d);
FCIMPLEND

/*=====================================Cosh====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Cosh, double d) 
    return (R8) cosh(d);
FCIMPLEND

/*=====================================Tanh====================================
**
==============================================================================*/
FCIMPL1(R8, COMDouble::Tanh, double d) 
    return (R8) tanh(d);
FCIMPLEND

/*=====================================IEEERemainder===========================
**
==============================================================================*/
FCIMPL2_RR(R8, COMDouble::IEEERemainder, double x, double y) 
    return (R8) fmod(x, y);
FCIMPLEND

/*====================================Round=====================================
**
==============================================================================*/
#ifdef _X86_
__declspec(naked)
R8 __fastcall COMDouble::Round(double d)
{
    __asm {
        fld QWORD PTR [ESP+4]
        frndint
        ret 8
    }
}

#else
FCIMPL1(R8, COMDouble::Round, double d) 
    R8 tempVal;
    R8 flrTempVal;
    tempVal = (d+0.5);
    //We had a number that was equally close to 2 integers. 
    //We need to return the even one.
    flrTempVal = floor(tempVal);
    if (flrTempVal==tempVal) {
        if (0==fmod(tempVal, 2.0)) {
            return flrTempVal;
        }
        return flrTempVal-1.0;
    }
    return flrTempVal;
FCIMPLEND
#endif


// We do the bounds checking in managed code to ensure that we have between 0 and 15 in cDecimals.
// Note this implementation is copied from OLEAut. However they supported upto 22 digits not clear why? 
FCIMPL2(R8, COMDouble::RoundDigits, double dblIn, int cDecimals)
    if (fabs(dblIn) < 1E16)
    {
      dblIn *= rgdblPower10[cDecimals];

#ifdef _M_IX86
      __asm {
	    fld     dblIn
	    frndint
	    fstp    dblIn
      }
#else
      double	  dblFrac;

      dblFrac = modf(dblIn, &dblIn);
      if (fabs(dblFrac) != 0.5 || fmod(dblIn, 2) != 0)
	dblIn += (int)(dblFrac * 2);
#endif

      dblIn /= rgdblPower10[cDecimals];
    }
    return dblIn;
FCIMPLEND

//
// Initialize Strings;
//
OBJECTHANDLE COMFloat::ReturnString[3] = {NULL,NULL,NULL};
LPCUTF8 COMFloat::ReturnStringNames[3] = {"PositiveInfinityString", "NegativeInfinityString", "NaNString" };
EEClass *COMFloat::FPInterfaceClass=NULL;
LPCUTF8 COMFloat::FPInterfaceName="System.Single";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\comfloat.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COMPLUSFLOAT_H
#define _COMPLUSFLOAT_H

#define POSITIVE_INFINITY_STRING L"1.#INF"
#define NEGATIVE_INFINITY_STRING L"-1.#INF"
#define NAN_STRING L"-1.#IND"

//The following #define is stolen from cruntime.h
#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
#define UNALIGNED __unaligned
#elif !defined(_M_IA64)  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
#define UNALIGNED
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

#ifdef	_M_IX86
/* Uncomment this for enabling 10-byte long double string conversions */
/* #define LONG_DOUBLE */
#endif

//Stolen from cruntime.h
#ifdef _M_IX86
/*
 * 386/486
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#elif (defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC))
/*
 * MIPS, ALPHA, or PPC
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#define REG5    register
#define REG6    register
#define REG7    register
#define REG8    register
#define REG9    register

#elif (defined (_M_M68K) || defined (_M_MPPC))
/*
 * Macros defining the calling type of a function
 */

#define _CALLTYPE1      __cdecl    /* old -- check source user visible functions */
#define _CALLTYPE2      __cdecl    /* old -- check source user visible functions */
#define _CALLTYPE3      illegal    /* old -- check source should not used*/
#define _CALLTYPE4      __cdecl    /* old -- check source internal (static) functions */

/*
 * Macros for defining the naming of a public variable
 */

#define _VARTYPE1

/*
 * Macros for register variable declarations
 */

#define REG1
#define REG2
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#else  /* (defined (_M_M68K) || defined (_M_MPPC)) */

#pragma message ("Machine register set not defined")

/*
 * Unknown machine
 */

#define REG1
#define REG2
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#endif  /* (defined (_M_M68K) || defined (_M_MPPC)) */
//#include <wchar.h>
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  _WCHAR_T_DEFINED

#ifndef _WCHAR_ABBREV_DEFINED
typedef wchar_t WCHAR;
#define _WCHAR_ABBREV_DEFINED
#endif  _WCHAR_ABBREV_DEFINED

//
// Infinity and NAN handling macros.
// Stolen from trans.h
//

#define D_BIASM1 0x3fe /* off by one to compensate for the implied bit */

//#ifdef B_END
/* big endian */
//#define D_EXP(x) ((unsigned short *)&(x))
//#define D_HI(x) ((unsigned long *)&(x))
//#define D_LO(x) ((unsigned long *)&(x)+1)
//#else
//Little Endian
#define D_EXP(x) ((unsigned short *)&(x)+3)
#define D_HI(x) ((unsigned long *)&(x)+1)
#define D_LO(x) ((unsigned long *)&(x))
//#endif

/* return the int representation of the exponent
 * if x = .f * 2^n, 0.5<=f<1, return n (unbiased)
 * e.g. INTEXP(3.0) == 2
 */
#define INTEXP(x) ((signed short)((*D_EXP(x) & 0x7ff0) >> 4) - D_BIASM1)

/* check for infinity, NAN */
#define D_ISINF(x) ((*D_HI(x) & 0x7fffffff) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_SPECIAL(x)	((*D_EXP(x) & 0x7ff0) == 0x7ff0)
#define IS_D_NAN(x) (IS_D_SPECIAL(x) && !D_ISINF(x))
#define IS_D_DENORMAL(x) ((*D_EXP(x)==0) && (*D_HI(x)!=0 || *D_LO(x)!=0))

#define FLOAT_MAX_EXP			 0x7F800000
#define FLOAT_MANTISSA_MASK		 0x007fffff
#define FLOAT_POSITIVE_INFINITY  0x7F800000
#define FLOAT_NEGATIVE_INFINITY  0xFF800000
#define FLOAT_NOT_A_NUMBER       0xFFC00000
#define DOUBLE_POSITIVE_INFINITY 0x7FF0000000000000
#define DOUBLE_NEGATIVE_INFINITY 0xFFF0000000000000
#define DOUBLE_NOT_A_NUMBER      0xFFF8000000000000

//Stolen from CVT.H
//This is way too big for a float.  How can I cut this down?
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop */

#define FORMAT_G 0
#define FORMAT_F 1
#define FORMAT_E 2

#ifndef _ALPHA_
_CRTIMP double __cdecl floor(double);
#else // !_ALPHA_
double __cdecl floor(double);
#endif // _ALPHA_
double __cdecl sqrt(double);
double __cdecl log(double);
double  __cdecl log10(double);
double __cdecl exp(double);
double __cdecl pow(double, double);
double  __cdecl acos(double);
double  __cdecl asin(double);
double  __cdecl atan(double);
double  __cdecl atan2(double,double);
double  __cdecl cos(double);
double  __cdecl sin(double);
double  __cdecl tan(double);
double  __cdecl cosh(double);
double  __cdecl sinh(double);
double  __cdecl tanh(double);
double  __cdecl fmod(double, double);
#ifndef _ALPHA_
_CRTIMP double  __cdecl ceil(double);
#else // !_ALPHA_
double  __cdecl ceil(double);
#endif // _ALPHA_


#endif _COMPLUSFLOAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\comfloatexternalmethods.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "COMFloat.h"
#include "COMCV.h"

extern "C" {
    WCHAR * __cdecl _ConvertG(double, int, WCHAR *);
    WCHAR * __cdecl _ConvertE (double,int,int *,int *,WCHAR *, int);
    WCHAR * __cdecl _ConvertF (double,int,int *,int *,WCHAR *, int);

/*
 * The static character array buf[CVTBUFSIZE] is used by the _fpcvt routine
 * (the workhorse for _ecvt and _fcvt) for storage of its output.  The routine
 * gcvt expects the user to have set up their own storage.  CVTBUFSIZE is set
 * large enough to accomodate the largest double precision number plus 40
 * decimal places (even though you only have 16 digits of accuracy in a
 * double precision IEEE number, the user may ask for more to effect 0
 * padding; but there has to be a limit somewhere).
 */

/*
 * define a maximum size for the conversion buffer.  It should be at least
 * as long as the number of digits in the largest double precision value
 * (?.?e308 in IEEE arithmetic).  We will use the same size buffer as is
 * used in the printf support routine (_output)
 */

#ifdef _MT
    WCHAR * __cdecl _Wfpcvt(STRFLT, int, int *, int *,WCHAR *, int);
#else  /* _MT */
    static WCHAR * __cdecl _Wfpcvt(STRFLT, int, int *, int *,WCHAR *, int);
#endif  /* _MT */
    //    void _atodbl(COMDOUBLE *, WCHAR *);
    //    void _atoflt(COMFLOAT *, WCHAR *);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\constpow.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*constpow.c - constant powers of ten
*
*Purpose:
*   Provide powers of ten in long double form:
*   10^(2^i), i=0,1,2,...
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*
*******************************************************************************/


#include <COMcv.h>

/* Format: A 10 byte long double + 2 bytes of extra precision
 * If the extra precision is desired, the 10-byte long double
 * should be "unrounded" first.
 * This may change in later versions
 */

#ifdef L_END

_LDBL12 _pow10pos[] = {
 /*P0001*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x02,0x40}},
 /*P0002*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x05,0x40}},
 /*P0003*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0x08,0x40}},
 /*P0004*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x9C,0x0C,0x40}},
 /*P0005*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xC3,0x0F,0x40}},
 /*P0006*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xF4,0x12,0x40}},
 /*P0007*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x80,0x96,0x98,0x16,0x40}},
 /*P0008*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x20,0xBC,0xBE,0x19,0x40}},
 /*P0016*/ {{0x00,0x00, 0x00,0x00,0x00,0x04,0xBF,0xC9,0x1B,0x8E,0x34,0x40}},
 /*P0024*/ {{0x00,0x00, 0x00,0xA1,0xED,0xCC,0xCE,0x1B,0xC2,0xD3,0x4E,0x40}},
 /*P0032*/ {{0x20,0xF0, 0x9E,0xB5,0x70,0x2B,0xA8,0xAD,0xC5,0x9D,0x69,0x40}},
 /*P0040*/ {{0xD0,0x5D, 0xFD,0x25,0xE5,0x1A,0x8E,0x4F,0x19,0xEB,0x83,0x40}},
 /*P0048*/ {{0x71,0x96, 0xD7,0x95,0x43,0x0E,0x05,0x8D,0x29,0xAF,0x9E,0x40}},
 /*P0056*/ {{0xF9,0xBF, 0xA0,0x44,0xED,0x81,0x12,0x8F,0x81,0x82,0xB9,0x40}},
 /*P0064*/ {{0xBF,0x3C, 0xD5,0xA6,0xCF,0xFF,0x49,0x1F,0x78,0xC2,0xD3,0x40}},
 /*P0128*/ {{0x6F,0xC6, 0xE0,0x8C,0xE9,0x80,0xC9,0x47,0xBA,0x93,0xA8,0x41}},
 /*P0192*/ {{0xBC,0x85, 0x6B,0x55,0x27,0x39,0x8D,0xF7,0x70,0xE0,0x7C,0x42}},
 /*P0256*/ {{0xBC,0xDD, 0x8E,0xDE,0xF9,0x9D,0xFB,0xEB,0x7E,0xAA,0x51,0x43}},
 /*P0320*/ {{0xA1,0xE6, 0x76,0xE3,0xCC,0xF2,0x29,0x2F,0x84,0x81,0x26,0x44}},
 /*P0384*/ {{0x28,0x10, 0x17,0xAA,0xF8,0xAE,0x10,0xE3,0xC5,0xC4,0xFA,0x44}},
 /*P0448*/ {{0xEB,0xA7, 0xD4,0xF3,0xF7,0xEB,0xE1,0x4A,0x7A,0x95,0xCF,0x45}},
 /*P0512*/ {{0x65,0xCC, 0xC7,0x91,0x0E,0xA6,0xAE,0xA0,0x19,0xE3,0xA3,0x46}},
 /*P1024*/ {{0x0D,0x65, 0x17,0x0C,0x75,0x81,0x86,0x75,0x76,0xC9,0x48,0x4D}},
 /*P1536*/ {{0x58,0x42, 0xE4,0xA7,0x93,0x39,0x3B,0x35,0xB8,0xB2,0xED,0x53}},
 /*P2048*/ {{0x4D,0xA7, 0xE5,0x5D,0x3D,0xC5,0x5D,0x3B,0x8B,0x9E,0x92,0x5A}},
 /*P2560*/ {{0xFF,0x5D, 0xA6,0xF0,0xA1,0x20,0xC0,0x54,0xA5,0x8C,0x37,0x61}},
 /*P3072*/ {{0xD1,0xFD, 0x8B,0x5A,0x8B,0xD8,0x25,0x5D,0x89,0xF9,0xDB,0x67}},
 /*P3584*/ {{0xAA,0x95, 0xF8,0xF3,0x27,0xBF,0xA2,0xC8,0x5D,0xDD,0x80,0x6E}},
 /*P4096*/ {{0x4C,0xC9, 0x9B,0x97,0x20,0x8A,0x02,0x52,0x60,0xC4,0x25,0x75}}
};

_LDBL12 _pow10neg[] = {
 /*N0001*/ {{0xCD,0xCC, 0xCD,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFB,0x3F}},
 /*N0002*/ {{0x71,0x3D, 0x0A,0xD7,0xA3,0x70,0x3D,0x0A,0xD7,0xA3,0xF8,0x3F}},
 /*N0003*/ {{0x5A,0x64, 0x3B,0xDF,0x4F,0x8D,0x97,0x6E,0x12,0x83,0xF5,0x3F}},
 /*N0004*/ {{0xC3,0xD3, 0x2C,0x65,0x19,0xE2,0x58,0x17,0xB7,0xD1,0xF1,0x3F}},
 /*N0005*/ {{0xD0,0x0F, 0x23,0x84,0x47,0x1B,0x47,0xAC,0xC5,0xA7,0xEE,0x3F}},
 /*N0006*/ {{0x40,0xA6, 0xB6,0x69,0x6C,0xAF,0x05,0xBD,0x37,0x86,0xEB,0x3F}},
 /*N0007*/ {{0x33,0x3D, 0xBC,0x42,0x7A,0xE5,0xD5,0x94,0xBF,0xD6,0xE7,0x3F}},
 /*N0008*/ {{0xC2,0xFD, 0xFD,0xCE,0x61,0x84,0x11,0x77,0xCC,0xAB,0xE4,0x3F}},
 /*N0016*/ {{0x2F,0x4C, 0x5B,0xE1,0x4D,0xC4,0xBE,0x94,0x95,0xE6,0xC9,0x3F}},
 /*N0024*/ {{0x92,0xC4, 0x53,0x3B,0x75,0x44,0xCD,0x14,0xBE,0x9A,0xAF,0x3F}},
 /*N0032*/ {{0xDE,0x67, 0xBA,0x94,0x39,0x45,0xAD,0x1E,0xB1,0xCF,0x94,0x3F}},
 /*N0040*/ {{0x24,0x23, 0xC6,0xE2,0xBC,0xBA,0x3B,0x31,0x61,0x8B,0x7A,0x3F}},
 /*N0048*/ {{0x61,0x55, 0x59,0xC1,0x7E,0xB1,0x53,0x7C,0x12,0xBB,0x5F,0x3F}},
 /*N0056*/ {{0xD7,0xEE, 0x2F,0x8D,0x06,0xBE,0x92,0x85,0x15,0xFB,0x44,0x3F}},
 /*N0064*/ {{0x24,0x3F, 0xA5,0xE9,0x39,0xA5,0x27,0xEA,0x7F,0xA8,0x2A,0x3F}},
 /*N0128*/ {{0x7D,0xAC, 0xA1,0xE4,0xBC,0x64,0x7C,0x46,0xD0,0xDD,0x55,0x3E}},
 /*N0192*/ {{0x63,0x7B, 0x06,0xCC,0x23,0x54,0x77,0x83,0xFF,0x91,0x81,0x3D}},
 /*N0256*/ {{0x91,0xFA, 0x3A,0x19,0x7A,0x63,0x25,0x43,0x31,0xC0,0xAC,0x3C}},
 /*N0320*/ {{0x21,0x89, 0xD1,0x38,0x82,0x47,0x97,0xB8,0x00,0xFD,0xD7,0x3B}},
 /*N0384*/ {{0xDC,0x88, 0x58,0x08,0x1B,0xB1,0xE8,0xE3,0x86,0xA6,0x03,0x3B}},
 /*N0448*/ {{0xC6,0x84, 0x45,0x42,0x07,0xB6,0x99,0x75,0x37,0xDB,0x2E,0x3A}},
 /*N0512*/ {{0x33,0x71, 0x1C,0xD2,0x23,0xDB,0x32,0xEE,0x49,0x90,0x5A,0x39}},
 /*N1024*/ {{0xA6,0x87, 0xBE,0xC0,0x57,0xDA,0xA5,0x82,0xA6,0xA2,0xB5,0x32}},
 /*N1536*/ {{0xE2,0x68, 0xB2,0x11,0xA7,0x52,0x9F,0x44,0x59,0xB7,0x10,0x2C}},
 /*N2048*/ {{0x25,0x49, 0xE4,0x2D,0x36,0x34,0x4F,0x53,0xAE,0xCE,0x6B,0x25}},
 /*N2560*/ {{0x8F,0x59, 0x04,0xA4,0xC0,0xDE,0xC2,0x7D,0xFB,0xE8,0xC6,0x1E}},
 /*N3072*/ {{0x9E,0xE7, 0x88,0x5A,0x57,0x91,0x3C,0xBF,0x50,0x83,0x22,0x18}},
 /*N3584*/ {{0x4E,0x4B, 0x65,0x62,0xFD,0x83,0x8F,0xAF,0x06,0x94,0x7D,0x11}},
 /*N4096*/ {{0xE4,0x2D, 0xDE,0x9F,0xCE,0xD2,0xC8,0x04,0xDD,0xA6,0xD8,0x0A}}
};

#endif

#ifdef B_END

_LDBL12 _pow10pos[] = {
 /*P0001*/ {{0x40,0x02,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0002*/ {{0x40,0x05,0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0003*/ {{0x40,0x08,0xFA,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0004*/ {{0x40,0x0C,0x9C,0x40,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0005*/ {{0x40,0x0F,0xC3,0x50,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0006*/ {{0x40,0x12,0xF4,0x24,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0007*/ {{0x40,0x16,0x98,0x96,0x80,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0008*/ {{0x40,0x19,0xBE,0xBC,0x20,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0016*/ {{0x40,0x34,0x8E,0x1B,0xC9,0xBF,0x04,0x00,0x00,0x00, 0x00,0x00}},
 /*P0024*/ {{0x40,0x4E,0xD3,0xC2,0x1B,0xCE,0xCC,0xED,0xA1,0x00, 0x00,0x00}},
 /*P0032*/ {{0x40,0x69,0x9D,0xC5,0xAD,0xA8,0x2B,0x70,0xB5,0x9E, 0xF0,0x20}},
 /*P0040*/ {{0x40,0x83,0xEB,0x19,0x4F,0x8E,0x1A,0xE5,0x25,0xFD, 0x5D,0xD0}},
 /*P0048*/ {{0x40,0x9E,0xAF,0x29,0x8D,0x05,0x0E,0x43,0x95,0xD7, 0x96,0x71}},
 /*P0056*/ {{0x40,0xB9,0x82,0x81,0x8F,0x12,0x81,0xED,0x44,0xA0, 0xBF,0xF9}},
 /*P0064*/ {{0x40,0xD3,0xC2,0x78,0x1F,0x49,0xFF,0xCF,0xA6,0xD5, 0x3C,0xBF}},
 /*P0128*/ {{0x41,0xA8,0x93,0xBA,0x47,0xC9,0x80,0xE9,0x8C,0xE0, 0xC6,0x6F}},
 /*P0192*/ {{0x42,0x7C,0xE0,0x70,0xF7,0x8D,0x39,0x27,0x55,0x6B, 0x85,0xBC}},
 /*P0256*/ {{0x43,0x51,0xAA,0x7E,0xEB,0xFB,0x9D,0xF9,0xDE,0x8E, 0xDD,0xBC}},
 /*P0320*/ {{0x44,0x26,0x81,0x84,0x2F,0x29,0xF2,0xCC,0xE3,0x76, 0xE6,0xA1}},
 /*P0384*/ {{0x44,0xFA,0xC4,0xC5,0xE3,0x10,0xAE,0xF8,0xAA,0x17, 0x10,0x28}},
 /*P0448*/ {{0x45,0xCF,0x95,0x7A,0x4A,0xE1,0xEB,0xF7,0xF3,0xD4, 0xA7,0xEB}},
 /*P0512*/ {{0x46,0xA3,0xE3,0x19,0xA0,0xAE,0xA6,0x0E,0x91,0xC7, 0xCC,0x65}},
 /*P1024*/ {{0x4D,0x48,0xC9,0x76,0x75,0x86,0x81,0x75,0x0C,0x17, 0x65,0x0D}},
 /*P1536*/ {{0x53,0xED,0xB2,0xB8,0x35,0x3B,0x39,0x93,0xA7,0xE4, 0x42,0x58}},
 /*P2048*/ {{0x5A,0x92,0x9E,0x8B,0x3B,0x5D,0xC5,0x3D,0x5D,0xE5, 0xA7,0x4D}},
 /*P2560*/ {{0x61,0x37,0x8C,0xA5,0x54,0xC0,0x20,0xA1,0xF0,0xA6, 0x5D,0xFF}},
 /*P3072*/ {{0x67,0xDB,0xF9,0x89,0x5D,0x25,0xD8,0x8B,0x5A,0x8B, 0xFD,0xD1}},
 /*P3584*/ {{0x6E,0x80,0xDD,0x5D,0xC8,0xA2,0xBF,0x27,0xF3,0xF8, 0x95,0xAA}},
 /*P4096*/ {{0x75,0x25,0xC4,0x60,0x52,0x02,0x8A,0x20,0x97,0x9B, 0xC9,0x4C}}
};

_LDBL12 _pow10neg[] = {
 /*N0001*/ {{0x3F,0xFB,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCD, 0xCC,0xCD}},
 /*N0002*/ {{0x3F,0xF8,0xA3,0xD7,0x0A,0x3D,0x70,0xA3,0xD7,0x0A, 0x3D,0x71}},
 /*N0003*/ {{0x3F,0xF5,0x83,0x12,0x6E,0x97,0x8D,0x4F,0xDF,0x3B, 0x64,0x5A}},
 /*N0004*/ {{0x3F,0xF1,0xD1,0xB7,0x17,0x58,0xE2,0x19,0x65,0x2C, 0xD3,0xC3}},
 /*N0005*/ {{0x3F,0xEE,0xA7,0xC5,0xAC,0x47,0x1B,0x47,0x84,0x23, 0x0F,0xD0}},
 /*N0006*/ {{0x3F,0xEB,0x86,0x37,0xBD,0x05,0xAF,0x6C,0x69,0xB6, 0xA6,0x40}},
 /*N0007*/ {{0x3F,0xE7,0xD6,0xBF,0x94,0xD5,0xE5,0x7A,0x42,0xBC, 0x3D,0x33}},
 /*N0008*/ {{0x3F,0xE4,0xAB,0xCC,0x77,0x11,0x84,0x61,0xCE,0xFD, 0xFD,0xC2}},
 /*N0016*/ {{0x3F,0xC9,0xE6,0x95,0x94,0xBE,0xC4,0x4D,0xE1,0x5B, 0x4C,0x2F}},
 /*N0024*/ {{0x3F,0xAF,0x9A,0xBE,0x14,0xCD,0x44,0x75,0x3B,0x53, 0xC4,0x92}},
 /*N0032*/ {{0x3F,0x94,0xCF,0xB1,0x1E,0xAD,0x45,0x39,0x94,0xBA, 0x67,0xDE}},
 /*N0040*/ {{0x3F,0x7A,0x8B,0x61,0x31,0x3B,0xBA,0xBC,0xE2,0xC6, 0x23,0x24}},
 /*N0048*/ {{0x3F,0x5F,0xBB,0x12,0x7C,0x53,0xB1,0x7E,0xC1,0x59, 0x55,0x61}},
 /*N0056*/ {{0x3F,0x44,0xFB,0x15,0x85,0x92,0xBE,0x06,0x8D,0x2F, 0xEE,0xD7}},
 /*N0064*/ {{0x3F,0x2A,0xA8,0x7F,0xEA,0x27,0xA5,0x39,0xE9,0xA5, 0x3F,0x24}},
 /*N0128*/ {{0x3E,0x55,0xDD,0xD0,0x46,0x7C,0x64,0xBC,0xE4,0xA1, 0xAC,0x7D}},
 /*N0192*/ {{0x3D,0x81,0x91,0xFF,0x83,0x77,0x54,0x23,0xCC,0x06, 0x7B,0x63}},
 /*N0256*/ {{0x3C,0xAC,0xC0,0x31,0x43,0x25,0x63,0x7A,0x19,0x3A, 0xFA,0x91}},
 /*N0320*/ {{0x3B,0xD7,0xFD,0x00,0xB8,0x97,0x47,0x82,0x38,0xD1, 0x89,0x21}},
 /*N0384*/ {{0x3B,0x03,0xA6,0x86,0xE3,0xE8,0xB1,0x1B,0x08,0x58, 0x88,0xDC}},
 /*N0448*/ {{0x3A,0x2E,0xDB,0x37,0x75,0x99,0xB6,0x07,0x42,0x45, 0x84,0xC6}},
 /*N0512*/ {{0x39,0x5A,0x90,0x49,0xEE,0x32,0xDB,0x23,0xD2,0x1C, 0x71,0x33}},
 /*N1024*/ {{0x32,0xB5,0xA2,0xA6,0x82,0xA5,0xDA,0x57,0xC0,0xBE, 0x87,0xA6}},
 /*N1536*/ {{0x2C,0x10,0xB7,0x59,0x44,0x9F,0x52,0xA7,0x11,0xB2, 0x68,0xE2}},
 /*N2048*/ {{0x25,0x6B,0xCE,0xAE,0x53,0x4F,0x34,0x36,0x2D,0xE4, 0x49,0x25}},
 /*N2560*/ {{0x1E,0xC6,0xE8,0xFB,0x7D,0xC2,0xDE,0xC0,0xA4,0x04, 0x59,0x8F}},
 /*N3072*/ {{0x18,0x22,0x83,0x50,0xBF,0x3C,0x91,0x57,0x5A,0x88, 0xE7,0x9E}},
 /*N3584*/ {{0x11,0x7D,0x94,0x06,0xAF,0x8F,0x83,0xFD,0x62,0x65, 0x4B,0x4E}},
 /*N4096*/ {{0x0A,0xD8,0xA6,0xDD,0x04,0xC8,0xD2,0xCE,0x9F,0xDE, 0x2D,0xE4}}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\comfltintrn.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*fltintrn.h - contains declarations of internal floating point types,
*             routines and variables
*
*Purpose:
*       Declares floating point types, routines and variables used
*       internally by the C run-time.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_FLTINTRN
#define _INC_FLTINTRN

#include "COMFloat.h"

//#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
//#error ERROR: Use of C runtime library internal header file.
//#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//#include <cruntime.h>


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else  /* _MSC_VER >= 800 && _M_IX86 >= 300 */
#define _CRTAPI1
#endif  /* _MSC_VER >= 800 && _M_IX86 >= 300 */
#endif  /* _CRTAPI1 */


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else  /* _MSC_VER >= 800 && _M_IX86 >= 300 */
#define _CRTAPI2
#endif  /* _MSC_VER >= 800 && _M_IX86 >= 300 */
#endif  /* _CRTAPI2 */

/* Define __cdecl for non-Microsoft compilers */

#if (!defined (_MSC_VER) && !defined (__cdecl))
#define __cdecl
#endif  /* (!defined (_MSC_VER) && !defined (__cdecl)) */

/*
 * For MS C for the x86 family, disable the annoying "long double is the
 * same precision as double" warning
 */

#ifdef _M_IX86
#pragma warning(disable:4069)
#endif  /* _M_IX86 */

/*
 * structs used to fool the compiler into not generating floating point
 * instructions when copying and pushing [long] double values
 */

#ifndef COMDOUBLE

typedef struct {
        double d;
} COMDOUBLE;  // a really stupid name to get around the fact that DOUBLE is also defined in windef.h

#endif  /* DOUBLE */

#ifndef LONGDOUBLE

typedef struct {
#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) || defined (_M_MPPC)
        /*
         * No long double type for MIPS, ALPHA, PPC. or PowerMac
         */
        double x;
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) || defined (_M_MPPC) */
        /*
         * Assume there is a long double type
         */
        long double x;
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) || defined (_M_MPPC) */
} LONGDOUBLE;

#endif  /* LONGDOUBLE */

/*
 * typedef for _fltout
 */

typedef struct _strflt
{
        int sign;             /* zero if positive otherwise negative */
        int decpt;            /* exponent of floating point number */
        int flag;             /* zero if okay otherwise IEEE overflow */
        WCHAR *mantissa;       /* pointer to mantissa in string form */
}
        *STRFLT;


/*
 * typedef for _fltin
 */

typedef struct _flt
{
        int flags;
        int nbytes;          /* number of characters read */
        long lval;
        double dval;         /* the returned floating point number */
}
        *FLT;


#if defined (_M_M68K) || defined (_M_MPPC)
/*
 * typedef for _fltinl
 */

typedef struct _fltl
{
        int flags;
        int nbytes;          /* number of characters read */
        long lval;
        long double ldval;           /* the returned floating point number */
}
        *FLTL;
#endif  /* defined (_M_M68K) || defined (_M_MPPC) */

/* floating point conversion routines, keep in sync with mrt32\include\convert.h */

WCHAR * __cdecl _Wcftoe(double *, WCHAR *, int, int);
WCHAR * __cdecl _Wcftof(double *, WCHAR *, int);
void __cdecl _Wfptostr(WCHAR *, int, STRFLT);

#ifdef _MT

STRFLT  __cdecl _Wfltout2( double, STRFLT, WCHAR * );
FLT     __cdecl _Wfltin2( FLT , const WCHAR *, int, int, int );

#else  /* _MT */

STRFLT  __cdecl _Wfltout( double );
FLT     __cdecl _Wfltin( const WCHAR *, int, int, int );
#if defined (_M_M68K) || defined (_M_MPPC)
FLTL    _CALLTYPE2 _Wfltinl( const WCHAR *, int, int, int );
#endif  /* defined (_M_M68K) || defined (_M_MPPC) */

#endif  /* _MT */


/*
 * table of pointers to floating point helper routines
 *
 * We can't specify the prototypes for the entries of the table accurately,
 * since different functions in the table have different arglists.
 * So we declare the functions to take and return void (which is the
 * correct prototype for _fptrap(), which is what the entries are all
 * initialized to if no floating point is loaded) and cast appropriately
 * on every usage.
 */

typedef void (_cdecl * PFV)(void);
extern PFV _cfltcvt_tab[6];

typedef void (* PF0)(COMDOUBLE*, WCHAR*, int, int, int);
#define _cfltcvt(a,b,c,d,e) (*((PF0)_cfltcvt_tab[0]))(a,b,c,d,e)

typedef void (* PF1)(WCHAR*);
#define _cropzeros(a)       (*((PF1)_cfltcvt_tab[1]))(a)

typedef void (* PF2)(int, WCHAR*, WCHAR*);
#define _fassign(a,b,c)     (*((PF2)_cfltcvt_tab[2]))(a,b,c)

typedef void (* PF3)(WCHAR*);
#define _forcdecpt(a)       (*((PF3)_cfltcvt_tab[3]))(a)

typedef int (* PF4)(COMDOUBLE*);
#define _positive(a)        (*((PF4)_cfltcvt_tab[4]))(a)

typedef void (* PF5)(LONGDOUBLE*, WCHAR*, int, int, int);
#define _cldcvt(a,b,c,d,e)  (*((PF5)_cfltcvt_tab[5]))(a,b,c,d,e)


#ifdef _M_IX86
#pragma warning(default:4069)
#endif  /* _M_IX86 */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_FLTINTRN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\mantold.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*mantold.c - conversion of a decimal mantissa to _LDBL12
*
*Purpose:
*   Conversion of a decimal mantissa into _LDBL12 format (i.e. long
*   double with two additional bytes of significand)
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*
*******************************************************************************/

#include <COMcv.h>

/***
*int _CALLTYPE5 __Waddl(u_long x, u_long y, u_long *sum) - u_long addition
*
*Purpose: add two u_long numbers and return carry
*
*Entry: u_long x, u_long y : the numbers to be added
*	u_long *sum : where to store the result
*
*Exit: *sum receives the value of x+y
*      the value of the carry is returned
*
*Exceptions:
*
*******************************************************************************/

int _CALLTYPE5 __Waddl(u_long x, u_long y, u_long *sum)
{
    u_long r;
    int carry=0;
    r = x+y;
    if (r < x || r < y)
	carry++;
    *sum = r;
    return carry;
}






/***
*void _CALLTYPE5 __Wadd_12(_LDBL12 *x, _LDBL12 *y) -	_LDBL12 addition
*
*Purpose: add two _LDBL12 numbers. The numbers are added
*   as 12-byte integers. Overflow is ignored.
*
*Entry: x,y: pointers to the operands
*
*Exit: *x receives the sum
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __Wadd_12(_LDBL12 *x, _LDBL12 *y)
{
    int c0,c1,c2;
    c0 = __Waddl(*UL_LO_12(x),*UL_LO_12(y),UL_LO_12(x));
    if (c0) {
	c1 = __Waddl(*UL_MED_12(x),(u_long)1,UL_MED_12(x));
	if (c1) {
	    (*UL_HI_12(x))++;
	}
    }
    c2 = __Waddl(*UL_MED_12(x),*UL_MED_12(y),UL_MED_12(x));
    if (c2) {
	(*UL_HI_12(x))++;
    }
    /* ignore next carry -- assume no overflow will occur */
    (void) __Waddl(*UL_HI_12(x),*UL_HI_12(y),UL_HI_12(x));
}





/***
*void _CALLTYPE5 __Wshl_12(_LDBL12 *x) - _LDBL12 shift left
*void _CALLTYPE5 __Wshr_12(_LDBL12 *x) - _LDBL12 shift right
*
*Purpose: Shift a _LDBL12 number one bit to the left (right). The number
*   is shifted as a 12-byte integer. The MSB is lost.
*
*Entry: x: a pointer to the operand
*
*Exit: *x is shifted one bit to the left (or right)
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __Wshl_12(_LDBL12 *p)
{
    u_long c0,c1;

    c0 = *UL_LO_12(p) & MSB_ULONG ? 1: 0;
    c1 = *UL_MED_12(p) & MSB_ULONG ? 1: 0;
    *UL_LO_12(p) <<= 1;
    *UL_MED_12(p) = *UL_MED_12(p)<<1 | c0;
    *UL_HI_12(p) = *UL_HI_12(p)<<1 | c1;
}

void _CALLTYPE5 __Wshr_12(_LDBL12 *p)
{
    u_long c2,c1;
    c2 = *UL_HI_12(p) & 0x1 ? MSB_ULONG: 0;
    c1 = *UL_MED_12(p) & 0x1 ? MSB_ULONG: 0;
    *UL_HI_12(p) >>= 1;
    *UL_MED_12(p) = *UL_MED_12(p)>>1 | c2;
    *UL_LO_12(p) = *UL_LO_12(p)>>1 | c1;
}






/***
*void _CALLTYPE5 __Wmtold12(char *manptr,unsigned manlen,_LDBL12 *ld12) -
*   convert a mantissa into a _LDBL12
*
*Purpose: convert a mantissa into a _LDBL12. The mantissa is
*   in the form of an array of manlen BCD digits and is
*   considered to be an integer.
*
*Entry: manptr: the array containing the packed BCD digits of the mantissa
*	manlen: the size of the array
*	ld12: a pointer to the long double where the result will be stored
*
*Exit:
*	ld12 gets the result of the conversion
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __Wmtold12(WCHAR *manptr,
			 unsigned manlen,
			 _LDBL12 *ld12)
{
    _LDBL12 tmp;
    u_short expn = LD_BIASM1+80;

    *UL_LO_12(ld12) = 0;
    *UL_MED_12(ld12) = 0;
    *UL_HI_12(ld12) = 0;
    for (;manlen>0;manlen--,manptr++){
	tmp = *ld12;
	__Wshl_12(ld12);
	__Wshl_12(ld12);
	__Wadd_12(ld12,&tmp);
	__Wshl_12(ld12);	       /* multiply by 10 */
	*UL_LO_12(&tmp) = (u_long)*manptr;
	*UL_MED_12(&tmp) = 0;
	*UL_HI_12(&tmp) = 0;
	__Wadd_12(ld12,&tmp);
    }

    /* normalize mantissa -- first shift word by word */
    while (*UL_HI_12(ld12) == 0) {
	*UL_HI_12(ld12) = *UL_MED_12(ld12) >> 16;
	*UL_MED_12(ld12) = *UL_MED_12(ld12) << 16 | *UL_LO_12(ld12) >> 16;
	(*UL_LO_12(ld12)) <<= 16;
	expn -= 16;
    }
    while ((*UL_HI_12(ld12) & 0x8000) == 0) {
	__Wshl_12(ld12);
	expn--;
    }
    *U_EXP_12(ld12) = expn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\floatconvert.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <CrtWrap.h>
#include <clsload.hpp>
#include "COMFloat.h"
#include "COMCV.h"
#include "NLSINT.h"
#include "COMFloatExternalMethods.h"
#include <basetsd.h>  // CHANGED, VC6.0
#include <object.h>
#include <excep.h>
#include <vars.hpp>
#include <frames.h>
#include <field.h>
#include <utilcode.h>
#include <COMStringCommon.h>
#include "COMFloatClass.h"
#include <COMString.h>


/***
* intrncvt.c - internal floating point conversions
*
*Purpose:
*   All fp string conversion routines use the same core conversion code
*   that converts strings into an internal long double representation
*   with an 80-bit mantissa field. The mantissa is represented
*   as an array (man) of 32-bit unsigned longs, with man[0] holding
*   the high order 32 bits of the mantissa. The binary point is assumed
*   to be between the MSB and MSB-1 of man[0].
*
*   Bits are counted as follows:
*
*
*     +-- binary point
*     |
*     v          MSB           LSB
*   ----------------     ------------------  --------------------
*   |0 1    .... 31|     | 32 33 ...    63|  | 64 65 ...      95|
*   ----------------     ------------------  --------------------
*
*   man[0]          man[1]           man[2]
*
*   This file provides the final conversion routines from this internal
*   form to the single, double, or long double precision floating point
*   format.
*
*   All these functions do not handle NaNs (it is not necessary)
*
*
*Revision History:
*   04-29-92    GDP written
*   06-18-92    GDP now ld12told returns INTRNCVT_STATUS
*   06-22-92    GDP use new __strgtold12 interface (FORTRAN support)
*   10-25-92    GDP _Watoldbl bug fix (cuda 1345): if the mantissa overflows
*           set its MSB to 1)
*
*******************************************************************************/

#define INTRNMAN_LEN  3       /* internal mantissa length in int's */

//
//  internal mantissaa representation
//  for string conversion routines
//

typedef u_long *intrnman;

typedef struct {
    int max_exp;      // maximum base 2 exponent (reserved for special values)
    int min_exp;      // minimum base 2 exponent (reserved for denormals)
    int precision;    // bits of precision carried in the mantissa
    int exp_width;    // number of bits for exponent
    int format_width; // format width in bits
    int bias;        // exponent bias
} FpFormatDescriptor;

static FpFormatDescriptor
DoubleFormat = {
    0x7ff - 0x3ff,  //  1024, maximum base 2 exponent (reserved for special values)
    0x0   - 0x3ff,  // -1023, minimum base 2 exponent (reserved for denormals)
    53,         // bits of precision carried in the mantissa
    11,         // number of bits for exponent
    64,         // format width in bits
    0x3ff,      // exponent bias
};

static FpFormatDescriptor
FloatFormat = {
    0xff - 0x7f,    //  128, maximum base 2 exponent (reserved for special values)
    0x0  - 0x7f,    // -127, minimum base 2 exponent (reserved for denormals)
    24,         // bits of precision carried in the mantissa
    8,          // number of bits for exponent
    32,         // format width in bits
    0x7f,       // exponent bias
};

//
// function prototypes
//

int _RoundMan (intrnman man, int nbit);
int _ZeroTail (intrnman man, int nbit);
int _IncMan (intrnman man, int nbit);
void _CopyMan (intrnman dest, intrnman src);
void _CopyMan (intrnman dest, intrnman src);
void _FillZeroMan(intrnman man);
void _Shrman (intrnman man, int n);
INTRNCVT_STATUS _ld12cvt(_LDBL12 *pld12, void *d, FpFormatDescriptor *format);

/***
* _ZeroTail - check if a mantissa ends in 0's
*
*Purpose:
*   Return TRUE if all mantissa bits after nbit (including nbit) are 0,
*   otherwise return FALSE
*
*
*Entry:
*   man: mantissa
*   nbit: order of bit where the tail begins
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _ZeroTail (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;


    //
    //           |<---- tail to be checked --->
    //
    //  --  ------------------------           ----
    //  |...    |         |  ...      |
    //  --  ------------------------           ----
    //  ^   ^    ^
    //  |   |    |<----nb----->
    //  man nl   nbit
    //



    u_long bitmask = ~(MAX_ULONG << nb);

    if (man[nl] & bitmask)
    return 0;

    nl++;

    for (;nl < INTRNMAN_LEN; nl++)
    if (man[nl])
        return 0;

    return 1;
}




/***
* _IncMan - increment mantissa
*
*Purpose:
*
*
*Entry:
*   man: mantissa in internal long form
*   nbit: order of bit that specifies the end of the part to be incremented
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _IncMan (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;

    //
    //  |<--- part to be incremented -->|
    //
    //  --         ---------------------------     ----
    //  |...          |         |   ...   |
    //  --         ---------------------------     ----
    //  ^         ^     ^
    //  |         |     |<--nb-->
    //  man       nl        nbit
    //

    u_long one = (u_long) 1 << nb;
    int carry;

    carry = __Waddl(man[nl], one, &man[nl]);

    nl--;

    for (; nl >= 0 && carry; nl--) {
    carry = (u_long) __Waddl(man[nl], (u_long) 1, &man[nl]);
    }

    return carry;
}




/***
* _RoundMan -  round mantissa
*
*Purpose:
*   round mantissa to nbit precision
*
*
*Entry:
*   man: mantissa in internal form
*   precision: number of bits to be kept after rounding
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _RoundMan (intrnman man, int precision)
{
    int i,rndbit,nl,nb;
    u_long rndmask;
    int nbit;
    int retval = 0;

    //
    // The order of the n'th bit is n-1, since the first bit is bit 0
    // therefore decrement precision to get the order of the last bit
    // to be kept
    //
    nbit = precision - 1;

    rndbit = nbit+1;

    nl = rndbit / 32;
    nb = 31 - rndbit % 32;

    //
    // Get value of round bit
    //

    rndmask = (u_long)1 << nb;

    if ((man[nl] & rndmask) &&
     !_ZeroTail(man, rndbit+1)) {

    //
    // round up
    //

    retval = _IncMan(man, nbit);
    }


    //
    // fill rest of mantissa with zeroes
    //

    man[nl] &= MAX_ULONG << nb;
    for(i=nl+1; i<INTRNMAN_LEN; i++) {
    man[i] = (u_long)0;
    }

    return retval;
}


/***
* _CopyMan - copy mantissa
*
*Purpose:
*    copy src to dest
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _CopyMan (intrnman dest, intrnman src)
{
    u_long *p, *q;
    int i;

    p = src;
    q = dest;

    for (i=0; i < INTRNMAN_LEN; i++) {
    *q++ = *p++;
    }
}



/***
* _FillZeroMan - fill mantissa with zeroes
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _FillZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
    man[i] = (u_long)0;
}



/***
* _IsZeroMan - check if mantissa is zero
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _IsZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
    if (man[i])
        return 0;

    return 1;
}





/***
* _ShrMan - shift mantissa to the right
*
*Purpose:
*  shift man by n bits to the right
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _ShrMan (intrnman man, int n)
{
    int i, n1, n2, mask;
    int carry_from_left;

    //
    // declare this as volatile in order to work around a C8
    // optimization bug
    //

    volatile int carry_to_right;

    n1 = n / 32;
    n2 = n % 32;

    mask = ~(MAX_ULONG << n2);


    //
    // first deal with shifts by less than 32 bits
    //

    carry_from_left = 0;
    for (i=0; i<INTRNMAN_LEN; i++) {

    carry_to_right = man[i] & mask;

    man[i] >>= n2;

    man[i] |= carry_from_left;

    carry_from_left = carry_to_right << (32 - n2);
    }


    //
    // now shift whole 32-bit ints
    //

    for (i=INTRNMAN_LEN-1; i>=0; i--) {
    if (i >= n1) {
        man[i] = man[i-n1];
    }
    else {
        man[i] = 0;
    }
    }
}

/***
* _ld12tocvt - _LDBL12 floating point conversion
*
*Purpose:
*   convert a internal _LBL12 structure into an IEEE floating point
*   representation
*
*
*Entry:
*   pld12:  pointer to the _LDBL12
*   format: pointer to the format descriptor structure
*
*Exit:
*   *d contains the IEEE representation
*   returns the INTRNCVT_STATUS
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12cvt(_LDBL12 *pld12, void *d, FpFormatDescriptor *format)
{
    u_long man[INTRNMAN_LEN];
    u_long saved_man[INTRNMAN_LEN];
    u_long msw;
    unsigned int bexp;          // biased exponent
    int exp_shift;
    int exponent, sign;
    INTRNCVT_STATUS retval;

    exponent = (*U_EXP_12(pld12) & 0x7fff) - 0x3fff;   // unbias exponent
    sign = *U_EXP_12(pld12) & 0x8000;


    man[0] = *UL_MANHI_12(pld12);
    man[1] = *UL_MANLO_12(pld12);
    man[2] = *U_XT_12(pld12) << 16;


    //
    // bexp is the final biased value of the exponent to be used
    // Each of the following blocks should provide appropriate
    // values for man, bexp and retval. The mantissa is also
    // shifted to the right, leaving space for the exponent
    // and sign to be inserted
    //

    if (exponent == 0 - 0x3fff) {

    // either a denormal or zero
    bexp = 0;

    if (_IsZeroMan(man)) {

        retval = INTRNCVT_OK;
    }
    else {

        _FillZeroMan(man);

        // denormal has been flushed to zero

        retval = INTRNCVT_UNDERFLOW;
    }
    }
    else {

    // save mantissa in case it needs to be rounded again
    // at a different point (e.g., if the result is a denormal)

    _CopyMan(saved_man, man);

    if (_RoundMan(man, format->precision)) {
        exponent ++;
    }

    if (exponent < format->min_exp - format->precision ) {

        //
        // underflow that produces a zero
        //

        _FillZeroMan(man);
        bexp = 0;
        retval = INTRNCVT_UNDERFLOW;
    }

    else if (exponent <= format->min_exp) {

        //
        // underflow that produces a denormal
        //
        //

        // The (unbiased) exponent will be MIN_EXP
        // Find out how much the mantissa should be shifted
        // One shift is done implicitly by moving the
        // binary point one bit to the left, i.e.,
        // we treat the mantissa as .ddddd instead of d.dddd
        // (where d is a binary digit)

        int shift = format->min_exp - exponent;

        // The mantissa should be rounded again, so it
        // has to be restored

        _CopyMan(man,saved_man);

        _ShrMan(man, shift);
        _RoundMan(man, format->precision); // need not check for carry

        // make room for the exponent + sign

        _ShrMan(man, format->exp_width + 1);

        bexp = 0;
        retval = INTRNCVT_UNDERFLOW;

    }

    else if (exponent >= format->max_exp) {

        //
        // overflow, return infinity
        //

        _FillZeroMan(man);
        man[0] |= (1 << 31); // set MSB

        // make room for the exponent + sign

        _ShrMan(man, (format->exp_width + 1) - 1);

        bexp = format->max_exp + format->bias;

        retval = INTRNCVT_OVERFLOW;
    }

    else {

        //
        // valid, normalized result
        //

        bexp = exponent + format->bias;


        // clear implied bit

        man[0] &= (~( 1 << 31));

        //
        // shift right to make room for exponent + sign
        //

        _ShrMan(man, (format->exp_width + 1) - 1);

        retval = INTRNCVT_OK;

    }
    }


    exp_shift = 32 - (format->exp_width + 1);
    msw =  man[0] |
       (bexp << exp_shift) |
       (sign ? 1<<31 : 0);

    if (format->format_width == 64) {

    *UL_HI_D(d) = msw;
    *UL_LO_D(d) = man[1];
    }

    else if (format->format_width == 32) {

    *(u_long *)d = msw;

    }

    return retval;
}


//Cut this code.  We inlined it directly.
#if 0
/***
* _Wld12tod - convert _LDBL12 to double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _Wld12tod(_LDBL12 *pld12, DOUBLE *d)
{
    return _ld12cvt(pld12, d, &DoubleFormat);
}



/***
* _Wld12tof - convert _LDBL12 to float
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _Wld12tof(_LDBL12 *pld12, FLOAT *f)
{
    return _ld12cvt(pld12, f, &FloatFormat);
}

#endif 0

void _Watodbl(COMDOUBLE *d, WCHAR *str)
{
    const WCHAR *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0 );
    //_Wld12tod(&ld12, d);
    _ld12cvt(&ld12, d, &DoubleFormat);

}

void _Watoflt(COMFLOAT *f, WCHAR *str)
{
    const WCHAR *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0 );

    //    printf("Input: %s\n",str);
    //    printf("EndPtr: %s\n",EndPtr);
    //    fflush(stdout);


    //    _Wld12tof(&ld12, f);
    _ld12cvt(&ld12, f, &FloatFormat);
}




//
//
// CVT.C
//
//



//
//
// GCVT.C
//
//

/***
*double _gcvt(value, ndec, buffer) - convert floating point value to char
*       string
*
*Purpose:
*       _gcvt converts the value to a null terminated ASCII string
*       buf.  It attempts to produce ndigit significant digits
*       in Fortran F format if possible, ortherwise E format,
*       ready for printing.  Trailing zeros may be suppressed.
*       No error checking or overflow protection is provided.
*       NOTE - to avoid the possibility of generating floating
*       point instructions in this code we fool the compiler
*       about the type of the 'value' parameter using a struct.
*       This is OK since all we do is pass it off as a
*       parameter.
*
*Entry:
*       value - double - number to be converted
*       ndec - int - number of significant digits
*       buf - char * - buffer to place result
*
*Exit:
*       result is written into buffer; it will be overwritten if it has
*       not been made big enough.
*
*Exceptions:
*
*******************************************************************************/

extern "C" WCHAR * __cdecl _ConvertG (double value, int ndec, WCHAR *buf)
{

#ifdef _MT
        struct _strflt strfltstruct;    /* temporary buffers */
        WCHAR   resultstring[21];
#endif  /* _MT */

        STRFLT string;
        int    magnitude;
        WCHAR   *rc;

        REG1 WCHAR *str;
        REG2 WCHAR *stop;

        /* get the magnitude of the number */

#ifdef _MT
        string = _Wfltout2( value, &strfltstruct, resultstring );
#else  /* _MT */
        string = _Wfltout( value );
#endif  /* _MT */

        magnitude = string->decpt - 1;

        /* output the result according to the Fortran G format as outlined in
           Fortran language specification */

        if ( magnitude < -1  ||  magnitude > ndec-1 )
                /* then  Ew.d  d = ndec */
                rc = str = _Wcftoe( &value, buf, ndec-1, 0);
        else
                /* Fw.d  where d = ndec-string->decpt */
                rc = str = _Wcftof( &value, buf, ndec-string->decpt );

        while (*str && *str != *__decimal_point)
                str++;

        if (*str++) {
                while (*str && *str != 'e')
                        str++;

                stop = str--;

                while (*str == '0')
                        str--;

                while (*++str = *stop++)
                        ;
        }

        return(rc);
}

/***
*char *_fcvt(value, ndec, decpr, sign) - convert floating point to char string
*
*Purpose:
*       _fcvt like _ecvt converts the value to a null terminated
*       string of ASCII digits, and returns a pointer to the
*       result.  The routine prepares data for Fortran F-format
*       output with the number of digits following the decimal
*       point specified by ndec.  The position of the decimal
*       point relative to the beginning of the string is returned
*       indirectly through decpt.  The correct digit for Fortran
*       F-format is rounded.
*       NOTE - to avoid the possibility of generating floating
*       point instructions in this code we fool the compiler
*       about the type of the 'value' parameter using a struct.
*       This is OK since all we do is pass it off as a
*       parameter.
*
*Entry:
*       double value - number to be converted
*       int ndec - number of digits after decimal point
*
*Exit:
*       returns pointer to the character string representation of value.
*       also, the output is written into the static char array buf.
*       int *decpt - pointer to int with pos. of dec. point
*       int *sign - pointer to int with sign (0 = pos, non-0 = neg)
*
*Exceptions:
*
*******************************************************************************/

extern "C" WCHAR * __cdecl _ConvertF (double value, int ndec,int *decpt,int *sign,WCHAR *buf, int buffLength) {
    REG1 STRFLT pflt;
    
#ifdef _MT
    struct _strflt strfltstruct;
    WCHAR resultstring[21];
    
    /* ok to take address of stack struct here; fltout2 knows to use ss */
    pflt = _Wfltout2( value, &strfltstruct, resultstring );
    
    
#else  /* _MT */
    pflt = _Wfltout( value );
#endif  /* _MT */
    
    return( _Wfpcvt( pflt, pflt->decpt + ndec, decpt, sign,buf,buffLength ) );
}


/***
*char *_ecvt( value, ndigit, decpt, sign ) - convert floating point to string
*
*Purpose:
*       _ecvt converts value to a null terminated string of
*       ASCII digits, and returns a pointer to the result.
*       The position of the decimal point relative to the
*       begining of the string is stored indirectly through
*       decpt, where negative means to the left of the returned
*       digits.  If the sign of the result is negative, the
*       word pointed to by sign is non zero, otherwise it is
*       zero.  The low order digit is rounded.
*
*Entry:
*       double value - number to be converted
*       int ndigit - number of digits after decimal point
*
*Exit:
*       returns pointer to the character representation of value.
*       also the output is written into the statuc char array buf.
*       int *decpt - pointer to int with position of decimal point
*       int *sign - pointer to int with sign in it (0 = pos, non-0 = neg)
*
*Exceptions:
*
*******************************************************************************/

extern "C" WCHAR * __cdecl _ConvertE (double value, int ndigit, int *decpt, int *sign, WCHAR *buf, int buffLength)
{

#ifdef _MT
        REG1 STRFLT pflt;

        struct _strflt strfltstruct;        /* temporary buffers */
        WCHAR resultstring[21];

        /* ok to take address of stack struct here; fltout2 knows to use ss */
        pflt = _Wfltout2( value, &strfltstruct, resultstring );

        buf = _Wfpcvt( pflt, ndigit, decpt, sign,buf,buffLength );

#else  /* _MT */
        buf = _Wfpcvt( _Wfltout(value), ndigit, decpt, sign,buf,buffLength );
#endif  /* _MT */

        /* _Wfptostr() occasionally returns an extra character in the buffer ... */

        if (buf[ndigit])
                buf[ndigit] = '\0';
        return( buf );
}


/***
*char *_Wfpcvt() - gets final string and sets decpt and sign     [STATIC]
*
*Purpose:
*       This is a small common routine used by [ef]cvt.  It calls fptostr
*       to get the final string and sets the decpt and sign indicators.
*
*History:  JRoxe       Apr 16, 1998      Modified to caller-allocate the buffer.
*  
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

extern "C" 
#ifdef _MT
WCHAR * __cdecl _Wfpcvt ( REG2 STRFLT pflt,REG3 int digits, int *decpt, int *sign, WCHAR *buf, int buffLength )
#else  /* _MT */
static WCHAR * __cdecl _Wfpcvt (REG2 STRFLT pflt,REG3 int digits,int *decpt,int *sign, WCHAR *buf, int buffLength)
#endif  /* _MT */
{

        /* make sure we don't overflow the buffer size.  If the user asks for
         * more digits than the buffer can handle, truncate it to the maximum
         * size allowed in the buffer.  The maximum size is CVTBUFSIZE - 2
         * since we useone character for overflow and one for the terminating
         * null character.
         */

    //        _Wfptostr(buf, (digits > CVTBUFSIZE - 2) ? CVTBUFSIZE - 2 : digits, pflt);
    _Wfptostr(buf, (digits > buffLength - 2) ? buffLength - 2 : digits, pflt);

        /* set the sign flag and decimal point position */

    *sign = (pflt->sign == '-') ? 1 : 0;
    *decpt = pflt->decpt;
    return(buf);
}


/*================================StringToFloat=================================
**This is a reexpression of _Watoflt so that we could fit it into a COM+ class 
**for convenience and neatness.
**Args:  WCHAR *str -- the string to be converted.
**Returns: Flags indicating return conditions.  We use the SLD flags, namely
**SLD_NODIGITS, SLD_UNDERFLOW, SLD_OVERFLOW.
**
**Exceptions: None, the caller is responsible for handling generated exceptions.
==============================================================================*/
INT32 COMFloat::StringToFloat(WCHAR *str, const WCHAR **EndPtr, float *result) {
    _LDBL12 ld12;
    COMFLOAT f;
    INT32 resultflags = 0;
    INTRNCVT_STATUS ret;

    resultflags=__strgtold12(&ld12, EndPtr, str, 0, 0, 0, 0 );
    ret=_ld12cvt(&ld12, &f, &FloatFormat);
    switch (ret) {
    case INTRNCVT_OVERFLOW:
        resultflags |= SLD_OVERFLOW;
        break;
    case INTRNCVT_UNDERFLOW:
        resultflags |= SLD_UNDERFLOW;
        break;
    case INTRNCVT_OK:
        break;
    default:
        //Do nothing.
        break;
    };
        
    *result = f.f;

    return resultflags;
}


/*==============================GetStringFromClass==============================
**
==============================================================================*/
STRINGREF COMFloat::GetStringFromClass(int StringPos){
    STRINGREF sTemp;
    
    THROWSCOMPLUSEXCEPTION();
    
    _ASSERTE(StringPos<=NAN_POS);

    //If we've never gotten a reference to the required string, we need to go get one.
    if (COMFloat::ReturnString[StringPos]==NULL) {
        //Get the class and field descriptors and verify that we actually got them.
        if (!COMFloat::FPInterfaceClass) {
#ifndef _NEW_CLASSLOADER
            if ((COMFloat::FPInterfaceClass = g_pClassLoader->LoadClass(COMFloat::FPInterfaceName))==NULL) {
                FATAL_EE_ERROR();
            }
#else //_NEW_CLASSLOADER
            if ((COMFloat::FPInterfaceClass = SystemDomain::Loader()->LoadClass(COMFloat::FPInterfaceName))==NULL) {
                FATAL_EE_ERROR();
            }
#endif //_NEW_CLASSLOADER
                    //Ensure that the class initializer has actually run.
            OBJECTREF Throwable;
            if (!COMFloat::FPInterfaceClass->DoRunClassInit(&Throwable)) {
                COMPlusThrow(Throwable);
            }

        }
        FieldDesc *fd = FPInterfaceClass->FindField((LPCUTF8)(COMFloat::ReturnStringNames[StringPos]),&gsig_StringClass);
        if (!fd) {
            FATAL_EE_ERROR();
        }
        //Get the value of the String.
        sTemp = (STRINGREF) fd->GetStaticOBJECTREF();
        //Create a GCHandle using the STRINGREF that we just got back.
        COMFloat::ReturnString[StringPos] = CreateHandle(NULL);
        StoreObjectInHandle(COMFloat::ReturnString[StringPos], (OBJECTREF) sTemp);
        //Return the StringRef that we just got.
        return sTemp;
    }

    //We've already have a reference to the needed String, so we can just return it.
    return (STRINGREF) ObjectFromHandle(COMFloat::ReturnString[StringPos]);
}

/*================================FloatToString=================================
**This is a wrapper around the CRT function gcvt (renamed _ConvertG) that puts
**the parsed characters into a STRINGREF and makes sure that everything is kosher
**from the COM+ point of view.
**
**Args:  float f -- the float to be parsed into a string
**Returns: A STRINGREF with a representation of f
**Exceptions:  None.
==============================================================================*/
STRINGREF COMFloat::FloatToString(float f, int precision, int fmtType) {
    WCHAR temp[CVTBUFSIZE];
    int length;
    int decpt, sign;
    INT32 fpTemp;

    THROWSCOMPLUSEXCEPTION();

    fpTemp = *((INT32 *)&f);

    if (FLOAT_POSITIVE_INFINITY==fpTemp) {
        return GetStringFromClass(POSITIVE_INFINITY_POS);
    } else if (FLOAT_NEGATIVE_INFINITY==fpTemp) {
        return GetStringFromClass(NEGATIVE_INFINITY_POS);
    } else if (FLOAT_NOT_A_NUMBER==fpTemp) {
        return GetStringFromClass(NAN_POS);
    }        
    
    switch (fmtType) {
    case FORMAT_G:
        _ConvertG((double)f,precision,temp);
        length = lstrlenW (temp);
        if (*__decimal_point==temp[length-1]) {
            //we have plenty of room in the buffer for this maneuver.
            temp[length++]='0';
            temp[length]='\0';
        }
        return COMString::NewString(temp);
    case FORMAT_F:
        _ConvertF((double)f,precision,&decpt, &sign, temp, CVTBUFSIZE);
        return COMString::NewStringFloat(temp,decpt,sign,*__decimal_point);
    case FORMAT_E:
        //@ToDo: The +1 is a hack to give the desired response.  _ConvertE seems to assume that 
        //the decimal point is at position 0.  Check if this is what C actually does.
        _ConvertE((double)f,precision+1,&decpt, &sign, temp, CVTBUFSIZE);
        return COMString::NewStringExponent(temp,decpt,sign,*__decimal_point);
    default:
        COMPlusThrow(kFormatException, L"Format_BadFormatSpecifier");
    }
    return NULL; //We'll never get here, but it keeps the compiler happy.
}

/*================================DoubleToString================================
**
==============================================================================*/
STRINGREF COMDouble::DoubleToString(double d, int precision, int fmtType) {
    WCHAR temp[CVTBUFSIZE];
    int length;
    int decpt, sign;
    INT64 fpTemp;


    THROWSCOMPLUSEXCEPTION();
    
    fpTemp = *((INT64 *)&d);

   if (DOUBLE_POSITIVE_INFINITY==fpTemp) {
        return COMFloat::GetStringFromClass(POSITIVE_INFINITY_POS);
    } else if (DOUBLE_NEGATIVE_INFINITY==fpTemp) {
        return COMFloat::GetStringFromClass(NEGATIVE_INFINITY_POS);
    } else if (DOUBLE_NOT_A_NUMBER==fpTemp) {
        return COMFloat::GetStringFromClass(NAN_POS);
    }        
 
    switch (fmtType) {
    case FORMAT_G:
        _ConvertG(d,precision,temp);
        length = lstrlenW (temp);
        if (*__decimal_point==temp[length-1]) {
            //we have plenty of room in the buffer for this maneuver.
            temp[length++]='0';
            temp[length]='\0';
        }
        return COMString::NewString(temp);
    case FORMAT_F:
        _ConvertF(d,precision,&decpt, &sign, temp, CVTBUFSIZE);
        return COMString::NewStringFloat(temp,decpt,sign,*__decimal_point);
    case FORMAT_E:
        //@ToDo: The +1 is a hack to give the desired response.  _ConvertE seems to assume that 
        //the decimal point is at position 0.  Check if this is what C actually does.
        _ConvertE(d,precision+1,&decpt, &sign, temp, CVTBUFSIZE);
        return COMString::NewStringExponent(temp,decpt,sign,*__decimal_point);
    default:
        COMPlusThrow(kFormatException, L"Format_BadFormatSpecifier");
    }
    return NULL; //We'll never get here, but it keeps the compiler happy.


}
    
/*================================StringToDouble================================
**
==============================================================================*/
INT32 COMDouble::StringToDouble(WCHAR *str, const WCHAR **EndPtr, double *result) {
    _LDBL12 ld12;
    COMDOUBLE d;
    INT32 resultflags = 0;
    INTRNCVT_STATUS ret;

    resultflags=__strgtold12(&ld12, EndPtr, str, 0, 0, 0, 0 );
    ret=_ld12cvt(&ld12, &d, &DoubleFormat);
    switch (ret) {
    case INTRNCVT_OVERFLOW:
        resultflags |= SLD_OVERFLOW;
        break;
    case INTRNCVT_UNDERFLOW:
        resultflags |= SLD_UNDERFLOW;
        break;
    case INTRNCVT_OK:
        break;
    default:
        //Do nothing.
        break;
    };
        
    *result = d.d;

    return resultflags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\cvt.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*** 
*cvt.c - C floating-point output conversions
*
*Purpose:
*   contains routines for performing %e, %f, and %g output conversions
*   for printf, etc.
*
*   routines include _Wcfltcvt(), _Wcftoe(), _Wcftof(), _cftog(),
*            _Wfassign(), _positive(), _Wcropzeros(), _Wforcdecpt()
*
*Revision History:
*   04-18-84  RN    author
*   01-15-87  BCM   corrected processing of %g formats (to handle precision
*           as the maximum number of signifcant digits displayed)
*   03-24-87  BCM   Evaluation Issues: (fccvt.obj version for ?LIBFA)
*           ------------------
*           SDS - no problem
*           GD/TS :
*               char g_fmt = 0;         (local,   initialized)
*               int g_magnitude =0;     (local,   initialized)
*               char g_round_expansion = 0; (local,   initialized)
*               STRFLT g_pflt;              (local, uninitialized)
*           other INIT :
*           ALTMATH __fpmath() initialization (perhaps)
*           TERM - nothing
*   10-22-87  BCM   changes for OS/2 Support Library -
*                   including elimination of g_... static variables
*                   in favor of stack-based variables & function arguments
*                   under MTHREAD switch;  changed interfaces to _cfto? routines
*   01-15-88  BCM   remove IBMC20 switches; use only memmove, not memcpy;
*                   use just MTHREAD switch, not SS_NEQ_DGROUP
*   06-13-88  WAJ   Fixed %.1g processing for small x
*   08-02-88  WAJ   Made changes to _Wfassign() for new input().
*   03-09-89  WAJ   Added some long double support.
*   06-05-89  WAJ   Made changes for C6. LDOUBLE => long double
*   06-12-89  WAJ   Renamed this file from cvtn.c to cvt.c
*   11-02-89  WAJ   Removed register.h
*   06-28-90  WAJ   Removed fars.
*   11-15-90  WAJ   Added _cdecl where needed. Also "pascal" => "_pascal".
*   09-12-91  GDP   _cdecl=>_CALLTYPE2 _pascal=>_CALLTYPE5 near=>_NEAR
*   04-30-92  GDP   Removed floating point code. Instead used S/W routines
*           (_Watodbl, _Watoflt _Watoldbl), so that to avoid
*           generation of IEEE exceptions from the lib code.
*   03-11-93  JWM   Added minimal support for _INTL decimal point - one byte only!
*   04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*   07-16-93  SRW   ALPHA Merge
*   11-15-93  GJF   Merged in NT SDK version ("ALPHA merge" stuff). Also,
*           dropped support of Alpha acc compier, replaced i386
*           with _M_IX86, replaced MTHREAD with _MT.
*   09-06-94  CFW   Remove _INTL switch.
*
*******************************************************************************/
#include <CrtWrap.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <COMcv.h>
#include <nlsint.h>
#include "COMFloat.h"
#include <COMUtilNative.h>


/* this routine resides in the crt32 tree */
extern void __cdecl _Wfptostr(WCHAR *buf, int digits, STRFLT pflt);


static void _CALLTYPE5 _shift( WCHAR *s, int dist );

#ifdef  _MT
    static WCHAR * _Wcftoe2( WCHAR * buf, int ndec, int caps, STRFLT pflt, WCHAR g_fmt );
    static WCHAR * _Wcftof2( WCHAR * buf, int ndec, STRFLT pflt, WCHAR g_fmt );

#else   /* not _MT */
    static WCHAR * _Wcftoe_g( double * pvalue, WCHAR * buf, int ndec, int caps );
    static WCHAR * _Wcftof_g( double * pvalue, WCHAR * buf, int ndec );
#endif  /* not _MT */

/*** 
*_Wforcdecpt(buffer) - force a decimal point in floating-point output
*Purpose:
*   force a decimal point in floating point output. we are only called if '#'
*   flag is given and precision is 0; so we know the number has no '.'. insert
*   the '.' and move everybody else back one position, until '\0' seen
*
*   side effects: futzes around with the buffer, trying to insert a '.' 
*   after the initial string of digits. the first char can usually be 
*   skipped since it will be a digit or a '-'.  but in the 0-precision case, 
*   the number could start with 'e' or 'E', so we'd want the '.' before the 
*   exponent in that case.
*
*Entry:
*   buffer = (char *) pointer to buffer to modify
*
*Exit:
*   returns : (void)
*
*Exceptions:
*******************************************************************************/

void __cdecl _Wforcdecpt( WCHAR * buffer )
{
WCHAR   holdchar;
WCHAR   nextchar;

    if (*buffer != 'e' && *buffer != 'E'){
    do {
        buffer++;
        }
    while (COMCharacter::nativeIsDigit(*buffer));
    }

    holdchar = *buffer;
    
    *buffer++ = *__decimal_point;

    do  {
    nextchar = *buffer;
    *buffer = holdchar;
    holdchar = nextchar;
    }

    while(*buffer++);
}


/*** 
*_Wcropzeros(buffer) - removes trailing zeros from floating-point output
*Purpose:
*   removes trailing zeros (after the '.') from floating-point output;
*   called only when we're doing %g format, there's no '#' flag, and 
*   precision is non-zero.  plays around with the buffer, looking for
*   trailing zeros.  when we find them, then we move everbody else forward
*   so they overlay the zeros.  if we eliminate the entire fraction part,
*   then we overlay the decimal point ('.'), too.   
*
*   side effects: changes the buffer from
*       [-] digit [digit...] [ . [digits...] [0...] ] [(exponent part)]
*   to
*       [-] digit [digit...] [ . digit [digits...] ] [(exponent part)]
*   or
*       [-] digit [digit...] [(exponent part)]
*
*Entry:
*   buffer = (char *) pointer to buffer to modify
*
*Exit:
*   returns : (void)
*
*Exceptions:
*******************************************************************************/

void __cdecl _Wcropzeros( char * buf )
{
char    *stop;

    while (*buf && *buf != *__decimal_point)
    buf++;

    if (*buf++) {
    while (*buf && *buf != 'e' && *buf != 'E')
        buf++;

    stop = buf--;

    while (*buf == '0')
        buf--;

    if (*buf == *__decimal_point)
        buf--;

    while( (*++buf = *stop++) != '\0' );
    }
}


int __cdecl _positive( double * arg )
{
    return( (*arg >= 0.0) );
}


void  __cdecl _Wfassign( int flag, WCHAR * argument, WCHAR * number )
{

    COMFLOAT floattemp;
    COMDOUBLE doubletemp;

#ifdef  LONG_DOUBLE

    _LDOUBLE longtemp;

    switch( flag ){
    case 2:
        _Watoldbl( &longtemp, number );
        *(_LDOUBLE UNALIGNED *)argument = longtemp;
        break;

    case 1:
        _Watodbl( &doubletemp, number );
        *(DOUBLE UNALIGNED *)argument = doubletemp;
        break;

    default:
        _Watoflt( &floattemp, number );
        *(FLOAT UNALIGNED *)argument = floattemp;
    }

#else   /* not LONG_DOUBLE */

    if (flag) {
    _Watodbl( &doubletemp, number );
    *(COMDOUBLE UNALIGNED *)argument = doubletemp;
    } else {
    _Watoflt( &floattemp, number );
    *(COMFLOAT UNALIGNED *)argument = floattemp;
    }

#endif  /* not LONG_DOUBLE */
}


#ifndef _MT
    static char   g_fmt = 0;
    static int    g_magnitude = 0;
    static char   g_round_expansion = 0;
    static STRFLT g_pflt;
#endif


/*
 *  Function name:  _Wcftoe
 *
 *  Arguments:      pvalue -  double * pointer
 *          buf    -  char * pointer
 *          ndec   -  int
 *          caps   -  int
 *
 *  Description:    _Wcftoe converts the double pointed to by pvalue to a null
 *          terminated string of ASCII digits in the c language
 *          printf %e format, nad returns a pointer to the result.
 *          This format has the form [-]d.ddde(+/-)ddd, where there
 *          will be ndec digits following the decimal point.  If
 *          ndec <= 0, no decimal point will appear.  The low order
 *          digit is rounded.  If caps is nonzero then the exponent
 *          will appear as E(+/-)ddd.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *          of CVTBUFSIZE (defined in cvt.h) and the routines will
 *          not write over this size.
 *
 *  written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

#ifdef _MT
    static WCHAR * _Wcftoe2( WCHAR * buf, int ndec, int caps, STRFLT pflt, WCHAR g_fmt )
#else
    WCHAR * __cdecl _Wcftoe( double * pvalue, WCHAR * buf, int ndec, int caps )
#endif
{
#ifndef _MT
    STRFLT pflt;
#endif

WCHAR   *p;
int exp;

    /* first convert the value */

    /* place the output in the buffer and round.  Leave space in the buffer
     * for the '-' sign (if any) and the decimal point (if any)
     */

    if (g_fmt) {
#ifndef _MT
    pflt = g_pflt;
#endif
    /* shift it right one place if nec. for decimal point */

    p = buf + (pflt->sign == '-');
    _shift(p, (ndec > 0));
        }
#ifndef _MT
    else {
    pflt = _Wfltout(*pvalue);
    _Wfptostr(buf + (pflt->sign == '-') + (ndec > 0), ndec + 1, pflt);
    }
#endif


    /* now fix the number up to be in e format */

    p = buf;

    /* put in negative sign if needed */

    if (pflt->sign == '-')
    *p++ = '-';

    /* put in decimal point if needed.  Copy the first digit to the place
     * left for it and put the decimal point in its place
     */

    if (ndec > 0) {
    *p = *(p+1);
    *(++p) = *__decimal_point;
    }

    /* find the end of the string and attach the exponent field */

    p = wcscpy(p+ndec+(!g_fmt), L"e+000");

    /* adjust exponent indicator according to caps flag and increment
     * pointer to point to exponent sign
     */

    if (caps)
    *p = 'E';

    p++;

    /* if mantissa is zero, then the number is 0 and we are done; otherwise
     * adjust the exponent sign (if necessary) and value.
     */

    if (*pflt->mantissa != '0') {

    /* check to see if exponent is negative; if so adjust exponent sign and
     * exponent value.
     */

    if( (exp = pflt->decpt - 1) < 0 ) {
        exp = -exp;
        *p = '-';
        }

    p++;

    if (exp >= 100) {
        *p += (WCHAR)(exp / 100);
        exp %= 100;
        }
    p++;

    if (exp >= 10) {
        *p += (WCHAR)(exp / 10);
        exp %= 10;
        }

    *++p += (WCHAR)exp;
    }

    return(buf);
}


#ifdef _MT

WCHAR * _cdecl _Wcftoe( double * pvalue, WCHAR * buf, int ndec, int caps )
{
struct _strflt retstrflt;
WCHAR  resstr[21];
STRFLT pflt = &retstrflt;

    _Wfltout2(*pvalue, (struct _strflt *)&retstrflt,
          (WCHAR *)resstr);
    _Wfptostr(buf + (pflt->sign == '-') + (ndec > 0), ndec + 1, pflt);
    _Wcftoe2(buf, ndec, caps, pflt, /* g_fmt = */ 0);

    return( buf );
}

#else   /* not _MT */

static WCHAR * _Wcftoe_g( double * pvalue, WCHAR * buf, int ndec, int caps )
{
    WCHAR *res;
    g_fmt = 1;
    res = _Wcftoe(pvalue, buf, ndec, caps);
    g_fmt = 0;
    return (res);
}

#endif  /* not _MT */


#ifdef _MT
static WCHAR * _Wcftof2( WCHAR * buf, int ndec, STRFLT pflt, WCHAR g_fmt )

#else
WCHAR * __cdecl _Wcftof( double * pvalue, WCHAR * buf, int ndec )
#endif

{
#ifndef _MT
STRFLT pflt;
#endif

WCHAR   *p;

#ifdef _MT
int g_magnitude = pflt->decpt - 1;
#endif


    /* first convert the value */

    /* place the output in the users buffer and round.  Save space for
     * the minus sign now if it will be needed
     */

    if (g_fmt) {
#ifndef _MT
    pflt = g_pflt;
#endif

    p = buf + (pflt->sign == '-');
    if (g_magnitude == ndec) {
        WCHAR *q = p + g_magnitude;
        *q++ = '0';
        *q = '\0';
        /* allows for extra place-holding '0' in the exponent == precision
         * case of the g format
         */
        }
    }
#ifndef _MT
    else {
    pflt = _Wfltout(*pvalue);
    _Wfptostr(buf+(pflt->sign == '-'), ndec + pflt->decpt, pflt);
    }
#endif


    /* now fix up the number to be in the correct f format */

    p = buf;

    /* put in negative sign, if necessary */

    if (pflt->sign == '-')
    *p++ = '-';

    /* insert leading 0 for purely fractional values and position ourselves
     * at the correct spot for inserting the decimal point
     */

    if (pflt->decpt <= 0) {
    _shift(p, 1);
    *p++ = '0';
    }
    else
    p += pflt->decpt;

    /* put in decimal point if required and any zero padding needed */

    if (ndec > 0) {
    _shift(p, 1);
    *p++ = *__decimal_point;

    /* if the value is less than 1 then we may need to put 0's out in
     * front of the first non-zero digit of the mantissa
     */

    if (pflt->decpt < 0) {
        if( g_fmt )
        ndec = -pflt->decpt;
        else
        ndec = (ndec < -pflt->decpt ) ? ndec : -pflt->decpt;
        _shift(p, ndec);
        memset( p, '0', ndec);
        }
    }

    return( buf);
}


/*
 *  Function name:  _Wcftof
 *
 *  Arguments:      value  -  double * pointer
 *          buf    -  char * pointer
 *          ndec   -  int
 *
 *  Description:    _Wcftof converts the double pointed to by pvalue to a null
 *          terminated string of ASCII digits in the c language
 *          printf %f format, and returns a pointer to the result.
 *          This format has the form [-]ddddd.ddddd, where there will
 *          be ndec digits following the decimal point.  If ndec <= 0,
 *          no decimal point will appear.  The low order digit is
 *          rounded.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *          of CVTBUFSIZE (defined in cvt.h) and the routines will
 *          not write over this size.
 *
 *  written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

#ifdef _MT

WCHAR * __cdecl _Wcftof( double * pvalue, WCHAR * buf, int ndec )
{
    struct _strflt retstrflt;
    WCHAR  resstr[21];
    STRFLT pflt = &retstrflt;
    _Wfltout2(*pvalue, (struct _strflt *) &retstrflt,
                      (WCHAR *) resstr);
    _Wfptostr(buf+(pflt->sign == '-'), ndec + pflt->decpt, pflt);
    _Wcftof2(buf, ndec, pflt, /* g_fmt = */ 0);

    return( buf );
}

#else   /* not _MT */


static WCHAR * _Wcftof_g( double * pvalue, WCHAR * buf, int ndec )
{
    WCHAR *res;
    g_fmt = 1;
    res = _Wcftof(pvalue, buf, ndec);
    g_fmt = 0;
    return (res);
}

#endif  /* not _MT */

/*
 *  Function name:  _cftog
 *
 *  Arguments:      value  -  double * pointer
 *          buf    -  char * pointer
 *          ndec   -  int
 *
 *  Description:    _cftog converts the double pointed to by pvalue to a null
 *          terminated string of ASCII digits in the c language
 *          printf %g format, and returns a pointer to the result.
 *          The form used depends on the value converted.  The printf
 *          %e form will be used if the magnitude of valude is less
 *          than -4 or is greater than ndec, otherwise printf %f will
 *          be used.  ndec always specifies the number of digits
 *          following the decimal point.  The low order digit is
 *          appropriately rounded.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *          of CVTBUFSIZE (defined in cvt.h) and the routines will
 *          not write over this size.
 *
 *  written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

WCHAR * __cdecl _cftog( double * pvalue, WCHAR * buf, int ndec, int caps )
{
WCHAR *p;

#ifdef _MT
WCHAR g_round_expansion = 0;
STRFLT g_pflt;
int g_magnitude;
struct _strflt retstrflt;
WCHAR  resstr[21];

    /* first convert the number */

    g_pflt = &retstrflt;
    _Wfltout2(*pvalue, (struct _strflt *)&retstrflt,
          (WCHAR *)resstr);

#else   /* not _MT */

    /* first convert the number */

    g_pflt = _Wfltout(*pvalue);
#endif  /* not _MT */

    g_magnitude = g_pflt->decpt - 1;
    p = buf + (g_pflt->sign == '-');

    _Wfptostr(p, ndec, g_pflt);
    g_round_expansion = (WCHAR)(g_magnitude < (g_pflt->decpt-1));


    /* compute the magnitude of value */

    g_magnitude = g_pflt->decpt - 1;

    /* convert value to the c language g format */

    if (g_magnitude < -4 || g_magnitude >= ndec){     /* use e format */
    /*  (g_round_expansion ==>
     *  extra digit will be overwritten by 'e+xxx')
     */

#ifdef _MT
    return(_Wcftoe2(buf, ndec, caps, g_pflt, /* g_fmt = */ 1));
#else
    return(_Wcftoe_g(pvalue, buf, ndec, caps));
#endif

    }
    else {                                           /* use f format */
    if (g_round_expansion) {
        /* throw away extra final digit from expansion */
        while (*p++);
        *(p-2) = '\0';
        }

#ifdef _MT
    return(_Wcftof2(buf, ndec, g_pflt, /* g_fmt = */ 1));
#else
    return(_Wcftof_g(pvalue, buf, ndec));
#endif

    }
}

/*** 
*_Wcfltcvt(arg, buf, format, precision, caps) - convert floating-point output
*Purpose:
*
*Entry:
*   arg = (double *) pointer to double-precision floating-point number 
*   buf = (char *) pointer to buffer into which to put the converted
*                  ASCII form of the number
*   format = (int) 'e', 'f', or 'g'
*   precision = (int) giving number of decimal places for %e and %f formats,
*                     and giving maximum number of significant digits for
*                     %g format
*   caps = (int) flag indicating whether 'E' in exponent should be capatilized
*                (for %E and %G formats only)
*   
*Exit:
*   returns : (void)
*
*Exceptions:
*******************************************************************************/
/*
 *  Function name:  _Wcfltcvt
 *
 *  Arguments:      arg    -  double * pointer
 *          buf    -  char * pointer
 *                  format -  int
 *          ndec   -  int
 *          caps   -  int
 *
 *  Description:    _Wcfltcvt determines from the format, what routines to
 *          call to generate the correct floating point format
 *
 *  Side Effects:   none
 *
 *  Author:        Dave Weil, Jan 12, 1985
 */

void __cdecl _Wcfltcvt( double * arg, WCHAR * buffer, int format, int precision, int caps )
{
    if (format == 'e' || format == 'E')
    _Wcftoe(arg, buffer, precision, caps);
    else if (format == 'f')
    _Wcftof(arg, buffer, precision);
    else
    _cftog(arg, buffer, precision, caps);
}

/*** 
*_shift(s, dist) - shift a null-terminated string in memory (internal routine)
*Purpose:
*   _shift is a helper routine that shifts a null-terminated string 
*   in memory, e.g., moves part of a buffer used for floating-point output
*
*   modifies memory locations (s+dist) through (s+dist+strlen(s))
*
*Entry:
*   s = (char *) pointer to string to move
*   dist = (int) distance to move the string to the right (if negative, to left)
*
*Exit:
*   returns : (void)
*
*Exceptions:
*******************************************************************************/

static void _CALLTYPE5 _shift( WCHAR *s, int dist )
{
    if( dist )
    memmove(s+dist, s, (lstrlenW (s)+1)*sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\sources.inc ===
#
# Viper build instructions for this directory
#
#   Bob Atkinson
#   April 1997

NO_CRT                  =1
!include $(NTMAKEENV)\sources.cor

# WarningControl.h disables too many warnings.  VM folder will not use it.
COMPILER_WARNINGS	=/WX

INCLUDES        = ..;..\..\inc;$(INCLUDES);..\..;..\..\inc;..\..\..\vm;..\..\..\vm\$(_TGTCPU);..\..\..\inc;..\..\..\..\inc;..\..\..\interp;..\..\..\ceegen\inc;

MINORCOMP       =cor

TARGETNAME      =$(DDKBUILDENV)\COMFloat_$(_CORFLAVOR)
TARGETPATH      =$(TARGETCORBIN)
TARGETTYPE      =LIBRARY

C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE -DCRTDLL -DUSE_MAPSYM /TP /FmCOMFloat.map -D_NEW_CLASSLOADER -DJIT_OR_NATIVE_SUPPORTED -W4 

# for some reason, I can't get the FPU intrinics for sin, cos, etc unless I use /Ox
# I can't find the pragma optimize that does it.  
!if "$(FREEBUILD)"=="1"
MSC_OPTIMIZATION=/Ox
!endif

# Causes the appropriate checked/free version of msvcprt{d}.lib
#   to be included in the link
# The static versions of this library is libcpmtd.lib (checked)
#   and libcpmt.lib (free)
USE_STL         = 1

TARGETLIBS      = \
#    $(SDK_LIB_PATH)\ole32.lib \
#    $(SDK_LIB_PATH)\comdlg32.lib

SOURCES=        \
    ..\COMFloat.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\tenpow.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*tenpow.c - multiply a _LDBL12 by a power of 10
*
*Purpose:
*
*Revision History:
*       07-17-91  GDP   Initial version (ported from assembly)
*       11-15-93  GJF   Merged in NT SDK verions. Replaced MIPS and _ALPHA_
*                       by _M_MRX000 and _M_ALPHA (resp.).
*       10-02-94  BWT   PPC changes
*       07-15-96  GJF   Added parantheses to fix precedence problem in expr.
*                       Also, detab-ed.
*
*******************************************************************************/

#include <COMFloat.h>
#include <COMcv.h>

extern _LDBL12 _pow10pos[];
extern _LDBL12 _pow10neg[];




/***
*void _CALLTYPE5 __Wld12mul(_LDBL12 *px, _LDBL12 *py) -
*   _LDBL12 multiplication
*
*Purpose: multiply two _LDBL12 numbers
*
*Entry: px,py: pointers to the _LDBL12 operands
*
*Exit: *px contains the product
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __Wld12mul(_LDBL12 *px, _LDBL12 *py)
{
    u_short sign = 0;
    _LDBL12 tempman; /*this is actually a 12-byte mantissa,
                         not a 12-byte long double */
    int i;
    u_short expx, expy, expsum;
    int roffs,poffs,qoffs;
    int sticky = 0;

    *UL_LO_12(&tempman) = 0;
    *UL_MED_12(&tempman) = 0;
    *UL_HI_12(&tempman) = 0;

    expx = *U_EXP_12(px);
    expy = *U_EXP_12(py);

    sign = (expx ^ expy) & (u_short)0x8000;
    expx &= 0x7fff;
    expy &= 0x7fff;
    expsum = expx+expy;
    if (expx >= LD_MAXEXP
        || expy >= LD_MAXEXP
        || expsum > LD_MAXEXP+ LD_BIASM1){
        /* overflow to infinity */
        PUT_INF_12(px,sign);
        return;
    }
    if (expsum <= LD_BIASM1-63) {
        /* underflow to zero */
        PUT_ZERO_12(px);
        return;
    }
    if (expx == 0) {
        /*
         * If this is a denormal temp real then the mantissa
         * was shifted right once to set bit 63 to zero.
         */
        expsum++; /* Correct for this */
        if (ISZERO_12(px)) {
            /* put positive sign */
            *U_EXP_12(px) = 0;
            return;
        }
    }
    if (expy == 0) {
        expsum++; /* because arg2 is denormal */
        if (ISZERO_12(py)) {
            PUT_ZERO_12(px);
            return;
        }
    }

    roffs = 0;
    for (i=0;i<5;i++) {
        int j;
        poffs = i<<1;
        qoffs = 8;
        for (j=5-i;j>0;j--) {
	    u_long prod;
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
            /* a variable to hold temprary sums */
            u_long sum;
#endif
            int carry;
            u_short *p, *q;
            u_long *r;
            p = USHORT_12(px,poffs);
            q = USHORT_12(py,qoffs);
            r = ULONG_12(&tempman,roffs);
            prod = (u_long)*p * (u_long)*q;
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
            /* handle misalignment problems */
            if (i&0x1){ /* i is odd */
                carry = __Waddl(*ALIGN(r), prod, &sum);
                *ALIGN(r) =  sum;
            }
            else /* i is even */
                carry = __Waddl(*r, prod, r);
#else
            carry = __Waddl(*r,prod,r);
#endif
            if (carry) {
                /* roffs should be less than 8 in this case */
                (*USHORT_12(&tempman,roffs+4))++;
            }
            poffs+=2;
            qoffs-=2;
        }
        roffs+=2;
    }

    expsum -= LD_BIASM1;

    /* normalize */
    while ((s_short)expsum > 0 &&
           ((*UL_HI_12(&tempman) & MSB_ULONG) == 0)) {
         __Wshl_12(&tempman);
         expsum--;
    }

    if ((s_short)expsum <= 0) {
        expsum--;
        while ((s_short)expsum < 0) {
            if (*U_XT_12(&tempman) & 0x1)
                sticky++;
            __Wshr_12(&tempman);
            expsum++;
        }
        if (sticky)
            *U_XT_12(&tempman) |= 0x1;
    }

    if (*U_XT_12(&tempman) > 0x8000 ||
         ((*UL_LO_12(&tempman) & 0x1ffff) == 0x18000)) {
        /* round up */
        if (*UL_MANLO_12(&tempman) == MAX_ULONG) {
            *UL_MANLO_12(&tempman) = 0;
            if (*UL_MANHI_12(&tempman) == MAX_ULONG) {
                *UL_MANHI_12(&tempman) = 0;
                if (*U_EXP_12(&tempman) == MAX_USHORT) {
                    /* 12-byte mantissa overflow */
                    *U_EXP_12(&tempman) = MSB_USHORT;
                    expsum++;
                }
                else
                    (*U_EXP_12(&tempman))++;
            }
            else
                (*UL_MANHI_12(&tempman))++;
        }
        else
            (*UL_MANLO_12(&tempman))++;
    }


    /* check for exponent overflow */
    if (expsum >= 0x7fff){
        PUT_INF_12(px, sign);
        return;
    }

    /* put result in px */
    *U_XT_12(px) = *USHORT_12(&tempman,2);
    *UL_MANLO_12(px) = *UL_MED_12(&tempman);
    *UL_MANHI_12(px) = *UL_HI_12(&tempman);
    *U_EXP_12(px) = expsum | sign;
}



void _CALLTYPE5
__Wmulttenpow12(_LDBL12 *pld12, int pow, unsigned mult12)
{
    _LDBL12 *pow_10p = _pow10pos-8;
    if (pow == 0)
        return;
    if (pow < 0) {
        pow = -pow;
        pow_10p = _pow10neg-8;
    }

    if (!mult12)
        *U_XT_12(pld12) = 0;


    while (pow) {
        int last3; /* the 3 LSBits of pow */
        _LDBL12 unround;
        _LDBL12 *py;

        pow_10p += 7;
        last3 = pow & 0x7;
        pow >>= 3;
        if (last3 == 0)
            continue;
        py = pow_10p + last3;

#ifdef _LDSUPPORT
        if (mult12) {
#endif
            /* do an exact 12byte multiplication */
            if (*U_XT_12(py) >= 0x8000) {
                /* copy number */
                unround = *py;
                /* unround adjacent byte */
                (*UL_MANLO_12(&unround))--;
                /* point to new operand */
                py = &unround;
            }
            __Wld12mul(pld12,py);
#ifdef _LDSUPPORT
        }
        else {
            /* do a 10byte multiplication */
            py = (_LDBL12 *)TEN_BYTE_PART(py);
            *(long double *)TEN_BYTE_PART(pld12) *=
                *(long double *)py;
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\nlsint.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*nlsint.h - national language support internal defintions
*
*Purpose:
*       Contains internal definitions/declarations for international functions,
*       shared between run-time and math libraries, in particular,
*       the localized decimal point.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_NLSINT
#define _INC_NLSINT

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

/*
 *  Definitions for a localized decimal point.
 *  Currently, run-times only support a single character decimal point.
 */
#define ___decimal_point                __decimal_point
extern wchar_t __decimal_point[];          /* localized decimal point string */

#define ___decimal_point_length         __decimal_point_length
extern size_t __decimal_point_length;   /* not including terminating null */

#define _ISDECIMAL(p)   (*(p) == *___decimal_point)
#define _PUTDECIMAL(p)  (*(p)++ = *___decimal_point)
#define _PREPUTDECIMAL(p)       (*(++p) = *___decimal_point)

#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif  /* _INC_NLSINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\x10fout.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*x10fout.c - floating point output for 10-byte long double
*
*Purpose:
*   Support conversion of a long double into a string
*
*Revision History:
*   07/15/91	GDP	Initial version in C (ported from assembly)
*   01/23/92	GDP	Support MIPS encoding for NaN
*
*******************************************************************************/

#include <string.h>
#include <COMcv.h>
#include <WinWrap.h>

#define STRCPY lstrcpyW

#define PUT_ZERO_FOS(fos)	 \
		fos->exp = 0,	 \
		fos->sign = ' ', \
		fos->ManLen = 1, \
		fos->man[0] = '0',\
		fos->man[1] = 0;

#define SNAN_STR      L"1#SNAN"
#define SNAN_STR_LEN  6
#define QNAN_STR      L"1#QNAN"
#define QNAN_STR_LEN  6
#define INF_STR	      L"1#INF"
#define INF_STR_LEN   5
#define IND_STR	      L"1#IND"
#define IND_STR_LEN   5


/***
*int _CALLTYPE5
* _$i10_output(_LDOUBLE ld,
*	    int ndigits,
*	    unsigned output_flags,
*	    FOS *fos) - output conversion of a 10-byte _LDOUBLE
*
*Purpose:
*   Fill in a FOS structure for a given _LDOUBLE
*
*Entry:
*   _LDOUBLE ld:  The long double to be converted into a string
*   int ndigits: number of digits allowed in the output format.
*   unsigned output_flags: The following flags can be used:
*	SO_FFORMAT: Indicates 'f' format
*	(default is 'e' format)
*   FOS *fos: the structure that i10_output will fill in
*
*Exit:
*   modifies *fos
*   return 1 if original number was ok, 0 otherwise (infinity, NaN, etc)
*
*Exceptions:
*
*******************************************************************************/


int _CALLTYPE5 $WI10_OUTPUT(_LDOUBLE ld, int ndigits,
		    unsigned output_flags, FOS *fos)
{
    u_short expn;
    u_long manhi,manlo;
    u_short sign;

    /* useful constants (see algorithm explanation below) */
    u_short const log2hi = 0x4d10;
    u_short const log2lo = 0x4d;
    u_short const log4hi = 0x9a;
    u_long const c = 0x134312f4;
#if defined(L_END)
    _LDBL12 ld12_one_tenth = {
	   {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xfb,0x3f}
    };
#elif defined(B_END)
    _LDBL12 ld12_one_tenth = {
	   {0x3f,0xfb,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xcc,0xcc}
    };
#endif

    _LDBL12 ld12; /* space for a 12-byte long double */
    _LDBL12 tmp12;
    u_short hh,ll; /* the bytes of the exponent grouped in 2 words*/
    u_short mm; /* the two MSBytes of the mantissa */
    s_long r; /* the corresponding power of 10 */
    s_short ir; /* ir = floor(r) */
    int retval = 1; /* assume valid number */
    WCHAR round; /* an additional character at the end of the string */
    WCHAR *p;
    int i;
    int ub_exp;
    int digcount;

    /* grab the components of the long double */
    expn = *U_EXP_LD(&ld);
    manhi = *UL_MANHI_LD(&ld);
    manlo = *UL_MANLO_LD(&ld);
    sign = expn & MSB_USHORT;
    expn &= 0x7fff;

    if (sign)
	fos->sign = '-';
    else
	fos->sign = ' ';

    if (expn==0 && manhi==0 && manlo==0) {
	PUT_ZERO_FOS(fos);
	return 1;
    }

    if (expn == 0x7fff) {
	fos->exp = 1; /* set a positive exponent for proper output */

	/* check for special cases */
	if (_IS_MAN_SNAN(sign, manhi, manlo)) {
	    /* signaling NAN */
	    STRCPY(fos->man,SNAN_STR);
	    fos->ManLen = SNAN_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_IND(sign, manhi, manlo)) {
	    /* indefinite */
	    STRCPY(fos->man,IND_STR);
	    fos->ManLen = IND_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_INF(sign, manhi, manlo)) {
	    /* infinity */
	    STRCPY(fos->man,INF_STR);
	    fos->ManLen = INF_STR_LEN;
	    retval = 0;
	}
	else {
	    /* quiet NAN */
	    STRCPY(fos->man,QNAN_STR);
	    fos->ManLen = QNAN_STR_LEN;
	    retval = 0;
	}
    }
    else {
       /*
	*    Algorithm for the decoding of a valid real number x
	*
	* In the  following  INT(r)  is	the largest integer less than or
	* equal to r (i.e. r rounded toward -infinity).	We want a result
	* r equal  to  1  + log(x), because then x = mantissa
	* * 10^(INT(r)) so that	.1  <=	mantissa  <  1.   Unfortunately,
	* we cannot  compute  s	exactly  so  we must alter the procedure
	* slightly.  We will  instead  compute	an  estimate  r	of  1  +
	* log(x) which	is  always  low.   This	will either result
	* in the correctly normalized number on	the  top  of  the  stack
	* or perhaps  a	number	which  is  a factor of 10 too large.  We
	* will then check to see that if  x  is	larger	 than  one
	* and if so multiply x by 1/10.
	*
	* We will  use	a  low	precision  (fixed  point 24 bit) estimate
	* of of 1 + log base 10 of x.  We  have	approximately  .mm
	* * 2^hhll  on	the  top of the stack where m, h, and l represent
	* hex digits,  mm  represents  the  high  2  hex  digits  of  the
	* mantissa, hh	represents the high 2 hex digits of the exponent,
	* and ll represents the low 2 hex digits of the exponent.   Since
	* .mm is  a  truncated	representation	of the mantissa, using it
	* in this  monotonically  increasing   polynomial   approximation
	* of the  logarithm  will  naturally  give  a  low result.  Let's
	* derive a formula for a lower	bound  r  on  1	+  log(x):
	*
	*      .4D104D42H < log(2)=.30102999...(base 10) < .4D104D43H
	*	  .9A20H < log(4)=.60205999...(base 10) < .9A21H
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) >= .mm * log(4) - log(4)
	*
	* Substituting in  truncated  hex  constants in the formula above
	* gives r = 1 + .4D104DH * hhll.  + .9AH *  .mm	-  .9A21H.   Now
	* multiplication of  hex  digits  5  and 6 of log(2) by ll has an
	* insignificant effect on the first 24	bits  of  the  result  so
	* it will  not	be  calculated.	 This  gives  the expression r =
	* 1 + .4D10H * hhll.  +	.4DH  *  .hh  +  .9A  *  .mm  -  .9A21H.
	* Finally we  must  add	terms to our formula to subtract out the
	* effect of the exponent bias.	We obtain the following	formula:
	*
	*			(implied decimal point)
	*   <				  >.<				   >
	*   |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
	*   |1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
	* + <		  1		  >
	* + <			    .4D10H * hhll.			   >
	* +				    <	    .00004DH * hh00.	   >
	* +				    <	       .9AH * .mm	   >
	* -				    <		 .9A21H 	   >
	* - <			    .4D10H * 3FFEH			   >
	* -				    <	    .00004DH * 3F00H	   >
	*
	*  ==>	r = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.12F4H
	*
	* The difference  between  the	lower bound r and the upper bound
	* s is calculated as follows:
	*
	*  .937EH < 1/ln(10)-log(1/ln(4))=.57614993...(base 10) < .937FH
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) <= .mm * log(4) - [1/ln(10) - log(1/ln(4))]
	*
	* so tenatively	s  =  r  +  log(4)  - [1/ln(10) - log(1/ln(4))],
	* but we must also add in terms to ensure we will have	an  upper
	* bound even  after  the  truncation  of various values.  Because
	* log(2) * hh00.  is truncated	to  .4D104DH  *	hh00.	we  must
	* add .0043H,  because	log(2)	*  ll.	is truncated to .4D10H *
	* ll.  we  must	add  .0005H,  because  <mantissa>  *  log(4)  is
	* truncated to .mm * .9AH we must add .009AH and .0021H.
	*
	* Thus s = r - .937EH + .9A21H + .0043H + .0005H + .009AH + .0021H
	*	= r + .07A6H
	*  ==>	s = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.0B4EH
	*
	* r is	equal  to  1  +	log(x) more than (10000H - 7A6H) /
	* 10000H = 97% of the time.
	*
	* In the above formula, a u_long is use to accomodate r, and
	* there is an implied decimal point in the middle.
	*/

	hh = expn >> 8;
	ll = expn & (u_short)0xff;
	mm = (u_short) (manhi >> 24);
	r = (s_long)log2hi*(s_long)expn + log2lo*hh + log4hi*mm - c;
	ir = (s_short)(r >> 16);

       /*
	*
	* We stated that we wanted to normalize x so that
	*
	*  .1 <= x < 1
	*
	* This was	a  slight  oversimplification.	 Actually  we  want a
	* number which when rounded to 16 significant digits  is  in  the
	* desired range.   To  do  this we must normalize x so that
	*
	*  .1 - 5*10^(-18) <= x < 1 - 5*10^(-17)
	*
	* and then round.
	*
	* If we  had f = INT(1+log(x)) we could multiply by 10^(-f)
	* to get x into the desired range.	We do  not  quite  have
	* f but  we  do  have  INT(r)  from  the last step which is equal
	* to f 97% of the time and 1 less than f the rest  of  the	time.
	* We can  multiply	by  10^-[INT(r)] and if the result is greater
	* than 1 - 5*10^(-17) we can then multiply by 1/10.   This	final
	* result will lie in the proper range.
	*/

	/* convert _LDOUBLE to _LDBL12) */
	*U_EXP_12(&ld12) = expn;
	*UL_MANHI_12(&ld12) = manhi;
	*UL_MANLO_12(&ld12) = manlo;
	*U_XT_12(&ld12) = 0;

	/* multiply by 10^(-ir) */
	__Wmulttenpow12(&ld12,-ir,1);

	/* if ld12 >= 1.0 then divide by 10.0 */
	if (*U_EXP_12(&ld12) >= 0x3fff) {
	    ir++;
	    __Wld12mul(&ld12,&ld12_one_tenth);
	}

	fos->exp = ir;
	if (output_flags & SO_FFORMAT){
	    /* 'f' format, add exponent to ndigits */
	    ndigits += ir;
	    if (ndigits <= 0) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	if (ndigits > MAX_MAN_DIGITS)
	    ndigits = MAX_MAN_DIGITS;

	ub_exp = *U_EXP_12(&ld12) - 0x3ffe; /* unbias exponent */
	*U_EXP_12(&ld12) = 0;

	/*
	 * Now the mantissa has to be converted to fixed point.
	 * Then we will use the MSB of ld12 for generating
	 * the decimal digits. The next 11 bytes will hold
	 * the mantissa (after it has been converted to
	 * fixed point).
	 */

	for (i=0;i<8;i++)
	    __Wshl_12(&ld12); /* make space for an extra byte,
			      in case we shift right later */
	if (ub_exp < 0) {
	    int shift_count = (-ub_exp) & 0xff;
	    for (;shift_count>0;shift_count--)
		__Wshr_12(&ld12);
	}

	p = fos->man;
	for(digcount=ndigits+1;digcount>0;digcount--) {
	    tmp12 = ld12;
	    __Wshl_12(&ld12);
	    __Wshl_12(&ld12);
	    __Wadd_12(&ld12,&tmp12);
	    __Wshl_12(&ld12);	/* ld12 *= 10 */

	    /* Now we have the first decimal digit in the msbyte of exponent */
	    *p++ = (char) (*UCHAR_12(&ld12,11) + '0');
	    *UCHAR_12(&ld12,11) = 0;
	}

	round = *(--p);
	p--; /* p points now to the last character of the string
		   excluding the rounding digit */
	if (round >= '5') {
	    /* look for a non-9 digit starting from the end of string */
	    for (;p>=fos->man && *p=='9';p--) {
		*p = '0';
	    }
	    if (p < fos->man){
		p++;
		fos->exp ++;
	    }
	    (*p)++;
	}
	else {
	    /* remove zeros */
	    for (;p>=fos->man && *p=='0';p--);
	    if (p < fos->man) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	fos->ManLen = (char) (p - fos->man + 1);
	fos->man[fos->ManLen] = '\0';
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\inc\comnls.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Module:   COMNLS
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This module defines the common header information for
//            the Globalization classes.
//
//  Date:     August 12, 1998
//
////////////////////////////////////////////////////////////////////////////


#ifndef _COMNLS_H
#define _COMNLS_H


//
//  Constant Declarations.
//

#define LCID_ENGLISH_US 0x0409

#define ASSERT_API(Win32API)  \
    if ((Win32API) == 0)      \
        FATAL_EE_ERROR();

#define ASSERT_ARGS(pargs)    \
    ASSERT((pargs) != NULL);  \


////////////////////////////////////////////////////////////////////////////
//
//  internalGetField
//
////////////////////////////////////////////////////////////////////////////

template<class T>
inline T internalGetField(OBJECTREF pObjRef, char* szArrayName, HardCodedMetaSig* Sig)
{
    ASSERT((pObjRef != NULL) && (szArrayName != NULL) && (Sig != NULL));

    THROWSCOMPLUSEXCEPTION();

    FieldDesc* pFD = pObjRef->GetClass()->FindField(szArrayName, Sig);
    if (pFD == NULL)
    {
        ASSERT(FALSE);
        FATAL_EE_ERROR();
    }

    // TODO: Win64: cast (INT64).
    T dataArrayRef = (T)Int64ToObj((INT64)pFD->GetValue32(pObjRef));
    return (dataArrayRef);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\float\_fptostr.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
*_Wfptostr.c - workhorse routine for converting floating point to string
*
*Purpose:
*       Workhorse routine for fcvt, ecvt.
*
*******************************************************************************/

#include <windows.h>
#include <COMFloat.h>
#include <string.h>
#include <COMFLTINTRN.h>
#include <crtwrap.h>

/***
*void _Wfptostr(buf, digits, pflt) - workhorse floating point conversion
*
*Purpose:
*       This is the workhorse routine for fcvt, ecvt. Here is where
*       all the digits are put into a buffer and the rounding is
*       performed and indicators of the decimal point position are set. Note,
*       this must not change the mantissa field of pflt since routines which
*       use this routine rely on this being unchanged.
*
*Entry:
*       char *buf - the buffer in which the digits are to be put
*       int digits - the number of digits which are to go into the buffer
*       STRFLT pflt - a pointer to a structure containing information on the
*               floating point value, including a string containing the
*               non-zero significant digits of the mantissa.
*
*Exit:
*       Changes the contents of the buffer and also may increment the decpt
*       field of the structure pointer to by the 'pflt' parameter if overflow
*       occurs during rounding (e.g. 9.999999... gets rounded to 10.000...).
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _Wfptostr (
        WCHAR *buf,
        REG4 int digits,
        REG3 STRFLT pflt
        )
{
        REG1 WCHAR *pbuf = buf;
        REG2 WCHAR *mantissa = pflt->mantissa;

        /* initialize the first digit in the buffer to '0' (NOTE - NOT '\0')
         * and set the pointer to the second digit of the buffer.  The first
         * digit is used to handle overflow on rounding (e.g. 9.9999...
         * becomes 10.000...) which requires a carry into the first digit.
         */

        *pbuf++ = '0';

        /* Copy the digits of the value into the buffer (with 0 padding)
         * and insert the terminating null character.
         */

        while (digits > 0) {
                *pbuf++ = (*mantissa) ? *mantissa++ : (WCHAR)'0';
                digits--;
        }
        *pbuf = '\0';

        /* do any rounding which may be needed.  Note - if digits < 0 don't
         * do any rounding since in this case, the rounding occurs in  a digit
         * which will not be output beause of the precision requested
         */

        if (digits >= 0 && *mantissa >= '5') {
                pbuf--;
                while (*pbuf == '9')
                        *pbuf-- = '0';
                *pbuf += 1;
        }

        if (*buf == '1') {
                /* the rounding caused overflow into the leading digit (e.g.
                 * 9.999.. went to 10.000...), so increment the decpt position
                 * by 1
                 */
                pflt->decpt++;
        }
        else {
                /* move the entire string to the left one digit to remove the
                 * unused overflow digit.
                 */
            //lstrcpyW is a no-op under W95.
            //lstrcpyW(buf, buf+1);
            wcscpy(buf, buf+1);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\inc\nlstable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _NLSTABLE_H
#define _NLSTABLE_H

////////////////////////////////////////////////////////////////////////////
//
//  Class:    NLSTable
//
//  Authors:  Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  The base class for NLS+ table.  This class provides the utility
//            functions to open and map a view of NLS+ data files.
//
//  Date: 	  August 31, 1999
//
////////////////////////////////////////////////////////////////////////////

typedef  LPWORD        P844_TABLE;     // ptr to 8:4:4 table

//
//  Macros For High and Low Nibbles of a BYTE.
//
#define LO_NIBBLE(b)              ((BYTE)((BYTE)(b) & 0xF))
#define HI_NIBBLE(b)              ((BYTE)(((BYTE)(b) >> 4) & 0xF))

//
//  Macros for Extracting the 8:4:4 Index Values.
//
#define GET8(w)                   (HIBYTE(w))
#define GETHI4(w)                 (HI_NIBBLE(LOBYTE(w)))
#define GETLO4(w)                 (LO_NIBBLE(LOBYTE(w)))

////////////////////////////////////////////////////////////////////////////
//
//  Traverse844Byte
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  returns the final value of the 8:4:4 table, which is a BYTE in length.
//
//  NOTE: Offsets in table are in BYTES.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)] / sizeof(WORD);
//        Incr = pTable[Incr + GETHI4(wch)];
//        Value = (BYTE *)pTable[Incr + GETLO4(wch)];
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

inline BYTE& Traverse844Byte(LPWORD pTable, WCHAR wch)                                        
{
    return ( 
             ((BYTE *)pTable)[
                pTable[ 
                   (pTable[GET8(wch)] / sizeof(WORD)) + GETHI4(wch)
                ] + GETLO4(wch)
             ]
           );
}

////////////////////////////////////////////////////////////////////////////
//
//  Traverse844Word
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  returns the final value of the 8:4:4 table, which is a WORD in length.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)];
//        Incr = pTable[Incr + GETHI4(wch)];
//        Value = pTable[Incr + GETLO4(wch)];
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

inline WORD& Traverse844Word(LPWORD pTable, WCHAR wch)
{
    return (pTable[pTable[pTable[GET8(wch)] + GETHI4(wch)] + GETLO4(wch)]);
}

////////////////////////////////////////////////////////////////////////////
//
//  GET_INCR_VALUE
//
//  Gets the value of a given wide character from the given 8:4:4 table.  It
//  then uses the value as an increment by adding it to the given wide
//  character code point.
//
//  NOTE:  Whenever there is no translation for the given code point, the
//         tables will return an increment value of 0.  This way, the
//         wide character passed in is the same value that is returned.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

inline WCHAR GetIncrValue(LPWORD p844Tbl, WCHAR wch)
{
     return ((WCHAR)(wch + Traverse844Word(p844Tbl, wch)));
}

#ifdef _USE_MSCORNLP
    typedef LPBYTE GETTABLE(LPCWSTR);
#endif
class NLSTable
{
	public:
		NLSTable(Assembly* pAssembly);
		LPVOID MapDataFile(LPCWSTR pMappingName, LPCSTR pFileName, HANDLE *hFileMap);
		LPVOID MapDataFile(LPCWSTR pMappingName, LPCWSTR pFileName, HANDLE *hFileMap);		
        HANDLE CreateSharedFileMapping(HANDLE hFile, LPCWSTR pMappingName );
	protected:
		HANDLE OpenDataFile(LPCSTR pFileName);
        HANDLE OpenDataFile(LPCWSTR pFileName);        

		// Add this data member so that we can retrieve data table from the specified Assembly
		// in the ctor.
        //NB (vNext): What happens if this assembly is unloaded?
		Assembly* m_pAssembly;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\inc\comfloatclass.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COMFLOATCLASS_H
#define _COMFLOATCLASS_H

#include <basetsd.h>  // CHANGED, VC6.0
#include <object.h>
#include <fcall.h>


#define POSITIVE_INFINITY_POS 0
#define NEGATIVE_INFINITY_POS 1
#define NAN_POS 2

class COMFloat {

    static EEClass *FPInterfaceClass;
    static LPCUTF8 FPInterfaceName;
    static OBJECTHANDLE ReturnString[3];
    static LPCUTF8 ReturnStringNames[3];
    static INT32 StringToFloat(WCHAR *, const WCHAR **, float *);
    static STRINGREF FloatToString(float f,int,int);
public:
    typedef struct {
        DECLARE_ECALL_I4_ARG(I4,fmtType);
        DECLARE_ECALL_I4_ARG(I4,precision);
        DECLARE_ECALL_R4_ARG(R4, flt);
    } _toStringArgs;
    typedef struct {
		DECLARE_ECALL_I4_ARG(INT32, isTight); 
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, str);
	} _parseFloatArgs;
    void COMFloatingPointInitialize();
    static float __stdcall Parse(_parseFloatArgs *);
    static LPVOID __stdcall ToString(_toStringArgs *);
    static STRINGREF GetStringFromClass(int);

    FCDECL1(static INT32, IsNAN, float d);
    FCDECL1(static INT32, IsInfinity, float d);
    FCDECL1(static INT32, IsNegativeInfinity, float d);
    FCDECL1(static INT32, IsPositiveInfinity, float d);
};

class COMDouble {
    static STRINGREF DoubleToString(double d,int,int);
    static INT32 StringToDouble(WCHAR *, const WCHAR **, R8 *);
public:
    typedef struct {
        DECLARE_ECALL_I4_ARG(I4,fmtType);
        DECLARE_ECALL_I4_ARG(I4,precision);
        DECLARE_ECALL_R8_ARG(R8, dbl);
    } _toStringArgs;
    typedef struct {
		DECLARE_ECALL_R4_ARG(INT32, isTight); 
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, str);
	} _parseDoubleArgs;

    static double __stdcall Parse(_parseDoubleArgs *);
    static LPVOID __stdcall ToString(_toStringArgs *);

    FCDECL1(static INT32, IsNAN, double d);
    FCDECL1(static INT32, IsInfinity, double d);
    FCDECL1(static INT32, IsNegativeInfinity, double d);
    FCDECL1(static INT32, IsPositiveInfinity, double d);

    FCDECL1(static R8, Floor, double d);
    FCDECL1(static R8, Sqrt, double d);
    FCDECL1(static R8, Log, double d);
    FCDECL1(static R8, Log10, double d);
    FCDECL1(static R8, Exp, double d);
    FCDECL2_RR(static R8, Pow, double x, double y);
    FCDECL1(static R8, Acos, double d);
    FCDECL1(static R8, Asin, double d);
    FCDECL1(static R8, Atan, double d);
    FCDECL2_RR(static R8, Atan2, double x, double y);
    FCDECL1(static R8, Cos, double d);
    FCDECL1(static R8, Sin, double d);
    FCDECL1(static R8, Tan, double d);
	FCDECL1(static R8, Cosh, double d);
    FCDECL1(static R8, Sinh, double d);
    FCDECL1(static R8, Tanh, double d);
    FCDECL1(static R8, Round, double d);
    FCDECL1(static R8, Ceil, double d);
    FCDECL1(static R4, AbsFlt, float f);
    FCDECL1(static R8, AbsDbl, double d);
    FCDECL2(static R8, RoundDigits, double dblIn,int cDecimals);
    FCDECL2_RR(static R8, IEEERemainder, double x, double y);

private:
    FCDECL2_RR(static R8, PowHelper, double x, double y);

};
    

#endif  _COMFLOATCLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\baseinfotable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __BASE_INFO_TABLE
#define __BASE_INFO_TABLE

struct CultureInfoHeader;
struct IDOffsetItem;

class BaseInfoTable : public NLSTable {
    public:
        BaseInfoTable(Assembly* pAssembly);
        virtual int  GetDataItem(int cultureID);
        //int  GetDataItem(LPWSTR name);

        INT32  GetInt32Data(int dataItem, int field, BOOL useUserOverride);
        INT32  GetDefaultInt32Data(int dataItem, int field);
        
        LPWSTR GetStringData(int dataItem, int field, BOOL userUserOverride, LPWSTR buffer, int bufferSize);
        LPWSTR GetDefaultStringData(int dataItem, int field);
        
        CultureInfoHeader*  GetHeader();
        NameOffsetItem* GetNameOffsetTable();
        LPWSTR          GetStringPoolTable();

    protected:
        void InitDataTable(LPCWSTR lpMappingName, LPCSTR lpwFileName, HANDLE& hHandle);
        void UninitDataTable();

        virtual int GetDataItemCultureID(int dataItem) = 0; 

        // BUGBUG YSLin: I should rename the managed side from Int16 to Int32 as well.
        virtual BOOL   GetUserInfoInt32(int field, LPCWSTR lpwRegName, INT32* pInt32DataValue);
        virtual BOOL   GetUserInfoString(int field, LPCWSTR lpwRegName, LPWSTR* buffer, INT32 bufferSize);
        virtual INT32  ConvertWin32FormatInt32(int field, int win32Value);
        virtual LPWSTR ConvertWin32FormatString(int field, LPWSTR pInfoStr);

    protected:
        CRITICAL_SECTION  m_ProtectCache;

        LPWORD        m_pBasePtr;
        HANDLE        m_hBaseHandle;

        //
        // Pointers to different parts of the table.
        //
        CultureInfoHeader* m_pHeader;
        LPWORD          m_pWordRegistryTable;
        LPWORD          m_pStringRegistryTable;
        IDOffsetItem*   m_pIDOffsetTable;
        NameOffsetItem* m_pNameOffsetTable;
        LPWORD          m_pDataTable;
        LPWSTR          m_pStringPool;

        // 
        // The size (in words) of every record in Culture Data Table.
        int m_dataItemSize;
};

struct IDOffsetItem {
    WORD dataItemIndex;        // Index to a record in Culture Data Table.
    WORD numSubLang;        // Number of sub-languages for this primary language.
};

//  User Info
#define NLS_CTRL_PANEL_KEY         L"Control Panel\\International"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\inc\comnlsinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    COMNlsInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This module defines the methods of the COMNlsInfo
//            class.  These methods are the helper functions for the
//            managed NLS+ classes.
//
//  Date:     August 12, 1998
//
////////////////////////////////////////////////////////////////////////////

#ifndef _COMNLSINFO_H
#define _COMNLSINFO_H

#ifndef _MLANG_INCLUDED
#define _MLANG_INCLUDED
#include <mlang.h>
#endif
//
//
//
//struct NLSDataItem
//{
//    WCHAR*  pName;
//    int     lcid;
//    WCHAR*  pISO639_1;
//    WCHAR*  pISO3166_1;
//    int     nRegionIndex;
//};
//
//struct CollisionItem
//{
//    WCHAR* pName;
//    int    nIndex;
//};

//
//This structure must map 1-for-1 with the InternalDataItem structure in 
//System.Globalization.EncodingTable.
//
struct EncodingDataItem {
    WCHAR* webName;
    int    codePage;
};

//
//This structure must map 1-for-1 with the InternalCodePageDataItem structure in 
//System.Globalization.EncodingTable.
//
struct CodePageDataItem {
    int    codePage;
    int    uiFamilyCodePage;
    WCHAR* webName;
    WCHAR* headerName;
    WCHAR* bodyName;
    DWORD dwFlags;
};

//
//This structure must map 1-for-1 with the NameOffsetItem structure in 
//System.Globalization.CultureTable.
//
struct NameOffsetItem {
	WORD 	strOffset;		// Offset (in words) to a string in the String Pool Table.
	WORD	dataItemIndex;	// Index to a record in Culture Data Table.
};

//
// This is the header for BaseInfoTable/CultureInfoTable/RegionInfoTable
//
//
//This structure must map 1-for-1 with the CultureInfoHeader structure in 
//System.Globalization.CultureTable.
//
struct CultureInfoHeader {
	DWORD 	version;		// version
	WORD	hashID[8];		// 128 bit hash ID
	WORD	numCultures;	// Number of cultures
	WORD 	maxPrimaryLang;	// Max number of primary language
	WORD	numWordFields;	// Number of WORD value fields.
	WORD	numStrFields;	// Number of string value fields.
	WORD    numWordRegistry;    // Number of registry entries for WORD values.
	WORD    numStringRegistry;  // Number of registry entries for String values.
	DWORD   wordRegistryOffset; // Offset (in bytes) to WORD Registry Offset Table.
	DWORD   stringRegistryOffset;   // Offset (in bytes) to String Registry Offset Table.
	DWORD	IDTableOffset;	// Offset (in bytes) to Culture ID Offset Table.
	DWORD	nameTableOffset;// Offset (in bytes) to Name Offset Table.
	DWORD	dataTableOffset;// Offset (in bytes) to Culture Data Table.
	DWORD	stringPoolOffset;// Offset (in bytes) to String Pool Table.
};

//
//  Proc Definition for Code Page DLL Routine.
//
typedef DWORD (*PFN_CP_PROC)(DWORD, DWORD, LPSTR, int, LPWSTR, int, LPCPINFO);

typedef DWORD (*PFN_GB18030_BYTES_TO_UNICODE)(
    BYTE* lpMultiByteStr,
    UINT cchMultiByte,
    UINT* pcchLeftOverBytes,
    LPWSTR lpWideCharStr,
    UINT cchWideChar);
    
typedef DWORD (*PFN_GB18030_UNICODE_TO_BYTES)(
    LPWSTR lpWideCharStr,
    UINT cchWideChar,
    LPSTR lpMultiByteStr,
    UINT cchMultiByte);    


////////////////////////////////////////////////////////////////////////////
//
// Forward declaration
//
////////////////////////////////////////////////////////////////////////////

class CharTypeTable;
class CasingTable;
class SortingTable;

class COMNlsInfo {
public:
    static BOOL InitializeNLS();
#ifdef SHOULD_WE_CLEANUP
    static BOOL ShutdownNLS();
#endif /* SHOULD_WE_CLEANUP */


private:

    //
    // NOTENOTE
    // WHEN ECALL IS USED, THE PARAMETERS IN THE STRUCTURE
    // SHOULD BE DEFINED IN REVERSED ORDER.
    //
    struct VoidArgs
    {
    };

    struct Int32Arg
    {
        DECLARE_ECALL_I4_ARG(INT32, nValue);
    };

    struct Int32Int32Arg
    {
        DECLARE_ECALL_I4_ARG(INT32, nValue2);
        DECLARE_ECALL_I4_ARG(INT32, nValue1);
    };

    struct CultureInfo_GetLocaleInfoArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, LCType);
        DECLARE_ECALL_I4_ARG(INT32, LangID);
    };

    struct CultureInfo_GetCultureInfoArgs3
    {
        DECLARE_ECALL_I4_ARG(BOOL, UseUserOverride);
        DECLARE_ECALL_I4_ARG(INT32, ValueField);
        DECLARE_ECALL_I4_ARG(INT32, CultureDataItem);
    };

    struct CultureInfo_GetCultureInfoArgs2
    {
        DECLARE_ECALL_I4_ARG(INT32, ValueField);
        DECLARE_ECALL_I4_ARG(INT32, CultureDataItem);
    };

    struct TextInfo_ToLowerCharArgs
    {
        DECLARE_ECALL_I2_ARG(WCHAR, ch);
        DECLARE_ECALL_I4_ARG(INT32, CultureID);
    };

    struct TextInfo_ToLowerStringArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pValueStrRef);
        DECLARE_ECALL_I4_ARG(INT32, CultureID);
    };


    struct CompareInfo_CompareStringArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString2);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString1);
        DECLARE_ECALL_I4_ARG(INT32, LCID);
        DECLARE_ECALL_I4_ARG(INT_PTR, pNativeCompareInfo);
    };

    struct CompareInfo_CompareRegionArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_I4_ARG(INT32, Length2);
        DECLARE_ECALL_I4_ARG(INT32, Offset2);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString2);
        DECLARE_ECALL_I4_ARG(INT32, Length1);
        DECLARE_ECALL_I4_ARG(INT32, Offset1);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString1);
        DECLARE_ECALL_I4_ARG(INT32, LCID);
        DECLARE_ECALL_I4_ARG(INT_PTR, pNativeCompareInfo);
    };

    struct CompareInfo_IndexOfCharArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_I4_ARG(INT32, Count);
        DECLARE_ECALL_I4_ARG(INT32, StartIndex);
        DECLARE_ECALL_OBJECTREF_ARG(WCHAR, ch);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString);
        DECLARE_ECALL_I4_ARG(INT32, LCID);
        DECLARE_ECALL_I4_ARG(INT_PTR, pNativeCompareInfo);
    };

    struct CompareInfo_IndexOfStringArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_I4_ARG(INT32, Count);
        DECLARE_ECALL_I4_ARG(INT32, StartIndex);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString2);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString1);
        DECLARE_ECALL_I4_ARG(INT32, LCID);
        DECLARE_ECALL_I4_ARG(INT_PTR, pNativeCompareInfo);
    };

    struct SortKey_CreateSortKeyArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pThis);
        DECLARE_ECALL_I4_ARG(INT32, SortId);
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString);
        DECLARE_ECALL_I4_ARG(INT_PTR, pNativeCompareInfo);
    };

    struct SortKey_CompareArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pSortKey2);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pSortKey1);
    };

    struct CreateGlobalizationAssemblyArg {
        DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYREF, pAssembly);
    };

//	struct NLSDataTable_GetLCIDFromCultureNameArgs
//	{
//		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString);
//	};

public:
    static INT32  WstrToInteger4(LPWSTR wstrLocale, int Radix);
    static INT32  StrToInteger4(LPSTR strLocale, int Radix);

    //
    //  Native helper functions for methods in CultureInfo.
    //
    static FCDECL1(INT32, IsSupportedLCID, INT32);
    static FCDECL1(INT32, IsInstalledLCID, INT32);

    static FCDECL0(INT32, nativeGetUserDefaultLCID);

    static INT32 GetCHTLangauge();
    static INT32 CallGetSystemDefaultUILanguage();
    static INT32  __stdcall nativeGetUserDefaultUILanguage(VoidArgs*);
    static INT32  __stdcall nativeGetSystemDefaultUILanguage(VoidArgs*);

    //
    // Native helper functions for methods in DateTimeFormatInfo
    //
    static LPVOID __stdcall nativeGetLocaleInfo(CultureInfo_GetLocaleInfoArgs*);
    static INT32  __stdcall nativeGetLocaleInfoInt32(CultureInfo_GetLocaleInfoArgs*);

    static FCDECL2(INT32, GetCaseInsHash, LPVOID strA, void *pNativeTextInfoPtr);

    static VOID   __stdcall nativeInitCultureInfoTable(VoidArgs*);
    static FCDECL0(CultureInfoHeader*, nativeGetCultureInfoHeader);
    static FCDECL1(LPWSTR,  nativeGetCultureInfoStringPoolStr, INT32);
    static FCDECL0(NameOffsetItem*, nativeGetCultureInfoNameOffsetTable);
    
    static FCDECL1(INT32, nativeGetCultureDataFromID, INT32);
    static FCDECL3(INT32, GetCultureInt32Value, INT32, INT32, BOOL);
    static FCDECL2(INT32, GetCultureDefaultInt32Value, INT32, INT32);
    
    static LPVOID __stdcall GetCultureStringValue(CultureInfo_GetCultureInfoArgs3*);
    static LPVOID __stdcall GetCultureDefaultStringValue(CultureInfo_GetCultureInfoArgs2*);
    static LPVOID __stdcall GetCultureMultiStringValues(CultureInfo_GetCultureInfoArgs3* pArgs);

    static VOID   __stdcall nativeInitRegionInfoTable(VoidArgs*);
    static FCDECL0(CultureInfoHeader*, nativeGetRegionInfoHeader);
    static FCDECL1(LPWSTR,  nativeGetRegionInfoStringPoolStr, INT32);
    static FCDECL0(NameOffsetItem*, nativeGetRegionInfoNameOffsetTable);
    
    static FCDECL1(INT32, nativeGetRegionDataFromID, INT32);
    static INT32  __stdcall nativeGetRegionInt32Value(CultureInfo_GetCultureInfoArgs3*);
    static LPVOID __stdcall nativeGetRegionStringValue(CultureInfo_GetCultureInfoArgs3*);

    static VOID   __stdcall nativeInitCalendarTable(VoidArgs*);
    static INT32  __stdcall nativeGetCalendarInt32Value(CultureInfo_GetCultureInfoArgs3*);
    static LPVOID __stdcall nativeGetCalendarStringValue(CultureInfo_GetCultureInfoArgs3*);
    static LPVOID __stdcall nativeGetCalendarMultiStringValues(CultureInfo_GetCultureInfoArgs3* pArgs);
    static LPVOID __stdcall nativeGetEraName(Int32Int32Arg* pArgs);
    
    static FCDECL0(CultureInfoHeader*, nativeGetCalendarHeader);
    static FCDECL1(LPWSTR,  nativeGetCalendarStringPoolStr, INT32);
    
    

    static VOID __stdcall nativeInitUnicodeCatTable(VoidArgs* pArg);
    static FCDECL0(LPVOID, nativeGetUnicodeCatTable);
    static FCDECL0(LPVOID, nativeGetUnicodeCatLevel2Offset);
    static BYTE GetUnicodeCategory(WCHAR wch);
    static BOOL nativeIsWhiteSpace(WCHAR c);

    static FCDECL0(LPVOID, nativeGetNumericTable);
    static FCDECL0(LPVOID, nativeGetNumericLevel2Offset);
    static FCDECL0(LPVOID, nativeGetNumericFloatData);
    
    static FCDECL0(INT32, nativeGetThreadLocale);
    static FCDECL1(BOOL,  nativeSetThreadLocale, INT32 lcid);

    //
    //  Native helper functions for methods in CompareInfo.
    //
    static INT32  __stdcall Compare(CompareInfo_CompareStringArgs*);
    static INT32  __stdcall CompareRegion(CompareInfo_CompareRegionArgs*);
    static INT32  __stdcall IndexOfChar(CompareInfo_IndexOfCharArgs*);
    //static INT32  __stdcall IndexOfString(CompareInfo_IndexOfStringArgs*);
    static FCDECL7(INT32, IndexOfString,     INT_PTR pNativeCompareInfo, INT32 LCID, StringObject* pString1UNSAFE, StringObject* pString2UNSAFE, INT32 StartIndex, INT32 Count, INT32 dwFlags);
	static INT32  __stdcall LastIndexOfChar(CompareInfo_IndexOfCharArgs*);
    static INT32  __stdcall LastIndexOfString(CompareInfo_IndexOfStringArgs*);
    static FCDECL5(INT32, nativeIsPrefix, INT32 pNativeCompareInfo, INT32 LCID, STRINGREF pString1, STRINGREF pString2, INT32 dwFlags);
    static FCDECL5(INT32, nativeIsSuffix, INT32 pNativeCompareInfo, INT32 LCID, STRINGREF pString1, STRINGREF pString2, INT32 dwFlags);
    
    //
    //  Native helper functions for methods in SortKey.
    //
    static LPVOID __stdcall nativeCreateSortKey(SortKey_CreateSortKeyArgs*);
    static INT32  __stdcall SortKey_Compare(SortKey_CompareArgs*);

	//
	//  Native helper functions for methods in NLSDataTable
	//
    //	static INT32 __stdcall GetLCIDFromCultureName(NLSDataTable_GetLCIDFromCultureNameArgs* pargs);

    //
    //  Native helper function for methods in Calendar
    //
    static INT32 __stdcall nativeGetTwoDigitYearMax(Int32Arg*);

    //
    //  Native helper function for mehtods in TimeZone
    //
    static FCDECL0(LONG, nativeGetTimeZoneMinuteOffset);
    static LPVOID __stdcall nativeGetStandardName(VoidArgs*);
    static LPVOID __stdcall nativeGetDaylightName(VoidArgs*);
    static LPVOID __stdcall nativeGetDaylightChanges(VoidArgs*);
    
    //
    //  Native helper function for methods in TextInfo
    //

    //////////////////////////////////////////////////////
    // DELETE THIS WHEN WE USE NLSPLUS TABLE ONLY - BEGIN
    //////////////////////////////////////////////////////
    static INT32  __stdcall ToUpperChar(TextInfo_ToLowerCharArgs*);
    static LPVOID __stdcall ToUpperString(TextInfo_ToLowerStringArgs*);
    static INT32  __stdcall ToLowerChar(TextInfo_ToLowerCharArgs*);
    static LPVOID __stdcall ToLowerString(TextInfo_ToLowerStringArgs*);
    //////////////////////////////////////////////////////
    // DELETE THIS WHEN WE USE NLSPLUS TABLE ONLY - END
    //////////////////////////////////////////////////////

    static FCDECL0(INT32, nativeGetNumEncodingItems);
    static FCDECL0(EncodingDataItem *, nativeGetEncodingTableDataPointer);
    static FCDECL0(CodePageDataItem *, nativeGetCodePageTableDataPointer);

    struct InitializeNativeCompareInfoArgs {
        DECLARE_ECALL_I4_ARG(INT32, sortID);
        DECLARE_ECALL_I4_ARG(INT_PTR, pNativeGlobalizationAssembly);
    };

    struct allocateCasingTableArgs {
        DECLARE_ECALL_I4_ARG(INT32, lcid);
    };

    //Native helper function for methods in CharacterInfo
    static void __stdcall AllocateCharTypeTable(VoidArgs *args);

    //Native helper functions for methods in GlobalizationAssembly.
    static LPVOID __stdcall nativeCreateGlobalizationAssembly(CreateGlobalizationAssemblyArg* pArgs);
    //Native helper functions for methods in CompareInfo.
    static LPVOID __stdcall InitializeNativeCompareInfo(InitializeNativeCompareInfoArgs *args);

    //
    //  Native helper function for methods in TextInfo
    //
    static FCDECL4(INT32, nativeChangeCaseChar, INT32, INT32, WCHAR, BOOL);
    static FCDECL2(INT32, nativeGetTitleCaseChar, INT32 , WCHAR);

    
    struct ChangeCaseStringArgs {
        DECLARE_ECALL_I4_ARG(BOOL, bIsToUpper);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString); 
        DECLARE_ECALL_I4_ARG(INT_PTR, pNativeTextInfo);
        DECLARE_ECALL_I4_ARG(INT32, nLCID);
    };    
    static LPVOID __stdcall nativeChangeCaseString(ChangeCaseStringArgs* pArgs);
    static LPVOID __stdcall AllocateDefaultCasingTable(VoidArgs *args);
    static LPVOID __stdcall AllocateCasingTable(allocateCasingTableArgs *args);

    static LoaderHeap *m_pNLSHeap;   //NLS Heap.

    //
    // Native helper function for methods in MLangCodePageEncoding
    //
    static FCDECL0(BOOL, nativeCreateIMultiLanguage);
    static FCDECL0(VOID, nativeReleaseIMultiLanguage);
    static FCDECL1(BOOL, nativeIsValidMLangCodePage, INT32 codepage);
    static FCDECL8(INT32, nativeBytesToUnicode, INT32 nCodePage, LPVOID bytes, UINT byteIndex, UINT* pByteCount, LPVOID chars, UINT charIndex, UINT charCount, DWORD* pdwMode);
    static FCDECL7(INT32, nativeUnicodeToBytes, INT32 nCodePage, LPVOID chars, UINT charIndex, UINT charCount, LPVOID bytes, UINT byteIndex, UINT byteCount);

    //
    // Native helper function for methods in GB18030Encoding
    //
    static FCDECL0(BOOL, nativeLoadGB18030DLL);
    static FCDECL0(BOOL, nativeUnloadGB18030DLL);
    static FCDECL7(INT32, nativeGB18030BytesToUnicode, 
        LPVOID bytes, UINT byteIndex, UINT pByteCount,  UINT* leftOverBytes,
        LPVOID chars, UINT charIndex, UINT charCount);
    static FCDECL6(INT32, nativeGB18030UnicodeToBytes, 
        LPVOID chars, UINT charIndex, UINT charCount, 
        LPVOID bytes, UINT byteIndex, UINT byteCount);


    static CasingTable* m_pCasingTable;

private:

    //
    //  Internal helper functions.
    //

    static INT32  ConvertStringCase(LCID Locale, WCHAR *wstr, int ThisLength, WCHAR* Value, int ValueLength, DWORD ConversionType);
    static LPVOID internalConvertStringCase(TextInfo_ToLowerStringArgs *pargs, DWORD dwOptions);
    static WCHAR internalToUpperChar(LCID Locale, WCHAR wch);

    
    static LPVOID internalEnumSystemLocales(DWORD dwFlags);
    static LPVOID GetMultiStringValues(LPWSTR pInfoStr);
    static INT32  CompareFast(STRINGREF strA, STRINGREF strB, BOOL *pbDifferInCaseOnly);
    static INT32 CompareOrdinal(WCHAR* strAChars, int Length1, WCHAR* strBChars, int Length2 );
    static INT32 __stdcall  DoCompareChars(WCHAR charA, WCHAR charB, BOOL *bDifferInCaseOnly);
    static inline INT32  DoComparisonLookup(wchar_t charA, wchar_t charB);
    static void   ConvertStringCaseFast(WCHAR *inBuff, WCHAR* outBuff, INT32 length, DWORD dwOptions);
    static INT32  FastIndexOfString(WCHAR *sourceString, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength);
    static INT32  FastIndexOfStringInsensitive(WCHAR *sourceString, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength);

    static INT32  FastLastIndexOfString(WCHAR *sourceString, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength);
    static INT32  FastLastIndexOfStringInsensitive(WCHAR *sourceString, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength);
//    static INT32  GetIndexFromHashTable(WCHAR* pName, int hashCode, int hashTable[], CollisionItem collisionTable[]);

    //
    //  Definitions.
    //
    
    #define CULTUREINFO_OPTIONS_SIZE 32
    
    const static WCHAR ToUpperMapping[];
    const static WCHAR ToLowerMapping[];
    const static INT8 ComparisonTable[0x80][0x80];

#ifdef PLATFORM_WIN32
    // The following are used to detect system default UI language in downlevel systems (Windows NT 4.0 & 
    // Windows 9x.
    static LANGID GetNTDLLNativeLangID();
    static BOOL IsHongKongVersion();
    static BOOL CALLBACK EnumLangProc(HMODULE hModule, LPCWSTR lpszType, LPCWSTR lpszName, WORD wIDLanguage, LPARAM lParam);
    static LANGID GetDownLevelSystemDefaultUILanguage();
#endif  // PLATFORM_WIN32 

    //
    // GB18030 implementation
    //
    static HMODULE m_hGB18030;
    static PFN_GB18030_UNICODE_TO_BYTES m_pfnGB18030UnicodeToBytesFunc;
    static PFN_GB18030_BYTES_TO_UNICODE m_pfnGB18030BytesToUnicodeFunc;

private:  
    //
    // Internal encoding data tables.
    //
    const static int m_nEncodingDataTableItems;
    const static EncodingDataItem EncodingDataTable[];
    
    const static int m_nCodePageTableItems;
    const static CodePageDataItem CodePageDataTable[];

    static IMultiLanguage* m_pIMultiLanguage;
    static int m_cRefIMultiLanguage;
};


class NativeTextInfo; //Defined in $\Com99\src\ClassLibNative\NLS;

class InternalCasingHelper {
    private:
    static NativeTextInfo* pNativeTextInfo;
    static void InitTable();

    public:
    //
    // Native helper functions to do correct casing operations in 
    // runtime native code.
    //

    // Convert szIn to lower case in the Invariant locale.
    static INT32 InvariantToLower(LPUTF8 szOut, int cMaxBytes, LPCUTF8 szIn);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\baseinfotable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _USE_NLS_PLUS_TABLE
////////////////////////////////////////////////////////////////////////////
//
//  Class:    BaseInfoTable
//
//  Author:   Yung-Shin Lin (YSLin)
//
//  Purpose:  Base class for CultureInfoTable and RegionInfoTable
//
//
//  Date:     01/21/2000
//
////////////////////////////////////////////////////////////////////////////


#include "common.h"
#include <winnls.h>
#include "COMString.h"
#include "winwrap.h"

#include "COMNlsInfo.h"
#include "NLSTable.h"
#include "BaseInfoTable.h"


BaseInfoTable::BaseInfoTable(Assembly* pAssembly) :
    NLSTable(pAssembly) {
}

/**
**        The index is the beginning of the first sub-languages for this primary 
**        languages, followed by the second sub-languages, the third sub-languages, etc.
**        From this index, we can get the data table index for a valid
**        culture ID.
*/

/*=================================InitDataTable============================
**Action: Read data table and initialize pointers to the different parts
**        of the table.
**Returns: void.
**Arguments:
**        lpwMappingName
**        lpFileName
**        hHandle
**Exceptions:
==============================================================================*/

void BaseInfoTable::InitDataTable(LPCWSTR lpwMappingName, LPCSTR lpFileName, HANDLE& hHandle ) {
    LPBYTE pBytePtr = (LPBYTE)MapDataFile(lpwMappingName, lpFileName, &hHandle);

    // Set up pointers to different parts of the table.
    m_pBasePtr = (LPWORD)pBytePtr;
    m_pHeader  = (CultureInfoHeader*)m_pBasePtr;
    m_pWordRegistryTable    = (LPWORD)(pBytePtr + m_pHeader->wordRegistryOffset);
    m_pStringRegistryTable  = (LPWORD)(pBytePtr + m_pHeader->stringRegistryOffset);
    m_pIDOffsetTable    = (IDOffsetItem*)(pBytePtr + m_pHeader->IDTableOffset);
    m_pNameOffsetTable  = (NameOffsetItem*)(pBytePtr + m_pHeader->nameTableOffset);
    m_pDataTable        = (LPWORD)(pBytePtr + m_pHeader->dataTableOffset);
    m_pStringPool       = (LPWSTR)(pBytePtr + m_pHeader->stringPoolOffset);

    m_dataItemSize = m_pHeader->numWordFields + m_pHeader->numStrFields;
}

/*=================================UninitDataTable============================
**Action: Release used resources.
**Returns: Void
**Arguments: Void
**Exceptions: None.
==============================================================================*/

void BaseInfoTable::UninitDataTable()
{
    #ifndef _USE_MSCORNLP
    UnmapViewOfFile((LPCVOID)m_pBasePtr);
    CloseHandle(m_hBaseHandle);
    #endif
}

/*=================================GetDataItem==================================
**Action: Given a culture ID, return the index which points to
**        the corresponding record in Culture Data Table.
**Returns: an int index points to a record in Culture Data Table.  If no corresponding
**         index to return (because the culture ID is invalid), -1 is returned.
**Arguments:
**         cultureID the specified culture ID.
**Exceptions: None.
==============================================================================*/

// BUGBUG YSLin: Port this to managed side.
int BaseInfoTable::GetDataItem(int cultureID) {
    WORD wPrimaryLang = PRIMARYLANGID(cultureID);
    WORD wSubLang    = SUBLANGID(cultureID);

    //
    // Check if the primary language in the parameter is greater than the max number of
    // the primary language.  If yes, this is an invalid culture ID.
    //
    if (wPrimaryLang > m_pHeader->maxPrimaryLang) {
        return (-1);
    }

    WORD wNumSubLang = m_pIDOffsetTable[wPrimaryLang].numSubLang;

    // Check the following:
    // 1. If the number of sub-languages is zero, it means the primary language ID
    //    is not valid. 
    // 2. Check if the sub-language is in valid range.    
    if (wNumSubLang == 0 || (wSubLang >= wNumSubLang)) {
        return (-1);
    }
    return (m_pIDOffsetTable[wPrimaryLang].dataItemIndex + wSubLang);
}


/*=================================GetDataItem==================================
**Action: Given a culture name, return the index which points to
**        the corresponding record in Culture Data Table.
**Returns: an int index points to a record in Culture Data Table.  If no corresponding
**         index to return (because the culture name is valid), -1 is returned.
**Arguments:
**         name the specified culture name.
**Exceptions: None.
==============================================================================*/
/*
// Not implemented.  We provide this function in managed code in CultureInfo.cool.
int BaseInfoTable::GetDataItem(LPWSTR name) {
    return (0);
}
*/


/*=================================GetInt32Data==================================
**Action: Get the data in the specified data item.  The type of the field is INT32.
**If the culture is the user default culture, and the requested field can have user
**overridden value from control panel, this method will retrieve the value from
**control panel.
**
**Returns: The requested INT32 value.
**Arguments:
**      dataItem an index to a record in the Culture Data Table.
**      field a field in the record.  See CultureInfoTable.h for list of fields.
**Exceptions: None.  Caller should make sure dataItem and field are valid.
==============================================================================*/

INT32 BaseInfoTable::GetInt32Data(int dataItem, int field, BOOL useUserOverride) {
    _ASSERTE(dataItem < m_pHeader->numCultures);
    _ASSERTE(field < m_pHeader->numWordFields);

    if (useUserOverride) {
        if (field < m_pHeader->numWordRegistry && GetDataItemCultureID(dataItem) == ::GetUserDefaultLangID()) {
            INT32 int32DataValue;
            if (GetUserInfoInt32(field, m_pStringPool+m_pWordRegistryTable[field], &int32DataValue)) {
                // The side effect of GetUserInfoInt32() is that int32DataValue will be updated.
                return (int32DataValue);
            }
        }
    }
    return (m_pDataTable[dataItem * m_dataItemSize + field]);
}

/*=================================GetDefaultInt32Data==================================
**Action: Get the data in the specified data item.  The type of the field is INT32.
**
**Returns: The requested INT32 value.
**Arguments:
**      dataItem an index to a record in the Culture Data Table.
**      field a field in the record.  See CultureInfoTable.h for list of fields.
**Exceptions: None.  Caller should make sure dataItem and field are valid.
==============================================================================*/

INT32 BaseInfoTable::GetDefaultInt32Data(int dataItem, int field) {
    _ASSERTE(dataItem < m_pHeader->numCultures);
    _ASSERTE(field < m_pHeader->numWordFields);
    return (m_pDataTable[dataItem * m_dataItemSize + field]);
}


/*=================================GetStringData==================================
**Action: Get the data in the specified data item.  Type of the field is LPWSTR.
**If the culture is the user default culture, and the requested field can have user
**overridden value from control panel, this method will retrieve the value from
**control panel.
**
**Returns: The requested LPWSTR value.
**      dataItem an index to a record in the Culture Data Table.
**      field a field in the record.  See CultureInfoTable.h for list of fields.
**Exceptions: None.  Caller should make sure dataItem and field are valid.
==============================================================================*/

LPWSTR BaseInfoTable::GetStringData(int dataItem, int field, BOOL useUserOverride, LPWSTR buffer, int bufferSize) {
    _ASSERTE(dataItem < m_pHeader->numCultures);
    _ASSERTE(field < m_pHeader->numStrFields);
    if (useUserOverride) { 
        if (field < m_pHeader->numStringRegistry && GetDataItemCultureID(dataItem) == ::GetUserDefaultLangID() ) {      
            if (GetUserInfoString(field, m_pStringPool+m_pStringRegistryTable[field], &buffer, bufferSize)) {
                //
                // Get the user-overriden registry value successfully.
                //
                return (buffer);
            }                
        }
    }
    
    // Otherwise, use the default data from the data table.
    return (m_pStringPool+m_pDataTable[dataItem * m_dataItemSize + m_pHeader->numWordFields + field]);
}

/*=================================GetDefaultStringData==================================
**Action: Get the data in the specified data item.  Type of the field is LPWSTR.
**
**Returns: The requested LPWSTR value.
**      dataItem an index to a record in the Culture Data Table.
**      field a field in the record.  See CultureInfoTable.h for list of fields.
**Exceptions: None.  Caller should make sure dataItem and field are valid.
==============================================================================*/

LPWSTR BaseInfoTable::GetDefaultStringData(int dataItem, int field) {
    _ASSERTE(dataItem < m_pHeader->numCultures);
    _ASSERTE(field < m_pHeader->numStrFields);
    return (m_pStringPool+m_pDataTable[dataItem * m_dataItemSize + m_pHeader->numWordFields + field]);
}

/*===============================GetHeader==============================
**Action: Return the header structure.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

CultureInfoHeader*  BaseInfoTable::GetHeader()
{
    return (m_pHeader);
}

/*=================================GetNameOffsetTable============================
**Action: Return the pointer to the Culture Name Offset Table.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

NameOffsetItem* BaseInfoTable::GetNameOffsetTable() {
    return (m_pNameOffsetTable);
}

/*=================================GetStringPool============================
**Action: Return the pointer to the String Pool Table.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

LPWSTR BaseInfoTable::GetStringPoolTable() {
    return (m_pStringPool);
}

/*=================================GetUserInfoInt32==================================
**Action: Get User overriden INT32 value from registry
**Returns: True if succeed.  False otherwise.
**Arguments:
**Exceptions:
==============================================================================*/

BOOL BaseInfoTable::GetUserInfoInt32(int field, LPCWSTR lpwRegName, INT32* pInt32DataValue) {
    BOOL bResult = FALSE;
    HKEY hKey = NULL;                          // handle to intl key
    CQuickBytes buffer;
    
    //
    //  Open the Control Panel International registry key.
    //
    if (WszRegOpenKeyEx(HKEY_CURRENT_USER,
                    NLS_CTRL_PANEL_KEY,
                    0,
                    KEY_READ, 
                    &hKey) != ERROR_SUCCESS) {                                                                  
        goto Exit;
    } 

    DWORD dwLen;
    DWORD dwType;
    
    if (WszRegQueryValueExTrue(hKey, lpwRegName, 0, &dwType, (LPBYTE)NULL, &dwLen) != ERROR_SUCCESS) {
        goto Exit;
    }

    if (dwLen > 0) {
        //Assert that we didn't get an odd number of bytes, which will cause the next allocation to screw up.
        //            _ASSERTE((dwLen%sizeof(WCHAR))==0); 

        LPWSTR pStr = (LPWSTR)buffer.Alloc(dwLen * sizeof(WCHAR));
        if (pStr==NULL) {
            goto Exit;
        }
        
        if (WszRegQueryValueExTrue(hKey, lpwRegName, 0, &dwType, (LPBYTE)pStr, &dwLen) != ERROR_SUCCESS) {
            goto Exit;
        }
        
        if (dwType != REG_SZ) {
            goto Exit;
        }
        *pInt32DataValue = COMNlsInfo::WstrToInteger4(pStr, 10);
        *pInt32DataValue = ConvertWin32FormatInt32(field, *pInt32DataValue);
        
        bResult = TRUE;
    }

Exit:

    if (hKey) {
        RegCloseKey(hKey);
    }
    
    //
    //  Return success.
    //
    return (bResult);    
}

/*=================================GetUserInfoString==================================
**Action: Get User overriden string value from registry
**        The side effect is that lpwCache, pInfoStr will be updated if the method succeeds.
**Returns: True if succeed.  False otherwise.
**Arguments:
**Exceptions:
==============================================================================*/

BOOL BaseInfoTable::GetUserInfoString(int field, LPCWSTR lpwRegName, LPWSTR* buffer, int bufferSize)
{
    BOOL bResult = FALSE;
    
    HKEY hKey = NULL;                          // handle to intl key
    
    //
    //  Open the Control Panel International registry key.
    //
    if (WszRegOpenKeyEx(HKEY_CURRENT_USER,
                    NLS_CTRL_PANEL_KEY,
                    0,
                    KEY_READ, 
                    &hKey) != ERROR_SUCCESS)
    {                                                                  
        goto Exit;
    } 

    DWORD dwLen = bufferSize * sizeof(WCHAR);
    DWORD dwType;
    
    if (dwLen > 0) {
        //Assert that we didn't get an odd number of bytes, which will cause the next allocation to screw up.
        //            _ASSERTE((dwLen%sizeof(WCHAR))==0); 

        // Update cached value.
        if (WszRegQueryValueExTrue(hKey, lpwRegName, 0, &dwType, (LPBYTE)(*buffer), &dwLen) != ERROR_SUCCESS) {
            goto CloseKey;
        }
        
        if (dwType != REG_SZ) {
            goto CloseKey;
        }
        
        *buffer = ConvertWin32FormatString(field, *buffer);
        
        bResult = TRUE;
    }
CloseKey:
    //
    //  Close the registry key.
    //
    RegCloseKey(hKey);

        

Exit:
    //
    //  Return success.
    //
    return (bResult);    
}

INT32 BaseInfoTable::ConvertWin32FormatInt32(int field, int win32Value) {
    return (win32Value);
}


/*=================================ConvertWin32FormatString==================================
**Action: Sometimes, Win32 NLS and NLS+ have different string format.
**        According to the data field, this method will convert the pInfoStr from Win32 format
**        to NLS+ format.
**Returns: pInfoStr will be updated if necessary.
**Arguments:
**Exceptions:
==============================================================================*/

LPWSTR BaseInfoTable::ConvertWin32FormatString(int field, LPWSTR pInfoStr)
{
    return pInfoStr;
}

#endif  // _USE_NLS_PLUS_TABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\calendartable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __CALENDAR_TABLE_TABLE
#define __CALENDAR_TABLE_TABLE

class CalendarTable: public BaseInfoTable {
    public:
        static void InitializeTable();
#ifdef SHOULD_WE_CLEANUP
        static void ShutdownTable();
#endif /* SHOULD_WE_CLEANUP */
        static CalendarTable* CreateInstance();
        static CalendarTable* GetInstance();

        virtual int  GetDataItem(int calendarID);

    protected:
        virtual int GetDataItemCultureID(int dataItem); 
    private:
        static CalendarTable* AllocateTable();
        
        CalendarTable();
        ~CalendarTable();
    private:
        static LPCSTR m_lpFileName;
        static LPCWSTR m_lpwMappingName;

    	static CRITICAL_SECTION  m_ProtectDefaultTable;
    	static CalendarTable* m_pDefaultTable;    	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\casingtable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __DEFAULT_CASING_TABLE_H
#define __DEFAULT_CASING_TABLE_H

////////////////////////////////////////////////////////////////////////////
//
//  Class:    CasingTable
//
//  Authors:  Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  This is the class to map a view of casing tables (from l_intl.nlp & l_except.nlp)
//            and create instances of NativeTextInfo from information of these tables.
//            The managed TextInfo will call methods on NativeTextInfo directly to do uppercasing/
//            lowercasing.
//
//  Date:     August 31, 1999
//
//  Note:     
//            The data used to do the lowercasing/uppercasing is stored in l_intl.nlp & l_except.nlp.
//          
//            l_intl.nlp stores the default linguistic casing table.  Default linguistic casing
//            table is the data used by most cultures to do linguistic-correct casing.
//            
//            However, there are cultures that do casing a little different from the default linguistic casing.
//            We say these cultures have 'exceptions'.  Based on the fact that the casing for most code points are 
//            the same and a few code points are different, we store the 'delta' information to 
//            the default linguistic casing table for these cultures.  The LCIDs for exception cultures 
//            and delta information are stored in l_except.nlp.
//          
//            One important culture which has exception is the 'invariant culture' in NLS+.  Invariant 
//            culture has a culture ID of zero.  The casing table for invariant culture is the one
//            used by file system to do casing.  It is not linguistic-correct, but we have to provide
//            this for the compatibilty with the file system. Invariant culture casing table is made from 
//            l_intl.nlp and fix up code points from l_except.nlp.

//
//            In summary, we have three types of casing tables:
//            1. Default linguistic casing table: 
//               This is like calling ::LCMapString() using LCMAP_LINGUISTIC_CASING. The
//               result of the casing is linguistic-correct. However, not every culture
//               can use this table. See point 2.
//            2. Default linguistic casing table + Exception:
//               Turkish has a different linguistic casing.  There are two chars in turkish
//               that has different result from the default linguistic casing.  
//            3. Invariant culture casing.
//               This is like calling ::LCMapString() WITHOUT using LCMAP_LINGUISTIC_CASING.
//               This exists basically for file system.
//
//            For those who understands Win32 NLS, I fudged the l_intl.nls to make
//                linguitic casing to be the default table in l_intl.nlp. 
//            In Win32, the invariant culture casing is the default table, and stored in l_intl.nls.
//                And the linguistic casing is the exception with culture ID 0x0000.
//            The reason is that we use linguitic casing by default in NLS+ world, so the change
//                here saves us from fixing up linguistic casing.
//
////////////////////////////////////////////////////////////////////////////

//
//  Casing Exceptions Header Structure.
//  This header contains the the information about:
//  * the cultures that have different casing data table from the default linguistic casing table.
//  * the offset to the casing exception tables (type: l_except_s).
//  * the number of exception upper case entries.
//  * the number of exception lower case entries.
typedef struct l_except_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset to exception nodes (words)
    DWORD     NumUpEntries;            // number of upper case entries
    DWORD     NumLoEntries;            // number of lower case entries
} L_EXCEPT_HDR, *PL_EXCEPT_HDR;

//
//  Casing Exceptions Structure.
//
//  We use this table to create casing table for cultures that have exceptions.
//  This contain the 'delta' information to the default linguistic casing table.
//
typedef struct l_except_s
{
    WORD      UCP;                     // unicode code point
    WORD      AddAmount;               // amount to add to code point
} L_EXCEPT, *PL_EXCEPT;

class NativeTextInfo;
typedef NativeTextInfo* PNativeTextInfo;

class CasingTable : public NLSTable {
    public:
        CasingTable();
        ~CasingTable();
        
        BOOL AllocateDefaultTable();
        //static int AllocateIndividualTable(int lcid);
        NativeTextInfo* InitializeNativeTextInfo(INT32 nLcid);

        NativeTextInfo* GetDefaultNativeTextInfo();
                        
    private:
        void SetData(LPWORD pLinguisticData);
    
        //
        // Create the (excptIndex)th linguistic casing table by coping
        // the default values from CasingTable::GetInvariantInstance()
        // and fix up the values according to m_pExceptionData.
        //
        NativeTextInfo* CreateNativeTextInfo(int exceptIndex);

        //
        // An initilization method used to read the casing exception table
        // and set up m_pExceptionHeader and m_pExceptionData.
        //
        BOOL GetExceptionHeader();
        
    private:
        //
        // ---------------- Static information ---------------- 
        //
        static LPCSTR m_lpFileName;
        static LPCWSTR m_lpMappingName;

        //
        // Variables for exception culture handling.
        //

        static LPCSTR m_lpExceptionFileName;
        static LPCWSTR m_lpExceptionMappingName;

        //
        // The default NativeTextInfo which is used for the default linguistic
        // casing for most of the cultures.
        //
        NativeTextInfo*  m_pDefaultNativeTextInfo; 
        
        //
        // The number of cultures which have exceptions.
        //
        LONG m_nExceptionCount;
        
        //
        // An array which points to casing tables for cultures which have exceptions.
        // The size of this array is dynamicly decided by m_nExceptionCount.
        //
        NativeTextInfo** m_ppExceptionTextInfoArray;
                
        PL_EXCEPT_HDR   m_pExceptionHeader;   // ptr to linguistic casing table header
        PL_EXCEPT       m_pExceptionData; 
        HANDLE          m_hExceptionHeader;
        HANDLE          m_hDefaultCasingTable;
        
        LPWORD  m_pCasingData;
        PCASE   m_pDefaultUpperCase844;
        PCASE   m_pDefaultLowerCase844; 
        PCASE   m_pDefaultTitleCase844;
        WORD    m_nDefaultUpperCaseSize;
        WORD    m_nDefaultLowerCaseSize;
        WORD    m_pDefaultTitleCaseSize;
        

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\calendartable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _USE_NLS_PLUS_TABLE
////////////////////////////////////////////////////////////////////////////
//
//  Class:    CalendarTable
//
//  Author:   Yung-Shin Lin (YSLin)
//
//  Purpose:  Used to retrieve Calendar information from calendar.nlp & registry.
//
//
//  Date:     01/21/2000
//
////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include <winnls.h>
#include "COMString.h"
#include "winwrap.h"

#include "COMNlsInfo.h"
#include "NLSTable.h"
#include "BaseInfoTable.h"
#include "CalendarTable.h"

//
// HACKHACK: At this stage (04/17/2000), we can not add new files into setup.
// Therefore, we reuse the file name (ctype.nlp).  This file is not used but it still exists in the setup.
// ctype.nlp is not necessary because we use unicode category table in runtime.
// When chance is availabe, this file should be renamed as "calendar.nlp"
//
LPCSTR CalendarTable::m_lpFileName      = "ctype.nlp";
LPCWSTR CalendarTable::m_lpwMappingName = L"_nlsplus_calendar_1_0_3627_11_nlp";

CRITICAL_SECTION CalendarTable::m_ProtectDefaultTable;
CalendarTable * CalendarTable::m_pDefaultTable;

/*=================================CalendarTable============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

CalendarTable::CalendarTable() :
    BaseInfoTable(SystemDomain::SystemAssembly()) {
    InitializeCriticalSection(&m_ProtectCache);
    InitDataTable(m_lpwMappingName, m_lpFileName, m_hBaseHandle);
}

/*=================================~CalendarTable============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

CalendarTable::~CalendarTable() {
    DeleteCriticalSection(&m_ProtectCache);
    UninitDataTable();
}

/*==========================InitializeCultureInfoTable==========================
**Action: Intialize critical section variables so they will be only initialized once. 
**        Used by COMNlsInfo::InitializeNLS().
**Returns: None.
**Arguments: None.
**Exceptions: None.
==============================================================================*/

void CalendarTable::InitializeTable() {
    InitializeCriticalSection(&m_ProtectDefaultTable);
}

/*===========================ShutdownCultureInfoTable===========================
**Action: Deletes any items that we may have allocated into the CalendarTable 
**        cache.  Once we have our own NLS heap, this won't be necessary.
**Returns:    Void
**Arguments:  None.  The side-effect is to free any allocated memory.
**Exceptions: None.
==============================================================================*/

#ifdef SHOULD_WE_CLEANUP
void CalendarTable::ShutdownTable() {
    DeleteCriticalSection(&m_ProtectDefaultTable);
    if (m_pDefaultTable) {
        delete m_pDefaultTable;
    }
}
#endif /* SHOULD_WE_CLEANUP */


/*================================AllocateTable=================================
**Action:  This is a very thin wrapper around the constructor. Calls to new can't be
**         made directly in a COMPLUS_TRY block. 
**Returns: A newly allocated CalendarTable.
**Arguments: None
**Exceptions: The CalendarTable constructor can throw an OutOfMemoryException or
**            an ExecutionEngineException.
==============================================================================*/

CalendarTable *CalendarTable::AllocateTable() {
    return (new CalendarTable());
}


/*===============================CreateInstance================================
**Action:  Create the default instance of CalendarTable.  This allocates the table if it hasn't
**         previously been allocated.  We need to carefully wrap the call to AllocateTable
**         because the constructor can throw some exceptions.  Unless we have the
**         try/finally block, the exception will skip the LeaveCriticalSection and
**         we'll create a potential deadlock.
**Returns: A pointer to the default CalendarTable.
**Arguments: None 
**Exceptions: Can throw an OutOfMemoryException or an ExecutionEngineException.
==============================================================================*/

CalendarTable* CalendarTable::CreateInstance() {
    THROWSCOMPLUSEXCEPTION();

    if (m_pDefaultTable==NULL) {
        Thread* pThread = GetThread();
        _ASSERTE(pThread != NULL);
        pThread->EnablePreemptiveGC();

        LOCKCOUNTINCL("CreateInstance in CalendarTable");

        EnterCriticalSection(&m_ProtectDefaultTable);
        
        pThread->DisablePreemptiveGC();
     
        EE_TRY_FOR_FINALLY {
            //Make sure that nobody allocated the table before us.
            if (m_pDefaultTable==NULL) {
                //Allocate the default table and verify that we got one.
                m_pDefaultTable = AllocateTable();
                if (m_pDefaultTable==NULL) {
                    _ASSERTE(!"Cannot create CalendarTable.");
                    COMPlusThrowOM();
                }
            }
        } EE_FINALLY {
            _ASSERTE(m_pDefaultTable != NULL);
            //We need to leave the critical section regardless of whether
            //or not we were successful in allocating the table.
            LeaveCriticalSection(&m_ProtectDefaultTable);
            LOCKCOUNTDECL("CreateInstance in CalendarTable");

        } EE_END_FINALLY;
    }
    return (m_pDefaultTable);
}

/*=================================GetInstance============================
**Action: Get the default instance of CalendarTable.
**Returns: A pointer to the default instance of CalendarTable.
**Arguments: None
**Exceptions: None.
**Notes: This method should be called after CreateInstance has been called.
** 
==============================================================================*/

CalendarTable *CalendarTable::GetInstance() {
    _ASSERTE(m_pDefaultTable);
    return (m_pDefaultTable);
}

/*=================================GetDataItem==================================
**Action: Given a culture ID, return the index which points to
**        the corresponding record in Culture Data Table.
**Returns: an int index points to a record in Culture Data Table.  If no corresponding
**         index to return (because the culture ID is invalid), -1 is returned.
**Arguments:
**		   cultureID the specified culture ID.
**Exceptions: None.
==============================================================================*/

// BUGBUG YSLin: Port this to managed side.
int CalendarTable::GetDataItem(int calendarID) {
    return (calendarID);
}

/*=================================GetDataItemCultureID==================================
**Action: Return the language ID for the specified culture data item index.
**Returns: The culture ID.
**Arguments:
**      dataItem an index to a record in the Culture Data Table.
**Exceptions: None.
==============================================================================*/

int CalendarTable::GetDataItemCultureID(int dataItem) {
    return (dataItem);
}
#endif // _USE_NLS_PLUS_TABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\cultureinfotable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _USE_NLS_PLUS_TABLE
////////////////////////////////////////////////////////////////////////////
//
//  Class:    CultureInfoTable
//
//  Author:   Yung-Shin Lin (YSLin)
//
//  Purpose:  Used to retrieve culture information from culture.nlp & registry.
//
//
//  Date:     01/21/2000
//
////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include <winnls.h>
#include "COMString.h"
#include "winwrap.h"

#include "COMNlsInfo.h"
#include "NLSTable.h"
#include "BaseInfoTable.h"
#include "CultureInfoTable.h"

#define LOCALE_BUFFER_SIZE  32

LPCSTR CultureInfoTable::m_lpCultureFileName       = "culture.nlp";
LPCWSTR CultureInfoTable::m_lpCultureMappingName = L"_nlsplus_culture_1_0_3627_11_nlp";

CRITICAL_SECTION CultureInfoTable::m_ProtectDefaultTable;
CultureInfoTable * CultureInfoTable::m_pDefaultTable;

//
// Stings used to convert Win32 string data value to NLS+ string data value.
//
LPWSTR CultureInfoTable::m_pDefaultPositiveSign = L"+";
LPWSTR CultureInfoTable::m_pGroup3    = L"3;0";
LPWSTR CultureInfoTable::m_pGroup30   = L"3";
LPWSTR CultureInfoTable::m_pGroup320  = L"3;2";
LPWSTR CultureInfoTable::m_pGroup0    = L"0";

/*=================================CultureInfoTable============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

CultureInfoTable::CultureInfoTable() :
    BaseInfoTable(SystemDomain::SystemAssembly()) {
    InitializeCriticalSection(&m_ProtectCache);
    InitDataTable(m_lpCultureMappingName, m_lpCultureFileName, m_hBaseHandle);
}

/*=================================~CultureInfoTable============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

CultureInfoTable::~CultureInfoTable() {
    DeleteCriticalSection(&m_ProtectCache);
    UninitDataTable();
}

/*==========================InitializeCultureInfoTable==========================
**Action: Intialize critical section variables so they will be only initialized once. 
**        Used by COMNlsInfo::InitializeNLS().
**Returns: None.
**Arguments: None.
**Exceptions: None.
==============================================================================*/

void CultureInfoTable::InitializeTable() {
    InitializeCriticalSection(&m_ProtectDefaultTable);
}

/*===========================ShutdownCultureInfoTable===========================
**Action: Deletes any items that we may have allocated into the CultureInfoTable 
**        cache.  Once we have our own NLS heap, this won't be necessary.
**Returns:    Void
**Arguments:  None.  The side-effect is to free any allocated memory.
**Exceptions: None.
==============================================================================*/

#ifdef SHOULD_WE_CLEANUP
void CultureInfoTable::ShutdownTable() {
    DeleteCriticalSection(&m_ProtectDefaultTable);
    if (m_pDefaultTable) {
        delete m_pDefaultTable;
    }
}
#endif /* SHOULD_WE_CLEANUP */


/*================================AllocateTable=================================
**Action:  This is a very thin wrapper around the constructor. Calls to new can't be
**         made directly in a COMPLUS_TRY block. 
**Returns: A newly allocated CultureInfoTable.
**Arguments: None
**Exceptions: The CultureInfoTable constructor can throw an OutOfMemoryException or
**            an ExecutionEngineException.
==============================================================================*/

CultureInfoTable *CultureInfoTable::AllocateTable() {
    return new CultureInfoTable();
}


/*===============================CreateInstance================================
**Action:  Create the default instance of CultureInfoTable.  This allocates the table if it hasn't
**         previously been allocated.  We need to carefully wrap the call to AllocateTable
**         because the constructor can throw some exceptions.  Unless we have the
**         try/finally block, the exception will skip the LeaveCriticalSection and
**         we'll create a potential deadlock.
**Returns: A pointer to the default CultureInfoTable.
**Arguments: None 
**Exceptions: Can throw an OutOfMemoryException or an ExecutionEngineException.
==============================================================================*/

CultureInfoTable* CultureInfoTable::CreateInstance() {
    THROWSCOMPLUSEXCEPTION();

    if (m_pDefaultTable==NULL) {
        Thread* pThread = GetThread();
        pThread->EnablePreemptiveGC();
        LOCKCOUNTINCL("CreateInstance in CultreInfoTable.cpp");								\
        EnterCriticalSection(&m_ProtectDefaultTable);
        
        pThread->DisablePreemptiveGC();
     
        EE_TRY_FOR_FINALLY {
            //Make sure that nobody allocated the table before us.
            if (m_pDefaultTable==NULL) {
                //Allocate the default table and verify that we got one.
                m_pDefaultTable = AllocateTable();
                if (m_pDefaultTable==NULL) {
                    COMPlusThrowOM();
                }
            }
        } EE_FINALLY {
            //We need to leave the critical section regardless of whether
            //or not we were successful in allocating the table.
            LeaveCriticalSection(&m_ProtectDefaultTable);
            LOCKCOUNTDECL("CreateInstance in CultreInfoTable.cpp");								\

        } EE_END_FINALLY;
    }
    return (m_pDefaultTable);
}

/*=================================GetInstance============================
**Action: Get the dfault instance of CultureInfoTable.
**Returns: A pointer to the default instance of CultureInfoTable.
**Arguments: None
**Exceptions: None.
**Notes: This method should be called after CreateInstance has been called.
** 
==============================================================================*/

CultureInfoTable *CultureInfoTable::GetInstance() {
    _ASSERTE(m_pDefaultTable);
    return (m_pDefaultTable);
}

int CultureInfoTable::GetDataItem(int cultureID) {
    WORD wPrimaryLang = PRIMARYLANGID(cultureID);
    WORD wSubLang    = SUBLANGID(cultureID);

    //
    // Check if the primary language in the parameter is greater than the max number of
    // the primary language.  If yes, this is an invalid culture ID.
    //
    if (wPrimaryLang > m_pHeader->maxPrimaryLang) {
        return (-1);
    }

    WORD wNumSubLang = m_pIDOffsetTable[wPrimaryLang].numSubLang;

    //
    // If the number of sub-languages is zero, it means the primary language ID
    //    is not valid. 
    if (wNumSubLang == 0) {
        return (-1);
    }
    //
    // Search thru the data items and try matching the culture ID.
    //
    int dataItem = m_pIDOffsetTable[wPrimaryLang].dataItemIndex;
    for (int i = 0; i < wNumSubLang; i++)
    {
        if (GetDataItemCultureID(dataItem) == cultureID) {            
            return (dataItem);
        }
        dataItem++;
    }
    return (-1);
}

/*=================================GetDataItemCultureID==================================
**Action: Return the language ID for the specified culture data item index.
**Returns: The culture ID.
**Arguments:
**      dataItem an index to a record in the Culture Data Table.
**Exceptions: None.
==============================================================================*/

int CultureInfoTable::GetDataItemCultureID(int dataItem) {
    return (m_pDataTable[dataItem * m_dataItemSize + CULTURE_ILANGUAGE]);
}

LPWSTR CultureInfoTable::ConvertWin32FormatString(int field, LPWSTR pInfoStr) {
    //
    // Win32 and NLS+ has several different fields with different data formats,
    // so we have to convert the format here. This is a virtual function called by
    // BaseInfoTable::GetStringData().
    switch (field) {
        case CULTURE_SPOSITIVESIGN:
            if (Wszlstrlen(pInfoStr) == 0) {
                pInfoStr = m_pDefaultPositiveSign;
            }
            break;
        case CULTURE_SGROUPING:
        case CULTURE_SMONGROUPING:
            // BUGBUG YSLin: Do a hack here.  We only check the common cases for now.
            // Have to port CultureInfo.ParseWin32GroupString() to here.
            // These data comes from Win32 locale.nls, and there is three formats "3;0", "3;2;0", and "0;0" there.
            // So we should be ok.  User can not set their groupings directly, because they have to choose
            // from the combo box in the control panel.
            if (wcscmp(pInfoStr, L"3") == 0) {
                pInfoStr = m_pGroup3;
            } else if (wcscmp(pInfoStr, L"3;0") == 0) {
                pInfoStr = m_pGroup30;
            } else if (wcscmp(pInfoStr, L"3;2;0") == 0) {
                pInfoStr = m_pGroup320;
            } else if (wcscmp(pInfoStr, L"0;0") == 0) {
                pInfoStr = m_pGroup0;
            } else {
                _ASSERTE(!"Need to port ParseWin32GroupString(). Contact YSLin");
            }
            break;
        case CULTURE_STIMEFORMAT:
            pInfoStr = ConvertWin32String(pInfoStr, LOCALE_STIME, L':');
            break;
        case CULTURE_SSHORTDATE:
        case CULTURE_SLONGDATE:
            pInfoStr = ConvertWin32String(pInfoStr, LOCALE_SDATE, L'/');
            break;
    }

    return pInfoStr;
}

INT32 CultureInfoTable::ConvertWin32FormatInt32(int field, int win32Value) {
    int nlpValue = win32Value;
    switch (field) {
        case CULTURE_IFIRSTDAYOFWEEK:
            //
            // NLS+ uses different day of week values than those of Win32.
            // So when we get the first day of week value from the registry, we have to
            // convert it.
            //
            // NLS Value 0 => Monday => NLS+ Value 1
            // NLS Value 1 => Tuesday => NLS+ Value 2
            // NLS Value 2 => Wednesday => NLS+ Value 3
            // NLS Value 3 => Thursday => NLS+ Value 4
            // NLS Value 4 => Friday => NLS+ Value 5
            // NLS Value 5 => Saturday => NLS+ Value 6
            // NLS Value 6 => Sunday => NLS+ Value 0    
        
            if (win32Value < 0 || win32Value > 6) {
                // If invalid data exist in registry, assume
                // the first day of week is Monday.
                nlpValue = 1; 
            } else {
                if (win32Value == 6) {
                    nlpValue = 0;   
                } else {
                    nlpValue++;
                }
            }
            break;        
    }
    return (nlpValue);
}

////////////////////////////////////////////////////////////////////////////
//
// Convert a Win32 style quote string to NLS+ style.
//
// We need this because Win32 uses '' to escape a single quote.
// Therefore, '''' is equal to '\'' in NLS+.
// This function also replaces the customized time/date separator
// with the URT style ':' and '/', so that we can avoid the problem when
// user sets their date/time separator to be something like 'X:'.
// Since Win32 control panel expands the time patterns to be something like
// "HHX:mmX:ss", we replace it so that it becomes "HH:mm:ss".
//
//        
////////////////////////////////////////////////////////////////////////////

LPWSTR CultureInfoTable::ConvertWin32String(
    LPWSTR win32Format, LCTYPE lctype, WCHAR separator) {
    WCHAR szSeparator[LOCALE_BUFFER_SIZE];
    int nSepLen;
    int i = 0;

    BOOL bReplaceSeparator = FALSE; // Decide if we need to replace Win32 separator with NLS+ style separator.
    // We will only set this flag to true when the following two holds:
    //  1. the Win32 separator has more than one character.
    //  2. the Win32 sepatator has NLS+ style seprator (suh as ':' or '/', passed in the separator parameter) in it.

    //
    // Scan the separator which has a length over 2 to see if there is ':' (for STIMEFORMAT) or '/' (for SSHORTDATE/SLONGDATE) in it.
    //
    
    if ((nSepLen = GetLocaleInfo(
        LOCALE_USER_DEFAULT, lctype, szSeparator, sizeof(szSeparator)/sizeof(WCHAR))) > 2) {
        // Note that the value that GetLocaleInfo() returns includes the NULL terminator. So decrement the null terminator.
        nSepLen--;
        // When we are here, we know that the Win32 sepatator has a length over 1.  Check if 
        // there is NLS+ separator in the Win32 separator.
        for (i = 0; i < nSepLen; i++) {
            if (szSeparator[i] == separator) {
                // NLS+ style separator (such as ':' or '/') is found in Win32 separator.  Need to do the separator replacement.
                bReplaceSeparator = TRUE;
                break;
            }
        }
    } else {
        // Do nothing here. When we are here, it either means:
        // 1. The separator has only one character (so that GetLocaleInfo() return 2).  So we don't need to do replacement.
        
        // 2. Or the separator is too long (so that GetLocaleInfo() return 0).  Won't support in this case.
        // Theoritically, we can support replacement in this case.  However, it's hard to imagine that someone will
        // set the date/time separator to be more than 32 characters.
    }

    WCHAR* pszOldFormat = NULL;
    int last = (int)wcslen(win32Format);
    if (!(pszOldFormat = new WCHAR[last])) {
        goto exit;
    }
    memcpy(pszOldFormat, win32Format, sizeof(WCHAR)*last);
    
    int sourceIndex = 0;
    i = 0;
    BOOL bInQuote = FALSE;
    while (sourceIndex < last) {
        WCHAR ch;
        if ((ch = pszOldFormat[sourceIndex]) == L'\'') {
            if (!bInQuote) {
                bInQuote = TRUE;
                win32Format[i++] = ch;
            } else {
                if (sourceIndex + 1 < last) {
                    if ((ch = pszOldFormat[sourceIndex+1]) == L'\'') {
                        win32Format[i++] = '\\';
                        sourceIndex++;
                    } else {
                        bInQuote = FALSE;
                    }
                }
                // Put the single quote back. The old code only puts the single quote back
                // when the previous (sourceIndex + 1 < last) holds true.  Therefore,
                // we are missing the single quote at the end.  This is the fix for 79132/79234.
                win32Format[i++] = '\'';
            }
        } else {
            if (!bInQuote) {
                if (bReplaceSeparator && wcsncmp(pszOldFormat+sourceIndex, szSeparator, nSepLen) == 0) {
                    // Find the separator. Replace it with a single ':'
                    win32Format[i++] = separator;
                    sourceIndex += (nSepLen - 1);
                } else {
                    win32Format[i++] = ch;
                }
            } else {
                win32Format[i++] = ch; 
            }
        }
        sourceIndex++;
    }    

exit:
    if (pszOldFormat) {
        delete [] pszOldFormat;
    }
    win32Format[i] = L'\0';
    
    return (win32Format);
}
#endif // _USE_NLS_PLUS_TABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\cultureinfotable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __CULTURE_INFO_TABLE2
#define __CULTURE_INFO_TABLE2

////////////////////////////////////////////////////////////////////////////
//
//  Class:    CultureInfoTable
//
//  Authors:  Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  This is the class to retrieve culture information like:
//            culture name, date format, currency symbol, etc.
//
//  Date: 	  January 07, 2000
//
////////////////////////////////////////////////////////////////////////////

class CultureInfoTable : public BaseInfoTable {
    public:
        static void InitializeTable();
#ifdef SHOULD_WE_CLEANUP
        static void ShutdownTable();
#endif /* SHOULD_WE_CLEANUP */
        static CultureInfoTable* CreateInstance();
        static CultureInfoTable* GetInstance();
        virtual int GetDataItem(int cultureID);

    protected:
        virtual int GetDataItemCultureID(int dataItem);

        virtual LPWSTR ConvertWin32FormatString(int field, LPWSTR pInfoStr);
        virtual INT32 ConvertWin32FormatInt32(int field, int win32Value);
        LPWSTR ConvertWin32String(LPWSTR pInfoStr, LCTYPE lctype, WCHAR separator);
    private:
        static CultureInfoTable* AllocateTable();

        CultureInfoTable();
        ~CultureInfoTable();

    private:
        static LPCSTR m_lpCultureFileName;
        static LPCWSTR m_lpCultureMappingName;

        static CRITICAL_SECTION  m_ProtectDefaultTable;
        static CultureInfoTable* m_pDefaultTable;
    
        static LPWSTR m_pDefaultPositiveSign;
        static LPWSTR m_pGroup3;
        static LPWSTR m_pGroup30;
        static LPWSTR m_pGroup320;
        static LPWSTR m_pGroup0;
};

//
// The list of WORD fields:
//
#define CULTURE_IDIGITS                 0
#define CULTURE_INEGNUMBER              1
#define CULTURE_ICURRDIGITS             2
#define CULTURE_ICURRENCY               3
#define CULTURE_INEGCURR                4
#define CULTURE_ICALENDARTYPE           5
#define CULTURE_IFIRSTDAYOFWEEK         6
#define CULTURE_IFIRSTWEEKOFYEAR        7
#define CULTURE_ILANGUAGE               8
#define CULTURE_WIN32LCID               9
#define CULTURE_INEGATIVEPERCENT        10
#define CULTURE_IPOSITIVEPERCENT        11
#define CULTURE_IDEFAULTANSICODEPAGE    12
#define CULTURE_IDEFAULTOEMCODEPAGE     13
#define CULTURE_IDEFAULTMACCODEPAGE     14
#define CULTURE_IDEFAULTEBCDICCODEPAGE  15
#define CULTURE_IPARENT                 16
#define CULTURE_IREGIONITEM             17

//
// The list of string fields
//

#define CULTURE_SLIST               0
#define CULTURE_SDECIMAL            1
#define CULTURE_STHOUSAND           2
#define CULTURE_SGROUPING           3
#define CULTURE_SCURRENCY           4
#define CULTURE_SMONDECIMALSEP      5
#define CULTURE_SMONTHOUSANDSEP     6
#define CULTURE_SMONGROUPING        7
#define CULTURE_SPOSITIVESIGN       8
#define CULTURE_SNEGATIVESIGN       9
#define CULTURE_STIMEFORMAT         10
#define CULTURE_STIME               11
#define CULTURE_S1159               12
#define CULTURE_S2359               13
#define CULTURE_SSHORTDATE          14
#define CULTURE_SDATE               15
#define CULTURE_SLONGDATE           16
#define CULTURE_SNAME               17
#define CULTURE_SENGDISPLAYNAME     18
#define CULTURE_SABBREVLANGNAME     19
#define CULTURE_SISO639LANGNAME     20
#define CULTURE_SISO639LANGNAME2    21
#define CULTURE_SNATIVEDISPLAYNAME  22
#define CULTURE_SPERCENT            23
#define CULTURE_SNAN                24
#define CULTURE_SPOSINFINITY        25
#define CULTURE_SNEGINFINITY        26
#define CULTURE_SSHORTTIME          27
#define CULTURE_SYEARMONTH          28
#define CULTURE_SMONTHDAY           29
#define CULTURE_SDAYNAME1           30
#define CULTURE_SDAYNAME2           31
#define CULTURE_SDAYNAME3           32
#define CULTURE_SDAYNAME4           33
#define CULTURE_SDAYNAME5           34
#define CULTURE_SDAYNAME6           35
#define CULTURE_SDAYNAME7           36
#define CULTURE_SABBREVDAYNAME1     37
#define CULTURE_SABBREVDAYNAME2     38
#define CULTURE_SABBREVDAYNAME3     39
#define CULTURE_SABBREVDAYNAME4     40
#define CULTURE_SABBREVDAYNAME5     41
#define CULTURE_SABBREVDAYNAME6     42
#define CULTURE_SABBREVDAYNAME7     43
#define CULTURE_SMONTHNAME1         44
#define CULTURE_SMONTHNAME2         45
#define CULTURE_SMONTHNAME3         46
#define CULTURE_SMONTHNAME4         47
#define CULTURE_SMONTHNAME5         48
#define CULTURE_SMONTHNAME6         49
#define CULTURE_SMONTHNAME7         50
#define CULTURE_SMONTHNAME8         51
#define CULTURE_SMONTHNAME9         52
#define CULTURE_SMONTHNAME10        53
#define CULTURE_SMONTHNAME11        54
#define CULTURE_SMONTHNAME12        55
#define CULTURE_SMONTHNAME13        56
#define CULTURE_SABBREVMONTHNAME1   57
#define CULTURE_SABBREVMONTHNAME2   58
#define CULTURE_SABBREVMONTHNAME3   59
#define CULTURE_SABBREVMONTHNAME4   60
#define CULTURE_SABBREVMONTHNAME5   61
#define CULTURE_SABBREVMONTHNAME6   62
#define CULTURE_SABBREVMONTHNAME7   63
#define CULTURE_SABBREVMONTHNAME8   64
#define CULTURE_SABBREVMONTHNAME9   65
#define CULTURE_SABBREVMONTHNAME10  66
#define CULTURE_SABBREVMONTHNAME11  67
#define CULTURE_SABBREVMONTHNAME12  68
#define CULTURE_SABBREVMONTHNAME13  69
#define CULTURE_NLPIOPTIONCALENDAR  70

/**
These keys are in [HKEY_CURRENT_USER\Control Panel\International]
The following can be overriden by user:

"iCountry"
"iMeasure"
"iDigits"
"iLZero"
"iNegNumber"
"iCurrDigits"
"iCurrency"
"iNegCurr"
"iTime"
"iTLZero"
"iDate"
"iCalendarType"
"iFirstDayOfWeek"
"iFirstWeekOfYear"

"iTimePrefix"	What is this?

"Locale"	What is this for?

"sList"
"sDecimal"
"sThousand"
"sGrouping"			Different format in NLS+
"sNativeDigits"
"sCurrency"
"sMonDecimalSep"
"sMonThousandSep"
"sMonGrouping"		Different format in NLS+
"sPositiveSign"		Different format in NLS+
"sNegativeSign"
"sTimeFormat"
"sTime"
"s1159"
"s2359"
"sShortDate"
"sDate"
"sLongDate"

"sCountry"		Not in NLS+ table.
"sLanguage"		Not in NLS+ table
"NumShape"          What is this for?

Country/region code, based on international phone codes, also referred to as 
IBM country codes. The maximum number of characters allowed for this string 
is six. 

 */
 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\casingtable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "NLSTable.h"   // class NLSTable
#include "NativeTextInfo.h" // class NativeTextInfo
#include "CasingTable.h" // class declaration

LPCSTR  CasingTable::m_lpFileName                   = "l_intl.nlp";
LPCWSTR CasingTable::m_lpMappingName               = L"_nlsplus_l_intl_1_0_3627_11_nlp";

LPCSTR  CasingTable::m_lpExceptionFileName          = "l_except.nlp";
LPCWSTR CasingTable::m_lpExceptionMappingName      = L"_nlsplus_l_except_1_0_3627_11_nlp";

CasingTable::CasingTable() :
    NLSTable(SystemDomain::SystemAssembly()) {

    m_pCasingData = NULL;
    
    m_pDefaultNativeTextInfo = NULL;
    m_pExceptionHeader = NULL;
    m_pExceptionData = NULL;

    m_nExceptionCount = 0;
    m_ppExceptionTextInfoArray = NULL;

    m_hDefaultCasingTable = m_hExceptionHeader = INVALID_HANDLE_VALUE;
}

CasingTable::~CasingTable() {
    if (m_pDefaultNativeTextInfo) {
        delete m_pDefaultNativeTextInfo;
        m_pDefaultNativeTextInfo=NULL;
    }

    #ifndef _USE_MSCORNLP
    if (m_pCasingData) {
        // m_pCasingData points to the beginning of the memory map view.
        UnmapViewOfFile((LPCVOID)(m_pCasingData));
    }

    if (m_pExceptionHeader) {
        //We added 2 to the start of the file in CasingTable::GetExceptionHeader.
        //We need to clean that up now.
        UnmapViewOfFile((LPCVOID)(((LPWORD)m_pExceptionHeader) - 2));
    }

    if (m_hDefaultCasingTable!=NULL && m_hDefaultCasingTable!=INVALID_HANDLE_VALUE) {
        CloseHandle(m_hDefaultCasingTable);
    }

    if (m_hExceptionHeader!=NULL && m_hExceptionHeader!=INVALID_HANDLE_VALUE) {
        CloseHandle(m_hExceptionHeader);
    }
    #endif
    if (m_ppExceptionTextInfoArray) {
        for (int i=0; i<m_nExceptionCount; i++) {
            if (m_ppExceptionTextInfoArray[i]) {
                m_ppExceptionTextInfoArray[i]->DeleteData();
                delete (m_ppExceptionTextInfoArray[i]);
            }
        }
        delete[] m_ppExceptionTextInfoArray;
    }   
}

/*=================================SetData==========================
**Action: Initialize the uppercase table pointer and lowercase table pointer from the specified data pointer.
**Returns: None.
**Arguments:
**      pCasingData WORD pointer to the casing data.
**Exceptions:
============================================================================*/

void CasingTable::SetData(LPWORD pCasingData) {
    LPWORD pData = pCasingData;
    m_pCasingData = pData;

    // The first word is the default flag.
    // The second word is the size of the upper case table (including the word for the size).
    // After the first words is the beginning of uppder casing table.
    m_nDefaultUpperCaseSize = *(++pData) - 1;
    m_pDefaultUpperCase844 = ++pData;
    
    
    // pCasingData + 1 is for the default flag (word).
    // pCasingData[1] is the size in word for the upper case table (including the word for the size)
    // The last 1 word is for the size of the lower case table.
    pData = m_pDefaultUpperCase844 + m_nDefaultUpperCaseSize;
    m_nDefaultLowerCaseSize = *pData - 1;
    m_pDefaultLowerCase844 = ++pData;

    pData = m_pDefaultLowerCase844 + m_nDefaultLowerCaseSize;
    m_pDefaultTitleCaseSize = *pData - 1;
    m_pDefaultTitleCase844 = ++pData;
}


/*=============================AllocateDefaultTable=============================
**Action:  Allocates the default casing table, gets the exception header information
**         for all tables, and allocates the cache of individual tables.  This should
**         always be called before calling AllocateIndividualTable.
**Returns: TRUE if success. Otherwise, retrun FALSE.
**Arguments: None
**Exceptions: None
**
** NOTE NOTE NOTE NOTE NOTE NOTE
** This method requires synchronization.  Currently, we handle this through the 
** class initializer for System.Globalization.TextInfo.  If you need to call this
** outside of that paradigm, make sure to add your own synchronization.
==============================================================================*/
BOOL CasingTable::AllocateDefaultTable() {
    // This method is not thread-safe.  It needs managed code to provide syncronization.
    // The code is in the static ctor of TextInfo.
    if (m_pDefaultNativeTextInfo!=NULL)
        return (TRUE);
    
    LPWORD pLinguisticData =
        (LPWORD)MapDataFile(m_lpMappingName, m_lpFileName, &m_hDefaultCasingTable);
    SetData(pLinguisticData);

    m_pDefaultNativeTextInfo = new NativeTextInfo(m_pDefaultUpperCase844, m_pDefaultLowerCase844, m_pDefaultTitleCase844);
    if (m_pDefaultNativeTextInfo == NULL) {
        return (FALSE);
    }
    if (!GetExceptionHeader()) {
        return (FALSE);
    }

    return (TRUE);
}

NativeTextInfo* CasingTable::GetDefaultNativeTextInfo() {
    _ASSERTE(m_pDefaultNativeTextInfo != NULL);
    return (m_pDefaultNativeTextInfo);        
}

/*===========================InitializeNativeTextInfo============================
**Action: Verify that the correct casing table for a given lcid has already been
**        created.  Create it if it hasn't previously been.  
**Returns:    void
**Arguments:  The lcid for the table to be created.
**Exceptions: None.
**
** NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
** This method requires synchronization.  Currently we're okay because we synchronize
** in the ctor of System.Globalization.TextInfo.  If you add any different code paths,
** make sure that you also add the appropriate synchronization.
==============================================================================*/
NativeTextInfo* CasingTable::InitializeNativeTextInfo(int lcid) {    
    _ASSERTE(m_pExceptionHeader != NULL);
    //
    //Check to see if the locale has any exceptions.  
    //
    for (int i = 0; i < m_nExceptionCount; i++) {
        if (m_pExceptionHeader[i].Locale == (DWORD)lcid) {
            //
            //If this locale has exceptions and we haven't yet allocated the table,
            //go ahead and allocate it now.  Cache the result in m_ppExceptionTextInfoArray.
            //
            if (m_ppExceptionTextInfoArray[i] == NULL) {
                m_ppExceptionTextInfoArray[i] = CreateNativeTextInfo(i);
                if (m_ppExceptionTextInfoArray[i]==NULL) {
                    for (int j=0; j<i; j++) {
                        delete m_ppExceptionTextInfoArray[j];
                    }
                    return NULL;
                }
            }
            return (m_ppExceptionTextInfoArray[i]);
        }
    }
    return (m_pDefaultNativeTextInfo);
}

// This can not be a static method because MapDataFile() is not a static method anymore after
// adding the Assembly versioning support in NLSTable.
BOOL CasingTable::GetExceptionHeader() {
    if (m_pExceptionHeader == NULL) {
        //Create the file mapping for the file containing our exception information.
        LPWORD pData = (LPWORD)MapDataFile(m_lpExceptionMappingName, m_lpExceptionFileName, &m_hExceptionHeader);
        
        //This is the total number of cultures with exceptions.
        m_nExceptionCount = MAKELONG(pData[0], pData[1]);

        // Skip the DWORD which contains the number of linguistic casing tables.
        m_pExceptionHeader = (PL_EXCEPT_HDR)(pData + 2);

        // Skip m_nExceptionCount count of L_EXCEPT_HDR.
        m_pExceptionData   = (PL_EXCEPT)(m_pExceptionHeader + m_nExceptionCount);

        //
        // Create m_ppExceptionTextInfoArray, and initialize the pointers to NULL.
        // m_ppExceptionTextInfoArray holds pointers to all of the tables including the default
        // casing table
        //
        m_ppExceptionTextInfoArray = new PNativeTextInfo[m_nExceptionCount];
        if (m_ppExceptionTextInfoArray == NULL) {
            return (FALSE);
        }
        ZeroMemory((LPVOID)m_ppExceptionTextInfoArray, m_nExceptionCount * sizeof (PNativeTextInfo));
    }
    return (TRUE);
}


//
// Creating the linguistic casing table according to the given exceptIndex.
//
NativeTextInfo* CasingTable::CreateNativeTextInfo(int exceptIndex) {
    //
    // Create a file mapping, and copy the default table into this region.
    //

    _ASSERTE(m_ppExceptionTextInfoArray[exceptIndex]==NULL);

    PCASE pUpperCase = new (nothrow) WORD[m_nDefaultUpperCaseSize];    
    if (!pUpperCase) {
        return NULL; // This will be caught lower down and an OM exception will be thrown.
    }
    PCASE pLowerCase = new (nothrow) WORD[m_nDefaultLowerCaseSize];    
    if (!pLowerCase) {
        delete [] pUpperCase;
        return NULL; // This will be caught lower down and an OM exception will be thrown.
    }

    CopyMemory((LPVOID)pUpperCase, (LPVOID)m_pDefaultUpperCase844, m_nDefaultUpperCaseSize * sizeof(WORD));
    CopyMemory((LPVOID)pLowerCase, (LPVOID)m_pDefaultLowerCase844, m_nDefaultLowerCaseSize * sizeof(WORD));    
    
    PL_EXCEPT except ;
    
    //
    // Fix up linguistic uppercasing.
    //
    except = (PL_EXCEPT)((LPWORD)m_pExceptionData + m_pExceptionHeader[ exceptIndex ].Offset);
    
    for (DWORD i = 0; i < m_pExceptionHeader[exceptIndex].NumUpEntries; i++, except++) {
        Traverse844Word(pUpperCase, except->UCP) = except->AddAmount;
    }

    //
    // Fix up linguistic lowercasing.
    //
    // Now except points to the beginning of lowercaseing exceptions.
    //
    for (i = 0; i < m_pExceptionHeader[exceptIndex].NumLoEntries; i++, except++) {
        Traverse844Word(pLowerCase, except->UCP) = except->AddAmount;
    }

    NativeTextInfo* pNewTable = new (nothrow) NativeTextInfo(pUpperCase, pLowerCase, m_pDefaultTitleCase844);
    if (!pNewTable) {
        delete [] pUpperCase;
        delete [] pLowerCase;
    }
    _ASSERTE(pNewTable);
    return (pNewTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\comnlsinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    COMNlsInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This module implements the methods of the COMNlsInfo
//            class.  These methods are the helper functions for the
//            Locale class.
//
//  Date:     August 12, 1998
//
////////////////////////////////////////////////////////////////////////////


//
//  Include Files.
//

#include "common.h"
#include "object.h"
#include "excep.h"
#include "vars.hpp"
#include "COMString.h"
#include "InteropUtil.h"
#include <winnls.h>
#include <mlang.h>
#include "utilcode.h"
#include "frames.h"
#include "field.h"
#include "MetaSig.h"
#include "ComNLS.h"
#include "gcscan.h"
#include "COMNlsInfo.h"
#include "NLSTable.h"
#include "NativeTextInfo.h"
#include "CasingTable.h"        // class CasingTable
#include "GlobalizationAssembly.h"
#include "SortingTableFile.h"
#include "SortingTable.h"
#include "BaseInfoTable.h"
#include "CultureInfoTable.h"
#include "RegionInfoTable.h"
#include "CalendarTable.h"
#include "wsperf.h"

#include "UnicodeCatTable.h"

// Used by nativeGetSystemDefaultUILanguage() to retrieve UI language in NT 3.5 or later 
// (except Windows 2000)
#define RESOURCE_LOCALE_KEY L".Default\\Control Panel\\desktop\\ResourceLocale"

// Used by EnumLangProc() to retrieve resource language in Win 9x.
typedef struct _tagLANGINFO {
    LANGID LangID;
    INT    Count;
} LANGINFO,*PLANGINFO;


//
//  Constant Declarations.
//
#ifndef COMPARE_OPTIONS_ORDINAL
#define COMPARE_OPTIONS_ORDINAL            0x40000000
#endif

#ifndef COMPARE_OPTIONS_IGNORECASE
#define COMPARE_OPTIONS_IGNORECASE            0x00000001
#endif

#define NLS_CP_MBTOWC             0x40000000                    
#define NLS_CP_WCTOMB             0x80000000                    

#define MAX_STRING_VALUE        512

// Language ID for Traditional Chinese (CHT)
#define LANGID_ZH_CHT           0x7c04
// Language ID for CHT (Taiwan)
#define LANGID_ZH_TW            0x0404
// Language ID for CHT (Hong-Kong)
#define LANGID_ZH_HK            0x0c04
#define REGION_NAME_0404 L"\x53f0\x7063"

CasingTable* COMNlsInfo::m_pCasingTable = NULL;
LoaderHeap *COMNlsInfo::m_pNLSHeap=NULL;

//
// GB18030 implementation
//
#define CODEPAGE_GBK 936
#define GB18030_DLL     L"c_g18030.dll"
HMODULE COMNlsInfo::m_hGB18030 = NULL;
PFN_GB18030_UNICODE_TO_BYTES COMNlsInfo::m_pfnGB18030UnicodeToBytesFunc = NULL;
PFN_GB18030_BYTES_TO_UNICODE COMNlsInfo::m_pfnGB18030BytesToUnicodeFunc = NULL;
IMultiLanguage* COMNlsInfo::m_pIMultiLanguage = NULL;
int COMNlsInfo::m_cRefIMultiLanguage = 0;


//
// BUGBUG YSLin: Check for calls that can be made into FCALLs so we can remove unnecessary ECALLs.
// 
BOOL COMNlsInfo::InitializeNLS() {
    CultureInfoTable::InitializeTable();
    RegionInfoTable::InitializeTable();
    CalendarTable::InitializeTable();
    m_pNLSHeap = new LoaderHeap(4096, 4096);
    WS_PERF_ADD_HEAP(NLS_HEAP, m_pNLSHeap);
    return TRUE; //Made a boolean in case we have further initialization in the future.
}

#ifdef SHOULD_WE_CLEANUP
BOOL COMNlsInfo::ShutdownNLS() {

    NativeGlobalizationAssembly::ShutDown();
    CultureInfoTable::ShutdownTable();
    RegionInfoTable::ShutdownTable();
    CalendarTable::ShutdownTable();
    CharacterInfoTable::ShutDown();

    if (m_pCasingTable) {
        delete m_pCasingTable;
    }
    
    if (m_pNLSHeap) {
        delete m_pNLSHeap;
    }

    return (TRUE);
}
#endif /* SHOULD_WE_CLEANUP */

/*============================nativeCreateGlobalizationAssembly============================
**Action: Create NativeGlobalizationAssembly instance for the specified Assembly.
**Returns: 
**  void.  
**  The side effect is to allocate the NativeCompareInfo cache.
**Arguments:  None
**Exceptions: OutOfMemoryException if we run out of memory.
** 
**NOTE NOTE: This is a synchronized operation.  The required synchronization is
**           provided by the fact that we only call this in the class initializer
**           for CompareInfo.  If this invariant ever changes, guarantee 
**           synchronization.
==============================================================================*/
LPVOID __stdcall COMNlsInfo::nativeCreateGlobalizationAssembly(CreateGlobalizationAssemblyArg *pArgs) {
    THROWSCOMPLUSEXCEPTION();

    NativeGlobalizationAssembly* pNGA;
    Assembly *pAssembly = pArgs->pAssembly->GetAssembly();

    if ((pNGA = NativeGlobalizationAssembly::FindGlobalizationAssembly(pAssembly))==NULL) {
        // Get the native pointer to Assembly from the ASSEMBLYREF, and use the pointer
        // to construct NativeGlobalizationAssembly.
        pNGA = new NativeGlobalizationAssembly(pAssembly);
        if (pNGA == NULL) {
            COMPlusThrowOM();
        }
        
        // Always add the newly created NGA to the static linked list of NativeGlobalizationAssembly.
        // This step is necessary so that we can shut down the SortingTable correctly.
        NativeGlobalizationAssembly::AddToList(pNGA);
    }

    RETURN(pNGA, LPVOID);
}

/*=============================InitializeNativeCompareInfo==============================
**Action: A very thin wrapper on top of the NativeCompareInfo class that prevents us
**        from having to include SortingTable.h in ecall.
**Returns: The LPVOID pointer to the constructed NativeCompareInfo for the specified sort ID.
**        The side effect is to allocate a particular sorting table
**Arguments:
**        pAssembly the NativeGlobalizationAssembly instance used to load the sorting data tables.
**        sortID    the sort ID.
**Exceptions: OutOfMemoryException if we run out of memory.
**            ExecutionEngineException if the needed resources cannot be loaded.
** 
**NOTE NOTE: This is a synchronized operation.  The required synchronization is
**           provided by making CompareInfo.InitializeSortTable a sychronized
**           operation.  If you call this method from anyplace else, ensure 
**           that synchronization remains intact.
==============================================================================*/
LPVOID __stdcall COMNlsInfo::InitializeNativeCompareInfo(InitializeNativeCompareInfoArgs *pargs) {
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(pargs);
    
    // Ask the SortingTable instance in pNativeGlobalizationAssembly to get back the 
    // NativeCompareInfo object for the specified LCID.
    NativeGlobalizationAssembly* pNGA = (NativeGlobalizationAssembly*)(pargs->pNativeGlobalizationAssembly);
    NativeCompareInfo* pNativeCompareInfo = 
        pNGA->m_pSortingTable->InitializeNativeCompareInfo(pargs->sortID);

    if (pNativeCompareInfo == NULL) {
        COMPlusThrowOM();
    }
        
    RETURN(pNativeCompareInfo, LPVOID);
}



////////////////////////////////////////////////////////////////////////////
//
//  IsSupportedLCID
//
////////////////////////////////////////////////////////////////////////////

FCIMPL1(INT32, COMNlsInfo::IsSupportedLCID, INT32 lcid) {
    return (::IsValidLocale(lcid, LCID_SUPPORTED));
}
FCIMPLEND


FCIMPL1(INT32, COMNlsInfo::IsInstalledLCID, INT32 lcid) {
    BOOL bResult = ::IsValidLocale(lcid, LCID_INSTALLED);
    if (!OnUnicodeSystem() && bResult) {
        // In Windows 9x, there is bug in IsValidLocale().  Sometimes this API reports
        // TRUE if locales that are not actually installed.
        // So for these platforms, we do extra checking by calling GetLocaleInfo() to
        // see if it succeeds.

        // Note here that we have to explicitly call the A version, since W version is only
        // a stub in Win9x.
        if (GetLocaleInfoA(lcid, LOCALE_SENGLANGUAGE, NULL, 0) == 0) {
            // The call to GetLocaleInfo() failed. This locale is not installed although
            // IsValidLocale(lcid, LCID_INSTALLED) tells us it is installed.
            bResult = FALSE;
        }
    }
    return (bResult);
}
FCIMPLEND


////////////////////////////////////////////////////////////////////////////
//
//  nativeGetUserDefaultLCID
//
////////////////////////////////////////////////////////////////////////////

FCIMPL0(INT32, COMNlsInfo::nativeGetUserDefaultLCID) {
    return (::GetUserDefaultLCID());
}
FCIMPLEND

/*++

Routine Description:

    Get the UI language when the GetUserDefaultUILanguage() is 0x0404.  
    NOTE: Call this functions only when GetUserDefaultUILanguage() returns 0x0404.  
    
    When GetUserDefaultUILanguage() returns 0x0404, we should consider 3 cases:
        * W2k/XP MUI system with CHT selected, we should return 0x0404 (zh-TW).
        * W2k/XP Taiwan machine, we should return 0x0404 (zh-TW)
        * W2k/XP Hong-Kong machine, we should return 0x0c04 (zh-HK)

    This method first calls GetSystemDefaultUILanguage() to check if this is a localized CHT system.
    If not, 0x0404 is returned.
    Otherwise, this method exames the native region name
    of 0x0404 to tell the differences between zh-TW/zh-HK.  This is working because native region names are
    different in CHT and CHH build.

Arguments:

    None.

Return Value:

    The UI language ID of the localized CHT build.  The value can be:
        0x0404 (Taiwan)
        0x0c04 (Hong-Kong)

--*/


INT32 COMNlsInfo::GetCHTLangauge()
{
    int langID = LANGID_ZH_TW;

    if (CallGetSystemDefaultUILanguage() == LANGID_ZH_TW)
    {
        // This is a CHT localized system, this could be either a Hong-Kong build or Taiwan build.
        // We can tell the differences by checking the native region name.
        WCHAR wszBuffer[32];
        int result = GetLocaleInfoW(LANGID_ZH_TW, LOCALE_SNATIVECTRYNAME, wszBuffer, sizeof(wszBuffer)/sizeof(WCHAR));
        if (result)
        {
            // For any non-Taiwan SKU (including HK), the native region name uses the string \x53f0\x7063.
            // For Taiwan SKU, the native region name is different.
            if (wcsncmp(wszBuffer, REGION_NAME_0404, 3) == 0)
            {
                 // This is a Hong-Kong build.
                 langID = LANGID_ZH_HK;
            } else
            {
                // This is a Taiwan build. Do nothing here.
                // langID = LANGID_ZH_TW;
            }
        }
    }
    // If this is not a CHT localized system, retrun zh-TW (0x0404)
    return (langID);
}

/*
    The order goes as the following:
        1. Try to call GetUserDefaultUILanguage().
        2. If fails, call nativeGetSystemDefaultUILanguage().
 */
INT32 __stdcall COMNlsInfo::nativeGetUserDefaultUILanguage(
    VoidArgs* pargs)
{
    THROWSCOMPLUSEXCEPTION();
    ASSERT(pargs != NULL);
    LANGID uiLangID = 0;

#ifdef PLATFORM_WIN32
    //
    // Test if the platform has the GetUserDefaultUILanguage() API.
    // Currently, this is supported  by Windows 2000 only.
    // 
    HINSTANCE hKernel32 ;
    typedef LANGID (GET_USER_DEFAULT_UI_LANGUAGE)(VOID);
    GET_USER_DEFAULT_UI_LANGUAGE* pGetUserDefaultUILanguage;

    hKernel32 = WszLoadLibrary(L"Kernel32.dll");
    if (hKernel32 != NULL) {

        pGetUserDefaultUILanguage = 
            (GET_USER_DEFAULT_UI_LANGUAGE*)GetProcAddress(hKernel32, "GetUserDefaultUILanguage");
        FreeLibrary(hKernel32);        

        if (pGetUserDefaultUILanguage != NULL)
        {
            uiLangID = (*pGetUserDefaultUILanguage)();
            if (uiLangID != 0) {
                if (uiLangID == LANGID_ZH_TW)
                {
                    // If the UI language ID is 0x0404, we need to do extra check to decide
                    // the real UI lanauge, since MUI (in CHT)/HK/TW Windows SKU all uses 0x0404 as their CHT language ID.
                    return (GetCHTLangauge());
                }            
                return (uiLangID);
            }
        }
    }
    uiLangID = GetDownLevelSystemDefaultUILanguage();
#endif // PLATFORM_WIN32

    if (uiLangID == 0) {
        uiLangID = GetUserDefaultLangID();
    }
    // Return the found language ID.
    return (uiLangID);    
}

#ifdef PLATFORM_WIN32
//
// NOTENOTE yslin: The code to detect UI language in NT 3.5 is from Windows 2000 Setup 
// provided by ScottHsu.
//
BOOL CALLBACK COMNlsInfo::EnumLangProc(
    HMODULE hModule,     // resource-module handle
    LPCWSTR lpszType,   // pointer to resource type
    LPCWSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LPARAM lParam     // application-defined parameter
   )
/*++

Routine Description:

    Callback that counts versions stamps.

Arguments:

    Details of version enumerated version stamp. (Ignore.)

Return Value:

    Indirectly thru lParam: count, langID

--*/
{
    PLANGINFO LangInfo;

    LangInfo = (PLANGINFO) lParam;

    LangInfo->Count++;

    //
    // for localized build contains multiple resource, 
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time 
    //
    if ((wIDLanguage == 0x409) && (LangInfo->LangID != 0)) {
        return (TRUE);
    }

    LangInfo->LangID  = wIDLanguage;

    return (TRUE);        // continue enumeration
}

//
// NOTENOTE yslin: The code to detect UI language in NT 3.5 is from Windows 2000 Setup 
// provided by ScottHsu.
//

LANGID COMNlsInfo::GetNTDLLNativeLangID()
/*++

Routine Description:

    This function is designed specifically for getting native lang of ntdll.dll
    
    This is not a generic function to get other module's language
    
    the assumption is:
    
    1. if only one language in resource then return this lang
    
    2. if two languages in resource then return non-US language
    
    3. if more than two languages, it's invalid in our case, but returns the last one.

Arguments:

    None

Return Value:

    Native lang ID in ntdll.dll

--*/
{
    THROWSCOMPLUSEXCEPTION();

    //
    // NOTE yslin: We don't need to use ANSI version of functions here because only 
    // NT will call this function.
    //

    // The following is expanded from RT_VERSION
    // #define RT_VERSION      MAKEINTRESOURCE(16)
    // #define MAKEINTRESOURCE  MAKEINTRESOURCEW
    // #define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((WORD)(i)))
    LPCTSTR Type = (LPCWSTR) ((LPVOID)((WORD)16));
    LPCTSTR Name = (LPCWSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));
    
    //OnUnicodeSystem doesn't have the mutent in it, so it should always return the
    //correct result for whether we are on a Unicode box.
    _ASSERTE(OnUnicodeSystem() && "We should never use this codepath on a non-unicode OS.");

    //Get the HModule for ntdll.
    HMODULE hMod = WszGetModuleHandle(L"ntdll.dll");
    if (hMod==NULL) {
        return (0);
    }

    //This will call the "W" version.
    BOOL result = WszEnumResourceLanguages(hMod, Type, Name, EnumLangProc, (LPARAM) &LangInfo);
    
    if (!result || (LangInfo.Count > 2) || (LangInfo.Count < 1) ) {
        // so far, for NT 3.51, only JPN has two language resources
        return (0);
    }
    
    return (LangInfo.LangID);
}

//
// NOTENOTE yslin: The code to detect UI language in NT 3.5 is from Windows 2000 Setup 
// provided by ScottHsu.
//

/*=========================GetDownLevelSystemDefaultUILanguage=================
**Action: The GetSystemDefaultUILanguage API doesn't exist in downlevel systems 
**        (Windows NT 4.0 & Windows 9x),
**        so try to decide the UI languages from other sources.
**Returns: A valid UI language ID if success.  Otherwise, return 0.
**Arguments: Void.
==============================================================================*/

LANGID COMNlsInfo::GetDownLevelSystemDefaultUILanguage() {
    THROWSCOMPLUSEXCEPTION();
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    WCHAR           buffer[512];

    LANGID uiLangID = 0;
    
    OSVERSIONINFO   sVerInfo;
    sVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (WszGetVersionEx(&sVerInfo) && sVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // We are in Windows NT 3.5 or after (exculding Windows 2000).
        //
        // NOTENOTE yslin: The code to detect UI language in NT 3.5/4.0 is from Windows 2000 Setup 
        // provided by ScottHsu.
        //
        
        //
        // by looking into \\boneyard\intl, almost every ntdll.dll marked correct lang ID
        // so get langID from ntdll.dll
        //

        uiLangID = GetNTDLLNativeLangID();

        if (uiLangID == 0x0409) {
            if (IsHongKongVersion()) {
                uiLangID = 0x0C04;
            }
        }
    } else {
        //
        // We're on Win9x.
        //
        dwErr = WszRegOpenKeyEx( HKEY_USERS,
                              L".Default\\Control Panel\\desktop\\ResourceLocale",
                              0,
                              KEY_READ,
                              &hkey );

        if (dwErr == ERROR_SUCCESS) {

            dwSize = sizeof(buffer);
            dwErr = WszRegQueryValueEx( hkey,
                                     L"",
                                     NULL,  //reserved
                                     NULL,  //type
                                     (LPBYTE)buffer,
                                     &dwSize );

            if(dwErr == ERROR_SUCCESS) {
                uiLangID = LANGIDFROMLCID(WstrToInteger4(buffer,16));
            }
            RegCloseKey(hkey);
        }

        if ( dwErr != ERROR_SUCCESS ) {
           // Check HKLM\System\CurrentControlSet\Control\Nls\Locale

           dwErr = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                L"System\\CurrentControlSet\\Control\\Nls\\Locale",
                                0,
                                KEY_READ,
                                &hkey );

           if (dwErr == ERROR_SUCCESS) {
              dwSize = sizeof(buffer);
              dwErr = WszRegQueryValueEx( hkey,
                                        L"",
                                        NULL,  //reserved
                                        NULL,  //type
                                        (LPBYTE)buffer,
                                        &dwSize );

              if (dwErr == ERROR_SUCCESS) {
                  uiLangID = LANGIDFROMLCID(WstrToInteger4(buffer,16));
              }
              RegCloseKey(hkey);
           }
        }
    }

    return (uiLangID);
}

//
// NOTENOTE yslin: The code to detect UI language in NT 3.5 is from Windows 2000 Setup 
// provided by ScottHsu.
//
BOOL COMNlsInfo::IsHongKongVersion()
/*++

Routine Description:

    Try to identify HongKong NT 4.0
    
    It based on:
    
    NTDLL's language is English and build is 1381 and
    pImmReleaseContext return TRUE
    
Arguments:
    

Return Value:

   Language ID of running system

--*/
{
    HMODULE hMod;
    BOOL bRet=FALSE;
    typedef BOOL (*IMMRELEASECONTEXT)(HWND,HANDLE);
    IMMRELEASECONTEXT pImmReleaseContext;

    LANGID TmpID = GetNTDLLNativeLangID();

    if (/*(OsVersion.dwBuildNumber == 1381) &&*/ (TmpID == 0x0409)) {
        hMod = WszLoadLibrary(L"imm32.dll");
        if (hMod) {
            pImmReleaseContext = (IMMRELEASECONTEXT) GetProcAddress(hMod,"ImmReleaseContext");
            if (pImmReleaseContext) {
                bRet = pImmReleaseContext(NULL,NULL);
            }
            FreeLibrary(hMod);
        }
    }
    return (bRet);
}
#endif // PLATFORM_WIN32

/*++

Routine Description:

    This is just a thin wrapper to call GetSystemDefaultUILanguage() dynamically.
    
Arguments:
    None    

Return Value:

   Returns system default UI Language if GetSystemDefaultUILanguage() is available in the OS.
   Otherwise, 0 is returned.

--*/

INT32 COMNlsInfo::CallGetSystemDefaultUILanguage()
{
    HINSTANCE hKernel32;
    typedef LANGID (GET_SYSTEM_DEFAULT_UI_LANGUAGE)(VOID);
    GET_SYSTEM_DEFAULT_UI_LANGUAGE* pGetSystemDefaultUILanguage;

    hKernel32 = WszLoadLibrary(L"Kernel32.dll");
    if (hKernel32 != NULL) {
        pGetSystemDefaultUILanguage = 
            (GET_SYSTEM_DEFAULT_UI_LANGUAGE*)GetProcAddress(hKernel32, "GetSystemDefaultUILanguage");
        FreeLibrary(hKernel32);

        if (pGetSystemDefaultUILanguage != NULL)
        {
            LCID uiLangID = (*pGetSystemDefaultUILanguage)();
            if (uiLangID != 0) {
                return (uiLangID);
            }
        }
    }
    return (0);
}


// Windows 2000 or other OS that support GetSystemDefaultUILanguage():
//    Call GetSystemDefaultUILanguage().
// NT
//    check ntdll's language, 
//    we scaned all 3.51's ntdll on boneyard\intl,
//    it looks like we can trust them.
//    
// Win9x                                                           
//    Use default user's resource language    
 
INT32 __stdcall COMNlsInfo::nativeGetSystemDefaultUILanguage(
    VoidArgs* pargs)
{
    THROWSCOMPLUSEXCEPTION();
    ASSERT(pargs != NULL);
    LANGID uiLangID = 0;

#ifdef PLATFORM_WIN32 
    uiLangID = CallGetSystemDefaultUILanguage();
    if (uiLangID != 0)
    {
        return (uiLangID);
    }
    // GetSystemDefaultUILanguage doesn't exist in downlevel systems (Windows NT 4.0 & Windows 9x)
    // , try to decide the UI languages from other sources.
    uiLangID = GetDownLevelSystemDefaultUILanguage();
#endif // PLATFORM_WIN32

    if (uiLangID == 0)
    {
        uiLangID = ::GetSystemDefaultLangID();
    }
    
    return (uiLangID);
}

////////////////////////////////////////////////////////////////////////////
//
//  WstrToInteger4
//
////////////////////////////////////////////////////////////////////////////

/*=================================WstrToInteger4==================================
**Action: Convert a Unicode string to an integer.  Error checking is ignored.
**Returns: The integer value of wstr
**Arguments:
**      wstr: NULL terminated wide string.  Can have character 0'-'9', 'a'-'f', and 'A' - 'F'
**      Radix: radix to be used in the conversion.
**Exceptions: None.
==============================================================================*/

INT32 COMNlsInfo::WstrToInteger4(
    LPWSTR wstr,
    int Radix)
{
    INT32 Value = 0;
    int Base = 1;

    for (int Length = Wszlstrlen(wstr) - 1; Length >= 0; Length--)

    {
        WCHAR ch = wstr[Length];
        _ASSERTE((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'));
        if (ch >= 'a')
        {
            ch = ch - 'a' + 'A';
        }

        Value += ((ch >= 'A') ? (ch - 'A' + 10) : (ch - '0')) * Base;
        Base *= Radix;
    }

    return (Value);
}


/*=================================StrToInteger4==================================
**Action: Convert an ANSI string to an integer.  Error checking is ignored.
**Returns: The integer value of str
**Arguments:
**      str: NULL terminated ANSI string.  Can have character 0'-'9', 'a'-'f', and 'A' - 'F'
**      Radix: radix to be used in the conversion.
**Exceptions: None.
==============================================================================*/

INT32 COMNlsInfo::StrToInteger4(
    LPSTR str,
    int Radix)
{
    INT32 Value = 0;
    int Base = 1;

    for (int Length = (int)strlen(str) - 1; Length >= 0; Length--)
    {
        char ch = str[Length];
        _ASSERTE((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'));
        if (ch >= 'a')
        {
            ch = ch - 'a' + 'A';
        }

        Value += ((ch >= 'A') ? (ch - 'A' + 10) : (ch - '0')) * Base;
        Base *= Radix;
    }

    return (Value);
}

////////////////////////////////////////////////////////////////////////////
//
//  nativeGetLocaleInfo
//
////////////////////////////////////////////////////////////////////////////

LPVOID __stdcall COMNlsInfo::nativeGetLocaleInfo(
    CultureInfo_GetLocaleInfoArgs* pargs)
{
    ASSERT(pargs != NULL);
    THROWSCOMPLUSEXCEPTION();

    LANGID langID = (LANGID)pargs->LangID;

    _ASSERTE(SORTIDFROMLCID(langID) == 0);
    _ASSERTE(::IsValidLocale(langID, LCID_SUPPORTED));

    //
    //  @ToDo: Use the UI language here.
    //
    switch (pargs->LCType)
    {
        case ( LOCALE_SCOUNTRY ) :
        {
            pargs->LCType = LOCALE_SENGCOUNTRY;
            break;
        }
        case ( LOCALE_SLANGUAGE ) :
        {
            pargs->LCType = LOCALE_SENGLANGUAGE;
            break;
        }
    }

    if (OnUnicodeSystem())
    {
        //
        //  The returned size includes the NULL character.
        //
        int ResultSize = 0;

        ASSERT_API(ResultSize = GetLocaleInfoW( langID,
                                                pargs->LCType,
                                                NULL,
                                                0 ));

        STRINGREF Result = AllocateString(ResultSize);
        WCHAR *ResultChars = Result->GetBuffer();

        ASSERT_API(GetLocaleInfoW( langID,
                                   pargs->LCType,
                                   ResultChars,
                                   ResultSize ));

        Result->SetStringLength(ResultSize - 1);
        ResultChars[ResultSize - 1] = 0;

        RETURN(Result, STRINGREF);        
    }

    int MBSize = 0;
    ASSERT_API(MBSize = GetLocaleInfoA(langID, pargs->LCType, NULL, 0));

    char* MBResult = new char[MBSize];
    if (!MBResult)
    {
        COMPlusThrowOM();
    }
    ASSERT_API(GetLocaleInfoA(langID, pargs->LCType, MBResult, MBSize))

    int ResultSize = 0;
    ASSERT_API(ResultSize = WszMultiByteToWideChar(CP_ACP,
                                                    MB_PRECOMPOSED,
                                                    MBResult,
                                                    MBSize,
                                                    NULL,
                                                    0 ));

    STRINGREF Result = AllocateString(ResultSize);
    WCHAR* ResultChars = Result->GetBuffer();

    ASSERT_API(WszMultiByteToWideChar(CP_ACP,
                                       MB_PRECOMPOSED,
                                       MBResult,
                                       MBSize,
                                       ResultChars,
                                       ResultSize ));

    Result->SetStringLength(ResultSize - 1);
    Result->GetBuffer()[ResultSize - 1] = 0;
    
    RETURN(Result, STRINGREF);

}

/*=================================nativeInitCultureInfoTable============================
**Action: Create the default instance of CultureInfoTable.
**Returns: void.
**Arguments: void.
**Exceptions:
**      OutOfMemoryException if the creation fails.
==============================================================================*/

VOID __stdcall COMNlsInfo::nativeInitCultureInfoTable(VoidArgs* pArg) {
    _ASSERTE(pArg);
    CultureInfoTable::CreateInstance();
}

/*==========================GetCultureInfoStringPoolTable======================
**Action: Return a pointer to the String Pool Table string in CultureInfoTable.
**        No range checking of any sort is performed.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL1(LPWSTR, COMNlsInfo::nativeGetCultureInfoStringPoolStr, INT32 offset) {
    _ASSERTE(CultureInfoTable::GetInstance());
    return (CultureInfoTable::GetInstance()->GetStringPoolTable() + offset);
}
FCIMPLEND

/*=========================nativeGetCultureInfoHeader======================
**Action: Return a pointer to the header in
**        CultureInfoTable.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL0(CultureInfoHeader*, COMNlsInfo::nativeGetCultureInfoHeader) {
    _ASSERTE(CultureInfoTable::GetInstance());
    return (CultureInfoTable::GetInstance()->GetHeader());
}
FCIMPLEND

/*=========================GetCultureInfoNameOffsetTable======================
**Action: Return a pointer to an item in the Culture Name Offset Table in
**        CultureInfoTable.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL0(NameOffsetItem*, COMNlsInfo::nativeGetCultureInfoNameOffsetTable) {
    _ASSERTE(CultureInfoTable::GetInstance());
    return (CultureInfoTable::GetInstance()->GetNameOffsetTable());
}
FCIMPLEND

/*=======================nativeGetCultureDataFromID=============================
**Action: Given a culture ID, return the index which points to
**        the corresponding record in Culture Data Table.  The index is referred
**        as 'Culture Data Item Index' in the code.
**Returns: an int index points to a record in Culture Data Table.  If no corresponding
**         index to return (because the culture ID is valid), -1 is returned.
**Arguments:
**         culture ID the specified culture ID.
**Exceptions: None.
==============================================================================*/

FCIMPL1(INT32,COMNlsInfo::nativeGetCultureDataFromID, INT32 nCultureID) {
    return (CultureInfoTable::GetInstance()->GetDataItem(nCultureID));
}
FCIMPLEND

/*=============================GetCultureInt32Value========================
**Action: Return the WORD value for a specific information of a culture.
**        This is used to query values like 'the number of decimal digits' for
**        a culture.
**Returns: An int for the required value (However, the value is always in WORD range).
**Arguments:
**      nCultureDataItem    the Culture Data Item index.  This is an index 
**                          which points to the corresponding record in the
**                          Culture Data Table.
**      nValueField  an integer indicating which fields that we are interested.
**                  See CultureInfoTable.h for a list of the fields.
**Exceptions:
==============================================================================*/

FCIMPL3(INT32, COMNlsInfo::GetCultureInt32Value, INT32 CultureDataItem, INT32 ValueField, BOOL UseUserOverride) {
    INT32 retVal = 0;

    retVal = CultureInfoTable::GetInstance()->GetInt32Data(CultureDataItem, ValueField, UseUserOverride);
    return (retVal);
}
FCIMPLEND

FCIMPL2(INT32, COMNlsInfo::GetCultureDefaultInt32Value, INT32 CultureDataItem, INT32 ValueField) {
    INT32 retVal = 0;

    retVal = CultureInfoTable::GetInstance()->GetDefaultInt32Data(CultureDataItem, ValueField); 
    return (retVal);
}
FCIMPLEND


LPVOID __stdcall COMNlsInfo::GetCultureStringValue(CultureInfo_GetCultureInfoArgs3* pArgs) {
    // This can not be a FCALL since new string are allocated.
    _ASSERTE(pArgs);
    WCHAR InfoStr[MAX_STRING_VALUE];
    LPWSTR pStringValue = CultureInfoTable::GetInstance()->GetStringData(pArgs->CultureDataItem, pArgs->ValueField, pArgs->UseUserOverride, InfoStr, MAX_STRING_VALUE);
    RETURN(COMString::NewString(pStringValue), STRINGREF);
}

LPVOID __stdcall COMNlsInfo::GetCultureDefaultStringValue(CultureInfo_GetCultureInfoArgs2* pArgs) {
    _ASSERTE(pArgs);    
    LPWSTR pInfoStr = CultureInfoTable::GetInstance()->GetDefaultStringData(pArgs->CultureDataItem, pArgs->ValueField);
    RETURN(COMString::NewString(pInfoStr), STRINGREF);
}


/*=================================GetMultiStringValues==========================
**Action:
**Returns:
**Arguments:
**Exceptions:
============================================================================*/

LPVOID COMNlsInfo::GetMultiStringValues(LPWSTR pInfoStr) {

    THROWSCOMPLUSEXCEPTION();

    //
    // Get the first string.
    //
    if (pInfoStr == NULL) {
        return (NULL);
    }

    //
    // Create a dynamic array to store multiple strings.
    //
    CUnorderedArray<WCHAR *, CULTUREINFO_OPTIONS_SIZE> * pStringArray;
    pStringArray = new CUnorderedArray<WCHAR *, CULTUREINFO_OPTIONS_SIZE>();
    
    if (!pStringArray) {
        COMPlusThrowOM();
    }

    //
    // We can't store STRINGREFs in an unordered array because the GC won't track
    // them properly.  To work around this, we'll count the number of strings
    // which we need to allocate and store a wchar* for the beginning of each string.
    // In the loop below, we'll walk this array of wchar*'s and allocate a managed
    // string for each one.
    //
    while (*pInfoStr != NULL) {
        *(pStringArray->Append()) = pInfoStr;
        //
        // Advance to next string.
        //
        pInfoStr += (Wszlstrlen(pInfoStr) + 1);
    }


    //
    // Allocate the array of STRINGREFs.  We don't need to check for null because the GC will throw 
    // an OutOfMemoryException if there's not enough memory.
    //
    PTRARRAYREF ResultArray = (PTRARRAYREF)AllocateObjectArray(pStringArray->Count(), g_pStringClass);

    LPVOID lpvReturn;
    STRINGREF pString;
    INT32 stringCount = pStringArray->Count();

    //
    // Walk the wchar*'s and allocate a string for each one which we put into the result array.
    //
    GCPROTECT_BEGIN(ResultArray);    
    for (int i = 0; i < stringCount; i++) {
        pString = COMString::NewString(pStringArray->m_pTable[i]);    
        ResultArray->SetAt(i, (OBJECTREF)pString);
    }
    *((PTRARRAYREF *)(&lpvReturn))=ResultArray;
    GCPROTECT_END();

    delete (pStringArray);

    return (lpvReturn);    
}

LPVOID __stdcall COMNlsInfo::GetCultureMultiStringValues(CultureInfo_GetCultureInfoArgs3* pArgs) {    
    _ASSERTE(pArgs);
    WCHAR InfoStr[MAX_STRING_VALUE];
    LPWSTR pMultiStringValue = CultureInfoTable::GetInstance()->GetStringData(
        pArgs->CultureDataItem, pArgs->ValueField, pArgs->UseUserOverride, InfoStr, MAX_STRING_VALUE);
    return (GetMultiStringValues(pMultiStringValue));
}

/*=================================nativeInitRegionInfoTable============================
**Action: Create the default instance of RegionInfoTable.
**Returns: void.
**Arguments: void.
**Exceptions:
**      OutOfMemoryException if the creation fails.
==============================================================================*/

VOID __stdcall COMNlsInfo::nativeInitRegionInfoTable(VoidArgs* pArg) {
    _ASSERTE(pArg);
    RegionInfoTable::CreateInstance();
}

/*==========================GetRegionInfoStringPoolTable======================
**Action: Return a pointer to the String Pool Table string in RegionInfoTable.
**        No range checking of any sort is performed.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL1(LPWSTR, COMNlsInfo::nativeGetRegionInfoStringPoolStr, INT32 offset) {
    _ASSERTE(RegionInfoTable::GetInstance());
    return (RegionInfoTable::GetInstance()->GetStringPoolTable() + offset);
}
FCIMPLEND

/*=========================nativeGetRegionInfoHeader======================
**Action: Return a pointer to the header in
**        RegionInfoTable.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL0(CultureInfoHeader*, COMNlsInfo::nativeGetRegionInfoHeader) {
    _ASSERTE(RegionInfoTable::GetInstance());
    return (RegionInfoTable::GetInstance()->GetHeader());
}
FCIMPLEND

/*=========================GetRegionInfoNameOffsetTable======================
**Action: Return a pointer to an item in the Region Name Offset Table in
**        RegionInfoTable.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL0(NameOffsetItem*, COMNlsInfo::nativeGetRegionInfoNameOffsetTable) {
    _ASSERTE(RegionInfoTable::GetInstance());
    return (RegionInfoTable::GetInstance()->GetNameOffsetTable());
}
FCIMPLEND

/*=======================nativeGetRegionDataFromID=============================
**Action: Given a Region ID, return the index which points to
**        the corresponding record in Region Data Table.  The index is referred
**        as 'Region Data Item Index' in the code.
**Returns: an int index points to a record in Region Data Table.  If no corresponding
**         index to return (because the Region ID is valid), -1 is returned.
**Arguments:
**         Region ID the specified Region ID.
**Exceptions: None.
==============================================================================*/

FCIMPL1(INT32,COMNlsInfo::nativeGetRegionDataFromID, INT32 nRegionID) {
    _ASSERTE(RegionInfoTable::GetInstance());
    return (RegionInfoTable::GetInstance()->GetDataItem(nRegionID));
}
FCIMPLEND

/*=============================nativeGetRegionInt32Value========================
**Action: Return the WORD value for a specific information of a Region.
**        This is used to query values like 'the number of decimal digits' for
**        a Region.
**Returns: An int for the required value (However, the value is always in WORD range).
**Arguments:
**      nRegionDataItem    the Region Data Item index.  This is an index 
**                          which points to the corresponding record in the
**                          Region Data Table.
**      nValueField  an integer indicating which fields that we are interested.
**                  See RegionInfoTable.h for a list of the fields.
**Exceptions:
==============================================================================*/

INT32 __stdcall COMNlsInfo::nativeGetRegionInt32Value(CultureInfo_GetCultureInfoArgs3* pArgs) {
    _ASSERTE(pArgs);
    _ASSERTE(RegionInfoTable::GetInstance());
    return (RegionInfoTable::GetInstance()->GetInt32Data(pArgs->CultureDataItem, pArgs->ValueField, pArgs->UseUserOverride));
}

LPVOID __stdcall COMNlsInfo::nativeGetRegionStringValue(CultureInfo_GetCultureInfoArgs3* pArgs) {
    _ASSERTE(pArgs);    
    _ASSERTE(RegionInfoTable::GetInstance());
    WCHAR InfoStr[MAX_STRING_VALUE];
    LPWSTR pStringValue = RegionInfoTable::GetInstance()->GetStringData(
        pArgs->CultureDataItem, pArgs->ValueField, pArgs->UseUserOverride, InfoStr, MAX_STRING_VALUE);
    RETURN(COMString::NewString(pStringValue), STRINGREF);
}

/*=================================nativeInitCalendarTable============================
**Action: Create the default instance of CalendarTable.
**Returns: void.
**Arguments: void.
**Exceptions:
**      OutOfMemoryException if the creation fails.
==============================================================================*/

VOID __stdcall COMNlsInfo::nativeInitCalendarTable(VoidArgs* pArg) {
    _ASSERTE(pArg);
    CalendarTable::CreateInstance();
}

/*==========================GetCalendarStringPoolTable======================
**Action: Return a pointer to the String Pool Table string in CalendarTable.
**        No range checking of any sort is performed.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL1(LPWSTR, COMNlsInfo::nativeGetCalendarStringPoolStr, INT32 offset) {
    _ASSERTE(CalendarTable::GetInstance());
    _ASSERTE(offset >= 0);
    return (CalendarTable::GetInstance()->GetStringPoolTable() + offset);
}
FCIMPLEND

/*=========================nativeGetCalendarHeader======================
**Action: Return a pointer to the header in
**        CalendarTable.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

FCIMPL0(CultureInfoHeader*, COMNlsInfo::nativeGetCalendarHeader) {
    _ASSERTE(CalendarTable::GetInstance());
    return (CalendarTable::GetInstance()->GetHeader());
}
FCIMPLEND

/*=============================nativeGetCalendarInt32Value========================
**Action: Return the WORD value for a specific information of a Calendar.
**        This is used to query values like 'the number of decimal digits' for
**        a Calendar.
**Returns: An int for the required value (However, the value is always in WORD range).
**Arguments:
**      nCalendarDataItem    the Calendar Data Item index.  This is an index 
**                          which points to the corresponding record in the
**                          Calendar Data Table.
**      nValueField  an integer indicating which fields that we are interested.
**                  See CalendarTable.h for a list of the fields.
**Exceptions:
==============================================================================*/

INT32 __stdcall COMNlsInfo::nativeGetCalendarInt32Value(CultureInfo_GetCultureInfoArgs3* pArgs) {
    _ASSERTE(pArgs);
    _ASSERTE(CalendarTable::GetInstance());
    return (CalendarTable::GetInstance()->GetDefaultInt32Data(pArgs->CultureDataItem, pArgs->ValueField));
}

LPVOID __stdcall COMNlsInfo::nativeGetCalendarStringValue(CultureInfo_GetCultureInfoArgs3* pArgs) {
    _ASSERTE(pArgs);    
    _ASSERTE(CalendarTable::GetInstance());
    LPWSTR pInfoStr = CalendarTable::GetInstance()->GetDefaultStringData(pArgs->CultureDataItem, pArgs->ValueField);
    if (pInfoStr == NULL) {
        RETURN(NULL, STRINGREF);
    }
    RETURN(COMString::NewString(pInfoStr), STRINGREF);
}

LPVOID __stdcall COMNlsInfo::nativeGetCalendarMultiStringValues(CultureInfo_GetCultureInfoArgs3* pArgs) {    
    _ASSERTE(pArgs);
    WCHAR InfoStr[MAX_STRING_VALUE];
    LPWSTR pStringValue = CalendarTable::GetInstance()->GetStringData(
        pArgs->CultureDataItem, pArgs->ValueField, pArgs->UseUserOverride, InfoStr, MAX_STRING_VALUE);    
    return (GetMultiStringValues(pStringValue));
}

//
// This method is only called by Taiwan localized build.
// 
LPVOID __stdcall COMNlsInfo::nativeGetEraName(Int32Int32Arg* pArgs) {
    _ASSERTE(pArgs);

    int culture = pArgs->nValue1;
    int calID   = pArgs->nValue2;
    
    if (GetSystemDefaultLCID() != culture) {
        goto Exit;
    }
    int size;
    WCHAR eraName[64];
    if (size = WszGetDateFormat(culture, DATE_USE_ALT_CALENDAR , NULL, L"gg", eraName, sizeof(eraName)/sizeof(WCHAR))) {
        STRINGREF Result = AllocateString(size);
        wcscpy(Result->GetBuffer(), eraName);
        Result->SetStringLength(size - 1);
        RETURN(Result,STRINGREF);
    }
Exit:
    // Return an empty string.
    RETURN(COMString::NewString(0),STRINGREF);
}


/*=================================nativeInitRegionInfoTable============================
**Action: Create the default instance of RegionInfoTable.
**Returns: void.
**Arguments: void.
**Exceptions:
**      OutOfMemoryException if the creation fails.
==============================================================================*/

VOID __stdcall COMNlsInfo::nativeInitUnicodeCatTable(VoidArgs* pArg) {
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArg);
    CharacterInfoTable* pTable = CharacterInfoTable::CreateInstance();
    if (pTable == NULL) {
        COMPlusThrowOM();
    }
}

FCIMPL0(LPVOID, COMNlsInfo::nativeGetUnicodeCatTable) {
    _ASSERTE(CharacterInfoTable::GetInstance());
    return (LPVOID)(CharacterInfoTable::GetInstance()->GetCategoryDataTable());
}
FCIMPLEND

BYTE COMNlsInfo::GetUnicodeCategory(WCHAR wch) {
    THROWSCOMPLUSEXCEPTION();
    CharacterInfoTable* pTable = CharacterInfoTable::CreateInstance();
    if (pTable == NULL) {
        COMPlusThrowOM();
    }
    return (pTable->GetUnicodeCategory(wch));
}

BOOL COMNlsInfo::nativeIsWhiteSpace(WCHAR c) {
    // This is the native equivalence of CharacterInfo.IsWhiteSpace().
    // NOTENOTE YSLin:
    // There are characters which belong to UnicodeCategory.Control but are considered as white spaces.
    // We use code point comparisons for these characters here as a temporary fix.
    // The compiler should be smart enough to do a range comparison to optimize this (U+0009 ~ U+000d).
    // Also provide a shortcut here for the space character (U+0020)
    switch (c) {
        case ' ':
        case '\x0009' :
        case '\x000a' :
        case '\x000b' :
        case '\x000c' :
        case '\x000d' :
        case '\x0085' :
            return (TRUE);
    }
      
    BYTE uc = GetUnicodeCategory(c);
    switch (uc) {
        case (11):      // UnicodeCategory.SpaceSeparator
        case (12):      // UnicodeCategory.LineSeparator
        case (13):      // UnicodeCategory.ParagraphSeparator
            return (TRUE);    
    }
    return (FALSE);
}


FCIMPL0(LPVOID, COMNlsInfo::nativeGetUnicodeCatLevel2Offset) {
    _ASSERTE(CharacterInfoTable::GetInstance());
    return (LPVOID)(CharacterInfoTable::GetInstance()->GetCategoryLevel2OffsetTable());
}
FCIMPLEND

FCIMPL0(LPVOID, COMNlsInfo::nativeGetNumericTable) {
    _ASSERTE(CharacterInfoTable::GetInstance());
    return (LPVOID)(CharacterInfoTable::GetInstance()->GetNumericDataTable());
}
FCIMPLEND

FCIMPL0(LPVOID, COMNlsInfo::nativeGetNumericLevel2Offset) {
    _ASSERTE(CharacterInfoTable::GetInstance());
    return (LPVOID)(CharacterInfoTable::GetInstance()->GetNumericLevel2OffsetTable());
}
FCIMPLEND

FCIMPL0(LPVOID, COMNlsInfo::nativeGetNumericFloatData) {
    _ASSERTE(CharacterInfoTable::GetInstance());
    return (LPVOID)(CharacterInfoTable::GetInstance()->GetNumericFloatData());
}
FCIMPLEND

FCIMPL0(INT32, COMNlsInfo::nativeGetThreadLocale)
{
    return (::GetThreadLocale());
}
FCIMPLEND

FCIMPL1(BOOL, COMNlsInfo::nativeSetThreadLocale, INT32 lcid)
{
    //We can't call this on Win9x.  OnUnicodeSystem() returns whether or not we're really on 
    //a Unicode System.  UseUnicodeAPI() has a debugging mutent which makes it do the wrong thing.
    if (OnUnicodeSystem()) { 
        return (::SetThreadLocale(lcid));
    } else {
        return 1;  // Return 1 to indicate "success".
    }
}
FCIMPLEND

////////////////////////////////////////////////////////////////////////////
//
//  ConvertStringCase
//
////////////////////////////////////////////////////////////////////////////

INT32 COMNlsInfo::ConvertStringCase(
    LCID Locale,
    WCHAR *wstr,
    int ThisLength,
    WCHAR* Value,
    int ValueLength,
    DWORD ConversionType)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(!((ConversionType&LCMAP_UPPERCASE)&&(ConversionType&LCMAP_LOWERCASE)));
    register int iCTest;
    
    //BUGBUG JRoxe: This should take advantage of the bit on String.
    //BUGBUG JRoxe: Is it faster to use the tables or to check if A-Z and use the offset?
    if (Locale==0x0409 && (ThisLength==ValueLength)) { //LCID for US English 
        if (ConversionType&LCMAP_UPPERCASE) {
            for (int i=0; i<ThisLength; i++) {
                iCTest = wstr[i];
                if (iCTest<0x80) {
                    Value[i]=ToUpperMapping[iCTest];
                } else {
                    goto FullPath;
                }
            }   
            return ThisLength;
        } else if (ConversionType&LCMAP_LOWERCASE) {
            for (int i=0; i<ThisLength; i++) {
                iCTest = wstr[i];
                if (iCTest<0x80) {
                    Value[i]=ToLowerMapping[iCTest];
                } else {
                    goto FullPath;
                }
            }    
            return ThisLength;
        }
    }

    FullPath:
    //
    //  Check to see if we're running on a Unicode system (NT) or not.
    //
    if (OnUnicodeSystem())
    {
        return (LCMapString( Locale,
                             ConversionType,
                             wstr,
                             ThisLength,
                             Value,
                             ValueLength ));
    }

    //
    //  If we get here, we're running on a Win9x system.
    //
    //  Allocate space for the conversion buffers.  Multiplying by 2
    //  (sizeof WCHAR) ensures that we have enough space even if each
    //  character gets converted to 2 bytes.
    //
    int MBLength = (ValueLength * sizeof(WCHAR)) + 1;

    //
    //  If there are fewer than 512 characters, allocate the space directly
    //  on the stack.  Otherwise, do a more expensive heap allocation.
    //
    char *InChar, *OutChar;
    int FoundLength;
    if (MBLength < 512)
    {
        InChar = (char *)alloca(MBLength);
        OutChar = (char *)alloca(MBLength);
    }
    else
    {
        InChar = new char[MBLength];
        OutChar = new char[MBLength];
        if (!InChar || !OutChar)
        {
            delete (InChar);
            delete (OutChar);
            COMPlusThrowOM();
        }
    }

    //
    //  Convert the Unicode characters to multi-byte characters.
    //
    if ((FoundLength = (WszWideCharToMultiByte(CP_ACP,
                                                0,
                                                wstr,
                                                ThisLength,
                                                InChar,
                                                MBLength,
                                                NULL,
                                                NULL ))) == 0)
    {
        _ASSERTE(!"WideCharToMultiByte");
        goto CleanAndThrow;
    }

    //
    //  Handle changing the case of the characters.
    //
    int ConvertedLength;

    if ((ConvertedLength = LCMapStringA( Locale,
                                         ConversionType,
                                         InChar,
                                         FoundLength,
                                         OutChar,
                                         MBLength)) == 0)
    {
        DWORD err = GetLastError();
        _ASSERTE(!"LCMapStringA");
        goto CleanAndThrow;
    }

    //
    //  Convert the now upper or lower cased string back into Unicode.
    //
    int UnicodeLength;

    if ((UnicodeLength = WszMultiByteToWideChar(CP_ACP,
                                                 MB_PRECOMPOSED,
                                                 OutChar,
                                                 ConvertedLength,
                                                 Value,
                                                 ValueLength + 1)) == 0)
    {
        _ASSERTE(!"MultiByteToWideChar");
        goto CleanAndThrow;
    }

    //
    //  Delete any allocated buffers.
    //
    if (MBLength >= 512)
    {
        delete (InChar);
        delete (OutChar);
    }

    //
    //  Return the length.
    //
    return ((INT32)UnicodeLength);


CleanAndThrow:

    if (MBLength >= 512)
    {
        delete (InChar);
        delete (OutChar);
    }
    COMPlusThrow(kArgumentException, L"Arg_ObjObj");

    return (-1);
}

/*============================ConvertStringCaseFast=============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMNlsInfo::ConvertStringCaseFast(WCHAR *inBuff, WCHAR *outBuff, INT32 length, DWORD dwOptions) {
        if (dwOptions&LCMAP_UPPERCASE) {
            for (int i=0; i<length; i++) {
                _ASSERTE(inBuff[i]>=0 && inBuff[i]<0x80);
                outBuff[i]=ToUpperMapping[inBuff[i]];
            }   
        } else if (dwOptions&LCMAP_LOWERCASE) {
            for (int i=0; i<length; i++) {
                _ASSERTE(inBuff[i]>=0 && inBuff[i]<0x80);
                outBuff[i]=ToLowerMapping[inBuff[i]];
            }    
        }
}


////////////////////////////////////////////////////////////////////////////
//
//  internalConvertStringCase
//
//  Returns a converted string according to dwOptions.
//
////////////////////////////////////////////////////////////////////////////

LPVOID COMNlsInfo::internalConvertStringCase(
    TextInfo_ToLowerStringArgs *pargs,
    DWORD dwOptions)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_ARGS(pargs);

    int RealLength = 0;

    //
    //  Check the string argument.
    //
    if (!pargs->pValueStrRef) {
        COMPlusThrowArgumentNull(L"str",L"ArgumentNull_String");
    }

    //
    //  Get the length of the string.
    //
    int ThisLength = pargs->pValueStrRef->GetStringLength();

    //
    //  Check if we have the empty string.
    //
    if (ThisLength == 0)
    {
        RETURN(pargs->pValueStrRef, STRINGREF);
    }

    //
    //  Create the string and set the length.
    //
    STRINGREF Local = AllocateString(ThisLength + 1);
    WCHAR *LocalChars = Local->GetBuffer();

    //If we've never before looked at whether this string has high chars, do so now.
    if (IS_STRING_STATE_UNDETERMINED(pargs->pValueStrRef->GetHighCharState())) {
        COMString::InternalCheckHighChars(pargs->pValueStrRef);
    }

    //If all of our characters are less than 0x80 and we're in a USEnglish locale, we can make certain
    //assumptions that allow us to do this a lot faster.

    //
    //  Convert the characters to lower case while copying.
    //
    if (IS_FAST_CASING(pargs->pValueStrRef->GetHighCharState()) && IS_FAST_COMPARE_LOCALE(pargs->CultureID)) {
        ConvertStringCaseFast(pargs->pValueStrRef->GetBuffer(), LocalChars, ThisLength, dwOptions);
        RealLength=ThisLength;
    } else {
        ASSERT_API(RealLength = ConvertStringCase( pargs->CultureID,
                                                   pargs->pValueStrRef->GetBuffer(),
                                                   ThisLength,
                                                   LocalChars,
                                                   ThisLength,
                                                   dwOptions | (pargs->CultureID == 0 ? 0 : LCMAP_LINGUISTIC_CASING)
                                                   ));
    }

    //
    //  Set the new string length and null terminate it.
    //
    Local->SetStringLength(RealLength);
    //Changing the case may have pushed this string outside of the 0x80 enveloppe, so we
    //just note that we haven't yet taken a look.
    Local->ResetHighCharState();
    Local->GetBuffer()[RealLength] = 0;

    //
    //  Return the resulting string.
    //
    RETURN(Local, STRINGREF);
}


////////////////////////////////////////////////////////////////////////////
//
//  internalToUpperChar
//
////////////////////////////////////////////////////////////////////////////

WCHAR COMNlsInfo::internalToUpperChar(
    LCID Locale,
    WCHAR wch)
{
    THROWSCOMPLUSEXCEPTION();

    WCHAR Upper;

    ASSERT_API(ConvertStringCase( Locale,
                                  &wch,
                                  1,
                                  &Upper,
                                  1,
                                  LCMAP_UPPERCASE ));
    return(Upper);
}


//////////////////////////////////////////////////////
// DELETE THIS WHEN WE USE NLSPLUS TABLE ONLY - BEGIN
//////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
//
//  ToLowerChar
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::ToLowerChar(
    TextInfo_ToLowerCharArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    WCHAR Result = 0;

    int nCultureID = pargs->CultureID;

    ASSERT_API(ConvertStringCase(nCultureID,
                                  &(pargs->ch),
                                  1,
                                  &Result,
                                  1,
                                  LCMAP_LOWERCASE |
                                    (nCultureID == 0 ? 0 : LCMAP_LINGUISTIC_CASING)
                                ));
    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  ToUpperChar
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::ToUpperChar(
    TextInfo_ToLowerCharArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    WCHAR Result = 0;

    int nCultureID = pargs->CultureID;

    ASSERT_API(ConvertStringCase(nCultureID,
                                  &(pargs->ch),
                                  1,
                                  &Result,
                                  1,
                                  LCMAP_UPPERCASE |
                                    (nCultureID == 0 ? 0 : LCMAP_LINGUISTIC_CASING)
                                ));
    return (Result);
}

////////////////////////////////////////////////////////////////////////////
//
//  ToLowerString
//
////////////////////////////////////////////////////////////////////////////

LPVOID __stdcall COMNlsInfo::ToLowerString(
    TextInfo_ToLowerStringArgs *pargs)
{
    return (internalConvertStringCase(pargs, LCMAP_LOWERCASE));
}


////////////////////////////////////////////////////////////////////////////
//
//  ToUpperString
//
////////////////////////////////////////////////////////////////////////////

LPVOID __stdcall COMNlsInfo::ToUpperString(
    TextInfo_ToLowerStringArgs *pargs)
{
    return (internalConvertStringCase(pargs, LCMAP_UPPERCASE));
}

//////////////////////////////////////////////////////
// DELETE THIS WHEN WE USE NLSPLUS TABLE ONLY - END
//////////////////////////////////////////////////////



/*==============================DoComparisonLookup==============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
INT32 COMNlsInfo::DoComparisonLookup(wchar_t charA, wchar_t charB) {
    
    if ((charA ^ charB) & 0x20) {
        //We may be talking about a special case
        if (charA>='A' && charA<='Z') {
            return 1;
        }

        if (charA>='a' && charA<='z') {
            return -1;
        }
    }

    if (charA==charB) {
        return 0;
    }

    return ((charA>charB)?1:-1);
}


/*================================DoCompareChars================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
__forceinline INT32 COMNlsInfo::DoCompareChars(WCHAR charA, WCHAR charB, BOOL *bDifferInCaseOnly) {
    INT32 result;
    WCHAR temp;

    //The ComparisonTable is a 0x80 by 0x80 table of all of the characters in which we're interested
    //and their sorting value relative to each other.  We can do a straight lookup to get this info.
    result = ComparisonTable[(int)(charA)][(int)(charB)];
    
    //This is the tricky part of doing locale-aware sorting.  Case-only differences only matter in the
    //event that they're the only difference in the string.  We mark characters that differ only in case
    //and deal with the rest of the logic in CompareFast.
    *bDifferInCaseOnly = (((charA ^ 0x20)==charB) && (((temp=(charA | 0x20))>='a') && (temp<='z')));
    return result;
}


/*=================================CompareFast==================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
INT32 COMNlsInfo::CompareFast(STRINGREF strA, STRINGREF strB, BOOL *pbDifferInCaseOnly) {
    WCHAR *charA, *charB;
    DWORD *dwAChars, *dwBChars;
    INT32 strALength, strBLength;
    BOOL bDifferInCaseOnly=false;
    BOOL bDifferTemp;
    INT32 caseOnlyDifference=0;
    INT32 result;

    RefInterpretGetStringValuesDangerousForGC(strA, (WCHAR **) &dwAChars, &strALength);
    RefInterpretGetStringValuesDangerousForGC(strB, (WCHAR **) &dwBChars, &strBLength);

    *pbDifferInCaseOnly = false;

    // If the strings are the same length, compare exactly the right # of chars.
    // If they are different, compare the shortest # + 1 (the '\0').
    int count = strALength;
    if (count > strBLength)
        count = strBLength;
    
    ptrdiff_t diff = (char *)dwAChars - (char *)dwBChars;

    int c;
    //Compare the characters a DWORD at a time.  If they differ at all, examine them
    //to find out which character (or both) is different.  The actual work of doing the comparison
    //is done in DoCompareChars.  If they differ in case only, we need to track this, but keep looking
    //in case there's someplace where they actually differ in more than case.  This is counterintuitive to
    //most devs, but makes sense if you consider the case where the strings are being sorted to be displayed.
    while ((count-=2)>=0) {
        if ((c = *((DWORD* )((char *)dwBChars + diff)) - *dwBChars) != 0) {
            //@ToDo Porting:  This needs be in the the other order to work on a big-endian machine.
            charB = (WCHAR *)dwBChars;
            charA = ((WCHAR* )((char *)dwBChars + diff));
            if (*charA!=*charB) {
                result = DoCompareChars(*charA, *charB, &bDifferTemp);
                //We know that the two characters are different because of the check that we did before calling DoCompareChars.
                //If they don't differ in just case, we've found the difference, so we can return that.
                if (!bDifferTemp) {
                    return result;
                }

                //We only note the difference the first time that they differ in case only.  If we haven't seen a case-only
                //difference before, we'll record the difference and set bDifferInCaseOnly to true and record the difference.
                if (!bDifferInCaseOnly) {
                    bDifferInCaseOnly = true;
                    caseOnlyDifference=result;
                }
            }
            // Two cases will get us here: The first chars are the same or
            // they differ in case only.
            // The logic here is identical to the logic described above.
            charA++; charB++;
            if (*charA!=*charB) {
                result = DoCompareChars(*charA, *charB, &bDifferTemp);
                if (!bDifferTemp) {
                    return result;
                }
                if (!bDifferInCaseOnly) {
                    bDifferInCaseOnly = true;
                    caseOnlyDifference=result;
                }
            }
        }
        ++dwBChars;
    }

    //We'll only get here if we had an odd number of characters.  If we did, repeat the logic from above for the last
    //character in the string.
    if (count == -1) {
        charB = (WCHAR *)dwBChars;
        charA = ((WCHAR* )((char *)dwBChars + diff));
        if (*charA!=*charB) {
            result = DoCompareChars(*charA, *charB, &bDifferTemp);
            if (!bDifferTemp) {
                return result;
            }
            if (!bDifferInCaseOnly) {
                bDifferInCaseOnly = true;
                caseOnlyDifference=result;
            }
        }
    }

    //If the lengths are the same, return the case-only difference (if such a thing exists).  
    //Otherwise just return the longer string.
    if (strALength==strBLength) {
        if (bDifferInCaseOnly) {
            *pbDifferInCaseOnly = true;
            return caseOnlyDifference;
        } 
        return 0;
    }
    
    return (strALength>strBLength)?1:-1;
}


INT32 COMNlsInfo::CompareOrdinal(WCHAR* string1, int Length1, WCHAR* string2, int Length2 )
{
    //
    // NOTENOTE The code here should be in sync with COMString::FCCompareOrdinal
    //
    DWORD *strAChars, *strBChars;
    strAChars = (DWORD*)string1;
    strBChars = (DWORD*)string2;

    // If the strings are the same length, compare exactly the right # of chars.
    // If they are different, compare the shortest # + 1 (the '\0').
    int count = Length1;
    if (count > Length2)
        count = Length2;
    ptrdiff_t diff = (char *)strAChars - (char *)strBChars;

    // Loop comparing a DWORD at a time.
    while ((count -= 2) >= 0)
    {
        if ((*((DWORD* )((char *)strBChars + diff)) - *strBChars) != 0)
        {
            LPWSTR ptr1 = (WCHAR*)((char *)strBChars + diff);
            LPWSTR ptr2 = (WCHAR*)strBChars;
            if (*ptr1 != *ptr2) {
                return ((int)*ptr1 - (int)*ptr2);
            }
            return ((int)*(ptr1+1) - (int)*(ptr2+1));
        }
        ++strBChars;
    }

    int c;
    // Handle an extra WORD.
    if (count == -1)
        if ((c = *((WCHAR *) ((char *)strBChars + diff)) - *((WCHAR *) strBChars)) != 0)
            return c;            
    return Length1 - Length2;
}

////////////////////////////////////////////////////////////////////////////
//
//  Compare
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::Compare(
    CompareInfo_CompareStringArgs* pargs)
{
    ASSERT_ARGS(pargs);
    THROWSCOMPLUSEXCEPTION();

    //Our paradigm is that null sorts less than any other string and 
    //that two nulls sort as equal.
    if (pargs->pString1 == NULL) {
        if (pargs->pString2 == NULL) {
            return (0);     // Equal
        }
        return (-1);    // null < non-null
    }
    if (pargs->pString2 == NULL) {
        return (1);     // non-null > null
    }
    //
    //  Check the parameters.
    //
    
    if (pargs->dwFlags<0) {
        COMPlusThrowArgumentOutOfRange(L"flags", L"ArgumentOutOfRange_MustBePositive");
    }

    //
    // Check if we can use the highly optimized comparisons
    //

    if (IS_FAST_COMPARE_LOCALE(pargs->LCID)) {
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pargs->pString1->GetHighCharState())) {
            COMString::InternalCheckHighChars(pargs->pString1);
        }
        
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pargs->pString2->GetHighCharState())) {
            COMString::InternalCheckHighChars(pargs->pString2);
        }
        
        if ((IS_FAST_SORT(pargs->pString1->GetHighCharState())) &&
            (IS_FAST_SORT(pargs->pString2->GetHighCharState())) &&
            (pargs->dwFlags<=1)) {
            //0 is no flags.  1 is ignore case.  We can handle both here.
            BOOL bDifferInCaseOnly;
            int result = CompareFast(pargs->pString1, pargs->pString2, &bDifferInCaseOnly);
            if (pargs->dwFlags==0) { //If we're looking to do a case-sensitive comparison
                return result;
            }
            
            //The remainder of this block deals with instances where we're ignoring case.
            if (bDifferInCaseOnly) {
                return 0;
            } 
            return result;
        }
    }

    if (pargs->dwFlags & COMPARE_OPTIONS_ORDINAL) {
        if (pargs->dwFlags == COMPARE_OPTIONS_ORDINAL) {            
            //
            // Ordinal means the code-point comparison.  This option can not be
            // used with other options.
            // 
            
            //
            //  Compare the two strings to the length of the shorter string.
            //  If they're not equal lengths, and the heads are equal, then the
            //  longer string is greater.
            //
            return (CompareOrdinal(
                        pargs->pString1->GetBuffer(), 
                        pargs->pString1->GetStringLength(), 
                        pargs->pString2->GetBuffer(), 
                        pargs->pString2->GetStringLength()));
        } else {
            COMPlusThrowArgumentException(L"options", L"Argument_CompareOptionOrdinal");
        }
    }

    // The return value of NativeCompareInfo::CompareString() is Win32-style value (1=less, 2=equal, 3=larger).
    // So substract by two to get the NLS+ value.
    // Will change NativeCompareInfo to return the correct value later s.t. we don't have
    // to subtract 2.

    // NativeCompareInfo::CompareString() won't take -1 as the end of string anymore.  Therefore,
    // pass the correct string length.
    // The change is for adding the null-embeded string support in CompareString().
    //
    return (((NativeCompareInfo*)(pargs->pNativeCompareInfo))->CompareString(
        pargs->dwFlags, 
        pargs->pString1->GetBuffer(), 
        pargs->pString1->GetStringLength(), 
        pargs->pString2->GetBuffer(), 
        pargs->pString2->GetStringLength()) - 2);
}


////////////////////////////////////////////////////////////////////////////
//
//  CompareRegion
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::CompareRegion(
    CompareInfo_CompareRegionArgs* pargs)
{
    ASSERT_ARGS(pargs);
    THROWSCOMPLUSEXCEPTION();

    //
    //  Get the arguments.
    //
    int Offset1 = pargs->Offset1;
    int Length1 = pargs->Length1;
    int Offset2 = pargs->Offset2;
    int Length2 = pargs->Length2;

    //
    // Check for the null case.
    //
    if (pargs->pString1 == NULL) {
        if (Offset1 != 0 || (Length1 != 0 && Length1 != -1)) {
            COMPlusThrowArgumentOutOfRange(L"string1", L"ArgumentOutOfRange_OffsetLength");
        }
        if (pargs->pString2 == NULL) {
            if (Offset2 != 0 || (Length2 != 0 && Length2 != -1)) {
                COMPlusThrowArgumentOutOfRange( L"string2", L"ArgumentOutOfRange_OffsetLength");
            }
            return (0);
        }
        return (-1);
    }
    if (pargs->pString2 == NULL) {
        if (Offset2 != 0 || (Length2 != 0 && Length2 != -1)) {
            COMPlusThrowArgumentOutOfRange(L"string2", L"ArgumentOutOfRange_OffsetLength");
        }
        return (1);
    }
    //
    //  Get the full length of the two strings.
    //
    int realLen1 = pargs->pString1->GetStringLength();
    int realLen2 = pargs->pString2->GetStringLength();

    //check the arguments.
    // Criteria:
    // OffsetX >= 0
    // LengthX >= 0 || LengthX == -1 (that is, LengthX >= -1)
    // If LengthX >= 0, OffsetX + LengthX <= realLenX
    if (Offset1<0) {
        COMPlusThrowArgumentOutOfRange(L"offset1", L"ArgumentOutOfRange_Index");
    }
    if (Offset2<0) {
        COMPlusThrowArgumentOutOfRange(L"offset2", L"ArgumentOutOfRange_Index");
    }
    if (Length1 >= 0 && Length1>realLen1 - Offset1) {
        COMPlusThrowArgumentOutOfRange(L"string1", L"ArgumentOutOfRange_OffsetLength");
    }
    if (Length2 >= 0 && Length2>realLen2 - Offset2){ 
        COMPlusThrowArgumentOutOfRange(L"string2", L"ArgumentOutOfRange_OffsetLength");
    }

    // NativeCompareInfo::CompareString() won't take -1 as the end of string anymore.  Therefore,
    // pass the correct string length.
    // The change is for adding the null-embeded string support in CompareString().
    // Therefore, if the length is -1, we have to get the correct string length here.
    //
    if (Length1 == -1) {
        Length1 = realLen1 - Offset1;
    }

    if (Length2 == -1) {
        Length2 = realLen2 - Offset2;
    }

    if (Length1 < 0) {
       COMPlusThrowArgumentOutOfRange(L"length1", L"ArgumentOutOfRange_NegativeLength");
    }
    if (Length2 < 0) {
       COMPlusThrowArgumentOutOfRange(L"length2", L"ArgumentOutOfRange_NegativeLength");
    }
    
    if (pargs->dwFlags == COMPARE_OPTIONS_ORDINAL)        
    {
        return (CompareOrdinal(
                    pargs->pString1->GetBuffer()+Offset1, 
                    Length1, 
                    pargs->pString2->GetBuffer()+Offset2, 
                    Length2));    
    }

    return (((NativeCompareInfo*)(pargs->pNativeCompareInfo))->CompareString(
        pargs->dwFlags, 
        pargs->pString1->GetBuffer() + Offset1, 
        Length1, 
        pargs->pString2->GetBuffer() + Offset2, 
        Length2) - 2);
}


////////////////////////////////////////////////////////////////////////////
//
//  IndexOfChar
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::IndexOfChar(
    CompareInfo_IndexOfCharArgs* pargs)
{
    ASSERT_ARGS(pargs);
    THROWSCOMPLUSEXCEPTION();

    //
    //  Make sure there is a string.
    //
    if (!pargs->pString) {
        COMPlusThrowArgumentNull(L"string",L"ArgumentNull_String");
    }
    //
    //  Get the arguments.
    //
    WCHAR ch = pargs->ch;
    int StartIndex = pargs->StartIndex;
    int Count = pargs->Count;
    int StringLength = pargs->pString->GetStringLength();
    DWORD dwFlags = pargs->dwFlags;

    //
    //  Check the ranges.
    //
    if (StringLength == 0)
    {
        return (-1);
    }
    
    if (StartIndex<0 || StartIndex> StringLength) {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
    }

    if (Count == -1)
    {
        Count = StringLength - StartIndex;        
    }
    else
    {
        if ((Count < 0) || (Count > StringLength - StartIndex))
        {
            COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Count");        
        }
    }

    //
    //  Search for the character in the string starting at StartIndex.
    //
    //  @ToDo: Should read the nls data tables directly to make this
    //         much faster and to handle composite characters.
    //

    int EndIndex = StartIndex + Count - 1;
    LCID Locale = pargs->LCID;
    WCHAR *buffer = pargs->pString->GetBuffer();
    int ctr;
    BOOL bASCII=false;

    if (dwFlags!=COMPARE_OPTIONS_ORDINAL) {
        //
        // Check if we can use the highly optimized comparisons
        //
        
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pargs->pString->GetHighCharState())) {
            COMString::InternalCheckHighChars(pargs->pString);
        }
        
        bASCII = ((IS_FAST_INDEX(pargs->pString->GetHighCharState())) && ch < 0x7f) || (ch == 0);
    }

    if ((bASCII && dwFlags == 0) || (dwFlags == COMPARE_OPTIONS_ORDINAL))
    {
        for (ctr = StartIndex; ctr <= EndIndex; ctr++)
        {
            if (buffer[ctr] == ch)
            {
                return (ctr);
            }
        }
        return (-1);
    } 
    else if (bASCII && dwFlags == COMPARE_OPTIONS_IGNORECASE)
    {
        WCHAR chctr= 0;
        WCHAR UpperValue = (ch>='A' && ch<='Z')?(ch|0x20):ch;

        for (ctr = StartIndex; ctr <= EndIndex; ctr++)
        {
            chctr = buffer[ctr];
            chctr = (chctr>='A' && chctr<='Z')?(chctr|0x20):chctr;

            if (UpperValue == chctr) {
                return (ctr);
            }
        }
        return (-1);
    } 
    // TODO YSLin: We can just use buffer below, instead of calling pargs->pString->GetBuffer() again.
    int result = ((NativeCompareInfo*)(pargs->pNativeCompareInfo))->IndexOfString(
        pargs->pString->GetBuffer(), &ch, StartIndex, EndIndex, 1, dwFlags, FALSE);
    if (result == INDEXOF_INVALID_FLAGS) {
        COMPlusThrowArgumentException(L"flags", L"Argument_InvalidFlag");
    }
    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  LastIndexOfChar
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::LastIndexOfChar(
    CompareInfo_IndexOfCharArgs* pargs)
{
    ASSERT_ARGS(pargs);
    THROWSCOMPLUSEXCEPTION();

    //
    //  Make sure there is a string.
    //
    if (!pargs->pString) {
        COMPlusThrowArgumentNull(L"string",L"ArgumentNull_String");
    }
    //
    //  Get the arguments.
    //
    WCHAR ch = pargs->ch;
    int StartIndex = pargs->StartIndex;
    int Count = pargs->Count;
    int StringLength = pargs->pString->GetStringLength();
    DWORD dwFlags = pargs->dwFlags;

    //
    //  Check the ranges.
    //
    if (StringLength == 0)
    {
        return (-1);
    }

    if ((StartIndex < 0) || (StartIndex > StringLength))
    {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
    }

    int EndIndex;
    if (Count == -1)
    {
        EndIndex = 0;
    }
    else
    {
        if ((Count < 0) || (Count > StartIndex + 1))
        {
            COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Count");
        }
        EndIndex = StartIndex - Count + 1;
    }    

    //
    //  Search for the character in the string starting at EndIndex.
    //
    //  @ToDo: Should read the nls data tables directly to make this
    //         much faster and to handle composite characters.
    //
    LCID Locale = pargs->LCID;
    WCHAR *buffer = pargs->pString->GetBuffer();
    int ctr;
    BOOL bASCII=false;

    //If they haven't asked for exact comparison, we may still be able to do a 
    //fast comparison if the string is all less than 0x80. 
    if (dwFlags!=COMPARE_OPTIONS_ORDINAL) {
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pargs->pString->GetHighCharState())) {
            COMString::InternalCheckHighChars(pargs->pString);
        }

        //
        //BUGBUG [JRoxe/YSLin/JulieB]: Is this broken in Turkish?
        //
        bASCII = (IS_FAST_INDEX(pargs->pString->GetHighCharState()) && ch < 0x7f) || (ch == 0);
    }

    if ((bASCII && dwFlags == 0) || (dwFlags == COMPARE_OPTIONS_ORDINAL))
    {
        for (ctr = StartIndex; ctr >= EndIndex; ctr--)
        {
            if (buffer[ctr] == ch)
            {
                return (ctr);
            }
        }
        return (-1);
    }
    else if (bASCII && dwFlags == COMPARE_OPTIONS_IGNORECASE)
    {
        WCHAR UpperValue = (ch>='A' && ch<='Z')?(ch|0x20):ch;
        WCHAR chctr;

        for (ctr = StartIndex; ctr >= EndIndex; ctr--)
        {
            chctr = buffer[ctr];
            chctr = (chctr>='A' && chctr<='Z')?(chctr|0x20):chctr;
            
            if (UpperValue == chctr) {
                return (ctr);
            }
        }
        return (-1);
    }
    int nMatchEndIndex;
    // TODO YSLin: We can just use buffer below, instead of calling pargs->pString->GetBuffer() again.
    int result = ((NativeCompareInfo*)(pargs->pNativeCompareInfo))->LastIndexOfString(
        pargs->pString->GetBuffer(), &ch, StartIndex, EndIndex, 1, dwFlags, &nMatchEndIndex);
    if (result == INDEXOF_INVALID_FLAGS) {
        COMPlusThrowArgumentException(L"flags", L"Argument_InvalidFlag");
    }
    return (result);
}

INT32 COMNlsInfo::FastIndexOfString(WCHAR *source, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength) {

	CANNOTTHROWCOMPLUSEXCEPTION();

	int endPattern = endIndex - patternLength + 1;
    
    if (endPattern<0) {
        return -1;
    }

    if (patternLength <= 0) {
        return startIndex;
    }

    WCHAR patternChar0 = pattern[0];
    for (int ctrSrc = startIndex; ctrSrc<=endPattern; ctrSrc++) {
        if (source[ctrSrc] != patternChar0)
            continue;
        for (int ctrPat = 1; (ctrPat < patternLength) && (source[ctrSrc + ctrPat] == pattern[ctrPat]); ctrPat++) {
            ;
        }
        if (ctrPat == patternLength) {
            return (ctrSrc);
        }
    }
    
    return (-1);
}

INT32 COMNlsInfo::FastIndexOfStringInsensitive(WCHAR *source, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength) {
    WCHAR srcChar;
    WCHAR patChar;

    int endPattern = endIndex - patternLength + 1;
    
    if (endPattern<0) {
        return -1;
    }

    for (int ctrSrc = startIndex; ctrSrc<=endPattern; ctrSrc++) {
        for (int ctrPat = 0; (ctrPat < patternLength); ctrPat++) {
            srcChar = source[ctrSrc + ctrPat];
            if (srcChar>='A' && srcChar<='Z') {
                srcChar|=0x20;
            }
            patChar = pattern[ctrPat];
            if (patChar>='A' && patChar<='Z') {
                patChar|=0x20;
            }
            if (srcChar!=patChar) {
                break;
            }
        }

        if (ctrPat == patternLength) {
            return (ctrSrc);
        }
    }
    
    return (-1);
}


////////////////////////////////////////////////////////////////////////////
//
//  IndexOfString
//
////////////////////////////////////////////////////////////////////////////
FCIMPL7(INT32, COMNlsInfo::IndexOfString,
                    INT_PTR pNativeCompareInfo,
                    INT32 LCID,
                    StringObject* pString1UNSAFE,
                    StringObject* pString2UNSAFE,
                    INT32 StartIndex,
                    INT32 Count,
                    INT32 dwFlags)
{
    THROWSCOMPLUSEXCEPTION();

    INT32       dwRetVal = 0;
    STRINGREF   pString1 = ObjectToSTRINGREF(pString1UNSAFE);
    STRINGREF   pString2 = ObjectToSTRINGREF(pString2UNSAFE);
    DWORD       errorCode = 0;
    enum {
        NullString,
        InvalidFlags,
        ArgumentOutOfRange
    };

    //
    //  Make sure there are strings.
    //
    if ((pString1 == NULL) || (pString2 == NULL))
    {
        errorCode = NullString; 
        goto lThrowException;
    }
    //
    //  Get the arguments.
    //
    int StringLength1 = pString1->GetStringLength();
    int StringLength2 = pString2->GetStringLength();

    //
    //  Check the ranges.
    //
    if (StringLength1 == 0)
    {
        if (StringLength2 == 0) 
        {
            dwRetVal = 0;
        }
        else
        {
            dwRetVal = -1;
        }
        goto lExit;
    }

    if ((StartIndex < 0) || (StartIndex > StringLength1))
    {
        errorCode = ArgumentOutOfRange;
        goto lThrowException; 
    }

    if (Count == -1)
    {
        Count = StringLength1 - StartIndex;
    }
    else
    {
        if ((Count < 0) || (Count > StringLength1 - StartIndex))
        {
            errorCode = ArgumentOutOfRange;
            goto lThrowException;
        }
    }

    //
    //  See if we have an empty string 2.
    //
    if (StringLength2 == 0)
    {
        dwRetVal = StartIndex;
        goto lExit;
    }

    int EndIndex = StartIndex + Count - 1;

    //
    //  Search for the character in the string.
    //
    WCHAR *Buffer1 = pString1->GetBuffer();
    WCHAR *Buffer2 = pString2->GetBuffer();

    if (dwFlags == COMPARE_OPTIONS_ORDINAL) 
    {
        dwRetVal = FastIndexOfString(Buffer1, StartIndex, EndIndex, Buffer2, StringLength2);
        goto lExit;
    }

    //For dwFlags, 0 is the default, 1 is ignore case, we can handle both.
    if (dwFlags<=1 && IS_FAST_COMPARE_LOCALE(LCID)) 
    {
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pString1->GetHighCharState())) 
        {
            COMString::InternalCheckHighChars(pString1);
        }
        
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pString2->GetHighCharState())) 
        {
            COMString::InternalCheckHighChars(pString2);
        }

        //If neither string has high chars, we can use a much faster comparison algorithm.
        if (IS_FAST_INDEX(pString1->GetHighCharState()) && IS_FAST_INDEX(pString2->GetHighCharState())) 
        {
            if (dwFlags==0) 
            {
                dwRetVal = FastIndexOfString(Buffer1, StartIndex, EndIndex, Buffer2, StringLength2);
                goto lExit;
            } 
            else 
            {
                dwRetVal = FastIndexOfStringInsensitive(Buffer1, StartIndex, EndIndex, Buffer2, StringLength2);
                goto lExit;
            }
        }
    }

    dwRetVal = ((NativeCompareInfo*)(pNativeCompareInfo))->IndexOfString(
        Buffer1, Buffer2, StartIndex, EndIndex, StringLength2, dwFlags, FALSE);

    if (dwRetVal == INDEXOF_INVALID_FLAGS) 
    {
        errorCode = InvalidFlags;
        goto lThrowException;
    }
    else 
	goto lExit;

    
lThrowException:

    HELPER_METHOD_FRAME_BEGIN_RET_2(pString1, pString2);
    switch (errorCode)
    {
    case NullString:
        COMPlusThrowArgumentNull((pString1 == NULL ? L"string1": L"string2"),L"ArgumentNull_String");
        break;
    case ArgumentOutOfRange:
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
        break;
    case InvalidFlags:
        COMPlusThrowArgumentException(L"flags", L"Argument_InvalidFlag");
        break;
    default:
        _ASSERTE(!"Invalid error code");
        COMPlusThrow(kExecutionEngineException);
    }
    HELPER_METHOD_FRAME_END();
lExit:
    NULL;
    return dwRetVal;    

}
FCIMPLEND

INT32 COMNlsInfo::FastLastIndexOfString(WCHAR *source, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength) {
    //startIndex is the greatest index into the string.
    int startPattern = startIndex - patternLength + 1;
    
    if (startPattern < 0) {
        return (-1);
    }
    
    for (int ctrSrc = startPattern; ctrSrc >= endIndex; ctrSrc--) {
        for (int ctrPat = 0; (ctrPat<patternLength) && (source[ctrSrc+ctrPat] == pattern[ctrPat]); ctrPat++) {
            //Deliberately empty.
        }
        if (ctrPat == patternLength) {
            return (ctrSrc);
        }
    }

    return (-1);
}

INT32 COMNlsInfo::FastLastIndexOfStringInsensitive(WCHAR *source, INT32 startIndex, INT32 endIndex, WCHAR *pattern, INT32 patternLength) {
    //startIndex is the greatest index into the string.
    int startPattern = startIndex - patternLength + 1;
    WCHAR srcChar;
    WCHAR patChar;
    
    if (startPattern < 0) {
        return (-1);
    }
    
    for (int ctrSrc = startPattern; ctrSrc >= endIndex; ctrSrc--) {
        for (int ctrPat = 0; (ctrPat<patternLength); ctrPat++) {
            srcChar = source[ctrSrc+ctrPat];
            if (srcChar>='A' && srcChar<='Z') {
                srcChar|=0x20;
            }
            patChar = pattern[ctrPat];
            if (patChar>='A' && patChar<='Z') {
                patChar|=0x20;
            }
            if (srcChar!=patChar) {
                break;
            }
        }
        if (ctrPat == patternLength) {
            return (ctrSrc);
        }
    }

    return (-1);
}

// The parameter verfication is done in the managed side.
FCIMPL5(INT32, COMNlsInfo::nativeIsPrefix, INT_PTR pNativeCompareInfo, INT32 LCID, STRINGREF pString1, STRINGREF pString2, INT32 dwFlags) {
    int SourceLength = pString1->GetStringLength();
    int PrefixLength = pString2->GetStringLength();

    WCHAR *SourceBuffer = pString1->GetBuffer();
    WCHAR *PrefixBuffer = pString2->GetBuffer();

    if (dwFlags == COMPARE_OPTIONS_ORDINAL) {
        if (PrefixLength > SourceLength) {
            return (FALSE);
        }
        return (memcmp(SourceBuffer, PrefixBuffer, PrefixLength * sizeof(WCHAR)) == 0);
    }

    //For dwFlags, 0 is the default, 1 is ignore case, we can handle both.
    if (dwFlags<=1 && IS_FAST_COMPARE_LOCALE(LCID)) {
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pString1->GetHighCharState())) {
            COMString::InternalCheckHighChars(pString1);
        }
        
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pString2->GetHighCharState())) {
            COMString::InternalCheckHighChars(pString2);
        }

        //If neither string has high chars, we can use a much faster comparison algorithm.
        if (IS_FAST_INDEX(pString1->GetHighCharState()) && IS_FAST_INDEX(pString2->GetHighCharState())) {
            if (SourceLength < PrefixLength) {
                return (FALSE);
            }
            if (dwFlags==0) {
                return (memcmp(SourceBuffer, PrefixBuffer, PrefixLength * sizeof(WCHAR)) == 0);
            } else {
                LPCWSTR SourceEnd = SourceBuffer + PrefixLength;
                while (SourceBuffer < SourceEnd) {
                    WCHAR srcChar = *SourceBuffer;
                    if (srcChar>='A' && srcChar<='Z') {
                        srcChar|=0x20;
                    }
                    WCHAR prefixChar = *PrefixBuffer;
                    if (prefixChar>='A' && prefixChar<='Z') {
                        prefixChar|=0x20;
                    }
                    if (srcChar!=prefixChar) {
                        return (FALSE);
                    }
                    SourceBuffer++; PrefixBuffer++;
                }
                return (TRUE);
            }
        }
    }
    

    return ((NativeCompareInfo*)pNativeCompareInfo)->IsPrefix(SourceBuffer, SourceLength, PrefixBuffer, PrefixLength, dwFlags);
}
FCIMPLEND

// The parameter verfication is done in the managed side.
FCIMPL5(INT32, COMNlsInfo::nativeIsSuffix, INT_PTR pNativeCompareInfo, INT32 LCID, STRINGREF pString1, STRINGREF pString2, INT32 dwFlags) {
    int SourceLength = pString1->GetStringLength();
    int SuffixLength = pString2->GetStringLength();

    WCHAR *SourceBuffer = pString1->GetBuffer();
    WCHAR *SuffixBuffer = pString2->GetBuffer();

    if (dwFlags == COMPARE_OPTIONS_ORDINAL) {
        if (SuffixLength > SourceLength) {
            return (FALSE);
        }
        return (memcmp(SourceBuffer + SourceLength - SuffixLength, SuffixBuffer, SuffixLength * sizeof(WCHAR)) == 0);
    }

    //For dwFlags, 0 is the default, 1 is ignore case, we can handle both.
    if (dwFlags<=1 && IS_FAST_COMPARE_LOCALE(LCID)) {
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pString1->GetHighCharState())) {
            COMString::InternalCheckHighChars(pString1);
        }
        
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pString2->GetHighCharState())) {
            COMString::InternalCheckHighChars(pString2);
        }

        //If neither string has high chars, we can use a much faster comparison algorithm.
        if (IS_FAST_INDEX(pString1->GetHighCharState()) && IS_FAST_INDEX(pString2->GetHighCharState())) {
            int nSourceStart = SourceLength - SuffixLength;
            if (nSourceStart < 0) {
                return (FALSE);
            }
            if (dwFlags==0) {
                return (memcmp(SourceBuffer + nSourceStart, SuffixBuffer, SuffixLength * sizeof(WCHAR)) == 0);
            } else {
                LPCWSTR SourceEnd = SourceBuffer + SourceLength;
                SourceBuffer += nSourceStart;
                while (SourceBuffer < SourceEnd) {
                    WCHAR srcChar = *SourceBuffer;
                    if (srcChar>='A' && srcChar<='Z') {
                        srcChar|=0x20;
                    }
                    WCHAR suffixChar = *SuffixBuffer;
                    if (suffixChar>='A' && suffixChar<='Z') {
                        suffixChar|=0x20;
                    }
                    if (srcChar!=suffixChar) {
                        return (FALSE);
                    }
                    SourceBuffer++; SuffixBuffer++;
                }
                return (TRUE);
            }
        }
    }
    
    return ((NativeCompareInfo*)pNativeCompareInfo)->IsSuffix(SourceBuffer, SourceLength, SuffixBuffer, SuffixLength, dwFlags);
}
FCIMPLEND

////////////////////////////////////////////////////////////////////////////
//
//  LastIndexOfString
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::LastIndexOfString(
    CompareInfo_IndexOfStringArgs* pargs)
{
    ASSERT_ARGS(pargs);
    THROWSCOMPLUSEXCEPTION();

    //
    //  Make sure there are strings.
    //
    if ((pargs->pString1 == NULL) || (pargs->pString2 == NULL))
    {
        COMPlusThrowArgumentNull((pargs->pString1 == NULL ? L"string1": L"string2"),L"ArgumentNull_String");
    }

    //
    //  Get the arguments.
    //
    int startIndex = pargs->StartIndex;
    int count = pargs->Count;
    int stringLength1 = pargs->pString1->GetStringLength();
    int findLength = pargs->pString2->GetStringLength();
    DWORD dwFlags = pargs->dwFlags;

    //
    //  Check the ranges.
    //
    if (stringLength1 == 0)
    {
        if (findLength == 0) {
            return (0);
        }
        return (-1);
    }

    if ((startIndex < 0) || (startIndex > stringLength1))
    {
        COMPlusThrowArgumentOutOfRange(L"startIndex", L"ArgumentOutOfRange_Index");
    }

    int endIndex;
    if (count == -1)
    {
        endIndex = 0;
    }
    else
    {
        if ((count < 0) || (count - 1 > startIndex))
        {
            COMPlusThrowArgumentOutOfRange(L"count", L"ArgumentOutOfRange_Count");
        }
        endIndex = startIndex - count + 1;
    }

    //
    //  See if we have an empty string 2.
    //
    if (findLength == 0)
    {
        return (startIndex);
    }

    //
    //  Search for the character in the string.
    //
    //  @ToDo: Should read the nls data tables directly to make this
    //         much faster and to handle composite characters.
    //
    LCID Locale = pargs->LCID;
    WCHAR *buffString = pargs->pString1->GetBuffer();
    WCHAR *buffFind = pargs->pString2->GetBuffer();

    if (dwFlags == COMPARE_OPTIONS_ORDINAL) {
        return FastLastIndexOfString(buffString, startIndex, endIndex, buffFind, findLength);
    }

    //For dwFlags, 0 is the default, 1 is ignore case, we can handle both.
    if (dwFlags<=1 && IS_FAST_COMPARE_LOCALE(pargs->LCID)) {
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pargs->pString1->GetHighCharState())) {
            COMString::InternalCheckHighChars(pargs->pString1);
        }
        
        //If we've never before looked at whether this string has high chars, do so now.
        if (IS_STRING_STATE_UNDETERMINED(pargs->pString2->GetHighCharState())) {
            COMString::InternalCheckHighChars(pargs->pString2);
        }

        //If neither string has high chars, we can use a much faster comparison algorithm.
        if (IS_FAST_INDEX(pargs->pString1->GetHighCharState()) && IS_FAST_INDEX(pargs->pString2->GetHighCharState())) {
            if (dwFlags==0) {
                return FastLastIndexOfString(buffString, startIndex, endIndex, buffFind, findLength);
            } else {
                return FastLastIndexOfStringInsensitive(buffString, startIndex, endIndex, buffFind, findLength);
            }
        }
    }

    int nMatchEndIndex;
    int result = ((NativeCompareInfo*)(pargs->pNativeCompareInfo))->LastIndexOfString(
        buffString, buffFind, startIndex, endIndex, findLength, dwFlags, &nMatchEndIndex);
    if (result == INDEXOF_INVALID_FLAGS) {
        COMPlusThrowArgumentException(L"flags", L"Argument_InvalidFlag");
    }
    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  nativeCreateSortKey
//
////////////////////////////////////////////////////////////////////////////

LPVOID __stdcall COMNlsInfo::nativeCreateSortKey(
    SortKey_CreateSortKeyArgs* pargs)
{
    ASSERT_ARGS(pargs);
    THROWSCOMPLUSEXCEPTION();

    //
    //  Make sure there is a string.
    //
    if (!pargs->pString) {
        COMPlusThrowArgumentNull(L"string",L"ArgumentNull_String");
    }


    WCHAR* wstr;
    int Length;
    U1ARRAYREF ResultArray;
    DWORD dwFlags = (LCMAP_SORTKEY | pargs->dwFlags);
    
    Length = pargs->pString->GetStringLength();

    if (Length==0) {
        //If they gave us an empty string, we're going to create an empty array.
        //This will serve to be less than any other compare string when we call sortkey_compare.
        ResultArray = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1,0);
        return (*((LPVOID*)&ResultArray));
    }

    int ByteCount = 0;

    //This just gets the correct size for the table.
    ByteCount = ((NativeCompareInfo*)(pargs->pNativeCompareInfo))->MapSortKey(dwFlags, (wstr = pargs->pString->GetBuffer()), Length, NULL, 0);

    //A count of 0 indicates that we either had an error or had a zero length string originally.
    if (ByteCount==0) {
        COMPlusThrow(kArgumentException, L"Argument_MustBeString");
    }


    ResultArray = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, ByteCount);

    //The previous allocation could have caused the buffer to move.
    wstr = pargs->pString->GetBuffer();

      LPBYTE pByte = (LPBYTE)(ResultArray->GetDirectPointerToNonObjectElements());

      //MapSortKey doesn't do anything that could cause GC to occur.
#ifdef _DEBUG
      _ASSERTE(((NativeCompareInfo*)(pargs->pNativeCompareInfo))->MapSortKey(dwFlags, wstr, Length, pByte, ByteCount) != 0);
#else
     ((NativeCompareInfo*)(pargs->pNativeCompareInfo))->MapSortKey(dwFlags, wstr, Length, pByte, ByteCount);
#endif    
      
      RETURN(ResultArray, U1ARRAYREF);

}

INT32 __stdcall COMNlsInfo::nativeGetTwoDigitYearMax(Int32Arg* pargs)
{
    DWORD dwTwoDigitYearMax = -1;
#ifdef PLATFORM_WIN32
    ASSERT(pargs != NULL);
    THROWSCOMPLUSEXCEPTION();
    HINSTANCE hKernel32 ;
    typedef int (GETCALENDARINFO)(LCID Locale, DWORD /*CALID*/ Calendar, DWORD /*CALTYPE*/CalType, LPTSTR lpCalData, int cchData, LPDWORD lpValue);
    GETCALENDARINFO* pGetCalendarInfo;

    if ((hKernel32 = WszLoadLibrary(L"Kernel32.dll")) == NULL) {
        return -1; //We're not going to be able to do any of the fancy stuff below, so we'll just short circuit this.
    }
    pGetCalendarInfo = (GETCALENDARINFO*)GetProcAddress(hKernel32, "GetCalendarInfoW");
    FreeLibrary(hKernel32);

    if (pGetCalendarInfo != NULL)
    {
#ifndef CAL_ITWODIGITYEARMAX
        #define CAL_ITWODIGITYEARMAX    0x00000030  // two digit year max
#endif // CAL_ITWODIGITYEARMAX
#ifndef CAL_RETURN_NUMBER
        #define CAL_RETURN_NUMBER       0x20000000   // return number instead of string
#endif // CAL_RETURN_NUMBER
        
        if (FAILED((*pGetCalendarInfo)(LOCALE_USER_DEFAULT, 
                                       pargs->nValue, 
                                       CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER, 
                                       NULL, 
                                       0, 
                                       &dwTwoDigitYearMax))) {
            return -1;
        }
    }
#endif // PLATFORM_WIN32
    return (dwTwoDigitYearMax);
}

FCIMPL0(LONG, COMNlsInfo::nativeGetTimeZoneMinuteOffset)
{
    TIME_ZONE_INFORMATION timeZoneInfo;

    DWORD result =  GetTimeZoneInformation(&timeZoneInfo);

    //
    // In Win32, UTC = local + offset.  So for Pacific Standard Time, offset = 8.
    // In NLS+, Local time = UTC + offset. So for PST, offset = -8.
    // So we have to reverse the sign here.
    //
    return (timeZoneInfo.Bias * -1);
}
FCIMPLEND

LPVOID __stdcall COMNlsInfo::nativeGetStandardName(VoidArgs* pargs)
{
    ASSERT(pargs != NULL);

    TIME_ZONE_INFORMATION timeZoneInfo;
    DWORD result =  GetTimeZoneInformation(&timeZoneInfo);
    
    RETURN (COMString::NewString(timeZoneInfo.StandardName), STRINGREF);
}

LPVOID __stdcall COMNlsInfo::nativeGetDaylightName(VoidArgs* pargs)
{
    ASSERT(pargs != NULL);
    
    TIME_ZONE_INFORMATION timeZoneInfo;
    DWORD result =  GetTimeZoneInformation(&timeZoneInfo);
    // Instead of returning null when daylight saving is not used, now we return the same result as the OS.  
    //In this case, if daylight saving time is used, the standard name is returned.
    /*    
    if (result == TIME_ZONE_ID_UNKNOWN || timeZoneInfo.DaylightDate.wMonth == 0) {
        // If daylight saving time is not used in this timezone, return null.
        //
        // Windows NT/2000: TIME_ZONE_ID_UNKNOWN is returned if daylight saving time is not used in
        // the current time zone, because there are no transition dates.
        //
        // For Windows 9x, a zero in the wMonth in DaylightDate means daylight saving time
        // is not specified.
        //
        // If the current timezone uses daylight saving rule, but user unchekced the
        // "Automatically adjust clock for daylight saving changes", the value 
        // for DaylightBias will be 0.
        RETURN(NULL, I2ARRAYREF);
    }
    */
    RETURN (COMString::NewString(timeZoneInfo.DaylightName), STRINGREF);
}

LPVOID __stdcall COMNlsInfo::nativeGetDaylightChanges(VoidArgs* pargs)
{
    ASSERT(pargs != NULL);
   
    TIME_ZONE_INFORMATION timeZoneInfo;
    DWORD result =  GetTimeZoneInformation(&timeZoneInfo);

    if (result == TIME_ZONE_ID_UNKNOWN || timeZoneInfo.DaylightBias == 0 
        || timeZoneInfo.DaylightDate.wMonth == 0) {
        // If daylight saving time is not used in this timezone, return null.
        //
        // Windows NT/2000: TIME_ZONE_ID_UNKNOWN is returned if daylight saving time is not used in
        // the current time zone, because there are no transition dates.
        //
        // For Windows 9x, a zero in the wMonth in DaylightDate means daylight saving time
        // is not specified.
        //
        // If the current timezone uses daylight saving rule, but user unchekced the
        // "Automatically adjust clock for daylight saving changes", the value 
        // for DaylightBias will be 0.
        RETURN(NULL, I2ARRAYREF);
    }

    I2ARRAYREF pResultArray = (I2ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_I2, 17);

    //
    // The content of timeZoneInfo.StandardDate is 8 words, which
    // contains year, month, day, dayOfWeek, hour, minute, second, millisecond.
    //
    memcpy(pResultArray->m_Array,
            (LPVOID)&timeZoneInfo.DaylightDate,
            8 * sizeof(INT16));   

    //
    // The content of timeZoneInfo.DaylightDate is 8 words, which
    // contains year, month, day, dayOfWeek, hour, minute, second, millisecond.
    //
    memcpy(((INT16*)pResultArray->m_Array) + 8,
            (LPVOID)&timeZoneInfo.StandardDate,
            8 * sizeof(INT16));

    ((INT16*)pResultArray->m_Array)[16] = (INT16)timeZoneInfo.DaylightBias * -1;

    RETURN(pResultArray, I2ARRAYREF);
}

////////////////////////////////////////////////////////////////////////////
//
//  SortKey_Compare
//
////////////////////////////////////////////////////////////////////////////

INT32 __stdcall COMNlsInfo::SortKey_Compare(
    SortKey_CompareArgs* pargs)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT(pargs != NULL);
    if ((pargs->pSortKey1 == NULL) || (pargs->pSortKey2 == NULL))
    {
        COMPlusThrowArgumentNull((pargs->pSortKey1 == NULL ? L"sortKey1": L"sortKey2"),L"ArgumentNull_String");
    }
    U1ARRAYREF pDataRef1 = internalGetField<U1ARRAYREF>( pargs->pSortKey1,
                                                         "m_KeyData",
                                                         &gsig_Fld_ArrByte );
    BYTE* Data1 = (BYTE*)pDataRef1->m_Array;

    U1ARRAYREF pDataRef2 = internalGetField<U1ARRAYREF>( pargs->pSortKey2,
                                                         "m_KeyData",
                                                         &gsig_Fld_ArrByte );
    BYTE* Data2 = (BYTE*)pDataRef2->m_Array;

    int Length1 = pDataRef1->GetNumComponents();
    int Length2 = pDataRef2->GetNumComponents();

    for (int ctr = 0; (ctr < Length1) && (ctr < Length2); ctr++)
    {
        if (Data1[ctr] > Data2[ctr])
        {
            return (1);
        }
        if (Data1[ctr] < Data2[ctr])
        {
            return (-1);
        }
    }

    return (0);
}

FCIMPL4(INT32, COMNlsInfo::nativeChangeCaseChar, 
    INT32 nLCID, INT_PTR pNativeTextInfo, WCHAR wch, BOOL bIsToUpper) {
    //
    // If our character is less than 0x80 and we're in US English locale, we can make certain
    // assumptions that allow us to do this a lot faster.  US English is 0x0409.  The "Invariant
    // Locale" is 0x0.
    //
    if ((nLCID == 0x0409 || nLCID==0x0) && wch < 0x7f) {
        return (bIsToUpper ? ToUpperMapping[wch] : ToLowerMapping[wch]);
    }

    NativeTextInfo* pNativeTextInfoPtr = (NativeTextInfo*)pNativeTextInfo;
    return (pNativeTextInfoPtr->ChangeCaseChar(bIsToUpper, wch));
}
FCIMPLEND

LPVOID  __stdcall COMNlsInfo::nativeChangeCaseString(ChangeCaseStringArgs* pArgs) {
    ASSERT(pArgs != NULL);    
    //
    //  Get the length of the string.
    //
    int nLength = pArgs->pString->GetStringLength();

    //
    //  Check if we have the empty string.
    //
    if (nLength == 0) {
        RETURN(pArgs->pString, STRINGREF);
    }

    //
    //  Create the result string.
    //
    STRINGREF pResult = COMString::NewString(nLength);
    LPWSTR pResultStr = pResult->GetBuffer();

    //
    // If we've never before looked at whether this string has high chars, do so now.
    //
    if (IS_STRING_STATE_UNDETERMINED(pArgs->pString->GetHighCharState())) {
        COMString::InternalCheckHighChars(pArgs->pString);
    }

    //
    // If all of our characters are less than 0x80 and in a USEnglish or Invariant Locale, we can make certain
    // assumptions that allow us to do this a lot faster.
    //

    if ((pArgs->nLCID == 0x0409 || pArgs->nLCID==0x0) && IS_FAST_CASING(pArgs->pString->GetHighCharState())) {
        ConvertStringCaseFast(pArgs->pString->GetBuffer(), pResultStr, nLength, pArgs->bIsToUpper ? LCMAP_UPPERCASE : LCMAP_LOWERCASE);
        pResult->ResetHighCharState();
    } else {
        NativeTextInfo* pNativeTextInfoPtr = (NativeTextInfo*)pArgs->pNativeTextInfo;
        pNativeTextInfoPtr->ChangeCaseString(pArgs->bIsToUpper, nLength, pArgs->pString->GetBuffer(), pResultStr);
    }            
    pResult->SetStringLength(nLength);
    pResultStr[nLength] = 0;
    
    RETURN(pResult, STRINGREF);
}

FCIMPL2(INT32, COMNlsInfo::nativeGetTitleCaseChar, 
    INT_PTR pNativeTextInfo, WCHAR wch) {
    NativeTextInfo* pNativeTextInfoPtr = (NativeTextInfo*)pNativeTextInfo;
    return (pNativeTextInfoPtr->GetTitleCaseChar(wch));
}    
FCIMPLEND


/*==========================AllocateDefaultCasingTable==========================
**Action:  A thin wrapper for the casing table functionality.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID COMNlsInfo::AllocateDefaultCasingTable(VoidArgs *args) {
    THROWSCOMPLUSEXCEPTION();
    // This method is not thread-safe.  It needs managed code to provide syncronization.
    // The code is in the static ctor of TextInfo.
    if (m_pCasingTable == NULL) {
        m_pCasingTable = new CasingTable();
    }
    if (m_pCasingTable == NULL) {
        COMPlusThrowOM();
    }
    if (!m_pCasingTable->AllocateDefaultTable()) {
        COMPlusThrowOM();
    }

    return (LPVOID)m_pCasingTable->GetDefaultNativeTextInfo();
}


/*=============================AllocateCasingTable==============================
**Action: This is a thin wrapper for the CasingTable that allows us not to have 
**        additional .h files.
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID COMNlsInfo::AllocateCasingTable(allocateCasingTableArgs *args) {
    THROWSCOMPLUSEXCEPTION();

    NativeTextInfo* pNativeTextInfo = m_pCasingTable->InitializeNativeTextInfo(args->lcid);
    if (pNativeTextInfo==NULL) {
        COMPlusThrowOM();
    }
    RETURN(pNativeTextInfo, LPVOID);
}

/*================================GetCaseInsHash================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL2(INT32, COMNlsInfo::GetCaseInsHash, LPVOID pvStrA, void *pNativeTextInfoPtr) {

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pvStrA!=NULL);
    STRINGREF strA;
    INT32 highCharState;
    INT32 result;
    
    *((LPVOID *)&strA)=pvStrA;
    LPCWSTR pCurrStr = (LPCWSTR)strA->GetBuffer();

    //
    // Check the high-char state of the string.  Mark this on the String for
    // future use.
    //
    if (IS_STRING_STATE_UNDETERMINED(highCharState=strA->GetHighCharState())) {
        COMString::InternalCheckHighChars(strA);
        highCharState=strA->GetHighCharState();
    }

    //
    // If we know that we don't have any high characters (the common case) we can
    // call a hash function that knows how to do a very fast case conversion.  If
    // we find characters above 0x80, it's much faster to convert the entire string
    // to Uppercase and then call the standard hash function on it.
    //
    if (IS_FAST_CASING(highCharState)) {
        result = HashiStringKnownLower80(pCurrStr);
    } else {
        CQuickBytes newBuffer;
        INT32 length = strA->GetStringLength();
        WCHAR *pNewStr = (WCHAR *)newBuffer.Alloc((length + 1) * sizeof(WCHAR));
        if (!pNewStr) {
            COMPlusThrowOM();
        }
        ((NativeTextInfo*)pNativeTextInfoPtr)->ChangeCaseString(true, length, (LPWSTR)pCurrStr, pNewStr);
        pNewStr[length]='\0';
        result = HashString(pNewStr);
    }
    return result;
}
FCIMPLEND

/**
 * This function returns a pointer to this table that we use in System.Globalization.EncodingTable.
 * No error checking of any sort is performed.  Range checking is entirely the responsiblity of the managed
 * code.
 */
FCIMPL0(EncodingDataItem *, COMNlsInfo::nativeGetEncodingTableDataPointer) {
    return (EncodingDataItem *)EncodingDataTable;
}
FCIMPLEND

/**
 * This function returns a pointer to this table that we use in System.Globalization.EncodingTable.
 * No error checking of any sort is performed.  Range checking is entirely the responsiblity of the managed
 * code.
 */
FCIMPL0(CodePageDataItem *, COMNlsInfo::nativeGetCodePageTableDataPointer) {
    return ((CodePageDataItem*) CodePageDataTable);
}
FCIMPLEND

//
// Casing Table Helpers for use in the EE.
//

#define TEXTINFO_CLASSNAME "System.Globalization.TextInfo"

NativeTextInfo *InternalCasingHelper::pNativeTextInfo=NULL;
void InternalCasingHelper::InitTable() {
    EEClass *pClass;
    MethodTable *pMT;
    BOOL bResult;
    
    if (!pNativeTextInfo) {
        pClass = SystemDomain::Loader()->LoadClass(TEXTINFO_CLASSNAME);
        _ASSERTE(pClass!=NULL || "Unable to load the class for TextInfo.  This is required for CaseInsensitive Type Lookups.");

        pMT = pClass->GetMethodTable();
        _ASSERTE(pMT!=NULL || "Unable to load the MethodTable for TextInfo.  This is required for CaseInsensitive Type Lookups.");

        bResult = pMT->CheckRunClassInit(NULL);
        _ASSERTE(bResult || "CheckRunClassInit Failed on TextInfo.");
        
        pNativeTextInfo = COMNlsInfo::m_pCasingTable->GetDefaultNativeTextInfo();
        _ASSERTE(pNativeTextInfo || "Unable to get a casing table for 0x0409.");
    }

    _ASSERTE(pNativeTextInfo || "Somebody has nulled the casing table required for case-insensitive type lookups.");

}

INT32 InternalCasingHelper::InvariantToLower(LPUTF8 szOut, int cMaxBytes, LPCUTF8 szIn) {
    _ASSERTE(szOut);
    _ASSERTE(szIn);

    //Figure out the maximum number of bytes which we can copy without
    //running out of buffer.  If cMaxBytes is less than inLength, copy
    //one fewer chars so that we have room for the null at the end;
    int inLength = (int)(strlen(szIn)+1);
    int maxCopyLen  = (inLength<=cMaxBytes)?inLength:(cMaxBytes-1);
    LPUTF8 szEnd;
    LPCUTF8 szInSave = szIn;
    LPUTF8 szOutSave = szOut;
    BOOL bFoundHighChars=FALSE;

    //Compute our end point.
    szEnd = szOut + maxCopyLen;

    //Walk the string copying the characters.  Change the case on
    //any character between A-Z.
    for (; szOut<szEnd; szOut++, szIn++) {
        if (*szIn>='A' && *szIn<='Z') {
            *szOut = *szIn | 0x20;
        } else {
            if (((UINT32)(*szIn))>((UINT32)0x80)) {
                bFoundHighChars = TRUE;
                break;
            }
            *szOut = *szIn;
        }
    }

    if (!bFoundHighChars) {
        //If we copied everything, tell them how many bytes we copied, 
        //and arrange it so that the original position of the string + the returned
        //length gives us the position of the null (useful if we're appending).
        if (maxCopyLen==inLength) {
            return maxCopyLen-1;
        } else {
            *szOut=0;
            return (maxCopyLen - inLength);
        }
    }

    InitTable();
    szOut = szOutSave;
    CQuickBytes qbOut;
    LPWSTR szWideOut;

    //convert the UTF8 to Unicode
    MAKE_WIDEPTR_FROMUTF8(szInWide, szInSave);
    INT32 wideCopyLen = (INT32)wcslen(szInWide);
    szWideOut = (LPWSTR)qbOut.Alloc((wideCopyLen + 1) * sizeof(WCHAR));

    //Do the casing operation
    pNativeTextInfo->ChangeCaseString(FALSE/*IsToUpper*/, wideCopyLen, szInWide, szWideOut);    
    szWideOut[wideCopyLen]=0;

    //Convert the Unicode back to UTF8
    INT32 result = WszWideCharToMultiByte(CP_UTF8, 0, szWideOut, wideCopyLen, szOut, cMaxBytes, NULL, NULL);
    _ASSERTE(result!=0);
    szOut[result]=0;//Null terminate the result string.

    //Setup the return value.
    if (result>0 && (inLength==maxCopyLen)) {
        //This is the success case.
        return (result-1);
    } else {
        //We didn't have enough space.  Specify how much we're going to need.
        result = WszWideCharToMultiByte(CP_UTF8, 0, szWideOut, wideCopyLen, NULL, 0, NULL, NULL);
        return (cMaxBytes - result);
    }
}

/*=================================nativeCreateIMLangConvertCharset==================================
**Action: Create an MLang IMLangConvertCharset object, and return the interface pointer.
**Returns: 
**Arguments:
**Exceptions: 
==============================================================================*/

FCIMPL0(BOOL, COMNlsInfo::nativeCreateIMultiLanguage) 
{
    // Note: this function and is not thread-safe and relies on synchronization
    // from the managed code.

    if (m_pIMultiLanguage == NULL) {
        HRESULT hr;

        //We need to call QuickCOMStartup to ensure that COM is initialized.  
        //QuickCOMStartup ensures that ::CoInitialize is only called once per instance
        //of the EE and takes care of calling ::CoUnitialize on shutdown.
        HELPER_METHOD_FRAME_BEGIN_RET_0();
        hr = QuickCOMStartup();
        HELPER_METHOD_FRAME_END();
        if (FAILED(hr)) {
            _ASSERTE(hr==S_OK);
            FCThrow(kExecutionEngineException);
            return (FALSE);
        }

        hr = ::CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (void**)&m_pIMultiLanguage);
        if (hr == S_OK) {
            _ASSERTE(m_cRefIMultiLanguage == 0);
            m_cRefIMultiLanguage = 1;
            return TRUE;
        }
        else {
            return FALSE;
        }
    } else {
        m_cRefIMultiLanguage++;
    }
    return (TRUE);
}
FCIMPLEND

FCIMPL1(BOOL, COMNlsInfo::nativeIsValidMLangCodePage, INT32 codepage) 
{
    _ASSERTE(m_pIMultiLanguage != NULL);
    return (m_pIMultiLanguage->IsConvertible(1200, codepage) == S_OK);  // Ask MLang if Unicode (codepage 1200) can be convertted to this codepage
}
FCIMPLEND


/*=================================nativeReleaseIMLangConvertCharset==================================
**Action: Release MLang IMLangConvertCharset objects.
**Returns: 
**Arguments:
**Exceptions: 
==============================================================================*/

FCIMPL0(VOID, COMNlsInfo::nativeReleaseIMultiLanguage) 
{
    // Note: this function and is not thread-safe and relies on synchronization
    // from the managed code.
	if (m_pIMultiLanguage != NULL) {	
        m_cRefIMultiLanguage--;
        if (m_cRefIMultiLanguage == 0) {		
    		m_pIMultiLanguage->Release();
    		m_pIMultiLanguage = NULL;
    	}
	}
}
FCIMPLEND

/*=================================nativeBytesToUnicode==================================
**Action: 
**Returns: 
**Arguments:
**Exceptions: 
==============================================================================*/

FCIMPL8(INT32, COMNlsInfo::nativeBytesToUnicode, \
        INT32 nCodePage, 
        LPVOID bytes, UINT byteIndex, UINT* pByteCount, \
        LPVOID chars, UINT charIndex, UINT charCount, DWORD* pdwMode) 
{
    //
    // BUGBUG YSLin: Ask JRoxe if there is GC issue with pByteCount
    //
    _ASSERTE(bytes);
    _ASSERTE(byteIndex >=0);
    _ASSERTE(pByteCount);
    _ASSERTE(*pByteCount >=0);
    _ASSERTE(charIndex == 0 || (charIndex > 0 && chars != NULL));
    _ASSERTE(charCount == 0 || (charCount > 0 && chars != NULL));

    U1ARRAYREF byteArray;
    *((void**)&byteArray) = bytes;
    char* bytesBuffer = (char*) (byteArray->GetDirectPointerToNonObjectElements());

    LPWSTR charsBuffer;

    HRESULT hr;
    
    if (chars != NULL) {
        UINT originalCharCount = charCount;
        CHARARRAYREF charArray;
        *((VOID**)&charArray) = chars;
        charsBuffer = (LPWSTR) (charArray->GetDirectPointerToNonObjectElements());

        hr = m_pIMultiLanguage->ConvertStringToUnicode(pdwMode, nCodePage, bytesBuffer + byteIndex, 
            pByteCount, charsBuffer + charIndex, &charCount);
            
        // In MLang, it will return the charCount needed for this conversion when charCount = 0.  I.e.
        // It has the same effect as passing NULL in charsBuffer.
        // Workaround this by checking the original count that we passed in and the returned charCount.
        if (originalCharCount < charCount) {
            FCThrowRes(kArgumentException, L"Argument_ConversionOverflow");
        }
    } else {    
        hr = m_pIMultiLanguage->ConvertStringToUnicode(pdwMode, nCodePage, bytesBuffer + byteIndex, 
            pByteCount, NULL, &charCount);
    }

    
    if (hr == S_FALSE) {
        FCThrowRes(kNotSupportedException, L"NotSupported_EncodingConversion");
    } else if (hr == E_FAIL) {
        FCThrowRes(kArgumentException, L"Argument_ConversionOverflow");
    }
    return (charCount);
}        
FCIMPLEND

/*=================================nativeUnicodeToBytes==================================
**Action: 
**Returns: 
**Arguments:
**Exceptions: 
==============================================================================*/

FCIMPL7(INT32, COMNlsInfo::nativeUnicodeToBytes, INT32 nCodePage, LPVOID chars, UINT charIndex, \
        UINT charCount, LPVOID bytes, UINT byteIndex, UINT byteCount) 
{
    _ASSERTE(chars);
    _ASSERTE(charIndex >=0);
    _ASSERTE(charCount >=0);
    _ASSERTE(byteIndex == 0 || (byteIndex > 0 && bytes != NULL));
    _ASSERTE(byteCount == 0 || (byteCount > 0 && bytes != NULL));

    CHARARRAYREF charArray;
    *((VOID**)&charArray) = chars;
    LPWSTR charsBuffer = (LPWSTR) (charArray->GetDirectPointerToNonObjectElements());
    
    U1ARRAYREF byteArray;
    *((void**)&byteArray) = bytes;
    LPSTR bytesBuffer;

    HRESULT hr;
    
    DWORD dwMode = 0;
    if (bytes != NULL) {
        bytesBuffer = (LPSTR) (byteArray->GetDirectPointerToNonObjectElements());
        hr = m_pIMultiLanguage->ConvertStringFromUnicode(&dwMode, nCodePage, charsBuffer + charIndex, &charCount,
            bytesBuffer + byteIndex, &byteCount);
        if (hr == E_FAIL) {
            FCThrowRes(kArgumentException, L"Argument_ConversionOverflow");
        } else if (hr != S_OK) {
            FCThrowRes(kNotSupportedException, L"NotSupported_EncodingConversion");
        } 
    } else
    {
        hr = m_pIMultiLanguage->ConvertStringFromUnicode(&dwMode, nCodePage, charsBuffer + charIndex, &charCount,
            NULL, &byteCount);        
        if (hr != S_OK) {
            FCThrowRes(kNotSupportedException, L"NotSupported_EncodingConversion");
        }            
    }

    return (byteCount);               
}        
FCIMPLEND


FCIMPL0(BOOL, COMNlsInfo::nativeLoadGB18030DLL) {
    if (!IsValidCodePage(CODEPAGE_GBK)) {
        //
        // We will also need codepage 932 to do the proper encoding of GB18030-2000.
        // If 932 is not there, bail out.
        //
        return (FALSE);
    }
    WCHAR szGB18030FullPath[MAX_PATH + sizeof(GB18030_DLL)/sizeof(GB18030_DLL[0])];
    wcscpy(szGB18030FullPath, SystemDomain::System()->SystemDirectory());
    wcscat(szGB18030FullPath, GB18030_DLL);
    if (m_pfnGB18030UnicodeToBytesFunc == NULL) {
        m_hGB18030 = WszLoadLibrary(szGB18030FullPath);
        if (!m_hGB18030) {
            return (FALSE);
        }
        m_pfnGB18030BytesToUnicodeFunc = (PFN_GB18030_BYTES_TO_UNICODE)GetProcAddress(m_hGB18030, "BytesToUnicode");
        if (m_pfnGB18030BytesToUnicodeFunc == NULL) {
            FreeLibrary(m_hGB18030);
            return (FALSE);
        }
        m_pfnGB18030UnicodeToBytesFunc = (PFN_GB18030_UNICODE_TO_BYTES)GetProcAddress(m_hGB18030, "UnicodeToBytes");
        if (m_pfnGB18030UnicodeToBytesFunc == NULL) {
            FreeLibrary(m_hGB18030);
            return (FALSE);
        }
    }
    return (TRUE);
}
FCIMPLEND

FCIMPL0(BOOL, COMNlsInfo::nativeUnloadGB18030DLL) {
    if (m_hGB18030) {
        FreeLibrary(m_hGB18030);
    }
    return (TRUE);
}
FCIMPLEND

FCIMPL7(INT32, COMNlsInfo::nativeGB18030BytesToUnicode, 
    LPVOID bytes, UINT byteIndex, UINT pByteCount, UINT* pLeftOverBytes,
    LPVOID chars, UINT charIndex, UINT charCount) {

    DWORD dwResult;
    U1ARRAYREF byteArray;
    *((void**)&byteArray) = bytes;
    char* bytesBuffer = (char*) (byteArray->GetDirectPointerToNonObjectElements());

    LPWSTR charsBuffer;

    if (chars != NULL) {
        CHARARRAYREF charArray;
        *((VOID**)&charArray) = chars;
        charsBuffer = (LPWSTR) (charArray->GetDirectPointerToNonObjectElements());

        dwResult = m_pfnGB18030BytesToUnicodeFunc(
            (BYTE*)(bytesBuffer + byteIndex), pByteCount, pLeftOverBytes,
            charsBuffer + charIndex, charCount );
    } else {    
        dwResult = m_pfnGB18030BytesToUnicodeFunc(
            (BYTE*)(bytesBuffer + byteIndex), pByteCount, pLeftOverBytes,
            NULL, 0);
    }            
    return (dwResult);

}
FCIMPLEND

FCIMPL6(INT32, COMNlsInfo::nativeGB18030UnicodeToBytes, 
    LPVOID chars, UINT charIndex, UINT charCount, 
    LPVOID bytes, UINT byteIndex, UINT byteCount) {

    DWORD dwResult;
    CHARARRAYREF charArray;
    *((VOID**)&charArray) = chars;
    LPWSTR charsBuffer = (LPWSTR) (charArray->GetDirectPointerToNonObjectElements());
    
    U1ARRAYREF byteArray;
    *((void**)&byteArray) = bytes;
    LPSTR bytesBuffer;

    if (bytes != NULL) {
        bytesBuffer = (LPSTR) (byteArray->GetDirectPointerToNonObjectElements());

        dwResult = m_pfnGB18030UnicodeToBytesFunc(
            charsBuffer + charIndex, charCount, 
            bytesBuffer + byteIndex, byteCount); 
    } else
    {
        dwResult = m_pfnGB18030UnicodeToBytesFunc(
            charsBuffer + charIndex, charCount,
            NULL, 0); 
    }                                  
    
    return (dwResult);
}
FCIMPLEND

//
// This table is taken from MLANG mimedb.cpp. The codePage field of EncodingDataItem == MLANG's "Internet Encoding".
//
// NOTENOTE YSLin:
// This table should be sorted using case-insensitive ordinal order.
// In the managed code, String.CompareStringOrdinalWC() is used to sort this.
// If you get the latest table from MLANG, notice that MLANG is sorted using CULTURE-SENSITIVE sorting of this table.
// SO YOU HAVE TO CHANGE THE ORDER. DO NOT JUST COPY MLANG's TABLE.
//


/**
 * This function returns the number of items in EncodingDataTable.
 */
FCIMPL0(INT32, COMNlsInfo::nativeGetNumEncodingItems) {
    return (m_nEncodingDataTableItems);
}
FCIMPLEND
    
const WCHAR COMNlsInfo::ToUpperMapping[] = {0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf,
                                            0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
                                            0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
                                            0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
                                            0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
                                            0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
                                            0x60,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
                                            0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x7b,0x7c,0x7d,0x7e,0x7f};

const WCHAR COMNlsInfo::ToLowerMapping[] = {0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf,
                                            0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
                                            0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
                                            0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
                                            0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
                                            0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
                                            0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
                                            0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f};


const INT8 COMNlsInfo::ComparisonTable[0x80][0x80] = {
{ 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 0, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 0,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 0,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 0, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,-1, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 0,-1,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 0,-1, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 0, 1},
{ 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\encodingdata.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include <mlang.h>
#include "COMNlsInfo.h"

//
// Encoding data tables
//

//
// Index an encoding name into an codepage in CodePageDataTable.
//
const EncodingDataItem COMNlsInfo::EncodingDataTable[] = {
// Total Items: 455
// encoding name, codepage.
{L"437", 437}, 
{L"ANSI_X3.4-1968", 20127}, 
{L"ANSI_X3.4-1986", 20127}, 
// {L"_autodetect", 50932}, 
// {L"_autodetect_all", 50001}, 
// {L"_autodetect_kr", 50949}, 
{L"arabic", 28596}, 
{L"ascii", 20127}, 
{L"ASMO-708", 708}, 
{L"Big5", 950}, 
{L"Big5-HKSCS", 950}, 
{L"CCSID00858", 858}, 
{L"CCSID00924", 20924}, 
{L"CCSID01140", 1140}, 
{L"CCSID01141", 1141}, 
{L"CCSID01142", 1142}, 
{L"CCSID01143", 1143}, 
{L"CCSID01144", 1144}, 
{L"CCSID01145", 1145}, 
{L"CCSID01146", 1146}, 
{L"CCSID01147", 1147}, 
{L"CCSID01148", 1148}, 
{L"CCSID01149", 1149}, 
{L"chinese", 936}, 
{L"cn-big5", 950}, 
{L"CN-GB", 936}, 
{L"CP00858", 858}, 
{L"CP00924", 20924}, 
{L"CP01140", 1140}, 
{L"CP01141", 1141}, 
{L"CP01142", 1142}, 
{L"CP01143", 1143}, 
{L"CP01144", 1144}, 
{L"CP01145", 1145}, 
{L"CP01146", 1146}, 
{L"CP01147", 1147}, 
{L"CP01148", 1148}, 
{L"CP01149", 1149}, 
{L"cp037", 37}, 
{L"cp1025", 21025}, 
{L"CP1026", 1026}, 
{L"cp1256", 1256}, 
{L"CP273", 20273}, 
{L"CP278", 20278}, 
{L"CP280", 20280}, 
{L"CP284", 20284}, 
{L"CP285", 20285}, 
{L"cp290", 20290}, 
{L"cp297", 20297}, 
{L"cp367", 20127}, 
{L"cp420", 20420}, 
{L"cp423", 20423}, 
{L"cp424", 20424}, 
{L"cp437", 437}, 
{L"CP500", 500}, 
{L"cp50227", 50227}, 
    //{L"cp50229", 50229}, 
{L"cp819", 28591}, 
{L"cp850", 850}, 
{L"cp852", 852}, 
{L"cp855", 855}, 
{L"cp857", 857}, 
{L"cp858", 858}, 
{L"cp860", 860}, 
{L"cp861", 861}, 
{L"cp862", 862}, 
{L"cp863", 863}, 
{L"cp864", 864}, 
{L"cp865", 865}, 
{L"cp866", 866}, 
{L"cp869", 869}, 
{L"CP870", 870}, 
{L"CP871", 20871}, 
{L"cp875", 875}, 
{L"cp880", 20880}, 
{L"CP905", 20905}, 
{L"cp930", 50930}, 
{L"cp933", 50933}, 
{L"cp935", 50935}, 
{L"cp937", 50937}, 
{L"cp939", 50939}, 
{L"csASCII", 20127}, 
{L"csbig5", 950}, 
{L"csEUCKR", 51949}, 
{L"csEUCPkdFmtJapanese", 51932}, 
{L"csGB2312", 936}, 
{L"csGB231280", 936}, 
{L"csIBM037", 37}, 
{L"csIBM1026", 1026}, 
{L"csIBM273", 20273}, 
{L"csIBM277", 20277}, 
{L"csIBM278", 20278}, 
{L"csIBM280", 20280}, 
{L"csIBM284", 20284}, 
{L"csIBM285", 20285}, 
{L"csIBM290", 20290}, 
{L"csIBM297", 20297}, 
{L"csIBM420", 20420}, 
{L"csIBM423", 20423}, 
{L"csIBM424", 20424}, 
{L"csIBM500", 500}, 
{L"csIBM870", 870}, 
{L"csIBM871", 20871}, 
{L"csIBM880", 20880}, 
{L"csIBM905", 20905}, 
{L"csIBMThai", 20838}, 
{L"csISO2022JP", 50221}, 
{L"csISO2022KR", 50225}, 
{L"csISO58GB231280", 936}, 
{L"csISOLatin1", 28591}, 
{L"csISOLatin2", 28592}, 
{L"csISOLatin3", 28593}, 
{L"csISOLatin4", 28594}, 
{L"csISOLatin5", 28599}, 
{L"csISOLatin9", 28605}, 
{L"csISOLatinArabic", 28596}, 
{L"csISOLatinCyrillic", 28595}, 
{L"csISOLatinGreek", 28597}, 
{L"csISOLatinHebrew", 28598}, 
{L"csKOI8R", 20866}, 
{L"csKSC56011987", 949}, 
{L"csPC8CodePage437", 437}, 
{L"csShiftJIS", 932}, 
{L"csUnicode11UTF7", 65000}, 
{L"csWindows31J", 932}, 
{L"cyrillic", 28595}, 
{L"DIN_66003", 20106}, 
{L"DOS-720", 720}, 
{L"DOS-862", 862}, 
{L"DOS-874", 874}, 
{L"ebcdic-cp-ar1", 20420}, 
{L"ebcdic-cp-be", 500}, 
{L"ebcdic-cp-ca", 37}, 
{L"ebcdic-cp-ch", 500}, 
{L"EBCDIC-CP-DK", 20277}, 
{L"ebcdic-cp-es", 20284}, 
{L"ebcdic-cp-fi", 20278}, 
{L"ebcdic-cp-fr", 20297}, 
{L"ebcdic-cp-gb", 20285}, 
{L"ebcdic-cp-gr", 20423}, 
{L"ebcdic-cp-he", 20424}, 
{L"ebcdic-cp-is", 20871}, 
{L"ebcdic-cp-it", 20280}, 
{L"ebcdic-cp-nl", 37}, 
{L"EBCDIC-CP-NO", 20277}, 
{L"ebcdic-cp-roece", 870}, 
{L"ebcdic-cp-se", 20278}, 
{L"ebcdic-cp-tr", 20905}, 
{L"ebcdic-cp-us", 37}, 
{L"ebcdic-cp-wt", 37}, 
{L"ebcdic-cp-yu", 870}, 
{L"EBCDIC-Cyrillic", 20880}, 
{L"ebcdic-de-273+euro", 1141}, 
{L"ebcdic-dk-277+euro", 1142}, 
{L"ebcdic-es-284+euro", 1145}, 
{L"ebcdic-fi-278+euro", 1143}, 
{L"ebcdic-fr-297+euro", 1147}, 
{L"ebcdic-gb-285+euro", 1146}, 
{L"ebcdic-international-500+euro", 1148}, 
{L"ebcdic-is-871+euro", 1149}, 
{L"ebcdic-it-280+euro", 1144}, 
{L"EBCDIC-JP-kana", 20290}, 
{L"ebcdic-Latin9--euro", 20924}, 
{L"ebcdic-no-277+euro", 1142}, 
{L"ebcdic-se-278+euro", 1143}, 
{L"ebcdic-us-37+euro", 1140}, 
{L"ECMA-114", 28596}, 
{L"ECMA-118", 28597}, 
{L"ELOT_928", 28597}, 
{L"euc-cn", 51936}, 
{L"euc-jp", 51932}, 
{L"euc-kr", 51949}, 
{L"Extended_UNIX_Code_Packed_Format_for_Japanese", 51932}, 
{L"GB18030", 54936}, 
{L"GB2312", 936}, 
{L"GB2312-80", 936}, 
{L"GB231280", 936}, 
{L"GBK", 936}, 
{L"GB_2312-80", 936}, 
{L"German", 20106}, 
{L"greek", 28597}, 
{L"greek8", 28597}, 
{L"hebrew", 28598}, 
{L"hz-gb-2312", 52936}, 
{L"IBM-Thai", 20838}, 
{L"IBM00858", 858}, 
{L"IBM00924", 20924}, 
{L"IBM01047", 1047}, 
{L"IBM01140", 1140}, 
{L"IBM01141", 1141}, 
{L"IBM01142", 1142}, 
{L"IBM01143", 1143}, 
{L"IBM01144", 1144}, 
{L"IBM01145", 1145}, 
{L"IBM01146", 1146}, 
{L"IBM01147", 1147}, 
{L"IBM01148", 1148}, 
{L"IBM01149", 1149}, 
{L"IBM037", 37}, 
{L"IBM1026", 1026}, 
{L"IBM273", 20273}, 
{L"IBM277", 20277}, 
{L"IBM278", 20278}, 
{L"IBM280", 20280}, 
{L"IBM284", 20284}, 
{L"IBM285", 20285}, 
{L"IBM290", 20290}, 
{L"IBM297", 20297}, 
{L"IBM367", 20127}, 
{L"IBM420", 20420}, 
{L"IBM423", 20423}, 
{L"IBM424", 20424}, 
{L"IBM437", 437}, 
{L"IBM500", 500}, 
{L"ibm737", 737}, 
{L"ibm775", 775}, 
{L"ibm819", 28591}, 
{L"IBM850", 850}, 
{L"IBM852", 852}, 
{L"IBM855", 855}, 
{L"IBM857", 857}, 
{L"IBM860", 860}, 
{L"IBM861", 861}, 
{L"IBM862", 862}, 
{L"IBM863", 863}, 
{L"IBM864", 864}, 
{L"IBM865", 865}, 
{L"IBM866", 866}, 
{L"IBM869", 869}, 
{L"IBM870", 870}, 
{L"IBM871", 20871}, 
{L"IBM880", 20880}, 
{L"IBM905", 20905}, 
{L"irv", 20105}, 
{L"ISO-10646-UCS-2", 1200}, 
{L"iso-2022-jp", 50220}, 
{L"iso-2022-jpeuc", 51932}, 
{L"iso-2022-kr", 50225}, 
{L"iso-2022-kr-7", 50225}, 
{L"iso-2022-kr-7bit", 50225}, 
{L"iso-2022-kr-8", 51949}, 
{L"iso-2022-kr-8bit", 51949}, 
{L"iso-8859-1", 28591}, 
{L"iso-8859-11", 874}, 
{L"iso-8859-13", 28603}, 
{L"iso-8859-15", 28605}, 
{L"iso-8859-2", 28592}, 
{L"iso-8859-3", 28593}, 
{L"iso-8859-4", 28594}, 
{L"iso-8859-5", 28595}, 
{L"iso-8859-6", 28596}, 
{L"iso-8859-7", 28597}, 
{L"iso-8859-8", 28598}, 
{L"ISO-8859-8 Visual", 28598}, 
{L"iso-8859-8-i", 38598}, 
{L"iso-8859-9", 28599}, 
{L"iso-ir-100", 28591}, 
{L"iso-ir-101", 28592}, 
{L"iso-ir-109", 28593}, 
{L"iso-ir-110", 28594}, 
{L"iso-ir-126", 28597}, 
{L"iso-ir-127", 28596}, 
{L"iso-ir-138", 28598}, 
{L"iso-ir-144", 28595}, 
{L"iso-ir-148", 28599}, 
{L"iso-ir-149", 949}, 
{L"iso-ir-58", 936}, 
{L"iso-ir-6", 20127}, 
{L"ISO646-US", 20127}, 
{L"iso8859-1", 28591}, 
{L"iso8859-2", 28592}, 
{L"ISO_646.irv:1991", 20127}, 
{L"iso_8859-1", 28591}, 
{L"ISO_8859-15", 28605}, 
{L"iso_8859-1:1987", 28591}, 
{L"iso_8859-2", 28592}, 
{L"iso_8859-2:1987", 28592}, 
{L"ISO_8859-3", 28593}, 
{L"ISO_8859-3:1988", 28593}, 
{L"ISO_8859-4", 28594}, 
{L"ISO_8859-4:1988", 28594}, 
{L"ISO_8859-5", 28595}, 
{L"ISO_8859-5:1988", 28595}, 
{L"ISO_8859-6", 28596}, 
{L"ISO_8859-6:1987", 28596}, 
{L"ISO_8859-7", 28597}, 
{L"ISO_8859-7:1987", 28597}, 
{L"ISO_8859-8", 28598}, 
{L"ISO_8859-8:1988", 28598}, 
{L"ISO_8859-9", 28599}, 
{L"ISO_8859-9:1989", 28599}, 
{L"Johab", 1361}, 
{L"koi", 20866}, 
{L"koi8", 20866}, 
{L"koi8-r", 20866}, 
{L"koi8-ru", 21866}, 
{L"koi8-u", 21866}, 
{L"koi8r", 20866}, 
{L"korean", 949}, 
{L"ks-c-5601", 949}, 
{L"ks-c5601", 949}, 
{L"KSC5601", 949}, 
{L"KSC_5601", 949}, 
{L"ks_c_5601", 949}, 
{L"ks_c_5601-1987", 949}, 
{L"ks_c_5601-1989", 949}, 
{L"ks_c_5601_1987", 949}, 
{L"l1", 28591}, 
{L"l2", 28592}, 
{L"l3", 28593}, 
{L"l4", 28594}, 
{L"l5", 28599}, 
{L"l9", 28605}, 
{L"latin1", 28591}, 
{L"latin2", 28592}, 
{L"latin3", 28593}, 
{L"latin4", 28594}, 
{L"latin5", 28599}, 
{L"latin9", 28605}, 
{L"logical", 28598}, 
{L"macintosh", 10000}, 
{L"ms_Kanji", 932}, 
{L"Norwegian", 20108}, 
{L"NS_4551-1", 20108}, 
{L"PC-Multilingual-850+euro", 858}, 
{L"SEN_850200_B", 20107}, 
{L"shift-jis", 932}, 
{L"shift_jis", 932}, 
{L"sjis", 932}, 
{L"Swedish", 20107}, 
{L"TIS-620", 874}, 
{L"ucs-2", 1200}, 
{L"unicode", 1200}, 
{L"unicode-1-1-utf-7", 65000}, 
{L"unicode-1-1-utf-8", 65001}, 
{L"unicode-2-0-utf-7", 65000}, 
{L"unicode-2-0-utf-8", 65001}, 
{L"unicodeFFFE", 1201}, 
{L"us", 20127}, 
{L"us-ascii", 20127}, 
{L"utf-16", 1200}, 
{L"UTF-16BE", 1201}, 
{L"UTF-16LE", 1200}, 
{L"utf-7", 65000}, 
{L"utf-8", 65001}, 
{L"visual", 28598}, 
{L"windows-1250", 1250}, 
{L"windows-1251", 1251}, 
{L"windows-1252", 1252}, 
{L"windows-1253", 1253}, 
{L"Windows-1254", 1254}, 
{L"windows-1255", 1255}, 
{L"windows-1256", 1256}, 
{L"windows-1257", 1257}, 
{L"windows-1258", 1258}, 
{L"windows-874", 874}, 
{L"x-ansi", 1252}, 
{L"x-Chinese-CNS", 20000}, 
{L"x-Chinese-Eten", 20002}, 
{L"x-cp1250", 1250}, 
{L"x-cp1251", 1251}, 
{L"x-cp20001", 20001}, 
{L"x-cp20003", 20003}, 
{L"x-cp20004", 20004}, 
{L"x-cp20005", 20005}, 
{L"x-cp20261", 20261}, 
{L"x-cp20269", 20269}, 
{L"x-cp20936", 20936}, 
{L"x-cp20949", 20949}, 
{L"x-cp21027", 21027}, 
{L"x-cp50227", 50227}, 
//{L"x-cp50229", 50229}, 
{L"X-EBCDIC-JapaneseAndUSCanada", 50931}, 
{L"X-EBCDIC-KoreanExtended", 20833}, 
{L"x-euc", 51932}, 
{L"x-euc-cn", 51936}, 
{L"x-euc-jp", 51932}, 
{L"x-Europa", 29001}, 
{L"x-IA5", 20105}, 
{L"x-IA5-German", 20106}, 
{L"x-IA5-Norwegian", 20108}, 
{L"x-IA5-Swedish", 20107}, 
{L"x-iscii-as", 57006}, 
{L"x-iscii-be", 57003}, 
{L"x-iscii-de", 57002}, 
{L"x-iscii-gu", 57010}, 
{L"x-iscii-ka", 57008}, 
{L"x-iscii-ma", 57009}, 
{L"x-iscii-or", 57007}, 
{L"x-iscii-pa", 57011}, 
{L"x-iscii-ta", 57004}, 
{L"x-iscii-te", 57005}, 
{L"x-mac-arabic", 10004}, 
{L"x-mac-ce", 10029}, 
{L"x-mac-chinesesimp", 10008}, 
{L"x-mac-chinesetrad", 10002}, 
{L"x-mac-croatian", 10082}, 
{L"x-mac-cyrillic", 10007}, 
{L"x-mac-greek", 10006}, 
{L"x-mac-hebrew", 10005}, 
{L"x-mac-icelandic", 10079}, 
{L"x-mac-japanese", 10001}, 
{L"x-mac-korean", 10003}, 
{L"x-mac-romanian", 10010}, 
{L"x-mac-thai", 10021}, 
{L"x-mac-turkish", 10081}, 
{L"x-mac-ukrainian", 10017}, 
{L"x-ms-cp932", 932}, 
{L"x-sjis", 932}, 
{L"x-unicode-1-1-utf-7", 65000}, 
{L"x-unicode-1-1-utf-8", 65001}, 
{L"x-unicode-2-0-utf-7", 65000}, 
{L"x-unicode-2-0-utf-8", 65001}, 
{L"x-user-defined", 50000}, 
{L"x-x-big5", 950}, 
};

const COMNlsInfo::m_nEncodingDataTableItems = 
    sizeof(COMNlsInfo::EncodingDataTable)/sizeof(EncodingDataItem);

//
// Information about codepages.
//
const CodePageDataItem COMNlsInfo::CodePageDataTable[] = {
// Total Items: 146
// code page, family code page, web name, header name, body name, flags


{    37,  1252, L"IBM037", L"IBM037", L"IBM037", 0}, // "IBM EBCDIC (US-Canada)"
{   437,  1252, L"IBM437", L"IBM437", L"IBM437", 0}, // "OEM United States"
{   500,  1252, L"IBM500", L"IBM500", L"IBM500", 0}, // "IBM EBCDIC (International)"
{   708,  1256, L"ASMO-708", L"ASMO-708", L"ASMO-708", MIMECONTF_BROWSER | MIMECONTF_SAVABLE_BROWSER | 0}, // "Arabic (ASMO 708)"
{   720,  1256, L"DOS-720", L"DOS-720", L"DOS-720", MIMECONTF_BROWSER | MIMECONTF_SAVABLE_BROWSER | 0}, // "Arabic (DOS)"
{   737,  1253, L"ibm737", L"ibm737", L"ibm737", 0}, // "Greek (DOS)"
{   775,  1257, L"ibm775", L"ibm775", L"ibm775", 0}, // "Baltic (DOS)"
{   850,  1252, L"ibm850", L"ibm850", L"ibm850", 0}, // "Western European (DOS)"
{   852,  1250, L"ibm852", L"ibm852", L"ibm852", MIMECONTF_BROWSER | MIMECONTF_SAVABLE_BROWSER | 0}, // "Central European (DOS)"
{   855,  1252, L"IBM855", L"IBM855", L"IBM855", 0}, // "OEM Cyrillic"
{   857,  1254, L"ibm857", L"ibm857", L"ibm857", 0}, // "Turkish (DOS)"
{   858,  1252, L"IBM00858", L"IBM00858", L"IBM00858", 0}, // "OEM Multilingual Latin I"
{   860,  1252, L"IBM860", L"IBM860", L"IBM860", 0}, // "Portuguese (DOS)"
{   861,  1252, L"ibm861", L"ibm861", L"ibm861", 0}, // "Icelandic (DOS)"
{   862,  1255, L"DOS-862", L"DOS-862", L"DOS-862", MIMECONTF_BROWSER | MIMECONTF_SAVABLE_BROWSER | 0}, // "Hebrew (DOS)"
{   863,  1252, L"IBM863", L"IBM863", L"IBM863", 0}, // "French Canadian (DOS)"
{   864,  1256, L"IBM864", L"IBM864", L"IBM864", 0}, // "Arabic (864)"
{   865,  1252, L"IBM865", L"IBM865", L"IBM865", 0}, // "Nordic (DOS)"
{   866,  1251, L"cp866", L"cp866", L"cp866", MIMECONTF_BROWSER | MIMECONTF_SAVABLE_BROWSER | 0}, // "Cyrillic (DOS)"
{   869,  1253, L"ibm869", L"ibm869", L"ibm869", 0}, // "Greek, Modern (DOS)"
{   870,  1250, L"IBM870", L"IBM870", L"IBM870", 0}, // "IBM EBCDIC (Multilingual Latin-2)"
{   874,   874, L"windows-874", L"windows-874", L"windows-874", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Thai (Windows)"
{   875,  1253, L"cp875", L"cp875", L"cp875", 0}, // "IBM EBCDIC (Greek Modern)"
{   932,   932, L"shift_jis", L"iso-2022-jp", L"iso-2022-jp", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Japanese (Shift-JIS)"
{   936,   936, L"gb2312", L"gb2312", L"gb2312", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Chinese Simplified (GB2312)"
{   949,   949, L"ks_c_5601-1987", L"ks_c_5601-1987", L"ks_c_5601-1987", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Korean"
{   950,   950, L"big5", L"big5", L"big5", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Chinese Traditional (Big5)"
{  1026,  1254, L"IBM1026", L"IBM1026", L"IBM1026", 0}, // "IBM EBCDIC (Turkish Latin-5)"
{  1047,  1252, L"IBM01047", L"IBM01047", L"IBM01047", 0}, // "IBM Latin-1"
{  1140,  1252, L"IBM01140", L"IBM01140", L"IBM01140", 0}, // "IBM EBCDIC (US-Canada-Euro)"
{  1141,  1252, L"IBM01141", L"IBM01141", L"IBM01141", 0}, // "IBM EBCDIC (Germany-Euro)"
{  1142,  1252, L"IBM01142", L"IBM01142", L"IBM01142", 0}, // "IBM EBCDIC (Denmark-Norway-Euro)"
{  1143,  1252, L"IBM01143", L"IBM01143", L"IBM01143", 0}, // "IBM EBCDIC (Finland-Sweden-Euro)"
{  1144,  1252, L"IBM01144", L"IBM01144", L"IBM01144", 0}, // "IBM EBCDIC (Italy-Euro)"
{  1145,  1252, L"IBM01145", L"IBM01145", L"IBM01145", 0}, // "IBM EBCDIC (Spain-Euro)"
{  1146,  1252, L"IBM01146", L"IBM01146", L"IBM01146", 0}, // "IBM EBCDIC (UK-Euro)"
{  1147,  1252, L"IBM01147", L"IBM01147", L"IBM01147", 0}, // "IBM EBCDIC (France-Euro)"
{  1148,  1252, L"IBM01148", L"IBM01148", L"IBM01148", 0}, // "IBM EBCDIC (International-Euro)"
{  1149,  1252, L"IBM01149", L"IBM01149", L"IBM01149", 0}, // "IBM EBCDIC (Icelandic-Euro)"
{  1200,  1200, L"utf-16", L"utf-16", L"utf-16", MIMECONTF_SAVABLE_BROWSER | 0}, // "Unicode"
{  1201,  1200, L"unicodeFFFE", L"unicodeFFFE", L"unicodeFFFE", 0}, // "Unicode (Big-Endian)"
{  1250,  1250, L"windows-1250", L"windows-1250", L"iso-8859-2", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Central European (Windows)"
{  1251,  1251, L"windows-1251", L"windows-1251", L"koi8-r", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Cyrillic (Windows)"
{  1252,  1252, L"Windows-1252", L"Windows-1252", L"iso-8859-1", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Western European (Windows)"
{  1253,  1253, L"windows-1253", L"windows-1253", L"iso-8859-7", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Greek (Windows)"
{  1254,  1254, L"windows-1254", L"windows-1254", L"iso-8859-9", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Turkish (Windows)"
{  1255,  1255, L"windows-1255", L"windows-1255", L"windows-1255", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Hebrew (Windows)"
{  1256,  1256, L"windows-1256", L"windows-1256", L"windows-1256", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Arabic (Windows)"
{  1257,  1257, L"windows-1257", L"windows-1257", L"windows-1257", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Baltic (Windows)"
{  1258,  1258, L"windows-1258", L"windows-1258", L"windows-1258", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Vietnamese (Windows)"
{  1361,   949, L"Johab", L"Johab", L"Johab", 0}, // "Korean (Johab)"
{ 10000,  1252, L"macintosh", L"macintosh", L"macintosh", 0}, // "Western European (Mac)"
{ 10001,   932, L"x-mac-japanese", L"x-mac-japanese", L"x-mac-japanese", 0}, // "Japanese (Mac)"
{ 10002,   950, L"x-mac-chinesetrad", L"x-mac-chinesetrad", L"x-mac-chinesetrad", 0}, // "Chinese Traditional (Mac)"
{ 10003,   949, L"x-mac-korean", L"x-mac-korean", L"x-mac-korean", 0}, // "Korean (Mac)"
{ 10004,  1256, L"x-mac-arabic", L"x-mac-arabic", L"x-mac-arabic", 0}, // "Arabic (Mac)"
{ 10005,  1255, L"x-mac-hebrew", L"x-mac-hebrew", L"x-mac-hebrew", 0}, // "Hebrew (Mac)"
{ 10006,  1253, L"x-mac-greek", L"x-mac-greek", L"x-mac-greek", 0}, // "Greek (Mac)"
{ 10007,  1251, L"x-mac-cyrillic", L"x-mac-cyrillic", L"x-mac-cyrillic", 0}, // "Cyrillic (Mac)"
{ 10008,   936, L"x-mac-chinesesimp", L"x-mac-chinesesimp", L"x-mac-chinesesimp", 0}, // "Chinese Simplified (Mac)"
{ 10010,  1250, L"x-mac-romanian", L"x-mac-romanian", L"x-mac-romanian", 0}, // "Romanian (Mac)"
{ 10017,  1251, L"x-mac-ukrainian", L"x-mac-ukrainian", L"x-mac-ukrainian", 0}, // "Ukrainian (Mac)"
{ 10021,   874, L"x-mac-thai", L"x-mac-thai", L"x-mac-thai", 0}, // "Thai (Mac)"
{ 10029,  1250, L"x-mac-ce", L"x-mac-ce", L"x-mac-ce", 0}, // "Central European (Mac)"
{ 10079,  1252, L"x-mac-icelandic", L"x-mac-icelandic", L"x-mac-icelandic", 0}, // "Icelandic (Mac)"
{ 10081,  1254, L"x-mac-turkish", L"x-mac-turkish", L"x-mac-turkish", 0}, // "Turkish (Mac)"
{ 10082,  1250, L"x-mac-croatian", L"x-mac-croatian", L"x-mac-croatian", 0}, // "Croatian (Mac)"
{ 20000,   950, L"x-Chinese-CNS", L"x-Chinese-CNS", L"x-Chinese-CNS", 0}, // "Chinese Traditional (CNS)"
{ 20001,   950, L"x-cp20001", L"x-cp20001", L"x-cp20001", 0}, // "TCA Taiwan"
{ 20002,   950, L"x-Chinese-Eten", L"x-Chinese-Eten", L"x-Chinese-Eten", 0}, // "Chinese Traditional (Eten)"
{ 20003,   950, L"x-cp20003", L"x-cp20003", L"x-cp20003", 0}, // "IBM5550 Taiwan"
{ 20004,   950, L"x-cp20004", L"x-cp20004", L"x-cp20004", 0}, // "TeleText Taiwan"
{ 20005,   950, L"x-cp20005", L"x-cp20005", L"x-cp20005", 0}, // "Wang Taiwan"
{ 20105,  1252, L"x-IA5", L"x-IA5", L"x-IA5", 0}, // "Western European (IA5)"
{ 20106,  1252, L"x-IA5-German", L"x-IA5-German", L"x-IA5-German", 0}, // "German (IA5)"
{ 20107,  1252, L"x-IA5-Swedish", L"x-IA5-Swedish", L"x-IA5-Swedish", 0}, // "Swedish (IA5)"
{ 20108,  1252, L"x-IA5-Norwegian", L"x-IA5-Norwegian", L"x-IA5-Norwegian", 0}, // "Norwegian (IA5)"
{ 20127,  1252, L"us-ascii", L"us-ascii", L"us-ascii", MIMECONTF_MAILNEWS | MIMECONTF_SAVABLE_MAILNEWS | 0}, // "US-ASCII"
{ 20261,  1252, L"x-cp20261", L"x-cp20261", L"x-cp20261", 0}, // "T.61"
{ 20269,  1252, L"x-cp20269", L"x-cp20269", L"x-cp20269", 0}, // "ISO-6937"
{ 20273,  1252, L"IBM273", L"IBM273", L"IBM273", 0}, // "IBM EBCDIC (Germany)"
{ 20277,  1252, L"IBM277", L"IBM277", L"IBM277", 0}, // "IBM EBCDIC (Denmark-Norway)"
{ 20278,  1252, L"IBM278", L"IBM278", L"IBM278", 0}, // "IBM EBCDIC (Finland-Sweden)"
{ 20280,  1252, L"IBM280", L"IBM280", L"IBM280", 0}, // "IBM EBCDIC (Italy)"
{ 20284,  1252, L"IBM284", L"IBM284", L"IBM284", 0}, // "IBM EBCDIC (Spain)"
{ 20285,  1252, L"IBM285", L"IBM285", L"IBM285", 0}, // "IBM EBCDIC (UK)"
{ 20290,   932, L"IBM290", L"IBM290", L"IBM290", 0}, // "IBM EBCDIC (Japanese katakana)"
{ 20297,  1252, L"IBM297", L"IBM297", L"IBM297", 0}, // "IBM EBCDIC (France)"
{ 20420,  1256, L"IBM420", L"IBM420", L"IBM420", 0}, // "IBM EBCDIC (Arabic)"
{ 20423,  1253, L"IBM423", L"IBM423", L"IBM423", 0}, // "IBM EBCDIC (Greek)"
{ 20424,  1255, L"IBM424", L"IBM424", L"IBM424", 0}, // "IBM EBCDIC (Hebrew)"
{ 20833,   949, L"x-EBCDIC-KoreanExtended", L"x-EBCDIC-KoreanExtended", L"x-EBCDIC-KoreanExtended", 0}, // "IBM EBCDIC (Korean Extended)"
{ 20838,   874, L"IBM-Thai", L"IBM-Thai", L"IBM-Thai", 0}, // "IBM EBCDIC (Thai)"
{ 20866,  1251, L"koi8-r", L"koi8-r", L"koi8-r", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Cyrillic (KOI8-R)"
{ 20871,  1252, L"IBM871", L"IBM871", L"IBM871", 0}, // "IBM EBCDIC (Icelandic)"
{ 20880,  1251, L"IBM880", L"IBM880", L"IBM880", 0}, // "IBM EBCDIC (Cyrillic Russian)"
{ 20905,  1254, L"IBM905", L"IBM905", L"IBM905", 0}, // "IBM EBCDIC (Turkish)"
{ 20924,  1252, L"IBM00924", L"IBM00924", L"IBM00924", 0}, // "IBM Latin-1"
{ 20932,   932, L"EUC-JP", L"EUC-JP", L"EUC-JP", 0}, // "Japanese (JIS 0208-1990 and 0212-1990)"
{ 20936,   936, L"x-cp20936", L"x-cp20936", L"x-cp20936", 0}, // "Chinese Simplified (GB2312-80)"
{ 20949,   949, L"x-cp20949", L"x-cp20949", L"x-cp20949", 0}, // "Korean Wansung"
{ 21025,  1251, L"cp1025", L"cp1025", L"cp1025", 0}, // "IBM EBCDIC (Cyrillic Serbian-Bulgarian)"
{ 21027,  1252, L"x-cp21027", L"x-cp21027", L"x-cp21027", 0}, // "Ext Alpha Lowercase"
{ 21866,  1251, L"koi8-u", L"koi8-u", L"koi8-u", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Cyrillic (KOI8-U)"
{ 28591,  1252, L"iso-8859-1", L"iso-8859-1", L"iso-8859-1", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Western European (ISO)"
{ 28592,  1250, L"iso-8859-2", L"iso-8859-2", L"iso-8859-2", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Central European (ISO)"
{ 28593,  1254, L"iso-8859-3", L"iso-8859-3", L"iso-8859-3", MIMECONTF_MAILNEWS | MIMECONTF_SAVABLE_MAILNEWS | 0}, // "Latin 3 (ISO)"
{ 28594,  1257, L"iso-8859-4", L"iso-8859-4", L"iso-8859-4", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Baltic (ISO)"
{ 28595,  1251, L"iso-8859-5", L"iso-8859-5", L"iso-8859-5", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Cyrillic (ISO)"
{ 28596,  1256, L"iso-8859-6", L"iso-8859-6", L"iso-8859-6", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Arabic (ISO)"
{ 28597,  1253, L"iso-8859-7", L"iso-8859-7", L"iso-8859-7", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Greek (ISO)"
{ 28598,  1255, L"iso-8859-8", L"iso-8859-8", L"iso-8859-8", MIMECONTF_BROWSER | MIMECONTF_SAVABLE_BROWSER | 0}, // "Hebrew (ISO-Visual)"
{ 28599,  1254, L"iso-8859-9", L"iso-8859-9", L"iso-8859-9", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Turkish (ISO)"
{ 28603,  1257, L"iso-8859-13", L"iso-8859-13", L"iso-8859-13", 0}, // "Estonian (ISO)"
{ 28605,  1252, L"iso-8859-15", L"iso-8859-15", L"iso-8859-15", MIMECONTF_MAILNEWS | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Latin 9 (ISO)"
{ 29001,  1252, L"x-Europa", L"x-Europa", L"x-Europa", 0}, // "Europa"
{ 38598,  1255, L"iso-8859-8-i", L"iso-8859-8-i", L"iso-8859-8-i", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Hebrew (ISO-Logical)"
{ 50000, 50000, L"x-user-defined", L"x-user-defined", L"x-user-defined", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "User Defined"
{ 50220,   932, L"iso-2022-jp", L"iso-2022-jp", L"iso-2022-jp", MIMECONTF_MAILNEWS | MIMECONTF_SAVABLE_MAILNEWS | 0}, // "Japanese (JIS)"
{ 50221,   932, L"csISO2022JP", L"iso-2022-jp", L"iso-2022-jp", MIMECONTF_MAILNEWS | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Japanese (JIS-Allow 1 byte Kana)"
{ 50222,   932, L"iso-2022-jp", L"iso-2022-jp", L"iso-2022-jp", 0}, // "Japanese (JIS-Allow 1 byte Kana - SO/SI)"
{ 50225,   949, L"iso-2022-kr", L"euc-kr", L"iso-2022-kr", MIMECONTF_MAILNEWS | 0}, // "Korean (ISO)"
{ 50227,   936, L"x-cp50227", L"x-cp50227", L"x-cp50227", 0}, // "Chinese Simplified (ISO-2022)"
//{ 50229,   950, L"x-cp50229", L"x-cp50229", L"x-cp50229", 0}, // "Chinese Traditional (ISO-2022)"
{ 50930,   932, L"cp930", L"cp930", L"cp930", 0}, // "IBM EBCDIC (Japanese and Japanese Katakana)"
{ 50931,   932, L"x-EBCDIC-JapaneseAndUSCanada", L"x-EBCDIC-JapaneseAndUSCanada", L"x-EBCDIC-JapaneseAndUSCanada", 0}, // "IBM EBCDIC (Japanese and US-Canada)"
{ 50933,   949, L"cp933", L"cp933", L"cp933", 0}, // "IBM EBCDIC (Korean and Korean Extended)"
{ 50935,   936, L"cp935", L"cp935", L"cp935", 0}, // "IBM EBCDIC (Simplified Chinese)"
{ 50937,   950, L"cp937", L"cp937", L"cp937", 0}, // "IBM EBCDIC (Traditional Chinese)"
{ 50939,   932, L"cp939", L"cp939", L"cp939", 0}, // "IBM EBCDIC (Japanese and Japanese-Latin)"
{ 51932,   932, L"euc-jp", L"euc-jp", L"euc-jp", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Japanese (EUC)"
{ 51936,   936, L"EUC-CN", L"EUC-CN", L"EUC-CN", 0}, // "Chinese Simplified (EUC)"
{ 51949,   949, L"euc-kr", L"euc-kr", L"euc-kr", MIMECONTF_MAILNEWS | MIMECONTF_SAVABLE_MAILNEWS | 0}, // "Korean (EUC)"
{ 52936,   936, L"hz-gb-2312", L"hz-gb-2312", L"hz-gb-2312", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Chinese Simplified (HZ)"
{ 54936,   936, L"GB18030", L"GB18030", L"GB18030", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Chinese Simplified (GB18030)"
{ 57002, 57002, L"x-iscii-de", L"x-iscii-de", L"x-iscii-de", 0}, // "ISCII Devanagari"
{ 57003, 57003, L"x-iscii-be", L"x-iscii-be", L"x-iscii-be", 0}, // "ISCII Bengali"
{ 57004, 57004, L"x-iscii-ta", L"x-iscii-ta", L"x-iscii-ta", 0}, // "ISCII Tamil"
{ 57005, 57005, L"x-iscii-te", L"x-iscii-te", L"x-iscii-te", 0}, // "ISCII Telugu"
{ 57006, 57006, L"x-iscii-as", L"x-iscii-as", L"x-iscii-as", 0}, // "ISCII Assamese"
{ 57007, 57007, L"x-iscii-or", L"x-iscii-or", L"x-iscii-or", 0}, // "ISCII Oriya"
{ 57008, 57008, L"x-iscii-ka", L"x-iscii-ka", L"x-iscii-ka", 0}, // "ISCII Kannada"
{ 57009, 57009, L"x-iscii-ma", L"x-iscii-ma", L"x-iscii-ma", 0}, // "ISCII Malayalam"
{ 57010, 57010, L"x-iscii-gu", L"x-iscii-gu", L"x-iscii-gu", 0}, // "ISCII Gujarati"
{ 57011, 57011, L"x-iscii-pa", L"x-iscii-pa", L"x-iscii-pa", 0}, // "ISCII Punjabi"
{ 65000,  1200, L"utf-7", L"utf-7", L"utf-7", MIMECONTF_MAILNEWS | MIMECONTF_SAVABLE_MAILNEWS | 0}, // "Unicode (UTF-7)"
{ 65001,  1200, L"utf-8", L"utf-8", L"utf-8", MIMECONTF_MAILNEWS | MIMECONTF_BROWSER | MIMECONTF_SAVABLE_MAILNEWS | MIMECONTF_SAVABLE_BROWSER | 0}, // "Unicode (UTF-8)"
// End of data.
{ 0, 0, NULL, NULL, NULL, 0 },
};

const COMNlsInfo::m_nCodePageTableItems = 
    sizeof(COMNlsInfo::CodePageDataTable)/sizeof(CodePageDataItem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\globalizationassembly.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include <winnls.h>
#include "NLSTable.h"

#include "GlobalizationAssembly.h"
#include "SortingTableFile.h"
#include "SortingTable.h"

#include "excep.h"

NativeGlobalizationAssembly* NativeGlobalizationAssembly::m_pHead = NULL;
NativeGlobalizationAssembly* NativeGlobalizationAssembly::m_pCurrent = NULL;
/*=================================AddToList==========================
**Action: Add the newly created NativeGlobalizationAssembly into a linked list.
**Returns: Void
**Arguments:
**      pNGA    the newly created NativeGlobalizationAssembly
**Exceptions: None.
**Notes:
**      When a new instance of NativeGlobalizationAssembly is created, you should 
**      call this method to add the instance to a linked list.
**      When the runtime is shutdown, we will use this linked list to shutdown
**      every instances of NativeGlobalizationAssembly.
============================================================================*/
void NativeGlobalizationAssembly::AddToList(NativeGlobalizationAssembly* pNGA) {
    if (m_pHead == NULL) {
        // This is the first node of the linked list.
        m_pCurrent = m_pHead = pNGA;
    } else {
        // Otherwise, link the previous node to the current node.
        m_pCurrent->m_pNext = pNGA;
        m_pCurrent = pNGA;
    }
}

/*==========================FindGlobalizationAssembly===========================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
NativeGlobalizationAssembly *NativeGlobalizationAssembly::FindGlobalizationAssembly(Assembly *targetAssembly) {
    NativeGlobalizationAssembly *pNode = m_pHead;
    while (pNode!=NULL) {
        if (targetAssembly==pNode->m_pAssembly) {
            return pNode;
        }
        pNode = pNode->m_pNext;
        //Remove this assert in vNext. 
        //However, if you see it in this version, it means that we're allocating
        //too much memory.
        _ASSERTE(pNode==NULL);  
    }
    return NULL;
}

/*=================================ShutDown==========================
**Action: Enumerate every node (which contains instance of NativeGlobalizationAssembly) in the linked list,
**      and call proper shutdown methods for every instance.
**Returns: None.
**Arguments:    None.
**Exceptions:   None.
**Notes:
**      When runtime shutdowns, you should call this methods to clean up every instance of 
============================================================================*/

#ifdef SHOULD_WE_CLEANUP
void NativeGlobalizationAssembly::ShutDown() {
    NativeGlobalizationAssembly* pNode = m_pHead;
    while (pNode != NULL) {
        // Call shutdown methods for this node.
        pNode->m_pSortingTable->SortingTableShutdown();
		delete pNode->m_pSortingTable;
		
        // Save the current instance in a temp buffer.
        NativeGlobalizationAssembly* pNodeToDelete = pNode;

        pNode = pNode->m_pNext;

        // Clean up the currnet instance.
        delete pNodeToDelete;
    }
}
#endif /* SHOULD_WE_CLEANUP */



NativeGlobalizationAssembly::NativeGlobalizationAssembly(Assembly* pAssembly) :
    NLSTable(pAssembly)
{
    // For now, we create SortingTable by default.
    // This is beause SortingTable is the only NLS+ data table to support Assembly versioning.
    // However, if we have more classes (CultureInfo, RegionInfo, etc.) to support versioning.
    // We should create SortingTable on demand.
    m_pSortingTable = new SortingTable(this);
    m_pNext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\globalizationassembly.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _NLS_ASSEMBLY
#define _NLS_ASSEMBLY

class SortingTable;

class NativeGlobalizationAssembly : public NLSTable {
public:
    static void AddToList(NativeGlobalizationAssembly* pNGA);
#ifdef SHOULD_WE_CLEANUP
    static void ShutDown();
#endif /* SHOULD_WE_CLEANUP */
    static NativeGlobalizationAssembly *FindGlobalizationAssembly(Assembly *targetAssembly);

    NativeGlobalizationAssembly(Assembly* pAssembly);
public:

    SortingTable* m_pSortingTable;

private:
    // Use the following two to construct a linked list of the NativeGlboalizationAssembly.
    // We will use this linked list to shutdown the NativeGlobalizationAssembly
    // ever created in the system.

    // The head of the linked list.
    static NativeGlobalizationAssembly* m_pHead;
    // The current node of the linked list.
    static NativeGlobalizationAssembly* m_pCurrent;
    
    //The next GlobalizationAssembly in the list.
    NativeGlobalizationAssembly* m_pNext;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\jamo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    jamo.c

Abstract:

    This file contains functions that deal with the sorting of old Hangul.  
    Korean characters (Hangul) can be composed by Jamos (U+1100 - U+11ff).
    However, some valid compositions of Jamo are not found in mordern
    Hangul (U+AC00 - U+D7AF).
    These valid compositions are called old Hangul.

    MapOldHangulSortKey() is called by CompareString() and MapSortKey() to
    handle the sorting of old Hangul.

Note:

    The Jamo composition means that several Jamo (Korean alpahbetic) composed
    a valid Hangul character or old Hangul character.
    Eg. U+1100 U+1103 U+1161 U+11a8 composes a valid old Hangul character.

    The following are data members of the global structure pTblPtrs used by
    old Hangul sorting:
        * pTblPtrs->pJamoIndex
            Given a Jamo, this is the index into the pJamoComposition state
              machine for this Jamo.
            The value for U+1100 is stored in pJamoIndex[0], U+1101 is in
              pJamoIndex[1], etc.
            The value for U+1100 is 1.  This means the state machine for
              U+1100 is stored in pJamoComposition[1].
            Note that not every Jamo can start a valid composition.  For
              those Jamos that can not start a valid composition, the table
              entry for that Jamo is 0.  E.g. the index for U+1101 is 0.

        * pTblPtrs->NumJamoIndex
            The number of entries in pJamoIndex.  Every index is a WORD.

        * pTblPtrs->pJamoComposition
            This is the Jamo composition state machine. It is used for two
            purposes:
                1. Used to verify a valid Jamo combination that composes an
                     old Hangul character.
                2. If a valid old Hangul composition is found, get the
                     SortInfo for the current combination.

        * pTblPtrs->NumJamoComposition
            The number of entires in pJamoComposition

Revision History:

    05-30-2000    JohnMcCo Create old Hangul sorting algorithm and sample.
    06-23-2000    YSLin    Created.

--*/

#include "common.h"
#include <winnls.h>
#include "ComNLS.h"
#include "NLSTable.h"
#include "GlobalizationAssembly.h"
#include "SortingTableFile.h"
#include "SortingTable.h"

//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  NOT_END_STRING
//
//  Checks to see if the search has reached the end of the string.
//  It returns TRUE if the counter is not at zero (counting backwards) and
//  the null termination has not been reached (if -2 was passed in the count
//  parameter.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NOT_END_STRING(ct, ptr, cchIn)                                     \
    ((ct != 0) && (!((*(ptr) == 0) && (cchIn == -2))))


////////////////////////////////////////////////////////////////////////////
//
//  GET_JAMO_INDEX
//
//  Update the global sort sequence info based on the new state.
//
////////////////////////////////////////////////////////////////////////////


#define GET_JAMO_INDEX(wch)   ((wch) - NLS_CHAR_FIRST_JAMO)

//-------------------------------------------------------------------------//
//                          INTERNAL ROUTINES                              //
//-------------------------------------------------------------------------//

 
////////////////////////////////////////////////////////////////////////////
//
//  UpdateJamoState
//
//  Update the sort result info based on the new state.
//
//  JamoClass   The current Jamo class (LeadingJamo/VowelJamo/TrailingJamo)
//  pSort       The sort information derived from the current state.
//  pSortResult The sort information for the final result.  Used to
//                collect info from pSort.
//
//  06-22-2000    YSLin    Created.
////////////////////////////////////////////////////////////////////////////
 
void NativeCompareInfo::UpdateJamoState(
    int JamoClass,
    PJAMO_SORT_INFO pSort,
    PJAMO_SORT_INFOEX pSortResult)     // new sort sequence information    
{
    //
    // Record if this is a jamo unique to old Hangul.
    //
    pSortResult->m_bOld |= pSort->m_bOld;
    //
    // Update the indices iff the new ones are higher than the current ones.
    //
    if (pSort->m_chLeadingIndex > pSortResult->m_chLeadingIndex)
    {
        pSortResult->m_chLeadingIndex = pSort->m_chLeadingIndex;
    }
    if (pSort->m_chVowelIndex > pSortResult->m_chVowelIndex)
    {
        pSortResult->m_chVowelIndex = pSort->m_chVowelIndex;
    }
    if (pSort->m_chTrailingIndex > pSortResult->m_chTrailingIndex)
    {
        pSortResult->m_chTrailingIndex = pSort->m_chTrailingIndex;
    }
    //
    // Update the extra weights according to the current Jamo class.
    //
    switch (JamoClass)
    {
        case ( NLS_CLASS_LEADING_JAMO ) :
        {
            if (pSort->m_ExtraWeight > pSortResult->m_LeadingWeight)
            {
                pSortResult->m_LeadingWeight = pSort->m_ExtraWeight;
            }
            break;
        }
        case ( NLS_CLASS_VOWEL_JAMO ) :
        {
            if (pSort->m_ExtraWeight > pSortResult->m_VowelWeight)
            {
                pSortResult->m_VowelWeight = pSort->m_ExtraWeight;
            }
            break;
        }
        case ( NLS_CLASS_TRAILING_JAMO ) :
        {
            if (pSort->m_ExtraWeight > pSortResult->m_TrailingWeight)
            {
                pSortResult->m_TrailingWeight = pSort->m_ExtraWeight;
            }
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetJamoComposition
//
//  ppString                pointer to the current Jamo character
//  pCount                  pointer to the current character count (couting backwards)
//  cchSrc                  The total character count (if the value is -2, then the string is null-terminated)
//  currentJamoClass        the current Jamo class.
//  lpJamoTable             The entry in jamo table.
//  JamoSortInfo            the sort information for the final result.
//
//  NOTENOTE This function assumes that the character at *ppString is a leading Jamo.
//
//  06-12-2000    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

int NativeCompareInfo::GetJamoComposition(
    LPCWSTR* ppString,      // The pointer to the current character
    int* pCount,            // The current character count
    int cchSrc,             // The total character length
    int currentJamoClass,   // The current Jamo class.
    JAMO_SORT_INFOEX* JamoSortInfo    // The result Jamo sorting information.
    )
{
    WCHAR wch;
    int JamoClass;    
    int Index;
    PJAMO_TABLE pJamo;
    PJAMO_COMPOSE_STATE lpNext = NULL;
    PJAMO_COMPOSE_STATE pSearchEnd;

    wch = **ppString;
    //
    // Get the Jamo information for the current character.
    //
    pJamo = m_pSortingFile->m_pJamoIndex + GET_JAMO_INDEX(wch);    
    UpdateJamoState(currentJamoClass, &(pJamo->SortInfo), JamoSortInfo);

    //
    // Move on to next character.
    //
    (*ppString)++; 
    while (NOT_END_STRING(*pCount, *ppString, cchSrc))
    {
        wch = **ppString;
        if (!IsJamo(wch))
        {
            // The current character is not a Jamo. We are done with checking the Jamo composition.
            return (-1);
        }        
        if (wch == 0x1160) {
            JamoSortInfo->m_bFiller = TRUE;
        }        
        // Get the Jamo class of it.        
        if (IsLeadingJamo(wch))
        {
            JamoClass = NLS_CLASS_LEADING_JAMO;
        }
        else if (IsTrailingJamo(wch))
        {
            JamoClass = NLS_CLASS_TRAILING_JAMO;
        }
        else
        {
            JamoClass = NLS_CLASS_VOWEL_JAMO;
        }

        if (JamoClass != currentJamoClass)
        {
            return (JamoClass);
        }

        if (lpNext == NULL)
        {
            //
            // Get the index into the Jamo composition information.
            //
            Index = pJamo->Index;
            if (Index == 0)
            {
                return (JamoClass);
            }
            lpNext = m_pSortingFile->m_pJamoComposition + Index;
            pSearchEnd = lpNext + pJamo->TransitionCount;
        }

        //
        // Push the current Jamo (pointed by pString) into a state machine,
        // to check if we have a valid old Hangul composition.
        // During the check, we will also update the sortkey result in JamoSortInfo.
        //        
        while (lpNext < pSearchEnd)
        {
            // Found a match--update the combination pointer and sort info.
            if (lpNext->m_wcCodePoint == wch)
            {
                UpdateJamoState(currentJamoClass, &(lpNext->m_SortInfo), JamoSortInfo);
                lpNext++;
                goto NextChar;
            }
            // No match -- skip all transitions beginning with this code point
            lpNext += lpNext->m_bTransitionCount + 1;
        }
        //
        // We didn't find a valid old Hangul composition for the current character.
        // So return the current Jamo class.
        //
        return (JamoClass);

NextChar:            
        // We are still in a valid old Hangul composition. Go check the next character.
        (*ppString)++; (*pCount)--;
    }

    return (-1);
}

//-------------------------------------------------------------------------//
//                          EXTERNAL ROUTINES                              //
//-------------------------------------------------------------------------//



////////////////////////////////////////////////////////////////////////////
//
//  MapOldHangulSortKey
//
//  Check if the given string has a valid old Hangul composition,
//  If yes, store the sortkey weights for the given string in the destination
//  buffer and return the number of CHARs consumed by the composition.
//  If not, return zero.
//
//  NOTENOTE: This function assumes that string starting from pSrc is a
//            leading Jamo.
//
//  06-12-2000    YSLin    Created.
//
////////////////////////////////////////////////////////////////////////////

SIZE_T NativeCompareInfo::MapOldHangulSortKey(
    LPCWSTR pSrc,       // source string
    int cchSrc,         // the length of the string
    WORD* pUW,          // generated Unicode weight
    LPBYTE pXW          // generated extra weight (3 bytes)
    )
{
    LPCWSTR pString = pSrc;
    JAMO_SORT_INFOEX JamoSortInfo;      // The result Jamo infomation.
    int Count = cchSrc;
    PSORTKEY pWeight;
    int JamoClass;                      // The current Jamo class.

    RtlZeroMemory(&JamoSortInfo, sizeof(JamoSortInfo));
    JamoClass = GetJamoComposition(&pString, &Count, cchSrc, NLS_CLASS_LEADING_JAMO, &JamoSortInfo);
        
    if (JamoClass == NLS_CLASS_VOWEL_JAMO) 
    {
        JamoClass = GetJamoComposition(&pString, &Count, cchSrc, NLS_CLASS_VOWEL_JAMO, &JamoSortInfo);
    }
    if (JamoClass == NLS_CLASS_TRAILING_JAMO)
    {
        GetJamoComposition(&pString, &Count, cchSrc, NLS_CLASS_TRAILING_JAMO, &JamoSortInfo);
    }
    
    //
    //  If we have a valid leading and vowel sequences and this is an old
    //  Hangul,...
    //    
    if (JamoSortInfo.m_bOld)
    {
        //
        // Compute the modern Hangul syllable prior to this composition.
        //    Uses formula from Unicode 3.0 Section 3.11 p54
        //    "Hangul Syllable Composition".
        //
        WCHAR wchModernHangul =
            (JamoSortInfo.m_chLeadingIndex * NLS_JAMO_VOWEL_COUNT + JamoSortInfo.m_chVowelIndex) * NLS_JAMO_TRAILING_COUNT
                + JamoSortInfo.m_chTrailingIndex
                + NLS_HANGUL_FIRST_SYLLABLE;

        if (JamoSortInfo.m_bFiller)
        {
            // Sort before the modern Hangul, instead of after.
            wchModernHangul--;
            // If we fall off the modern Hangul syllable block,... 
            if (wchModernHangul < NLS_HANGUL_FIRST_SYLLABLE)
            {
                // Sort after the previous character (Circled Hangul Kiyeok A)
                wchModernHangul = 0x326e;
            }
            // Shift the leading weight past any old Hangul that sorts after this modern Hangul
            JamoSortInfo.m_LeadingWeight += 0x80;
         }

        pWeight = &(m_pSortKey[wchModernHangul]);
        *pUW = GET_UNICODE((DWORD*)pWeight);
        pXW[0] = JamoSortInfo.m_LeadingWeight;
        pXW[1] = JamoSortInfo.m_VowelWeight;
        pXW[2] = JamoSortInfo.m_TrailingWeight;

        return (SIZE_T)(pString - pSrc);
    }

    //
    //  Otherwise it isn't a valid old Hangul composition and we don't do
    //  anything with it.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\nativetextinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "NLSTable.h"   // class NLSTable
#include "NativeTextInfo.h" // class NativeTextInfo

NativeTextInfo::NativeTextInfo(PCASE pUpperCase844, PCASE pLowerCase844, PCASE pTitleCase844) {
    m_pUpperCase844 = pUpperCase844;
    m_pLowerCase844 = pLowerCase844;
    m_pTitleCase844 = pTitleCase844;
}

NativeTextInfo::~NativeTextInfo() {
}

void NativeTextInfo::DeleteData() {
    delete [] m_pUpperCase844;
    delete [] m_pLowerCase844;
}

WCHAR  NativeTextInfo::ChangeCaseChar(BOOL bIsToUpper, WCHAR wch) {
    return (GetLowerUpperCase(bIsToUpper ? m_pUpperCase844 : m_pLowerCase844, wch));
}

LPWSTR NativeTextInfo::ChangeCaseString
    (BOOL bIsToUpper, int nStrLen, LPWSTR source, LPWSTR target) {
    //_ASSERTE(!source && !target);
    PCASE pCase = (bIsToUpper ? m_pUpperCase844 : m_pLowerCase844);
    for (int i = 0; i < nStrLen; i++) {
        target[i] = GetLowerUpperCase(pCase, source[i]);
    }
    return (target);
}

/*=================================GetTitleCaseChar==========================
**Action: Get the titlecasing for the specified character.
**Returns: The titlecasing character.
**Arguments:
**      wch
**Exceptions: None.
**  Normally, the titlecasing for a certain character is its uppercase form.  However
**  there are certain titlecasing characters (such as "U+01C4 DZ LATIN CAPITAL LETTER
**  DZ WITH CARON"), which needs special handling (the result will be "U+01C5 
**  LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON).
**  These special cases are stored in m_pTitleCase844, which is a 8:4:4 table.
**  
============================================================================*/

WCHAR NativeTextInfo::GetTitleCaseChar(WCHAR wch) {
    //
    // Get the title case casing for wch.
    //
    WCHAR wchResult = GetLowerUpperCase(m_pTitleCase844, wch);
    
    if (wchResult == 0) {
        //
        // In the case like U+01c5, U+01c8, the titlecase chars are themselves.
        // We set up the table so that wchResult is zero.
        // So if we see the result is zero, just return wch itself.
        // This setup of table is necessary since the logic below.
        // When wchResult == wch, we will get the titlecase char from
        // the upper case table.  So we need a special way to deal the
        // U+01c5/U+01c8/etc. case.
        //
        return (wch);
    }
    //
    // If the wchResult is the same as wch, it means that this character
    // is not a titlecase character, so it doesn't not have a special 
    // titlecasing case (such as dz ==> Dz).
    // So we have to get the uppercase for this character from the uppercase table.
    //
    if (wchResult == wch) {
        wchResult = GetLowerUpperCase(m_pUpperCase844, wch);
    }
    return (wchResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\nativetextinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __NATIVE_TEXTINFO_H
#define __NATIVE_TEXTINFO_H

typedef  P844_TABLE    PCASE;        // ptr to Lower or Upper Case table

class NativeTextInfo {
    public:
        NativeTextInfo(PCASE pUpperCase844, PCASE pLowerCase844, PCASE pTitleCase844);
        ~NativeTextInfo();
        void DeleteData();
        
        WCHAR  ChangeCaseChar(BOOL bIsToUpper, WCHAR wch);
        LPWSTR ChangeCaseString(BOOL bIsToUpper, int nStrLen, LPWSTR source, LPWSTR target);
        WCHAR GetTitleCaseChar(WCHAR wch);
        
    private:        
        inline WCHAR GetIncrValue(LPWORD p844Tbl, WCHAR wch)
        {
             return ((WCHAR)(wch + Traverse844Word(p844Tbl, wch)));
        }

        inline WCHAR GetLowerUpperCase(PCASE pCase844, WCHAR wch)
        {
            return (GetIncrValue(pCase844, wch));
        };
        
    private:
        PCASE   m_pUpperCase844;
        PCASE   m_pLowerCase844; 
        PCASE   m_pTitleCase844;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\regioninfotable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _USE_NLS_PLUS_TABLE
////////////////////////////////////////////////////////////////////////////
//
//  Class:    RegionInfoTable
//
//  Author:   Yung-Shin Lin (YSLin)
//
//  Purpose:  Used to retrieve Region information from Region.nlp & registry.
//
//
//  Date:     01/21/2000
//
////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include <winnls.h>
#include "COMString.h"
#include "winwrap.h"

#include "COMNlsInfo.h"
#include "NLSTable.h"
#include "BaseInfoTable.h"
#include "RegionInfoTable.h"

LPCSTR RegionInfoTable::m_lpFileName    	= "region.nlp";
LPCWSTR RegionInfoTable::m_lpwMappingName 	= L"_nlsplus_region_1_0_3627_11_nlp";

CRITICAL_SECTION RegionInfoTable::m_ProtectDefaultTable;
RegionInfoTable * RegionInfoTable::m_pDefaultTable;

/*=================================RegionInfoTable============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

RegionInfoTable::RegionInfoTable() :
    BaseInfoTable(SystemDomain::SystemAssembly()) {
    InitializeCriticalSection(&m_ProtectCache);
    InitDataTable(m_lpwMappingName, m_lpFileName, m_hBaseHandle);
    //
    // In Region ID Offset Table, the first level is the offset which points to the second level table.
    // The size of the first level table is (the number of primary languages) * 2 words.
    //
    m_pIDOffsetTableLevel2 = (LPWORD)((LPBYTE)m_pIDOffsetTable + (m_pHeader->maxPrimaryLang + 1) * 4);
}

/*=================================~RegionInfoTable============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/

RegionInfoTable::~RegionInfoTable() {
    DeleteCriticalSection(&m_ProtectCache);
    UninitDataTable();
}

/*==========================InitializeCultureInfoTable==========================
**Action: Intialize critical section variables so they will be only initialized once. 
**        Used by COMNlsInfo::InitializeNLS().
**Returns: None.
**Arguments: None.
**Exceptions: None.
==============================================================================*/

void RegionInfoTable::InitializeTable() {
    InitializeCriticalSection(&m_ProtectDefaultTable);
}

/*===========================ShutdownCultureInfoTable===========================
**Action: Deletes any items that we may have allocated into the RegionInfoTable 
**        cache.  Once we have our own NLS heap, this won't be necessary.
**Returns:    Void
**Arguments:  None.  The side-effect is to free any allocated memory.
**Exceptions: None.
==============================================================================*/

#ifdef SHOULD_WE_CLEANUP
void RegionInfoTable::ShutdownTable() {
    DeleteCriticalSection(&m_ProtectDefaultTable);
    if (m_pDefaultTable) {
        delete m_pDefaultTable;
    }
}
#endif /* SHOULD_WE_CLEANUP */


/*================================AllocateTable=================================
**Action:  This is a very thin wrapper around the constructor. Calls to new can't be
**         made directly in a COMPLUS_TRY block. 
**Returns: A newly allocated RegionInfoTable.
**Arguments: None
**Exceptions: The RegionInfoTable constructor can throw an OutOfMemoryException or
**            an ExecutionEngineException.
==============================================================================*/

RegionInfoTable *RegionInfoTable::AllocateTable() {
    return (new RegionInfoTable());
}


/*===============================CreateInstance================================
**Action:  Create the default instance of RegionInfoTable.  This allocates the table if it hasn't
**         previously been allocated.  We need to carefully wrap the call to AllocateTable
**         because the constructor can throw some exceptions.  Unless we have the
**         try/finally block, the exception will skip the LeaveCriticalSection and
**         we'll create a potential deadlock.
**Returns: A pointer to the default RegionInfoTable.
**Arguments: None 
**Exceptions: Can throw an OutOfMemoryException or an ExecutionEngineException.
==============================================================================*/

RegionInfoTable* RegionInfoTable::CreateInstance() {
    THROWSCOMPLUSEXCEPTION();

    if (m_pDefaultTable==NULL) {
        Thread* pThread = GetThread();
        pThread->EnablePreemptiveGC();

        LOCKCOUNTINCL("CreateInstance in regioninfotable.cpp");						\
        EnterCriticalSection(&m_ProtectDefaultTable);
        
        pThread->DisablePreemptiveGC();
     
        EE_TRY_FOR_FINALLY {
            //Make sure that nobody allocated the table before us.
            if (m_pDefaultTable==NULL) {
                //Allocate the default table and verify that we got one.
                m_pDefaultTable = AllocateTable();
                if (m_pDefaultTable==NULL) {
                    COMPlusThrowOM();
                }
            }
        } EE_FINALLY {
            //We need to leave the critical section regardless of whether
            //or not we were successful in allocating the table.
            LeaveCriticalSection(&m_ProtectDefaultTable);
			LOCKCOUNTDECL("CreateInstance in regioninfotable.cpp");						\

        } EE_END_FINALLY;
    }
    return (m_pDefaultTable);
}

/*=================================GetInstance============================
**Action: Get the default instance of RegionInfoTable.
**Returns: A pointer to the default instance of RegionInfoTable.
**Arguments: None
**Exceptions: None.
**Notes: This method should be called after CreateInstance has been called.
** 
==============================================================================*/

RegionInfoTable *RegionInfoTable::GetInstance() {
    _ASSERTE(m_pDefaultTable);
    return (m_pDefaultTable);
}

/*=================================GetDataItem==================================
**Action: Given a culture ID, return the index which points to
**        the corresponding record in Culture Data Table.
**Returns: an int index points to a record in Culture Data Table.  If no corresponding
**         index to return (because the culture ID is invalid), -1 is returned.
**Arguments:
**		   cultureID the specified culture ID.
**Exceptions: None.
==============================================================================*/

// BUGBUG YSLin: Port this to managed side.
int RegionInfoTable::GetDataItem(int cultureID) {
	WORD wPrimaryLang = PRIMARYLANGID(cultureID);
	WORD wSubLang 	 = SUBLANGID(cultureID);

    //
    // Check if the primary language in the parameter is greater than the max number of
    // the primary language.  If yes, this is an invalid culture ID.
    //
	if (wPrimaryLang > m_pHeader->maxPrimaryLang) {
        return (-1);
	}

    WORD wNumSubLang = m_pIDOffsetTable[wPrimaryLang].numSubLang;

    // Check the following:
    // 1. If the number of sub-languages is zero, it means the primary language ID
    //    is not valid. 
    // 2. Check if the sub-language is in valid range.    
	if (wNumSubLang == 0 || (wSubLang > wNumSubLang)) {
		return (-1);
	}
	//
	// In the Region ID Offset Table, there is not neutral languages.  Therefore, the offset pointed
	// by m_pIDOffsetTable[wPrimaryLang].dataItemIndex is for sub-language 0x01. So we have to
	// subtract wSubLang by one below.
	return (m_pIDOffsetTableLevel2[m_pIDOffsetTable[wPrimaryLang].dataItemIndex + (wSubLang - 1)]);
}

/*=================================GetDataItemCultureID==================================
**Action: Return the language ID for the specified culture data item index.
**Returns: The culture ID.
**Arguments:
**      dataItem an index to a record in the Culture Data Table.
**Exceptions: None.
==============================================================================*/

int RegionInfoTable::GetDataItemCultureID(int dataItem) {
    return (m_pDataTable[dataItem * m_dataItemSize + REGION_ILANGUAGE]);
}
#endif // _USE_NLS_PLUS_TABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\nlstable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include <winwrap.h>
#include <excep.h>          // For COMPlusThrow
#include <AppDomain.hpp>
#include <Assembly.hpp>
#include "NLSTable.h"       // Class declaration

#define MSCORNLP_DLL_NAME   L"mscornlp.dll"

/*=================================NLSTable==========================
**Action: Constructor for NLSTable.  It caches the assembly from which we will read data table files.
**Returns: Create a new NLSTable instance.
**Arguments: pAssembly  the Assembly that NLSTable will retrieve data table files from.
**Exceptions: None.
============================================================================*/

NLSTable::NLSTable(Assembly* pAssembly) {
    _ASSERTE(pAssembly != NULL);
    m_pAssembly = pAssembly;
}

/*=================================OpenDataFile==================================
**Action: Open the specified NLS+ data file from system assembly.
**Returns: The file handle for the required NLS+ data file.
**Arguments: The required NLS+ data file name (in ANSI)
**Exceptions: ExecutionEngineException if error happens in get the data file
**            from system assembly.
==============================================================================*/

HANDLE NLSTable::OpenDataFile(LPCSTR pFileName) {
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(m_pAssembly != NULL);

    DWORD cbResource;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE pbInMemoryResource = NULL;
    //
    // Get the base system assembly (mscorlib.dll to most of us);
    //
    
    //@Consider: If the second parameter to GetResource() is NULL, the resource
    // will be kept in memory, and pbInmMemoryResource will be set.  That
    // may make MapDataFile() unnecessary.

    // Get the resource, and associated file handle, from the assembly.
    if (FAILED(m_pAssembly->GetResource(pFileName, &hFile,
                                        &cbResource, &pbInMemoryResource,
                                        NULL, NULL, NULL))) {
        _ASSERTE(!"Didn't get the resource for System.Globalization.");
        FATAL_EE_ERROR();
    }

    // Get resource could return S_OK, but hFile not be set if
    // the found resource was in-memory.
    _ASSERTE(hFile != INVALID_HANDLE_VALUE);

    return (hFile);
}

/*=================================OpenDataFile==================================
**Action: Open a NLS+ data file from system assembly.
**Returns: The file handle for the required NLS+ data file.
**Arguments: The required NLS+ data file name (in Unicode)
**Exceptions: OutOfMemoryException if buffer can not be allocated.
**            ExecutionEngineException if error happens in calling OpenDataFile(LPCSTR)
==============================================================================*/

HANDLE NLSTable::OpenDataFile(LPCWSTR pFileName)
{
    THROWSCOMPLUSEXCEPTION();
    // The following marco will delete pAnsiFileName when
    // getting out of the scope of this function.
    MAKE_ANSIPTR_FROMWIDE(pAnsiFileName, pFileName);
    if (!pAnsiFileName)
    {
        COMPlusThrowOM();
    }

    // @Consider: OpenDataFile says it can throw a COMPLUS exception - does that mean the result
    //            doesn't need to be checked?
    HANDLE hFile = OpenDataFile((LPCSTR)pAnsiFileName);
    _ASSERTE(hFile != INVALID_HANDLE_VALUE);
    return (hFile);
}

/*=================================CreateSharedFileMapping==================================
**Action: Create a file mapping object which can be shared among different users under Windows NT/2000.
**Returns: The file mapping handle.  NULL if any error happens.
**Arguments:
**      hFile   The file handle
**      pMappingName    the name of the file mapping object.
**Exceptions: 
**Note:
**      This function creates a DACL which grants GENERIC_ALL access to members of the "Everyone" group.
**      Then create a security descriptor using this DACL.  Finally, use this SA to create the file mapping object.
==============================================================================*/

HANDLE NLSTable::CreateSharedFileMapping(HANDLE hFile, LPCWSTR pMappingName ) {    
    HANDLE hFileMap = NULL;
    
    SECURITY_DESCRIPTOR sd ;
    SECURITY_ATTRIBUTES sa ; 

    //
    // Create the sid for the Everyone group.
    //
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID pSID = NULL;     
    int nSidSize;
    
    PACL pDACL = NULL; 
    int nAclSize;

    CQuickBytes newBuffer;
    
    if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSID)) {            
        goto ErrorExit;
    }

    nSidSize = GetLengthSid(pSID);

    //
    // Create Discretionary Access Control List (DACL).
    //
    
    
    // First calculate the size of the DACL, since this is a linked-list like structure which contains one or more 
    // ACE (access control entry)    
    nAclSize = sizeof(ACL)                          // the header structure of ACL
        + sizeof(ACCESS_ALLOWED_ACE) + nSidSize;     // and one "access allowed ACE".

    // We know the size needed for DACL now, so create it.        
    if ((pDACL = (PACL) (newBuffer.Alloc(nAclSize))) == NULL)
        goto ErrorExit; 
    if(!InitializeAcl( pDACL, nAclSize, ACL_REVISION ))
        goto ErrorExit;  

    // Add the "access allowed ACE", meaning:
    //    we will allow members of the "Everyone" group to have SECTION_MAP_READ | SECTION_QUERY access to the file mapping object.
    if(!AddAccessAllowedAce( pDACL, ACL_REVISION, SECTION_MAP_READ | SECTION_QUERY, pSID ))
        goto ErrorExit; 

    //
    // Create Security descriptor (SD).
    //
    if(!InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION ))
        goto ErrorExit; 
    // Set the previously created DACL to this SD.
    if(!SetSecurityDescriptorDacl( &sd, TRUE, pDACL, FALSE ))
        goto ErrorExit; 

    // Create Security Attribute (SA).        
    sa.nLength = sizeof( sa ) ;
    sa.bInheritHandle = TRUE ; 
    sa.lpSecurityDescriptor = &sd ;

    //
    // Finally, create the file mapping using the SA.
    //
    hFileMap = WszCreateFileMapping(hFile, &sa, PAGE_READONLY, 0, 0, pMappingName);
    if (hFileMap==NULL && ::GetLastError()==ERROR_ACCESS_DENIED) {
        // The semantics that we have for CreateSharedFileMapping is that it returns a 
        // a pointer to the opened file map.  If the file mapping was already created by
        // another process (or, potentially, another thread in this process) the DACL
        // has already been set.  Because we explicitly add the AccessDenied ACL, we can't
        // go set the ACL on the file twice (as calling CreateFileMapping twice will do).  
        // If CreateFileMapping fails with an access denied, try opening the file mapping
        // to see if it was already mapped correctly on another thread.
        hFileMap = WszOpenFileMapping(FILE_MAP_READ, TRUE, pMappingName);
    }

ErrorExit:    
    if(pSID)
        FreeSid( pSID ) ;        

    return (hFileMap) ;
}

/*=================================MapDataFile==================================
**Action: Open a named file mapping object specified by pMappingName.  If the
**  file mapping object is not created yet, create it from the file specified
**  by pFileName.
**Returns: a LPVOID pointer points to the view of the file mapping object.
**Arguments:
**  pMappingName: the name used to create file mapping.
**  pFileName: the required file name.
**  hFileMap: used to return the file mapping handle.
**Exceptions: ExecutionEngineException if error happens.
==============================================================================*/


#ifndef _USE_MSCORNLP
LPVOID NLSTable::MapDataFile(LPCWSTR pMappingName, LPCSTR pFileName, HANDLE *hFileMap) {
    _ASSERTE(pMappingName != NULL); // Must be a named file mapping object.
    _ASSERTE(pFileName != NULL);    // Must have a valid file name.
    _ASSERTE(hFileMap != NULL);     // Must have a valid location for the handle.

    THROWSCOMPLUSEXCEPTION();

    *hFileMap = NULL;
    LPVOID pData=NULL; //It's silly to have this up here, but it makes the compiler happy.

    //
    // Check to see if this file mapping is created already?
    //    
    *hFileMap = WszOpenFileMapping(FILE_MAP_READ, TRUE, pMappingName);
    if (*hFileMap == NULL) {
        //
        // The file mapping is not done yet.  Create the file mapping using the specified pMappingName.
        //
        HANDLE hFile = OpenDataFile(pFileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            goto ErrorExit;
        }

        BOOL isRunningOnWinNT = RunningOnWinNT();
        if (isRunningOnWinNT) {
            *hFileMap = CreateSharedFileMapping(hFile, pMappingName);
        } else {
            // In Windows 9x, security is not supported, so just pass NULL in security attribute.
            *hFileMap = WszCreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, pMappingName);
        }
        
        if (*hFileMap == NULL) {
            _ASSERTE(!"Error in CreateFileMapping");
            CloseHandle(hFile);
            goto ErrorExit;
        }
        CloseHandle(hFile);
    }
    //
    // Map a view of the file mapping.
    //
    pData = MapViewOfFile(*hFileMap, FILE_MAP_READ, 0, 0, 0);
    if (pData == NULL)
    {
        _ASSERTE(!"Error in MapViewOfFile");
        goto ErrorExit;
    }

    return (pData);
            
 ErrorExit:
    if (*hFileMap) {
        CloseHandle(*hFileMap);
    }

    //If we can't get the table, we're in trouble anyway.  Throw an EE Exception.
    FATAL_EE_ERROR();
    return NULL;
}
#else
// BUGBUG YSLin: Not implemented yet for CE.
LPVOID NLSTable::MapDataFile(LPCWSTR pMappingName, LPCSTR pFileName, HANDLE *hFileMap) {
    int resultSize = 0;
    CQuickBytes newBuffer;

    //
    //Verify that we have at least a somewhat valid string
    //
    _ASSERTE(pFileName && pFileName[0]!='\0');

    //
    //Get the largest buffer that we can from the CQuickBytes without causing an alloc.
    //We don't need to check this memory because we're just taking a pointer to memory
    //already on the stack.
    //
    LPWSTR pwszFileName = (WCHAR *)newBuffer.Alloc(CQUICKBYTES_BASE_SIZE); 
    int numWideChars = CQUICKBYTES_BASE_SIZE/sizeof(WCHAR);

    resultSize = WszMultiByteToWideChar(CP_ACP,  MB_PRECOMPOSED, pFileName, -1, pwszFileName, numWideChars);

    //
    // We failed.  This may be because the buffer wasn't big enough, so lets take the time to go 
    // figure out what the correct size should be (don't some windows APIs take the number of bytes as 
    // an out param to avoid this very step?)
    //
    if (resultSize == 0) {
        //
        // If we failed because of an insufficient buffer condition, lets go find the correct size
        // allocate that buffer and try this again.  If we failed for some other reason, simply throw.
        //
        DWORD error = ::GetLastError();
        if (error==ERROR_INSUFFICIENT_BUFFER) {
            resultSize = WszMultiByteToWideChar(CP_ACP,  MB_PRECOMPOSED, pFileName, -1, NULL, 0);
            if (resultSize == 0) {
                _ASSERTE(!"WszMultiByteToWideChar Failed in MapDataFile");
                FATAL_EE_ERROR();
            }

            pwszFileName = (WCHAR *)(newBuffer.Alloc(resultSize * sizeof(WCHAR)));
            if (!pwszFileName) {
                COMPlusThrowOM();
            }

            int result = WszMultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pFileName, -1, pwszFileName, resultSize);
            if (result==0) {
                _ASSERTE(!"WszMultiByteToWideChar Failed in MapDataFile");
                FATAL_EE_ERROR();
            }
        } else {
            _ASSERTE(!"WszMultiByteToWideChar Failed in MapDataFile with an unexpected error");
            FATAL_EE_ERROR();
        }
    }

    LPVOID result = MapDataFile(pMappingName, pwszFileName, hFileMap);

    return (result);
}
#endif    


/*=================================MapDataFile==================================
**Action: Open a named file mapping object specified by pMappingName.  If the
**  file mapping object is not created yet, create it from the file specified
**  by pFileName.
**Returns: a LPVOID pointer points to the view of the file mapping object.
**Arguments:
**  pMappingName: the name used to create file mapping.
**  pFileName: the required file name.
**  hFileMap: used to return the file mapping handle.
**Exceptions: ExecutionEngineException if error happens.
==============================================================================*/

LPVOID NLSTable::MapDataFile(LPCWSTR pMappingName, LPCWSTR pFileName, HANDLE *hFileMap) 
#ifndef _USE_MSCORNLP
{    
    THROWSCOMPLUSEXCEPTION();
    // The following marco will delete pAnsiFileName when
    // getting out of the scope of this function.
    MAKE_ANSIPTR_FROMWIDE(pAnsiFileName, pFileName);
    if (!pAnsiFileName)
    {
        COMPlusThrowOM();
    }

    // @Consider: OpenDataFile says it can throw a COMPLUS exception - does that mean the result
    //            doesn't need to be checked?
    return (MapDataFile(pMappingName, pAnsiFileName, hFileMap));
}
#else
{
    THROWSCOMPLUSEXCEPTION();
    GETTABLE* pGetTable;
    HMODULE hMSCorNLP;

    DWORD lgth = _MAX_PATH + 1;
    WCHAR wszFile[_MAX_PATH + 1 + sizeof(MSCORNLP_DLL_NAME) /sizeof(MSCORNLP_DLL_NAME[0]) ];
    HRESULT hr = GetInternalSystemDirectory(wszFile, &lgth);
    if(FAILED(hr)) 
        COMPlusThrowHR(hr);

    wcscat(wszFile, MSCORNLP_DLL_NAME);
    hMSCorNLP = WszLoadLibrary(wszFile);
    if (hMSCorNLP == NULL) {
        _ASSERTE(!"Can't load mscornlp.dll.");
        FATAL_EE_ERROR();
    }
    pGetTable = (GETTABLE*)GetProcAddress(hMSCorNLP, "GetTable");
    if (pGetTable == NULL) {
        _ASSERTE(!"Can't load function GetTable() in mscornlp.dll.");
        FATAL_EE_ERROR();
    }
    LPVOID result = (LPVOID)(pGetTable(pFileName));
    FreeLibrary(hMSCorNLP);
    return (result);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\regioninfotable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __REGION_INFO_TABLE
#define __REGION_INFO_TABLE

class RegionInfoTable: public BaseInfoTable {
    public:
        static void InitializeTable();
#ifdef SHOULD_WE_CLEANUP
        static void ShutdownTable();
#endif /* SHOULD_WE_CLEANUP */
        static RegionInfoTable* CreateInstance();
        static RegionInfoTable* GetInstance();

        virtual int  GetDataItem(int cultureID);

    protected:
        virtual int GetDataItemCultureID(int dataItem); 
    private:
        static RegionInfoTable* AllocateTable();
        
        RegionInfoTable();
        ~RegionInfoTable();

        //
        // Second level of Region ID offset table.
        // This points to the real offset of a record in Region Data Table.
        //
        LPWORD  m_pIDOffsetTableLevel2;        
    private:
        static LPCSTR m_lpFileName;
        static LPCWSTR m_lpwMappingName;

        static CRITICAL_SECTION  m_ProtectDefaultTable;
        static RegionInfoTable* m_pDefaultTable;    
};

//
// The list of WORD fields:
//

#define REGION_ICOUNTRY  0
#define REGION_IMEASURE  1
#define REGION_ILANGUAGE  2
#define REGION_IPAPERSIZE  3

//
// The list of string fields
//

#define REGION_SCURRENCY            0
#define REGION_SNAME                1
#define REGION_SENGCOUNTRY          2
#define REGION_SABBREVCTRYNAME      3
#define REGION_SISO3166CTRYNAME     4
#define REGION_SISO3166CTRYNAME2    5
#define REGION_SINTLSYMBOL          6

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\sources.inc ===
#
#  Viper build instructions for this directory.
#

NO_CRT = 1
!include $(NTMAKEENV)\sources.cor

# WarningControl.h disables too many warnings.  VM folder will not use it.
COMPILER_WARNINGS	=/WX

INCLUDES = $(INCLUDES);..;..\..;..\..\inc;..\..\..\vm;..\..\..\vm\$(_TGTCPU);..\..\..\inc;..\..\..\..\inc;..\..\..\interp;..\..\..\ceegen\inc;

MINORCOMP = cor

TARGETNAME = $(DDKBUILDENV)\COMNLS_$(_CORFLAVOR)
TARGETPATH = $(TARGETCORBIN)
TARGETTYPE = LIBRARY

!ifndef _BUILD_WINCE
C_DEFINES = $(C_DEFINES) 
!else
C_DEFINES = $(C_DEFINES) -D_USE_MSCORNLP
!endif

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE -DCRTDLL -DUSE_MAPSYM -D_NEW_CLASSLOADER -DJIT_OR_NATIVE_SUPPORTED -D_USE_NLS_PLUS_TABLE


CDEFINES = $(CDEFINES) $(C_DEFINES) -W4

#
#  Causes the appropriate checked/free version of msvcprt{d}.lib
#  to be included in the link.
#  The static versions of this library are libcpmtd.lib (checked)
#  and libcpmt.lib (free).
#
USE_STL = 1

TARGETLIBS =                      \
    $(SDK_LIB_PATH)\ole32.lib     \
    $(SDK_LIB_PATH)\comdlg32.lib

SOURCES =                 \
	..\CalendarTable.cpp \
    ..\COMNlsInfo.cpp        \
    ..\NLSTable.cpp          \
    ..\GlobalizationAssembly.cpp   \
    ..\CasingTable.cpp       \
    ..\BaseInfoTable.cpp     \
    ..\CultureInfoTable.cpp  \
    ..\RegionInfoTable.cpp   \
    ..\SortingTable.cpp \
    ..\SortingTableFile.cpp \
    ..\UnicodeCatTable.cpp \
    ..\jamo.cpp \
    ..\NativeTextInfo.cpp \
    ..\EncodingData.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\sortingtablefile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SORTING_TABLE_FILE_H
#define _SORTING_TABLE_FILE_H

//This is the list of English locales which we currently understand.  
//We should only do fast comparisons in one of these locales.
//@Consider: What non-English locales can we use?
//@Consider: Can we just look at the 0xnn09 to determine English?  (This is limiting in the future, because
//      it will bite us if we ever have install an English locale that has combining characters or
//      a different sorting order for characters less than 0x80.
#define IS_FAST_COMPARE_LOCALE(loc) (((loc)==0x0409) /*USA*/     || ((loc)==0x0809) /*UK*/ ||\
                                     ((loc)==0x0C09) /*AUS*/     || ((loc)==0x1009) /*CANADA*/ ||\
                                     ((loc)==0x2809) /*Belize*/  || ((loc)==0x2409) /*Caribean*/ ||\
                                     ((loc)==0x1809) /*Ireland*/ || ((loc)==0x2009) /*Jamaica*/ ||\
                                     ((loc)==0x1409) /*NZ*/      || ((loc)==0x3409) /*Philippines*/ ||\
                                     ((loc)==0x2C09) /*Trinidad*/|| ((loc)==0x1c09) /*South Africa*/ ||\
                                     ((loc)==0x3009) /*Zimbabwe*/)


//
//  Sortkey Structure.
//
typedef struct sortkey_s {

    union {
        struct sm_aw_s {
            BYTE   Alpha;              // alphanumeric weight
            BYTE   Script;             // script member
        } SM_AW;

        WORD  Unicode;                 // unicode weight

    } UW;

    BYTE      Diacritic;               // diacritic weight
    BYTE      Case;                    // case weight (with COMP)

} SORTKEY, *PSORTKEY;


//
//  Ideograph Lcid Exception Structure.
//
typedef struct ideograph_lcid_s {
    DWORD     Locale;                  // locale id
    WORD      pFileName[14];           // ptr to file name
} IDEOGRAPH_LCID, *PIDEOGRAPH_LCID;

//
//  Expansion Structure.
//
typedef struct expand_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
} EXPAND, *PEXPAND;


//
//  Exception Header Structure.
//  This is the header for the exception tables.
//
typedef struct except_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset to exception nodes (words)
    DWORD     NumEntries;              // number of entries for locale id
} EXCEPT_HDR, *PEXCEPT_HDR;


//
//  Exception Structure.
//
//  NOTE: May also be used for Ideograph Exceptions (4 column tables).
//
typedef struct except_s
{
    WORD      UCP;                     // unicode code point
    WORD      Unicode;                 // unicode weight
    BYTE      Diacritic;               // diacritic weight
    BYTE      Case;                    // case weight
} EXCEPT, *PEXCEPT;


//
//  Ideograph Exception Header Structure.
//
typedef struct ideograph_except_hdr_s
{
    DWORD     NumEntries;              // number of entries in table
    DWORD     NumColumns;              // number of columns in table (2 or 4)
} IDEOGRAPH_EXCEPT_HDR, *PIDEOGRAPH_EXCEPT_HDR;


//
//  Ideograph Exception Structure.
//
typedef struct ideograph_except_s
{
    WORD      UCP;                     // unicode code point
    WORD      Unicode;                 // unicode weight
} IDEOGRAPH_EXCEPT, *PIDEOGRAPH_EXCEPT;

typedef  DWORD         REVERSE_DW;     // reverse diacritic table
typedef  REVERSE_DW   *PREVERSE_DW;    // ptr to reverse diacritic table
typedef  DWORD         DBL_COMPRESS;   // double compression table
typedef  DBL_COMPRESS *PDBL_COMPRESS;  // ptr to double compression table
typedef  LPWORD        PCOMPRESS;      // ptr to compression table (2 or 3)

//
//  Extra Weight Structure.
//
typedef struct extra_wt_s {
    BYTE      Four;                    // weight 4
    BYTE      Five;                    // weight 5
    BYTE      Six;                     // weight 6
    BYTE      Seven;                   // weight 7
} EXTRA_WT, *PEXTRA_WT;

//
//  Compression Header Structure.
//  This is the header for the compression tables.
//
typedef struct compress_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset (in words)
    WORD      Num2;                    // Number of 2 compressions
    WORD      Num3;                    // Number of 3 compressions
} COMPRESS_HDR, *PCOMPRESS_HDR;


//
//  Compression 2 Structure.
//  This is for a 2 code point compression - 2 code points
//  compress to ONE weight.
//
typedef struct compress_2_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
    SORTKEY   Weights;                 // sortkey weights
} COMPRESS_2, *PCOMPRESS_2;


//
//  Compression 3 Structure.
//  This is for a 3 code point compression - 3 code points
//  compress to ONE weight.
//
typedef struct compress_3_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
    WCHAR     UCP3;                    // Unicode code point 3
    WCHAR     Reserved;                // dword alignment
    SORTKEY   Weights;                 // sortkey weights
} COMPRESS_3, *PCOMPRESS_3;


//
//  Multiple Weight Structure.
//
typedef struct multiwt_s {
    BYTE      FirstSM;                 // value of first script member
    BYTE      NumSM;                   // number of script members in range
} MULTI_WT, *PMULTI_WT;

// Jamo Sequence Sorting Info:
typedef struct {
    BYTE m_bOld;                        // Sequence occurs only in old Hangul flag
    CHAR m_chLeadingIndex;              // Indices used to locate the prior modern Hangul syllable
    CHAR m_chVowelIndex;
    CHAR m_chTrailingIndex;
    BYTE m_ExtraWeight;              // Extra weights that distinguish this from other old Hangul syllables,
                                       // depending on the jamo, this can be a weight for leading jamo,
                                       // vowel jamo, or trailing jamo.
} JAMO_SORT_INFO, *PJAMO_SORT_INFO;

// Jamo Index Table Entry:
typedef struct {
    JAMO_SORT_INFO SortInfo;               // Sequence sorting info
    BYTE Index;                     // Index into the composition array.
    BYTE TransitionCount;            // Number of possible transitions from this state
    BYTE Reserved;                  // Reserved byte.  To make this structure aligned with WORD.
} JAMO_TABLE, *PJAMO_TABLE;

// Jamo Combination Table Entry:
// NOTENOTE: Make sure that this structure is aligned with WORD.
// Otherwise, code will fail in GetDefaultSortTable().
typedef struct {
    WCHAR m_wcCodePoint;                // Code point value that enters this state
    JAMO_SORT_INFO m_SortInfo;               // Sequence sorting info
    BYTE m_bTransitionCount;            // Number of possible transitions from this state
} JAMO_COMPOSE_STATE, *PJAMO_COMPOSE_STATE;


//
//  Table Header Constants  (all sizes in WORDS).
//
#define SORTKEY_HEADER            2    // size of SORTKEY table header
#define REV_DW_HEADER             2    // size of REVERSE DW table header
#define DBL_COMP_HEADER           2    // size of DOUBLE COMPRESS table header
#define IDEO_LCID_HEADER          2    // size of IDEOGRAPH LCID table header
#define EXPAND_HEADER             2    // size of EXPANSION table header
#define COMPRESS_HDR_OFFSET       2    // offset to COMPRESSION header
#define EXCEPT_HDR_OFFSET         2    // offset to EXCEPTION header
#define MULTI_WT_HEADER           1    // size of MULTIPLE WEIGHTS table header
#define JAMO_INDEX_HEADER           1   // size of Jamo Index table header
#define JAMO_COMPOSITION_HEADER     1   // size of Jamo Composition state machine table hader


#define NUM_SM     256                  // total number of script members

#define LANG_ENGLISH_US 		0x0409

class NativeCompareInfo;
typedef NativeCompareInfo* PNativeCompareInfo;

class SortingTable {
	public:
		SortingTable(NativeGlobalizationAssembly* pNativeGlobalizationAssembly);
		~SortingTable();
    	NativeCompareInfo* InitializeNativeCompareInfo(INT32 nLcid);
#ifdef SHOULD_WE_CLEANUP
    	BOOL SortingTableShutdown();
#endif /* SHOULD_WE_CLEANUP */
		NativeCompareInfo* GetNativeCompareInfo(int nLcid);
		

		// Methods to be called by NativeCompareInfo.
		PSORTKEY GetSortKey(int nLcid, HANDLE* phSortKey);

	public:
		// Information stored in sorting information table (sorttbls.nlp)
		// These are accessed by NativeCompareInfo.
        DWORD            m_NumReverseDW;       // number of REVERSE DIACRITICS
        DWORD            m_NumDblCompression;  // number of DOUBLE COMPRESSION locales
        DWORD            m_NumIdeographLcid;   // number of IDEOGRAPH LCIDs
        DWORD            m_NumExpansion;       // number of EXPANSIONS
        DWORD            m_NumCompression;     // number of COMPRESSION locales
        DWORD            m_NumException;       // number of EXCEPTION locales
        DWORD            m_NumMultiWeight;     // number of MULTIPLE WEIGHTS
        DWORD            m_NumJamoIndex;           // Number of entires for Jamo Index Table
        DWORD            m_NumJamoComposition;     // Number of entires for Jamo Composition Table


        PREVERSE_DW      m_pReverseDW;         // ptr to reverse diacritic table
        PDBL_COMPRESS    m_pDblCompression;    // ptr to double compression table
        PIDEOGRAPH_LCID  m_pIdeographLcid;     // ptr to ideograph lcid table
        PEXPAND          m_pExpansion;         // ptr to expansion table        
        PCOMPRESS_HDR    m_pCompressHdr;       // ptr to compression table header
        PCOMPRESS        m_pCompression;       // ptr to compression tables
        PEXCEPT_HDR      m_pExceptHdr;         // ptr to exception table header
        PEXCEPT          m_pException;         // ptr to exception tables
        PMULTI_WT        m_pMultiWeight;       // ptr to multiple weights table

        BYTE             m_SMWeight[NUM_SM];    // script member weights
        
        PJAMO_TABLE         m_pJamoIndex;                 // ptr ot Jamo Index table.
        PJAMO_COMPOSE_STATE m_pJamoComposition;  // ptr to Jamo Composition state machine table.
        
    private:
    	void InitializeSortingCache();
    	void GetSortInformation();
    	PSORTKEY GetDefaultSortKeyTable(HANDLE *pMapHandle);    
		PSORTKEY GetExceptionSortKeyTable(
	    	PEXCEPT_HDR pExceptHdr,       // ptr to exception header
	        PEXCEPT     pExceptTbl,       // ptr to exception table
	        PVOID       pIdeograph,       // ptr to ideograph exception table
	        HANDLE *    pMapHandle        // ptr to handle map.
	    );

    	BOOL FindExceptionPointers(LCID nLcid, PEXCEPT_HDR *ppExceptHdr, PEXCEPT *ppExceptTbl, PVOID *ppIdeograph);

    	void CopyExceptionInfo(PSORTKEY pSortkey, PEXCEPT_HDR pExceptHdr, PEXCEPT pExceptTbl, PVOID pIdeograph);

    	void GetSortTablesFileInfo();
	private:
        static LPCSTR m_lpSortKeyFileName;
        static LPCWSTR m_lpSortKeyMappingName;
        
        static LPCSTR m_lpSortTableFileName;
        static LPCWSTR m_lpSortTableMappingName;
	
    private:
    	NativeGlobalizationAssembly* m_pNativeGlobalizationAssembly;
    	
    	// File handle to the sorting information table "sorttbls.nlp" file.
        HANDLE m_hSortTable;
        
        // This is the number of supported language ID today.
        static int              m_nLangIDCount;
        
        //The array is one larger than the count.  Rather than always
        //remembering this math, we'll create a variable for it.
        static int              m_nLangArraySize;

        // This table maps the primary language ID to an offset in the m_ppSortingTableCache.
        static BYTE             m_SortingTableOffset[];
        
        // This table caches the pointer to NativeCompareInfo for every supported lcid.
        NativeCompareInfo**   m_ppNativeCompareInfoCache;

        PSORTKEY         m_pDefaultSortKeyTable;

		// This points to the sortkey table in sortkey.nlp.
        LPWORD           m_pSortTable;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\sortingtable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SORTING_TABLE_H
#define _SORTING_TABLE_H

////////////////////////////////////////////////////////////////////////////
//
//  Class:    NativeCompareInfo
//
//  Authors:  Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  This is the class to map views of sorting tables (sortkey.nlp and sorttbls.nlp)
//            and provides methods to do comparision and sortkey generation.
//            MUCH OF THIS CODE IS TAKEN FROM WINNLS.H
//  Note:
//            NLS+ string comparision is based on the concept of the sortkey.
//            sortkey.nlp provides the default sortkey table.
//            Most of the locales uses the default sortkey table.
//
//            However, there are many locales which has different sortkey tables.
//            For these cutlures, we store the 'delta' information to the default sortkey
//            table.  We call these 'delta' information as 'exception'.
//   
//            sorttbls.nlp provides all of the information needed to handle these exceptions.
//
//            There are different kinds of exceptions:
//            1. Locale exceptions
//               These are the locales which have different sortkey tables compared with
//               the default sortkey tables.
//
//            2. Ideographic locale exceptions
//               Ideographic locales often have several sorting methods.  Take Traditional Chinese
//               for example.  It can be sorted using stroke count, or it can be sorted alternatively 
//               using phonetic symbol order (bopomofo order).  For these alternative sorting methods,
//               we call them 'ideographic locale exceptions'.
//
//            sorttbls.nlp also provides the following global information to handle special cases:
//            1. reverse diacritic locales.
//            2. double compression locales.
//            3. expansion characters. (for example, \u00c6 = \u0041 + \u0045)
//            4. multiple weight (what is this?)
//            5. compression locales.
//
//  Performance improvements:
//            Today, we store reverse diacritic information, double compression, compression,
//            and exception information in sorttbls.nlp.  During the runtime, we iterate
//            these information to decide the properties of a locale (to see if they have resverse 
//            diacritic, if they have locale excetions, etc).  This is time-expansive.
//            We can put these information in a per locale basis.  This save us:
//            1. Time to initialize these tables.
//            2. Time to iterate these tables when a NativeCompareInfo is constructed.
//
//  Date: 	  September 7, 1999
//
////////////////////////////////////////////////////////////////////////////

//
//  Constant Declarations.
//

// Compare options.
// These values have to be in sync with CompareOptions (in the managed code).
// Some of the values are different from Win32 NORM_xxxxxx values.

#define COMPARE_OPTIONS_NONE            0x00000000
#define COMPARE_OPTIONS_IGNORECASE       0x00000001
#define COMPARE_OPTIONS_IGNORENONSPACE   0x00000002
#define COMPARE_OPTIONS_IGNORESYMBOLS    0x00000004
#define COMPARE_OPTIONS_IGNOREKANATYPE   0x00000008 // ignore kanatype
#define COMPARE_OPTIONS_IGNOREWIDTH      0x00000010 // ignore width

#define COMPARE_OPTIONS_STRINGSORT       0x20000000 // use string sort method
#define COMPARE_OPTIONS_ORDINAL          0x40000000  // use code-point comparison
#define COMPARE_OPTIONS_STOP_ON_NULL   0x10000000

#define COMPARE_OPTIONS_ALL_CASE     (COMPARE_OPTIONS_IGNORECASE    | COMPARE_OPTIONS_IGNOREKANATYPE |      \
                           COMPARE_OPTIONS_IGNOREWIDTH)

//
//  Separator and Terminator Values - Sortkey String.
//
#define SORTKEY_SEPARATOR    0x01
#define SORTKEY_TERMINATOR   0x00


//
//  Lowest weight values.
//  Used to remove trailing DW and CW values.
//
#define MIN_DW  2
#define MIN_CW  2


//
//  Bit mask values.
//
//  Case Weight (CW) - 8 bits:
//    bit 0   => width
//    bit 1,2 => small kana, sei-on
//    bit 3,4 => upper/lower case
//    bit 5   => kana
//    bit 6,7 => compression
//
#define COMPRESS_3_MASK      0xc0      // compress 3-to-1 or 2-to-1
#define COMPRESS_2_MASK      0x80      // compress 2-to-1

#define CASE_MASK            0x3f      // zero out compression bits

#define CASE_UPPER_MASK      0xe7      // zero out case bits
#define CASE_SMALL_MASK      0xf9      // zero out small modifier bits
#define CASE_KANA_MASK       0xdf      // zero out kana bit
#define CASE_WIDTH_MASK      0xfe      // zero out width bit

#define SW_POSITION_MASK     0x8003    // avoid 0 or 1 in bytes of word

//
//  Bit Mask Values for CompareString.
//
//  NOTE: Due to intel byte reversal, the DWORD value is backwards:
//                CW   DW   SM   AW
//
//  Case Weight (CW) - 8 bits:
//    bit 0   => width
//    bit 4   => case
//    bit 5   => kana
//    bit 6,7 => compression
//
#define CMP_MASKOFF_NONE          0xffffffff
#define CMP_MASKOFF_DW            0xff00ffff		//11111111 00000000 11111111 11111111
#define CMP_MASKOFF_CW            0xe7ffffff		//11100111 11111111 11111111 11111111
#define CMP_MASKOFF_DW_CW         0xe700ffff
#define CMP_MASKOFF_COMPRESSION   0x3fffffff		//00111111 11111111 11111111 11111111

#define CMP_MASKOFF_KANA          0xdfffffff		//11011111 11111111 11111111 11111111
#define CMP_MASKOFF_WIDTH         0xfeffffff		//11111110 11111111 11111111 11111111
#define CMP_MASKOFF_KANA_WIDTH    0xdeffffff        //11011110 11111111 11111111 11111111

//
// Get the mask-off value for all valid flags, so that we can use this mask to test the invalid flags in IndexOfString()/LastIndexOfString().
//
#define INDEXOF_MASKOFF_VALIDFLAGS 	~(COMPARE_OPTIONS_IGNORECASE | COMPARE_OPTIONS_IGNORESYMBOLS | COMPARE_OPTIONS_IGNORENONSPACE | COMPARE_OPTIONS_IGNOREWIDTH | COMPARE_OPTIONS_IGNOREKANATYPE)

//
// Return value for IndexOfString()/LastIndexOfString()
// Values greater or equal to 0 mean the specified string is found.
//
#define INDEXOF_NOT_FOUND			-1
#define INDEXOF_INVALID_FLAGS		-2


//
//  Masks to isolate the various bits in the case weight.
//
//  NOTE: Bit 2 must always equal 1 to avoid getting a byte value
//        of either 0 or 1.
//
#define CASE_XW_MASK         0xc4

#define ISOLATE_SMALL        ( (BYTE)((~CASE_SMALL_MASK) | CASE_XW_MASK) )
#define ISOLATE_KANA         ( (BYTE)((~CASE_KANA_MASK)  | CASE_XW_MASK) )
#define ISOLATE_WIDTH        ( (BYTE)((~CASE_WIDTH_MASK) | CASE_XW_MASK) )

//
//  UW Mask for Cho-On:
//    Leaves bit 7 on in AW, so it becomes Repeat if it follows Kana N.
//
#define CHO_ON_UW_MASK       0xff87

//
//  Values for fareast special case alphanumeric weights.
//
#define AW_REPEAT            0
#define AW_CHO_ON            1
#define MAX_SPECIAL_AW       AW_CHO_ON

//
//  Values for weight 5 - Far East Extra Weights.
//
#define WT_FIVE_KANA         3
#define WT_FIVE_REPEAT       4
#define WT_FIVE_CHO_ON       5



//
//  Values for CJK Unified Ideographs Extension A range.
//    0x3400 thru 0x4dbf
//
#define SM_EXT_A                  254       // SM for Extension A
#define AW_EXT_A                  255       // AW for Extension A

//
//  Values for UW extra weights (e.g. Jamo (old Hangul)).
//
#define SM_UW_XW                  255       // SM for extra UW weights


//
//  Script Member Values.
//
#define UNSORTABLE           0
#define NONSPACE_MARK        1
#define EXPANSION            2
#define FAREAST_SPECIAL      3

  //  Values 4 thru 5 are available for other special cases
#define JAMO_SPECIAL         4
#define EXTENSION_A          5

#define PUNCTUATION          6

#define SYMBOL_1             7
#define SYMBOL_2             8
#define SYMBOL_3             9
#define SYMBOL_4             10
#define SYMBOL_5             11

#define NUMERIC_1            12
#define NUMERIC_2            13

#define LATIN                14
#define GREEK                15
#define CYRILLIC             16
#define ARMENIAN             17
#define HEBREW               18
#define ARABIC               19
#define DEVANAGARI           20
#define BENGALI              21
#define GURMUKKHI            22
#define GUJARATI             23
#define ORIYA                24
#define TAMIL                25
#define TELUGU               26
#define KANNADA              27
#define MALAYLAM             28
#define SINHALESE            29
#define THAI                 30
#define LAO                  31
#define TIBETAN              32
#define GEORGIAN             33
#define KANA                 34
#define BOPOMOFO             35
#define HANGUL               36
#define IDEOGRAPH            128

#define MAX_SPECIAL_CASE     SYMBOL_5
#define FIRST_SCRIPT         LATIN


//
//  String Constants.
//
#define MAX_PATH_LEN              512  // max length of path name
#define MAX_STRING_LEN            128  // max string length for static buffer
#define MAX_SMALL_BUF_LEN         64   // max length of small buffer

#define MAX_COMPOSITE             5    // max number of composite characters
#define MAX_EXPANSION             3    // max number of expansion characters
#define MAX_TBL_EXPANSION         2    // max expansion chars per table entry
#define MAX_WEIGHTS               9    // max number of words in all weights

//
//  Invalid weight value.
//
#define MAP_INVALID_UW       0xffff

//
//  Number of bytes in each weight.
//
//
//  Note: Total number of bytes is limited by MAX_WEIGHTS definition.
//        The padding is needed if SW is not on a WORD boundary.
//
#define NUM_BYTES_UW         8
#define NUM_BYTES_DW         1
#define NUM_BYTES_CW         1
#define NUM_BYTES_XW         4
#define NUM_BYTES_PADDING    0
#define NUM_BYTES_SW         4

//
//  Flags to drop the 3rd weight (CW).
//
#define COMPARE_OPTIONS_DROP_CW         (COMPARE_OPTIONS_IGNORECASE | COMPARE_OPTIONS_IGNOREWIDTH)

// length of sortkey static buffer
#define MAX_SKEYBUFLEN       ( MAX_STRING_LEN * MAX_EXPANSION * MAX_WEIGHTS )


//
//  Constant Declarations.
//

//
//  State Table.
//
#define STATE_DW                  1    // normal diacritic weight state
#define STATE_REVERSE_DW          2    // reverse diacritic weight state
#define STATE_CW                  4    // case weight state
#define STATE_JAMO_WEIGHT         8    // Jamo weight state


//
//  Invalid weight value.
//
#define CMP_INVALID_WEIGHT        0xffffffff
#define CMP_INVALID_FAREAST       0xffff0000
#define CMP_INVALID_UW            0xffff

//
//  Invalid Flag Checks.
//

#define CS_INVALID_FLAG   (~(COMPARE_OPTIONS_IGNORECASE    | COMPARE_OPTIONS_IGNORENONSPACE |     \
                             COMPARE_OPTIONS_IGNORESYMBOLS | COMPARE_OPTIONS_IGNOREKANATYPE |     \
                             COMPARE_OPTIONS_IGNOREWIDTH   | COMPARE_OPTIONS_STRINGSORT))

////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
// Some Significant Values for Korean Jamo
//
#define NLS_CHAR_FIRST_JAMO     L'\x1100'       // Beginning of the jamo range
#define NLS_CHAR_LAST_JAMO      L'\x11f9'         // End of the jamo range
#define NLS_CHAR_FIRST_VOWEL_JAMO       L'\x1160'   // First Vowel Jamo
#define NLS_CHAR_FIRST_TRAILING_JAMO    L'\x11a8'   // First Trailing Jamo

#define NLS_JAMO_VOWEL_COUNT 21      // Number of modern vowel jamo
#define NLS_JAMO_TRAILING_COUNT 28   // Number of modern trailing consonant jamo
#define NLS_HANGUL_FIRST_SYLLABLE       L'\xac00'   // Beginning of the modern syllable range

//
//  Jamo classes for leading Jamo/Vowel Jamo/Trailing Jamo.
// 
#define NLS_CLASS_LEADING_JAMO 1
#define NLS_CLASS_VOWEL_JAMO 2
#define NLS_CLASS_TRAILING_JAMO 3


////////////////////////////////////////////////////////////////////////////
//
//  Some Significant Values for Korean Jamo.
//
////////////////////////////////////////////////////////////////////////////

//
// Expanded Jamo Sequence Sorting Info.
//  The JAMO_SORT_INFO.ExtraWeight is expanded to
//     Leading Weight/Vowel Weight/Trailing Weight
//  according to the current Jamo class.
//
typedef struct {
    BYTE m_bOld;               // sequence occurs only in old Hangul flag
    BOOL m_bFiller;            // Indicate if U+1160 (Hangul Jungseong Filler is used.
    CHAR m_chLeadingIndex;     // indices used to locate the prior
    CHAR m_chVowelIndex;       //     modern Hangul syllable
    CHAR m_chTrailingIndex;    //
    BYTE m_LeadingWeight;      // extra weights that distinguish this from
    BYTE m_VowelWeight;        //      other old Hangul syllables
    BYTE m_TrailingWeight;     //
} JAMO_SORT_INFOEX, *PJAMO_SORT_INFOEX;

////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////

#define IS_JAMO(wch) \
    ((wch) >= NLS_CHAR_FIRST_JAMO && (wch) <= NLS_CHAR_LAST_JAMO)

#define IsJamo(wch) \
    ((wch) >= NLS_CHAR_FIRST_JAMO && (wch) <= NLS_CHAR_LAST_JAMO)

#define IsLeadingJamo(wch) \
     ((wch) < NLS_CHAR_FIRST_VOWEL_JAMO)

#define IsVowelJamo(wch) \
     ((wch) >= NLS_CHAR_FIRST_VOWEL_JAMO && (wch) < NLS_CHAR_FIRST_TRAILING_JAMO)

#define IsTrailingJamo(wch) \
    ((wch) >= NLS_CHAR_FIRST_TRAILING_JAMO)    

class NativeCompareInfo {
    public:    
        NativeCompareInfo(int nLcid, SortingTable* pSortingFile);
        ~NativeCompareInfo();

        int CompareString(
            DWORD dwCmpFlags,  // comparison-style options
            LPCWSTR lpString1, // pointer to first string
            int cchCount1,     // size, in bytes or characters, of first string
            LPCWSTR lpString2, // pointer to second string
            int cchCount2);
            
        int LongCompareStringW(
            DWORD dwCmpFlags,
            LPCWSTR lpString1,
            int cchCount1,
            LPCWSTR lpString2,
            int cchCount2);
            
        int MapSortKey(
            DWORD dwFlags,
            LPCWSTR pSrc,
            int cchSrc,
            LPBYTE pDest,
            int cbDest);
            
        int IndexOfString(LPCWSTR pString1, LPCWSTR pString2, int nStartIndex, int nEndIndex, int nLength2, DWORD dwFlags, BOOL bMatchFirstCharOnly);
        int LastIndexOfString(LPCWSTR pString1, LPCWSTR pString2, int nStartIndex, int nEndIndex, int nLength2, DWORD dwFlags, int* pnMatchEndIndex);
        BOOL IsSuffix(LPCWSTR pSource, int nSourceLen, LPCWSTR pSuffix, int nSuffixLen, DWORD dwFlags);
        BOOL IsPrefix(LPCWSTR pSource, int nSourceLen, LPCWSTR pPrefix, int nPrefixLen, DWORD dwFlags);

        SIZE_T MapOldHangulSortKey(
            LPCWSTR pSrc,       // source string
            int cchSrc,         // the length of the string
            WORD* pUW,  // generated Unicode weight
            LPBYTE pXW     // generated extra weight (3 bytes)
            );

        BOOL InitSortingData();
        
    private:
        int FindJamoDifference(
            LPCWSTR* ppString1, int* ctr1, int cchCount1, DWORD* pWeight1,
            LPCWSTR* ppString2, int* ctr2, int cchCount2, DWORD* pWeight2,
            LPCWSTR* pLastJamo,
            WORD* uw1, 
            WORD* uw2, 
            DWORD* pState,
            int* WhichJamo);

        void UpdateJamoState(
            int JamoClass,
            PJAMO_SORT_INFO pSort,
            PJAMO_SORT_INFOEX pSortResult);

        BOOL GetNextJamoState(
            WCHAR wch,
            int* pCurrentJamoClass,
            PJAMO_TABLE lpJamoTable,
            PJAMO_SORT_INFOEX lpSortInfoResult);

        int GetJamoComposition(
            LPCWSTR* ppString,      // The pointer to the current character
            int* pCount,            // The current character count
            int cchSrc,             // The total character length
            int currentJamoClass,   // The current Jamo class.
            JAMO_SORT_INFOEX* JamoSortInfo    // The result Jamo sorting information.
        );

        ////////////////////////////////////////////////////////////////////////////
        //
        //  SORTKEY WEIGHT MACROS
        //
        //  Parse out the different sortkey weights from a DWORD value.
        //
        //  05-31-91    JulieB    Created.
        ////////////////////////////////////////////////////////////////////////////

        inline BYTE GET_SCRIPT_MEMBER(DWORD* pwt) {
            return ( (BYTE)(((PSORTKEY)pwt)->UW.SM_AW.Script) );
        }

        inline BYTE GET_ALPHA_NUMERIC(DWORD* pwt) {
            return ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Alpha) );
        }

        inline BYTE GET_SCRIPT_MEMBER_FROM_UW(DWORD dwUW) {
            return ((BYTE)(dwUW >> 4));
        }

        inline WORD GET_UNICODE(DWORD* pwt);

        inline WORD MAKE_UNICODE_WT(int sm, BYTE aw);

#define UNICODE_WT(pwt)           ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

#define GET_DIACRITIC(pwt)        ( (BYTE)(((PSORTKEY)(pwt))->Diacritic) )

#define GET_CASE(pwt)             ( (BYTE)((((PSORTKEY)(pwt))->Case) & CASE_MASK) )

#define CASE_WT(pwt)              ( (BYTE)(((PSORTKEY)(pwt))->Case) )

#define GET_COMPRESSION(pwt)      ( (BYTE)((((PSORTKEY)(pwt))->Case) & COMPRESS_3_MASK) )

#define GET_EXPAND_INDEX(pwt)     ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Alpha) )

#define GET_SPECIAL_WEIGHT(pwt)   ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

//  position returned is backwards - byte reversal
#define GET_POSITION_SW(pos)      ( (WORD)(((pos) << 2) | SW_POSITION_MASK) )


#define GET_WT_FOUR(pwt)          ( (BYTE)(((PEXTRA_WT)(pwt))->Four) )
#define GET_WT_FIVE(pwt)          ( (BYTE)(((PEXTRA_WT)(pwt))->Five) )
#define GET_WT_SIX(pwt)           ( (BYTE)(((PEXTRA_WT)(pwt))->Six) )
#define GET_WT_SEVEN(pwt)         ( (BYTE)(((PEXTRA_WT)(pwt))->Seven) )

#define GET_COMPRESSION(pwt)      ( (BYTE)((((PSORTKEY)(pwt))->Case) & COMPRESS_3_MASK) )


        inline WCHAR GET_EXPANSION_1(LPDWORD pwt);

        inline WCHAR GET_EXPANSION_2(LPDWORD pwt);                                           

        inline DWORD MAKE_SORTKEY_DWORD(SORTKEY wt)
        {
            return ( (DWORD)(*((LPDWORD)(&wt))) );
        }            

        inline DWORD MAKE_EXTRA_WT_DWORD(SORTKEY wt)
        {
            return ( (DWORD)(*((LPDWORD)(&wt))) );
        }            

        inline DWORD  GET_DWORD_WEIGHT(PSORTKEY pSortKey, WCHAR wch)
        {
            return ( MAKE_SORTKEY_DWORD(pSortKey[wch]) );
        }

//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NOT_END_STRING
//
//  Checks to see if the search has reached the end of the string.
//  It returns TRUE if the counter is not at zero (counting backwards) and
//  the null termination has not been reached (if -1 was passed in the count
//  parameter.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NOT_END_STRING(ct, ptr, cchIn)                                     \
    ((ct != 0) && (!((*(ptr) == 0) && (cchIn == -2))))


////////////////////////////////////////////////////////////////////////////
//
//  AT_STRING_END
//
//  Checks to see if the pointer is at the end of the string.
//  It returns TRUE if the counter is zero or if the null termination
//  has been reached (if -2 was passed in the count parameter).
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define AT_STRING_END(ct, ptr, cchIn)                                      \
    ((ct == 0) || ((*(ptr) == 0) && (cchIn == -2)))

////////////////////////////////////////////////////////////////////////////
//
//  REMOVE_STATE
//
//  Removes the current state from the state table.  This should only be
//  called when the current state should not be entered for the remainder
//  of the comparison.  It decrements the counter going through the state
//  table and decrements the number of states in the table.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define REMOVE_STATE(value)            (State &= ~value)

////////////////////////////////////////////////////////////////////////////
//
//  POINTER_FIXUP
//
//  Fixup the string pointers if expansion characters were found.
//  Then, advance the string pointers and decrement the string counters.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define POINTER_FIXUP()                                                    \
{                                                                          \
    /*                                                                     \
     *  Fixup the pointers (if necessary).                                 \
     */                                                                    \
    if (pSave1 && (--cExpChar1 == 0))                                      \
    {                                                                      \
        /*                                                                 \
         *  Done using expansion temporary buffer.                         \
         */                                                                \
        pString1 = pSave1;                                                 \
        pSave1 = NULL;                                                     \
    }                                                                      \
                                                                           \
    if (pSave2 && (--cExpChar2 == 0))                                      \
    {                                                                      \
        /*                                                                 \
         *  Done using expansion temporary buffer.                         \
         */                                                                \
        pString2 = pSave2;                                                 \
        pSave2 = NULL;                                                     \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Advance the string pointers.                                       \
     */                                                                    \
    pString1++;                                                            \
    pString2++;                                                            \
}

    ////////////////////////////////////////////////////////////////////////////
    //
    //  GET_FAREAST_WEIGHT
    //
    //  Returns the weight for the far east special case in "wt".  This currently
    //  includes the Cho-on, the Repeat, and the Kana characters.
    //
    //  08-19-93    JulieB    Created.
    ////////////////////////////////////////////////////////////////////////////

/*
    inline void GET_FAREAST_WEIGHT( DWORD& wt,
                             WORD& uw,
                             DWORD mask,
                             LPCWSTR pBegin,
                             LPCWSTR pCur,
                             DWORD& ExtraWt);   
*/
    inline void GET_FAREAST_WEIGHT( DWORD& wt,
                             WORD& uw,
                             DWORD mask,
                             LPCWSTR pBegin,
                             LPCWSTR pCur,
                             DWORD& ExtraWt);   

    ////////////////////////////////////////////////////////////////////////////
    //
    //  SCAN_LONGER_STRING
    //
    //  Scans the longer string for diacritic, case, and special weights.
    //
    //  11-04-92    JulieB    Created.
    ////////////////////////////////////////////////////////////////////////////

    inline int SCAN_LONGER_STRING( 
        int ct,
        LPCWSTR ptr,
        int cchIn,
        BOOL ret,
        DWORD& Weight1,
        BOOL& fIgnoreDiacritic,
        int& WhichDiacritic,
        BOOL& fIgnoreSymbol ,
        int& WhichCase ,
        DWORD& WhichExtra ,
        int& WhichPunct1,
        int& WhichPunct2);

    ////////////////////////////////////////////////////////////////////////////
    //
    //  QUICK_SCAN_LONGER_STRING
    //
    //  Scans the longer string for diacritic, case, and special weights.
    //  Assumes that both strings are null-terminated.
    //
    //  11-04-92    JulieB    Created.
    ////////////////////////////////////////////////////////////////////////////

    inline int QUICK_SCAN_LONGER_STRING( 
        LPCWSTR ptr, 
        int cchCount1,
        int ret,
        int& WhichDiacritic,
        int& WhichCase, 
        int& WhichPunct1,   
        int& WhichPunct2,
        DWORD& WhichExtra);

    void NativeCompareInfo::GetCompressionWeight(
        DWORD Mask,                   // mask for weights
        PSORTKEY sortkey1, LPCWSTR& pString1, LPCWSTR pString1End,
        PSORTKEY sortkey2, LPCWSTR& pString2, LPCWSTR pString2End);

	public:
    	int m_nLcid;

		// 
    	HANDLE m_hSortKey;
    	PSORTKEY m_pSortKey;

        BOOL            m_IfReverseDW;        // if DW should go from right to left
        BOOL            m_IfCompression;      // if compression code points exist
        BOOL            m_IfDblCompression;   // if double compression exists        
        PCOMPRESS_HDR   m_pCompHdr;           // ptr to compression header
        PCOMPRESS_2     m_pCompress2;         // ptr to 2 compression table
        PCOMPRESS_3     m_pCompress3;         // ptr to 3 compression table
        
	    // Point to next NativeCompareInfo which has the same LANGID. 
	    // This is used in the cases for locales which have the same LANGID, but have different
	    // SORTID. We create a linked list to handle this situation.
	    NativeCompareInfo*       m_pNext;                  
	
    private:
        static BYTE             pXWDrop[];        
        static BYTE             pXWSeparator[];        

		SortingTable*	  m_pSortingFile;    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\sortingtable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include <winnls.h>
#include "NLSTable.h"
#include "GlobalizationAssembly.h"
#include "SortingTableFile.h"
#include "SortingTable.h"
#include "excep.h"

// The "old" SortingTable has been renamed to NativeCompareInfo.  This is a better name
// because this class is a native implementation for the managed CompareInfo.
// If you see methods missing from this file, they are moved to SortingTableFile.cpp,
// and are methods of the "new" SortingTable.

/*
    NOTE YSLin:
    There are a lot of terms in SortingTable.cpp.  This section gives some explanations.  The contents here are adapted from
    JulieB's NLS Design documentation.  Please contact JulieB/YSLin for the doc if you need more information.  Thanks.

    The default sortkey file will be named sortkey.nls.

    Each code point has a 32-bit weight (1 dword).
                - Script Member                 (SM)       is    8 bits    (0 - 255)
                - Alphanumeric Weight   (AW)      is    8 bits    (2 - 255)
                - Diacritic Weight                (DW)      is    8 bits    (2 - 255)
                - Case Weight                   (CW)      is    6 bits    (2 - 63)
                - Compression                         (CMP)    is    2 bits    (0 - 3)
                - Unicode Weight                 (UW)       is   16 bits
                       and consists of:
                            - Script Member (SM)
                            - Alphanumeric Weight (AW)
 */

//
//  XW Values for FE Special Weights.
//
BYTE NativeCompareInfo::pXWDrop[] =                  // values to drop from XW
{
    0xc6,                         // weight 4
    0x03,                         // weight 5
    0xe4,                         // weight 6
    0xc5                          // weight 7
};

BYTE NativeCompareInfo::pXWSeparator[] =             // separator values for XW
{
    0xff,                         // weight 4
    0x02,                         // weight 5
    0xff,                         // weight 6
    0xff                          // weight 7
};


//
// NOTE NOTE NOTE NOTE NOTE
//
// This constructor needs to be in a critical section because we could potentially hit some problems
// with multiple threads thrying to create the default tables at the same time.  We're doing
// this synchronization in managed code by making CompareInfo.InitializeSortTable the only
// accessor that will go down this path.  Do not call this function from anywhere else.
// The only valid code path is:
// System.Globalization.CompareInfo.InitializeSortTable
// COMNlsInfo::InitializeSortTable
// NativeCompareInfo::InitializeSortTable
// NativeCompareInfo::NativeCompareInfo
//
NativeCompareInfo::NativeCompareInfo(int nLcid, SortingTable* pSortingFile):
    m_IfReverseDW(FALSE), m_IfCompression(FALSE), m_IfDblCompression(FALSE),
    m_pNext(NULL), m_hSortKey(NULL)
{
    m_nLcid = nLcid;
    m_pSortingFile = pSortingFile;
    m_pSortKey = NULL;
}

NativeCompareInfo::~NativeCompareInfo()
{
    //In NativeCompareInfo::GetDefaultSortKeyTable and GetExceptionSortKeyTable,
    //we incremented the pointer by to skip a semaphore value.
    //We need to decrement the pointer here in order to deallocate cleanly.
    #ifdef _USE_MSCORNLP
    if (!m_pSortKey) {
        UnmapViewOfFile((LPCVOID)((LPWORD)m_pSortKey));
    }

    if (m_hSortKey) {
        CloseHandle(m_hSortKey);
    }
    #endif
}


/*============================InitSortingData============================
**Action:
**  Get the following information for sorttbls.nlp:
**
**  1. Check for if this locale is reverse diacritic.
**  2. Check for if this locale has compression.  If yes,
**     get the compression table.
**  3. Check for if this locale has double compression.
**
**  See [Performance improvements] in SortingTableFile.h for perf notes.
**
**Returns: Void.  The side effect is data members: m_IfReverseDW/m_IfCompression/m_pCompress2
**                m_pCompress3/m_IfDblCompression will be set.
**Arguments:  None
**Exceptions: None.
**  05-31-91    JulieB    Created. (On her birthday)
==============================================================================*/

BOOL NativeCompareInfo::InitSortingData()
{
    DWORD ctr;                    // loop counter
    PREVERSE_DW pRevDW;           // ptr to reverse diacritic table
    PDBL_COMPRESS pDblComp;       // ptr to double compression table
    PCOMPRESS_HDR pCompHdr;       // ptr to compression header

    // Get the sortkey for this culture.
    m_pSortKey = m_pSortingFile->GetSortKey(m_nLcid, &m_hSortKey);
    if (m_pSortKey == NULL) {
        return (FALSE);
    }

    // If the culture is US English, there is no need to
    // check for the  reverse diacritic, compression, etc.
    if (m_nLcid == LANG_ENGLISH_US) {
        return (TRUE);
    }

    // Get reverse diacritic/compression/double compression information.


    //
    //  Check for Reverse Diacritic Locale.
    //
    pRevDW = m_pSortingFile->m_pReverseDW;
    for (ctr = m_pSortingFile->m_NumReverseDW; ctr > 0; ctr--, pRevDW++)
    {
        if (*pRevDW == (DWORD)m_nLcid)
        {
            m_IfReverseDW = TRUE;
            break;
        }
    }

    //
    //  Check for Compression.
    //
    pCompHdr = m_pSortingFile->m_pCompressHdr;
    for (ctr = m_pSortingFile->m_NumCompression; ctr > 0; ctr--, pCompHdr++)
    {
        if (pCompHdr->Locale == (DWORD)m_nLcid)
        {
            m_IfCompression = TRUE;
            m_pCompHdr = pCompHdr;
            if (pCompHdr->Num2 > 0)
            {
                m_pCompress2 = (PCOMPRESS_2)
                                       (((LPWORD)(m_pSortingFile->m_pCompression)) +
                                        (pCompHdr->Offset));
            }
            if (pCompHdr->Num3 > 0)
            {
                m_pCompress3 = (PCOMPRESS_3)
                                       (((LPWORD)(m_pSortingFile->m_pCompression)) +
                                        (pCompHdr->Offset) +
                                        (pCompHdr->Num2 *
                                          (sizeof(COMPRESS_2) / sizeof(WORD))));
            }
            break;
        }
    }

    //
    //  Check for Double Compression.
    //
    if (m_IfCompression)
    {
        pDblComp = m_pSortingFile->m_pDblCompression;
        for (ctr = m_pSortingFile->m_NumDblCompression; ctr > 0; ctr--, pDblComp++)
        {
            if (*pDblComp == (DWORD)m_nLcid)
            {
                m_IfDblCompression = TRUE;
                break;
            }
        }
    }
    return (TRUE);
}

WORD NativeCompareInfo::GET_UNICODE(DWORD* pwt)
{
    return ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) );
}

WORD NativeCompareInfo::MAKE_UNICODE_WT(int sm, BYTE aw)
{
    return (((WORD)((((WORD)(sm)) << 8) | (WORD)(aw))) );
}

int NativeCompareInfo::FindJamoDifference(
    LPCWSTR* ppString1, int* ctr1, int cchCount1, DWORD* pWeight1,
    LPCWSTR* ppString2, int* ctr2, int cchCount2, DWORD* pWeight2,
    LPCWSTR* pLastJamo,
    WORD* uw1, 
    WORD* uw2, 
    DWORD* pState,
    int* WhichJamo)
{
    int bRestart = 0;                 // The value to indicate if the string compare should restart again.
    
    DWORD oldHangulsFound1 = 0;            // The character number of valid old Hangul Jamo compositions is found.
    DWORD oldHangulsFound2 = 0;            // The character number of valid old Hangul Jamo compositions is found.
    WORD UW;
    BYTE JamoWeight1[3];            // Extra weight for the first old Hangul composition.
    BYTE JamoWeight2[3];            // Extra weight for the second old Hangul composition.

    //
    // Roll back to the first Jamo.  We know that these Jamos in both strings should be equal, so that
    // we can decrement both strings at once.
    //
    while ((*ppString1 > *pLastJamo) && IsJamo(*(*ppString1 - 1)))
    {
        (*ppString1)--; (*ppString2)--; (*ctr1)++; (*ctr2)++;
    }

    //
    // Now we are at the beginning of two groups of Jamo characters.
    // Compare Jamo unit(either a single Jamo or a valid old Hangul Jamo composition) 
    // until we run out Jamo units in either strings.
    // We also exit when we reach the ends of either strings.
    //
    for (;;)
    {
        if (IsJamo(**ppString1))
        {
            if (IsLeadingJamo(**ppString1)) 
            {                
                if ((oldHangulsFound1 = (DWORD) MapOldHangulSortKey(*ppString1, *ctr1, &UW, JamoWeight1)) > 0)
                {
                    *uw1 = UW;
                    *pWeight1 = ((DWORD)UW | 0x02020000);  // Mark *pWeight1 so that it is not CMP_INVALID_WEIGHT. 0202 is the DW/CW.
                    *ppString1 += (oldHangulsFound1 - 1);     // We always increment ppString1/ctr1 at the end of the loop, hense we subtract 1.
                    *ctr1 -= (oldHangulsFound1 - 1);
                }
            }
            if (oldHangulsFound1 == 0)
            {
                //
                // No valid old Hangul composition are found.  Get the UW for the Jamo instead.
                //
                *pWeight1 = GET_DWORD_WEIGHT(m_pSortKey, **ppString1);
                //
                // The SMs in PSORTKEY for Jamos are not really SMs. They are all 4 (for JAMO_SPECIAL)
                // Here we get the real Jamo Unicode weight. The actual SM is stored in DW.
                //
                *uw1 = MAKE_UNICODE_WT(GET_DIACRITIC(pWeight1), GET_ALPHA_NUMERIC(pWeight1));
                ((PSORTKEY)pWeight1)->Diacritic = MIN_DW;
            } 
        } 
        
        if (IsJamo(**ppString2))
        {
            if (IsLeadingJamo(**ppString2)) 
            {
                if ((oldHangulsFound2 = (DWORD) MapOldHangulSortKey(*ppString2, *ctr2, &UW, JamoWeight2)) > 0)
                {
                    *uw2 = UW;
                    *pWeight2 = ((DWORD)UW | 0x02020000);
                    *ppString2 += (oldHangulsFound2 - 1); 
                    *ctr2 -= (oldHangulsFound2 - 1);
                }
            }
            if (oldHangulsFound2 == 0)
            {
                *pWeight2 = GET_DWORD_WEIGHT(m_pSortKey, **ppString2);
                *uw2 = MAKE_UNICODE_WT(GET_DIACRITIC(pWeight2), GET_ALPHA_NUMERIC(pWeight2));
                ((PSORTKEY)pWeight2)->Diacritic = MIN_DW;
            }
        }

        if (*pWeight1 == CMP_INVALID_WEIGHT)
        {
            //
            // The current character is not a Jamo.  Make the Weight to be CMP_INVALID_WEIGHT,
            // so that the string comparision can restart within the loop of CompareString().
            //
            *pWeight1 = CMP_INVALID_WEIGHT;
            bRestart = 1;
            goto Exit;            
        }
        if (*pWeight2 == CMP_INVALID_WEIGHT)
        {
            *pWeight2 = CMP_INVALID_WEIGHT;
            bRestart = 1;
            goto Exit;            
        }
        if (*uw1 != *uw2)
        {
            //
            // Find differences in Unicode weight.  We can stop the processing now.
            //
            goto Exit;
        }
        
        //
        // When we get here, we know that we have the same Unicode Weight.  Check
        // if we need to record the WhichJamo
        //
        if ((*pState & STATE_JAMO_WEIGHT) && (oldHangulsFound1 > 0 || oldHangulsFound2 > 0))
        {
            if (oldHangulsFound1 > 0 && oldHangulsFound2 > 0)
            {
                *WhichJamo = (int)memcmp(JamoWeight1, JamoWeight2, sizeof(JamoWeight1)) + 2;
            } else if (oldHangulsFound1 > 0)
            {
                *WhichJamo = CSTR_GREATER_THAN;
            } else
            {
                *WhichJamo = CSTR_LESS_THAN;
            }
            *pState &= ~STATE_JAMO_WEIGHT;            
            oldHangulsFound1 = oldHangulsFound2 = 0;
        }
        (*ppString1)++; (*ctr1)--;
        (*ppString2)++; (*ctr2)--;
        if (AT_STRING_END(*ctr1, *ppString1, cchCount1) || AT_STRING_END(*ctr2, *ppString2, cchCount2))
        {
            break;
        }
        *pWeight1 = *pWeight2 = CMP_INVALID_WEIGHT;        
    }

    //
    // If we drop out of the while loop because we reach the end of strings.  Decrement the pointers
    // by one because loops in CompareString() will increase the pointers at the end of the loop.
    // 
    // If we drop out of the while loop because the goto's in it, we are already off by one.
    //
    if (AT_STRING_END(*ctr1, *ppString1, cchCount1))
    {
        (*ppString1)--; (*ctr1)++;
    }
    if (AT_STRING_END(*ctr2, *ppString2, cchCount2))
    {
        (*ppString2)--; (*ctr2)++;
    }
Exit:
    *pLastJamo = *ppString1;    
    return (bRestart);
}



/*=================================CompareString==========================
**Action: Compare two string in a linguistic way.
**Returns:
**Arguments:
**Exceptions:
============================================================================*/

int NativeCompareInfo::CompareString(
    DWORD dwCmpFlags,  // comparison-style options
    LPCWSTR lpString1, // pointer to first string
    int cchCount1,     // size, in bytes or characters, of first string
    LPCWSTR lpString2, // pointer to second string
    int cchCount2)
{
    // Make sure that we call InitSortingData() after ctor.
    _ASSERTE(m_pSortKey != NULL);
    register LPCWSTR pString1;     // ptr to go thru string 1
    register LPCWSTR pString2;     // ptr to go thru string 2
    BOOL fIgnorePunct;            // flag to ignore punctuation (not symbol)
    DWORD State;                  // state table
    DWORD Mask;                   // mask for weights
    DWORD Weight1;                // full weight of char - string 1
    DWORD Weight2;                // full weight of char - string 2
    int JamoFlag = FALSE;
    LPCWSTR pLastJamo = lpString1;        
    
    int WhichDiacritic = 0;           // DW => 1 = str1 smaller, 3 = str2 smaller
    int WhichCase = 0;                // CW => 1 = str1 smaller, 3 = str2 smaller
    int WhichJamo = 0;              // SW for Jamo    
    int WhichPunct1 = 0;              // SW => 1 = str1 smaller, 3 = str2 smaller
    int WhichPunct2 = 0;              // SW => 1 = str1 smaller, 3 = str2 smaller
    DWORD WhichExtra = 0;             // XW => wts 4, 5, 6, 7 (for far east)
    
    LPCWSTR pSave1;                // ptr to saved pString1
    LPCWSTR pSave2;                // ptr to saved pString2
    int cExpChar1, cExpChar2;     // ct of expansions in tmp

    DWORD ExtraWt1 = 0;
    DWORD ExtraWt2 = 0;     // extra weight values (for far east)
    
    //cchCount1 is also used a counter to track the characters that we are tracing right now.
    //cchCount2 is also used a counter to track the characters that we are tracing right now.  

    //
    //  Call longer compare string if any of the following is true:
    //     - locale is invalid
    //     - compression locale
    //     - either count is not -1
    //     - dwCmpFlags is not 0 or ignore case   (see NOTE below)
    //     - locale is Korean - script member weight adjustment needed
    //
    //  NOTE:  If the value of COMPARE_OPTIONS_IGNORECASE ever changes, this
    //         code should check for:
    //            ( (dwCmpFlags != 0)  &&  (dwCmpFlags != COMPARE_OPTIONS_IGNORECASE) )
    //         Since COMPARE_OPTIONS_IGNORECASE is equal to 1, we can optimize this
    //         by checking for > 1.
    //

    // From now on, in this function, we don't rely on scanning null string as the end of the 
    // string.  Instead, we use cchCount1/cchCount2 to track the end of the string.    
    // Therefore, cchCount1/cchCount2 can not be -1 anymore.
    // we make sure in here about the assumption.   
    _ASSERTE(cchCount1 >= 0 && cchCount2 >= 0);
    
    // I change the order of checking so the common case
    // is checked first.
    if ( (dwCmpFlags > COMPARE_OPTIONS_IGNORECASE) ||
         (m_IfCompression) || (m_pSortKey == NULL)) {
        return (LongCompareStringW( dwCmpFlags,
                                    lpString1,
                                    cchCount1,
                                    lpString2,
                                    cchCount2));
    }

    //
    //  Initialize string pointers.
    //
    pString1 = (LPWSTR)lpString1;
    pString2 = (LPWSTR)lpString2;

    //
    //  Invalid Parameter Check:
    //    - NULL string pointers
    //
    // We have already validate pString1 and pString2 in COMNlsInfo::CompareString().
    //
    _ASSERTE(pString1 != NULL && pString2 != NULL);

    //
    //  Do a wchar by wchar compare.
    //
    
    while (TRUE)
    {
        //
        //  See if characters are equal.
        //  If characters are equal, increment pointers and continue
        //  string compare.
        //
        //  NOTE: Loop isp unrolled 8 times for performance.
        //
        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
        cchCount1--; cchCount2--;

        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
        cchCount1--; cchCount2--;

        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
        cchCount1--; cchCount2--;

        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
        cchCount1--; cchCount2--;

        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
        cchCount1--; cchCount2--;

        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
        cchCount1--; cchCount2--;

        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
        cchCount1--; cchCount2--;

        if ((cchCount1 == 0 || cchCount2 == 0) || (*pString1 != *pString2))
        {
            break;
        }
        pString1++; pString2++;
		cchCount1--; cchCount2--;
    }

    //
    //  If strings are both at null terminators, return equal.
    //

    if ((cchCount1 == 0) && (cchCount2 == 0))
    {
        return (CSTR_EQUAL);
    }

    if (cchCount1 == 0 || cchCount2 == 0) {
        goto ScanLongerString;
    }

    //
    //  Initialize flags, pointers, and counters.
    //
    fIgnorePunct = FALSE;
    pSave1 = NULL;
    pSave2 = NULL;
    ExtraWt1 = (DWORD)0;

    //
    //  Switch on the different flag options.  This will speed up
    //  the comparisons of two strings that are different.
    //
    //  The only two possibilities in this optimized section are
    //  no flags and the ignore case flag.
    //
    if (dwCmpFlags == 0)
    {
        Mask = CMP_MASKOFF_NONE;
    }
    else
    {
        Mask = CMP_MASKOFF_CW;
    }

    State = (m_IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;
    State |= STATE_CW | STATE_JAMO_WEIGHT;

    //
    //  Compare each character's sortkey weight in the two strings.
    //
    while ((cchCount1 != 0) && (cchCount2 != 0))
    {
        Weight1 = GET_DWORD_WEIGHT(m_pSortKey, *pString1);
        Weight2 = GET_DWORD_WEIGHT(m_pSortKey, *pString2);
        Weight1 &= Mask;
        Weight2 &= Mask;

        if (Weight1 != Weight2)
        {
            BYTE sm1 = GET_SCRIPT_MEMBER(&Weight1);     // script member 1
            BYTE sm2 = GET_SCRIPT_MEMBER(&Weight2);     // script member 2
            // GET_UNICODE_SM is the same us GET_UNICODE().  So I removed GET_UNICODE_SM.
            WORD uw1 = GET_UNICODE(&Weight1);   // unicode weight 1
            WORD uw2 = GET_UNICODE(&Weight2);   // unicode weight 2
            BYTE dw1;                                   // diacritic weight 1
            BYTE dw2;                                   // diacritic weight 2
            BOOL fContinue;                             // flag to continue loop
            DWORD Wt;                                   // temp weight holder
            WCHAR pTmpBuf1[MAX_TBL_EXPANSION];          // temp buffer for exp 1
            WCHAR pTmpBuf2[MAX_TBL_EXPANSION];          // temp buffer for exp 2


            //
            //  If Unicode Weights are different and no special cases,
            //  then we're done.  Otherwise, we need to do extra checking.
            //
            //  Must check ENTIRE string for any possibility of Unicode Weight
            //  differences.  As soon as a Unicode Weight difference is found,
            //  then we're done.  If no UW difference is found, then the
            //  first Diacritic Weight difference is used.  If no DW difference
            //  is found, then use the first Case Difference.  If no CW
            //  difference is found, then use the first Extra Weight
            //  difference.  If no XW difference is found, then use the first
            //  Special Weight difference.
            //
            if ((uw1 != uw2) ||
                (sm1 == FAREAST_SPECIAL) ||
                (sm1 == EXTENSION_A))
            {
                //
                //  Initialize the continue flag.
                //
                fContinue = FALSE;

                //
                //  Check for Unsortable characters and skip them.
                //  This needs to be outside the switch statement.  If EITHER
                //  character is unsortable, must skip it and start over.
                //
                if (sm1 == UNSORTABLE)
                {
                    pString1++; cchCount1--;
                    fContinue = TRUE;
                }
                if (sm2 == UNSORTABLE)
                {
                    pString2++; cchCount2--;
                    fContinue = TRUE;
                }
                if (fContinue)
                {
                    continue;
                }
                
                //
                //  Switch on the script member of string 1 and take care
                //  of any special cases.
                //
                switch (sm1)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if ((WhichDiacritic == 0) ||
                            (State & STATE_REVERSE_DW))
                        {
                            WhichDiacritic = CSTR_GREATER_THAN;

                            //
                            //  Remove state from state machine.
                            //
                            REMOVE_STATE(STATE_DW);
                        }

                        //
                        //  Adjust pointer and set flags.
                        //
                        pString1++; cchCount1--;
                        fContinue = TRUE;

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation.
                        //
                        if (fIgnorePunct)
                        {
                            pString1++; cchCount1--;
                            fContinue = TRUE;
                        }
                        else if (sm2 != PUNCTUATION)
                        {
                            //
                            //  The character in the second string is
                            //  NOT punctuation.
                            //
                            if (WhichPunct2)
                            {
                                //
                                //  Set WP 2 to show that string 2 is smaller,
                                //  since a punctuation char had already been
                                //  found at an earlier position in string 2.
                                //
                                //  Set the Ignore Punctuation flag so we just
                                //  skip over any other punctuation chars in
                                //  the string.
                                //
                                WhichPunct2 = CSTR_GREATER_THAN;
                                fIgnorePunct = TRUE;
                            }
                            else
                            {
                                //
                                //  Set WP 1 to show that string 2 is smaller,
                                //  and that string 1 has had a punctuation
                                //  char - since no punctuation chars have
                                //  been found in string 2.
                                //
                                WhichPunct1 = CSTR_GREATER_THAN;
                            }

                            //
                            //  Advance pointer 1, and set flag to true.
                            //
                            pString1++; cchCount1--;
                            fContinue = TRUE;
                        }

                        //
                        //  Do NOT want to advance the pointer in string 1 if
                        //  string 2 is also a punctuation char.  This will
                        //  be done later.
                        //

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave1 == NULL)
                        {
                            pSave1 = pString1;
                        }
                        pString1 = pTmpBuf1;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf1[0] = GET_EXPANSION_1(&Weight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(&Weight1);

                        //
                        //  Set cExpChar1 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar1 = MAX_TBL_EXPANSION;
                        cchCount1++;

                        fContinue = TRUE;
                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm2 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight1.
                            //
                            GET_FAREAST_WEIGHT( Weight1,
                                                uw1,
                                                Mask,
                                                lpString1,
                                                pString1,
                                                ExtraWt1);

                            if (sm2 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the second string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 2 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt1) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt1) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt1) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt1) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        int ctr1;     // dummy variables needed by FindJamoDifference
                        LPCWSTR pStr1 = pString1;
                        LPCWSTR pStr2 = pString2;
                        // Set the JamoFlag so we don't handle it again in SM2.
                        JamoFlag = TRUE;
                        fContinue = FindJamoDifference(
                            &pStr1, &cchCount1, 0, &Weight1, 
                            &pStr2, &cchCount2, 0, &Weight2, 
                            &pLastJamo, 
                            &uw1, &uw2, 
                            &State,
                            &WhichJamo);
                        if (WhichJamo)
                        {
                            return (WhichJamo);
                        }    
                                                    
                        pString1 = pStr1;
                        pString2 = pStr2;                        
                        break;
                    }                    
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  Compare the weights.
                        //
                        if (Weight1 == Weight2)
                        {
                            //
                            //  Adjust pointers and set flag.
                            //
                            pString1++;  pString2++;
                            cchCount1--; cchCount2--;
                            fContinue = TRUE;
                        }
                        else
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            if (sm2 == EXTENSION_A)
                            {
                                //
                                //  Set the UW values to be the AW and DW since
                                //  both strings contain an extension A char.
                                //
                                uw1 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight1),
                                                       GET_DIACRITIC(&Weight1));
                                uw2 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight2),
                                                       GET_DIACRITIC(&Weight2));
                            }
                            else
                            {
                                //
                                //  Only string1 contains an extension A char,
                                //  so set the UW value to be the first UW
                                //  value for extension A (default values):
                                //    SM_EXT_A, AW_EXT_A
                                //
                                uw1 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A);
                            }
                        }

                        break;
                    }
                    case ( UNSORTABLE ):                    
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  Switch on the script member of string 2 and take care
                //  of any special cases.
                //
                switch (sm2)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if ((WhichDiacritic == 0) ||
                            (State & STATE_REVERSE_DW))
                        {
                            WhichDiacritic = CSTR_LESS_THAN;

                            //
                            //  Remove state from state machine.
                            //
                            REMOVE_STATE(STATE_DW);
                        }

                        //
                        //  Adjust pointer and set flags.
                        //
                        pString2++; cchCount2--;
                        fContinue = TRUE;

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation.
                        //
                        if (fIgnorePunct)
                        {
                            //
                            //  Pointer 2 will be advanced after if-else
                            //  statement.
                            //
                            ;
                        }
                        else if (sm1 != PUNCTUATION)
                        {
                            //
                            //  The character in the first string is
                            //  NOT punctuation.
                            //
                            if (WhichPunct1)
                            {
                                //
                                //  Set WP 1 to show that string 1 is smaller,
                                //  since a punctuation char had already
                                //  been found at an earlier position in
                                //  string 1.
                                //
                                //  Set the Ignore Punctuation flag so we just
                                //  skip over any other punctuation in the
                                //  string.
                                //
                                WhichPunct1 = CSTR_LESS_THAN;
                                fIgnorePunct = TRUE;
                            }
                            else
                            {
                                //
                                //  Set WP 2 to show that string 1 is smaller,
                                //  and that string 2 has had a punctuation
                                //  char - since no punctuation chars have
                                //  been found in string 1.
                                //
                                WhichPunct2 = CSTR_LESS_THAN;
                            }

                            //
                            //  Pointer 2 will be advanced after if-else
                            //  statement.
                            //
                        }
                        else
                        {
                            //
                            //  Both code points are punctuation.
                            //
                            //  See if either of the strings has encountered
                            //  punctuation chars previous to this.
                            //
                            if (WhichPunct1)
                            {
                                //
                                //  String 1 has had a punctuation char, so
                                //  it should be the smaller string (since
                                //  both have punctuation chars).
                                //
                                WhichPunct1 = CSTR_LESS_THAN;
                            }
                            else if (WhichPunct2)
                            {
                                //
                                //  String 2 has had a punctuation char, so
                                //  it should be the smaller string (since
                                //  both have punctuation chars).
                                //
                                WhichPunct2 = CSTR_GREATER_THAN;
                            }
                            else
                            {
                                //
                                //  Position is the same, so compare the
                                //  special weights.  Set WhichPunct1 to
                                //  the smaller special weight.
                                //
                                WhichPunct1 = (((GET_ALPHA_NUMERIC(&Weight1) <
                                                 GET_ALPHA_NUMERIC(&Weight2)))
                                                 ? CSTR_LESS_THAN
                                                 : CSTR_GREATER_THAN);
                            }

                            //
                            //  Set the Ignore Punctuation flag so we just
                            //  skip over any other punctuation in the string.
                            //
                            fIgnorePunct = TRUE;

                            //
                            //  Advance pointer 1.  Pointer 2 will be
                            //  advanced after if-else statement.
                            //
                            pString1++; cchCount1--;
                        }

                        //
                        //  Advance pointer 2 and set flag to true.
                        //
                        pString2++; cchCount2--;
                        fContinue = TRUE;

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave2 == NULL)
                        {
                            pSave2 = pString2;
                        }
                        pString2 = pTmpBuf2;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf2[0] = GET_EXPANSION_1(&Weight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(&Weight2);

                        //
                        //  Set cExpChar2 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar2 = MAX_TBL_EXPANSION;
                        cchCount2++;

                        fContinue = TRUE;
                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm1 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight2.
                            //
                            GET_FAREAST_WEIGHT( Weight2,
                                                uw2,
                                                Mask,
                                                lpString2,
                                                pString2,
                                                ExtraWt2);

                            if (sm1 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the first string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 1 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt2) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt2) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt2) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt2) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_LESS_THAN;
                                }
                            }
                            else
                            {
                                //
                                //  Characters in both strings are fareast
                                //  special chars.
                                //
                                //  Set each of weights 4, 5, 6, and 7
                                //  appropriately (if not already set).
                                //
                                if ( (GET_WT_FOUR(&WhichExtra) == 0) &&
                                     ( GET_WT_FOUR(&ExtraWt1) !=
                                       GET_WT_FOUR(&ExtraWt2) ) )
                                {
                                    GET_WT_FOUR(&WhichExtra) =
                                      ( GET_WT_FOUR(&ExtraWt1) <
                                        GET_WT_FOUR(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_FIVE(&WhichExtra) == 0) &&
                                     ( GET_WT_FIVE(&ExtraWt1) !=
                                       GET_WT_FIVE(&ExtraWt2) ) )
                                {
                                    GET_WT_FIVE(&WhichExtra) =
                                      ( GET_WT_FIVE(&ExtraWt1) <
                                        GET_WT_FIVE(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SIX(&WhichExtra) == 0) &&
                                     ( GET_WT_SIX(&ExtraWt1) !=
                                       GET_WT_SIX(&ExtraWt2) ) )
                                {
                                    GET_WT_SIX(&WhichExtra) =
                                      ( GET_WT_SIX(&ExtraWt1) <
                                        GET_WT_SIX(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SEVEN(&WhichExtra) == 0) &&
                                     ( GET_WT_SEVEN(&ExtraWt1) !=
                                       GET_WT_SEVEN(&ExtraWt2) ) )
                                {
                                    GET_WT_SEVEN(&WhichExtra) =
                                      ( GET_WT_SEVEN(&ExtraWt1) <
                                        GET_WT_SEVEN(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        if (!JamoFlag)
                        {
                            LPCWSTR pStr1 = pString1;
                            LPCWSTR pStr2 = pString2;
                            // Set the JamoFlag so we don't handle it again in SM2.
                            JamoFlag = TRUE;
                            fContinue = FindJamoDifference(
                                &pStr1, &cchCount1, 0, &Weight1, 
                                &pStr2, &cchCount2, 0, &Weight2, 
                                &pLastJamo, 
                                &uw1, &uw2, 
                                &State,
                                &WhichJamo);

                            if (WhichJamo)
                            {
                                return (WhichJamo);
                            }
                            pString1 = pStr1;
                            pString2 = pStr2;                            
                        }
                        else
                        {
                            JamoFlag = FALSE;
                        }
                        break;
                    }                     
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  If sm1 is an extension A character, then
                        //  both sm1 and sm2 have been handled.  We should
                        //  only get here when either sm1 is not an
                        //  extension A character or the two extension A
                        //  characters are different.
                        //
                        if (sm1 != EXTENSION_A)
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            //  Only string2 contains an extension A char,
                            //  so set the UW value to be the first UW
                            //  value for extension A (default values):
                            //    SM_EXT_A, AW_EXT_A
                            //
                            uw2 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A);
                        }

                        //
                        //  We should then fall through to the comparison
                        //  of the Unicode weights.
                        //

                        break;
                    }
                    case ( UNSORTABLE ):
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  See if the comparison should start again.
                //
                if (fContinue)
                {
                    continue;
                }

                //
                //  We're not supposed to drop down into the state table if
                //  unicode weights are different, so stop comparison and
                //  return result of unicode weight comparison.
                //
                if (uw1 != uw2)
                {
                    return ((uw1 < uw2) ? CSTR_LESS_THAN : CSTR_GREATER_THAN);
                }
            }

            //
            //  For each state in the state table, do the appropriate
            //  comparisons.     (UW1 == UW2)
            //
            if (State & (STATE_DW | STATE_REVERSE_DW))
            {
                //
                //  Get the diacritic weights.
                //
                dw1 = GET_DIACRITIC(&Weight1);
                dw2 = GET_DIACRITIC(&Weight2);

                if (dw1 != dw2)
                {
                    //
                    //  Look ahead to see if diacritic follows a
                    //  minimum diacritic weight.  If so, get the
                    //  diacritic weight of the nonspace mark.
                    //

                    // Termination condition: when cchCount1 == 1, we are at
                    // the end of the string, so there is no way to look ahead.
                    // Hense cchCount should be greater than 1.
                    while (cchCount1 > 1)
                    {
                        Wt = GET_DWORD_WEIGHT(m_pSortKey, *(pString1 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw1 += GET_DIACRITIC(&Wt);
                            pString1++; cchCount1--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    while (cchCount2 > 1)
                    {
                        Wt = GET_DWORD_WEIGHT(m_pSortKey, *(pString2 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw2 += GET_DIACRITIC(&Wt);
                            pString2++; cchCount2--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    //  Save which string has the smaller diacritic
                    //  weight if the diacritic weights are still
                    //  different.
                    //
                    if (dw1 != dw2)
                    {
                        WhichDiacritic = (dw1 < dw2)
                                           ? CSTR_LESS_THAN
                                           : CSTR_GREATER_THAN;

                        //
                        //  Remove state from state machine.
                        //
                        REMOVE_STATE(STATE_DW);
                    }
                }
            }
            if (State & STATE_CW)
            {
                //
                //  Get the case weights.
                //
                if (GET_CASE(&Weight1) != GET_CASE(&Weight2))
                {
                    //
                    //  Save which string has the smaller case weight.
                    //
                    WhichCase = (GET_CASE(&Weight1) < GET_CASE(&Weight2))
                                  ? CSTR_LESS_THAN
                                  : CSTR_GREATER_THAN;

                    //
                    //  Remove state from state machine.
                    //
                    REMOVE_STATE(STATE_CW);
                }
            }
        }

        //
        //  Fixup the pointers.
        //
        if (pSave1 && (--cExpChar1 == 0))                                      
        {                                                                      
            /*                                                                 
             *  Done using expansion temporary buffer.                         
             */                                                                
            pString1 = pSave1;                                                 
            pSave1 = NULL;
        }
                                                                               
        if (pSave2 && (--cExpChar2 == 0))                                      
        {                                                                      
            /*                                                                 
             *  Done using expansion temporary buffer. 
             */ 
            pString2 = pSave2; 
            pSave2 = NULL; 
        }
                                                                               
        /* 
         *  Advance the string pointers. 
         */ 
        pString1++; cchCount1--;
        pString2++; cchCount2--;                                                
    }

ScanLongerString:
    //
    //  If the end of BOTH strings has been reached, then the unicode
    //  weights match exactly.  Check the diacritic, case and special
    //  weights.  If all are zero, then return success.  Otherwise,
    //  return the result of the weight difference.
    //
    //  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
    //            Diacritic, Case, Punctuation.
    //
    if (cchCount1 == 0)
    {
        if (cchCount2 == 0)
        {
            // Both of the strings have reached the end.
            if (WhichDiacritic)
            {
                return (WhichDiacritic);
            }
            if (WhichCase)
            {
                return (WhichCase);
            }
            if (WhichExtra)
            {
                if (GET_WT_FOUR(&WhichExtra))
                {
                    return (GET_WT_FOUR(&WhichExtra));
                }
                if (GET_WT_FIVE(&WhichExtra))
                {
                    return (GET_WT_FIVE(&WhichExtra));
                }
                if (GET_WT_SIX(&WhichExtra))
                {
                    return (GET_WT_SIX(&WhichExtra));
                }
                if (GET_WT_SEVEN(&WhichExtra))
                {
                    return (GET_WT_SEVEN(&WhichExtra));
                }
            }
            if (WhichPunct1)
            {
                return (WhichPunct1);
            }
            if (WhichPunct2)
            {
                return (WhichPunct2);
            }

            return (CSTR_EQUAL);
        }
        else
        {
            //
            //  String 2 is longer.
            //
            pString1 = pString2;
            cchCount1 = cchCount2;
        }
    }

    //
    //  Scan to the end of the longer string.
    //
    return QUICK_SCAN_LONGER_STRING( pString1,
                              cchCount1,
                              ((cchCount2 == 0)
                                ? CSTR_GREATER_THAN
                                : CSTR_LESS_THAN),
                                WhichDiacritic,
                                WhichCase,
                                WhichPunct1,
                                WhichPunct2,
                                WhichExtra);
}

int NativeCompareInfo::QUICK_SCAN_LONGER_STRING(
    LPCWSTR ptr,
    int cchCount1,
    int ret,
    int& WhichDiacritic,
    int& WhichCase,
    int& WhichPunct1,
    int& WhichPunct2,
    DWORD& WhichExtra
)
{
    /*
     *  Search through the rest of the longer string to make sure
     *  all characters are not to be ignored.  If find a character that
     *  should not be ignored, return the given return value immediately.
     *
     *  The only exception to this is when a nonspace mark is found.  If
     *  another DW difference has been found earlier, then use that.
     */
    while (cchCount1 != 0)
    {
        switch (GET_SCRIPT_MEMBER((LPDWORD)&(m_pSortKey[*ptr])))
        {
            case ( UNSORTABLE ):
            {
                break;
            }
            case ( NONSPACE_MARK ):
            {
                if (!WhichDiacritic)
                {
                    return (ret);
                }
                break;
            }
            default :
            {
                return (ret);
            }
        }

        /*
         *  Advance pointer.
         */
        ptr++; cchCount1--;
    }

    /*
     *  Need to check diacritic, case, extra, and special weights for
     *  final return value.  Still could be equal if the longer part of
     *  the string contained only unsortable characters.
     *
     *  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
     *            Diacritic, Case, Extra, Punctuation.
     */
    if (WhichDiacritic)
    {
        return (WhichDiacritic);
    }
    if (WhichCase)
    {
        return (WhichCase);
    }
    if (WhichExtra)
    {
        if (GET_WT_FOUR(&WhichExtra))
        {
            return (GET_WT_FOUR(&WhichExtra));
        }
        if (GET_WT_FIVE(&WhichExtra))
        {
            return (GET_WT_FIVE(&WhichExtra));
        }
        if (GET_WT_SIX(&WhichExtra))
        {
            return (GET_WT_SIX(&WhichExtra));
        }
        if (GET_WT_SEVEN(&WhichExtra))
        {
            return (GET_WT_SEVEN(&WhichExtra));
        }
    }
    if (WhichPunct1)
    {
        return (WhichPunct1);
    }
    if (WhichPunct2)
    {
        return (WhichPunct2);
    }

    return (CSTR_EQUAL);
}

int NativeCompareInfo::SCAN_LONGER_STRING(
    int ct,
    LPCWSTR ptr,
    int cchIn,
    BOOL ret,
    DWORD& Weight1,
    BOOL& fIgnoreDiacritic,
    int& WhichDiacritic,
    BOOL& fIgnoreSymbol ,
    int& WhichCase ,
    DWORD& WhichExtra ,
    int& WhichPunct1,
    int& WhichPunct2)
{
    /*
     *  Search through the rest of the longer string to make sure
     *  all characters are not to be ignored.  If find a character that
     *  should not be ignored, return the given return value immediately.
     *
     *  The only exception to this is when a nonspace mark is found.  If
     *  another DW difference has been found earlier, then use that.
     */
    while (NOT_END_STRING(ct, ptr, cchIn))
    {
        Weight1 = GET_DWORD_WEIGHT(m_pSortKey, *ptr);
        switch (GET_SCRIPT_MEMBER(&Weight1))
        {
            case ( UNSORTABLE ):
            {
                break;
            }
            case ( NONSPACE_MARK ):
            {
                if ((!fIgnoreDiacritic) && (!WhichDiacritic))
                {
                    return (ret);
                }
                break;
            }
            case ( PUNCTUATION ) :
            case ( SYMBOL_1 ) :
            case ( SYMBOL_2 ) :
            case ( SYMBOL_3 ) :
            case ( SYMBOL_4 ) :
            case ( SYMBOL_5 ) :
            {
                if (!fIgnoreSymbol)
                {
                    return (ret);
                }
                break;
            }
            case ( EXPANSION ) :
            case ( FAREAST_SPECIAL ) :
            case ( JAMO_SPECIAL ) :
            case ( EXTENSION_A) :
            default :
            {
                return (ret);
            }
        }

        /*
         *  Advance pointer and decrement counter.
         */
        ptr++;
        ct--;
    }

    /*
     *  Need to check diacritic, case, extra, and special weights for
     *  final return value.  Still could be equal if the longer part of
     *  the string contained only characters to be ignored.
     *
     *  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
     *            Diacritic, Case, Extra, Punctuation.
     */
    if (WhichDiacritic)
    {
        return (WhichDiacritic);
    }
    if (WhichCase)
    {
        return (WhichCase);
    }
    if (WhichExtra)
    {
        if (!fIgnoreDiacritic)
        {
            if (GET_WT_FOUR(&WhichExtra))
            {
                return (GET_WT_FOUR(&WhichExtra));
            }
            if (GET_WT_FIVE(&WhichExtra))
            {
                return (GET_WT_FIVE(&WhichExtra));
            }
        }
        if (GET_WT_SIX(&WhichExtra))
        {
            return (GET_WT_SIX(&WhichExtra));
        }
        if (GET_WT_SEVEN(&WhichExtra))
        {
            return (GET_WT_SEVEN(&WhichExtra));
        }
    }
    if (WhichPunct1)
    {
        return (WhichPunct1);
    }
    if (WhichPunct2)
    {
        return (WhichPunct2);
    }

    return (CSTR_EQUAL);
}

////////////////////////////////////////////////////////////////////////////
//
//  LongCompareStringW
//
//  Compares two wide character strings of the same locale according to the
//  supplied locale handle.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int NativeCompareInfo::LongCompareStringW(
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2)
{
    int ctr1 = cchCount1;         // loop counter for string 1
    int ctr2 = cchCount2;         // loop counter for string 2
    register LPCWSTR pString1;     // ptr to go thru string 1
    register LPCWSTR pString2;     // ptr to go thru string 2
    BOOL IfCompress;              // if compression in locale
    BOOL IfDblCompress1;          // if double compression in string 1
    BOOL IfDblCompress2;          // if double compression in string 2
    BOOL fEnd1;                   // if at end of string 1
    BOOL fIgnorePunct;            // flag to ignore punctuation (not symbol)
    BOOL fIgnoreDiacritic;        // flag to ignore diacritics
    BOOL fIgnoreSymbol;           // flag to ignore symbols
    BOOL fStringSort;             // flag to use string sort
    DWORD State;                  // state table
    DWORD Mask;                   // mask for weights
    DWORD Weight1;                // full weight of char - string 1
    DWORD Weight2;                // full weight of char - string 2
    int JamoFlag = FALSE;
    LPCWSTR pLastJamo = lpString1;
    
    int WhichDiacritic;           // DW => 1 = str1 smaller, 3 = str2 smaller
    int WhichCase;                // CW => 1 = str1 smaller, 3 = str2 smaller
    int WhichJamo;              // SW for Jamo
    int WhichPunct1;              // SW => 1 = str1 smaller, 3 = str2 smaller
    int WhichPunct2;              // SW => 1 = str1 smaller, 3 = str2 smaller
    LPCWSTR pSave1;                // ptr to saved pString1
    LPCWSTR pSave2;                // ptr to saved pString2
    int cExpChar1, cExpChar2;     // ct of expansions in tmp

    DWORD ExtraWt1, ExtraWt2;     // extra weight values (for far east)
///
    ExtraWt1 = ExtraWt2 = 0;

    DWORD WhichExtra;             // XW => wts 4, 5, 6, 7 (for far east)

    THROWSCOMPLUSEXCEPTION();

    //
    //  Initialize string pointers.
    //
    pString1 = (LPWSTR)lpString1;
    pString2 = (LPWSTR)lpString2;

    //
    //  Invalid Parameter Check:
    //    - invalid locale (hash node)
    //    - either string is null
    //
    // We have already validate pString1/pString2 in COMNlsInfo::CompareString().
    _ASSERTE(pString1 != NULL && pString2 != NULL);

    //
    //  Invalid Flags Check:
    //    - invalid flags
    //
    if (dwCmpFlags & CS_INVALID_FLAG)
    {
        COMPlusThrowArgumentException(L"flags", L"Argument_InvalidFlag");
        return (0);
    }

    //
    //  See if we should stop on the null terminator regardless of the
    //  count values.  The original count values are stored in ctr1 and ctr2
    //  above, so it's ok to set these here.
    //
    if (dwCmpFlags & COMPARE_OPTIONS_STOP_ON_NULL)
    {
        cchCount1 = cchCount2 = -2;
    }

    //
    //  Check if compression in the given locale.  If not, then
    //  try a wchar by wchar compare.  If strings are equal, this
    //  will be quick.
    //
///

    if ((IfCompress = m_IfCompression) == FALSE)
    {
        //
        //  Compare each wide character in the two strings.
        //
        while ( NOT_END_STRING(ctr1, pString1, cchCount1) &&
                NOT_END_STRING(ctr2, pString2, cchCount2) )
        {
            //
            //  See if characters are equal.
            //
            if (*pString1 == *pString2)
            {
                //
                //  Characters are equal, so increment pointers,
                //  decrement counters, and continue string compare.
                //
                pString1++;
                pString2++;
                ctr1--;
                ctr2--;
            }
            else
            {
                //
                //  Difference was found.  Fall into the sortkey
                //  check below.
                //
                break;
            }
        }

        //
        //  If the end of BOTH strings has been reached, then the strings
        //  match exactly.  Return success.
        //
        if ( AT_STRING_END(ctr1, pString1, cchCount1) &&
             AT_STRING_END(ctr2, pString2, cchCount2) )
        {
            return (CSTR_EQUAL);
        }
    }
    //
    //  Initialize flags, pointers, and counters.
    //
    fIgnorePunct = dwCmpFlags & COMPARE_OPTIONS_IGNORESYMBOLS;
    fIgnoreDiacritic = dwCmpFlags & COMPARE_OPTIONS_IGNORENONSPACE;
    fIgnoreSymbol = fIgnorePunct;
    fStringSort = dwCmpFlags & COMPARE_OPTIONS_STRINGSORT;
    WhichDiacritic = 0;
    WhichCase = 0;
    WhichJamo = 0;
    WhichPunct1 = 0;
    WhichPunct2 = 0;
    pSave1 = NULL;
    pSave2 = NULL;
    ExtraWt1 = (DWORD)0;
    WhichExtra = (DWORD)0;

    //
    //  Set the weights to be invalid.  This flags whether or not to
    //  recompute the weights next time through the loop.  It also flags
    //  whether or not to start over (continue) in the loop.
    //
    Weight1 = CMP_INVALID_WEIGHT;
    Weight2 = CMP_INVALID_WEIGHT;

    //
    //  Switch on the different flag options.  This will speed up
    //  the comparisons of two strings that are different.
    //
    State = STATE_CW | STATE_JAMO_WEIGHT;    
    switch (dwCmpFlags & (COMPARE_OPTIONS_IGNORECASE | COMPARE_OPTIONS_IGNORENONSPACE))
    {
        case ( 0 ) :
        {
            Mask = CMP_MASKOFF_NONE;
            State |= (m_IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;

            break;
        }

        case ( COMPARE_OPTIONS_IGNORECASE ) :
        {
            Mask = CMP_MASKOFF_CW;
            State |= (m_IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;

            break;
        }

        case ( COMPARE_OPTIONS_IGNORENONSPACE ) :
        {
            Mask = CMP_MASKOFF_DW;

            break;
        }

        case ( COMPARE_OPTIONS_IGNORECASE | COMPARE_OPTIONS_IGNORENONSPACE ) :
        {
            Mask = CMP_MASKOFF_DW_CW;

            break;
        }

        default:
            _ASSERTE(!"Unknown compare options passed into LongCompareStringW!");
            Mask = CMP_MASKOFF_NONE;
    }

    switch (dwCmpFlags & (COMPARE_OPTIONS_IGNOREKANATYPE | COMPARE_OPTIONS_IGNOREWIDTH))
    {
        case ( 0 ) :
        {
            break;
        }

        case ( COMPARE_OPTIONS_IGNOREKANATYPE ) :
        {
            Mask &= CMP_MASKOFF_KANA;

            break;
        }

        case ( COMPARE_OPTIONS_IGNOREWIDTH ) :
        {
            Mask &= CMP_MASKOFF_WIDTH;

            if (dwCmpFlags & COMPARE_OPTIONS_IGNORECASE)
            {
                REMOVE_STATE(STATE_CW);
            }

            break;
        }

        case ( COMPARE_OPTIONS_IGNOREKANATYPE | COMPARE_OPTIONS_IGNOREWIDTH ) :
        {
            Mask &= CMP_MASKOFF_KANA_WIDTH;

            if (dwCmpFlags & COMPARE_OPTIONS_IGNORECASE)
            {
                REMOVE_STATE(STATE_CW);
            }

            break;
        }
    }

    //
    //  Compare each character's sortkey weight in the two strings.
    //
    while ( NOT_END_STRING(ctr1, pString1, cchCount1) &&
            NOT_END_STRING(ctr2, pString2, cchCount2) )
    {
        if (Weight1 == CMP_INVALID_WEIGHT)
        {
            Weight1 = GET_DWORD_WEIGHT(m_pSortKey, *pString1);
            Weight1 &= Mask;
        }
        if (Weight2 == CMP_INVALID_WEIGHT)
        {
            Weight2 = GET_DWORD_WEIGHT(m_pSortKey, *pString2);
            Weight2 &= Mask;
        }

        //
        //  If compression locale, then need to check for compression
        //  characters even if the weights are equal.  If it's not a
        //  compression locale, then we don't need to check anything
        //  if the weights are equal.
        //
        if ( (IfCompress) &&
             (GET_COMPRESSION(&Weight1) || GET_COMPRESSION(&Weight2)) )
        {
            int ctr;                   // loop counter
            PCOMPRESS_3 pComp3;        // ptr to compress 3 table
            PCOMPRESS_2 pComp2;        // ptr to compress 2 table
            int If1;                   // if compression found in string 1
            int If2;                   // if compression found in string 2
            int CompVal;               // compression value
            int IfEnd1;                // if exists 1 more char in string 1
            int IfEnd2;                // if exists 1 more char in string 2


            //
            //  Check for compression in the weights.
            //
            If1 = GET_COMPRESSION(&Weight1);
            If2 = GET_COMPRESSION(&Weight2);
            CompVal = ((If1 > If2) ? If1 : If2);

            IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
            IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);

            if (m_IfDblCompression == FALSE)
            {
                //
                //  NO double compression, so don't check for it.
                //
                switch (CompVal)
                {
                    //
                    //  Check for 3 characters compressing to 1.
                    //
                    case ( COMPRESS_3_MASK ) :
                    {
                        //
                        //  Check character in string 1 and string 2.
                        //
                        if ( ((If1) && (!IfEnd1) &&
                              !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1)) ||
                             ((If2) && (!IfEnd2) &&
                              !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2)) )
                        {
                            ctr = m_pCompHdr->Num3;
                            pComp3 = m_pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (If1) && (!IfEnd1) &&
                                     !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) &&
                                     (pComp3->UCP1 == *pString1) &&
                                     (pComp3->UCP2 == *(pString1 + 1)) &&
                                     (pComp3->UCP3 == *(pString1 + 2)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight1 &= Mask;
                                    pString1 += 2;
                                    ctr1 -= 2;

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If2 == 0)
                                        break;
                                }

                                //
                                //  Check character in string 2.
                                //
                                if ( (If2) && (!IfEnd2) &&
                                     !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) &&
                                     (pComp3->UCP1 == *pString2) &&
                                     (pComp3->UCP2 == *(pString2 + 1)) &&
                                     (pComp3->UCP3 == *(pString2 + 2)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight2 &= Mask;
                                    pString2 += 2;
                                    ctr2 -= 2;

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If1 == 0)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                        //
                        //  Fall through if not found.
                        //
                    }

                    //
                    //  Check for 2 characters compressing to 1.
                    //
                    case ( COMPRESS_2_MASK ) :
                    {
                        //
                        //  Check character in string 1 and string 2.
                        //
                        if ( ((If1) && (!IfEnd1)) ||
                             ((If2) && (!IfEnd2)) )
                        {
                            ctr = m_pCompHdr->Num2;
                            pComp2 = m_pCompress2;
                            for (; ((ctr > 0) && (If1 || If2)); ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (If1) &&
                                     (!IfEnd1) &&
                                     (pComp2->UCP1 == *pString1) &&
                                     (pComp2->UCP2 == *(pString1 + 1)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight1 &= Mask;
                                    pString1++;
                                    ctr1--;

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If2 == 0)
                                   {
                                        break;
                                   }
                                }

                                //
                                //  Check character in string 2.
                                //
                                if ( (If2) &&
                                     (!IfEnd2) &&
                                     (pComp2->UCP1 == *pString2) &&
                                     (pComp2->UCP2 == *(pString2 + 1)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight2 &= Mask;
                                    pString2++;
                                    ctr2--;

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If1 == 0)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            else if (!IfEnd1 && !IfEnd2)
            {
                //
                //  Double Compression exists, so must check for it.
                //
                if (IfDblCompress1 =
                       ((GET_DWORD_WEIGHT(m_pSortKey, *pString1) & CMP_MASKOFF_CW) ==
                        (GET_DWORD_WEIGHT(m_pSortKey, *(pString1 + 1)) & CMP_MASKOFF_CW)))
                {
                    //
                    //  Advance past the first code point to get to the
                    //  compression character.
                    //
                    pString1++;
                    ctr1--;
                    IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
                }

                if (IfDblCompress2 =
                       ((GET_DWORD_WEIGHT(m_pSortKey, *pString2) & CMP_MASKOFF_CW) ==
                        (GET_DWORD_WEIGHT(m_pSortKey, *(pString2 + 1)) & CMP_MASKOFF_CW)))
                {
                    //
                    //  Advance past the first code point to get to the
                    //  compression character.
                    //
                    pString2++;
                    ctr2--;
                    IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);
                }

                switch (CompVal)
                {
                    //
                    //  Check for 3 characters compressing to 1.
                    //
                    case ( COMPRESS_3_MASK ) :
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ( (If1) && (!IfEnd1) &&
                             !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) )
                        {
                            ctr = m_pCompHdr->Num3;
                            pComp3 = m_pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (pComp3->UCP1 == *pString1) &&
                                     (pComp3->UCP2 == *(pString1 + 1)) &&
                                     (pComp3->UCP3 == *(pString1 + 2)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight1 &= Mask;
                                    if (!IfDblCompress1)
                                    {
                                        pString1 += 2;
                                        ctr1 -= 2;
                                    }

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;
                                    break;
                                }
                            }
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ( (If2) && (!IfEnd2) &&
                             !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) )
                        {
                            ctr = m_pCompHdr->Num3;
                            pComp3 = m_pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 2.
                                //
                                if ( (pComp3->UCP1 == *pString2) &&
                                     (pComp3->UCP2 == *(pString2 + 1)) &&
                                     (pComp3->UCP3 == *(pString2 + 2)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight2 &= Mask;
                                    if (!IfDblCompress2)
                                    {
                                        pString2 += 2;
                                        ctr2 -= 2;
                                    }

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;
                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((If1 == 0) && (If2 == 0))
                        {
                            break;
                        }
                    }

                    //
                    //  Check for 2 characters compressing to 1.
                    //
                    case ( COMPRESS_2_MASK ) :
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ((If1) && (!IfEnd1))
                        {
                            ctr = m_pCompHdr->Num2;
                            pComp2 = m_pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ((pComp2->UCP1 == *pString1) &&
                                    (pComp2->UCP2 == *(pString1 + 1)))
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight1 &= Mask;
                                    if (!IfDblCompress1)
                                    {
                                        pString1++;
                                        ctr1--;
                                    }

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;
                                    break;
                                }
                            }
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ((If2) && (!IfEnd2))
                        {
                            ctr = m_pCompHdr->Num2;
                            pComp2 = m_pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 2.
                                //
                                if ((pComp2->UCP1 == *pString2) &&
                                    (pComp2->UCP2 == *(pString2 + 1)))
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight2 &= Mask;
                                    if (!IfDblCompress2)
                                    {
                                        pString2++;
                                        ctr2--;
                                    }

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;
                                    break;
                                }
                            }
                        }
                    }
                }

                //
                //  Reset the pointer back to the beginning of the double
                //  compression.  Pointer fixup at the end will advance
                //  them correctly.
                //
                //  If double compression, we advanced the pointer at
                //  the beginning of the switch statement.  If double
                //  compression character was actually found, the pointer
                //  was NOT advanced.  We now want to decrement the pointer
                //  to put it back to where it was.
                //
                //  The next time through, the pointer will be pointing to
                //  the regular compression part of the string.
                //
                if (IfDblCompress1)
                {
                    pString1--;
                    ctr1++;
                }
                if (IfDblCompress2)
                {
                    pString2--;
                    ctr2++;
                }
            }
        }

        //
        //  Check the weights again.
        //
        if ((Weight1 != Weight2) ||
            (GET_SCRIPT_MEMBER(&Weight1) == EXTENSION_A))
        {
            //
            //  Weights are still not equal, even after compression
            //  check, so compare the different weights.
            //
            BYTE sm1 = GET_SCRIPT_MEMBER(&Weight1);                // script member 1
            BYTE sm2 = GET_SCRIPT_MEMBER(&Weight2);                // script member 2
            WORD uw1 = GET_UNICODE(&Weight1);                      // unicode weight 1
            WORD uw2 = GET_UNICODE(&Weight2);                      // unicode weight 2
            BYTE dw1;                                              // diacritic weight 1
            BYTE dw2;                                              // diacritic weight 2
            DWORD Wt;                                              // temp weight holder
            WCHAR pTmpBuf1[MAX_TBL_EXPANSION];                     // temp buffer for exp 1
            WCHAR pTmpBuf2[MAX_TBL_EXPANSION];                     // temp buffer for exp 2


            //
            //  If Unicode Weights are different and no special cases,
            //  then we're done.  Otherwise, we need to do extra checking.
            //
            //  Must check ENTIRE string for any possibility of Unicode Weight
            //  differences.  As soon as a Unicode Weight difference is found,
            //  then we're done.  If no UW difference is found, then the
            //  first Diacritic Weight difference is used.  If no DW difference
            //  is found, then use the first Case Difference.  If no CW
            //  difference is found, then use the first Extra Weight
            //  difference.  If no XW difference is found, then use the first
            //  Special Weight difference.
            //
            if ((uw1 != uw2) ||
                ((sm1 <= SYMBOL_5) && (sm1 >= FAREAST_SPECIAL)))
            {
                //
                //  Check for Unsortable characters and skip them.
                //  This needs to be outside the switch statement.  If EITHER
                //  character is unsortable, must skip it and start over.
                //
                if (sm1 == UNSORTABLE)
                {
                    pString1++;
                    ctr1--;
                    Weight1 = CMP_INVALID_WEIGHT;
                }
                if (sm2 == UNSORTABLE)
                {
                    pString2++;
                    ctr2--;
                    Weight2 = CMP_INVALID_WEIGHT;
                }

                //
                //  Check for Ignore Nonspace and Ignore Symbol.  If
                //  Ignore Nonspace is set and either character is a
                //  nonspace mark only, then we need to advance the
                //  pointer to skip over the character and continue.
                //  If Ignore Symbol is set and either character is a
                //  punctuation char, then we need to advance the
                //  pointer to skip over the character and continue.
                //
                //  This step is necessary so that a string with a
                //  nonspace mark and a punctuation char following one
                //  another are properly ignored when one or both of
                //  the ignore flags is set.
                //
                if (fIgnoreDiacritic)
                {
                    if (sm1 == NONSPACE_MARK)
                    {
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;
                    }
                    if (sm2 == NONSPACE_MARK)
                    {
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;
                    }
                }
                if (fIgnoreSymbol)
                {
                    if (sm1 == PUNCTUATION)
                    {
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;
                    }
                    if (sm2 == PUNCTUATION)
                    {
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;
                    }
                }
                if ((Weight1 == CMP_INVALID_WEIGHT) || (Weight2 == CMP_INVALID_WEIGHT))
                {
                    continue;
                }

                //
                //  Switch on the script member of string 1 and take care
                //  of any special cases.
                //
                switch (sm1)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if (!fIgnoreDiacritic)
                        {
                            if ((WhichDiacritic == 0) ||
                                (State & STATE_REVERSE_DW))
                            {
                                WhichDiacritic = CSTR_GREATER_THAN;

                                //
                                //  Remove state from state machine.
                                //
                                REMOVE_STATE(STATE_DW);
                            }
                        }

                        //
                        //  Adjust pointer and counter and set flags.
                        //
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( SYMBOL_1 ) :
                    case ( SYMBOL_2 ) :
                    case ( SYMBOL_3 ) :
                    case ( SYMBOL_4 ) :
                    case ( SYMBOL_5 ) :
                    {
                        //
                        //  If the ignore symbol flag is set, then skip over
                        //  the symbol.
                        //
                        if (fIgnoreSymbol)
                        {
                            pString1++;
                            ctr1--;
                            Weight1 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation char.
                        //
                        if (fIgnorePunct)
                        {
                            pString1++;
                            ctr1--;
                            Weight1 = CMP_INVALID_WEIGHT;
                        }
                        else if (!fStringSort)
                        {
                            //
                            //  Use WORD sort method.
                            //
                            if (sm2 != PUNCTUATION)
                            {
                                //
                                //  The character in the second string is
                                //  NOT punctuation.
                                //
                                if (WhichPunct2)
                                {
                                    //
                                    //  Set WP 2 to show that string 2 is
                                    //  smaller, since a punctuation char had
                                    //  already been found at an earlier
                                    //  position in string 2.
                                    //
                                    //  Set the Ignore Punctuation flag so we
                                    //  just skip over any other punctuation
                                    //  chars in the string.
                                    //
                                    WhichPunct2 = CSTR_GREATER_THAN;
                                    fIgnorePunct = TRUE;
                                }
                                else
                                {
                                    //
                                    //  Set WP 1 to show that string 2 is
                                    //  smaller, and that string 1 has had
                                    //  a punctuation char - since no
                                    //  punctuation chars have been found
                                    //  in string 2.
                                    //
                                    WhichPunct1 = CSTR_GREATER_THAN;
                                }

                                //
                                //  Advance pointer 1 and decrement counter 1.
                                //
                                pString1++;
                                ctr1--;
                                Weight1 = CMP_INVALID_WEIGHT;
                            }

                            //
                            //  Do NOT want to advance the pointer in string 1
                            //  if string 2 is also a punctuation char.  This
                            //  will be done later.
                            //
                        }

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave1 == NULL)
                        {
                            pSave1 = pString1;
                        }
                        pString1 = pTmpBuf1;

                        //
                        //  Add one to counter so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        ctr1++;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf1[0] = GET_EXPANSION_1(&Weight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(&Weight1);

                        //
                        //  Set cExpChar1 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar1 = MAX_TBL_EXPANSION;

                        Weight1 = CMP_INVALID_WEIGHT;
                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm2 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight1.
                            //
                            GET_FAREAST_WEIGHT( Weight1,
                                                uw1,
                                                Mask,
                                                lpString1,
                                                pString1,
                                                ExtraWt1);

                            if (sm2 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the second string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 2 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt1) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt1) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt1) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt1) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        LPCWSTR pStr1 = pString1;
                        LPCWSTR pStr2 = pString2;
                        // Set the JamoFlag so we don't handle it again in SM2.
                        JamoFlag = TRUE;
                        FindJamoDifference(
                            &pStr1, &ctr1, cchCount1, &Weight1, 
                            &pStr2, &ctr2, cchCount2, &Weight2, 
                            &pLastJamo, 
                            &uw1, &uw2, 
                            &State,
                            &WhichJamo);

                        if (WhichJamo) 
                        {
                            return (WhichJamo);
                        }
                        pString1 = pStr1;
                        pString2 = pStr2;
                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  Get the full weight in case DW got masked.
                        //
                        Weight1 = GET_DWORD_WEIGHT(m_pSortKey, *pString1);
                        if (sm2 == EXTENSION_A)
                        {
                            Weight2 = GET_DWORD_WEIGHT(m_pSortKey, *pString2);
                        }

                        //
                        //  Compare the weights.
                        //
                        if (Weight1 == Weight2)
                        {
                            //
                            //  Adjust pointers and counters and set flags.
                            //
                            pString1++;  pString2++;
                            ctr1--;  ctr2--;
                            Weight1 = CMP_INVALID_WEIGHT;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                        else
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            if (sm2 == EXTENSION_A)
                            {
                                //
                                //  Set the UW values to be the AW and DW since
                                //  both strings contain an extension A char.
                                //
                                uw1 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight1),
                                                       GET_DIACRITIC(&Weight1));
                                uw2 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight2),
                                                       GET_DIACRITIC(&Weight2));
                            }
                            else
                            {
                                //
                                //  Only string1 contains an extension A char,
                                //  so set the UW value to be the first UW
                                //  value for extension A (default values):
                                //    SM_EXT_A, AW_EXT_A
                                //
                                uw1 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A);
                            }
                        }

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  Switch on the script member of string 2 and take care
                //  of any special cases.
                //
                switch (sm2)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if (!fIgnoreDiacritic)
                        {
                            if ((WhichDiacritic == 0) ||
                                (State & STATE_REVERSE_DW))

                            {
                                WhichDiacritic = CSTR_LESS_THAN;

                                //
                                //  Remove state from state machine.
                                //
                                REMOVE_STATE(STATE_DW);
                            }
                        }

                        //
                        //  Adjust pointer and counter and set flags.
                        //
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( SYMBOL_1 ) :
                    case ( SYMBOL_2 ) :
                    case ( SYMBOL_3 ) :
                    case ( SYMBOL_4 ) :
                    case ( SYMBOL_5 ) :
                    {
                        //
                        //  If the ignore symbol flag is set, then skip over
                        //  the symbol.
                        //
                        if (fIgnoreSymbol)
                        {
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then
                        //  skip over the punctuation char.
                        //
                        if (fIgnorePunct)
                        {
                            //
                            //  Advance pointer 2 and decrement counter 2.
                            //
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                        else if (!fStringSort)
                        {
                            //
                            //  Use WORD sort method.
                            //
                            if (sm1 != PUNCTUATION)
                            {
                                //
                                //  The character in the first string is
                                //  NOT punctuation.
                                //
                                if (WhichPunct1)
                                {
                                    //
                                    //  Set WP 1 to show that string 1 is
                                    //  smaller, since a punctuation char had
                                    //  already been found at an earlier
                                    //  position in string 1.
                                    //
                                    //  Set the Ignore Punctuation flag so we
                                    //  just skip over any other punctuation
                                    //  chars in the string.
                                    //
                                    WhichPunct1 = CSTR_LESS_THAN;
                                    fIgnorePunct = TRUE;
                                }
                                else
                                {
                                    //
                                    //  Set WP 2 to show that string 1 is
                                    //  smaller, and that string 2 has had
                                    //  a punctuation char - since no
                                    //  punctuation chars have been found
                                    //  in string 1.
                                    //
                                    WhichPunct2 = CSTR_LESS_THAN;
                                }

                                //
                                //  Pointer 2 and counter 2 will be updated
                                //  after if-else statement.
                                //
                            }
                            else
                            {
                                //
                                //  Both code points are punctuation chars.
                                //
                                //  See if either of the strings has encountered
                                //  punctuation chars previous to this.
                                //
                                if (WhichPunct1)
                                {
                                    //
                                    //  String 1 has had a punctuation char, so
                                    //  it should be the smaller string (since
                                    //  both have punctuation chars).
                                    //
                                    WhichPunct1 = CSTR_LESS_THAN;
                                }
                                else if (WhichPunct2)
                                {
                                    //
                                    //  String 2 has had a punctuation char, so
                                    //  it should be the smaller string (since
                                    //  both have punctuation chars).
                                    //
                                    WhichPunct2 = CSTR_GREATER_THAN;
                                }
                                else
                                {
                                    BYTE aw1 = GET_ALPHA_NUMERIC(&Weight1);
                                    BYTE aw2 = GET_ALPHA_NUMERIC(&Weight2);

                                    if (aw1 == aw2) 
                                    {
                                        BYTE cw1 = GET_CASE(&Weight1);
                                        BYTE cw2 = GET_CASE(&Weight2);
                                        if (cw1 < cw2) 
                                        {
                                            WhichPunct1 = CSTR_LESS_THAN;
                                        } else if (cw1 > cw2)
                                        {
                                            WhichPunct1 = CSTR_GREATER_THAN;
                                        }
                                    } else 
                                    {
                                        //
                                        //  Position is the same, so compare the
                                        //  special weights.   Set WhichPunct1 to
                                        //  the smaller special weight.
                                        //
                                        WhichPunct1 = (aw1 < aw2)
                                                        ? CSTR_LESS_THAN
                                                        : CSTR_GREATER_THAN;
                                    }
                                }

                                //
                                //  Set the Ignore Punctuation flag.
                                //
                                fIgnorePunct = TRUE;

                                //
                                //  Advance pointer 1 and decrement counter 1.
                                //  Pointer 2 and counter 2 will be updated
                                //  after if-else statement.
                                //
                                pString1++;
                                ctr1--;
                                Weight1 = CMP_INVALID_WEIGHT;
                            }

                            //
                            //  Advance pointer 2 and decrement counter 2.
                            //
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be restored.
                        //
                        if (pSave2 == NULL)
                        {
                            pSave2 = pString2;
                        }
                        pString2 = pTmpBuf2;

                        //
                        //  Add one to counter so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        ctr2++;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf2[0] = GET_EXPANSION_1(&Weight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(&Weight2);

                        //
                        //  Set cExpChar2 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar2 = MAX_TBL_EXPANSION;

                        Weight2 = CMP_INVALID_WEIGHT;
                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm1 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight2.
                            //


                            GET_FAREAST_WEIGHT( Weight2,
                                                uw2,
                                                Mask,
                                                lpString2,
                                                pString2,
                                                ExtraWt2);

                            if (sm1 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the first string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 1 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt2) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt2) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt2) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt2) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_LESS_THAN;
                                }
                            }
                            else
                            {
                                //
                                //  Characters in both strings are fareast
                                //  special chars.
                                //
                                //  Set each of weights 4, 5, 6, and 7
                                //  appropriately (if not already set).
                                //
                                if ( (GET_WT_FOUR(&WhichExtra) == 0) &&
                                     ( GET_WT_FOUR(&ExtraWt1) !=
                                       GET_WT_FOUR(&ExtraWt2) ) )
                                {
                                    GET_WT_FOUR(&WhichExtra) =
                                      ( GET_WT_FOUR(&ExtraWt1) <
                                        GET_WT_FOUR(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_FIVE(&WhichExtra) == 0) &&
                                     ( GET_WT_FIVE(&ExtraWt1) !=
                                       GET_WT_FIVE(&ExtraWt2) ) )
                                {
                                    GET_WT_FIVE(&WhichExtra) =
                                      ( GET_WT_FIVE(&ExtraWt1) <
                                        GET_WT_FIVE(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SIX(&WhichExtra) == 0) &&
                                     ( GET_WT_SIX(&ExtraWt1) !=
                                       GET_WT_SIX(&ExtraWt2) ) )
                                {
                                    GET_WT_SIX(&WhichExtra) =
                                      ( GET_WT_SIX(&ExtraWt1) <
                                        GET_WT_SIX(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SEVEN(&WhichExtra) == 0) &&
                                     ( GET_WT_SEVEN(&ExtraWt1) !=
                                       GET_WT_SEVEN(&ExtraWt2) ) )
                                {
                                    GET_WT_SEVEN(&WhichExtra) =
                                      ( GET_WT_SEVEN(&ExtraWt1) <
                                        GET_WT_SEVEN(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        if (!JamoFlag)
                        {                            
                            LPCWSTR pStr1 = pString1;
                            LPCWSTR pStr2 = pString2;
                            FindJamoDifference(
                                &pStr1, &ctr1, cchCount1, &Weight1, 
                                &pStr2, &ctr2, cchCount2, &Weight2, 
                                &pLastJamo, 
                                &uw1, &uw2, 
                                &State,
                                &WhichJamo);
                            if (WhichJamo) 
                            {
                                return (WhichJamo);
                            }                            
                            pString1 = pStr1;
                            pString2 = pStr2;
                        } else
                        {
                            // Reset the Jamo flag.
                            JamoFlag = FALSE;
                        }
                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  If sm1 is an extension A character, then
                        //  both sm1 and sm2 have been handled.  We should
                        //  only get here when either sm1 is not an
                        //  extension A character or the two extension A
                        //  characters are different.
                        //
                        if (sm1 != EXTENSION_A)
                        {
                            //
                            //  Get the full weight in case DW got masked.
                            //  Also, get the actual UW to compare.
                            //
                            //  Only string2 contains an extension A char,
                            //  so set the UW value to be the first UW
                            //  value for extension A (default values):
                            //    SM_EXT_A, AW_EXT_A
                            //
                            Weight2 = GET_DWORD_WEIGHT(m_pSortKey, *pString2);
                            uw2 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A);
                        }

                        //
                        //  We should then fall through to the comparison
                        //  of the Unicode weights.
                        //

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  See if the comparison should start again.
                //
                if ((Weight1 == CMP_INVALID_WEIGHT) || (Weight2 == CMP_INVALID_WEIGHT))
                {
                    continue;
                }

                //
                //  We're not supposed to drop down into the state table if
                //  the unicode weights are different, so stop comparison
                //  and return result of unicode weight comparison.
                //
                if (uw1 != uw2)
                {
                    return ((uw1 < uw2) ? CSTR_LESS_THAN : CSTR_GREATER_THAN);
                }
            }

            //
            //  For each state in the state table, do the appropriate
            //  comparisons.
            //
            if (State & (STATE_DW | STATE_REVERSE_DW))
            {
                //
                //  Get the diacritic weights.
                //
                dw1 = GET_DIACRITIC(&Weight1);
                dw2 = GET_DIACRITIC(&Weight2);

                if (dw1 != dw2)
                {
                    //
                    //  Look ahead to see if diacritic follows a
                    //  minimum diacritic weight.  If so, get the
                    //  diacritic weight of the nonspace mark.
                    //
                    while (!AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1))
                    {
                        Wt = GET_DWORD_WEIGHT(m_pSortKey, *(pString1 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw1 += GET_DIACRITIC(&Wt);
                            pString1++;
                            ctr1--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    while (!AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2))
                    {
                        Wt = GET_DWORD_WEIGHT(m_pSortKey, *(pString2 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw2 += GET_DIACRITIC(&Wt);
                            pString2++;
                            ctr2--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    //  Save which string has the smaller diacritic
                    //  weight if the diacritic weights are still
                    //  different.
                    //
                    if (dw1 != dw2)
                    {
                        WhichDiacritic = (dw1 < dw2)
                                           ? CSTR_LESS_THAN
                                           : CSTR_GREATER_THAN;

                        //
                        //  Remove state from state machine.
                        //
                        REMOVE_STATE(STATE_DW);
                    }
                }
            }
            if (State & STATE_CW)
            {
                //
                //  Get the case weights.
                //
                if (GET_CASE(&Weight1) != GET_CASE(&Weight2))
                {
                    //
                    //  Save which string has the smaller case weight.
                    //
                    WhichCase = (GET_CASE(&Weight1) < GET_CASE(&Weight2))
                                  ? CSTR_LESS_THAN
                                  : CSTR_GREATER_THAN;

                    //
                    //  Remove state from state machine.
                    //
                    REMOVE_STATE(STATE_CW);
                }
            }
        }

        //
        //  Fixup the pointers and counters.
        //
        POINTER_FIXUP();
        ctr1--;
        ctr2--;

        //
        //  Reset the weights to be invalid.
        //
        Weight1 = CMP_INVALID_WEIGHT;
        Weight2 = CMP_INVALID_WEIGHT;
    }

    //
    //  If the end of BOTH strings has been reached, then the unicode
    //  weights match exactly.  Check the diacritic, case and special
    //  weights.  If all are zero, then return success.  Otherwise,
    //  return the result of the weight difference.
    //
    //  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
    //            Diacritic, Case, Punctuation.
    //
    if (AT_STRING_END(ctr1, pString1, cchCount1))
    {
        if (AT_STRING_END(ctr2, pString2, cchCount2))
        {
            if (WhichDiacritic)
            {
                return (WhichDiacritic);
            }
            if (WhichCase)
            {
                return (WhichCase);
            }
            if (WhichExtra)
            {
                if (!fIgnoreDiacritic)
                {
                    if (GET_WT_FOUR(&WhichExtra))
                    {
                        return (GET_WT_FOUR(&WhichExtra));
                    }
                    if (GET_WT_FIVE(&WhichExtra))
                    {
                        return (GET_WT_FIVE(&WhichExtra));
                    }
                }
                if (GET_WT_SIX(&WhichExtra))
                {
                    return (GET_WT_SIX(&WhichExtra));
                }
                if (GET_WT_SEVEN(&WhichExtra))
                {
                    return (GET_WT_SEVEN(&WhichExtra));
                }
            }
            if (WhichPunct1)
            {
                return (WhichPunct1);
            }
            if (WhichPunct2)
            {
                return (WhichPunct2);
            }

            return (CSTR_EQUAL);
        }
        else
        {
            //
            //  String 2 is longer.
            //
            pString1 = pString2;
            ctr1 = ctr2;
            cchCount1 = cchCount2;
            fEnd1 = CSTR_LESS_THAN;
        }
    }
    else
    {
        fEnd1 = CSTR_GREATER_THAN;
    }

    //
    //  Scan to the end of the longer string.
    //
    return SCAN_LONGER_STRING(
        ctr1,
        pString1,
        cchCount1,
        fEnd1,
        Weight1,
        fIgnoreDiacritic,
        WhichDiacritic,
        fIgnoreSymbol,
        WhichCase,
        WhichExtra,
        WhichPunct1,
        WhichPunct2);
}

void NativeCompareInfo::GET_FAREAST_WEIGHT(DWORD& wt, WORD& uw, DWORD mask, LPCWSTR pBegin, LPCWSTR pCur, DWORD& ExtraWt)
{
    int ct;                       /* loop counter */
    BYTE PrevSM;                  /* previous script member value */
    BYTE PrevAW;                  /* previous alphanumeric value */
    BYTE PrevCW;                  /* previous case value */
    BYTE AW;                      /* alphanumeric value */
    BYTE CW;                      /* case value */
    DWORD PrevWt;                 /* previous weight */


    /*
     *  Get the alphanumeric weight and the case weight of the
     *  current code point.
     */
    AW = GET_ALPHA_NUMERIC(&wt);
    CW = GET_CASE(&wt);
    ExtraWt = (DWORD)0;

    /*
     *  Special case Repeat and Cho-On.
     *    AW = 0  =>  Repeat
     *    AW = 1  =>  Cho-On
     *    AW = 2+ =>  Kana
     */
    if (AW <= MAX_SPECIAL_AW)
    {
        /*
         *  If the script member of the previous character is
         *  invalid, then give the special character an
         *  invalid weight (highest possible weight) so that it
         *  will sort AFTER everything else.
         */
        ct = 1;
        PrevWt = CMP_INVALID_FAREAST;
        while ((pCur - ct) >= pBegin)
        {
            PrevWt = GET_DWORD_WEIGHT(m_pSortKey, *(pCur - ct));
            PrevWt &= mask;
            PrevSM = GET_SCRIPT_MEMBER(&PrevWt);
            if (PrevSM < FAREAST_SPECIAL)
            {
                if (PrevSM == EXPANSION)
                {
                    PrevWt = CMP_INVALID_FAREAST;
                }
                else
                {
                    /*
                     *  UNSORTABLE or NONSPACE_MARK.
                     *
                     *  Just ignore these, since we only care about the
                     *  previous UW value.
                     */
                    PrevWt = CMP_INVALID_FAREAST;
                    ct++;
                    continue;
                }
            }
            else if (PrevSM == FAREAST_SPECIAL)
            {
                PrevAW = GET_ALPHA_NUMERIC(&PrevWt);
                if (PrevAW <= MAX_SPECIAL_AW)
                {
                    /*
                     *  Handle case where two special chars follow
                     *  each other.  Keep going back in the string.
                     */
                    PrevWt = CMP_INVALID_FAREAST;
                    ct++;
                    continue;
                }

                UNICODE_WT(&PrevWt) =
                    MAKE_UNICODE_WT(KANA, PrevAW);

                /*
                 *  Only build weights 4, 5, 6, and 7 if the
                 *  previous character is KANA.
                 *
                 *  Always:
                 *    4W = previous CW  &  ISOLATE_SMALL
                 *    6W = previous CW  &  ISOLATE_KANA
                 *
                 */
                PrevCW = GET_CASE(&PrevWt);
                GET_WT_FOUR(&ExtraWt) = PrevCW & ISOLATE_SMALL;
                GET_WT_SIX(&ExtraWt)  = PrevCW & ISOLATE_KANA;

                if (AW == AW_REPEAT)
                {
                    /*
                     *  Repeat:
                     *    UW = previous UW
                     *    5W = WT_FIVE_REPEAT
                     *    7W = previous CW  &  ISOLATE_WIDTH
                     */
                    uw = UNICODE_WT(&PrevWt);
                    GET_WT_FIVE(&ExtraWt)  = WT_FIVE_REPEAT;
                    GET_WT_SEVEN(&ExtraWt) = PrevCW & ISOLATE_WIDTH;
                }
                else
                {
                    /*
                     *  Cho-On:
                     *    UW = previous UW  &  CHO_ON_UW_MASK
                     *    5W = WT_FIVE_CHO_ON
                     *    7W = current  CW  &  ISOLATE_WIDTH
                     */
                    uw = UNICODE_WT(&PrevWt) & CHO_ON_UW_MASK;
                    GET_WT_FIVE(&ExtraWt)  = WT_FIVE_CHO_ON;
                    GET_WT_SEVEN(&ExtraWt) = CW & ISOLATE_WIDTH;
                }
            }
            else
            {
                uw = GET_UNICODE(&PrevWt);
            }

            break;
        }
    }
    else
    {
        /*
         *  Kana:
         *    SM = KANA
         *    AW = current AW
         *    4W = current CW  &  ISOLATE_SMALL
         *    5W = WT_FIVE_KANA
         *    6W = current CW  &  ISOLATE_KANA
         *    7W = current CW  &  ISOLATE_WIDTH
         */
        uw = MAKE_UNICODE_WT(KANA, AW);
        GET_WT_FOUR(&ExtraWt)  = CW & ISOLATE_SMALL;
        GET_WT_FIVE(&ExtraWt)  = WT_FIVE_KANA;
        GET_WT_SIX(&ExtraWt)   = CW & ISOLATE_KANA;
        GET_WT_SEVEN(&ExtraWt) = CW & ISOLATE_WIDTH;
    }

    /*
     *  Get the weight for the far east special case and store it in wt.
     */
    if ((AW > MAX_SPECIAL_AW) || (PrevWt != CMP_INVALID_FAREAST))
    {
        /*
         *  Always:
         *    DW = current DW
         *    CW = minimum CW
         */
        UNICODE_WT(&wt) = uw;
        CASE_WT(&wt) = MIN_CW;
    }
    else
    {
        uw = CMP_INVALID_UW;
        wt = CMP_INVALID_FAREAST;
        ExtraWt = 0;
    }
}

WCHAR NativeCompareInfo::GET_EXPANSION_1(LPDWORD pwt)
{
    return (m_pSortingFile->m_pExpansion[GET_EXPAND_INDEX(pwt)].UCP1);
}

WCHAR NativeCompareInfo::GET_EXPANSION_2(LPDWORD pwt)
{

    return (m_pSortingFile->m_pExpansion[GET_EXPAND_INDEX(pwt)].UCP2);
}

////////////////////////////////////////////////////////////////////////////
//
//  NLS_FREE_TMP_BUFFER
//
//  Checks to see if the buffer is the same as the static buffer.  If it
//  is NOT the same, then the buffer is freed.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_FREE_TMP_BUFFER(pBuf, pStaticBuf)                              \
{                                                                          \
    if (pBuf != pStaticBuf)                                                \
    {                                                                      \
        delete [] pBuf;                                                \
    }                                                                      \
}

#define EXTRA_WEIGHT_POS(WtNum)        (*(pPosXW + (WtNum * WeightLen)))

#define SPECIAL_CASE_HANDLER( SM,                                           \
                              pWeight,                                      \
                              pSortkey,                                     \
                              pExpand,                                      \
                              Position,                                     \
                              fStringSort,                                  \
                              fIgnoreSymbols,                               \
                              pCur,                                         \
                              pBegin)                                     \
{                                                                           \
    PSORTKEY pExpWt;              /* weight of 1 expansion char */          \
    BYTE AW;                      /* alphanumeric weight */                 \
    BYTE XW;                      /* case weight value with extra bits */   \
    DWORD PrevWt;                 /* previous weight */                     \
    BYTE PrevSM;                  /* previous script member */              \
    BYTE PrevAW;                  /* previuos alphanumeric weight */        \
    BYTE PrevCW;                  /* previuos case weight */                \
    LPWSTR pPrev;                 /* ptr to previous char */                \
                                                                            \
                                                                            \
    switch (SM)                                                             \
    {                                                                       \
        case ( UNSORTABLE ) :                                               \
        {                                                                   \
            /*                                                              \
             *  Character is unsortable, so skip it.                        \
             */                                                             \
            break;                                                          \
        }                                                                   \
                                                                            \
        case ( NONSPACE_MARK ) :                                            \
        {                                                                   \
            /*                                                              \
             *  Character is a nonspace mark, so only store                 \
             *  the diacritic weight.                                       \
             */                                                             \
            if (pPosDW > pDW)                                               \
            {                                                               \
                (*(pPosDW - 1)) += GET_DIACRITIC(pWeight);                  \
            }                                                               \
            else                                                            \
            {                                                               \
                *pPosDW = GET_DIACRITIC(pWeight);                           \
                pPosDW++;                                                   \
            }                                                               \
                                                                            \
            break;                                                          \
        }                                                                   \
                                                                            \
        case ( EXPANSION ) :                                                \
        {                                                                   \
            /*                                                              \
             *  Expansion character - one character has 2                   \
             *  different weights.  Store each weight separately.           \
             */                                                             \
            pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP1]); \
            *pPosUW = GET_UNICODE((DWORD*)pExpWt);                          \
            *pPosDW = GET_DIACRITIC(pExpWt);                                \
            *pPosCW = GET_CASE(pExpWt) & CaseMask;                          \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP2]); \
            while (GET_SCRIPT_MEMBER((DWORD*)pExpWt) == EXPANSION)                  \
            {                                                               \
                pWeight = pExpWt;                                           \
                pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP1]); \
                *pPosUW = GET_UNICODE((DWORD*)pExpWt);                 \
                *pPosDW = GET_DIACRITIC(pExpWt);                            \
                *pPosCW = GET_CASE(pExpWt) & CaseMask;                      \
                pPosUW++;                                                   \
                pPosDW++;                                                   \
                pPosCW++;                                                   \
                pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP2]); \
            }                                                               \
            *pPosUW = GET_UNICODE((DWORD*)pExpWt);                     \
            *pPosDW = GET_DIACRITIC(pExpWt);                                \
            *pPosCW = GET_CASE(pExpWt) & CaseMask;                          \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
                                                                            \
        case ( PUNCTUATION ) :                                              \
        {                                                                   \
            if (!fStringSort)                                               \
            {                                                               \
                /*                                                          \
                 *  Word Sort Method.                                       \
                 *                                                          \
                 *  Character is punctuation, so only store the special     \
                 *  weight.                                                 \
                 */                                                         \
                *((LPBYTE)pPosSW)       = HIBYTE(GET_POSITION_SW(Position)); \
                *(((LPBYTE)pPosSW) + 1) = LOBYTE(GET_POSITION_SW(Position)); \
                pPosSW++;                                                   \
                *pPosSW = GET_SPECIAL_WEIGHT(pWeight);                      \
                pPosSW++;                                                   \
                                                                            \
                break;                                                      \
            }                                                               \
                                                                            \
            /*                                                              \
             *  If using STRING sort method, treat punctuation the same     \
             *  as symbol.  So, FALL THROUGH to the symbol cases.           \
             */                                                             \
        }                                                                   \
                                                                            \
        case ( SYMBOL_1 ) :                                                 \
        case ( SYMBOL_2 ) :                                                 \
        case ( SYMBOL_3 ) :                                                 \
        case ( SYMBOL_4 ) :                                                 \
        case ( SYMBOL_5 ) :                                                 \
        {                                                                   \
            /*                                                              \
             *  Character is a symbol.                                      \
             *  Store the Unicode weights ONLY if the COMPARE_OPTIONS_IGNORESYMBOLS    \
             *  flag is NOT set.                                            \
             */                                                             \
            if (!fIgnoreSymbols)                                            \
            {                                                               \
                *pPosUW = GET_UNICODE((DWORD*)pWeight);                \
                *pPosDW = GET_DIACRITIC(pWeight);                           \
                *pPosCW = GET_CASE(pWeight) & CaseMask;                     \
                pPosUW++;                                                   \
                pPosDW++;                                                   \
                pPosCW++;                                                   \
            }                                                               \
                                                                            \
            break;                                                          \
        }                                                                   \
                                                                            \
        case ( FAREAST_SPECIAL ) :                                          \
        {                                                                   \
            /*                                                              \
             *  Get the alphanumeric weight and the case weight of the      \
             *  current code point.                                         \
             */                                                             \
            AW = GET_ALPHA_NUMERIC((DWORD*)pWeight);                                \
            XW = (GET_CASE(pWeight) & CaseMask) | CASE_XW_MASK;             \
                                                                            \
            /*                                                              \
             *  Special case Repeat and Cho-On.                             \
             *    AW = 0  =>  Repeat                                        \
             *    AW = 1  =>  Cho-On                                        \
             *    AW = 2+ =>  Kana                                          \
             */                                                             \
            if (AW <= MAX_SPECIAL_AW)                                       \
            {                                                               \
                /*                                                          \
                 *  If the script member of the previous character is       \
                 *  invalid, then give the special character an             \
                 *  invalid weight (highest possible weight) so that it     \
                 *  will sort AFTER everything else.                        \
                 */                                                         \
                pPrev = pCur - 1;                                           \
                *pPosUW = MAP_INVALID_UW;                                   \
                while (pPrev >= pBegin)                                     \
                {                                                           \
                    PrevWt = GET_DWORD_WEIGHT(m_pSortKey, *pPrev);              \
                    PrevSM = GET_SCRIPT_MEMBER(&PrevWt);                    \
                    if (PrevSM < FAREAST_SPECIAL)                           \
                    {                                                       \
                        if (PrevSM != EXPANSION)                            \
                        {                                                   \
                            /*                                              \
                             *  UNSORTABLE or NONSPACE_MARK.                \
                             *                                              \
                             *  Just ignore these, since we only care       \
                             *  about the previous UW value.                \
                             */                                             \
                            pPrev--;                                        \
                            continue;                                       \
                        }                                                   \
                    }                                                       \
                    else if (PrevSM == FAREAST_SPECIAL)                     \
                    {                                                       \
                        PrevAW = GET_ALPHA_NUMERIC(&PrevWt);                \
                        if (PrevAW <= MAX_SPECIAL_AW)                       \
                        {                                                   \
                            /*                                              \
                             *  Handle case where two special chars follow  \
                             *  each other.  Keep going back in the string. \
                             */                                             \
                            pPrev--;                                        \
                            continue;                                       \
                        }                                                   \
                                                                            \
                        *pPosUW = MAKE_UNICODE_WT(KANA, PrevAW);            \
                                                                            \
                        /*                                                  \
                         *  Only build weights 4, 5, 6, and 7 if the        \
                         *  previous character is KANA.                     \
                         *                                                  \
                         *  Always:                                         \
                         *    4W = previous CW  &  ISOLATE_SMALL            \
                         *    6W = previous CW  &  ISOLATE_KANA             \
                         *                                                  \
                         */                                                 \
                        PrevCW = (GET_CASE(&PrevWt) & CaseMask) |           \
                                 CASE_XW_MASK;                              \
                        EXTRA_WEIGHT_POS(0) = PrevCW & ISOLATE_SMALL;       \
                        EXTRA_WEIGHT_POS(2) = PrevCW & ISOLATE_KANA;        \
                                                                            \
                        if (AW == AW_REPEAT)                                \
                        {                                                   \
                            /*                                              \
                             *  Repeat:                                     \
                             *    UW = previous UW   (set above)            \
                             *    5W = WT_FIVE_REPEAT                       \
                             *    7W = previous CW  &  ISOLATE_WIDTH        \
                             */                                             \
                            EXTRA_WEIGHT_POS(1) = WT_FIVE_REPEAT;           \
                            EXTRA_WEIGHT_POS(3) = PrevCW & ISOLATE_WIDTH;   \
                        }                                                   \
                        else                                                \
                        {                                                   \
                            /*                                              \
                             *  Cho-On:                                     \
                             *    UW = previous UW  &  CHO_ON_UW_MASK       \
                             *    5W = WT_FIVE_CHO_ON                       \
                             *    7W = current  CW  &  ISOLATE_WIDTH        \
                             */                                             \
                            *pPosUW &= CHO_ON_UW_MASK;                      \
                            EXTRA_WEIGHT_POS(1) = WT_FIVE_CHO_ON;           \
                            EXTRA_WEIGHT_POS(3) = XW & ISOLATE_WIDTH;       \
                        }                                                   \
                                                                            \
                        pPosXW++;                                           \
                    }                                                       \
                    else                                                    \
                    {                                                       \
                        *pPosUW = GET_UNICODE(&PrevWt);                     \
                    }                                                       \
                                                                            \
                    break;                                                  \
                }                                                           \
                                                                            \
                /*                                                          \
                 *  Make sure there is a valid UW.  If not, quit out        \
                 *  of switch case.                                         \
                 */                                                         \
                if (*pPosUW == MAP_INVALID_UW)                              \
                {                                                           \
                    pPosUW++;                                               \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else                                                            \
            {                                                               \
                /*                                                          \
                 *  Kana:                                                   \
                 *    SM = KANA                                             \
                 *    AW = current AW                                       \
                 *    4W = current CW  &  ISOLATE_SMALL                     \
                 *    5W = WT_FIVE_KANA                                     \
                 *    6W = current CW  &  ISOLATE_KANA                      \
                 *    7W = current CW  &  ISOLATE_WIDTH                     \
                 */                                                         \
                *pPosUW = MAKE_UNICODE_WT(KANA, AW);                        \
                EXTRA_WEIGHT_POS(0) = XW & ISOLATE_SMALL;                   \
                EXTRA_WEIGHT_POS(1) = WT_FIVE_KANA;                         \
                EXTRA_WEIGHT_POS(2) = XW & ISOLATE_KANA;                    \
                EXTRA_WEIGHT_POS(3) = XW & ISOLATE_WIDTH;                   \
                                                                            \
                pPosXW++;                                                   \
            }                                                               \
                                                                            \
            /*                                                              \
             *  Always:                                                     \
             *    DW = current DW                                           \
             *    CW = minimum CW                                           \
             */                                                             \
            *pPosDW = GET_DIACRITIC(pWeight);                               \
            *pPosCW = MIN_CW;                                               \
                                                                            \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
                                                                            \
        case ( JAMO_SPECIAL ) :                                               \
            /*                                                              \
             *  See if it's a leading Jamo.                                 \
             */                                                             \
            if (IsLeadingJamo(*pPos))                                           \
            {                                                                   \
                /*                                                              \
                 * If the characters beginning from pPos is a valid old Hangul composition,             \
                 * create the sortkey according to the old Hangul rule.                                \
                 */                                                              \
                                                                                \
                int OldHangulCount;  /* Number of old Hangul found */               \
                WORD JamoUW;                                                    \
                BYTE JamoXW[3];                                                     \
                if ((OldHangulCount = (int) MapOldHangulSortKey(pPos, cchSrc - PosCtr, &JamoUW, JamoXW)) > 0)                \
                {                                                                   \
                    *pPosUW = JamoUW;                                               \
                    pPosUW++;                                                   \
                                                                                \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[0]);  \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[1]);  \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[2]);  \
                    pPosUW++;                                               \
                                                                            \
                    *pPosDW = MIN_DW;                                       \
                    *pPosCW = MIN_CW;                                       \
                    pPosDW++;                                               \
                    pPosCW++;                                               \
                                                                                    \
                    OldHangulCount--;   /* Cause for loop will increase PosCtr/pPos as well*/   \
                    PosCtr += OldHangulCount;                                         \
                    pPos += OldHangulCount;                                                 \
                    break;                                                   \
                }                                                               \
            }                                                                   \
            /*                                                                  \
             * Otherwise, fall back to the normal behavior.                         \
             *                                                                  \
             *                                                                  \
             *  No special case on character, so store the                          \
             *  various weights for the character.                                  \
             */                                                                 \
                                                                                            \
            /* We store the real script member in the case weight. Since diacritic                 \
             * weight is not used in Korean.                                                \
             */                                                                 \
            *pPosUW = MAKE_UNICODE_WT(GET_DIACRITIC(pWeight), GET_ALPHA_NUMERIC((DWORD*)pWeight));             \
            *pPosDW = MIN_DW;                                               \
            *pPosCW = GET_CASE(pWeight);                                               \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
            break;                                                          \
        case ( EXTENSION_A ) :                                              \
        {                                                                   \
            /*                                                              \
             *  UW = SM_EXT_A, AW_EXT_A, AW, DW                             \
             *  DW = miniumum DW                                            \
             *  CW = minimum CW                                             \
             */                                                             \
            *pPosUW = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A);       \
            pPosUW++;                                                       \
                                                                            \
            *pPosUW = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC((DWORD*)pWeight),          \
                                       GET_DIACRITIC(pWeight));             \
            pPosUW++;                                                       \
                                                                            \
            *pPosDW = MIN_DW;                                               \
            *pPosCW = MIN_CW;                                               \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
    }                                                                       \
}


////////////////////////////////////////////////////////////////////////////
//
//  MapSortKey
//
//  Stores the sortkey weights for the given string in the destination
//  buffer and returns the number of BYTES written to the buffer.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int NativeCompareInfo::MapSortKey(
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPBYTE pDest,
    int cbDest)
{
    register int WeightLen;       // length of one set of weights
    LPWSTR pUW;                   // ptr to Unicode Weights
    LPBYTE pDW;                   // ptr to Diacritic Weights
    LPBYTE pCW;                   // ptr to Case Weights
    LPBYTE pXW;                   // ptr to Extra Weights
    LPWSTR pSW;                   // ptr to Special Weights
    LPWSTR pPosUW;                // ptr to position in pUW buffer
    LPBYTE pPosDW;                // ptr to position in pDW buffer
    LPBYTE pPosCW;                // ptr to position in pCW buffer
    LPBYTE pPosXW;                // ptr to position in pXW buffer
    LPWSTR pPosSW;                // ptr to position in pSW buffer
    PSORTKEY pWeight;             // ptr to weight of character
    BYTE SM;                      // script member value
    BYTE CaseMask;                // mask for case weight
    int PosCtr;                   // position counter in string
    LPWSTR pPos;                  // ptr to position in string
    LPBYTE pTmp;                  // ptr to go through UW, XW, and SW
    LPBYTE pPosTmp;               // ptr to tmp position in XW
    PCOMPRESS_2 pComp2;           // ptr to compression 2 list
    PCOMPRESS_3 pComp3;           // ptr to compression 3 list
    WORD pBuffer[MAX_SKEYBUFLEN]; // buffer to hold weights
    int ctr;                      // loop counter
    BOOL IfDblCompress;           // if double compress possibility
    BOOL fStringSort;             // if using string sort method
    BOOL fIgnoreSymbols;          // if ignore symbols flag is set

    THROWSCOMPLUSEXCEPTION();

    //
    //  See if the length of the string is too large for the static
    //  buffer.  If so, allocate a buffer that is large enough.
    //
    if (cchSrc > MAX_STRING_LEN)
    {
        //
        //  Allocate buffer to hold all of the weights.
        //     (cchSrc) * (max # of expansions) * (# of weights)
        //
        WeightLen = cchSrc * MAX_EXPANSION;
        if ((pUW = new WCHAR[WeightLen * MAX_WEIGHTS]) == NULL)
        {
            COMPlusThrowOM();
            return (0);
        }
    }
    else
    {
        WeightLen = MAX_STRING_LEN * MAX_EXPANSION;
        pUW = (LPWSTR)pBuffer;
    }

    //
    //  Set the case weight mask based on the given flags.
    //  If none or all of the ignore case flags are set, then
    //  just leave the mask as 0xff.
    //
    CaseMask = 0xff;
    switch (dwFlags & COMPARE_OPTIONS_ALL_CASE)
    {
        case ( COMPARE_OPTIONS_IGNORECASE ) :
        {
            CaseMask &= CASE_UPPER_MASK;
            break;
        }
        case ( COMPARE_OPTIONS_IGNOREKANATYPE ) :
        {
            CaseMask &= CASE_KANA_MASK;
            break;
        }
        case ( COMPARE_OPTIONS_IGNOREWIDTH ) :
        {
            CaseMask &= CASE_WIDTH_MASK;
            break;
        }
        case ( COMPARE_OPTIONS_IGNORECASE | COMPARE_OPTIONS_IGNOREKANATYPE ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_KANA_MASK);
            break;
        }
        case ( COMPARE_OPTIONS_IGNORECASE | COMPARE_OPTIONS_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_WIDTH_MASK);
            break;
        }
        case ( COMPARE_OPTIONS_IGNOREKANATYPE | COMPARE_OPTIONS_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_KANA_MASK & CASE_WIDTH_MASK);
            break;
        }
        case ( COMPARE_OPTIONS_IGNORECASE | COMPARE_OPTIONS_IGNOREKANATYPE | COMPARE_OPTIONS_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_KANA_MASK & CASE_WIDTH_MASK);
            break;
        }
    }

    //
    //  Set pointers to positions of weights in buffer.
    //
    //      UW  =>  4 word length  (extension A and Jamo need extra words)
    //      DW  =>  byte   length
    //      CW  =>  byte   length
    //      XW  =>  4 byte length  (4 weights, 1 byte each)   FE Special
    //      SW  =>  dword  length  (2 words each)
    //
    //  Note: SW must start on a WORD boundary, so XW needs to be padded
    //        appropriately.
    //
    pDW = (LPBYTE)(pUW + (WeightLen * (NUM_BYTES_UW / sizeof(WCHAR))));
    pCW = (LPBYTE)(pDW + (WeightLen * NUM_BYTES_DW));
    pXW = (LPBYTE)(pCW + (WeightLen * NUM_BYTES_CW));
    pSW     = (LPWSTR)(pXW + (WeightLen * (NUM_BYTES_XW + NUM_BYTES_PADDING)));
    pPosUW = pUW;
    pPosDW = pDW;
    pPosCW = pCW;
    pPosXW = pXW;
    pPosSW = pSW;

    //
    //  Initialize flags and loop values.
    //
    fStringSort = dwFlags & COMPARE_OPTIONS_STRINGSORT;
    fIgnoreSymbols = dwFlags & COMPARE_OPTIONS_IGNORESYMBOLS;
    pPos = (LPWSTR)pSrc;
    PosCtr = 1;

    //
    //  Check if given locale has compressions.
    //
    if (m_IfCompression == FALSE)
    {
        //
        //  Go through string, code point by code point.
        //
        //  No compressions exist in the given locale, so
        //  DO NOT check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &(m_pSortKey[*pPos]);
            SM = GET_SCRIPT_MEMBER((DWORD*)pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, so store the
                //  various weights for the character.
                //
                *pPosUW = GET_UNICODE((DWORD*)pWeight);
                *pPosDW = GET_DIACRITIC(pWeight);
                *pPosCW = GET_CASE(pWeight) & CaseMask;
                pPosUW++;
                pPosDW++;
                pPosCW++;
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      m_pSortKey,
                                      m_pSortingFile->m_pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc
                                      );
            }
        }
    }
    else if (m_IfDblCompression == FALSE)
    {
        //
        //  Go through string, code point by code point.
        //
        //  Compressions DO exist in the given locale, so
        //  check for them.
        //
        //  No double compressions exist in the given locale,
        //  so DO NOT check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &(m_pSortKey[*pPos]);
            SM = GET_SCRIPT_MEMBER((DWORD*)pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, but must check for
                //  compression characters.
                //
                switch (GET_COMPRESSION(pWeight))
                {
                    case ( COMPRESS_3_MASK ) :
                    {
                        if ((PosCtr + 2) <= cchSrc)
                        {
                            ctr = m_pCompHdr->Num3;
                            pComp3 = m_pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                if ((pComp3->UCP1 == *pPos) &&
                                    (pComp3->UCP2 == *(pPos + 1)) &&
                                    (pComp3->UCP3 == *(pPos + 2)))
                                {
                                    pWeight = &(pComp3->Weights);
                                    *pPosUW = GET_UNICODE((DWORD*)pWeight);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only two to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos += 2;
                                    PosCtr += 2;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }

                    case ( COMPRESS_2_MASK ) :
                    {
                        if ((PosCtr + 1) <= cchSrc)
                        {
                            ctr = m_pCompHdr->Num2;
                            pComp2 = m_pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                if ((pComp2->UCP1 == *pPos) &&
                                    (pComp2->UCP2 == *(pPos + 1)))
                                {
                                    pWeight = &(pComp2->Weights);
                                    *pPosUW = GET_UNICODE((DWORD*)pWeight);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only one to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos++;
                                    PosCtr++;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }

                    default :
                    {
                        //
                        //  No possible compression for character, so store
                        //  the various weights for the character.
                        //
                        *pPosUW = GET_UNICODE((DWORD*)pWeight);
                        *pPosDW = GET_DIACRITIC(pWeight);
                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                        pPosUW++;
                        pPosDW++;
                        pPosCW++;
                    }
                }
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      m_pSortKey,
                                      m_pSortingFile->m_pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc);
            }
        }
    }
    else
    {
        //
        //  Go through string, code point by code point.
        //
        //  Compressions DO exist in the given locale, so
        //  check for them.
        //
        //  Double Compressions also exist in the given locale,
        //  so check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &(m_pSortKey[*pPos]);
            SM = GET_SCRIPT_MEMBER((DWORD*)pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, but must check for
                //  compression characters and double compression
                //  characters.
                //
                IfDblCompress =
                  (((PosCtr + 1) <= cchSrc) &&
                   ((GET_DWORD_WEIGHT(m_pSortKey, *pPos) & CMP_MASKOFF_CW) ==
                    (GET_DWORD_WEIGHT(m_pSortKey, *(pPos + 1)) & CMP_MASKOFF_CW)))
                   ? 1
                   : 0;

                switch (GET_COMPRESSION(pWeight))
                {
                    case ( COMPRESS_3_MASK ) :
                    {
                        if (IfDblCompress)
                        {
                            if ((PosCtr + 3) <= cchSrc)
                            {
                                ctr = m_pCompHdr->Num3;
                                pComp3 = m_pCompress3;
                                for (; ctr > 0; ctr--, pComp3++)
                                {
                                    if ((pComp3->UCP1 == *(pPos + 1)) &&
                                        (pComp3->UCP2 == *(pPos + 2)) &&
                                        (pComp3->UCP3 == *(pPos + 3)))
                                    {
                                        pWeight = &(pComp3->Weights);
                                        *pPosUW = GET_UNICODE((DWORD*)pWeight);
                                        *pPosDW = GET_DIACRITIC(pWeight);
                                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                                        *(pPosUW + 1) = *pPosUW;
                                        *(pPosDW + 1) = *pPosDW;
                                        *(pPosCW + 1) = *pPosCW;
                                        pPosUW += 2;
                                        pPosDW += 2;
                                        pPosCW += 2;

                                        //
                                        //  Add only three to source, since one
                                        //  will be added by "for" structure.
                                        //
                                        pPos += 3;
                                        PosCtr += 3;
                                        break;
                                    }
                                }
                                if (ctr > 0)
                                {
                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((PosCtr + 2) <= cchSrc)
                        {
                            ctr = m_pCompHdr->Num3;
                            pComp3 = m_pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                if ((pComp3->UCP1 == *pPos) &&
                                    (pComp3->UCP2 == *(pPos + 1)) &&
                                    (pComp3->UCP3 == *(pPos + 2)))
                                {
                                    pWeight = &(pComp3->Weights);
                                    *pPosUW = GET_UNICODE((DWORD*)pWeight);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only two to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos += 2;
                                    PosCtr += 2;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                        //
                        //  Fall through if not found.
                        //
                    }

                    case ( COMPRESS_2_MASK ) :
                    {
                        if (IfDblCompress)
                        {
                            if ((PosCtr + 2) <= cchSrc)
                            {
                                ctr = m_pCompHdr->Num2;
                                pComp2 = m_pCompress2;
                                for (; ctr > 0; ctr--, pComp2++)
                                {
                                    if ((pComp2->UCP1 == *(pPos + 1)) &&
                                        (pComp2->UCP2 == *(pPos + 2)))
                                    {
                                        pWeight = &(pComp2->Weights);
                                        *pPosUW = GET_UNICODE((DWORD*)pWeight);
                                        *pPosDW = GET_DIACRITIC(pWeight);
                                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                                        *(pPosUW + 1) = *pPosUW;
                                        *(pPosDW + 1) = *pPosDW;
                                        *(pPosCW + 1) = *pPosCW;
                                        pPosUW += 2;
                                        pPosDW += 2;
                                        pPosCW += 2;

                                        //
                                        //  Add only two to source, since one
                                        //  will be added by "for" structure.
                                        //
                                        pPos += 2;
                                        PosCtr += 2;
                                        break;
                                    }
                                }
                                if (ctr > 0)
                                {
                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((PosCtr + 1) <= cchSrc)
                        {
                            ctr = m_pCompHdr->Num2;
                            pComp2 = m_pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                if ((pComp2->UCP1 == *pPos) &&
                                    (pComp2->UCP2 == *(pPos + 1)))
                                {
                                    pWeight = &(pComp2->Weights);
                                    *pPosUW = GET_UNICODE((DWORD*)pWeight);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only one to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos++;
                                    PosCtr++;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }

                    default :
                    {
                        //
                        //  No possible compression for character, so store
                        //  the various weights for the character.
                        //
                        *pPosUW = GET_UNICODE((DWORD*)pWeight);
                        *pPosDW = GET_DIACRITIC(pWeight);
                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                        pPosUW++;
                        pPosDW++;
                        pPosCW++;
                    }
                }
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      m_pSortKey,
                                      m_pSortingFile->m_pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc);
            }
        }
    }

    //
    //  Store the final sortkey weights in the destination buffer.
    //
    //  PosCtr will be a BYTE count.
    //
    PosCtr = 0;

    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cbDest == 0)
    {
        //
        //  Count the Unicode Weights.
        //
        PosCtr += (int)((LPBYTE)pPosUW - (LPBYTE)pUW);

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Diacritic Weights.
        //
        //    - Eliminate minimum DW.
        //    - Count the number of diacritic weights.
        //
        if (!(dwFlags & COMPARE_OPTIONS_IGNORENONSPACE))
        {
            pPosDW--;
            if (m_IfReverseDW == TRUE)
            {
                //
                //  Reverse diacritics:
                //    - remove diacritics from left  to right.
                //    - count  diacritics from right to left.
                //
                while ((pDW <= pPosDW) && (*pDW <= MIN_DW))
                {
                    pDW++;
                }
                PosCtr += (int)(pPosDW - pDW + 1);
            }
            else
            {
                //
                //  Regular diacritics:
                //    - remove diacritics from right to left.
                //    - count  diacritics from left  to right.
                //
                while ((pPosDW >= pDW) && (*pPosDW <= MIN_DW))
                {
                    pPosDW--;
                }
                PosCtr += (int)(pPosDW - pDW + 1);
            }
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Case Weights.
        //
        //    - Eliminate minimum CW.
        //    - Count the number of case weights.
        //
        if ((dwFlags & COMPARE_OPTIONS_DROP_CW) != COMPARE_OPTIONS_DROP_CW)
        {
            pPosCW--;
            while ((pPosCW >= pCW) && (*pPosCW <= MIN_CW))
            {
                pPosCW--;
            }
            PosCtr += (int)(pPosCW - pCW + 1);
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Extra Weights for Far East Special.
        //
        //    - Eliminate unnecessary XW.
        //    - Count the number of extra weights and separators.
        //
        if (pXW < pPosXW)
        {
            if (dwFlags & NORM_IGNORENONSPACE)
            {
                //
                //  Ignore 4W and 5W.  Must count separators for
                //  4W and 5W, though.
                //
                PosCtr += 2;
                ctr = 2;
            }
            else
            {
                ctr = 0;
            }
            pPosXW--;
            for (; ctr < NUM_BYTES_XW; ctr++)
            {
                pTmp = pXW + (WeightLen * ctr);
                pPosTmp = pPosXW + (WeightLen * ctr);
                while ((pPosTmp >= pTmp) && (*pPosTmp == pXWDrop[ctr]))
                {
                    pPosTmp--;
                }                    
                PosCtr += (int)(pPosTmp - pTmp + 1);
                //
                //  Count the Separator.
                //
                PosCtr++;
            }
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Special Weights.
        //
        if (!fIgnoreSymbols)
        {
            PosCtr += (int)((LPBYTE)pPosSW - (LPBYTE)pSW);
        }

        //
        //  Count the Terminator.
        //
        PosCtr++;
    }
    else
    {
        //
        //  Store the Unicode Weights in the destination buffer.
        //
        //    - Make sure destination buffer is large enough.
        //    - Copy unicode weights to destination buffer.
        //
        //  NOTE:  cbDest is the number of BYTES.
        //         Also, must add one to length for separator.
        //
        if (cbDest < (((LPBYTE)pPosUW - (LPBYTE)pUW) + 1))
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            return (0);
        }
        pTmp = (LPBYTE)pUW;
        while (pTmp < (LPBYTE)pPosUW)
        {
            //
            //  Copy Unicode weight to destination buffer.
            //
            //  NOTE:  Unicode Weight is stored in the data file as
            //             Alphanumeric Weight, Script Member
            //         so that the WORD value will be read correctly.
            //
            pDest[PosCtr]     = *(pTmp + 1);
            pDest[PosCtr + 1] = *pTmp;
            PosCtr += 2;
            pTmp += 2;
        }

        //
        //  Copy Separator to destination buffer.
        //
        //  Destination buffer is large enough to hold the separator,
        //  since it was checked with the Unicode weights above.
        //
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Diacritic Weights in the destination buffer.
        //
        //    - Eliminate minimum DW.
        //    - Make sure destination buffer is large enough.
        //    - Copy diacritic weights to destination buffer.
        //
        if (!(dwFlags & COMPARE_OPTIONS_IGNORENONSPACE))
        {
            pPosDW--;
            if (m_IfReverseDW == TRUE)
            {
                //
                //  Reverse diacritics:
                //    - remove diacritics from left  to right.
                //    - store  diacritics from right to left.
                //
                while ((pDW <= pPosDW) && (*pDW <= MIN_DW))
                {
                    pDW++;
                }
                if ((cbDest - PosCtr) <= (pPosDW - pDW + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    return (0);
                }
                while (pPosDW >= pDW)
                {
                    pDest[PosCtr] = *pPosDW;
                    PosCtr++;
                    pPosDW--;
                }
            }
            else
            {
                //
                //  Regular diacritics:
                //    - remove diacritics from right to left.
                //    - store  diacritics from left  to right.
                //
                while ((pPosDW >= pDW) && (*pPosDW <= MIN_DW))
                {
                    pPosDW--;
                }
                if ((cbDest - PosCtr) <= (pPosDW - pDW + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    return (0);
                }
                while (pDW <= pPosDW)
                {
                    pDest[PosCtr] = *pDW;
                    PosCtr++;
                    pDW++;
                }
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Case Weights in the destination buffer.
        //
        //    - Eliminate minimum CW.
        //    - Make sure destination buffer is large enough.
        //    - Copy case weights to destination buffer.
        //
        if ((dwFlags & COMPARE_OPTIONS_DROP_CW) != COMPARE_OPTIONS_DROP_CW)
        {
            pPosCW--;
            while ((pPosCW >= pCW) && (*pPosCW <= MIN_CW))
            {
                pPosCW--;
            }
            if ((cbDest - PosCtr) <= (pPosCW - pCW + 1))
            {
                NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                return (0);
            }
            while (pCW <= pPosCW)
            {
                pDest[PosCtr] = *pCW;
                PosCtr++;
                pCW++;
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Extra Weights in the destination buffer for
        //  Far East Special.
        //
        //    - Eliminate unnecessary XW.
        //    - Make sure destination buffer is large enough.
        //    - Copy extra weights to destination buffer.
        //
        if (pXW < pPosXW)
        {
            if (dwFlags & NORM_IGNORENONSPACE)
            {
                //
                //  Extra weight for Fareast Special Weight:
                //  Ignore 4W and 5W.  Must count separators for
                //  4W and 5W, though.
                //
                if ((cbDest - PosCtr) <= 2)
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    return (0);
                }

                pDest[PosCtr] = pXWSeparator[0];
                pDest[PosCtr + 1] = pXWSeparator[1];
                PosCtr += 2;
                ctr = 2;
            }
            else
            {
                ctr = 0;
            }
            pPosXW--;
            for (; ctr < NUM_BYTES_XW; ctr++)
            {
                pTmp = pXW + (WeightLen * ctr);
                pPosTmp = pPosXW + (WeightLen * ctr);
                while ((pPosTmp >= pTmp) && (*pPosTmp == pXWDrop[ctr]))
                {
                    pPosTmp--;
                }
                if ((cbDest - PosCtr) <= (pPosTmp - pTmp + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    return (0);
                }
                while (pTmp <= pPosTmp)
                {
                    pDest[PosCtr] = *pTmp;
                    PosCtr++;
                    pTmp++;
                }

                //
                //  Copy Separator to destination buffer.
                //
                pDest[PosCtr] = pXWSeparator[ctr];
                PosCtr++;
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Special Weights in the destination buffer.
        //
        //    - Make sure destination buffer is large enough.
        //    - Copy special weights to destination buffer.
        //
        if (!fIgnoreSymbols)
        {
            if ((cbDest - PosCtr) <= (((LPBYTE)pPosSW - (LPBYTE)pSW)))
            {
                NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                return (0);
            }
            pTmp = (LPBYTE)pSW;
            while (pTmp < (LPBYTE)pPosSW)
            {
                pDest[PosCtr]     = *pTmp;
                pDest[PosCtr + 1] = *(pTmp + 1);

                //
                //  NOTE:  Special Weight is stored in the data file as
                //             Weight, Script
                //         so that the WORD value will be read correctly.
                //
                pDest[PosCtr + 2] = *(pTmp + 3);
                pDest[PosCtr + 3] = *(pTmp + 2);

                PosCtr += 4;
                pTmp += 4;
            }
        }

        //
        //  Copy Terminator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_TERMINATOR;
        PosCtr++;
    }

    //
    //  Free the buffer used for the weights, if one was allocated.
    //
    NLS_FREE_TMP_BUFFER(pUW, pBuffer);

    //
    //  Return number of BYTES written to destination buffer.
    //
    return (PosCtr);
}

void NativeCompareInfo::GetCompressionWeight(
    DWORD Mask,                   // mask for weights
    PSORTKEY pSortkey1, LPCWSTR& pString1, LPCWSTR pString1End,
    PSORTKEY pSortkey2, LPCWSTR& pString2, LPCWSTR pString2End) {
    
    DWORD Weight1 = *((LPDWORD)pSortkey1);
    DWORD Weight2 = *((LPDWORD)pSortkey2);
    
    int ctr;                   // loop counter
    PCOMPRESS_3 pComp3;        // ptr to compress 3 table
    PCOMPRESS_2 pComp2;        // ptr to compress 2 table
    int If1;                   // if compression found in string 1
    int If2;                   // if compression found in string 2
    int CompVal;               // compression value
    int IfEnd1;                // if exists 1 more char in string 1
    int IfEnd2;                // if exists 1 more char in string 2

    BOOL IfDblCompress1;          // if double compression in string 1
    BOOL IfDblCompress2;          // if double compression in string 2

    //
    //  Check for compression in the weights.
    //
    If1 = GET_COMPRESSION(&Weight1);
    If2 = GET_COMPRESSION(&Weight2);
    CompVal = ((If1 > If2) ? If1 : If2);

    //IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
    IfEnd1 = pString1 + 1 > pString1End;
    //IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);
    IfEnd2 = pString2 + 1 > pString2End;
    
    if (m_IfDblCompression == FALSE)
    {
        //
        //  NO double compression, so don't check for it.
        //
        switch (CompVal)
        {
            //
            //  Check for 3 characters compressing to 1.
            //
            case ( COMPRESS_3_MASK ) :
            {
                //
                //  Check character in string 1 and string 2.
                //
                if ( ((If1) && (!IfEnd1) &&
                      //!AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1)) ||
                      !(pString1 + 2 > pString1End)) ||
                     ((If2) && (!IfEnd2) &&
                      //!AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2)) )
                      !(pString2 + 2 > pString2End)) )
                {
                    ctr = m_pCompHdr->Num3;
                    pComp3 = m_pCompress3;
                    for (; ctr > 0; ctr--, pComp3++)
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ( (If1) && (!IfEnd1) &&
                             //!AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) &&
                             !(pString1 + 2 > pString1End) &&
                             (pComp3->UCP1 == *pString1) &&
                             (pComp3->UCP2 == *(pString1 + 1)) &&
                             (pComp3->UCP3 == *(pString1 + 2)) )
                        {
                            //
                            //  Found compression for string 1.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                            Weight1 &= Mask;
                            pString1 += 2;
                            //ctr1 -= 2;

                            //
                            //  Set boolean for string 1 - search is
                            //  complete.
                            //
                            If1 = 0;

                            //
                            //  Break out of loop if both searches are
                            //  done.
                            //
                            if (If2 == 0)
                                break;
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ( (If2) && (!IfEnd2) &&
                             //!AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) &&
                             !(pString2 + 2 > pString2End) &&
                             (pComp3->UCP1 == *pString2) &&
                             (pComp3->UCP2 == *(pString2 + 1)) &&
                             (pComp3->UCP3 == *(pString2 + 2)) )
                        {
                            //
                            //  Found compression for string 2.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                            Weight2 &= Mask;
                            pString2 += 2;
                            //ctr2 -= 2;

                            //
                            //  Set boolean for string 2 - search is
                            //  complete.
                            //
                            If2 = 0;

                            //
                            //  Break out of loop if both searches are
                            //  done.
                            //
                            if (If1 == 0)
                            {
                                break;
                            }
                        }
                    }
                    if (ctr > 0)
                    {
                        break;
                    }
                }
                //
                //  Fall through if not found.
                //
            }

            //
            //  Check for 2 characters compressing to 1.
            //
            case ( COMPRESS_2_MASK ) :
            {
                //
                //  Check character in string 1 and string 2.
                //
                if ( ((If1) && (!IfEnd1)) ||
                     ((If2) && (!IfEnd2)) )
                {
                    ctr = m_pCompHdr->Num2;
                    pComp2 = m_pCompress2;
                    for (; ((ctr > 0) && (If1 || If2)); ctr--, pComp2++)
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ( (If1) &&
                             (!IfEnd1) &&
                             (pComp2->UCP1 == *pString1) &&
                             (pComp2->UCP2 == *(pString1 + 1)) )
                        {
                            //
                            //  Found compression for string 1.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                            Weight1 &= Mask;
                            pString1++;

                            //
                            //  Set boolean for string 1 - search is
                            //  complete.
                            //
                            If1 = 0;

                            //
                            //  Break out of loop if both searches are
                            //  done.
                            //
                            if (If2 == 0)
                           {
                                break;
                           }
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ( (If2) &&
                             (!IfEnd2) &&
                             (pComp2->UCP1 == *pString2) &&
                             (pComp2->UCP2 == *(pString2 + 1)) )
                        {
                            //
                            //  Found compression for string 2.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                            Weight2 &= Mask;
                            pString2++;

                            //
                            //  Set boolean for string 2 - search is
                            //  complete.
                            //
                            If2 = 0;

                            //
                            //  Break out of loop if both searches are
                            //  done.
                            //
                            if (If1 == 0)
                            {
                                break;
                            }
                        }
                    }
                    if (ctr > 0)
                    {
                        break;
                    }
                }
            }
        }
    } else if (!IfEnd1 && !IfEnd2)
    {
        //
        //  Double Compression exists, so must check for it.
        //  The next two characters are compression 
        //
        if (IfDblCompress1 =
               ((GET_DWORD_WEIGHT(m_pSortKey, *pString1) & CMP_MASKOFF_CW) ==
                (GET_DWORD_WEIGHT(m_pSortKey, *(pString1 + 1)) & CMP_MASKOFF_CW)))
        {
            //
            //  Advance past the first code point to get to the
            //  compression character.
            //
            pString1++;
            ///IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
            IfEnd1 = pString1 + 1 > pString1End;
        }

        if (IfDblCompress2 =
               ((GET_DWORD_WEIGHT(m_pSortKey, *pString2) & CMP_MASKOFF_CW) ==
                (GET_DWORD_WEIGHT(m_pSortKey, *(pString2 + 1)) & CMP_MASKOFF_CW)))
        {
            //
            //  Advance past the first code point to get to the
            //  compression character.
            //
            pString2++;
            ///IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);
            IfEnd2 = pString2 + 1 > pString2End;
        }

        switch (CompVal)
        {
            //
            //  Check for 3 characters compressing to 1.
            //
            case ( COMPRESS_3_MASK ) :
            {
                //
                //  Check character in string 1.
                //
                if ( (If1) && (!IfEnd1) &&
                     ///!AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) )
                     !(pString1 + 2 > pString1End) )
                {
                    ctr = m_pCompHdr->Num3;
                    pComp3 = m_pCompress3;
                    for (; ctr > 0; ctr--, pComp3++)
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ( (pComp3->UCP1 == *pString1) &&
                             (pComp3->UCP2 == *(pString1 + 1)) &&
                             (pComp3->UCP3 == *(pString1 + 2)) )
                        {
                            //
                            //  Found compression for string 1.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                            Weight1 &= Mask;
                            if (!IfDblCompress1)
                            {
                                pString1 += 2;
                                ///ctr1 -= 2;
                            }

                            //
                            //  Set boolean for string 1 - search is
                            //  complete.
                            //
                            If1 = 0;
                            break;
                        }
                    }
                }

                //
                //  Check character in string 2.
                //
                if ( (If2) && (!IfEnd2) &&
                     ///!AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) )
                     !(pString2 + 2 > pString2End) )
                {
                    ctr = m_pCompHdr->Num3;
                    pComp3 = m_pCompress3;
                    for (; ctr > 0; ctr--, pComp3++)
                    {
                        //
                        //  Check character in string 2.
                        //
                        if ( (pComp3->UCP1 == *pString2) &&
                             (pComp3->UCP2 == *(pString2 + 1)) &&
                             (pComp3->UCP3 == *(pString2 + 2)) )
                        {
                            //
                            //  Found compression for string 2.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                            Weight2 &= Mask;
                            if (!IfDblCompress2)
                            {
                                pString2 += 2;
                                ///ctr2 -= 2;
                            }

                            //
                            //  Set boolean for string 2 - search is
                            //  complete.
                            //
                            If2 = 0;
                            break;
                        }
                    }
                }

                //
                //  Fall through if not found.
                //
                if ((If1 == 0) && (If2 == 0))
                {
                    break;
                }
            }

            //
            //  Check for 2 characters compressing to 1.
            //
            case ( COMPRESS_2_MASK ) :
            {
                //
                //  Check character in string 1.
                //
                if ((If1) && (!IfEnd1))
                {
                    ctr = m_pCompHdr->Num2;
                    pComp2 = m_pCompress2;
                    for (; ctr > 0; ctr--, pComp2++)
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ((pComp2->UCP1 == *pString1) &&
                            (pComp2->UCP2 == *(pString1 + 1)))
                        {
                            //
                            //  Found compression for string 1.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                            Weight1 &= Mask;
                            if (!IfDblCompress1)
                            {
                                pString1++;
                                ///ctr1--;
                            }

                            //
                            //  Set boolean for string 1 - search is
                            //  complete.
                            //
                            If1 = 0;
                            break;
                        }
                    }
                }

                //
                //  Check character in string 2.
                //
                if ((If2) && (!IfEnd2))
                {
                    ctr = m_pCompHdr->Num2;
                    pComp2 = m_pCompress2;
                    for (; ctr > 0; ctr--, pComp2++)
                    {
                        //
                        //  Check character in string 2.
                        //
                        if ((pComp2->UCP1 == *pString2) &&
                            (pComp2->UCP2 == *(pString2 + 1)))
                        {
                            //
                            //  Found compression for string 2.
                            //  Get new weight and mask it.
                            //  Increment pointer and decrement counter.
                            //
                            Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                            Weight2 &= Mask;
                            if (!IfDblCompress2)
                            {
                                pString2++;
                                //ctr2--;
                            }

                            //
                            //  Set boolean for string 2 - search is
                            //  complete.
                            //
                            If2 = 0;
                            break;
                        }
                    }
                }
            }
        }

        //
        //  Reset the pointer back to the beginning of the double
        //  compression.  Pointer fixup at the end will advance
        //  them correctly.
        //
        //  If double compression, we advanced the pointer at
        //  the beginning of the switch statement.  If double
        //  compression character was actually found, the pointer
        //  was NOT advanced.  We now want to decrement the pointer
        //  to put it back to where it was.
        //
        //  The next time through, the pointer will be pointing to
        //  the regular compression part of the string.
        //
        if (IfDblCompress1)
        {
            pString1--;
            ///ctr1++;
        }
        if (IfDblCompress2)
        {
            pString2--;
            ///ctr2++;
        }
    }    

    Weight1 &= Mask;
    Weight2 &= Mask;
    
    *pSortkey1 = *((PSORTKEY)&Weight1);
    *pSortkey2 = *((PSORTKEY)&Weight2);
}

/*============================IndexOfString============================
**Action: The native implementation for CompareInfo.IndexOf().
**Returns: 
**  The starting index of the match.
**Arguments:
**  pString1    The source string
**  pString2    The target string
**  OUT matchEndIndex   The end index of the string1 which matches pString2.
**Exceptions: OutOfMemoryException if we run out of memory.
** 
**NOTE NOTE: This is a synchronized operation.  The required synchronization is
**           provided by the fact that we only call this in the class initializer
**           for CompareInfo.  If this invariant ever changes, guarantee 
**           synchronization.
==============================================================================*/

int NativeCompareInfo::IndexOfString(
    LPCWSTR pString1, LPCWSTR pString2, int nStartIndex, int nEndIndex, int nLength2, DWORD dwFlags, BOOL bMatchFirstCharOnly) {
    // Make sure that we call InitSortingData() after ctor.
    _ASSERTE(m_pSortKey != NULL);
    DWORD dwMask = CMP_MASKOFF_NONE;       // Mask used to mask off sortkey for characters so that we can ignore diacritic/case/width/kana type.

    BOOL fIgnoreNonSpace     = FALSE;    // Flag to indicate if we should ignore diacritic characters and nonspace characters.
    BOOL fIgnoreSymbols     = FALSE;    // Flag to indicate if we should ignore symbols.

    // Set up dwMask and other flags according to the dwFlags
    if (dwFlags != 0) {
        if (dwFlags & INDEXOF_MASKOFF_VALIDFLAGS) {
            return (INDEXOF_INVALID_FLAGS);
        }

        fIgnoreSymbols = (dwFlags & COMPARE_OPTIONS_IGNORESYMBOLS);

        if (dwFlags & COMPARE_OPTIONS_IGNORECASE) {
            dwMask &= CMP_MASKOFF_CW;
        }

        if (fIgnoreNonSpace = (dwFlags & COMPARE_OPTIONS_IGNORENONSPACE)) {
            // Note that we have to ignore two types of diacritic:
            // 1. Diacritic characters: like U+00C0 "LATIN CAPITAL LETTER A WITH GRAVE".
            // 2. base character/diacritic character + combining charcters: like U+0041 + U+0300 "COMBINING GRAVE ACCENT".
            dwMask &= CMP_MASKOFF_DW;
            // We use this flag to trace the second type of diacritic.
        }
        if (dwFlags & COMPARE_OPTIONS_IGNOREWIDTH) {
            dwMask &= CMP_MASKOFF_WIDTH;
        }
        if (dwFlags & COMPARE_OPTIONS_IGNOREKANATYPE) {
            dwMask &= CMP_MASKOFF_KANA;
        }
    }

    LPCWSTR pSave1 = NULL;                         // Used to save the pointer in the original pString1 when pString1 is expanded.
    LPCWSTR pSave2 = NULL;                         // Used to save the pointer in the original pString2 when pString2 is expanded.
    LPCWSTR pSaveEnd1;                              // Used to save the pointer in the end of the original pString1 when pString1 is expanded.
    LPCWSTR pSaveEnd2;                              // Used to save the pointer in the end of the original pString2 when pString2 is expanded.
    
    // Extra weight for Fareast special (Japanese Kana)
    DWORD dwExtraWt1;   
    DWORD dwExtraWt2;

    WCHAR pTmpBuf1[MAX_TBL_EXPANSION];      // Temp buffer for pString1 when pString1 is expanded. pString1 will point to here.
    WCHAR pTmpBuf2[MAX_TBL_EXPANSION];      // Temp buffer for pString1 when pString2 is expanded. pString2 will point to here.
    int cExpChar1, cExpChar2;               // Counter for expansion characters.

    LPCWSTR pString1End = pSaveEnd1 = pString1 + nEndIndex;
    LPCWSTR pString2End = pSaveEnd2 = pString2 + nLength2 - 1;

    pString1 += nStartIndex;

    // Places where we start the search
    LPCWSTR pString1SearchStart = pString1;
    LPCWSTR pString1SearchEnd = (bMatchFirstCharOnly ? pString1 : pString1End);
    //
    // Start from the (nStartIndex)th character in pString1 to the (nEndIndex)th character of pString1.
    //
    for (; pString1 <= pString1SearchEnd; pString1++) {
        // pSearchStr1 now points to the (i)th character in first string. pString1 will be increaced at the end of this for loop.
        LPCWSTR pSearchStr1 = pString1;
        // Reset pSearchStr2 to the first character of the second string.
        LPCWSTR pSearchStr2 = pString2;

        //
        // Scan every character in pString2 to see if pString2 matches the string started at (pString1+i);
        // In this loop, we bail as long as we are sure that pString1 won't match pString2.
        //
        while ((pSearchStr2 <= pString2End) && (pSearchStr1 <= pString1End)) {
            BOOL fContinue = FALSE;         // Flag to indicate that we should jump back to the while loop and compare again.

            SORTKEY sortKey1;
            SORTKEY sortKey2;
            LPDWORD pdwWeight1;
            LPDWORD pdwWeight2;
            
            if (m_IfCompression) {
                sortKey1 = m_pSortKey[*pSearchStr1];
                sortKey2 = m_pSortKey[*pSearchStr2];               
                GetCompressionWeight(dwMask, &sortKey1, pSearchStr1, pString1End, &sortKey2, pSearchStr2, pString2End);
                pdwWeight1 = (LPDWORD)&sortKey1;    // Sortkey weight for characters in the first string.
                pdwWeight2 = (LPDWORD)&sortKey2;    // Sortkey weight for characters in the second string.
            } else {
                if (*pSearchStr1 == *pSearchStr2) {
                    goto Advance;
                }
                sortKey1 = m_pSortKey[*pSearchStr1];
                sortKey2 = m_pSortKey[*pSearchStr2];
                //
                // About two cases of IgnoreNonSpace:
                //  1. When comparing chars like "\u00c0" & \u00c1, the diacritic weight will be masked off.
                //  2. When compairng chars like "\u00c0" & "A\u0301", the first characters on both strings will be
                //     compared equal after masking.  And \u0301 will be ignored by fIgnoreNonSpace flag.
                pdwWeight1 = (LPDWORD)&sortKey1;    // Sortkey weight for characters in the first string.
                pdwWeight2 = (LPDWORD)&sortKey2;    // Sortkey weight for characters in the second string.
                //
                // Mask the diacritic/case/width/Kana type using the pattern stored in dwMask.
                //
                *pdwWeight1 &= dwMask; // Sortkey weight for characters in the first string.
                *pdwWeight2 &= dwMask; // Sortkey weight for characters in the second string.
                
            }
            //
            // The codepoint values of the characters pointed by pSearchStr1 and pSearchStr2 are not the same.
            // However, there are still chances that these characters may be the compared as equal.
            // 1. User may choose to ignore diacritics, cases, width, and kanatypes.
            // 2. We may deal with expansion characters.  That is, when comparing a ligature like
            //     "\u0153" (U+0153 "LATIN SMALL LIGATURE OE") with "OE", they are considered equal.
            // 3. Fareast special (Japanese Kana) is involved.
            // Therefore, we use sortkey to deal with these cases.
            //

            //
            // Get the Sortkey weight for these two characters.
            //
            
            // Get the script member
            BYTE sm1  = sortKey1.UW.SM_AW.Script;
            BYTE sm2  = sortKey2.UW.SM_AW.Script;
            
            // In here, we use dwMask to deal with the following flags:
            //      IgnoreCase
            //      IgnoreNonSpace (two cases, see below)
            //      IgnoreKanaType
            //      IgnoreWidth
            // We don't have to worry about ligatures (i.e. expansion characters, which have script member
            // as EXPANSION) and IgnoreSymbols (letters can NOT be symbols).
            
            // Reset extra weight
            dwExtraWt1 = dwExtraWt2 = 0;
            
            if (sm1 == FAREAST_SPECIAL) {
                WORD uw = sortKey1.UW.Unicode;
                GET_FAREAST_WEIGHT(*pdwWeight1, uw, dwMask, pString1SearchStart, pSearchStr1, dwExtraWt1);
                sm1 = GET_SCRIPT_MEMBER_FROM_UW(uw);
            }
            if (sm2 == FAREAST_SPECIAL) {
                WORD uw = sortKey2.UW.Unicode;
                GET_FAREAST_WEIGHT(*pdwWeight2, uw, dwMask, pString2, pSearchStr2, dwExtraWt2);
                sm2 = GET_SCRIPT_MEMBER_FROM_UW(uw);        // // Re-get the new script member.
            }

            if (sm1 == sm2 && (sm1 >= LATIN)) {
                // The characters on both strings are general letters.  We can optimize on this.                                        

                // Compare alphabetic weight for these two characters.
                if (sortKey1.UW.SM_AW.Alpha != sortKey2.UW.SM_AW.Alpha) {
                    goto NextCharInString1;
                }                    

                if (sortKey1.Case != sortKey2.Case) {
                    // If case is different, skip to the next character in pString1.
                    goto NextCharInString1;
                } 

                // Handle Fareast special first.  
                if (dwExtraWt1 != dwExtraWt2) {
                    if (fIgnoreNonSpace) {
                        if (GET_WT_SIX(&dwExtraWt1) != GET_WT_SIX(&dwExtraWt2)) {
                            goto NextCharInString1;
                        }
                        if (GET_WT_SEVEN(&dwExtraWt1) != GET_WT_SEVEN(&dwExtraWt2)) {
                            // Reset extra weight
                            dwExtraWt1 = dwExtraWt2 = 0;
                            goto NextCharInString1;
                        }
                    } else {
                        goto NextCharInString1;
                    }
                }
                
                //
                // Check for diacritic weights.
                //
                WORD dw1 = sortKey1.Diacritic;
                WORD dw2 = sortKey2.Diacritic;
                if (dw1 == dw2) {
                    // If diacrtic weights are equal, we can move to next chracters.
                    goto Advance;
                }                    

                while (pSearchStr1 < pString1End) {
                    SORTKEY sortKey = m_pSortKey[*(pSearchStr1+1)];
                    if (sortKey.UW.SM_AW.Script  == NONSPACE_MARK) {
                        pSearchStr1++;
                        //
                        // The following chracter is a nonspace character. Add up
                        // the diacritic weight.
                        dw1 += sortKey.Diacritic;
                    }
                    else {
                        break;
                    }
                }

                while (pSearchStr2 < pString2End) {
                    SORTKEY sortKey = m_pSortKey[*(pSearchStr2+1)];
                    if (sortKey.UW.SM_AW.Script == NONSPACE_MARK) {
                        pSearchStr2++;
                        dw2 += sortKey.Diacritic;
                    }
                    else {
                        break;
                    }
                }
        
                if (dw1 == dw2) {
                    //
                    // Find a match at this postion. Move to next character in pString1.
                    //
                    goto Advance;
                }
                // Fail to find a match at this position. 
                goto NextCharInString1;
            }

            DWORD dw1, dw2;
            
            //
            // If the masked dwWeight1 and dwWeight2 are equal, we can go to next character in pSearchStr2.
            // Otherwise, go to the following if statement.
            //
            if (*pdwWeight1 == *pdwWeight2) {
                if (*pSearchStr2 == L'\x0000' && *pSearchStr1 != L'\x0000') {
                    // The target string is an embeded NULL, but the source string is not an embeded NULL.
                    goto NextCharInString1;
                }
                // Otherwise, we can move to the next character in pSearchStr2.
            } else {
                switch (sm1) {
                    case PUNCTUATION:
                    case SYMBOL_1:
                    case SYMBOL_2:
                    case SYMBOL_3:
                    case SYMBOL_4:
                    case SYMBOL_5:
                        if (fIgnoreSymbols) {
                            pSearchStr1++;
                            fContinue = TRUE;
                        }
                        break;
                    case NONSPACE_MARK:
                        if (fIgnoreNonSpace) {
                            pSearchStr1++;
                            fContinue = TRUE;
                        } else { 
                            if (sm2 == NONSPACE_MARK) {
                                dw1 = sortKey1.Diacritic;
                                pSearchStr1++;
                                while (pSearchStr1 <= pString1End) {
                                    SORTKEY sortKey = m_pSortKey[*pSearchStr1];
                                    if (sortKey.UW.SM_AW.Script  == NONSPACE_MARK) {
                                        pSearchStr1++;
                                        //
                                        // The following chracter is a nonspace character. Add up
                                        // the diacritic weight.
                                        dw1 += sortKey.Diacritic;
                                    } else {
                                        break;
                                    }
                                }
                                dw2 = sortKey2.Diacritic;
                                pSearchStr2++;
                                while (pSearchStr2 <= pString2End) {
                                    SORTKEY sortKey = m_pSortKey[*pSearchStr2];
                                    if (sortKey.UW.SM_AW.Script  == NONSPACE_MARK) {
                                        pSearchStr2++;
                                        //
                                        // The following chracter is a nonspace character. Add up
                                        // the diacritic weight.
                                        dw2 += sortKey.Diacritic;
                                    } else {
                                        break;
                                    }
                                }
                                if (dw1 == dw2) {
                                    continue;
                                }
                            }
                        }
                        break;
                    case EXPANSION:
                        if (sm2 == EXPANSION && !(dwFlags & COMPARE_OPTIONS_IGNORECASE)) {
                            // If the script member for the current character in pString2 is also a EXPANSION, and case is not ignoed, 
                            // there is no chance that they may be compared equally.  Go to next character in pString1.
                            goto NextCharInString1;
                        }
                        //
                        // Deal with ligatures.
                        //

                        // We will get to this when we are comparing a character like \x0153 (LATIN SMALL LIGATURE OE).
                        // In this case, we will expand this character to O & E into pTmpBuf1, and replace pSeachStr1 with
                        // pTmpbuf1 temporarily.

                        // Note that sometimes a Unicode char will expand to three characters.  They are done this way:
                        // U+fb03 = U+0066 U+fb01        ;ffi
                        // U+fb01 = U+0066 U+0069        ;fi
                        // That is, they are listed as two expansions in the sorting table.  So we process this in two passes.
                        // In this case, we should make sure the pSave1 stored in the first pass will not be
                        // overwritten by the second passes.
                        // Hense, the pSave1 check below.
                        
                        if (pSave1 == NULL) {
                            pSave1 = pSearchStr1;
                            pSaveEnd1 = pString1End;
                        }
                        pTmpBuf1[0] = GET_EXPANSION_1(pdwWeight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(pdwWeight1);
                        

                        cExpChar1 = MAX_TBL_EXPANSION;
                        // Redirect pSearchStr1 to pTmpBuf1.
                        pSearchStr1 = pTmpBuf1;
                        pString1End = pTmpBuf1 + MAX_TBL_EXPANSION - 1;

                        fContinue = TRUE;
                        break;
                    case UNSORTABLE:
                        if (pString1 == pSearchStr1 || *pSearchStr1 == L'\x0000') {
                            // If the first character in pSearchStr1 is an unsortable, we should
                            // advance to next character in pString1, instead of ignoring it.
                            // This way, we will get a correct result by skipping unsortable characters
                            // at the beginning of pString1.
                            
                            // When we are here, sort weights of two characters are different.
                            // If the character in pString1 is a embedded NULL, we can not just ignore it.
                            // Therefore, we fail to match and should advance to next character in pString1.
                            goto NextCharInString1;
                        }                        
                        pSearchStr1++;
                        fContinue = TRUE;
                        break;
                }   // switch (sm1)

                switch (sm2) {
                    case NONSPACE_MARK:
                        if (fIgnoreNonSpace) {
                            pSearchStr2++;
                            fContinue = TRUE;
                        }
                        break;
                    case PUNCTUATION:
                    case SYMBOL_1:
                    case SYMBOL_2:
                    case SYMBOL_3:
                    case SYMBOL_4:
                    case SYMBOL_5:
                        if (fIgnoreSymbols) {
                            pSearchStr2++;
                            fContinue = TRUE;
                        }
                        break;
                    case EXPANSION:
                        if (pSave2 == NULL) {
                            pSave2 = pSearchStr2;
                            pSaveEnd2 = pString2End;
                        }
                        pTmpBuf2[0] = GET_EXPANSION_1(pdwWeight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(pdwWeight2);

                        cExpChar2 = MAX_TBL_EXPANSION;
                        pSearchStr2 = pTmpBuf2;
                        pString2End = pTmpBuf2 + MAX_TBL_EXPANSION - 1;

                        //
                        //  Decrease counter by one so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        fContinue = TRUE;
                        break;
                    case UNSORTABLE:
                        if (*pSearchStr2 == L'\x0000') {
                            goto NextCharInString1;
                        }                        
                        pSearchStr2++;
                        fContinue = TRUE;
                        break;
                }   // switch (sm2)

                if (fContinue) {
                    continue;
                }
                goto NextCharInString1;
            } // if (dwWeight1 != dwWeight2)
Advance:
            if (pSave1 && (--cExpChar1 == 0)) {
                //
                //  Done using expansion temporary buffer.
                //
                pSearchStr1 = pSave1;
                pString1End = pSaveEnd1;
                pSave1 = NULL;
            }

            if (pSave2 && (--cExpChar2 == 0)) {
                //
                //  Done using expansion temporary buffer.
                //
                pSearchStr2 = pSave2;
                pString2End = pSaveEnd2;
                pSave2 = NULL;
            }

            pSearchStr1++;
            pSearchStr2++;
        }

        //
        // When we are here, either pSearchStr1, pSearchStr2, or both are at the end.
        //

        // If pSearchStr1 is not at the end, check the next character to see if it is a diactritc.
        // Note that pSearchStr1 is incremented at the end of while loop, hense the equal sign check
        // below.
        if (pSearchStr1 <= pString1End) {
            DWORD dwWeight = GET_DWORD_WEIGHT(m_pSortKey, *pSearchStr1);
            if (GET_SCRIPT_MEMBER(&dwWeight) == NONSPACE_MARK) {
                if (!fIgnoreNonSpace) {
                    goto NextCharInString1;
                }
            }
        }
        //
        // Search through the rest of pString2 to make sure
        // all other characters can be ignored.  If we find
        // a character that should not be ignored, we fail to
        // find a match.
        //
        while (pSearchStr2 <= pString2End) {
            DWORD dwWeight = GET_DWORD_WEIGHT(m_pSortKey, *pSearchStr2);
            switch (GET_SCRIPT_MEMBER(&dwWeight)) {
                case NONSPACE_MARK:
                    if (!fIgnoreNonSpace) {
                        goto NextCharInString1;
                    }
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. Go to next character in pString1.
                    break;
                case PUNCTUATION:
                case SYMBOL_1:
                case SYMBOL_2:
                case SYMBOL_3:
                case SYMBOL_4:
                case SYMBOL_5:
                    if (!fIgnoreSymbols) {
                        goto NextCharInString1;
                    }
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. Go to next character in pString1.
                    break;
                case UNSORTABLE:
                    break;
                default:
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. Go to next character in pString1.
                    goto NextCharInString1;
            }
            pSearchStr2++;
        }
        //
        // We didn't bail during the loop.  This means that we find a match.  Return the value.
        //
        return (int)(nStartIndex + pString1 - pString1SearchStart);
        
NextCharInString1:
        // If expansion is used, point pString1End to the original end of the string.
        if (pSave1) {
            pString1End = pSaveEnd1;
            pSave1 = NULL;
        }
        if (pSave2) {
            pString2End = pSaveEnd2;
            pSave2 = NULL;
        }
    }
    return (INDEXOF_NOT_FOUND);    
}


int NativeCompareInfo::LastIndexOfString(LPCWSTR pString1, LPCWSTR pString2, int nStartIndex, int nEndIndex, int nLength2, DWORD dwFlags, int* pnMatchEndIndex) {
    // Make sure that we call InitSortingData() after ctor.
    _ASSERTE(m_pSortKey != NULL);
    DWORD dwMask = CMP_MASKOFF_NONE;       // Mask used to mask off sortkey for characters so that we can ignore diacritic/case/width/kana type.

    BOOL fIgnoreNonSpace     = FALSE;    // Flag to indicate if we should ignore diacritic characters and nonspace characters.
    BOOL fIgnoreSymbols     = FALSE;    // Flag to indicate if we should ignore symbols.

    // Set up dwMask and other flags according to the dwFlags
    if (dwFlags != 0) {
        if (dwFlags & INDEXOF_MASKOFF_VALIDFLAGS) {
            return (INDEXOF_INVALID_FLAGS);
        }

        fIgnoreSymbols = (dwFlags & COMPARE_OPTIONS_IGNORESYMBOLS);        

        if (dwFlags & COMPARE_OPTIONS_IGNORECASE) {
            dwMask &= CMP_MASKOFF_CW;
        }

        if (fIgnoreNonSpace = (dwFlags & COMPARE_OPTIONS_IGNORENONSPACE)) {
            // Note that we have to ignore two types of diacritic:
            // 1. Diacritic characters: like U+00C0 "LATIN CAPITAL LETTER A WITH GRAVE".
            // 2. base character/diacritic character + combining charcters: like U+0041 + U+0300 "COMBINING GRAVE ACCENT".
            dwMask &= CMP_MASKOFF_DW;
            // We use this flag to trace the second type of diacritic.
        }
        if (dwFlags & COMPARE_OPTIONS_IGNOREWIDTH) {
            dwMask &= CMP_MASKOFF_WIDTH;
        }
        if (dwFlags & COMPARE_OPTIONS_IGNOREKANATYPE) {
            dwMask &= CMP_MASKOFF_KANA;
        }
    }

    LPCWSTR pSave1 = NULL;                         // Used to save the pointer in the original pString1 when pString1 is expanded.
    LPCWSTR pSave2 = NULL;                         // Used to save the pointer in the original pString2 when pString2 is expanded.
    LPCWSTR pSaveEnd1;                              // Used to save the pointer in the end of the original pString1 when pString1 is expanded.
    LPCWSTR pSaveEnd2;                              // Used to save the pointer in the end of the original pString2 when pString2 is expanded.
    
    // Extra weight for Fareast special (Japanese Kana)
    DWORD dwExtraWt1;   
    DWORD dwExtraWt2;    

    WCHAR pTmpBuf1[MAX_TBL_EXPANSION];      // Temp buffer for pString1 when pString1 is expanded. pString1 will point to here.
    WCHAR pTmpBuf2[MAX_TBL_EXPANSION];      // Temp buffer for pString1 when pString2 is expanded. pString2 will point to here.
    int cExpChar1, cExpChar2;               // Counter for expansion characters.

    // In the parameters, nStartIndex >= nEndIndex.  "Start" is where the search begins.
    // "End" is where the search ends.
    // In the code below, pString1End means the end of string1.
    // So pString1End should be pString1 + nStartIndex, instead of pString1 + nEndIndex
    
    LPCWSTR pString1Start = pString1 + nEndIndex;
    // Places where we start the search
    LPCWSTR pString1SearchStart = pString1;    
    LPCWSTR pString1End = pSaveEnd1 = pString1 + nStartIndex;
    LPCWSTR pString2End = pSaveEnd2 = pString2 + nLength2 - 1;

    //
    // Start from the (nStartIndex)th character in pString1 to the (nEndIndex)th character of pString1.
    //
    for (pString1 = pString1End; pString1 >= pString1Start; pString1--) {
        // pSearchStr1 now points to the (i)th character in first string. pString1 will be increaced at the end of this for loop.
        LPCWSTR pSearchStr1 = pString1;
        // Reset pSearchStr2 to the first character of the second string.
        LPCWSTR pSearchStr2 = pString2;

        //
        // Scan every character in pString2 to see if pString2 matches the string started at (pString1+i);
        // In this loop, we bail as long as we are sure that pString1 won't match pString2.
        //
        while ((pSearchStr2 <= pString2End) && (pSearchStr1 <= pString1End)) {
            BOOL fContinue = FALSE;         // Flag to indicate that we should jump back to the while loop and compare again.

            SORTKEY sortKey1;
            SORTKEY sortKey2;

            LPDWORD pdwWeight1;
            LPDWORD pdwWeight2;
            
            if (m_IfCompression) {
                sortKey1 = m_pSortKey[*pSearchStr1];
                sortKey2 = m_pSortKey[*pSearchStr2];               
                GetCompressionWeight(dwMask, &sortKey1, pSearchStr1, pString1End, &sortKey2, pSearchStr2, pString2End);
                pdwWeight1 = (LPDWORD)&sortKey1; // Sortkey weight for characters in the first string.
                pdwWeight2 = (LPDWORD)&sortKey2; // Sortkey weight for characters in the second string.
            } else {
                if (*pSearchStr1 == *pSearchStr2) {
                    goto Advance;
                }
                sortKey1 = m_pSortKey[*pSearchStr1];
                sortKey2 = m_pSortKey[*pSearchStr2];
                //
                // About two cases of IgnoreNonSpace:
                //  1. When comparing chars like "\u00c0" & \u00c1, the diacritic weight will be masked off.
                //  2. When compairng chars like "\u00c0" & "A\u0301", the first characters on both strings will be
                //     compared equal after masking.  And \u0301 will be ignored by fIgnoreNonSpace flag.
                pdwWeight1 = (LPDWORD)&sortKey1; // Sortkey weight for characters in the first string.
                pdwWeight2 = (LPDWORD)&sortKey2; // Sortkey weight for characters in the second string.

                *pdwWeight1 &= dwMask;
                *pdwWeight2 &= dwMask;                
            }

            // Do a code-point comparison
            //
            // The codepoint values of the characters pointed by pSearchStr1 and pSearchStr2 are not the same.
            // However, there are still chances that these characters may be the compared as equal.
            // 1. User may choose to ignore diacritics, cases, width, and kanatypes.
            // 2. We may deal with expansion characters.  That is, when comparing a ligature like
            //     "\u0153" (U+0153 "LATIN SMALL LIGATURE OE") with "OE", they are considered equal.
            // 3. Fareast special (Japanese Kana) is involved.
            // Therefore, we use sortkey to deal with these cases.
            //

            //
            // Get the Sortkey weight for these two characters.
            //
            
            // Get the script member
            BYTE sm1  = sortKey1.UW.SM_AW.Script;
            BYTE sm2  = sortKey2.UW.SM_AW.Script;
            
            // In here, we use dwMask to deal with the following flags:
            //      IgnoreCase
            //      IgnoreNonSpace (two cases, see below)
            //      IgnoreKanaType
            //      IgnoreWidth
            // We don't have to worry about ligatures (i.e. expansion characters, which have script member
            // as EXPANSION) and IgnoreSymbols (letters can NOT be symbols).
            
            // Reset extra weight
            dwExtraWt1 = dwExtraWt2 = 0;

            if (sm1 == FAREAST_SPECIAL) {
                WORD uw = sortKey1.UW.Unicode;
                GET_FAREAST_WEIGHT(*pdwWeight1, uw, dwMask, pString1SearchStart, pSearchStr1, dwExtraWt1);
                sm1 = GET_SCRIPT_MEMBER_FROM_UW(uw);        // // Re-get the new script member.
            }
            if (sm2 == FAREAST_SPECIAL) {
                WORD uw = sortKey2.UW.Unicode;
                GET_FAREAST_WEIGHT(*pdwWeight2, uw, dwMask, pString2, pSearchStr2, dwExtraWt2);
                sm2 = GET_SCRIPT_MEMBER_FROM_UW(uw);        // // Re-get the new script member.
            }

            if (sm1 == sm2 && (sm1 >= LATIN)) {
                // The characters on both strings are general letters.  We can optimize on this.
                
                // Compare alphabetic weight for these two characters.
                if (sortKey1.UW.SM_AW.Alpha != sortKey2.UW.SM_AW.Alpha) {
                    goto NextCharInString1;
                }
                
                // At this point, we know that masked sortkeys are different.
                
                if (sortKey1.Case != sortKey2.Case) {
                    goto NextCharInString1;
                }

                // Handle Fareast special first.  
                if (dwExtraWt1 != dwExtraWt2) {
                    if (fIgnoreNonSpace) {
                        if (GET_WT_SIX(&dwExtraWt1) != GET_WT_SIX(&dwExtraWt2)) {
                            goto NextCharInString1;
                        }
                        if (GET_WT_SEVEN(&dwExtraWt1) != GET_WT_SEVEN(&dwExtraWt2)) {
                            goto NextCharInString1;
                        }
                    } else {
                        goto NextCharInString1;
                    }
                }
                
                
                //
                // Check for diacritic weights.
                //
                WORD dw1 = sortKey1.Diacritic;
                WORD dw2 = sortKey2.Diacritic;

                if (dw1 == dw2) {
                    // If the diacritic weights are equal, and
                    // case weights are not equal, we fail to find a match.
                    goto Advance;
                }
                while (pSearchStr1 < pString1End) {
                    SORTKEY sortKey = m_pSortKey[*(pSearchStr1+1)];
                    if (sortKey.UW.SM_AW.Script  == NONSPACE_MARK) {
                        pSearchStr1++;
                        //
                        // The following chracter is a nonspace character. Add up
                        // the diacritic weight.
                        dw1 += sortKey.Diacritic;
                    }
                    else {
                        break;
                    }
                }

                while (pSearchStr2 < pString2End) {
                    SORTKEY sortKey = m_pSortKey[*(pSearchStr2+1)];
                    if (sortKey.UW.SM_AW.Script == NONSPACE_MARK) {
                        pSearchStr2++;
                        dw2 += sortKey.Diacritic;
                    }
                    else {
                        break;
                    }
                }

                if (dw1 == dw2) {
                    //
                    // Find a match at this postion. Move to next character in pString1.
                    //
                    goto Advance;
                }
                goto NextCharInString1;
            }
            
            //
            // If the masked dwWeight1 and dwWeight2 are equal, we can go to next character in pSearchStr2.
            // Otherwise, go to the following if statement.
            //
            WORD dw1, dw2;

            if (*pdwWeight1 == *pdwWeight2) {
                if (*pSearchStr2 == L'\x0000' && *pSearchStr1 != L'\x0000') {
                    goto NextCharInString1;
                }
            } else {
                switch (sm1) {
                    case PUNCTUATION:
                    case SYMBOL_1:
                    case SYMBOL_2:
                    case SYMBOL_3:
                    case SYMBOL_4:
                    case SYMBOL_5:
                        if (fIgnoreSymbols) {
                            pSearchStr1++;
                            fContinue = TRUE;
                        }
                        break;
                    case NONSPACE_MARK:
                        if (fIgnoreNonSpace) {
                            pSearchStr1++;
                            fContinue = TRUE;
                        } else {
                            if (sm2 == NONSPACE_MARK) {
                                dw1 = sortKey1.Diacritic;
                                pSearchStr1++;
                                while (pSearchStr1 <= pString1End) {
                                    SORTKEY sortKey = m_pSortKey[*pSearchStr1];
                                    if (sortKey.UW.SM_AW.Script  == NONSPACE_MARK) {
                                        pSearchStr1++;
                                        //
                                        // The following chracter is a nonspace character. Add up
                                        // the diacritic weight.
                                        dw1 += sortKey.Diacritic;
                                    } else {
                                        break;
                                    }
                                }

                                dw2 = sortKey2.Diacritic;
                                pSearchStr2++;
                                while (pSearchStr2 <= pString2End) {
                                    SORTKEY sortKey = m_pSortKey[*pSearchStr2];
                                    if (sortKey.UW.SM_AW.Script  == NONSPACE_MARK) {
                                        pSearchStr2++;
                                        //
                                        // The following chracter is a nonspace character. Add up
                                        // the diacritic weight.
                                        dw2 += sortKey.Diacritic;
                                    } else {
                                        break;
                                    }
                                }
                                if (dw1 == dw2) {
                                    continue;
                                }
                                
                            }
                        }
                        break;
                    case EXPANSION:
                        if (sm2 == EXPANSION && !(dwFlags & COMPARE_OPTIONS_IGNORECASE)) {
                            // If the script member for the current character in pString2 is also a EXPNSION, and case is not ignoed, 
                            // there is no chance that they may be compared equally.  Go to next character in pString1.
                            goto NextCharInString1;
                        }
                        //
                        // Deal with ligatures.
                        //

                        // We will get to this when we are comparing a character like \x0153 (LATIN SMALL LIGATURE OE).
                        // In this case, we will expand this character to O & E into pTmpBuf1, and replace pSeachStr1 with
                        // pTmpbuf1 temporarily.

                        if (pSave1 == NULL) {
                            pSave1 = pSearchStr1;
                            pSaveEnd1 = pString1End;
                        }
                        pTmpBuf1[0] = GET_EXPANSION_1(pdwWeight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(pdwWeight1);

                        cExpChar1 = MAX_TBL_EXPANSION;
                        // Redirect pSearchStr1 to pTmpBuf1.
                        pSearchStr1 = pTmpBuf1;
                        pString1End = pTmpBuf1 + MAX_TBL_EXPANSION - 1;

                        fContinue = TRUE;
                        break;
                    case UNSORTABLE:
                        if (*pSearchStr1 == L'\x0000') {
                            goto NextCharInString1;
                        }                        
                        pSearchStr1++;
                        fContinue = TRUE;
                        break;
                }   // switch (sm1)

                switch (sm2) {
                    case NONSPACE_MARK:
                        if (fIgnoreNonSpace) {
                            pSearchStr2++;
                            fContinue = TRUE;
                        }
                        break;
                    case PUNCTUATION:
                    case SYMBOL_1:
                    case SYMBOL_2:
                    case SYMBOL_3:
                    case SYMBOL_4:
                    case SYMBOL_5:
                        if (fIgnoreSymbols) {
                            pSearchStr2++;
                            fContinue = TRUE;
                        }
                        break;
                    case EXPANSION:
                        if (pSave2 == NULL) {
                            pSave2 = pSearchStr2;
                            pSaveEnd2 = pString2End;
                        }
                        
                        pTmpBuf2[0] = GET_EXPANSION_1(pdwWeight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(pdwWeight2);

                        cExpChar2 = MAX_TBL_EXPANSION;
                        pSearchStr2 = pTmpBuf2;
                        pString2End = pTmpBuf2 + MAX_TBL_EXPANSION - 1;

                        //
                        //  Decrease counter by one so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        fContinue = TRUE;
                        break;
                    case UNSORTABLE:
                        if (*pSearchStr2 == L'\x0000') {
                            goto NextCharInString1;
                        }                        
                        pSearchStr2++;
                        fContinue = TRUE;
                        break;
                }   // switch (sm2)

                if (fContinue) {
                    continue;
                }
                goto NextCharInString1;
            } // if (dwWeight1 != dwWeight2)
Advance:
            if (pSave1 && (--cExpChar1 == 0)) {
                //
                //  Done using expansion temporary buffer.
                //
                pSearchStr1 = pSave1;
                pString1End = pSaveEnd1;
                pSave1 = NULL;
            }

            if (pSave2 && (--cExpChar2 == 0)) {
                //
                //  Done using expansion temporary buffer.
                //
                pSearchStr2 = pSave2;
                pString2End = pSaveEnd2;
                pSave2 = NULL;
            }

            pSearchStr1++;
            pSearchStr2++;
        }

        // Look ahead to check if the next character is a diactritc.
        if (pSearchStr1 <= pString1End) {
            DWORD dwWeight = GET_DWORD_WEIGHT(m_pSortKey, *pSearchStr1);
            if (GET_SCRIPT_MEMBER(&dwWeight) == NONSPACE_MARK) {
                if (!fIgnoreNonSpace) {
                    goto NextCharInString1;
                }
            }
        }

        //
        // Search through the rest of pString2 to make sure
        // all other characters can be ignored.  If we find
        // a character that should not be ignored, we fail to
        // find a match.
        //
        while (pSearchStr2 <= pString2End) {
            DWORD dwWeight = GET_DWORD_WEIGHT(m_pSortKey, *pSearchStr2);
            switch (GET_SCRIPT_MEMBER(&dwWeight)) {
                case NONSPACE_MARK:
                    if (!fIgnoreNonSpace) {
                        goto NextCharInString1;
                    }
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. Go to next character in pString1.
                    break;
                case PUNCTUATION:
                case SYMBOL_1:
                case SYMBOL_2:
                case SYMBOL_3:
                case SYMBOL_4:
                case SYMBOL_5:
                    if (!fIgnoreSymbols) {
                        goto NextCharInString1;
                    }
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. Go to next character in pString1.
                    break;
                case UNSORTABLE:
                    break;
                default:
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. Go to next character in pString1.
                    goto NextCharInString1;
            }
            pSearchStr2++;
        }
        // This is the end of matching string1.
        *pnMatchEndIndex = (int)(pSearchStr1 - pString1Start + nEndIndex);
        //
        // We didn't bail during the loop.  This means that we find a match.  Return the value.
        //
        return (int)(pString1 - pString1Start + nEndIndex);
        
NextCharInString1:
        // If expansion is used, point pString1End to the original end of the string.
        if (pSave1) {
            pString1End = pSaveEnd1;
            pSave1 = NULL;
        }
        if (pSave2) {
            pString2End = pSaveEnd2;
            pSave2 = NULL;
        }
    }
    return (INDEXOF_NOT_FOUND);    
}

BOOL NativeCompareInfo::IsSuffix(LPCWSTR pSou