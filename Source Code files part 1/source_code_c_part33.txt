;
	
	return fFalse;
}

// could be DBCS
ifvsEnum CheckFilename(const ICHAR* szFileName, Bool fLFN)
{
	return CheckWildFilename(szFileName, fLFN, fFalse /* fWildCard */);
}

// could be DBCS
ifvsEnum CheckWildFilename(const ICHAR* szFileName, Bool fLFN, Bool fWildCard)
/*----------------------------------------------------------------------------------
CheckWildFilename -- validates a particular filename (short)
 or long and returns an enum describing the error (or success)

  Returns one of ifvsEnum:
  ifvsValid --> valid, no error
  ifvsInvalidLength --> invalid length or not filename
  ifvsReservedWords --> filename has reserved words
  ifvsReservedChar --> filename has reserved char(s)
  ifvsSFNFormat --> invalid SFN format (8.3)
  ifvsLFNFormat --> invalid LFN format (all periods, must have one non-period char)
------------------------------------------------------------------------------------*/
{
	// variables
	const int* rgiValidChar;
	int cchMaxLen;

	// determine which to use...
	if (fLFN)
	{
		rgiValidChar = rgiLFNValidChar;
		cchMaxLen = cchMaxLongFileName;
	}
	else
	{
		rgiValidChar = rgiSFNValidChar;
		cchMaxLen = cchMaxShortFileName;
	}

	int cchName = 0;
	if (szFileName)
		cchName = CountChars(szFileName);
		
	//check length
	if (cchName < 1)
	{
		AssertSz(szFileName, "Null filename to CheckFileName");  //!! should we assert??
		return ifvsInvalidLength;
	}

	//check reserved words
	// We are making the assumption here that there are no DBCS characters in pszReservedWords
	// Thus if we find any in szFileName (cch != IStrLen in this case) we can skip this compare
	if (cchName == IStrLen(szFileName))
	{
		if (cchName <= cchMaxReservedWords && cchName >= cchMinReservedWords)
		{
			for (int csz=0; csz < cszReservedWords; csz++)
			{
				if (!IStrCompI(szFileName, pszReservedWords[csz]))
					return ifvsReservedWords;
			}
		}
	}

	//check invalid characters
	const ICHAR* pchFileName = szFileName;

	if (!fLFN && *pchFileName == '.') // leading dots are not allowed in SFN (are allowed in LFN)
		return ifvsReservedChar;

	int cch = 1;
	int cchPeriod = 0;
	Bool fNonPeriodChar = fFalse;
	int cWildCardCount[2] = {0, 0};

	do
	{
		// wildcards: For validation, ? must be a character, even if it is right before
		// the period in a SFN. We still allow for * to be 0
		if (fWildCard && (*pchFileName == '*'))
			// keep track of how many *'s we see.
			cWildCardCount[cchPeriod != 0]++;
		else if (fWildCard && (*pchFileName == '?'))
		{
			// eat char
		}
		else


		// Check for valid char
		// NOTE:  division finds location in rgiValidChar array and modulus finds particular bit
		if (((int)(*pchFileName)) < iValidChar && !(rgiValidChar[((int)(*pchFileName)) / (sizeof(int)*8)] & (1 << (((int)(*pchFileName)) % (sizeof(int)*8)))))
			return ifvsReservedChar;
		
		// Check here for too many periods
		if (fLFN == fFalse && *pchFileName == '.')
		{
			// If this is the first ., cchPeriod should be 0
			if (cchPeriod != 0)
			{
				// Otherwise, we have an error
				return ifvsSFNFormat;
			}
			cchPeriod = cch;
		}

		// LFN can't be all periods
		if (fLFN && !fNonPeriodChar && *pchFileName != '.')
			fNonPeriodChar = fTrue;

		cch++;
	}
	while ( *(pchFileName = ICharNext(pchFileName)) != 0);
	
	if (cchPeriod == 0)
		cchPeriod = cch;
	cch--;
	Assert(cch == cchName);

	if (fLFN && !fNonPeriodChar)
		return ifvsLFNFormat;

	if (fLFN == fFalse)
	{
		if((cchPeriod - cWildCardCount[0] - 1 > cchMaxSFNPreDotLength) ||
			(cch - cchPeriod - cWildCardCount[1] > cchMaxSFNPostDotLength))
			return ifvsSFNFormat;
	}

	// check for length limits
	if ( (fLFN == fTrue) &&
		 (cchName - cWildCardCount[0] - cWildCardCount[1] > cchMaxLen) )
		return ifvsInvalidLength;

	return ifvsValid;
}

Bool ParsePath(MsiString& rstrPath, bool fRelative)
/*--------------------------------------------------------------------------------
ParsePath -- Validates a path string.  Must be a full path.  Path can begin with
a drive letter [i.e. c:\], or a server/share specification [i.e. \\server\share],
or a drive property [i.e. [DRIVE]\].  The full path can end with a '\'  and
cannot contain '\' twice in a row [except at the beginning of a \\server\share
path]. All subpaths are validated as filenames/folders except for the server and
share, which are not validated because the rules are not universal (depend on
the network system). Properties must follow correct property syntax, and key
properties ($#!) are only allowed at the beginning of the path. URLs are NOT
allowed in this form of path.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
----------------------------------------------------------------------------------*/
{
	const ICHAR *szDriveSep      = TEXT(":");
	const ICHAR *szOpenProperty  = TEXT("[");
	const ICHAR *szCloseProperty = TEXT("]");

	ICHAR rgDoubleSeps[3] = {chDirSep, chDirSep, '\0'};
	int iReqComponent = 0;

	MsiString strNewPath = rstrPath;
	if (strNewPath.Compare(iscStart, rgDoubleSeps) != 0)
	{
		// network syntax. Only remove the first '\' from the path. The other will be
		// ignored by the parser, but leaving it will cause the doublesep check to
		// catch things like "\\\server\share"
		strNewPath.Remove(iseFirst, 1);

		// A drive delimiter is now invalid and we must have at least
		// <something>\<something> before the path is considered valid. But as soon
		// as we hit a property, all bets are off.
		iReqComponent = 2;
	}

	if (strNewPath.Compare(iscWithin, rgDoubleSeps) != 0)
		return fFalse; // INVALID -- double seps

	if (strNewPath.Compare(iscEnd, szDirSep) != 0) // can end with a '\'
		strNewPath.Remove(iseLast, 1);
	
	if (iReqComponent == 0)
	{
		if (strNewPath.Compare(iscWithin, szDriveSep))
		{
			// we have a ':' somewhere. Its not valid for filenames, or properties,
			// so it must be the drive delimiter.
			MsiString strDrive = strNewPath.Extract(iseUptoTrim, *szDriveSep);
			strNewPath.Remove(iseIncluding, *szDriveSep);

			// after the ':' must be either nothing (path is c:), a dirsep (c:\...)
			// or a property (c:[myprop]). c:abc is not allowed (we are a path, not a
			// filename)
			if (strNewPath.TextSize() && !strNewPath.Compare(iscStart, szOpenProperty) &&
				!strNewPath.Compare(iscStart, szDirSep))
				return fFalse; // INVALID - bad stuff after drive letter

			// if the part before the ':' is more than one char, it has to be
			// a property or it is invalid
			if (strDrive.TextSize() > 1)
			{
				if (!strDrive.Compare(iscStart, szOpenProperty) ||
					!strDrive.Compare(iscEnd, szCloseProperty))
					return fFalse; // INVALID - bad drive letter
				strDrive.Remove(iseFirst, 1);
				strDrive.Remove(iseLast, 1);
				// Formatted determines whether [#] is valid. fKeyAllowed determines if $#!
				// is allowed. iCol and iForeignKeyMask are not needed.	Because we are before
				// the drive delimiter, a full path property is not valid, so we can eliminate
				// the $#! types.
				int iCol = 0;
				int iForeignKeyMask = 0;
				if (!ParseProperty(strDrive, fFalse /* fFormatted */, fFalse /* fKeyAllowed */, iCol, iForeignKeyMask))
					return fFalse; // INVALID - bad property
			}
			else
			{
				// part before the ':' is 0 or 1 chars.
				const ICHAR chDrive = *(const ICHAR *)strDrive;
				if (!((chDrive >= 'A' && chDrive <= 'Z') || (chDrive >= 'a' && chDrive <= 'z')))
					return fFalse; // INVALID - bad drive letter
			}
		}
		else
		{
			// not a network share or drive letter. If we don't allow relative paths
			// it must be a property (unless something goofy like A[ColonProperty]\temp, but
			// thats an extreme case.
			if (strNewPath.Compare(iscStart, szOpenProperty))
			{
				strNewPath.Remove(iseFirst, 1);
				if (!strNewPath.Compare(iscWithin, szCloseProperty))
					return fFalse;	// INVALID - not a property
				MsiString strProperty = strNewPath.Extract(iseUptoTrim, *szCloseProperty);
				strNewPath.Remove(iseIncluding, ']');
				// Formatted determines whether [#] is valid. fKeyAllowed determines if $#!
				// is allowed. iCol and iForeignKeyMask are not needed.	
				int iCol = 0;
				int iForeignKeyMask = 0;
				if (!ParseProperty(strProperty, fFalse /* fFormatted */, fTrue /* fKeyAllowed */, iCol, iForeignKeyMask))
					return fFalse; // INVALID -- bad property reference
			}
			else if (!fRelative)
				return fFalse; // INVALID - not a valid drive specification
		}
	}
		
	// the author can put properties anywhere, so all we can check are the validitiy
	// of property references and that none of the characters are bogus for
	// LFN filenames. If we do hit a property, all restrictions
	while (strNewPath.TextSize())
	{
		// if a dir separator, eat it and move on, we have already checked for double '\'
		if (strNewPath.Compare(iscStart, szDirSep))
		{
			strNewPath.Remove(iseFirst, 1);
			continue;
		}

		// unmatched brackets are left in the text. Only matched ones
		// define properties
		if (strNewPath.Compare(iscStart, szOpenProperty) && strNewPath.Compare(iscWithin, szCloseProperty))
		{
			// once we hit a property, anything that might have been required is not a requirement
			// anymore (because it could all be in the property)
			iReqComponent = 0;

			strNewPath.Remove(iseFirst, 1);
			MsiString strProperty = strNewPath.Extract(iseUptoTrim, *szCloseProperty);
			strNewPath.Remove(iseIncluding, ']');
			// Formatted determines whether [#] is valid. fKeyAllowed determines if $#!
			// is allowed. iCol and iForeignKeyMask are not needed.	$#! are not allowed
			// because we are not at the beginning of the path
			int iCol = 0;
			int iForeignKeyMask = 0;
			if (!ParseProperty(strProperty, fFalse /*fFormatted*/, fFalse /*fKeyAllowed*/, iCol, iForeignKeyMask))
				return fFalse;
			continue;
		}

		// can only validate up to the next property or dir sep char.
		int cchSep = 0;
		const ICHAR *pchCur = strNewPath;
		while ((*pchCur != chDirSep) && (*pchCur != *szOpenProperty) && (*pchCur))
		{
			pchCur = ICharNext(pchCur);
			cchSep++;
		}
		MsiString strSubPath;
		strSubPath = strNewPath.Extract(iseFirst, cchSep);
		strNewPath.Remove(iseFirst, cchSep);
	
		// string of chars. if we are currently requiring a server or share name, there's nothing
		// that we can validate, because the requirements are defined by the network service
		// provider
		if (iReqComponent)
		{
			iReqComponent--;
		}
		// otherwise, it can be anything that is a valid filename
		else if (ifvsValid != CheckFilename(strSubPath, fTrue /* fLFN */))
			return fFalse; // INVALID -- must be some bad chars
	}

	// unless we haven't satisfied the server\share requirement, this is valid
	return iReqComponent ? fFalse : fTrue;
}

Bool GetProperties(const ICHAR* szRecord, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask)
/*-----------------------------------------------------------------------------------------------------------
GetProperties -- extracts properties from a data string.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
	Updates iForeignKeyMask
-----------------------------------------------------------------------------------------------------------*/
{
	// Variables
	CTempBuffer<ICHAR,MAX_PATH> rgBuffer;
	int cBuffer = 0;
	ICHAR* pchOut = rgBuffer;
	const ICHAR* pchIn = szRecord;
	Bool fDoubleBrackets   = fFalse;          // whether [[variable]] setup
	Bool fFirstTime        = fTrue;           // first time in loop
	int cCurlyBrace        = 0;               // number of curly braces
	int cBracket           = 0;               // number of brackets


	// Count number of braces and brackets to make sure num left equal num right
	const ICHAR* pchPrev = 0;
	while (*pchIn != 0)
	{
		if (*pchIn == '{')
			cCurlyBrace++;
		else if (*pchIn == '}')
			cCurlyBrace--;
		else if (*pchIn == '[')
			cBracket++;
		else if (*pchIn == ']')
			cBracket--;
		else if (*pchIn == chDirSep)
		{
			if (pchPrev != 0 && *pchPrev == '[')
				pchIn = ICharNext(pchIn); // do a skip -- escape sequence, but we don't know what the escaped char is
		}
		pchPrev = pchIn;
		pchIn = ICharNext(pchIn);
	}
	if ((cCurlyBrace != 0) || (cBracket != 0))
		return fFalse; // INVALID -- brackets and braces don't match up

	// Reset pchIn
	pchIn = szRecord;

	// Grab out all properties in string and validate
	do
	{
		pchOut = rgBuffer;
		cBuffer = 0;

		if (fDoubleBrackets)
		{
			if (*pchIn != ']' && *pchIn != '[')
				return fFalse; // INVALID -- bad format [[variable]xx] or something similar
			if (*pchIn == ']')
			{	fDoubleBrackets = fFalse;
				++pchIn;
				continue;
			}
		}
		
		if (*pchIn != '[')
			pchIn = ICharNext(pchIn);
		else
		{
			pchIn++; // for '['
			while (*pchIn != 0 && *pchIn != ']')
			{
				// Check for double brackets
				if (fFirstTime && *pchIn == '[')
				{
					if (fDoubleBrackets)
						return fFalse; // INVALID -- bad property [[variable][[var] not allowed
					fDoubleBrackets = fTrue;
					pchIn++; // for '['
					
				}
				else if (*pchIn == '[')
					return fFalse; // brackets within brackets [xx[xxx]xx] or something similar
				else if (fFirstTime && *pchIn == chDirSep)
				{
#ifdef UNICODE
					if (cBuffer >= rgBuffer.GetSize()-2)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}
					*pchOut++ = *pchIn++;
					if(*pchIn)
						*pchOut++ = *pchIn++; // copy escape char
					else
						return fFalse; // malformed
					cBuffer += 2;
#else // !UNICODE
					if (cBuffer >= rgBuffer.GetSize()-4)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}
					for (int i = 0; i < 2; i++)
					{
						const ICHAR* pchTemp = pchIn;
						*pchOut++ = *pchIn;
						cBuffer++;
						pchIn = ICharNext(pchIn);
						if (pchIn == pchTemp + 2)
						{
							cBuffer++;
							*pchOut++ = *(pchIn - 1); // for DBCS char
						}
					}
#endif // UNICODE
				}
				else
				{
#ifdef UNICODE
					if (cBuffer >= rgBuffer.GetSize()-1)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}
					*pchOut++ = *pchIn++;
					cBuffer++;
#else // !UNICODE
					if (cBuffer >= rgBuffer.GetSize()-2)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}

					const ICHAR* pchTemp = pchIn;
					*pchOut++ = *pchIn;
					pchIn = ICharNext(pchIn);
					if (pchIn == pchTemp + 2)
					{
						*pchOut++ = *(pchIn - 1); // for DBCS char
						cBuffer++;
					}
#endif // UNICODE
				}
				fFirstTime = fFalse;
			}

			if (*pchIn == 0)
				return fTrue; // No closing bracket, so valid.

			fFirstTime = fTrue; // reset
			*pchOut = '\0';
			pchIn++; // for ']'
			if (!ParseProperty(rgBuffer, fFormatted/*fFormatted*/, fKeyAllowed/*fKeyAllowed*/, iCol, iForeignKeyMask))
				return fFalse; // INVALID -- bad property
		}
	}
	while (*pchIn != 0);

	return fTrue; // VALID
}


Bool ParseProperty(const ICHAR* szProperty, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask)
/*------------------------------------------------------------------------------------------------------------
ParseProperty -- validates property strings, [abc], [1], [#abc], [$abc]

  Returns:
	Bool fTrue (valid), fFalse (invalid)
	Updates iForeignKeyMask
-------------------------------------------------------------------------------------------------------------*/
{
	const ICHAR* pchProperty = szProperty;
	
	if (szProperty == 0 || *szProperty == 0)
		return fFalse; // INVALID -- no property

	if (*pchProperty == chFormatEscape) // Escape sequence prop
		return (IStrLen(szProperty) == 2) ? fTrue : fFalse;
	else if (*pchProperty == '$' || *pchProperty == '#' || *pchProperty == '!')
	{
		if (!fKeyAllowed)
			return fFalse; // INVALID -- not allowed in this property
		iForeignKeyMask |= 1 << (iCol -1);
	}
	
	if (*pchProperty == '%' || *pchProperty == '$' || *pchProperty == '#' || *pchProperty == '!')
	{
		MsiString strProperty(szProperty);
		strProperty.Remove(iseFirst, 1); // for '%'
		return CheckIdentifier((const ICHAR*)strProperty) ? fTrue : fFalse;
	}
	else if(*pchProperty == '~' && !*(pchProperty+1)) //!! multi_sz - we should create a new category
		return fTrue;
	else
	{
		// either identifier or integer prop (int only permitted w/ Template)
		MsiString strIdentifier(szProperty);
		if (int(strIdentifier) != iMsiStringBadInteger)
			return fFormatted ? fFalse : fTrue;
		return CheckIdentifier((const ICHAR*)strIdentifier) ? fTrue : fFalse;
	}
}



Bool CheckSet(MsiString& rstrSet, MsiString& rstrData, Bool fIntegerData)
/*------------------------------------------------------------------------------------
CheckSet -- checks to see if data string matches a value in the set string.

  Returns:
	Bool fTrue (valid -- match), fFalse (invalid -- no match)
-------------------------------------------------------------------------------------*/
{
	MsiString rstrSetValue = (const ICHAR*)0;
	while (rstrSet.TextSize())
	{
		rstrSetValue = rstrSet.Extract(iseUptoTrim, ';');
		if (fIntegerData && (int(rstrData) == int(rstrSetValue)))
				return fTrue;
		else if (!fIntegerData && (IStrComp(rstrSetValue, rstrData) == 0))
				return fTrue;
		if (!rstrSet.Remove(iseIncluding, ';'))
				break;
	}
	return fFalse;  // invalid (no match)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\dbfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbfile.cpp
//
//--------------------------------------------------------------------------

/* dbfile.cpp - persistant database implemtation

CMsiStorage - database file management, based on IStorage
CMsiStream - stream object, based on IStream
CMsiMemoryStream - stream object, based on memory allocation
CMsiFileStream   - stream object created on a file
CMsiSummaryInfo  - summary stream property input/output
CFileRead CFileWrite - internal objects for database table import/export
CMsiLockBytes - internal object to allow lockbytes on a resource
____________________________________________________________________________*/

#include "precomp.h"
#include "_databas.h"

extern long g_cInstances;

#define LOC  // module scope

enum issEnum  // stream state, to prevent simultaneous read/write
{
	issReset = 0,
	issRead,
	issWrite,
	issError,
};

enum idorEnum // delete-on-release possibilities
{
	idorDontDelete = 0,
	idorDelete,
	idorElevateAndDelete,
};

const GUID IID_NULL = {0,0,0,{0,0,0,0,0,0,0,0}};

//____________________________________________________________________________
//
//  CMsiLockBytes definitions
//____________________________________________________________________________
//
//
// The implementation of CreateILockBytesOnHGlobal doesn't correctly handle
// an HGLOBAL that was returned from LoadResource. Apparently it internally
// does a GlobalSizeof which doesn't seem to deal with resource HGLOBAL's 
// correctly. 
//
// This is a minimal, read-only implementation of ILockBytes to allow creation
// of MsiStorage's on streams, or on memory by creating a memory stream object.
//

const GUID IID_ILockBytes = GUID_IID_ILockBytes;
class CMsiLockBytes: public ILockBytes
{
 public:
	CMsiLockBytes(const char* pchMem, int iLength);
	CMsiLockBytes(IMsiStream& riStream);
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall ReadAt(ULARGE_INTEGER ulOffset, void* pv, ULONG cb, ULONG* pcbRead);
	HRESULT __stdcall WriteAt(ULARGE_INTEGER ulOffset, const void* pv, ULONG cb, ULONG* pcbWritten);
	HRESULT __stdcall Flush();
	HRESULT __stdcall SetSize(ULARGE_INTEGER cb);
	HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT __stdcall Stat(STATSTG* pstatstg, DWORD grfStatFlag);
 protected:
	~CMsiLockBytes();  // protected to prevent creation on stack
	int             m_iRefCnt;      // COM reference count
	IMsiStream*     m_piStream;
};

//____________________________________________________________________________
//
//  CMsiStorage, CMsiStream definitions
//____________________________________________________________________________

class CMsiStream;  // forward declaration

class CMsiStorage : public IMsiStorage
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString& __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	IMsiRecord*   __stdcall OpenStream(const ICHAR* szName, Bool fWrite,
									IMsiStream*& rpiStream);
	IMsiRecord*   __stdcall RemoveElement(const ICHAR* szName, Bool fStorage);
	IMsiRecord*   __stdcall RenameElement(const ICHAR* szOldName, const ICHAR* szNewName, Bool fStorage);
	IEnumMsiString* __stdcall GetStreamEnumerator();
	IEnumMsiString* __stdcall GetStorageEnumerator();
	IMsiRecord*   __stdcall OpenStorage(const ICHAR* szName, ismEnum ismOpenMode, IMsiStorage*& rpiStorage);
	IMsiRecord*   __stdcall SetClass(const IID& riid);
	Bool          __stdcall GetClass(IID* piid);
	IMsiRecord*   __stdcall Commit();
	IMsiRecord*   __stdcall Rollback();
	Bool          __stdcall DeleteOnRelease(bool fElevateToDelete);
	IMsiRecord*   __stdcall CreateSummaryInfo(unsigned int cMaxProperties,
															IMsiSummaryInfo*& rpiSummary);
	IMsiRecord* __stdcall CopyTo(IMsiStorage& riDestStorage, IMsiRecord* piExcludedStreams);
	IMsiRecord* __stdcall GetName(const IMsiString*& rpiName);
	IMsiRecord* __stdcall GetSubStorageNameList(const IMsiString*& rpiTopParent, const IMsiString*& rpiSubStorageList);
	bool        __stdcall ValidateStorageClass(ivscEnum ivsc);
 public: // constructor, destructor
	void* operator new(size_t cb);
	void  operator delete(void * pv);
	CMsiStorage(IStorage& riStorage, ismEnum ismOpenMode, CMsiStorage* piParent, bool fFile);
 protected:
  ~CMsiStorage();  // protected to prevent creation on stack
 public: // for use by members of this and stream classes
	ismEnum GetOpenMode();
	void StreamCreated(CMsiStream& riStream);
	void StreamReleased(CMsiStream& riStream);
	void FlushStreams();
 private:
	CMsiRef<iidMsiStorage>   m_Ref;      // COM reference count
	IStorage& m_riStorage;
	CMsiStorage* m_piParent;
	CMsiStream*  m_piStreams;  // list of active streams
	ismEnum   m_ismOpenMode;
	Bool      m_fCommit;
	idorEnum  m_idorDeleteOnRelease;
	bool	    m_fNetworkFile;
	bool	    m_fRawStreamNames;
#ifdef USE_OBJECT_POOL
	unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
 private: // eliminate warning: assignment operator could not be generated
	void operator =(const CMsiStorage&){}
};
inline void*   CMsiStorage::operator new(size_t cb) {return AllocObject(cb);}
inline void    CMsiStorage::operator delete(void * pv) { FreeObject(pv); }
inline ismEnum CMsiStorage::GetOpenMode() { return m_ismOpenMode; }

const int cbMinReadDirect = 512;
const int cbBufferSize	= 1024;

class CMsiStreamBuffer : public IMsiStream
{
 public:
	short         __stdcall GetInt16();
	int           __stdcall GetInt32();
	void          __stdcall PutInt16(short i);
	void          __stdcall PutInt32(int i);
	unsigned int  __stdcall GetData(void* pch, unsigned int cb);
	void 		  __stdcall PutData(const void* pch, unsigned int cb);
	Bool		  __stdcall Error();
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
 protected:
 	CMsiStreamBuffer();
 #ifdef USE_OBJECT_POOL
 	~CMsiStreamBuffer();
 #endif //USE_OBJECT_POOL
	unsigned int  m_cbCopied;
	char          m_rgbBuffer[cbBufferSize]; // local buffer for performance
	unsigned long m_cbBuffer;  // bytes read into buffer
	unsigned long m_cbUsed;    // bytes currently used in buffer
	issEnum       m_issState;
	Bool                m_fWrite;
	unsigned int        m_cbLength;
#ifdef USE_OBJECT_POOL
 private:
	unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
 protected:
	virtual HRESULT __stdcall Read(void *pv, unsigned long cb, unsigned long *pcbRead) = 0;
};

class CMsiStream : public CMsiStreamBuffer
{
 public:  // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
	unsigned int  __stdcall Remaining() const;
	void          __stdcall Reset();
	void          __stdcall Seek(int position);
	IMsiStream*   __stdcall Clone();
 	void          __stdcall Flush();
	HRESULT 	  __stdcall Read(void *pv, unsigned long cb, unsigned long *pcbRead);
 public: // constructor, destructor
	void* operator new(size_t cb);
	void  operator delete(void * pv);
	CMsiStream(CMsiStorage& riStorage, IStream& riStream, Bool fWrite);
 protected:
  ~CMsiStream();  // protected to prevent creation on stack
 private:  // internal functions
	CMsiRef<iidMsiStream>	m_Ref;      // COM reference count
	CMsiStorage&  m_riStorage;
	CMsiStream*   m_piNextStream;  // link list, maintained by CMsiStorage
	IStream&      m_riStream;
 private: // eliminate warning: assignment operator could not be generated
	void operator =(const CMsiStream&){}
	friend class CMsiStorage;  // access to linked list
};
inline void* CMsiStream::operator new(size_t cb) {return AllocObject(cb);}
inline void  CMsiStream::operator delete(void * pv) { FreeObject(pv); }

inline void  CMsiStorage::StreamCreated(CMsiStream& riStream)
	{riStream.m_piNextStream = m_piStreams; m_piStreams = &riStream;}
inline void  CMsiStorage::StreamReleased(CMsiStream& riStream)
{
	for (CMsiStream** ppPrev = &m_piStreams;
						 *ppPrev != &riStream;
						  ppPrev = &((*ppPrev)->m_piNextStream))
		if (*ppPrev == 0)
		{
			AssertSz(0, "Stream unlink error");
			break;
		}
	*ppPrev = riStream.m_piNextStream;
}

//____________________________________________________________________________
//
//  Definitions for Summary Stream
//____________________________________________________________________________

const unsigned int iFileTimeDosBaseLow  = 0xE1D58000L;
const unsigned int iFileTimeDosBaseHigh = 0x01A8E79FL;
const unsigned int iFileTimeOneDayLow   = 0x2A69C000L;
const unsigned int iFileTimeOneDayHigh  = 0x000000C9L;

const int cbSummaryHeader = 48;
const int cbSectionHeader = 2 * sizeof(int);  // section size + property count

static const ICHAR szSummaryStream[] = TEXT("\005SummaryInformation");
static const unsigned char fmtidSummaryStream[16] =
		{ 0xE0, 0x85, 0x9F, 0xF2, 0xF9, 0x4F, 0x68, 0x10,
		  0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9 };
static const char fmtidSourceClsid[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
const int PID_Deleted = -1;

struct PropertyData
{
	int iPID;     // property ID, PID_XXX
	int iType;    // data type, VT_XXX
	union
	{
		int cbText;     // if VT_LPSTR
		int iLow;       // if VT_FILETIME
		int iValue;     // if VT_I4
	};
	union
	{
		const IMsiString* piText;  // if VT_LPSTR
		int iHigh;           // if VT_FILETIME
	};
};

class CMsiSummaryInfo : public IMsiSummaryInfo
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	int           __stdcall GetPropertyCount();
	int           __stdcall GetPropertyType(int iPID); // returns VT_XXX
	const IMsiString&   __stdcall GetStringProperty(int iPID);
	Bool          __stdcall GetIntegerProperty(int iPID, int& iValue);
	Bool          __stdcall GetTimeProperty(int iPID, MsiDate& riDateTime);
	Bool          __stdcall RemoveProperty(int iPID);
	int           __stdcall SetStringProperty(int iPID, const IMsiString& riText);
	int           __stdcall SetIntegerProperty(int iPID, int iValue);
	int           __stdcall SetTimeProperty(int iPID, MsiDate iDateTime);
	Bool          __stdcall WritePropertyStream();
	Bool          __stdcall GetFileTimeProperty(int iPID, FILETIME& rftDateTime);
	int           __stdcall SetFileTimeProperty(int iPID, FILETIME& rftDateTime);
 public: // constructor
	static IMsiRecord* Create(CMsiStorage& riStorage, unsigned int cMaxProperties,
									  IMsiSummaryInfo*& rpiSummary);
	void* operator new(size_t iBase, unsigned int cbStream, unsigned int cMaxProperties);
	void* operator new(size_t cb);
	void  operator delete(void * pv);
	CMsiSummaryInfo(unsigned int cbStream, unsigned int cMaxProperties);
 protected:
  ~CMsiSummaryInfo();  // protected to prevent creation on stack
 private:
	int  GetInt32(int* p);  // accessor that swaps bytes on Mac
	int  GetInt16(int* p);  // accessor that swaps bytes on Mac
	int*          FindOldProperty(int iPID);
	PropertyData* FindNewProperty(int iPID);
	PropertyData* GetPropertyData();
	void operator=(CMsiSummaryInfo&); // avoid warning
 private:
	unsigned int m_iRefCnt;
	int          m_iCodepage;
	unsigned int m_cbStream;
	void*        m_pvStream;
	unsigned int m_cOldProp;
	unsigned int m_cDeleted;
	unsigned int m_cNewProp;
	char*        m_pbSection;
	int*         m_pPropertyIndex;
	IMsiStream*  m_piStream;
	unsigned int m_cMaxProp;
	unsigned int m_cbSection;
};
inline void* CMsiSummaryInfo::operator new(size_t iBase, unsigned int cbStream, unsigned int cMaxProperties)
	{return CMsiSummaryInfo::operator new(iBase + cbStream + cMaxProperties * sizeof(PropertyData));}
inline void* CMsiSummaryInfo::operator new(size_t cb) {return AllocObject(cb);}
inline void  CMsiSummaryInfo::operator delete(void * pv) { FreeObject(pv); }
inline PropertyData* CMsiSummaryInfo::GetPropertyData() { return (PropertyData*)(this + 1); }
	
inline int CMsiSummaryInfo::GetInt32(int* p) {return *p;}
inline int CMsiSummaryInfo::GetInt16(int* p) {return (int)*(short*)p;}

//____________________________________________________________________________
//
//  Implementation of CMsiStreamBuffer
//____________________________________________________________________________

CMsiStreamBuffer::CMsiStreamBuffer()
	: m_cbCopied(0)
	, m_issState(issReset)
{
#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}

#ifdef USE_OBJECT_POOL
CMsiStreamBuffer::~CMsiStreamBuffer()
{
	RemoveObjectData(m_iCacheId);
}
#endif //USE_OBJECT_POOL

Bool CMsiStreamBuffer::Error()
{
	return (m_issState == issError ? fTrue : fFalse);
}


short CMsiStreamBuffer::GetInt16()
{
	short i = 0; // default value in case error
	CMsiStreamBuffer::GetData(&i, sizeof(i));
	return i;
}

int CMsiStreamBuffer::GetInt32()
{
	int i = 0; // default value in case error
	CMsiStreamBuffer::GetData(&i, sizeof(i));
	return i;
}

void CMsiStreamBuffer::PutInt16(short i)
{
	CMsiStreamBuffer::PutData(&i, sizeof(i));
}

void CMsiStreamBuffer::PutInt32(int i)
{
	CMsiStreamBuffer::PutData(&i, sizeof(i));
}


unsigned int CMsiStreamBuffer::GetData(void* pch, unsigned int cb)
{
	if (m_issState != issRead) // first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbBuffer = m_cbUsed = sizeof(m_rgbBuffer);
	}
	int cbCopied = 0;
	while (cb)
	{
		int cbCopy = m_cbBuffer - m_cbUsed;
		if (!cbCopy)
		{
			if (m_cbBuffer < sizeof(m_rgbBuffer))
			{
				m_issState = issError;
				break;
			}

			if (cb >= cbMinReadDirect)
			{			
				unsigned long cbRead;
				
				if (Read(pch, cb, &cbRead) != 0)
				{
					m_issState = issError;
					return 0;
				}
				cbCopied += cbRead;
				cb -= cbRead;
				if (cb > 0)
				{
					m_issState = issError;
				}
				break;
			}
			else
			{
				if (Read(m_rgbBuffer, sizeof(m_rgbBuffer), &m_cbBuffer) != 0)
				{
					m_issState = issError;
					return 0;
				}
				m_cbUsed = 0;
			}
			continue;
		}
		if (cbCopy > cb)
			cbCopy = cb;
		memcpy(pch, &m_rgbBuffer[m_cbUsed], cbCopy);
		m_cbUsed += cbCopy;
		cb -= cbCopy;
		cbCopied += cbCopy;
		*(char**)&pch += cbCopy;
	}
	m_cbCopied += cbCopied;
	return cbCopied;
}

void CMsiStreamBuffer::PutData(const void* pch, unsigned int cb)
{
	if (m_issState != issWrite) // first write
	{
		if (!m_fWrite || m_issState != issReset)
		{
			m_issState = issError;
			return;
		}
		m_issState = issWrite;
		m_cbLength = m_cbCopied = m_cbUsed = 0;
	}
	m_cbLength += cb;
	while (cb)
	{
		int cbCopy = sizeof(m_rgbBuffer) - m_cbUsed;
		if (cb >= cbCopy)
		{
			memcpy(&m_rgbBuffer[m_cbUsed], pch, cbCopy);
			m_cbUsed += cbCopy;
			Flush();
			cb -= cbCopy;
			*(char**)&pch += cbCopy;
		}
		else
		{
			memcpy(&m_rgbBuffer[m_cbUsed], pch, cb);
			m_cbUsed += cb;
			return;
		}
	}
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiStreamBuffer::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiStreamBuffer::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL



//____________________________________________________________________________
//
//  Implementation of CMsiStream
//____________________________________________________________________________

const GUID IID_IMsiStream     = GUID_IID_IMsiStream;
const GUID IID_IMsiMemoryStream = GUID_IID_IMsiMemoryStream;
const GUID IID_IMsiStorage    = GUID_IID_IMsiStorage;

CMsiStream::CMsiStream(CMsiStorage& riStorage, IStream& riStream, Bool fWrite)
	: m_riStorage(riStorage)
	, m_riStream(riStream)
{  // m_cbBuffer and m_cbUsed initialized at first read/write
	m_fWrite = fWrite;
	if (fWrite)
	{
		m_cbLength = 0;
		riStorage.StreamCreated(*this);
	}
	else
	{
		STATSTG statstg;
		HRESULT hres = riStream.Stat(&statstg, STATFLAG_NONAME);
		m_cbLength = statstg.cbSize.LowPart;
	}
	m_riStorage.AddRef();
	Debug(m_Ref.m_pobj = this);
}

CMsiStream::~CMsiStream()
{
	m_riStream.Release();
}

HRESULT CMsiStream::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiStream)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiStream::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiStream::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	Flush();
	CMsiStorage& riStorage = m_riStorage;
	if (m_fWrite)
		riStorage.StreamReleased(*this);
	delete this;
	riStorage.Release();
	return 0;
}

const IMsiString& CMsiStream::GetMsiStringValue() const
{
	const IMsiString* piString;
	IStream* piClone;
	unsigned long cbRead;
	ICHAR* pch;
	if (m_cbLength == 0 || m_fWrite || m_riStream.Clone(&piClone) != NOERROR)
		return SRV::CreateString();
#ifdef UNICODE
	CTempBuffer<char, 1024> rgchBuf;
	rgchBuf.SetSize(m_cbLength);
	if ( ! (char *) rgchBuf )
		return SRV::CreateString();
	piClone->Read(rgchBuf, m_cbLength, &cbRead);
	piClone->Release();
	if (cbRead != m_cbLength)
		return SRV::CreateString();
	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, m_cbLength, 0, 0); //!! should use m_iCodepage from database, but how?
	pch = SRV::AllocateString(cch, fFalse, piString);
	if ( ! pch )
		return SRV::CreateString();
	WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, m_cbLength, pch, cch);
#else
	// stream could have DBCS chars -- we can't tell prior to copying the stream,
	// so instead we will default to fDBCS = fTrue in the ANSI build and take
	// the performance hit to guarantee DBCS is supported
	pch = SRV::AllocateString(m_cbLength, /*fDBCS=*/fTrue, piString);
	if ( ! pch )
		return SRV::CreateString();
	piClone->Read(pch, m_cbLength, &cbRead);
	piClone->Release();
	if (cbRead != m_cbLength)
	{
		piString->Release();
		return SRV::CreateString();
	}
#endif
	return *piString;
}

int CMsiStream::GetIntegerValue() const
{
	return m_cbLength;
}

unsigned int CMsiStream::Remaining() const
{
	return m_cbLength - m_cbCopied;
}

HRESULT CMsiStream::Read(void *pv, unsigned long cb, unsigned long *pcbRead)
{
	return m_riStream.Read(pv, cb, pcbRead);
}

LARGE_INTEGER liZero = {0,0};

void CMsiStream::Reset()
{
	Flush();
	m_riStream.Seek(liZero, STREAM_SEEK_SET, 0);
	m_cbCopied = 0;
	m_issState = issReset;
}

void CMsiStream::Seek(int position)
{
	LARGE_INTEGER liPos = {position,0};
	ULARGE_INTEGER liNewPos;
	Flush();
	if((m_riStream.Seek(liPos, STREAM_SEEK_SET, &liNewPos)) != S_OK)
	{
		m_issState = issError;
		return;
	}
	m_cbCopied = liNewPos.LowPart;
}

void CMsiStream::Flush()
{
	if (m_issState == issWrite && m_cbUsed != 0)
	{
		unsigned long cbWritten = 0;
		m_riStream.Write(m_rgbBuffer, m_cbUsed, &cbWritten);
		if (cbWritten != m_cbUsed)
			m_issState = issError;
		m_cbCopied += cbWritten;
		m_cbUsed = 0;
	}
	else if (m_issState == issRead)
		m_cbUsed = m_cbBuffer = sizeof(m_rgbBuffer);
}

IMsiStream* CMsiStream::Clone()
{
	IStream* piStream;
	if (m_riStream.Clone(&piStream) != NOERROR)
		return 0;
	if (piStream == 0)   // only fails if reverted above or out of memory
		return 0;
	piStream->Seek(liZero, STREAM_SEEK_SET, 0);
	return new CMsiStream(m_riStorage, *piStream, m_fWrite);
}

//____________________________________________________________________________
//
//  Implementation of CMsiStorage
//____________________________________________________________________________

static const ICHAR* rgszSysTableNames[] =  // list of system streams, null terminated
{
	szMsiInfo,
	szTableCatalog,
	szColumnCatalog,
	szStringPool,
	szStringData,
	0
};

// Create read-only storage on ILockBytes, which in turn is implemented on a stream
IMsiRecord* CreateMsiStorage(ILockBytes* piLockBytes, IMsiStorage*& rpiStorage)
{
	IStorage* piStorage;
	DWORD grfMode = STGM_READ | STGM_SHARE_EXCLUSIVE;
	HRESULT hres = OLE32::StgOpenStorageOnILockBytes(piLockBytes, (IStorage*)0, grfMode, (SNB)0, 0, &piStorage);
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbOpenStorage), TEXT("ILockBytes"), hres); //?? no name
	rpiStorage = new CMsiStorage(*piStorage, ismReadOnly, 0, false);
	piStorage->Release();
	return 0;
}

IMsiRecord* CreateMsiStorage(const char* pchMem, unsigned int iSize, IMsiStorage*& rpiStorage)
{
	CComPointer<ILockBytes> pLockBytes(new CMsiLockBytes(pchMem, iSize));
	return CreateMsiStorage(pLockBytes, rpiStorage);
};

// Create a storage on a stream, read-only
IMsiRecord* CreateMsiStorage(IMsiStream& riStream, IMsiStorage*& rpiStorage)
{
	CComPointer<ILockBytes> pLockBytes(new CMsiLockBytes(riStream));
	return CreateMsiStorage(pLockBytes, rpiStorage);
};

HRESULT OpenRootStorage(const ICHAR* szPath, ismEnum ismOpenMode, IStorage** ppiStorage)
{
	HRESULT hres = 0; //prevent warning
	const OLECHAR* pPathBuf;

	if (!szPath || IStrLen(szPath) > MAX_PATH)
		return STG_E_PATHNOTFOUND;

#ifdef UNICODE
	pPathBuf = szPath;
#else
	OLECHAR rgPathBuf[MAX_PATH];
	int cchWide = MultiByteToWideChar(CP_ACP, 0, szPath, -1, rgPathBuf, MAX_PATH);
	pPathBuf = rgPathBuf;
#endif

	
	// Even when STGM_SHARE_DENY_WRITE used with ismTransact, read permission is not granted

	// According to "8.3 Storage-related Functions and Interfaces" in "Specs: OLE 2.0 Design",
	// in the present Docfile implementation, direct mode on root level storage objects is
	// only supported with the simultaneous additional specification of:
	//
	// STGM_READ      | STGM_SHARE_DENY_WRITE, or
	// STGM_READWRITE | STGM_SHARE_EXCLUSIVE , or
	// STGM_PRIORITY  | STGM_READ

	DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE; // initialize for ismDirect
	int cRetry;
	switch (ismOpenMode)
	{
	case ismCreate:
		grfMode |= STGM_TRANSACTED;  // fall through to case ismCreateDirect
	case ismCreateDirect:
		hres = OLE32::StgCreateDocfile(pPathBuf, grfMode | STGM_CREATE, 0, ppiStorage);
		break;
	case ismReadOnly:
		grfMode  = STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READ;  // fall through, STGM_TRANSACTED and STGM_SHARE_EXCLUSIVE turned off below
	case ismTransact:
		grfMode ^= STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_SHARE_DENY_WRITE; // fall through, STGM_SHARE_EXCLUSIVE turned off below
	case ismDirect:
		cRetry = 0;
		do
		{
			if (cRetry)
				WIN::Sleep(cRetry);
			hres = OLE32::StgOpenStorage(pPathBuf, (IStorage*)0, grfMode, (SNB)0, 0, ppiStorage);
		} while (hres == STG_E_LOCKVIOLATION && (cRetry+=10) <= 200);  // keep adding time on each retry
		break;
	default: 
		Assert(0);
		hres = E_INVALIDARG;
	};
	return hres;
}

IMsiRecord* CreateMsiStorage(const ICHAR* szPath, ismEnum ismOpenMode, IMsiStorage*& rpiStorage)
{
	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(szPath) == fTrue) ? fTrue : fFalse;
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	IStorage* piStorage;
	HRESULT hres = OpenRootStorage(szPath, ismEnum(ismOpenMode & idoOpenModeMask), &piStorage);
	if(fImpersonate)
		StopImpersonating();
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbOpenStorage), szPath, hres);
	rpiStorage = new CMsiStorage(*piStorage, ismOpenMode, 0, true);
	piStorage->Release();
	return 0;
}

CMsiStorage::CMsiStorage(IStorage& riStorage, ismEnum ismOpenMode, CMsiStorage* piParent, bool fFile)
	: m_riStorage(riStorage), m_ismOpenMode(ismEnum(ismOpenMode & idoOpenModeMask)), m_piParent(piParent),
	  m_fCommit(fFalse), m_idorDeleteOnRelease(idorDontDelete), m_piStreams(0)
{
	m_fRawStreamNames = (ismOpenMode & ismRawStreamNames) != 0 || GetTestFlag('Z'); //!! temp option to force old storage name format
	riStorage.AddRef();
	g_cInstances++;
	AddRefAllocator();
	if (piParent)
		piParent->AddRef();  // hold parent until we're released
	Debug(m_Ref.m_pobj = this);

	m_fNetworkFile = false;
	
	if (fFile)
	{
		MsiString riString;

		AssertRecord(GetName(*&riString));
		// Is this open across a network?

		if (FIsNetworkVolume(riString))
		{
			LOC::SetNoPowerdown();
			m_fNetworkFile = true;
		}
	}

#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}

CMsiStorage::~CMsiStorage()
{
	MsiString strStorageName;
	IMsiRecord* piError = Commit();  // flush an uncommited data to storage, should rollback instead?
	if (piError)
		SRV::SetUnhandledError(piError);
	Assert(m_piStreams == 0);
	if (m_fNetworkFile)
	{
		ClearNoPowerdown();
	}
	if (m_idorDeleteOnRelease != idorDontDelete)
	{
		// attempt remove created file or substorage, no error if failure
		AssertRecord(this->GetName(*&strStorageName));
		m_riStorage.Release();  // must release before file or storage can be deleted
		if (m_piParent)
			m_piParent->m_riStorage.DestroyElement(CConvertString((const ICHAR*)strStorageName));
		else
		{
			CElevate(m_idorDeleteOnRelease == idorElevateAndDelete &&
						false == GetImpersonationFromPath(strStorageName));

			DWORD dwRes = WIN::DeleteFile((const ICHAR*)strStorageName);
			if (dwRes == 0)
				SRV::SetUnhandledError(LOC::PostError(Imsg(idbgStgDelete), *strStorageName, GetLastError()));
		}
	}
	else // root file, not rolled back
		m_riStorage.Release();

	if (m_piParent)
		m_piParent->Release();  // now we can release parent

	RemoveObjectData(m_iCacheId);
}

HRESULT CMsiStorage::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiStorage))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiStorage::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiStorage::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	delete this;
	
	// These two lines are needed since CMsiStorage is an object in
	// the services dll but is independant of services
	// We need to do this after the memory is released
	ReleaseAllocator();
	g_cInstances--;
	return 0;
}

const IMsiString& CMsiStorage::GetMsiStringValue() const
{
	return g_MsiStringNull;
}

int CMsiStorage::GetIntegerValue() const
{
	return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiStorage::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiStorage::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL


const int cchEncode = 64;  // count of set of characters that can be compressed
const int cx = cchEncode;  // character to indicate non-compressible
const int chDoubleCharBase = 0x3800;  // offset for double characters, abandoned Hangul Unicode block
const int chSingleCharBase = chDoubleCharBase + cchEncode*cchEncode;  // offset for single characters, just after double characters
const int chCatalogStream  = chSingleCharBase + cchEncode; // prefix character for system table streams
const int cchMaxStreamName = 31;  // current OLE docfile limit on stream names

const unsigned char rgDecode[cchEncode] = 
{ '0','1','2','3','4','5','6','7','8','9',
  'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
  'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
  '.' , '_' };

const unsigned char rgEncode[128] =
{ cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,62,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,
  cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,62,cx, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,cx,cx,cx,cx,cx,cx,
//(sp)!  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?
  cx,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,cx,cx,cx,cx,63,
// @, A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _ 
  cx,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,cx,cx,cx,cx,cx};
// ` a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~ 0x7F

bool CompressStreamName(const OLECHAR* pchIn, OLECHAR* pchOut, int fSystem)  // pchOut must be cchMaxStreamName characters + 1
{
	unsigned int ch, ch1, ch2;
	unsigned int cchLimit = cchMaxStreamName;
	if (fSystem)
	{
		*pchOut++ = chCatalogStream;
		cchLimit--;
	}
	while ((ch = *pchIn++) != 0)
	{
		if (cchLimit-- == 0)  // need check to avoid 32-character stream name bug in OLE32
			return false;
		if (ch < sizeof(rgEncode) && (ch1 = rgEncode[ch]) != cx) // compressible character
		{
			ch = ch1 + chSingleCharBase;
			if ((ch2 = *pchIn) != 0 && ch2 < sizeof(rgEncode) && (ch2 = rgEncode[ch2]) != cx)
			{
				pchIn++;  // we'll take it, else let it go through the loop again
				ch += (ch2 * cchEncode + chDoubleCharBase - chSingleCharBase);
			}
		}
		*pchOut++ = (OLECHAR)ch;
	}
	*pchOut = 0;
	return true;
}

int UncompressStreamName(const OLECHAR* pchIn, OLECHAR* pchOut)  // pchOut must be cchMaxStreamName*2 characters + 1
{
	unsigned int ch;
	int cch = 0;
	while ((ch = *pchIn++) != 0)
	{
		if (ch >= chDoubleCharBase && ch < chCatalogStream) // chCatalogStream tested before calling this function
		{
			if (ch >= chSingleCharBase)
				ch = rgDecode[ch - chSingleCharBase];
			else
			{
				ch -= chDoubleCharBase;
				*pchOut++ = OLECHAR(rgDecode[ch % cchEncode]);
				cch++;
				ch = rgDecode[ch / cchEncode];
			}
		}
		*pchOut++ = OLECHAR(ch);
		cch++;
	}
	*pchOut = 0;
	return cch;
}

IMsiRecord* CMsiStorage::OpenStream(const ICHAR* szName, Bool fWrite,
												IMsiStream*& rpiStream)
{
	HRESULT hres;
	bool fStat;
	OLECHAR rgPathBuf[cchMaxStreamName*2 + 1 + 1];
	const OLECHAR* pchName;
#ifdef UNICODE
	if (m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = szName;
		fStat = lstrlenW(szName) <= cchMaxStreamName;
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(szName, rgPathBuf, fWrite & iCatalogStreamFlag);
	}
#else // !UNICODE
	int cch = MultiByteToWideChar(CP_ACP, 0, szName, -1, rgPathBuf + 1, cchMaxStreamName*2 + 1);
	if (m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = rgPathBuf + 1;
		fStat = (cch > 0);
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(rgPathBuf + 1, rgPathBuf, fWrite & iCatalogStreamFlag);
	}
#endif
	if (fStat == false)
		return LOC::PostError(Imsg(idbgStgInvalidStreamName), szName);

	IStream* piStream;
	if (fWrite & fTrue)
	{
		hres = m_riStorage.CreateStream(pchName,
						STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
						0, 0, &piStream);
	}
	else // open for read
	{
		hres = m_riStorage.OpenStream(pchName,0,
						STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piStream);
	}
	if (hres != NOERROR)
	{
		rpiStream = 0;
		return LOC::PostError(hres == STG_E_FILENOTFOUND ? Imsg(idbgStgStreamMissing)
														 : Imsg(idbgStgOpenStream), szName, hres);
	}
	rpiStream = new CMsiStream(*this, *piStream, Bool(fWrite & fTrue));
	return 0;
}

IMsiRecord* CMsiStorage::RemoveElement(const ICHAR* szName, Bool fStorage)
{
	bool fStat;
	OLECHAR rgPathBuf[cchMaxStreamName*2 + 1 + 1];
	const OLECHAR* pchName;
#ifdef UNICODE
	if ((fStorage & fTrue) || m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = szName;
		fStat = lstrlenW(szName) <= cchMaxStreamName;
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(szName, rgPathBuf, fStorage & iCatalogStreamFlag);
	}
#else // !UNICODE
	int cch = MultiByteToWideChar(CP_ACP, 0, szName, -1, rgPathBuf + 1, cchMaxStreamName*2 + 1);
	if ((fStorage & fTrue) || m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = rgPathBuf + 1;
		fStat = (cch > 0);
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(rgPathBuf + 1, rgPathBuf, fStorage & iCatalogStreamFlag);
	}
#endif
	if (fStat == false)
		return LOC::PostError(Imsg(idbgStgInvalidStreamName), szName);
	HRESULT hres = m_riStorage.DestroyElement(pchName);
	if (hres != NOERROR)
		return LOC::PostError(hres == STG_E_FILENOTFOUND ? Imsg(idbgStgStreamMissing)
														 : Imsg(idbgStgOpenStream), szName, hres);
	return 0;
}

IMsiRecord* CMsiStorage::RenameElement(const ICHAR* szOldName, const ICHAR* szNewName, Bool fStorage)
{
	bool fStat;
	OLECHAR rgOldBuf[cchMaxStreamName*2 + 1 + 1];
	OLECHAR rgNewBuf[cchMaxStreamName*2 + 1 + 1];
	const OLECHAR* pchOldName;
	const OLECHAR* pchNewName;
#ifdef UNICODE
	if ((fStorage & fTrue) || m_fRawStreamNames || szOldName[0] == '\005')
	{
		pchOldName = szOldName;
		fStat = lstrlenW(szOldName) <= cchMaxStreamName;
	}
	else
	{
		pchOldName = rgOldBuf;
		fStat = CompressStreamName(szOldName, rgOldBuf, fStorage & iCatalogStreamFlag);
	}
	if ((fStorage & fTrue) || m_fRawStreamNames || szNewName[0] == '\005')
	{
		pchNewName = szNewName;
		fStat = fStat && lstrlenW(szNewName) <= cchMaxStreamName;
	}
	else
	{
		pchNewName = rgNewBuf;
		fStat = fStat && CompressStreamName(szNewName, rgNewBuf, fStorage & iCatalogStreamFlag);
	}
#else // !UNICODE
	int cchOld = MultiByteToWideChar(CP_ACP, 0, szOldName, -1, rgOldBuf + 1, cchMaxStreamName*2 + 1);
	if ((fStorage & fTrue) || m_fRawStreamNames || szOldName[0] == '\005')
	{
		pchOldName = rgOldBuf + 1;
		fStat = (cchOld > 0);
	}
	else
	{
		pchOldName = rgOldBuf;
		fStat = CompressStreamName(rgOldBuf + 1, rgOldBuf, fStorage & iCatalogStreamFlag);
	}
	int cchNew = MultiByteToWideChar(CP_ACP, 0, szNewName, -1, rgNewBuf + 1, cchMaxStreamName*2 + 1);
	if ((fStorage & fTrue) || m_fRawStreamNames || szNewName[0] == '\005')
	{
		pchNewName = rgNewBuf + 1;
		fStat = fStat && (cchNew > 0);
	}
	else
	{
		pchNewName = rgNewBuf;
		fStat = fStat && CompressStreamName(rgNewBuf + 1, rgNewBuf, fStorage & iCatalogStreamFlag);
	}
#endif
	if (fStat == false)
		return LOC::PostError(Imsg(idbgStgInvalidStreamName), szNewName);
	HRESULT hres = m_riStorage.RenameElement(pchOldName, pchNewName);
	if (hres != NOERROR)
		return LOC::PostError(hres == STG_E_FILENOTFOUND ? Imsg(idbgStgStreamMissing)
														 : Imsg(idbgStgRenameElement), szOldName, hres);
	return 0;
}

Bool CMsiStorage::DeleteOnRelease(bool fElevateToDelete)
{
	m_idorDeleteOnRelease = fElevateToDelete ? idorElevateAndDelete : idorDelete;
	return fTrue;
}

IMsiRecord* CMsiStorage::OpenStorage(const ICHAR* szName, ismEnum ismOpenMode, IMsiStorage*& rpiStorage)
{
	HRESULT hres = 0; //prevent warning
	IStorage* piStorage = NULL;
	if (szName == 0) // null name, mechanism for setting open non-OLE attributes after open
	{
		if ((ismOpenMode & idoOpenModeMask) == 0)
		{
			m_fRawStreamNames = true;
			return 0;
		}
	}	// else allow to fail below

// STGM_SHARE_DENY_WRITE doesn't work, gives a grf flags wrong error
	DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
	switch (ismOpenMode)
	{
	case ismCreate:  // seems to be OK if child specifies transacted with direct mode parent
		grfMode |= STGM_TRANSACTED;  // fall through to case ismCreateDirect
	case ismCreateDirect:
		hres = m_riStorage.CreateStorage(CConvertString(szName), grfMode | STGM_CREATE, /*dwStgFmt*/0, 0, &piStorage);
		break;
	case ismReadOnly:
		grfMode ^= (STGM_TRANSACTED ^ STGM_READ ^ STGM_READWRITE); // fall through
	case ismTransact:
		grfMode ^= STGM_TRANSACTED;  // fall through
	case ismDirect:
		hres = m_riStorage.OpenStorage(CConvertString(szName), (IStorage*)0, grfMode, (SNB)0, 0, &piStorage);
		break;
	default: 
		Assert(0);
		hres = E_INVALIDARG;
	};
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbOpenStorage), szName, hres);
		
	rpiStorage = new CMsiStorage(*piStorage, ismOpenMode, this, false);
	piStorage->Release();
	
	return 0;
}

IMsiRecord* CMsiStorage::SetClass(const IID& riid)
{
	HRESULT hres = m_riStorage.SetClass(riid);
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbCommitTables), 0, hres);
	return 0;
}

Bool CMsiStorage::GetClass(IID* piid)
{
	STATSTG statstg;
	HRESULT hres = m_riStorage.Stat(&statstg, STATFLAG_NONAME);
	if (hres != NOERROR)
		memcpy((void*)&statstg.clsid, &IID_NULL, sizeof(GUID));
	if (piid)
		memcpy(piid, &statstg.clsid, sizeof(GUID));
	return (memcmp(&statstg.clsid, &IID_NULL, sizeof(GUID)) ? fTrue : fFalse);
}

IMsiRecord* CMsiStorage::Rollback()
{
	if (m_ismOpenMode != ismReadOnly)
	{
		for (CMsiStream** ppPrev = &m_piStreams;
							  *ppPrev != 0;
								ppPrev = &((*ppPrev)->m_piNextStream))
			(*ppPrev)->Flush();
		HRESULT hres = m_riStorage.Revert();
		if (hres != NOERROR)
			return LOC::PostError(Imsg(idbgStgRollback), 0, hres);
	}
	if (!m_fCommit && m_ismOpenMode == ismCreate) // rollback created root file
		m_idorDeleteOnRelease = idorDelete;
	return 0;
}

IMsiRecord* CMsiStorage::Commit()
{
	if (m_ismOpenMode != ismReadOnly)
	{
		for (CMsiStream** ppPrev = &m_piStreams;
							  *ppPrev != 0;
								ppPrev = &((*ppPrev)->m_piNextStream))
			(*ppPrev)->Flush();
		HRESULT hres = m_riStorage.Commit(STGC_OVERWRITE);
		if (hres != NOERROR)
			return LOC::PostError(Imsg(idbgStgCommit), 0, hres);
	}
	m_fCommit = fTrue;
	return 0;
}

IMsiRecord* CMsiStorage::CreateSummaryInfo(unsigned int cMaxProperties,
														 IMsiSummaryInfo*& rpiSummary)
{
	return CMsiSummaryInfo::Create(*this, cMaxProperties, rpiSummary);
}

IMsiRecord* CMsiStorage::CopyTo(IMsiStorage& riDestStorage, IMsiRecord* piExcludedStreams) // could add another arg for excluded storages
{
	WCHAR** snbExclude = 0;
	CTempBuffer<WCHAR, MAX_PATH> SNB;

	if (piExcludedStreams)
	{
		// we need to create a String Name Block. See MSDN (under "SNB") for details

		unsigned int cString = piExcludedStreams->GetFieldCount();
		unsigned int cchStrings = 0;
		CTempBuffer<size_t, 10> rgcchLengths;
		if ( rgcchLengths.GetSize() < cString+1 )
			rgcchLengths.SetSize(cString+1);

		for (int c = 1; c <= cString; c++)
		{
			rgcchLengths[c] = MsiString(piExcludedStreams->GetMsiString(c)).TextSize() + 1;
			cchStrings += rgcchLengths[c];
		}

		unsigned int cchSNB = (cString+1)*sizeof(WCHAR*)/sizeof(WCHAR) + cchStrings + 1; // extra char for compressions inplace
		if (SNB.GetSize() < cchSNB)
			SNB.SetSize(cchSNB);

		snbExclude = (WCHAR**)(WCHAR*)SNB; // do this _after_ we've resized the buffer
		
		WCHAR* psz = (WCHAR*)(((WCHAR**)(WCHAR*)SNB)+(cString+1)) + 1; // offset by 1 for compression inplace
		WCHAR** ppsz = (WCHAR**)(WCHAR*)SNB;

		for (c = 1; c <= cString; c++)
		{
			WCHAR* pch = psz;  // final location of processed stream name
			ASSERT_IF_FAILED(StringCchCopyW(psz,
													  rgcchLengths[c],
													  CConvertString(piExcludedStreams->GetString(c))));
			if (!m_fRawStreamNames && psz[0] != '\005')
				CompressStreamName(psz, --pch, 0);  // never can exclude system streams
			*ppsz++ = pch;
			psz += (lstrlenW(pch) + 1);
		}
		*ppsz = 0;
	}

	HRESULT hRes = m_riStorage.CopyTo(0, 0, snbExclude, 
									   &(static_cast<CMsiStorage*>(&riDestStorage)->m_riStorage));
	if (hRes != NOERROR)
		return LOC::PostError(Imsg(idbgStgCopyTo), 0, hRes);

	return 0;
}

IMsiRecord* CMsiStorage::GetName(const IMsiString*& rpiName)
{
	STATSTG statstg;
	HRESULT hRes = m_riStorage.Stat(&statstg, STATFLAG_DEFAULT); // retrieve file name
	if (ERROR_SUCCESS != hRes)
		return LOC::PostError(Imsg(idbgStgStatFailed), 0, hRes);

	MsiString(CConvertString(statstg.pwcsName)).ReturnArg(rpiName);
	IMalloc* piMalloc;
	AssertZero(OLE32::CoGetMalloc(MEMCTX_TASK, &piMalloc));
	piMalloc->Free(statstg.pwcsName);
	piMalloc->Release();
	return 0;
}

IMsiRecord* CMsiStorage::GetSubStorageNameList(const IMsiString*& rpiTopParent, const IMsiString*& rpiSubStorageList)
{
	MsiString strName;

	IMsiRecord* piError = GetName(*&strName);
	if(piError)
		return piError;

	if(!m_piParent)
	{
		// top-level storage
		strName.ReturnArg(rpiTopParent);
		MsiString strNull;
		strNull.ReturnArg(rpiSubStorageList);
		return 0;
	}
	else
	{
		// sub-storage
		MsiString strTopParent, strSubStorageList;
		
		piError = m_piParent->GetSubStorageNameList(*&strTopParent, *&strSubStorageList);
		if(piError)
			return piError;

		AssertSz(strTopParent.TextSize(), "parent storage returned empty name");

		if(strSubStorageList.TextSize())
		{
			strSubStorageList += MsiChar(':');
		}

		strSubStorageList += strName;

		strTopParent.ReturnArg(rpiTopParent);
		strSubStorageList.ReturnArg(rpiSubStorageList);
		return 0;
	}
}

bool CMsiStorage::ValidateStorageClass(ivscEnum ivsc)
{
	return SRV::ValidateStorageClass(m_riStorage, ivsc);
}

//____________________________________________________________________________
//
//  CEnumStorage - stream/storage enumerator within storage
//____________________________________________________________________________

class CEnumStorage : public IEnumMsiString
{
 public:  // implemented virtuals
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched);
	HRESULT __stdcall Skip(unsigned long cSkip);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumMsiString** ppiEnum);
 public:  // construct/destructor
	CEnumStorage(IStorage& riStorage, bool fStorages, bool fRawStreamNames);
	CEnumStorage(IEnumSTATSTG* piEnum, IMalloc* piMalloc, bool fStorages, bool fRawStreamNames);
	void* ConstructedOK();
 protected:
	virtual ~CEnumStorage(void);  // protected to prevent creation on stack
	unsigned long    m_iRefCnt;      // reference count
	IEnumSTATSTG*    m_piEnum;       // OLE enumerator
	IMalloc*         m_piMalloc;     // OLE allocator
	bool             m_fStorages;    // fTrue: storages, fFalse: streams
	bool             m_fRawStreamNames;
};

IEnumMsiString* CMsiStorage::GetStorageEnumerator()
{
	CEnumStorage* piEnum = new CEnumStorage(m_riStorage, fTrue, fTrue);
	if (piEnum && !piEnum->ConstructedOK())
	{
		piEnum->Release();
		piEnum = 0;
	}
	return piEnum;
}

IEnumMsiString* CMsiStorage::GetStreamEnumerator()
{
	CEnumStorage* piEnum = new CEnumStorage(m_riStorage, fFalse, m_fRawStreamNames);
	if (piEnum && !piEnum->ConstructedOK())
	{
		piEnum->Release();
		piEnum = 0;
	}
	return piEnum;
}

CEnumStorage::CEnumStorage(IStorage& riStorage, bool fStorages, bool fRawStreamNames)
	: m_piEnum(0), m_piMalloc(0), m_fStorages(fStorages), m_fRawStreamNames(fRawStreamNames)
	, m_iRefCnt(1)
{
	if (OLE32::CoGetMalloc(MEMCTX_TASK, &m_piMalloc) != NOERROR)
		return;  // should never happen unless OLE messed up
	if (riStorage.EnumElements(0, 0, 0, &m_piEnum) != NOERROR)
		m_piMalloc->Release();
}

CEnumStorage::CEnumStorage(IEnumSTATSTG* piEnum, IMalloc* piMalloc, bool fStorages, bool fRawStreamNames)
	: m_piEnum(piEnum), m_piMalloc(piMalloc), m_iRefCnt(1), m_fStorages(fStorages), m_fRawStreamNames(fRawStreamNames)
{
}

void* CEnumStorage::ConstructedOK()
{
	return m_piEnum;
}

CEnumStorage::~CEnumStorage()
{
	if (m_piMalloc)
		m_piMalloc->Release();
	if (m_piEnum)
		m_piEnum->Release();
}

HRESULT CEnumStorage::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumMsiString)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumStorage::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumStorage::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CEnumStorage::Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched)
{
	STATSTG statstg;
	if (!rgpi)
		return S_FALSE;
	int cFetched = 0;
	unsigned long cRequested = cFetch;
	int cch;
	OLECHAR rgchName[cchMaxStreamName * 2 + 1];
	OLECHAR* pch;
	while (cFetch)
	{
		if (m_piEnum->Next(1, &statstg, 0) != NOERROR)
			break;
		if (!statstg.pwcsName)
			continue;
		if ((statstg.type == STGTY_STREAM && !m_fStorages)
		 || (statstg.type == STGTY_STORAGE && m_fStorages))
		{
			const IMsiString* piStr = &SRV::g_MsiStringNull;
#ifdef UNICODE
			if (m_fStorages || m_fRawStreamNames)
				pch = statstg.pwcsName;
			else if (statstg.pwcsName[0] == chCatalogStream)
			{
				m_piMalloc->Free(statstg.pwcsName);
				continue;
			}
			else
				cch = UncompressStreamName(statstg.pwcsName, pch = rgchName);
			piStr->SetString(pch, piStr);
#else // !UNICODE
			if (m_fStorages || m_fRawStreamNames)
				cch = lstrlenW(pch = statstg.pwcsName);
			else if (statstg.pwcsName[0] == chCatalogStream)
			{
				m_piMalloc->Free(statstg.pwcsName);
				continue;
			}
			else
				cch = UncompressStreamName(statstg.pwcsName, pch = rgchName);
			int cb = WIN::WideCharToMultiByte(CP_ACP, 0, pch, cch, 0, 0, 0, 0);
			Bool fDBCS = (cb == cch ? fFalse : fTrue);
			ICHAR* pb = piStr->AllocateString(cb, fDBCS, piStr);
			BOOL fUsedDefault;
			WIN::WideCharToMultiByte(CP_ACP, 0, pch, cch, pb, cb, 0, &fUsedDefault);
#endif
			cFetch--;
			cFetched++;
			*rgpi++ = piStr;  // ref count transferred to caller
		}
		m_piMalloc->Free(statstg.pwcsName);
	}
	if (pcFetched)
		*pcFetched = cFetched;
	//return (cFetched == cFetch ? S_OK : S_FALSE);FIXmsh
	return (cFetched == cRequested ? S_OK : S_FALSE);
}


HRESULT CEnumStorage::Skip(unsigned long cSkip)
{
	return m_piEnum->Skip(cSkip);
}

HRESULT CEnumStorage::Reset()
{
	return m_piEnum->Reset();
}

HRESULT CEnumStorage::Clone(IEnumMsiString** ppiEnum)
{
	IEnumSTATSTG* piEnum;
	HRESULT hres = m_piEnum->Clone(&piEnum);
	if (hres != NOERROR)
		return hres;
	*ppiEnum = new CEnumStorage(piEnum, m_piMalloc, m_fStorages, m_fRawStreamNames);
	return *ppiEnum ? NOERROR: E_OUTOFMEMORY;
}

//____________________________________________________________________________
//
//  CMsiMemoryStream defintions
//____________________________________________________________________________

class CMsiMemoryStream : public IMsiMemoryStream
{
 public:  // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	unsigned int  __stdcall Remaining() const;
	unsigned int  __stdcall GetData(void* pch, unsigned int cb);
	void          __stdcall PutData(const void* pch, unsigned int cb);
	short         __stdcall GetInt16();
	int           __stdcall GetInt32();
	void          __stdcall PutInt16(short i);
	void          __stdcall PutInt32(int i);
	Bool          __stdcall Error();
	void          __stdcall Reset();
	void          __stdcall Seek(int position);
	IMsiStream*   __stdcall Clone();
	void          __stdcall Flush();
	const char*   __stdcall GetMemory() { return m_rgbData; }
 public: // constructor, destructor
	CMsiMemoryStream(const char* rgbData, unsigned int cbSize, Bool fDelete, Bool fWrite);
 protected:
  ~CMsiMemoryStream();  // protected to prevent creation on stack
 private:
	int          m_iRefCnt;      // COM reference count
	Bool         m_fDelete;
	const char*  m_rgbData;
	Bool         m_fWrite;
	unsigned int m_cbLength;
	unsigned int m_cbRemaining;
	issEnum		 m_issState;
	Bool		 m_fReadOnly;
	unsigned int m_cbSize;
#ifdef USE_OBJECT_POOL
	unsigned int m_iCacheId;
#endif //USE_OBJECT_POOL
};

//____________________________________________________________________________
//
//  Implementation of CMsiMemoryStream
//____________________________________________________________________________

char* AllocateMemoryStream(unsigned int cbSize, IMsiStream*& rpiStream)
{
	CMsiMemoryStream* piStream = 0;
	char* rgbBuffer = new char[cbSize];
	if (rgbBuffer != 0 && (piStream = new CMsiMemoryStream(rgbBuffer, cbSize, fTrue, fTrue)) == 0)
	{
		delete [] rgbBuffer;
		rgbBuffer = 0;
	}
	rpiStream = piStream;
	return rgbBuffer;
}

IMsiStream* CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize)
{
	return new CMsiMemoryStream(pbReadOnly, cbSize, fFalse, fFalse);
}

CMsiMemoryStream::CMsiMemoryStream(const char* rgbData, unsigned int cbSize, Bool fDelete, Bool fWrite)
	: m_rgbData(rgbData), m_cbLength(cbSize), m_cbRemaining(cbSize), m_fDelete(fDelete)
	, m_issState(issReset), m_fWrite(fWrite)
{
	m_iRefCnt = 1;
#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}

CMsiMemoryStream::~CMsiMemoryStream()
{
	RemoveObjectData(m_iCacheId);
	if (m_fDelete)
		delete [] const_cast<char*>(m_rgbData);
}

HRESULT CMsiMemoryStream::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiStream)
	 || MsGuidEqual(riid, IID_IMsiMemoryStream)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiMemoryStream::AddRef()
{
	return ++m_iRefCnt;
}
unsigned long CMsiMemoryStream::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiMemoryStream::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiMemoryStream::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

const IMsiString& CMsiMemoryStream::GetMsiStringValue() const
{
#ifdef UNICODE
	const IMsiString* piString;
	ICHAR* pch;
	
	if (m_cbLength == 0)
		return SRV::CreateString();

	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, m_rgbData, m_cbLength, 0, 0); //!! should use m_iCodepage from database, but how?
	pch = SRV::AllocateString(cch, fFalse, piString);
	if ( pch )
	{
		WIN::MultiByteToWideChar(CP_ACP, 0, m_rgbData, m_cbLength, pch, cch);
		return *piString;
	}
	else 
		return g_riMsiStringNull;
#else
	return SRV::CreateStringComRef(*m_rgbData, m_cbLength, *this);
#endif
}

int CMsiMemoryStream::GetIntegerValue() const
{
	return m_cbLength;
}

unsigned int CMsiMemoryStream::Remaining() const
{
	return m_cbRemaining;
}

unsigned int CMsiMemoryStream::GetData(void* pch, unsigned int cb)
{
	if (m_issState != issRead)	// first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbRemaining = m_cbLength;
	}
	
	if (cb > m_cbRemaining)
	{
		cb = m_cbRemaining;
		m_issState = issError;
	}
	memcpy(pch, m_rgbData+(m_cbLength-m_cbRemaining), cb);
	m_cbRemaining -= cb;
	return cb;
}

void CMsiMemoryStream::PutData(const void* pch, unsigned int cb)
{
	if (m_issState != issWrite) // first write
	{
		if (!m_fWrite || m_issState != issReset)
		{
			m_issState = issError;
			return;
		}
		m_issState = issWrite;
	}

	if (cb > m_cbRemaining)
	{
		// Need to allocate more space
		unsigned int cbNew;
		unsigned int cbSize = m_cbLength + (cbNew = (cb < 256 ? 256 : cb * 2));
		char* rgbBuffer = new char[cbSize];
		if (rgbBuffer == 0)
		{
			m_issState = issError;
			return;
		}
		memcpy(rgbBuffer, m_rgbData, m_cbLength - m_cbRemaining);
		m_cbRemaining += cbNew;
		m_cbLength = cbSize;
		const char *pchT = m_rgbData;
		m_rgbData = rgbBuffer;
		Assert(m_fDelete);
		delete const_cast<char*>(pchT);
	}
	memcpy((void *)(m_rgbData+(m_cbLength-m_cbRemaining)), pch, cb);
	m_cbRemaining -= cb;
	Assert(m_cbRemaining <= m_cbLength);
}

short CMsiMemoryStream::GetInt16()
{
	if (m_issState != issRead)	// first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbRemaining = m_cbLength;
	}
	
	if (m_cbRemaining < sizeof(short))
	{
		m_issState = issError;
		m_cbRemaining = 0;
		return 0;
	}
	unsigned int iOffset = m_cbLength-m_cbRemaining;
	m_cbRemaining -= sizeof(short);
	return *(short UNALIGNED *)(m_rgbData + iOffset);
}

int CMsiMemoryStream::GetInt32()
{
	if (m_issState != issRead)	// first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbRemaining = m_cbLength;
	}
	
	if (m_cbRemaining < sizeof(int))
	{
		m_issState = issError;
		return (m_cbRemaining = 0);
	}
	unsigned int iOffset = m_cbLength-m_cbRemaining;
	m_cbRemaining -= sizeof(int);
	return *(int UNALIGNED *)(m_rgbData + iOffset);
}

void CMsiMemoryStream::PutInt16(short i)
{
	PutData(&i, sizeof(i));
}

void CMsiMemoryStream::PutInt32(int i)
{
	PutData(&i, sizeof(i));
}

Bool CMsiMemoryStream::Error()
{
	return (m_issState == issError ? fTrue : fFalse);
}

void CMsiMemoryStream::Reset()
{
	m_issState = issReset;
	m_cbRemaining = m_cbLength;
}

void CMsiMemoryStream::Seek(int cbPosition)
{
	if(m_cbLength < cbPosition || cbPosition < 0)
	{
		m_issState = issError;
		return;
	}
	m_cbRemaining = m_cbLength - cbPosition;
}

IMsiStream* CMsiMemoryStream::Clone()
{
	//!! need to chain together to handle m_fDelete!!
	return new CMsiMemoryStream(m_rgbData, m_cbLength, m_fDelete, m_fWrite);
}

void CMsiMemoryStream::Flush()
{
}

//____________________________________________________________________________
//
//  Implementation for IMsiSummaryInfo
//____________________________________________________________________________

// NOTE: cannot access integers directory from stream buffer, byte order reversed on Mac

IMsiRecord* CMsiSummaryInfo::Create(CMsiStorage& riStorage, unsigned int cMaxProperties,
												IMsiSummaryInfo*& rpiSummary)
{
	rpiSummary=0; 
	CMsiSummaryInfo* This = 0;
	IMsiStream* piStream;
	IMsiRecord* piError = riStorage.OpenStream(szSummaryStream, fFalse, piStream);
	if (piError)
	{
		if (piError->GetInteger(1) != idbgStgStreamMissing)
			return piError;
		piError->Release();
	}
	int cbStream = piStream ? piStream->GetIntegerValue() : 0;
	Bool fError = fFalse;
	if (riStorage.GetOpenMode() == ismReadOnly)
		cMaxProperties = 0;  // no changes allowed
	if ((This = new(cbStream, cMaxProperties) CMsiSummaryInfo(cbStream, cMaxProperties)) == 0)
		fError = fTrue;
	else if (cbStream)
	{
		piStream->GetData(This->m_pvStream, cbStream);
		fError = piStream->Error();  // check FMTID also?
	}
	if (piStream)
		piStream->Release();
	if (fError)
	{
		if (This)
			This->Release();
		return LOC::PostError(Imsg(idbgStgOpenStream), szSummaryStream+1, E_OUTOFMEMORY);
	}
	if (cbStream)
	{
		int* pIndex = (int*)((char*)This->m_pvStream + cbSummaryHeader) - 1; // point to section offset
		int i = This->GetInt32(pIndex); // section offset
		Assert(i < cbStream);
		This->m_pbSection = (char*)This->m_pvStream + i; // start of section
		pIndex = (int*)This->m_pbSection;
		This->m_cbSection = This->GetInt32(pIndex++);
		Assert(This->m_cbSection <= cbStream - cbSummaryHeader); // section size
		This->m_cOldProp = This->GetInt32(pIndex++); // number of properties, skip over section size
		This->m_pPropertyIndex = pIndex;  // start of PID/offset pairs
		rpiSummary = This;
#ifdef UNICODE
		This->GetIntegerProperty(PID_CODEPAGE, This->m_iCodepage);
#endif
	}
	else
	{
		This->m_cOldProp = 0;
	}

	if (cMaxProperties != 0)
	{
		piError = riStorage.OpenStream(szSummaryStream, fTrue, piStream);
		if (piError)
		{
			This->Release();
			return piError;
		}
		This->m_piStream = piStream;
	}
	rpiSummary = This;
	return 0;
}

CMsiSummaryInfo::CMsiSummaryInfo(unsigned int cbStream, unsigned int cMaxProperties)
	: m_cbStream(cbStream), m_iCodepage(0), m_piStream(0)
	, m_cMaxProp(cMaxProperties), m_cNewProp(0), m_cOldProp(0), m_cDeleted(0)
{
	m_iRefCnt = 1;
	m_pvStream = (PropertyData*)(this + 1) + cMaxProperties;  // location of buffer for stream
}

CMsiSummaryInfo::~CMsiSummaryInfo()
{
	PropertyData* pData = GetPropertyData();
	for (int cProp = m_cNewProp; cProp--; pData++)
		if (pData->iType == VT_LPSTR)
			pData->piText->Release(); // release unprocessed strings
}

int CMsiSummaryInfo::GetPropertyCount()
{
	return m_cOldProp + m_cNewProp - m_cDeleted;
}

int CMsiSummaryInfo::GetPropertyType(int iPID)
{
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		if (iPID == PID_DICTIONARY)
			return VT_I4;  // type code missing, space used for count
		int i = GetInt32(pProp + 1); // offset to property data
		return GetInt32(pProp);
	}
	PropertyData* pData = FindNewProperty(iPID);
	if (pData)
		return pData->iType;
	return VT_EMPTY;
}

Bool CMsiSummaryInfo::RemoveProperty(int iPID)
{
	if (m_cMaxProp == 0)
		return fFalse;  // not updatable
	int* pIndex = m_pPropertyIndex;
	for (int cProp = m_cOldProp; cProp--; pIndex+=2)
		if (GetInt32(pIndex) == iPID)
		{
			*pIndex = PID_Deleted;
			m_cDeleted++;
			return fTrue;
		}
	PropertyData* pData = FindNewProperty(iPID);
	if (!pData)
		return fFalse;
	if (pData->iType == VT_LPSTR)
		pData->piText->Release();
	m_cNewProp--;
//	Assert(GetPropertyData() + m_cNewProp - pData <= INT_MAX);	//--merced: 64-bit ptr subtraction may theoretically lead to values too big for cb
	int cb = ((int)(INT_PTR)(GetPropertyData() + m_cNewProp - pData)) * sizeof(PropertyData);
	if (cb)
		memmove(pData, pData + 1, cb);
	return fTrue;
}

HRESULT CMsiSummaryInfo::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown))  // No GUID for this guy yet
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiSummaryInfo::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiSummaryInfo::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	IMsiStream* piStream = m_piStream;
	delete this;
	if (piStream)  // release AFTER freeeing memory to avoid memory assert
		piStream->Release();
	return 0;
}

const IMsiString& CMsiSummaryInfo::GetStringProperty(int iPID)
{
	PropertyData* pData;
	const IMsiString* piStr = &SRV::CreateString();
	int iType, cbProp;
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		if (iPID != 0 && (iType = GetInt32(pProp++)) == VT_LPSTR
						  && (cbProp = GetInt32(pProp++)) > 1)
		{
				Assert(((char*)pProp)[cbProp-1] == 0);
#ifdef UNICODE
				int cch = WIN::MultiByteToWideChar(m_iCodepage, 0, (char*)pProp, cbProp-1, 0, 0);
				ICHAR* pch = SRV::AllocateString(cch, fFalse, piStr);
				if ( pch )
				    WIN::MultiByteToWideChar(m_iCodepage, 0, (char*)pProp, cbProp-1, pch, cch);
#else
				piStr->SetString((const ICHAR*)pProp, piStr);
#endif
		}
	}
	else if ((pData = FindNewProperty(iPID)) != 0)
	{
		if (pData->iType == VT_LPSTR)
			(piStr = pData->piText)->AddRef();
	}
	return *piStr;
}

Bool CMsiSummaryInfo::GetFileTimeProperty(int iPID, FILETIME& rftDateTime)
{
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		int iType = GetInt32(pProp++);
		if (iPID == 0 || iType != VT_FILETIME)
			return fFalse;
		rftDateTime.dwLowDateTime = GetInt32(pProp++);
		rftDateTime.dwHighDateTime = GetInt32(pProp);
	}
	else
	{
		PropertyData* pData = FindNewProperty(iPID);
		if (!pData || pData->iType != VT_FILETIME)
			return fFalse;
		rftDateTime.dwLowDateTime  = pData->iLow;
		rftDateTime.dwHighDateTime = pData->iHigh;
	}
	return fTrue;
}

Bool CMsiSummaryInfo::GetTimeProperty(int iPID, MsiDate& riDateTime)
{
	FILETIME ft;
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		int iType = GetInt32(pProp++);
		if (iPID == 0 || iType != VT_FILETIME)
			return fFalse;
		ft.dwLowDateTime = GetInt32(pProp++);
		ft.dwHighDateTime = GetInt32(pProp);
	}
	else
	{
		PropertyData* pData = FindNewProperty(iPID);
		if (!pData || pData->iType != VT_FILETIME)
			return fFalse;
		ft.dwLowDateTime  = pData->iLow;
		ft.dwHighDateTime = pData->iHigh;
	}
	unsigned short iDosOffset = 0;
	if (ft.dwHighDateTime <  iFileTimeOneDayHigh
	|| (ft.dwHighDateTime == iFileTimeOneDayHigh
	 && ft.dwLowDateTime  <  iFileTimeOneDayLow))
	{  // add 1/1/1980, then subtract it off again
		ft.dwLowDateTime  += iFileTimeDosBaseLow;
		ft.dwHighDateTime += iFileTimeDosBaseHigh;
		if(ft.dwLowDateTime < iFileTimeDosBaseLow)
			ft.dwHighDateTime++;
		iDosOffset = 0x0021;
	}
	unsigned short wDosDate, wDosTime;
	if (iDosOffset == 0 && !::FileTimeToLocalFileTime(&ft, &ft))
		return fFalse;
	if (!::FileTimeToDosDateTime(&ft, &wDosDate, &wDosTime))
		return fFalse;
//	wDosDate -= iDosOffset;  //!! could not elimnate warning
	wDosDate  = unsigned short(wDosDate - iDosOffset);
	riDateTime = (MsiDate)((wDosDate << 16) | wDosTime);
	return fTrue;
}

Bool CMsiSummaryInfo::GetIntegerProperty(int iPID, int& iValue)
{
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		int iType = GetInt32(pProp++);
		if (iPID == PID_DICTIONARY)
			iValue = iType;
		else if (iType == VT_I2)
			iValue = GetInt16(pProp);
		else if (iType == VT_I4)
			iValue = GetInt32(pProp);
		else
			return fFalse;
	}
	else
	{
		PropertyData* pData = FindNewProperty(iPID);
		if (!pData)
			return fFalse;
		int iType = pData->iType;
		if (iType == VT_I2 || iType == VT_I4)
			iValue = pData->iValue;
		else
			return fFalse;
	}
	return fTrue;
}

int* CMsiSummaryInfo::FindOldProperty(int iPID)
{
	int* pProp = m_pPropertyIndex;
	for (int cProp = m_cOldProp; cProp--; pProp++)
		if (GetInt32(pProp++) == iPID)
			return (int*)(m_pbSection + GetInt32(pProp));
	return 0;
}

PropertyData* CMsiSummaryInfo::FindNewProperty(int iPID)
{
	PropertyData* pData = GetPropertyData();
	for (int cProp = m_cNewProp; cProp--; pData++)
		if (pData->iPID == iPID)
			return pData;
	return 0;
}

int CMsiSummaryInfo::SetStringProperty(int iPID, const IMsiString& riText)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID = iPID;
	pData->iType = VT_LPSTR;
#ifdef UNICODE
	pData->cbText = WIN::WideCharToMultiByte(m_iCodepage, 0,
								riText.GetString(), -1, 0, 0, 0, 0);
#else
	pData->cbText = riText.TextSize() + 1;
#endif
	pData->piText = &riText;
	riText.AddRef();
	return ++m_cNewProp;
}

int CMsiSummaryInfo::SetFileTimeProperty(int iPID, FILETIME& rftDateTime)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID  = iPID;
	pData->iType = VT_FILETIME;
	pData->iLow  = rftDateTime.dwLowDateTime;
	pData->iHigh = rftDateTime.dwHighDateTime;
	return ++m_cNewProp;
}

int CMsiSummaryInfo::SetTimeProperty(int iPID, MsiDate iDateTime)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	FILETIME ft;
	int iDate = ((unsigned int)iDateTime)>>16;
	unsigned short usDate = (short)iDate;
	if (!iDate)
		usDate = 0x0021;  // offset to 1/1/80, lowest valid date

	if (!::DosDateTimeToFileTime(usDate, (short)iDateTime, &ft))
		return 0;
	if (!::LocalFileTimeToFileTime(&ft, &ft))
		return 0;
	if (!iDate)  // remove 1/1/80 if time only
	{
		if(ft.dwLowDateTime < iFileTimeDosBaseLow)
			ft.dwHighDateTime--;
		ft.dwLowDateTime  -= iFileTimeDosBaseLow;
		ft.dwHighDateTime -= iFileTimeDosBaseHigh;
	}
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID = iPID;
	pData->iType = VT_FILETIME;
	pData->iLow  = ft.dwLowDateTime;
	pData->iHigh = ft.dwHighDateTime;
	return ++m_cNewProp;
}

int CMsiSummaryInfo::SetIntegerProperty(int iPID, int iValue)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID = iPID;
	pData->iType = (iPID == PID_CODEPAGE ? VT_I2 : VT_I4);
	pData->iValue = (iPID == PID_CODEPAGE ? (unsigned short)iValue : iValue);
#ifdef UNICODE
	if (iPID == PID_CODEPAGE)
		m_iCodepage = iValue;
#endif
	return ++m_cNewProp;
}

int GetPropSize(int iPID, char* pbData)  // ID + data
{
	if (iPID == 0 || iPID == PID_Deleted)
		return 0;  // we don't do dictionaries
	int iType = *(int*)pbData;
	int	cb;
	switch (iType)
	{
	case VT_I2:
	case VT_I4:
		return 2 * sizeof(int);
	case VT_LPSTR:
	case VT_BSTR:
		pbData += sizeof(int);
		cb = *(int*)pbData;
		return 2 * sizeof(int) + ((cb+3) & ~3);
	case VT_FILETIME:
		return 3 * sizeof(int);
	default:  // bitmaps, blobs, arrays
		return 0;
	}
}

Bool CMsiSummaryInfo::WritePropertyStream()
{
	// note: we always write out the stream if it was opened read-write
	// this puts back the existing data even if no properties were written
	if (m_cMaxProp == 0)
		return fFalse;  // read-only

	// calculate section size for old properties.
	// we make the assumption that the properties are stored in the order
	// given in the index, otherwise we don't know how to calculate
	// the data sizes for dictionaries, arrays, blobs, etc.
	int cbSectionData = 0;
	int iPID, iOffset;
	int* pIndex = m_pPropertyIndex;
	int cProp = m_cOldProp;
	int cCopyProp = 0;
	while (cProp--)
	{
		iPID    = GetInt32(pIndex++);
		iOffset = GetInt32(pIndex++);
		int cb = GetPropSize(iPID, m_pbSection + iOffset);
		if (cb)
		{
			cCopyProp++;
			cbSectionData += GetPropSize(iPID, m_pbSection + iOffset);
		}
	}

	// calculate section size for new properties.
	PropertyData* pData = GetPropertyData();
	for (cProp = m_cNewProp; cProp--; pData++)
	{
		cbSectionData += 2 * sizeof(int);
		if (pData->iType == VT_FILETIME)
			cbSectionData += sizeof(int);
		else if (pData->iType == VT_LPSTR)
			cbSectionData += (pData->cbText + 3) & ~3;  // align
	}

	// output stream header and section header
	int cTotalProp = cCopyProp + m_cNewProp;
	int cbSectionIndex = cTotalProp * 2 * sizeof(int) + cbSectionHeader;
	IMsiStream* piStream = m_piStream; // for efficiency
	piStream->PutInt16((unsigned short)0xFFFE); // byte order, always little-endian
	piStream->PutInt16(0);       // property stream format, always 0
	piStream->PutInt16(short(g_iMinorVersion * 256 + g_iMajorVersion));
#ifdef WIN
	piStream->PutInt16(2);  // Win32 platform code
#else // MAC
	piStream->PutInt16(1);  // Mac platform code
#endif
	piStream->PutData(fmtidSourceClsid, sizeof(fmtidSourceClsid));
	piStream->PutInt32(1);        // section count
	piStream->PutData(fmtidSummaryStream, sizeof(fmtidSummaryStream));
	piStream->PutInt32(cbSummaryHeader); // offset to 1st section
	Assert(piStream->GetIntegerValue() == cbSummaryHeader);
	piStream->PutInt32(cbSectionIndex + cbSectionData);  // section size
	piStream->PutInt32(cTotalProp);  // property count

	// output property index
	int iSectionOffset = cbSectionIndex;  // start of section data offset
	for (pIndex = m_pPropertyIndex, cProp = m_cOldProp; cProp--; )
	{
		iPID    = GetInt32(pIndex++);
		iOffset = GetInt32(pIndex++);
		int cb = GetPropSize(iPID, m_pbSection + iOffset);
		if (cb)
		{
			piStream->PutInt32(iPID);
			piStream->PutInt32(iSectionOffset);
			iSectionOffset += cb;
		}
	}
	for (pData = GetPropertyData(), cProp = m_cNewProp; cProp--; pData++)
	{
		piStream->PutInt32(pData->iPID);
		piStream->PutInt32(iSectionOffset);
		iSectionOffset += 2 * sizeof(int);
		if (pData->iType == VT_FILETIME)
			iSectionOffset += sizeof(int);
		else if (pData->iType == VT_LPSTR)
			iSectionOffset += (pData->cbText + 3) & ~3;  // align
	}

	// output old properties
	for (pIndex = m_pPropertyIndex, cProp = m_cOldProp; cProp--; )
	{
		iPID    = GetInt32(pIndex++);
		iOffset = GetInt32(pIndex++);
		int cb = GetPropSize(iPID, m_pbSection + iOffset);
		if (cb)
			piStream->PutData(m_pbSection + iOffset, cb);
	}

	// output new properties
	static const char rgbNullPad[4] = {0,0,0,0}; // need from 0 to 3 pad bytes
	int cbText;   // string size, including null terminator
	for (pData = GetPropertyData(), cProp = m_cNewProp; cProp--; pData++)
	{
		piStream->PutInt32(pData->iType);
		switch(pData->iType)
		{
		case VT_I2:
		case VT_I4:
			piStream->PutInt32(pData->iValue);
			break;
		case VT_LPSTR:
		{
			cbText = pData->cbText; // includes null
			piStream->PutInt32(cbText);
#ifdef UNICODE
			CTempBuffer<char, 512> rgchBuf;
			rgchBuf.SetSize(cbText);
			if ( ! (char *) rgchBuf )
			{
				m_cMaxProp = m_cNewProp = 0;
				return fFalse;
			}
			int cbData = WIN::WideCharToMultiByte(m_iCodepage, 0,
								pData->piText->GetString(), -1, rgchBuf, cbText, "\177", 0);
			Assert(cbData == cbText);
			piStream->PutData(rgchBuf, cbText);
#else
			piStream->PutData(pData->piText->GetString(), cbText);
#endif
			if ((cbText &= 3) != 0)
				piStream->PutData(rgbNullPad, 4 - cbText);
			pData->piText->Release();
			break;
		}
		case VT_FILETIME:
			piStream->PutInt32(pData->iLow);
			piStream->PutInt32(pData->iHigh);
			break;
		default: Assert(0);
		};
	}
	Assert(piStream->GetIntegerValue() == cbSummaryHeader + cbSectionIndex + cbSectionData);
	Bool fError = piStream->Error();
	m_cMaxProp = m_cNewProp = 0;  // prevent further write
	return fError ? fFalse : fTrue;
}

//____________________________________________________________________________
//
// CFileRead CFileWrite implementation
//____________________________________________________________________________

char rgchCtrlMap[16]   = {21, 1, 2, 3, 4, 5, 6, 7,27,16,25,11,24,17,14,15};
// translate from:       NULL                     BS HT LF    FF CR

char rgchCtrlUnMap[16] = { 9,13,18,19,20, 0,22,23,12,10,26, 8,28,29,30,31};
// restore to:            HT CR         NULL      FF LF    BS

CFileWrite::CFileWrite(int iCodePage) : m_iCodePage(iCodePage)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileWrite::CFileWrite() : m_iCodePage(CP_ACP)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileWrite::~CFileWrite()
{
	Close();
}

Bool CFileWrite::Open(IMsiPath& riPath, const ICHAR* szFile)
{
	Close();
	if (!szFile || !szFile[0])
		return fFalse;
	MsiString istrFullPath;
	IMsiRecord* piError;
	if ((piError = riPath.GetFullFilePath(szFile, *&istrFullPath)) != 0)
	{
		piError->Release();
		return fFalse;
	}
	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(istrFullPath) == fTrue) ? fTrue : fFalse;
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	m_hFile = ::CreateFile(istrFullPath, GENERIC_WRITE, FILE_SHARE_READ, 0,
							CREATE_ALWAYS, 
							(FILE_ATTRIBUTE_NORMAL 
							| (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
    if (m_hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(m_hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFullPath);
			Close();
			SetLastError(ERROR_OPEN_FAILED);
		}
	}

	if(fImpersonate)
		StopImpersonating();
	return (m_hFile == INVALID_HANDLE_VALUE) ? fFalse : fTrue;
}

Bool CFileWrite::Close()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	if (!::CloseHandle(m_hFile))
		return fFalse;
	m_hFile = INVALID_HANDLE_VALUE;
	return fTrue;
}

Bool CFileWrite::WriteString(const ICHAR* szData, int fNewLine)
{
	return CFileWrite::WriteText(szData, IStrLen(szData), fNewLine);
}

Bool CFileWrite::WriteMsiString(const IMsiString& riData, int fNewLine)
{
	return CFileWrite::WriteText(riData.GetString(), riData.TextSize(), fNewLine);
}

Bool CFileWrite::WriteInteger(int iData, int fNewLine)
{
	ICHAR rgchBuffer[20];
	if (iData == iMsiNullInteger)
		return CFileWrite::WriteText(rgchBuffer, 0, fNewLine);
	else
	{
		StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(ICHAR), TEXT("%i"), iData);
		size_t i;
		StringCchLength(rgchBuffer, sizeof(rgchBuffer)/sizeof(ICHAR), &i);
		return CFileWrite::WriteText(rgchBuffer, i, fNewLine);
	}
}

Bool CFileWrite::WriteText(const ICHAR* szData, unsigned long cchData, int fNewLine)
{
	int iStatus;
	DWORD cbWritten;
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	char* szDelim = fNewLine ? "\r\n" : "\t";
	long cbDelim = fNewLine ? 2 : 1;
	if (cchData)
	{
		Bool fControlChars = fFalse;
		long cbData;
		char* pbBuffer;
#ifdef UNICODE
		BOOL fDefaultUsed = 0;
		DWORD dwFlags = 0; // WC_COMPOSITECHECK fails on Vietnamese
		const char* szDefault = "\177";
		BOOL* pfDefaultUsed = &fDefaultUsed;
		if (m_iCodePage >= CP_UTF7 || m_iCodePage >= CP_UTF8)
		{
			dwFlags = 0;    // flags must be 0 to avoid invalid argument errors
			szDefault = 0;
			pfDefaultUsed = 0;
		}
		cbData = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
									szData, cchData, m_rgbTemp, m_rgbTemp.GetSize(), szDefault, pfDefaultUsed);
		if (cbData == 0)   // can only happen on buffer overflow
		{
			cbData = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
									szData, cchData, 0, 0, 0, 0);
			m_rgbTemp.SetSize(cbData);
			if ( ! (char *) m_rgbTemp )
				return fFalse;
			cbData = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
									szData, cchData, m_rgbTemp, m_rgbTemp.GetSize(), szDefault, pfDefaultUsed);
			Assert(cbData);
		}
		pbBuffer = m_rgbTemp;
#else
		cbData  = cchData;
		pbBuffer = const_cast<char*>(szData);
#endif
		if (fNewLine != -1)
		{
			char* pchData = pbBuffer;
			for (int iData = cbData; iData; iData--, pchData++)
				if ((unsigned char)*pchData < 16) // check for control chars in string
				{
					*pchData = rgchCtrlMap[*pchData];
					fControlChars = fTrue;
				}
		}
		iStatus = ::WriteFile(m_hFile, pbBuffer, cbData, &cbWritten, 0);
#ifndef UNICODE
		if (fControlChars) // restore for control chars in string
		{
			char* pchData = pbBuffer;
			for (int iData = cbData; iData; iData--, pchData++)
				if ((unsigned char)*pchData < 32 && (unsigned char)*pchData >= 16)
					*pchData = rgchCtrlUnMap[*pchData-16];
		}
#endif
	}
	else
		iStatus = fTrue;
	if (iStatus && fNewLine != -1)
		iStatus = ::WriteFile(m_hFile, szDelim, cbDelim, &cbWritten, 0);
	if (iStatus)
		return fTrue;
	Close();  // forces immediate failure on close or subsequent writes
	return fFalse;
}

Bool CFileWrite::WriteBinary(char* rgchBuf, unsigned long cbBuf)
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	if (!::WriteFile(m_hFile, rgchBuf, cbBuf, &cbBuf, 0))
		return fFalse;
	return fTrue;
}

CFileRead::CFileRead(int iCodePage) : m_iCodePage(iCodePage)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileRead::CFileRead() : m_iCodePage(CP_ACP)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileRead::~CFileRead()
{
	Close();
}

Bool CFileRead::Open(IMsiPath& riPath, const ICHAR* szFile)
{
	Close();
	if (!szFile || !szFile[0])
		return fFalse;
	m_cRead = m_iBuffer = cFileReadBuffer;
	MsiString istrFullPath;
	IMsiRecord* piError;
	if ((piError = riPath.GetFullFilePath(szFile, *&istrFullPath)) != 0)
	{
		piError->Release();
		return fFalse;
	}
	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(istrFullPath) == fTrue) ? fTrue : fFalse;
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	m_hFile = ::CreateFile(istrFullPath, GENERIC_READ, FILE_SHARE_READ, 0,
									OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
    if (m_hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(m_hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), istrFullPath);
			Close();
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
	if(fImpersonate)
		StopImpersonating();
	return (m_hFile == INVALID_HANDLE_VALUE) ? fFalse : fTrue;
}

Bool CFileRead::Close()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	if (!::CloseHandle(m_hFile))
		return fFalse;
	m_hFile = INVALID_HANDLE_VALUE;
	return fTrue;
}

unsigned long CFileRead::GetSize()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return 0;
	return ::GetFileSize(m_hFile, 0);
}

unsigned long CFileRead::ReadBinary(char* rgchBuf, unsigned long cbBuf)
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return 0;
	if (!::ReadFile(m_hFile, rgchBuf, cbBuf, &cbBuf, 0))
		return 0;
	return cbBuf;
}

ICHAR CFileRead::ReadString(const IMsiString*& rpiData)
{
	rpiData = &CreateString();
	if (m_hFile == INVALID_HANDLE_VALUE)
		return 0;
#ifdef UNICODE
	int cbTemp = 0;
	int cch;
#endif
	unsigned int iStart = m_iBuffer;
	char ch;
	for (;;)
	{
		if (m_iBuffer == m_cRead)  // end of buffer
		{
			ch = 0;
#ifndef UNICODE
			if (m_iBuffer != iStart)
				rpiData->AppendString(m_rgchBuf + iStart, rpiData);
#endif
			if (m_cRead != cFileReadBuffer)
			{
#ifdef UNICODE
				if (cbTemp != 0)
#else
				if (rpiData->TextSize() != 0)
#endif //UNICODE
				{
					ch = '\n';
				}
				break;
			}
			if (!(::ReadFile(m_hFile, m_rgchBuf, cFileReadBuffer, &m_cRead, 0))
				|| m_cRead == 0)
			{
				if (GetLastError() == ERROR_HANDLE_EOF && 
#ifdef UNICODE
				cbTemp != 0
#else
				rpiData->TextSize() != 0
#endif
				)
				{
					ch = '\n';
				}
				break;   
			}
			iStart = m_iBuffer = 0;
			m_rgchBuf[m_cRead] = 0;
		}
		ch = m_rgchBuf[m_iBuffer];
		if ((unsigned char)ch < 32)  // control char or end of string
		{
			if (ch == 0)
				ch = '\n';
			else if (ch == '\r')
			{
				m_rgchBuf[m_iBuffer++] = 0;  // ignore CR, wait for LF
				continue;
			}
			else if (ch == '\n' || ch == '\t')
			{
				m_rgchBuf[m_iBuffer++] = 0;
				
#ifndef UNICODE
				rpiData->AppendString(m_rgchBuf + iStart, rpiData);
#endif
				break;
			}
			else if ((unsigned char)ch >= 16) // translated control char
#ifdef UNICODE
				ch = rgchCtrlUnMap[ch-16]; // remapped control char
#else
				m_rgchBuf[m_iBuffer] = rgchCtrlUnMap[ch-16]; // restore control char
#endif
		}
#ifdef UNICODE
		if (cbTemp >= m_rgbTemp.GetSize())
			m_rgbTemp.Resize(cbTemp + 1024);  //!! need better algorithm
		m_rgbTemp[cbTemp++] = ch;
#endif // UNICODE
		m_iBuffer++;
	}
#ifdef UNICODE
	if (cbTemp)
	{
		// if DBCS enabled  // need extra call to find size of DBCS string
		cch = WIN::MultiByteToWideChar(m_iCodePage, 0, m_rgbTemp, cbTemp, 0, 0);
		ICHAR* pchStr = SRV::AllocateString(cch, fFalse, rpiData);
		if ( pchStr )
		    WIN::MultiByteToWideChar(m_iCodePage, 0, m_rgbTemp, cbTemp, pchStr, cch);
	}
	else
		rpiData = &SRV::g_MsiStringNull;
#endif
	return ch;
}

//____________________________________________________________________________
//
// CLockBytes implementation
//____________________________________________________________________________

HRESULT CMsiLockBytes::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_ILockBytes))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
	
}
unsigned long CMsiLockBytes::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiLockBytes::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

CMsiLockBytes::CMsiLockBytes(IMsiStream& riStream)	: m_piStream(&riStream)
{
	m_piStream->AddRef();
	m_iRefCnt = 1;
}

CMsiLockBytes::CMsiLockBytes(const char* pchMem, int iLength)
{
	CMsiLockBytes(*PMsiStream(new CMsiMemoryStream(pchMem, iLength, fFalse, fFalse)));
}

CMsiLockBytes::~CMsiLockBytes()
{
	m_piStream->Release();
}

HRESULT __stdcall CMsiLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void* pv, ULONG cb, ULONG* pcbRead)
{
	if (ulOffset.HighPart) // Our database shouldn't exceed 4 gigs
		return E_FAIL;

	m_piStream->Seek(ulOffset.LowPart);
	ULONG cbRead = m_piStream->GetData(pv, cb);
	if (pcbRead)
		*pcbRead = cbRead;
	return m_piStream->Error() ? E_FAIL : S_OK;
}

HRESULT __stdcall CMsiLockBytes::WriteAt(ULARGE_INTEGER /*ulOffset*/, const void* /*pv*/,
													  ULONG /*cb*/, ULONG* /*pcbWritten*/)
{
	return E_FAIL;
}

HRESULT __stdcall CMsiLockBytes::Flush()
{
	return S_OK;
}

HRESULT __stdcall CMsiLockBytes::SetSize(ULARGE_INTEGER /*cb*/)
{
	return E_FAIL;
}

HRESULT __stdcall CMsiLockBytes::LockRegion(ULARGE_INTEGER /*libOffset*/,
														  ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT __stdcall CMsiLockBytes::UnlockRegion(ULARGE_INTEGER /*libOffset*/,
											ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT __stdcall CMsiLockBytes::Stat(STATSTG* pstatstg, DWORD /*grfStatFlag*/)
{
	memset (pstatstg, 0, sizeof(*pstatstg));
	pstatstg->type = STGTY_LOCKBYTES;
	pstatstg->cbSize.LowPart = m_piStream->GetIntegerValue();
	return S_OK;
}

//____________________________________________________________________________
//
// CMsiFileStream implementation
//____________________________________________________________________________

#ifdef WIN
typedef HANDLE MsiFileHandle;
#else
typedef short MsiFileHandle;
#endif

class CMsiFileStream;

class CFileStreamData  // common clone information
{
 public:
	CFileStreamData(MsiFileHandle hFile, unsigned int cbLength, Bool fWrite);
  ~CFileStreamData();
	int                 m_cStreams;
	CMsiFileStream*     m_piCurrentStream;
	const MsiFileHandle m_hFile;
	Bool                m_fWrite;
	unsigned int        m_cbLength;
	bool				m_fFirstWrite;
};

class CMsiFileStream : public CMsiStreamBuffer
{
 public:  // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
	unsigned int  __stdcall Remaining() const;
	void          __stdcall Reset();
	void          __stdcall Seek(int position);
	IMsiStream*   __stdcall Clone();
	HRESULT __stdcall Read(void *pv, unsigned long cb, unsigned long *pcbRead);
 public: // constructor
	CMsiFileStream(CFileStreamData& rStreamData);
	void operator =(CMsiFileStream&);
 protected:
  ~CMsiFileStream(){}; // protected to prevent creation on stack
   void __stdcall Flush();
 private:
	int               m_iRefCnt;   // COM reference count
	CFileStreamData&  m_rData;     // common clone information
};

extern bool RunningAsLocalSystem();

IMsiRecord* CreateFileStream(const ICHAR* szFile, Bool fWrite, IMsiStream*& rpiStream)
{
	Bool fImpersonate = RunningAsLocalSystem() && (GetImpersonationFromPath(szFile) == fTrue) ? fTrue : fFalse;
	MsiFileHandle hFile;

	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	if (fWrite)
	{
		hFile = WIN::CreateFile(szFile, GENERIC_WRITE, FILE_SHARE_READ, 0,
					CREATE_ALWAYS, (FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwType = GetFileType(hFile);
			if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
			{
				DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szFile);
				WIN::CloseHandle(hFile);
				hFile = INVALID_HANDLE_VALUE;
				SetLastError(ERROR_OPEN_FAILED);
			}
		}
	}
	else
	{
		// Per Bug 9965/146155 (opening stream for reading) On WinNT, also specify FILE_SHARE_DELETE
		// so that callee can specify FILE_FLAG_DELETE_ON_CLOSE
		if (!g_fWin9X)
		{
			hFile = WIN::CreateFile(szFile, GENERIC_READ, 
					FILE_SHARE_READ | FILE_SHARE_DELETE, 0, OPEN_EXISTING, 
					(FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				DWORD dwType = GetFileType(hFile);
				if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
				{
					DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szFile);
					WIN::CloseHandle(hFile);
					hFile = INVALID_HANDLE_VALUE;
					SetLastError(ERROR_OPEN_FAILED);
				}
			}
		}
		else // FILE_SHARE_DELETE is unsupported on Win9X (and is not required with FFDOC flag)
			hFile = WIN::CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, 0,
											OPEN_EXISTING, 
						(FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
	}
	
	DWORD dwLastErr = WIN::GetLastError();
	if(fImpersonate)
		StopImpersonating();
	
	if (hFile == INVALID_HANDLE_VALUE)
		return LOC::PostError(Imsg(imsgOpenFileStream), szFile, dwLastErr);

	unsigned int cbFileSize = WIN::GetFileSize(hFile, 0);
	Assert(cbFileSize != 0xFFFFFFFFL);
	CFileStreamData* pStreamData = new CFileStreamData(hFile, cbFileSize, fWrite);
	rpiStream = new CMsiFileStream(*pStreamData);
	return 0;
}

CFileStreamData::CFileStreamData(MsiFileHandle hFile, unsigned int cbLength, Bool fWrite)
	: m_cStreams(1)
	, m_hFile(hFile)
	, m_fWrite(fWrite)
	, m_cbLength(cbLength)
	, m_fFirstWrite(true)
{
}

CFileStreamData::~CFileStreamData()
{
	AssertNonZero(WIN::CloseHandle(m_hFile));
}

CMsiFileStream::CMsiFileStream(CFileStreamData& rStreamData)
 :  m_iRefCnt(1)
 ,  m_rData(rStreamData)
{
	m_rData.m_piCurrentStream = this;
	m_fWrite = m_rData.m_fWrite;
	m_cbLength = m_rData.m_cbLength;
}

HRESULT CMsiFileStream::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiStream)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiFileStream::AddRef()
{
	return ++m_iRefCnt;
}
unsigned long CMsiFileStream::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	Flush();
	if (--m_rData.m_cStreams == 0)
		delete &m_rData;
	delete this;
	return 0;
}

const IMsiString& CMsiFileStream::GetMsiStringValue() const
{
	return SRV::CreateString();
//	return SRV::CreateStringComRef(*m_rgbData, m_cbLength, *this);
}

int CMsiFileStream::GetIntegerValue() const
{
	return m_rData.m_cbLength;
}

unsigned int CMsiFileStream::Remaining() const
{
	return (m_issState == issRead || m_issState == issReset) ? m_rData.m_cbLength - m_cbCopied : 0;
}

HRESULT CMsiFileStream::Read(void* pb, unsigned long cb, unsigned long* pcbRead)
{
	if (m_rData.m_piCurrentStream != this)
	{
		AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, m_cbCopied, 0, FILE_BEGIN) - 0xFFFFFFFFL);
		m_rData.m_piCurrentStream = this;
	}
	if (!WIN::ReadFile(m_rData.m_hFile, pb, cb, pcbRead, 0) )
	{
		*pcbRead = 0;
		return E_FAIL;
	}
	return S_OK;
}

#ifdef OLD
void CMsiFileStream::PutData(const void* pb, unsigned int cb)
{
	if (m_issState != issWrite) // first write
	{
		if (!m_rData.m_fWrite || m_issState != issReset)
		{
			m_issState = issError;
			return;
		}
		m_issState = issWrite;
		m_rData.m_cbLength = 0;
	}
	else if (m_rData.m_piCurrentStream != this)
	{
		AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, 0, 0, FILE_END) - 0xFFFFFFFFL);
		m_rData.m_piCurrentStream = this;
	}

	unsigned long cbWrite;  //!! = 0; ?
	WIN::WriteFile(m_rData.m_hFile, pb, cb, &cbWrite, 0);
	m_rData.m_cbLength += cbWrite;
	if (cbWrite != cb)
		m_issState = issError;
}
#endif //OLD

void CMsiFileStream::Reset()
{
	Flush();
	AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, 0, 0, FILE_BEGIN) - 0xFFFFFFFFL);
	// if writing, do we need to flush the file out here?
	m_cbCopied = 0;
	m_issState = issReset;
	m_rData.m_piCurrentStream = this;  //!! needed?
	m_rData.m_fFirstWrite = true;
}

void CMsiFileStream::Seek(int cbPosition)
{
	Flush();
	unsigned long cbSeek;
	if(m_rData.m_cbLength < cbPosition || cbPosition < 0 ||
		(cbSeek = WIN::SetFilePointer(m_rData.m_hFile, cbPosition, 0, FILE_BEGIN)) == 0xFFFFFFFFL)
	{
		DWORD err = GetLastError();
		m_issState = issError;
		return;
	}
	m_cbCopied = cbSeek;
	m_rData.m_piCurrentStream = this;
}

void CMsiFileStream::Flush()
{
	if (m_issState == issWrite && m_cbUsed != 0)
	{
		if (m_rData.m_fFirstWrite)
		{
			m_rData.m_fFirstWrite = false;
			m_rData.m_cbLength = 0;
		}
		if (m_rData.m_piCurrentStream != this)
		{
			AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, 0, 0, FILE_END) - 0xFFFFFFFFL);
			m_rData.m_piCurrentStream = this;
		}

		unsigned long cbWritten = 0;
		WIN::WriteFile(m_rData.m_hFile, m_rgbBuffer, m_cbUsed, &cbWritten, 0);
		m_rData.m_cbLength += cbWritten;
		if (cbWritten != m_cbUsed)
			m_issState = issError;
		m_cbCopied += cbWritten;
		m_cbUsed = 0;
	}
	else if (m_issState == issRead)
		m_cbUsed = m_cbBuffer = sizeof(m_rgbBuffer);
}

IMsiStream* CMsiFileStream::Clone()
{
	if (m_rData.m_fWrite)
	{
		AssertSz(fFalse, "Cannot close a CMsiFileStream for writing");
		return 0;
	}
	++m_rData.m_cStreams;
	return new CMsiFileStream(m_rData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\dbview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbview.cpp
//
//--------------------------------------------------------------------------

/*____________________________________________________________________________

File:	dbview.cpp 
Purpose:CMsiView implementation  
Notes:	Need to optimise for strings not in the database
		Need to pass back the exact syntax error that occured in case of OpenView
		failure.

____________________________________________________________________________*/

/*____________________________________________________________________________
The Grammar supported by the Darwin for the SQL queries is described below. 
The grammar is the result of left-factoring and removing left-recursion. 
The non-terminals are denoted by words in bold and are in all capitals. 
The terminals are denoted by words in all small capitals. The grammar is LL(1) 
and corresponds to the implemented recursive descent parser. 
Null productions have only the symbol " /\ " on their right hand side. 

1.  SQL					--> STMT eos
2.  STMT				--> select DISTINCT-PHRASE COLUMN-LIST from TABLE-LIST PREDICATE ORDER
3.  COLUMN-LIST			--> COLUMN-ELEMENT COLUMN-LIST-TAIL
4.  COLUMN-ELEMENT		--> COLUMNID COLUMN-LIST-TAIL
5.  COLUMN-ELEMENT		--> LITERAL COLUMN-LIST-TAIL
6.  COLUMN-ELEMENT		--> starid COLUMN-LIST-TAIL
7.  COLUMN-ELEMENT		--> parameter
8.  COLUMN-ELEMENT		--> null  COLUMN-LIST-TAIL 
9.  COLUMNID			--> id COLUMNID-TAIL
10.  COLUMNID-TAIL		--> dotid id
11.  COLUMNID-TAIL		--> /\
12.  LITERAL			--> literal-string
13.  LITERAL			--> literal-integer
14.  COLUMN-LIST-TAIL	--> comma COLUMN-LIST
15.  COLUMN-LIST-TAIL	--> /\
16.  TABLE-LIST			--> id  TABLEID-TAIL TABLE-LIST-TAIL
17.  TABLEID-TAIL		--> as id
18.  TABLEID-TAIL		--> /\
19.  TABLE-LIST-TAIL	--> comma TABLE-LIST
20.  TABLE-LIST-TAIL	--> /\
21.  PREDICATE			--> where EXPRESSION
22.  PREDICATE			--> /\
23.  EXPRESSION			--> EXPR-1 EXPR-1-TAIL
24.  EXPR-1-TAIL		--> orop EXPR-1 EXPR-1-TAIL
25.  EXPR-1-TAIL		--> /\
26.  EXPR-1				--> EXPR-2 EXPR-2-TAIL
27.  EXPR-2-TAIL		--> andop EXPR-2 EXPR-2-TAIL
28.  EXPR-2-TAIL		--> /\
29.  EXPR-2				--> bopen EXPRESSION bclose
30.  EXPR-2				--> notop EXPR-2 //!! not supported
31.  EXPR-2				--> COLUMNID E2-TAIL
32.  E2-TAIL			--> RELOP COLM-OPERAND
33.  E2-TAIL			--> equal COLM-OPERAND1
34.  RELOP				--> not-equal
35.  RELOP				--> less-equal
36.  RELOP				--> greater-equal
37.  RELOP				--> greater
38.  RELOP				--> less
39.  COLM-OPERAND1		--> COLM-OPERAND
40.  COLM-OPERAND1		--> COLUMNID
41.  COLM-OPERAND		--> LITERAL
42.  COLM-OPERAND		--> null
43.  COLM-OPERAND		--> parameter
44.  EXPR-2				--> literal-string E2-TAIL1
45.  E2-TAIL1			--> equal STR-OPERAND
46.  E2-TAIL1			--> not-equal STR-OPERAND
47.  STR-OPERAND		--> literal-string
48.  STR-OPERAND		--> parameter
49.  STR-OPERAND		--> null
50.  STR-OPERAND		--> COLUMNID
51.  EXPR-2				--> literal-integer E2-TAIL2
52.  E2-TAIL2			--> RELOP INT-OPERAND
53.  E2-TAIL2			--> equal INT-OPERAND
54.  INT-OPERAND		--> literal-integer
55.  INT-OPERAND		--> parameter
56.  INT-OPERAND		--> null
57.  INT-OPERAND		--> COLUMNID
58.  EXPR-2				--> parameter E2-TAIL3
59.  E2-TAIL3			--> RELOP PAR-OPERAND
60.  E2-TAIL3			--> equal PAR-OPERAND
61.  PAR-OPERAND		--> LITERAL
62.  PAR-OPERAND		--> null
63.  PAR-OPERAND		--> COLUMNID
64.  EXPR-2				--> null E2-TAIL4
65.  E2-TAIL4			--> equal NUL- OPERAND
66.  E2-TAIL4			--> RELOP NUL- OPERAND
67.  NUL- OPERAND		--> LITERAL
68.  NUL- OPERAND		--> null
69.  NUL- OPERAND		--> COLUMID
70.  NUL- OPERAND		--> parameter
71.  ORDER				--> order by COLUMNID ORDER-TAIL
72.  ORDER				--> /\
73.  ORDER-TAIL			--> comma COLUMNID ORDER-TAIL
74.  ORDER-TAIL			--> /\
75.	 DISTINCT-PHRASE	--> distinct
76.	 DISTINCT-PHRASE	--> /\
____________________________________________________________________________*/

// includes
#include "precomp.h" 
#include "_databas.h" // local factories
#include "tables.h" // table and column name definitions
#ifdef MAC
#include "macutil.h"
#include <Folders.h>
#endif

// macro wrapper for IMsiRecord* errors
#define RETURN_ERROR_RECORD(function){							\
							IMsiRecord* piError;	\
							piError = function;		\
							if(piError)				\
								return piError;		\
						}

// defines used in the file
const unsigned int iMsiMissingString = ~(unsigned int)0; // max value, hopefully the database will never have these many strings
const unsigned int iMsiNullString = 0;
const unsigned int iopAND = 0x8000;
const unsigned int iopOR = 0x4000;
const unsigned int iopANDOR = iopAND | iopOR;


// reserved table and column names
const ICHAR* CATALOG_TABLE  = TEXT("_Tables");
const ICHAR* CATALOG_COLUMN = TEXT("_Columns");
const ICHAR* ROWSTATE_COLUMN = TEXT("_RowState");


// internal ivcEnum defines
static const int ivcCreate          = 16;
static const int ivcAlter           = 32;
static const int ivcDrop            = 64;
static const int ivcInsertTemporary = 128;

// charnext function - selectively calls WIN::CharNext

inline void Lex::CharNext(ICHAR*& rpchCur)
{
#ifdef UNICODE
	rpchCur ++;
#else
	if(!g_fDBCSEnabled)
		rpchCur ++;
	else
	{
		rpchCur = WIN::CharNext(rpchCur);
	}
#endif
}



const ICHAR STD_WHITE_SPACE = ' ';

// the string to ipqTok map
const TokenStringList Lex::m_rgTokenStringArray[] = {
	TokenStringList(TEXT("SELECT"), ipqTokSelect),
	TokenStringList(TEXT("FROM"), ipqTokFrom),
	TokenStringList(TEXT("AS"), ipqTokAs),
	TokenStringList(TEXT("WHERE"), ipqTokWhere),
	TokenStringList(TEXT("NULL"), ipqTokNull),
	TokenStringList(TEXT("OR"),ipqTokOrOp),
	TokenStringList(TEXT("AND"), ipqTokAndOp),
	TokenStringList(TEXT("NOT"), ipqTokNotop),
	TokenStringList(TEXT("ORDER"), ipqTokOrder),
	TokenStringList(TEXT("BY"), ipqTokBy),
	TokenStringList(TEXT("DISTINCT"), ipqTokDistinct),
	TokenStringList(TEXT("UPDATE"), ipqTokUpdate),
	TokenStringList(TEXT("DELETE"), ipqTokDelete),
	TokenStringList(TEXT("INSERT"), ipqTokInsert),
	TokenStringList(TEXT("INTO"), ipqTokInto),
	TokenStringList(TEXT("SET"), ipqTokSet),
	TokenStringList(TEXT("VALUES"), ipqTokValues),
	TokenStringList(TEXT("IS"),  ipqTokIs),
	TokenStringList(TEXT("CREATE"),  ipqTokCreate),
	TokenStringList(TEXT("DROP"),  ipqTokDrop),
	TokenStringList(TEXT("ALTER"),  ipqTokAlter),
	TokenStringList(TEXT("TABLE"),  ipqTokTable),
	TokenStringList(TEXT("ADD"),  ipqTokAdd),
	TokenStringList(TEXT("PRIMARY"),  ipqTokPrimary),
	TokenStringList(TEXT("KEY"),  ipqTokKey),
	TokenStringList(TEXT("CHAR"),  ipqTokChar),
	TokenStringList(TEXT("CHARACTER"),  ipqTokCharacter),
	TokenStringList(TEXT("VARCHAR"),  ipqTokVarChar),
	TokenStringList(TEXT("LONGCHAR"),  ipqTokLongChar),
	TokenStringList(TEXT("INT"),  ipqTokInt),
	TokenStringList(TEXT("INTEGER"),  ipqTokInteger),
	TokenStringList(TEXT("SHORT"),  ipqTokShort),
	TokenStringList(TEXT("LONG"),  ipqTokLong),
	TokenStringList(TEXT("OBJECT"),  ipqTokObject),
	TokenStringList(TEXT("TEMPORARY"),  ipqTokTemporary),
	TokenStringList(TEXT("HOLD"),  ipqTokHold),
	TokenStringList(TEXT("FREE"),  ipqTokFree),
	TokenStringList(TEXT("LOCALIZABLE"),  ipqTokLocalizable),
	TokenStringList(TEXT(""), ipqTokEnd) // end condition
};

// special characters understood by lex
const ICHAR Lex::m_chQuotes   = '\'';
const ICHAR Lex::m_chIdQuotes = STD_IDENTIFIER_QUOTE_CHAR;
const ICHAR Lex::m_chSpace    = STD_WHITE_SPACE;
const ICHAR Lex::m_chEnd      = 0;

// the ICHAR to ipqTok map
const TokenCharList Lex::m_rgTokenCharArray[] = {
	TokenCharList(Lex::m_chQuotes, ipqTokQuotes),
	TokenCharList(Lex::m_chIdQuotes, ipqTokIdQuotes),
	TokenCharList(Lex::m_chSpace, ipqTokWhiteSpace),
	TokenCharList('.', ipqTokDot),
	TokenCharList('(', ipqTokOpen),
	TokenCharList(')', ipqTokClose),
	TokenCharList(',', ipqTokComma),
	TokenCharList('=', ipqTokEqual),
	TokenCharList('>', ipqTokGreater),
	TokenCharList('<', ipqTokLess),
	TokenCharList('?', ipqTokParam),
	TokenCharList('*', ipqTokStar),
	TokenCharList(Lex::m_chEnd, ipqTokEnd) // end condition
};

// constructor
Lex::Lex(const ICHAR* szSQL):m_ipos(0)
{
	// need to copy string into own array, since we modify string in place for token identification

	//?? Is there a reason that we always resize the buffer w/o first checking whether it's big enough? -- malcolmh
	if(szSQL && *szSQL)
	{
		//!! AssertNonZero
		m_szBuffer.SetSize(IStrLen(szSQL) + 1);
		ASSERT_IF_FAILED(StringCchCopy(m_szBuffer, m_szBuffer.GetSize(), szSQL));
	}
	else
	{
		// empty string
		//!! AssertNonZero
		m_szBuffer.SetSize(1);
		m_szBuffer[0] = 0;
	}
}

// destructor
Lex::~Lex()
{
}

Bool Lex::Skip(const ipqToken& rtokSkipUpto)
{
	for(;;)
	{
		const ipqToken& rtokTmp = GetNextToken(m_ipos, 0, 0);
		if(rtokTmp == rtokSkipUpto)
			return fTrue;
		if(rtokTmp == ipqTokEnd)
			return fFalse;
	}
}

Bool Lex::MatchNext(const ipqToken& rtokToMatch)
{
	INT_PTR inewPos = m_ipos; // store current pointer, forward only if matched		//--merced: changed int to INT_PTR
	const ipqToken& rtokTmp = GetNextToken(inewPos, &rtokToMatch, 0);
	if(rtokTmp == rtokToMatch)
	{
		m_ipos = inewPos;
		return fTrue;
	}
	else
		return fFalse;
}

Bool Lex::InspectNext(const ipqToken& rtokToInspect)
{
	INT_PTR inewPos = m_ipos;		//--merced: changed int to INT_PTR
	const ipqToken& rtokTmp = GetNextToken(inewPos, &rtokToInspect, 0);
	return (rtokTmp == rtokToInspect) ? fTrue : fFalse;
}

const ipqToken& Lex::GetNext(const IMsiString*& rpistrToken)
{	
	return GetNextToken(m_ipos, 0, &rpistrToken);
}

const ipqToken& Lex::GetNext()
{
	return GetNextToken(m_ipos, 0, 0);
}

int Lex::NumEntriesInList(const ipqToken& rtokEnds,const ipqToken& rtokDelimits)
{
	INT_PTR inewPos = m_ipos;		//--merced: changed int to INT_PTR
	int iEntries = 1;// we should be returning 0 if there is nothing in the list
	// ipqTokEnd token should always be one of the endTokens
	ipqToken tokEndsend = rtokEnds | ipqTokEnd;
	for(;;)
	{
		const ipqToken& rtokTmp = GetNextToken(inewPos, 0, 0);
		if(rtokTmp & rtokDelimits)
			iEntries ++;
		if(rtokTmp & tokEndsend) 
			return iEntries;
	}
}

const ipqToken& Lex::GetCharToken(ICHAR cCur)
{
	int nTmp = 0;
	do{
		if(m_rgTokenCharArray[nTmp].string == cCur)
			// ipqTok found
			return m_rgTokenCharArray[nTmp].ipqTok;
	}while(m_rgTokenCharArray[nTmp++].string);// we should be using ++nTmp here
	return ipqTokUnknown;
}

const ipqToken& Lex::GetStringToken(ICHAR* pcCur, const ipqToken* ptokHint)
{
	int nTmp = 0;
	if(ptokHint)
	{
		// is this a string token
		do{
			if(m_rgTokenStringArray[nTmp].ipqTok ==  *ptokHint)
			{
				// ipqTok found, try matching
				if(!IStrCompI(m_rgTokenStringArray[nTmp].string, pcCur))
					return m_rgTokenStringArray[nTmp].ipqTok;
				else
					break;
			}
		}while(m_rgTokenStringArray[nTmp++].ipqTok != ipqTokEnd);// we should be using ++nTmp here
	}
	nTmp = 0;
	do{
		if(!IStrCompI(m_rgTokenStringArray[nTmp].string, pcCur))
			// ipqTok found
			return m_rgTokenStringArray[nTmp].ipqTok;
	}while(*(m_rgTokenStringArray[nTmp++].string));
	return ipqTokUnknown;
}

// function to get the next ipqTok, the passed in current position is advanced
const ipqToken& Lex::GetNextToken(INT_PTR& currPos, const ipqToken* ptokHint, const IMsiString** ppistrRet)		//--merced: changed int to INT_PTR
{
	ICHAR* pchCur = &m_szBuffer[currPos];
	// get the ipqTok string, remove spaces

	while(*pchCur == m_chSpace)
		pchCur ++; //?? we dont need an CharNext here, do we?

	// beginning of the token
	ICHAR* pchBegin = pchCur;

	// check if ipqTok is char
	const ipqToken* ptokToRet = &GetCharToken(*pchBegin);
	if(*ptokToRet != ipqTokEnd)
	{
		// we are not at the end
		// increment to next pos
		Lex::CharNext(pchCur);
	}
	if(*ptokToRet == ipqTokUnknown) 
	{
		// ipqTok not found, not char, not literal string
		// skip till next delimiter
		while(GetCharToken(*pchCur) == ipqTokUnknown)
		{
			Lex::CharNext(pchCur);
		}
		// plant string terminator, temporarily 	
		ICHAR cTemp = *pchCur;
		*pchCur = 0;


		// which ipqTok is this?
		ptokToRet = &GetStringToken(pchBegin, ptokHint);

		// restore original char at temporary string terminator
		*pchCur = cTemp;

		if(*ptokToRet == ipqTokUnknown)
		{
			// check if literali or id
			ICHAR* pchTmp = pchBegin;
			if(*pchTmp == '-')
				pchTmp ++;//?? we dont need an CharNext here, do we?
			
			while((*pchTmp >= '0') && (*pchTmp <= '9'))
				pchTmp ++;//?? we dont need an CharNext here, do we?
			if(pchTmp == pchCur)
			{
				ptokToRet = &ipqTokLiteralI;
			}
			else
			{
				ptokToRet = &ipqTokId;
			}
		}
	}
	else if(*ptokToRet == ipqTokQuotes) 
	{
		// skip the quotes
		pchBegin ++;
		while((*pchCur != m_chQuotes) && (*pchCur != m_chEnd))
		{
			Lex::CharNext(pchCur);
		}
		if(*pchCur == m_chQuotes)
			ptokToRet = &ipqTokLiteralS;
		else
			ptokToRet = &ipqTokUnknown;
	}
	else if(*ptokToRet == ipqTokIdQuotes)
	{
		// skip the quotes
		pchBegin ++;
		while((*pchCur != m_chIdQuotes) && (*pchCur != m_chEnd))
		{
			Lex::CharNext(pchCur);
		}
		if(*pchCur == m_chIdQuotes)
			ptokToRet = &ipqTokId;
		else
			ptokToRet = &ipqTokUnknown;
	}
	else if(*ptokToRet == ipqTokLess)
	{
		//!! change to int inewPos = pchCur - m_szBuffer;
		INT_PTR inewPos = currPos + (pchCur - &m_szBuffer[currPos]);		//--merced: changed int to INT_PTR
		const ipqToken& rtokTmp =  GetNextToken(inewPos, 0, 0);
		if(rtokTmp == ipqTokEqual)
		{
			pchCur = &m_szBuffer[inewPos];
			ptokToRet = &ipqTokLessEq;
		}
		else if(rtokTmp == ipqTokGreater)
		{
			pchCur = &m_szBuffer[inewPos];
			ptokToRet = &ipqTokNotEq;
		}
	}
	else if(*ptokToRet == ipqTokGreater)
	{
		//!! change to int inewPos = pchCur - m_szBuffer;
		INT_PTR inewPos = currPos + (pchCur - &m_szBuffer[currPos]);		//--merced: changed int to INT_PTR
		const ipqToken& rtokTmp =  GetNextToken(inewPos, 0, 0);
		if(rtokTmp == ipqTokEqual)
		{
			pchCur = &m_szBuffer[inewPos];
			ptokToRet = &ipqTokGreaterEq;
		}
	}
	if(ppistrRet != 0)
	{
		// need to return the value of the token
		*ppistrRet = &CreateString();

		if((*ptokToRet != ipqTokEnd) && (*ptokToRet != ipqTokUnknown))
		{
			// plant string terminator, temporarily 	
			ICHAR cTemp = *pchCur;
			*pchCur = 0;
			(*ppistrRet)->SetString(pchBegin, *ppistrRet);
			*pchCur = cTemp;
		}
	}
	if((*ptokToRet == ipqTokLiteralS) || ((*ptokToRet == ipqTokId) && (*pchCur == m_chIdQuotes)))
		// skip the quotes
		pchCur++;//?? we dont need an CharNext here, do we?
	//!! change to currPos = pchCur - m_szBuffer;
//	Assert (pchCur - &m_szBuffer[currPos] <= INT_MAX);		//--merced: 64-bit ptr subtraction may lead to values too big for currPos
	currPos = currPos + (int)(INT_PTR)(pchCur - &m_szBuffer[currPos]);
	return *ptokToRet;
}

// derivation used exclusively by CMsiView
CMsiDCursor::CMsiDCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, CMsiView& cView, int iHandle)
:CMsiCursor(riTable, riDatabase, fFalse), m_cView(cView), m_iHandle(iHandle)
{
}

void CMsiDCursor::RowDeleted(unsigned int iRow, unsigned int iPrevNode)
{
	m_riDatabase.Block();
	CMsiCursor::RowDeleted(iRow, iPrevNode);
	m_riDatabase.Unblock();
	// notify the View
	m_cView.RowDeleted(iRow, m_iHandle);
}

void CMsiDCursor::RowInserted(unsigned int iRow)
{
	CMsiCursor::RowInserted(iRow);
	// notify the View
	m_cView.RowInserted(iRow, m_iHandle);
}

inline int CMsiDCursor::GetRow()
{
	return m_iRow;
}

inline void CMsiDCursor::SetRow(int iRow)
{
	m_iRow = iRow;
	m_riDatabase.Block();
	m_riTable.FetchRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
}





CScriptView::CScriptView(CScriptDatabase& riDatabase, IMsiServices& riServices):
m_riDatabase(riDatabase),
m_riServices(riServices),
m_piPrevRecord(0),
m_iScriptVersion(0),
m_pStream(0)
{
	m_riDatabase.AddRef();
	m_riServices.AddRef();
}

IMsiRecord* __stdcall CScriptView::Initialise(const ICHAR* szScriptFile) {
	return m_riServices.CreateFileStream(szScriptFile, fFalse, *&m_pStream);
}

IMsiRecord*  __stdcall CScriptView::Execute(IMsiRecord* /*piParams*/) {
	return 0;
}

#define MSIXA0()                             
#define MSIXA1(a)                              MSIXA0()                             TEXT( "{") TEXT(#a) TEXT("=[1]}")
#define MSIXA2(a,b)                            MSIXA1(a)                            TEXT(",{") TEXT(#b) TEXT("=[2]}")
#define MSIXA3(a,b,c)                          MSIXA2(a,b)                          TEXT(",{") TEXT(#c) TEXT("=[3]}")
#define MSIXA4(a,b,c,d)                        MSIXA3(a,b,c)                        TEXT(",{") TEXT(#d) TEXT("=[4]}")
#define MSIXA5(a,b,c,d,e)                      MSIXA4(a,b,c,d)                      TEXT(",{") TEXT(#e) TEXT("=[5]}")
#define MSIXA6(a,b,c,d,e,f)                    MSIXA5(a,b,c,d,e)                    TEXT(",{") TEXT(#f) TEXT("=[6]}")
#define MSIXA7(a,b,c,d,e,f,g)                  MSIXA6(a,b,c,d,e,f)                  TEXT(",{") TEXT(#g) TEXT("=[7]}")
#define MSIXA8(a,b,c,d,e,f,g,h)                MSIXA7(a,b,c,d,e,f,g)                TEXT(",{") TEXT(#h) TEXT("=[8]}")
#define MSIXA9(a,b,c,d,e,f,g,h,i)              MSIXA8(a,b,c,d,e,f,g,h)              TEXT(",{") TEXT(#i) TEXT("=[9]}")
#define MSIXA10(a,b,c,d,e,f,g,h,i,j)           MSIXA9(a,b,c,d,e,f,g,h,i)            TEXT(",{") TEXT(#j) TEXT("=[10]}")
#define MSIXA11(a,b,c,d,e,f,g,h,i,j,k)         MSIXA10(a,b,c,d,e,f,g,h,i,j)         TEXT(",{") TEXT(#k) TEXT("=[11]}")
#define MSIXA12(a,b,c,d,e,f,g,h,i,j,k,l)       MSIXA11(a,b,c,d,e,f,g,h,i,j,k)       TEXT(",{") TEXT(#l) TEXT("=[12]}")
#define MSIXA13(a,b,c,d,e,f,g,h,i,j,k,l,m)     MSIXA12(a,b,c,d,e,f,g,h,i,j,k,l)     TEXT(",{") TEXT(#m) TEXT("=[13]}")
#define MSIXA14(a,b,c,d,e,f,g,h,i,j,k,l,m,n)   MSIXA13(a,b,c,d,e,f,g,h,i,j,k,l,m)   TEXT(",{") TEXT(#n) TEXT("=[14]}")
#define MSIXA15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) MSIXA14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) TEXT(",{") TEXT(#o) TEXT("=[15]}")
#define MSIXA16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)           MSIXA15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)           TEXT(",{") TEXT(#p) TEXT("=[16]}")
#define MSIXA17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)         MSIXA16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)         TEXT(",{") TEXT(#q) TEXT("=[17]}")
#define MSIXA18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)       MSIXA17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)       TEXT(",{") TEXT(#r) TEXT("=[18]}")
#define MSIXA19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)     MSIXA18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)     TEXT(",{") TEXT(#s) TEXT("=[19]}")
#define MSIXA20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)   MSIXA19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)   TEXT(",{") TEXT(#t) TEXT("=[20]}")
#define MSIXA21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) MSIXA20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) TEXT(",{") TEXT(#u) TEXT("=[21]}")
#define MSIXA22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)   MSIXA21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)   TEXT(",{") TEXT(#v) TEXT("=[22]}")
#define MSIXA23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) MSIXA22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) TEXT(",{") TEXT(#w) TEXT("=[23]}")

const ICHAR* rgszixo[] = {
#define MSIXO(op,type,args) TEXT(#op) TEXT("(") args TEXT(")"),
#include "opcodes.h"
};

int GetScriptMajorVersionFromHeaderRecord(IMsiRecord* piRecord);

IMsiRecord*  __stdcall CScriptView::Fetch()
{
	if (m_piPrevRecord != 0)
		m_piPrevRecord->SetInteger(0, m_ixoPrev);
	IMsiRecord* piRecord = m_riServices.ReadScriptRecord(*m_pStream, *&m_piPrevRecord, m_iScriptVersion);
	if (piRecord)
	{
		piRecord->SetString(0, rgszixo[m_ixoPrev = (ixoEnum)piRecord->GetInteger(0)]);
		if (m_ixoPrev == ixoHeader)
		{
			m_iScriptVersion = GetScriptMajorVersionFromHeaderRecord(piRecord);
		}
	}			

	return piRecord;
}

IMsiRecord*  __stdcall CScriptView::Close() {
	return 0;
}



unsigned long CScriptView::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}


unsigned long CScriptView::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	PMsiServices piServices (&m_riServices); // release after delete
	delete this;
	return 0;
}



CScriptView::~CScriptView() {
	m_riDatabase.Release();
	if (m_piPrevRecord != 0)
	{
		m_piPrevRecord->Release();
		m_piPrevRecord = 0;
	}

}


// table name if failure on creating internal table
const ICHAR* szInternal = TEXT("Internal Table");

IMsiRecord* CMsiView::CheckSQL(const ICHAR* sqlquery)
{
	m_istrSqlQuery = sqlquery; // necessary for error messages
	// create the lex
	Lex lex(sqlquery);
	// we now support SELECT, UPDATE, INSERT and DELETE
	const ipqToken& rtok = lex.GetNext();
	if(rtok == ipqTokSelect)
	{
		m_ivcIntent = ivcEnum(m_ivcIntent | ivcFetch);
		/*
		if(!(m_ivcIntent & ivcFetch)) // have to Fetch in SELECT mode
			return m_riDatabase.PostError(Imsg(idbgDbIntentViolation));
		*/

		RETURN_ERROR_RECORD(ParseSelectSQL(lex));
	}
	else if(rtok == ipqTokUpdate)
	{
		//!! force to be only update mode
		// cannot make this a requirement to be set from outside as ODBC driver is transparant
		// to the actual sql query that is passed in
		m_ivcIntent = ivcUpdate;
		RETURN_ERROR_RECORD(ParseUpdateSQL(lex));
	}
	else if(rtok == ipqTokInsert)
	{
		//!! force to be only insert mode
		// cannot make this a requirement to be set from outside as ODBC driver is transparant
		// to the actual sql query that is passed in
		m_ivcIntent = ivcInsert; // may be changed to ivcInsertTemporary by ParseInsertSQL
		RETURN_ERROR_RECORD(ParseInsertSQL(lex));
	}
	else if(rtok == ipqTokDelete)
	{
		//!! force to be only delete mode
		// cannot make this a requirement to be set from outside as ODBC driver is transparant
		// to the actual sql query that is passed in
		m_ivcIntent = ivcDelete;
		RETURN_ERROR_RECORD(ParseDeleteSQL(lex));
	}
	else if(rtok == ipqTokCreate)
	{
		m_ivcIntent = (ivcEnum)ivcCreate;
		RETURN_ERROR_RECORD(ParseCreateSQL(lex));
	}
	else if(rtok == ipqTokAlter)
	{
		m_ivcIntent = (ivcEnum)ivcAlter;
		RETURN_ERROR_RECORD(ParseAlterSQL(lex));
	}
	else if(rtok == ipqTokDrop)
	{
		m_ivcIntent = (ivcEnum)ivcDrop;
		RETURN_ERROR_RECORD(ParseDropSQL(lex));
	}
	else
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseCreateSQL(Lex& lex)
{
	// table
	if(lex.MatchNext(ipqTokTable) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// <table name>
	MsiString tableName;
	const ipqToken& rtok = lex.GetNext(*&tableName);
		
	if (rtok != ipqTokId)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

	PMsiRecord piError = ResolveTable(lex, tableName);
	if((piError == 0) || (piError->GetInteger(1) != idbgDbQueryUnknownTable))
		return m_riDatabase.PostError(Imsg(idbgDbTableDefined), tableName, (const ICHAR*)m_istrSqlQuery);
	m_rgTableDefn[m_iTables].iTable = BindString(tableName);

	// (
	if(lex.MatchNext(ipqTokOpen) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// column definition
	RETURN_ERROR_RECORD(ParseCreateColumns(lex));

	// primary
	if(lex.MatchNext(ipqTokPrimary) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	

	// key
	if(lex.MatchNext(ipqTokKey) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	

	// primary columns
	RETURN_ERROR_RECORD(ParsePrimaryColumns(lex));

	// )
	if(lex.MatchNext(ipqTokClose) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// HOLD
	if(lex.MatchNext(ipqTokHold) != fFalse)
		m_fLock = fTrue;

	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}


IMsiRecord* CMsiView::ParseAlterSQL(Lex& lex)
{
	// table
	if(lex.MatchNext(ipqTokTable) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// <table name>
	MsiString tableName;
	const ipqToken& rtok = lex.GetNext(*&tableName);
		
	if (rtok != ipqTokId)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

	IMsiRecord* piError = ResolveTable(lex, tableName);
	if(piError != 0)
		return piError;

	if(lex.MatchNext(ipqTokFree) != fFalse)
		m_fLock = fFalse;
	else
	{
		// add 
		if(lex.MatchNext(ipqTokAdd) != fFalse)
		{
			// column definition
			RETURN_ERROR_RECORD(ParseCreateColumns(lex));
		}
		// HOLD
		if(lex.MatchNext(ipqTokHold) != fFalse)
			m_fLock = fTrue;
	}

	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseDropSQL(Lex& lex)
{
	// table
	if(lex.MatchNext(ipqTokTable) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// <table name>
	MsiString tableName;
	const ipqToken& rtok = lex.GetNext(*&tableName);
		
	if (rtok != ipqTokId)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

	PMsiRecord piError = ResolveTable(lex, tableName);
	if(piError != 0)
	{
		piError->AddRef();
		return piError;
	}

	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseCreateColumns(Lex & lex)
{
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokPrimary, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);

		// don't allow the RowState column to be created
		if((rtok == ipqTokId) && !(strColumn.Compare(iscExact, ROWSTATE_COLUMN)))
		{
			RETURN_ERROR_RECORD(ResolveCreateColumn(lex, strColumn, iColumnIndex++));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}while(lex.MatchNext(ipqTokComma) == fTrue);

	return 0;
}

IMsiRecord* CMsiView::ResolveCreateColumn(Lex& lex, MsiString& strColumn, int iColumnIndex)
{
	MsiStringId iColumnId = BindString(strColumn);
	// make sure the column is not repeated
	for (unsigned int iCol = iColumnIndex; iCol--;)
	{
		if(m_rgColumnDefn[iCol].iColumnIndex == iColumnId)
		{
			// repeat
			return m_riDatabase.PostError(Imsg(idbgDbQueryRepeatColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		}
	}
	if(m_ivcIntent == ivcAlter)
	{
		// make sure the column is not already on the table
		if(((m_rgTableDefn[m_iTables].piTable)->GetColumnIndex(iColumnId)) != 0)
		{
			// repeat
			return m_riDatabase.PostError(Imsg(idbgDbQueryRepeatColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		}
	}
	m_rgColumnDefn[iColumnIndex].iColumnIndex = iColumnId;
	m_rgColumnDefn[iColumnIndex].itdType = 0;
	// get the column type
	MsiString strTempToken;
	const ipqToken& rtok = lex.GetNext(*&strTempToken);
	if((rtok == ipqTokChar) || (rtok == ipqTokCharacter))
	{
		m_rgColumnDefn[iColumnIndex].itdType |= icdString;
		if(lex.MatchNext(ipqTokOpen) == fTrue)
		{
			MsiString strTextSize;
			const ipqToken& rtok1 = lex.GetNext(*&strTextSize);
			if((rtok1 != ipqTokLiteralI) || (strTextSize > icdSizeMask))//string literal
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
			m_rgColumnDefn[iColumnIndex].itdType |= (int)strTextSize;
			if(lex.MatchNext(ipqTokClose) == fFalse)
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
		}
	}
	else if(rtok == ipqTokLongChar)
	{
		m_rgColumnDefn[iColumnIndex].itdType |= icdString;
	}
	else if((rtok == ipqTokInt) || (rtok == ipqTokInteger) || (rtok == ipqTokShort))
	{
		m_rgColumnDefn[iColumnIndex].itdType |= (icdShort | 2);
	}
	else if(rtok == ipqTokLong)
	{
		m_rgColumnDefn[iColumnIndex].itdType |= (icdLong | 4);
	}
	else if(rtok == ipqTokObject)
	{
		m_rgColumnDefn[iColumnIndex].itdType |= icdObject;
	}
	else
	{
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidType), strTempToken, (const ICHAR*)m_istrSqlQuery);
	}

	RETURN_ERROR_RECORD(ParseColumnAttributes(lex, iColumnIndex));

	return 0;
}

struct ColAttrib
{
	const ipqToken* pTok;   // token 
	const ipqToken* pTok2;  // token required to follow pTok
	int icdIfMatch;         // attribute to be used if token(s) are matched
	int icdIfNoMatch;       // attribute to be used if token(s) are not matched
};

static const ColAttrib colAttribs[] = 
{
	{ &ipqTokNotop,       &ipqTokNull, icdNoNulls,     icdNullable    },
	{ &ipqTokTemporary,   0,           icdTemporary,   icdPersistent  },
	{ &ipqTokLocalizable, 0,           icdLocalizable, 0              },
	{ 0,                  0,           0,              0              },
};

IMsiRecord* CMsiView::ParseColumnAttributes(Lex& lex, int iColumnIndex)
{
	for (const ColAttrib* pColAttrib = colAttribs; pColAttrib->pTok; pColAttrib++)
	{
		if(lex.MatchNext(*(pColAttrib->pTok)) == fTrue)
		{
			if (pColAttrib->pTok2)
			{
				if (lex.MatchNext(*(pColAttrib->pTok2)) == fFalse)
				{
					return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
				}
			}
			m_rgColumnDefn[iColumnIndex].itdType |= pColAttrib->icdIfMatch;
		}
		else
		{
			// for Temporary databases (no storage), need to mark column as temporary & not persistent by default
			if (*(pColAttrib->pTok) == ipqTokTemporary && PMsiStorage(m_riDatabase.GetStorage(1)) == 0)
				m_rgColumnDefn[iColumnIndex].itdType |= icdTemporary;
			else
				m_rgColumnDefn[iColumnIndex].itdType |= pColAttrib->icdIfNoMatch;
		}
	}

	return 0;
}

IMsiRecord* CMsiView::ParsePrimaryColumns(Lex & lex)
{
	int iColumnIndex = 0;
	// get the number of primary columns
	if ((lex.NumEntriesInList(ipqTokEnd, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoPrimaryColumns), (const ICHAR*)m_istrSqlQuery);
	do
	{
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok == ipqTokId)
		{
			RETURN_ERROR_RECORD(ResolvePrimaryColumn(lex, strColumn, iColumnIndex++));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;

}

IMsiRecord* CMsiView::ResolvePrimaryColumn(Lex& /*lex*/, MsiString& strColumn, int iColumnIndex)
{
	MsiStringId iColumnId = BindString(strColumn);

	for (unsigned int iCol = m_iColumns; iCol--;)
	{
		if(m_rgColumnDefn[iCol].iColumnIndex == iColumnId)
		{
			if(m_rgColumnDefn[iCol].itdType & icdPrimaryKey)
			{
				// repeat
				return m_riDatabase.PostError(Imsg(idbgDbQueryRepeatColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
			}
			m_rgColumnDefn[iCol].itdType |= icdPrimaryKey;
			// swap with iColumnIndex
			ColumnDefn cdTemp = m_rgColumnDefn[iCol];
			m_rgColumnDefn[iCol] = m_rgColumnDefn[iColumnIndex];
			m_rgColumnDefn[iColumnIndex] = cdTemp;
			return 0;
		}
	}
	//error
	return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
}


IMsiRecord* CMsiView::ParseInsertSQL(Lex& lex)
{
	// into
	if(lex.MatchNext(ipqTokInto) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// open bracket
	if(lex.MatchNext(ipqTokOpen) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// column list
	RETURN_ERROR_RECORD(ParseInsertColumns(lex));
	// close bracket
	if(lex.MatchNext(ipqTokClose) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// values
	if(lex.MatchNext(ipqTokValues) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// open bracket
	if(lex.MatchNext(ipqTokOpen) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// values list
	RETURN_ERROR_RECORD(ParseInsertValues(lex));
	// close bracket
	if(lex.MatchNext(ipqTokClose) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// optional "TEMPORARY"
	if (lex.MatchNext(ipqTokTemporary) == fTrue)
		m_ivcIntent = (ivcEnum)ivcInsertTemporary;

	// no [where ....] clause allowed
	// no order by clause allowed
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseUpdateSQL(Lex& lex)
{
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// set
	if(lex.MatchNext(ipqTokSet) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	RETURN_ERROR_RECORD(ParseUpdateColumns(lex));
	// [where ....]
	if(lex.MatchNext(ipqTokWhere) == fTrue)
	{
		m_iExpressions = lex.NumEntriesInList(ipqTokOrder, ipqTokAndOp | ipqTokOrOp);
		if(m_iExpressions > sizeof(int)*8)
			return m_riDatabase.PostError(Imsg(idbgDbQueryExceedExpressionLimit), (const ICHAR*)m_istrSqlQuery);

		//!! AssertNonZero
		m_rgExpressionDefn.Resize(m_iExpressions + 1);
		//!! AssertNonZero
		m_rgOperationTree.Resize((m_iExpressions + 1)*2 + 1);
		unsigned int iPosInArray = 1;		
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, m_iOperations, m_iTreeParent));
	}
	// no order by clause allowed
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseDeleteSQL(Lex& lex)
{
	// first set up the tables
	if(lex.Skip(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbMissingFromClause), (const ICHAR*)m_istrSqlQuery);
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// [where ....]
	if(lex.MatchNext(ipqTokWhere) == fTrue)
	{
		m_iExpressions = lex.NumEntriesInList(ipqTokOrder, ipqTokAndOp | ipqTokOrOp);
		if(m_iExpressions > sizeof(int)*8)
			return m_riDatabase.PostError(Imsg(idbgDbQueryExceedExpressionLimit), (const ICHAR*)m_istrSqlQuery);

		//!! AssertNonZero
		m_rgExpressionDefn.Resize(m_iExpressions + 1);
		//!! AssertNonZero
		m_rgOperationTree.Resize((m_iExpressions + 1)*2 + 1);
		unsigned int iPosInArray = 1;		
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, m_iOperations, m_iTreeParent));
	}
	// no order by clause allowed
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// delete
	if(lex.MatchNext(ipqTokDelete) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// no distinct clause allowed
	// no columns allowed, m_iColumns (remains) = 0;
	// from
	if(lex.MatchNext(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseSelectSQL(Lex& lex)
{
	// first set up the tables
	if(lex.Skip(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbMissingFromClause), (const ICHAR*)m_istrSqlQuery);
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// [where ....]
	if(lex.MatchNext(ipqTokWhere) == fTrue)
	{
		m_iExpressions = lex.NumEntriesInList(ipqTokOrder, ipqTokAndOp | ipqTokOrOp);
		if(m_iExpressions > sizeof(int)*8)
			return m_riDatabase.PostError(Imsg(idbgDbQueryExceedExpressionLimit), (const ICHAR*)m_istrSqlQuery);

		//!! AssertNonZero
		m_rgExpressionDefn.Resize(m_iExpressions + 1);
		//!! AssertNonZero
		m_rgOperationTree.Resize((m_iExpressions + 1)*2 + 1);
		unsigned int iPosInArray = 1;		
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, m_iOperations, m_iTreeParent));
	}
	// [order by...]
	if(lex.MatchNext(ipqTokOrder) == fTrue)
	{
		if(lex.MatchNext(ipqTokBy) == fFalse)
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
		RETURN_ERROR_RECORD(ParseOrderBy(lex));
	}
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// select
	if(lex.MatchNext(ipqTokSelect) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// distinct
	if(lex.MatchNext(ipqTokDistinct) == fTrue)
		m_fDistinct = fTrue;
	// columns
	RETURN_ERROR_RECORD(ParseSelectColumns(lex));
	// from
	if(lex.MatchNext(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseInsertValues(Lex& lex)
{
	int iNumValues;
	// get the number of columns
	if ((iNumValues = lex.NumEntriesInList(ipqTokClose, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInsufficentValues), (const ICHAR*)m_istrSqlQuery);
	if (iNumValues != m_iColumns)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInsufficentValues), (const ICHAR*)m_istrSqlQuery);
	m_piInsertUpdateRec = &m_riServices.CreateRecord(iNumValues);
	int iColumnIndex = 1;
	do
	{
		Assert(iColumnIndex <= iNumValues);
		// set up the columns
		MsiString strColumnValue;
		const ipqToken& rtok = lex.GetNext(*&strColumnValue);
		if(rtok == ipqTokLiteralS) //string literal
			m_piInsertUpdateRec->SetMsiString(iColumnIndex, *strColumnValue);
		else if(rtok == ipqTokLiteralI) //integer literal
			m_piInsertUpdateRec->SetInteger(iColumnIndex, strColumnValue.operator int());// calls operator int
		else if(rtok == ipqTokNull) //null literal
			m_piInsertUpdateRec->SetNull(iColumnIndex);
		else if(rtok == ipqTokParam)//param (?) literal
		{
			m_iParamInputs = m_iParamInputs | (0x1 << (iColumnIndex - 1));
			m_iParams ++;
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumnValue, (const ICHAR*)m_istrSqlQuery);
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ParseUpdateColumns(Lex& lex)
{
	int iColumnDef;
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokWhere, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoUpdateColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	m_piInsertUpdateRec = &m_riServices.CreateRecord(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strColumn, (const ICHAR*)m_istrSqlQuery);
		RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnDefn[iColumnIndex].iTableIndex,
											m_rgColumnDefn[iColumnIndex].iColumnIndex, iColumnDef));
		m_rgColumnDefn[iColumnIndex].itdType = iColumnDef & icdTypeMask; //!! remove mask and save all of def


		if(lex.MatchNext(ipqTokEqual) == fFalse)
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

		MsiString strColumnValue;
		const ipqToken& rtok1 = lex.GetNext(*&strColumnValue);
		if(rtok1 == ipqTokLiteralS) //string literal
			m_piInsertUpdateRec->SetMsiString(iColumnIndex + 1, *strColumnValue);
		else if(rtok1 == ipqTokLiteralI) //integer literal
			m_piInsertUpdateRec->SetInteger(iColumnIndex + 1, strColumnValue.operator int());// calls operator int
		else if(rtok1 == ipqTokNull) //null literal
			m_piInsertUpdateRec->SetNull(iColumnIndex + 1);
		else if(rtok1 == ipqTokParam)//param (?) literal
		{
			m_iParamInputs = m_iParamInputs | (0x1 << iColumnIndex);
			m_iParams ++;
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

// get the values to be inserted in the INSERT SQL stmt.
IMsiRecord* CMsiView::ParseInsertColumns(Lex& lex)
{
	int iColumnDef;
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokClose, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoInsertColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strColumn, (const ICHAR*)m_istrSqlQuery);
		RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnDefn[iColumnIndex].iTableIndex,
											m_rgColumnDefn[iColumnIndex].iColumnIndex, iColumnDef));
		m_rgColumnDefn[iColumnIndex].itdType = iColumnDef & icdTypeMask; //!! remove mask and save all of def
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ParseSelectColumns(Lex& lex)
{
	int iColumnDef;
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokFrom, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoSelectColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok == ipqTokStar)//*
		{
			m_iColumns--; // we counted the *
			for(unsigned int iTmp = 1; iTmp <= m_iTables; iTmp++)
			{
				unsigned int iColCount = (m_rgTableDefn[iTmp].piTable)->GetColumnCount();
				m_iColumns += iColCount; 
				m_rgColumnDefn.Resize(m_iColumns);
				unsigned int cCount = 1;
				while(cCount <=  iColCount)
				{
					m_rgColumnDefn[iColumnIndex].iTableIndex = iTmp;
					m_rgColumnDefn[iColumnIndex++].iColumnIndex = cCount++;
				}
			}
			continue; // required to skip the end iColumnIndex ++;
		}
		else if(rtok == ipqTokLiteralS) //string literal
		{
			m_rgColumnDefn[iColumnIndex].iColumnIndex = BindString(strColumn);
			m_rgColumnDefn[iColumnIndex++].itdType = icdString;
		}
		else if(rtok == ipqTokLiteralI) //integer literal
		{
			m_rgColumnDefn[iColumnIndex].iColumnIndex = strColumn.operator int(); // calls operator int
			m_rgColumnDefn[iColumnIndex++].itdType = icdLong;
		}
		else if(rtok == ipqTokNull) //null literal
		{
			m_rgColumnDefn[iColumnIndex].iColumnIndex = 0;
			m_rgColumnDefn[iColumnIndex++].itdType = icdString;
		}
		else if(rtok == ipqTokParam)//param (?) literal
		{
			m_iParamOutputs = m_iParamOutputs | (0x1 << iColumnIndex);
			m_iParams ++;
		}
		else if(rtok == ipqTokId)
		{
			RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnDefn[iColumnIndex].iTableIndex,
											m_rgColumnDefn[iColumnIndex].iColumnIndex, iColumnDef));
			m_rgColumnDefn[iColumnIndex++].itdType = iColumnDef & icdTypeMask; //!! remove mask and save all of def
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ParseOrderBy(Lex& lex)
{
	int iColumnIndex = 0;
	// get the number of columns, ordered by
	if ((m_iSortColumns = lex.NumEntriesInList(ipqTokFrom, ipqTokComma)) == 0)
			return m_riDatabase.PostError(Imsg(idbgDbQueryNoOrderByColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnsortDefn.Resize(m_iSortColumns);
	do
	{
		// set up the columns
		Assert(iColumnIndex< m_iSortColumns);
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
		int iDummy;
		RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnsortDefn[iColumnIndex].iTableIndex,
													 m_rgColumnsortDefn[iColumnIndex].iColumnIndex, iDummy));
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ResolveColumn(Lex& lex, MsiString& strColumn, unsigned int& iTableIndex, unsigned int& iColumnIndex, int& iColumnDef)
{
	iTableIndex = 0;
	iColumnIndex = 0;
	iColumnDef = 0;
	if(lex.InspectNext(ipqTokDot) == fTrue)
	{
		// column is fully specified, strColumn is table name
		// RETURN_ERROR_RECORD that the table is referenced in join
		MsiStringId tableId;
		if((tableId = m_riDatabase.EncodeString((const IMsiString& )*strColumn)) == 0)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownTable), strColumn, (const ICHAR*)m_istrSqlQuery);
		for((iTableIndex = m_iTables)++; (--iTableIndex != 0 && (m_rgTableDefn[iTableIndex].iTable != tableId)););
		if(!iTableIndex)
			// table not found
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownTable), strColumn, (const ICHAR*)m_istrSqlQuery);
		// we came in here because of the ipqTokDot
		AssertNonZero(lex.MatchNext(ipqTokDot));
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}
	// set up the column
	if(strColumn.Compare(iscExact, ROWSTATE_COLUMN)) //!! possible optimization here
	{
		if(iTableIndex == 0)
		{
			if(m_iTables > 1)
				// _RowStatus part of all tables - ambiguous specification
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
			else
				iTableIndex = 1;
		}
		iColumnIndex = 0;
	}
	else
	{
		MsiStringId columnId = m_riDatabase.EncodeString((const IMsiString&)*strColumn);
		if(columnId == 0)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		if(iTableIndex != 0)
		{
			// for fully specified columns
			if((iColumnIndex = (m_rgTableDefn[iTableIndex].piTable)->GetColumnIndex(columnId)) == 0)
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
			
		}
		else
		{
			// set up the table
			for(unsigned int iTmp = m_iTables + 1, iCnt = 0; --iTmp != 0;)
			{
				unsigned int iIndex = (m_rgTableDefn[iTmp].piTable)->GetColumnIndex(columnId);
				if(iIndex)
				{
					// column found
					iTableIndex = iTmp;
					iColumnIndex = iIndex;
					iCnt ++;
				}
			}
			if(iCnt != 1)
				// not present or ambiguous
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		}
	}
	iColumnDef = m_rgTableDefn[iTableIndex].piTable->GetColumnType(iColumnIndex);
	return 0;
}

IMsiRecord* CMsiView::ParseTables(Lex& lex)
{

	do
	{	
		// set up the tables
		MsiString tableName;
		const ipqToken& rtok = lex.GetNext(*&tableName);
		
		if (rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

		RETURN_ERROR_RECORD(ResolveTable(lex, tableName));
//		fRet = ((ipqTok == ipqTokId) && (ResolveTable(lex, tableName) == fTrue)) ? fTrue : fFalse;

	}while(lex.MatchNext(ipqTokComma) == fTrue);
	
	return 0;
}

IMsiRecord* CMsiView::ResolveTable(Lex& lex, MsiString& tableName)
{
	// increase array size, 10 units at a time
	PMsiRecord piError(0);
	m_rgTableDefn.Resize(((++m_iTables)/10 + 1) * 10);
	// is the table one of the catalog tables
	if(tableName.Compare(iscExact, CATALOG_TABLE))//?? case sensitive
		m_rgTableDefn[m_iTables].piTable = m_riDatabase.GetCatalogTable(0);
	else if(tableName.Compare(iscExact, CATALOG_COLUMN))//?? case sensitive
		m_rgTableDefn[m_iTables].piTable = m_riDatabase.GetCatalogTable(1);
	else
	{
		piError = m_riDatabase.LoadTable(*tableName, 0, *&m_rgTableDefn[m_iTables].piTable);
		if (piError)
		{
			if (piError->GetInteger(1) == idbgDbTableUndefined)
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownTable), tableName, (const ICHAR*)m_istrSqlQuery);
			else
				return m_riDatabase.PostError(Imsg(idbgDbQueryLoadTableFailed), tableName, (const ICHAR*)m_istrSqlQuery);
		}
	}	
	//?? ugly cast in following since CMsiCursor class constructor takes reference to CMsiTable class
	m_rgTableDefn[m_iTables].piCursor = new CMsiDCursor(*((CMsiTable* )(IMsiTable* )(m_rgTableDefn[m_iTables].piTable)), m_riDatabase, *this, m_iTables);
	if(lex.MatchNext(ipqTokAs) == fTrue)
	{
		// table alias
		const ipqToken& rtok = lex.GetNext(*&tableName);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery );
	}
	// make sure the table is not repeated
	m_rgTableDefn[m_iTables].iTable = BindString(tableName);
	for(int iPrev = m_iTables; --iPrev != 0;)
		if(m_rgTableDefn[m_iTables].iTable == m_rgTableDefn[iPrev].iTable)
			return m_riDatabase.PostError(Imsg(idbgDbQueryTableRepeated), tableName, (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseExpression(Lex& lex,unsigned int& iPosInArray,unsigned int& iPosInTree,unsigned int& iChild)
{
	// set expression tree
	RETURN_ERROR_RECORD(ParseExpr2(lex, iPosInArray, iPosInTree, iChild));
	if(lex.MatchNext(ipqTokOrOp) == fTrue)
	{
		m_rgOperationTree[iChild].iParentIndex = iPosInTree;
		m_rgOperationTree[iPosInTree].iValue = iopOR;
		int iToRet = iChild = iPosInTree;
		iPosInTree ++;
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, iPosInTree, iChild));
		m_rgOperationTree[iChild].iParentIndex = iToRet;
		iChild = iToRet;
	}
	return 0;
}

inline Bool CompatibleTypes(int icdLHS, int icdRHS)
{
	return (((icdLHS & icdTypeMask) == (icdRHS & icdTypeMask)) ||
		   (((icdLHS & icdTypeMask) == icdShort) && ((icdRHS & icdTypeMask) == icdLong)) ||
		   (((icdLHS & icdTypeMask) == icdLong)  && ((icdRHS & icdTypeMask) == icdShort))) ? fTrue : fFalse;
}

IMsiRecord* CMsiView::ParseExpr2(Lex& lex,unsigned int& iPosInArray,unsigned int& iPosInTree,unsigned int& iChild)
{
	if(lex.MatchNext(ipqTokOpen) == fTrue)
	{
		//(expression)
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, iPosInTree, iChild));
		if (lex.MatchNext(ipqTokClose) == fFalse)
			return m_riDatabase.PostError(Imsg(idbgDbQueryMissingCloseParen), (const ICHAR*)m_istrSqlQuery);
	}
	else
	{
		//!! we do not support "NOT"
		// comparison
		MsiString strToken1;
		MsiString strToken2;
		const ipqToken* ptok1 = &lex.GetNext(*&strToken1);
		if(*ptok1 == ipqTokId)
		{
			int iDummy;
			RETURN_ERROR_RECORD(ResolveColumn(lex, strToken1, m_rgExpressionDefn[iPosInArray].iTableIndex1, 
					m_rgExpressionDefn[iPosInArray].iColumn1, iDummy));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken1, (const ICHAR*)m_istrSqlQuery);
		MsiString istrTempTok;
		const ipqToken* ptok2 = &lex.GetNext(*&istrTempTok);
		const ipqToken* ptok3 = &lex.GetNext(*&strToken2);
		if(*ptok2 == ipqTokIs)
		{
			if (*ptok3 == ipqTokNull)
			{
				ptok2 = &ipqTokEqual;
			}
			else if ((*ptok3 == ipqTokNotop) && (*(ptok3 = &lex.GetNext(*&istrTempTok)) == ipqTokNull))
			{
				ptok2 = &ipqTokNotEq;
			}
			else
			{
				return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidOperator), istrTempTok, (const ICHAR*)m_istrSqlQuery);
			}
		}
		m_rgExpressionDefn[iPosInArray].ptokOperation = ptok2;
		if((*ptok2 != ipqTokEqual) && (*ptok2 != ipqTokGreater)  && (*ptok2 != ipqTokLess) &&
			(*ptok2 != ipqTokGreaterEq) && (*ptok2 != ipqTokLessEq) && (*ptok2 != ipqTokNotEq))
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidOperator), istrTempTok, (const ICHAR*)m_istrSqlQuery);
		if(*ptok3 == ipqTokNull)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			m_rgExpressionDefn[iPosInArray].iColumn2 = 0;
		}
		else if(*ptok3 == ipqTokLiteralS)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			// !! need to optimise on missing strings
			m_rgExpressionDefn[iPosInArray].iColumn2 = BindString(strToken2);
		}
		else if(*ptok3 == ipqTokLiteralI)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			m_rgExpressionDefn[iPosInArray].iColumn2 = strToken2.operator int(); // calls operator int
		}
		else if(*ptok3 == ipqTokParam)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			m_rgExpressionDefn[iPosInArray].iColumn2 = 0;
			m_iParamExpressions = m_iParamExpressions | (0x1 << (iPosInArray - 1));
			m_iParams ++;
		}
		else if(*ptok3 == ipqTokId)
		{
			int iDummy;
			RETURN_ERROR_RECORD(ResolveColumn(lex, strToken2, m_rgExpressionDefn[iPosInArray].iTableIndex2, 
					m_rgExpressionDefn[iPosInArray].iColumn2, iDummy));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2, (const ICHAR*)m_istrSqlQuery);
		// id ? id, only = op allowed
		if(	(*ptok1 == ipqTokId) && (*ptok3 == ipqTokId) && (*ptok2 != ipqTokEqual))
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
		if(*ptok3 == ipqTokParam)
		{
			// set the type
			m_rgExpressionDefn[iPosInArray].itdType = (*ptok1 == ipqTokLiteralS) ? icdString : icdLong;
		}
		// also one string means compare either equal or not equal
		if( ((*ptok3 == ipqTokLiteralS)) &&
			 ((*ptok2 != ipqTokEqual)    && (*ptok2 != ipqTokNotEq)))
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

		m_rgExpressionDefn[iPosInArray].ijtType = ijtNoJoin;

		Assert(m_rgExpressionDefn[iPosInArray].iTableIndex1);
		m_rgExpressionDefn[iPosInArray].itdType = m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex1].piTable->
																	GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn1) & icdTypeMask;
		// check the types
		if(m_rgExpressionDefn[iPosInArray].iTableIndex2)
		{
			// ipqTokId = ipqTokId, join
			if (!CompatibleTypes(m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex1].piTable->
					GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn1),
					m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex2].piTable->
					GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn2)))
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);//!! is itdShort vs. itdLong OK??

			// set the join type
			if((m_rgExpressionDefn[iPosInArray].iColumn1 != 1) && (m_rgExpressionDefn[iPosInArray].iColumn2 != 1))
				m_rgExpressionDefn[iPosInArray].ijtType = ijtMToMJoin;
			else if ((m_rgExpressionDefn[iPosInArray].iColumn1 == 1) && (m_rgExpressionDefn[iPosInArray].iColumn2 == 1))
				m_rgExpressionDefn[iPosInArray].ijtType = ijt1To1Join;
			else
			{
				if(m_rgExpressionDefn[iPosInArray].iColumn2 == 1)
				{
					//switch 
					unsigned int iTable = m_rgExpressionDefn[iPosInArray].iTableIndex2;
					unsigned int iColumn = m_rgExpressionDefn[iPosInArray].iColumn2;

					m_rgExpressionDefn[iPosInArray].iTableIndex2 = m_rgExpressionDefn[iPosInArray].iTableIndex1;
					m_rgExpressionDefn[iPosInArray].iColumn2 = m_rgExpressionDefn[iPosInArray].iColumn1;
					m_rgExpressionDefn[iPosInArray].iTableIndex1 = iTable;
					m_rgExpressionDefn[iPosInArray].iColumn1 = iColumn;
				}
				m_rgExpressionDefn[iPosInArray].ijtType = ijt1ToMJoin;
			}
		}
		else
		{
			// ipqTokId = literal
			switch(m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex1].piTable->
					  GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn1) & icdTypeMask)
			{
			case icdLong:
			case icdShort: //!!needed?
				if((*ptok3 == ipqTokParam) || (*ptok3 == ipqTokLiteralI))
					;
				else if(*ptok3 == ipqTokNull)
					m_rgExpressionDefn[iPosInArray].iColumn2 = (unsigned int)iMsiNullInteger;
				else
					return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2,(const ICHAR*)m_istrSqlQuery);
				break;
			case icdString:
				if((*ptok3 == ipqTokParam) || (*ptok3 == ipqTokLiteralS))
					;
				else if(*ptok3 == ipqTokNull)
					m_rgExpressionDefn[iPosInArray].iColumn2 = iMsiNullString;
				else
					return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2,(const ICHAR*)m_istrSqlQuery);
				break;
			case icdObject:
				if (*ptok3 == ipqTokNull)
					m_rgExpressionDefn[iPosInArray].iColumn2 = 0;
				else
					return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2,(const ICHAR*)m_istrSqlQuery);
				break;
			default:
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec));
			}
		}
		
		m_rgOperationTree[iPosInTree].iValue = iPosInArray;
		m_rgOperationTree[iPosInTree].iParentIndex = 0;
		iChild = iPosInTree;
		iPosInArray ++;
		iPosInTree ++;
	}
	if(lex.MatchNext(ipqTokAndOp) == fTrue)
	{
		m_rgOperationTree[iChild].iParentIndex = iPosInTree;
		m_rgOperationTree[iPosInTree].iValue = iopAND;
		int iToRet = iChild = iPosInTree;
		iPosInTree ++;
		RETURN_ERROR_RECORD(ParseExpr2(lex, iPosInArray, iPosInTree, iChild));
		m_rgOperationTree[iChild].iParentIndex = iToRet;
		iChild = iToRet;
	}
	return 0;
}

IMsiRecord* CMsiView::_Fetch()
{
	return FetchCore();
}

IMsiRecord* CMsiView::Fetch()
{
	if (!(m_ivcIntent & ivcFetch))
	{
		AssertSz(0, "Intent violation");
		return 0;
	}
	return FetchCore();
}

IMsiRecord* CMsiView::FetchCore()
{
	if (m_CursorState != dvcsFetched && m_CursorState != dvcsBound)
	{
		AssertSz(0, "Wrong database state.Did you forget to call Execute() before Fetch()?");
		return 0;
	}
	if (m_piRecord)  // row record from previous fetch
	{
		m_piRecord->AddRef(); // protect against self-destruction
		if (m_piRecord->Release() == 1) // no one else is holding on
			m_piRecord->ClearData();
		else  // too bad, must release it
		{
			m_piRecord = 0;
		}
	}
	Bool fRetCode;
	if(m_piFetchTable)
	{
		// records already fetched
		fRetCode = GetNextFetchRecord();
		m_CursorState = dvcsFetched;
	}
	else
	{
		do{
			if(m_CursorState == dvcsFetched)
			{
				fRetCode = FetchNext();
			}
			else if(m_CursorState == dvcsBound)
			{
				// fetch for the first time
				fRetCode = EvaluateConstExpressions();
				if(fRetCode == fTrue)
					fRetCode = FetchFirst();
				m_CursorState = dvcsFetched;
			}
			else
			{
				AssertSz(0, "Wrong database state");
				return 0;
			}
		}while((fRetCode == fTrue) && ((IsDistinct() == fFalse) || (FitCriteriaORExpr(m_iTreeParent) == fFalse)));
	}
	if (fRetCode != fTrue) 	
	{
		// last record fetched.
		m_piRecord = 0;
		m_CursorState = dvcsBound;
	}
	else
	{
		// add to row count if not prefetched
		if(!m_piFetchTable)
			m_lRowCount++;
		if (!m_piRecord)
			m_piRecord = &m_riServices.CreateRecord(m_iColumns);
		m_piRecord->AddRef(); // we keep a reference so we can reuse it
		FetchRecordInfoFromCursors();
		// stamp 0th field with this pointer
#ifdef _WIN64	// !merced
		m_piRecord->SetHandle(0, (HANDLE)(this));
#else
		m_piRecord->SetInteger(0, int(this));
#endif
	}
	return m_piRecord;    // client better do a Release()
}

void CMsiView::FetchRecordInfoFromCursors()
{
	for (unsigned int iCol = m_iColumns; iCol--;)
	{
		if(m_rgColumnDefn[iCol].iTableIndex == 0)
		{
			// literal
			if (m_rgColumnDefn[iCol].itdType & icdObject) // index to database string cache
			{
				MsiString strStr = m_riDatabase.DecodeString(m_rgColumnDefn[iCol].iColumnIndex);
				if(strStr.TextSize())
					m_piRecord->SetMsiString(iCol+1, *strStr);
				else
					m_piRecord->SetNull(iCol+1);
			}
			else // integer
			{
				if (m_rgColumnDefn[iCol].iColumnIndex == iMsiNullInteger)
					m_piRecord->SetNull(iCol+1);
				else
					m_piRecord->SetInteger(iCol+1, m_rgColumnDefn[iCol].iColumnIndex);
			}
		}
		else
		{
			switch((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->
					  GetColumnType(m_rgColumnDefn[iCol].iColumnIndex) & icdTypeMask)
			{
			case icdLong:// integer
			case icdShort: //!!needed?
			{
				int iTmp =	(m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetInteger(m_rgColumnDefn[iCol].iColumnIndex);
				if(iMsiNullInteger == iTmp)
					m_piRecord->SetNull(iCol+1);
				else
					m_piRecord->SetInteger(iCol+1, iTmp);
				break;
			}
			case icdString:// index to database string cache
			{
				// temp variable necessary for correct refcnt
				MsiString strString = (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetString(m_rgColumnDefn[iCol].iColumnIndex);
				if(strString.TextSize())
					m_piRecord->SetMsiString(iCol+1, *strString);
				else
					m_piRecord->SetNull(iCol+1);
				break;
			}
			case icdObject:
			{
				// IMsiData interface pointer (temp. columns or persisten streams, database code handles the difference transparantly)
				// temp variable necessary for correct refcnt
//					CComPointer<const IMsiData> piData = (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetMsiData(m_rgColumnDefn[iCol].iColumnIndex);

				// following line put in explicitly to release pointer to previously held stream.
				// this is essential in case we are holding to the same stream as the one we are 
				// attempting to read. (cannot obtain handle to OLE stream if already opened)
				m_piRecord->SetNull(iCol+1);
				PMsiData piData = (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetMsiData(m_rgColumnDefn[iCol].iColumnIndex);
				m_piRecord->SetMsiData(iCol+1, piData);
				break;
			}
			}
		}
	}
	m_piRecord->ClearUpdate();  // to detect changed fields for Update
}

// first fetch
Bool CMsiView::FetchFirst(unsigned int iTableSequence)
{
	int iRet = 0;
	Bool fContinue = fTrue;
	if(iTableSequence < (m_iTables - 1))
		fContinue = FetchFirst(iTableSequence + 1);
	while(fContinue == fTrue)
	{
		if(SetTableFilters(m_rgiTableSequence[iTableSequence]) == fTrue)
			while(((iRet = (m_rgTableDefn[m_rgiTableSequence[iTableSequence]].piCursor)->Next()) != 0) && !(FitCriteria(m_rgiTableSequence[iTableSequence])))
				;
		fContinue = ((iRet != 0) ? fFalse : FetchNext(iTableSequence + 1));
	}
	return iRet ? fTrue : fFalse;
}

// all subsequent fetches
Bool CMsiView::FetchNext(unsigned int iTableSequence)
{
	int iRet = 0;
	Bool fContinue = (iTableSequence >= m_iTables) ? fFalse : fTrue;
	while(fContinue == fTrue)
	{
		while(((iRet = (m_rgTableDefn[m_rgiTableSequence[iTableSequence]].piCursor)->Next()) != 0) && !(FitCriteria(m_rgiTableSequence[iTableSequence])))
			;
		do{
			fContinue = ((iRet != 0) ? fFalse : FetchNext(iTableSequence + 1));
				//we rerun through the table, set the filters again
		}while((fContinue != fFalse) && (SetTableFilters(m_rgiTableSequence[iTableSequence]) == fFalse));
	}
	return iRet ? fTrue : fFalse;
}

// prefetched row counts need to be updated due to a row being deleted
void CMsiView::RowDeleted(int iRow, int iTable)
{
	if(m_piFetchTable != 0)
	{
		PMsiCursor piCursor = m_piFetchTable->CreateCursor(fFalse);
		Assert(piCursor != 0);
		int fRet;
		while((fRet = piCursor->Next()) != 0)
		{
			int iRow1 = piCursor->GetInteger(m_iSortColumns + 1 + iTable);
			if(iRow1 > 0)
			{
				if(iRow1 > iRow)
				{
					AssertNonZero(piCursor->PutInteger(m_iSortColumns + 1 + iTable, iRow1 - 1) == fTrue);
					AssertNonZero(piCursor->Update() == fTrue);
				}
				else if(iRow1 == iRow)
				{
					AssertNonZero(piCursor->PutInteger(m_iSortColumns + 1 + iTable, -(iRow1 - 1)) == fTrue);
					AssertNonZero(piCursor->Update() == fTrue);
				}
			}
		}
	}
}

// prefetched row counts need to be updated due to a row being inserted
void CMsiView::RowInserted(int iRow, int iTable)
{
	if(m_piFetchTable != 0)
	{
		PMsiCursor piCursor = m_piFetchTable->CreateCursor(fFalse);
		Assert(piCursor != 0);
		int fRet;
		while((fRet = piCursor->Next()) != 0)
		{
			int iRow1 = piCursor->GetInteger(m_iSortColumns + 1 + iTable );
			if(iRow1 >= iRow)
			{
				AssertNonZero(piCursor->PutInteger(m_iSortColumns  + 1 + iTable, iRow1 + 1) == fTrue);
				AssertNonZero(piCursor->Update() == fTrue);
			}
		}
	}
}

Bool CMsiView::GetNextFetchRecord()
{
	if(m_piFetchCursor->Next())
	{
		for(unsigned int iTables = m_iTables + 1; --iTables != 0;)
		{
			// need to honour prefetched row count, hence return null cursor if row has been deleted
			int iRow = m_piFetchCursor->GetInteger(m_iSortColumns + iTables + 1);
			if(iRow <= 0)
				// row deleted
				(m_rgTableDefn[iTables].piCursor)->Reset();
			else
				(m_rgTableDefn[iTables].piCursor)->SetRow(iRow);
		}
		return fTrue;
	}
	else
		return fFalse;
}

void CMsiView::SetNextFetchRecord()
{
	int cCount = PMsiTable(&m_piFetchCursor->GetTable())->GetRowCount();
	for(unsigned int iTmp = m_iTables + 1; --iTmp != 0;)
		AssertNonZero(m_piFetchCursor->PutInteger(m_iSortColumns + 1 + iTmp, (m_rgTableDefn[iTmp].piCursor)->GetRow()) == fTrue);
	for((iTmp = m_iSortColumns)++; --iTmp != 0;)
		AssertNonZero(m_piFetchCursor->PutInteger(iTmp, (m_rgTableDefn[m_rgColumnsortDefn[iTmp - 1].iTableIndex].piCursor)->GetInteger(m_rgColumnsortDefn[iTmp - 1].iColumnIndex)) == fTrue);
	AssertNonZero(m_piFetchCursor->PutInteger(m_iSortColumns + 1, cCount) == fTrue);
	AssertNonZero(m_piFetchCursor->Insert());
}

// does the record fit all independant criteria for the table
Bool CMsiView::FitCriteria(unsigned int iTableIndex)
{
	Bool fRet = fTrue;
	int iExpression = 1;
	unsigned int iExpressions = m_rgTableDefn[iTableIndex].iExpressions;
	while((fRet == fTrue) && (iExpressions))
	{
		if(iExpressions & 0x1)
			// iExpression pertains to this table
			fRet = EvaluateExpression(iExpression);
		iExpressions = iExpressions >> 1;
		iExpression ++;
	}
	return fRet;
}

// function to evaluate an expression
Bool CMsiView::EvaluateExpression(unsigned int iExpression)
{
	int iOperand1;
	int iOperand2;
	Bool fResult = fFalse;
	// we support literal comparisons
	if(m_rgExpressionDefn[iExpression].iTableIndex1)
		iOperand1 = (m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn1);
	else
		iOperand1 = m_rgExpressionDefn[iExpression].iColumn1;
	if(m_rgExpressionDefn[iExpression].iTableIndex2)
		iOperand2 = (m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex2].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn2);
	else
		iOperand2 = m_rgExpressionDefn[iExpression].iColumn2;
	if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokEqual)
		fResult = (iOperand1 == iOperand2)?fTrue:fFalse;
	else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokNotEq)
		fResult = (iOperand1 != iOperand2)?fTrue:fFalse;
	else
	{
		// need to return false for null comparisons
		if((iOperand1 == iMsiNullInteger) || (iOperand2 == iMsiNullInteger))
			fResult = fFalse;
		else
		{
			if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokGreater)
				fResult = (iOperand1 > iOperand2)? fTrue:fFalse;
			else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokLess)
				fResult = (iOperand1 < iOperand2)? fTrue:fFalse;
			else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokGreaterEq)
				fResult = (iOperand1 >= iOperand2)? fTrue:fFalse;
			else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokLessEq)
				fResult = (iOperand1 <= iOperand2)? fTrue:fFalse;
		}
	}
	return fResult;
}

// set up the values from the parent as a filter on the subsequent child gets
// also set up the independant filters
Bool CMsiView::SetTableFilters(unsigned int iTableIndex)
{
	int iExpression = 1;
	unsigned int iExpressions = m_rgTableDefn[iTableIndex].iExpressions;
	while(iExpressions)
	{
		if(iExpressions & 0x1)
		{
			// iOperation pertains to this table
			if(m_rgExpressionDefn[iExpression].fFlags == fTrue)
			{

				if(m_rgExpressionDefn[iExpression].iTableIndex2 == 0)
				{
					if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokEqual)
						// set the data for the filtered columns
						if((m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->PutInteger(
						m_rgExpressionDefn[iExpression].iColumn1, m_rgExpressionDefn[iExpression].iColumn2) == fFalse)
							return fFalse;
				}
				else if(m_rgExpressionDefn[iExpression].iTableIndex1 == iTableIndex)
				{
					// set the data for the filtered columns
					if((m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->PutInteger(
						m_rgExpressionDefn[iExpression].iColumn1,
						(m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex2].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn2)) == fFalse)
						return fFalse;
				}
				else 
				{
					// set the data for the filtered columns
					if((m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex2].piCursor)->PutInteger(
							m_rgExpressionDefn[iExpression].iColumn2,
							(m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn1)) == fFalse)
						return fFalse;

				}
			}
		}
		iExpressions = iExpressions >> 1;
		iExpression ++;
	}
	return fTrue;
}




// set up the hierarchy between the table for the joins
// the following maths holds true
// For a join between 2 tables T1, T2 of size S1, S2
// 1. the join involves 1 primary index (for T1), none for T2
// search takes S1 + S1 * S2/2 OR S2 + S2 * logS1
// hence go sequentially through T2 always

// 2. the join involves 2 primary indiices for the 2 tables
// search takes S1 + S1 * logS2 OR S2 + S2 * logS1
// hence sequentially go through the SMALLER of the 2 tables
// UNLESS filter on primary key of a table where go 
// from that table to the other table.

// 3. the join involves no primary indiices,
// search takes S1 + S1* S2/2 OR S2 + S2 * S1/2
// hence sequentially go through the SMALLER of the 2 tables

Bool CMsiView::SetupTableJoins()
{
	for(unsigned int iTmp = m_iExpressions + 1; --iTmp != 0;)
	{
		if((m_rgExpressionDefn[iTmp].fFlags == fTrue) && (m_rgExpressionDefn[iTmp].iTableIndex2))
		{
			// self join skipped
			if(m_rgExpressionDefn[iTmp].iTableIndex1 == m_rgExpressionDefn[iTmp].iTableIndex2)
				continue;

			// if we have already joined these 2 tables, skip
			if(	(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex1].iParentIndex == m_rgExpressionDefn[iTmp].iTableIndex2) ||
				(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex2].iParentIndex == m_rgExpressionDefn[iTmp].iTableIndex1))
				continue;

			// check which way will have least cost
			unsigned int iParent1, iParent2;
			int iCost1 = GetSearchReversingCost(m_rgExpressionDefn[iTmp].iTableIndex1, iParent1);
			int iCost2 = GetSearchReversingCost(m_rgExpressionDefn[iTmp].iTableIndex2, iParent2);
			if(m_rgExpressionDefn[iTmp].ijtType == ijt1ToMJoin)
				iCost2 ++;

			if((iCost1 < iCost2) || 
				((iCost1 == iCost2) && ((m_rgTableDefn[iParent2].piTable)->GetRowCount() <
					(m_rgTableDefn[iParent1].piTable)->GetRowCount())))
			{
				// do not reverse if already as desired
				if(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex1].iParentIndex != m_rgExpressionDefn[iTmp].iTableIndex2)
				{
					ReverseJoinLink(m_rgExpressionDefn[iTmp].iTableIndex1);
					m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex1].iParentIndex = m_rgExpressionDefn[iTmp].iTableIndex2;
				}
			}
			else
			{
				// do not reverse if already as desired
				if(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex2].iParentIndex != m_rgExpressionDefn[iTmp].iTableIndex1)
				{
					ReverseJoinLink(m_rgExpressionDefn[iTmp].iTableIndex2);
					m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex2].iParentIndex = m_rgExpressionDefn[iTmp].iTableIndex1;
				}
			}
		}
	}


	unsigned int iParent = 0;
	for(iTmp = m_iTables + 1; --iTmp != 0;)
	{
		if(m_rgTableDefn[iTmp].iParentIndex == 0)
		{
			m_rgTableDefn[iTmp].iParentIndex = iParent;
			iParent = iTmp;
		}
	}

	// check if we have no root
	return (iParent == 0) ? fFalse : fTrue;
}


//?? Why does this function return a Bool? it never fails...this leaves dead error code at the calling end -- malcolmh

// Determine which expressions are to be associated with which tables
Bool CMsiView::InitialiseFilters()
{
	unsigned int iTable;
	unsigned int iColumn;

	for(int iTmp = m_iExpressions + 1; --iTmp != 0;)
	{
		if(m_rgExpressionDefn[iTmp].fFlags == fTrue)
		{
			iTable = m_rgExpressionDefn[iTmp].iTableIndex1;
			iColumn = m_rgExpressionDefn[iTmp].iColumn1;
			if(m_rgExpressionDefn[iTmp].iTableIndex2)
			{
				Assert(m_rgExpressionDefn[iTmp].iTableIndex1);

				for(unsigned int iTmp1 = m_iTables; iTmp1--;)
				{
					if(m_rgiTableSequence[iTmp1] == m_rgExpressionDefn[iTmp].iTableIndex2)
						break;
					if(m_rgiTableSequence[iTmp1] == m_rgExpressionDefn[iTmp].iTableIndex1)
					{
						iTable = m_rgExpressionDefn[iTmp].iTableIndex2;
						iColumn = m_rgExpressionDefn[iTmp].iColumn2;
						break;
					}
				}
			}
			m_rgTableDefn[iTable].iExpressions |= (1 << (iTmp - 1));
			if((*m_rgExpressionDefn[iTmp].ptokOperation == ipqTokEqual) &&
				(m_rgExpressionDefn[iTmp].iTableIndex1 != m_rgExpressionDefn[iTmp].iTableIndex2))
			{
				unsigned int prevFilter = m_rgTableDefn[iTable].piCursor->SetFilter(0);
				m_rgTableDefn[iTable].piCursor->SetFilter(prevFilter | (1 << (iColumn - 1)));
			}
		}
	}
	return fTrue;
}


// set up the sort table, if required
void CMsiView::SetupSortTable()
{
	// check if we need to have an explicit sort
	// we do not need one if the sort columns are
	// the keys of the tables in order of the joins, starting
	// at the root table AND w/o gaps.
	if(m_iSortColumns)
	{
		unsigned int iSortColumns = 0;
		unsigned int iTable = m_rgiTableSequence[m_iTables - 1];
		unsigned int iColumnIndex = 1;

		while(iSortColumns < m_iSortColumns)
		{
			if(m_rgColumnsortDefn[iSortColumns].iTableIndex != iTable ||
				m_rgColumnsortDefn[iSortColumns].iColumnIndex != iColumnIndex)
				return;

			if(iColumnIndex == (m_rgTableDefn[iTable].piTable)->GetPrimaryKeyCount())
			{
				iTable = m_rgTableDefn[iTable].iParentIndex;
				iColumnIndex = 1;
			}
			else
				iColumnIndex ++;

			iSortColumns ++;
		}
		m_iSortColumns = 0;
	}
}

void CMsiView::ReverseJoinLink(unsigned int iTable)
{
	unsigned int iTmp1 = iTable;
	unsigned int iTmp2 = m_rgTableDefn[iTable].iParentIndex;
	while (iTmp2)
	{
		unsigned int iTmp3 = m_rgTableDefn[iTmp2].iParentIndex;
		m_rgTableDefn[iTmp2].iParentIndex = iTmp1;
		iTmp1 = iTmp2;
		iTmp2 = iTmp3;
	}
}

int CMsiView::GetSearchReversingCost(unsigned int iTable, unsigned int& riParentTable)
{
	int iCost = 0;
	while(m_rgTableDefn[iTable].iParentIndex)
	{
		// check type of join
		for(unsigned int iTmp = m_iExpressions + 1; --iTmp != 0;)
		{
			if(m_rgExpressionDefn[iTmp].fFlags == fTrue)
			{
				if((m_rgExpressionDefn[iTmp].iTableIndex1 == iTable) &&
					(m_rgExpressionDefn[iTmp].iTableIndex2 == m_rgTableDefn[iTable].iParentIndex))
				{
					if(m_rgExpressionDefn[iTmp].ijtType == ijt1ToMJoin)
						iCost ++;
					break;
				}
				else if((m_rgExpressionDefn[iTmp].iTableIndex2 == iTable) &&
					(m_rgExpressionDefn[iTmp].iTableIndex1 == m_rgTableDefn[iTable].iParentIndex))
				{
					if(m_rgExpressionDefn[iTmp].ijtType == ijt1ToMJoin)
						iCost --;
					break;
				}
			}
		}
		iTable = m_rgTableDefn[iTable].iParentIndex;
	}
	riParentTable = iTable;
	return iCost;
}


// fn to get the order in which the tables need to be fetched
void CMsiView::SetTableSequence(int iParent, int& iPos)
{
	for(unsigned int iTmp = m_iTables + 1; --iTmp != 0;)
	{
		if(m_rgTableDefn[iTmp].iParentIndex == iParent)
		{
			m_rgiTableSequence[iPos--] = iTmp;
			SetTableSequence(iTmp, iPos);
		}
	}
}


// evaluate const. expressions
Bool CMsiView::EvaluateConstExpressions()
{
	Bool fRet = fTrue;

	for(unsigned int iTmp = m_iExpressions + 1; (--iTmp != 0 && fRet == fTrue);)
	{
		if((m_rgExpressionDefn[iTmp].fFlags == fTrue) && 
			(!m_rgExpressionDefn[iTmp].iTableIndex1) &&
			(!m_rgExpressionDefn[iTmp].iTableIndex2))
			fRet = EvaluateExpression(iTmp);
	}
	return fRet;
}

// find all the independant expressions (not rooted directly or indirectly to an OR operation
void CMsiView::SetAndExpressions(unsigned int iTreeRoot)
{
	if(!m_iOperations)
		return;
	if(m_rgOperationTree[iTreeRoot].iValue == iopOR)
		return;
	if(m_rgOperationTree[iTreeRoot].iValue == iopAND)
	{
		Bool bFirst = fTrue;
		unsigned int iChild1, iChild2;
		unsigned int iOperations = m_iOperations - 1;
		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild1 = iOperations;

		Assert((int)iOperations > 0);
		iOperations--;

		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild2 = iOperations;

		Assert((int)iOperations >= 0);

		SetAndExpressions(iChild1);
		SetAndExpressions(iChild2);

		return;
	}
	m_rgExpressionDefn[m_rgOperationTree[iTreeRoot].iValue].fFlags = fTrue;
	return;
}

// evaluate if the result is distinct
Bool CMsiView::IsDistinct()
{
	Bool fRet = fTrue;
	if(m_fDistinct != fFalse)
	{
		Assert(m_piDistinctTable);
		PMsiCursor piCursor = m_piDistinctTable->CreateCursor(fFalse);

		for (unsigned int iCol = m_iColumns; iCol--;)
		{
			if(m_rgColumnDefn[iCol].iTableIndex == 0)
				piCursor->PutInteger(iCol + 1, m_rgColumnDefn[iCol].iColumnIndex);
			else
				piCursor->PutInteger(iCol + 1, (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetInteger(m_rgColumnDefn[iCol].iColumnIndex));
		}
		fRet = piCursor->Insert(); // fTrue if no duplicate row (all columns are primary keys),
											// fFalse if a duplicate row - bench 11/22/96
	}
	return fRet;

}

// evaluate the auxiliary OR expression, we skip over the independant expressions
// which are evaluated to be true earlier.
Bool CMsiView::FitCriteriaORExpr(unsigned int iTreeRoot)
{
	if(!m_iOperations)
		return fTrue;

	if(m_rgOperationTree[iTreeRoot].iValue & iopANDOR)
	{
		unsigned int iChild1, iChild2;
		unsigned int iOperations = m_iOperations - 1;
		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild1 = iOperations;

		Assert((int)iOperations > 0);
		iOperations--;

		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild2 = iOperations;

		Assert((int)iOperations >= 0);

		if(m_rgOperationTree[iTreeRoot].iValue == iopAND)
			// and operation
			return (((FitCriteriaORExpr(iChild1) == fTrue) && (FitCriteriaORExpr(iChild2) == fTrue))?fTrue:fFalse);
		else 
			// or operation
			return (((FitCriteriaORExpr(iChild1) == fTrue) || (FitCriteriaORExpr(iChild2) == fTrue))?fTrue:fFalse);
	}
	if(m_rgExpressionDefn[m_rgOperationTree[iTreeRoot].iValue].fFlags == fTrue)
		return fTrue;
	else
		return EvaluateExpression(m_rgOperationTree[iTreeRoot].iValue);
}


MsiStringId CMsiView::BindString(MsiString& rstr)
{
	Assert(m_piBindTableCursor);
	m_piBindTableCursor->Reset();
	m_piBindTableCursor->PutString(1, *rstr);
	AssertNonZero(m_piBindTableCursor->Assign());
	return m_piBindTableCursor->GetInteger(1);
}


CMsiView::CMsiView(CMsiDatabase& riDatabase, IMsiServices& riServices):
		m_riDatabase(riDatabase), m_riServices(riServices), 
		m_piRecord(0), m_piFetchTable(0), m_piFetchCursor(0),
		m_piBindTable(0),m_piBindTableCursor(0), m_piDistinctTable(0), m_fDistinct(fFalse),
		m_piInsertUpdateRec(0)
{
	m_iTables = 0;
	m_iColumns = 0;
	m_iSortColumns = 0;
	m_iExpressions = 0;
#if 0
	m_rgTableDefn = 0;
	m_rgiTableSequence = 0;
	m_rgExpressionDefn = 0;
	m_rgColumnDefn = 0;
	m_rgOperationTree = 0;
	m_rgColumnsortDefn = 0;
#endif
	m_CursorState = dvcsClosed;
	m_iParams = 0;
	m_iParamInputs = 0;
	m_iParamOutputs = 0;
	m_iParamExpressions = 0;
	m_iOperations = 0;
	m_iTreeParent = 0;
	m_lRowCount = 0;
	m_riDatabase.AddRef();
	m_riServices.AddRef();
	memset(m_rgchError, 0, 1+cMsiMaxTableColumns);
	m_fErrorRefreshed = fTrue;
	m_iFirstErrorIndex = 1;
	m_fLock = -1;
	Debug(m_Ref.m_pobj = this);
}



CMsiView::~CMsiView()
{
	m_CursorState = dvcsDestructor;
	Close();
}



IMsiRecord* CMsiView::GetColumnNames()
{
	int iNumCol = GetFieldCount();
	IMsiRecord* piRecord = &m_riServices.CreateRecord(iNumCol);
	for (unsigned int iCol = iNumCol; iCol--;)
	{

		if(m_rgColumnDefn[iCol].iTableIndex)
		{
			MsiString strCol = m_riDatabase.DecodeString((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->GetColumnName(m_rgColumnDefn[iCol].iColumnIndex));
			piRecord->SetMsiString(iCol+1, *strCol);
		}
		else
			piRecord->SetNull(iCol+1);
	}
	return piRecord;
}


unsigned int CMsiView::GetFieldCount()
{
	if (m_CursorState == dvcsClosed)
		return 0;
	else
		return m_iColumns;
}


IMsiRecord* CMsiView::GetColumnTypes()
{
	int iNumCol = GetFieldCount();
	IMsiRecord* piRecord = &m_riServices.CreateRecord(iNumCol);
	for (unsigned int iCol = iNumCol; iCol--;)
	{
		ICHAR chType = 0;
		int iLength = 0;
		int iColIndex = m_rgColumnDefn[iCol].iColumnIndex;
		int iTableIndex = m_rgColumnDefn[iCol].iTableIndex;
		if (iTableIndex == 0)  // constant
		{
			switch (m_rgColumnDefn[iCol].itdType)
			{
			case icdString:
				chType = 'f';
				iLength = MsiString(m_riDatabase.DecodeString(iColIndex)).TextSize();
				break;
			case icdLong:
				chType = 'h';
				iLength = 4;
				break;
			default:
				Assert(0);
			}
		}
		else // iTableIndex > 0
		{
			int iColumnDef = m_rgTableDefn[iTableIndex].piTable->GetColumnType(iColIndex);
			if (iColumnDef & icdObject)
			{
				if (iColumnDef & icdShort) // string index
				{
					if (iColumnDef & icdPersistent)
						chType = (iColumnDef & icdLocalizable) ? 'l' : 's';
					else
						chType = 'g';
					iLength = iColumnDef & icdSizeMask;
				}
				else if (iColumnDef & icdPersistent) // binary stream
				{
					chType =  'v';
					iLength = 0;
				}
				else // temporary object column
				{
					chType =  'o';
					iLength = 0;
				}
			}
			else // integer
			{
				chType = ((iColumnDef & icdPersistent) ? 'i' : 'j');
				iLength = (iColumnDef & icdShort) ? 2 : 4;
			}
			if (iColumnDef & icdNullable)
				chType -= ('a' - 'A');
		}
		ICHAR szTemp[20];
		StringCchPrintf(szTemp, sizeof(szTemp)/sizeof(ICHAR), TEXT("%c%i"), chType, iLength);
		piRecord->SetString(iCol + 1, szTemp);
	}
	return piRecord;
}


IMsiRecord* CMsiView::Close()
{
	switch (m_CursorState)
	{
	case dvcsFetched:
	case dvcsBound:
	case dvcsExecuted:
	case dvcsPrepared:
		m_CursorState = dvcsPrepared;
		break;
	case dvcsClosed:
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
	case dvcsDestructor:
		break;
	}
	m_piFetchCursor = 0;
	m_piFetchTable = 0;
	m_piDistinctTable=0;
	m_piRecord = 0;
	m_lRowCount = 0;
	return 0;
}


/*-----------------------------------------------------------------------------------------------
CMsiView::Modify

-------------------------------------------------------------------------------------------------*/
// inline function to set irmEnum to Modify bit
inline unsigned int iModifyBit(irmEnum irmAction) { return 1 << (irmAction - (irmPrevEnum + 1)); }

// Actions that require that we prefetch the remaining result set
const int iPrefetchResultSet =    iModifyBit(irmInsert)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmAssign)
								| iModifyBit(irmReplace)
								| iModifyBit(irmMerge);

// Actions that require all record data to be copied
const int iCopyAll             =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmAssign)
								| iModifyBit(irmMerge)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField);

// Actions that require the cursor state to not be closed or destructed
const int iCheckCursorState    = iCopyAll;

// Actions that require record to have been fetched before
const int iFetchRequired       =iModifyBit(irmRefresh)
								| iModifyBit(irmReplace)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateDelete);

// Actions that are unsupported for joins
const int iDisallowJoins       =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmAssign)
								| iModifyBit(irmReplace)
								| iModifyBit(irmMerge)
								| iModifyBit(irmDelete)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField)
								| iModifyBit(irmValidateDelete);

// Actions that can occur with a fetched record OR a record that was just inserted OR seeked
const int iRequireStamp        =iModifyBit(irmUpdate)
								| iModifyBit(irmDelete);

// Actions that require stamping
const int iNeedStamp           =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmInsertTemporary);

// Actions where m_piRecord must match the passed in record
const int iRequireFetch        =iModifyBit(irmRefresh)
								| iModifyBit(irmReplace)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateDelete);

// Actions that only need to have primary key record data copied over to cursors
const int iKeysOnly            =iModifyBit(irmSeek);

// Actions that require transfer of data
const int iTransfer            =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmAssign)
								| iModifyBit(irmUpdate)
								| iModifyBit(irmReplace)
								| iModifyBit(irmMerge)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField)
								| iModifyBit(irmValidateDelete);

// Fetch record info from cursors
const int iFetchRecInfo        =iModifyBit(irmSeek)
								| iModifyBit(irmRefresh);
	
// Validation actions
const int iValidation          =iModifyBit(irmValidate)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField)
								| iModifyBit(irmValidateDelete);

// Function pointer array to Cursor member functions
typedef Bool (__stdcall CMsiCursor::*FAction)(void);
static FAction s_rgAction[] ={                      //!! must be in this order 
						CMsiCursor::Seek,           // index = irmSeek + 1
						CMsiCursor::Refresh,        // index = irmRefresh + 1
						CMsiCursor::Insert,         // index = irmInsert + 1 
						CMsiCursor::Update,         // index = irmUpdate + 1
						CMsiCursor::Assign,         // index = irmAssign + 1
						CMsiCursor::Replace,        // index = irmReplace + 1
						CMsiCursor::Merge,          // index = irmMerge + 1
						CMsiCursor::Delete,         // index = irmDelete + 1
						CMsiCursor::InsertTemporary // index = irmInsertTemporary + 1
					};

IMsiRecord* __stdcall CMsiView::Modify(IMsiRecord& riRecord, irmEnum irmAction)
{
	// clear error array if not already clear
	if ( ! m_fErrorRefreshed )
	{
		memset(m_rgchError, 0, 1+cMsiMaxTableColumns);
		m_fErrorRefreshed = fTrue;
		m_iFirstErrorIndex = 1;
	}

	// Cannot truly validate intent here due to possible temporary columns and row
	// that are valid for read-only databases. Also need to support all validations.
	// Problem arises from the fact that intent is not exposed to external APIs.
	// cannot do this:	if ((irmAction != irmRefresh) && (irmAction != irmValidate) && (irmAction != irmValidateField) && (irmAction != irmInsertTemporary) && (!(m_ivcIntent & ivcModify)))
	// cannot do this:         return m_riDatabase.PostError(Imsg(idbgDbIntentViolation));
	int iModify = iModifyBit(irmAction);

	// check for correct states
	// --> whether joins allowed
	// --> whether require fetch
	// --> whether require 0th field to be stamped with the this pointer
	// --> whether cursor correct state
	if ((iModify & iDisallowJoins) && (m_iTables != 1))
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidOperation), irmAction);
	if ((iModify & iRequireFetch) && (m_CursorState != dvcsFetched || m_piRecord == 0 || (m_piRecord != &riRecord &&  m_piInsertUpdateRec != &riRecord)))
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
#ifdef	_WIN64	// !merced
	if ((iModify & iRequireStamp) && (m_piRecord == 0 || (m_piRecord != &riRecord &&  m_piInsertUpdateRec != &riRecord) || (riRecord.GetHandle(0) != (HANDLE)this)))
#else
	if ((iModify & iRequireStamp) && (m_piRecord == 0 || (m_piRecord != &riRecord &&  m_piInsertUpdateRec != &riRecord) || (riRecord.GetInteger(0) != (int)this)))
#endif
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
//	if ((iModify & iCheckCursorState) && m_CursorState == dvcsClosed || m_CursorState == dvcsDestructor)
	//!! need to allow CAs (in office9) to be able to call ::Modify() on a SELECT query w/o
	//!! therefore the need to call Execute() implicitly, ourselves
	if((m_ivcIntent & ivcFetch) && (m_CursorState == dvcsPrepared))
	{
		RETURN_ERROR_RECORD(Execute(0));
	}

	if (m_CursorState != dvcsFetched && m_CursorState != dvcsBound)
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));


	if((iModify & iPrefetchResultSet) && !m_piFetchTable)// need to prefetch the result set, if not already done so
	{
		RETURN_ERROR_RECORD(GetResult());
	}

	// NOTE:  seek sets copy all from record, but also has the PrimaryKeyOnly which prevents complete copy of all
	Bool fCopyAllFromRecord = (iModify & iCopyAll) ? fTrue : fFalse;
	if (iModify & iTransfer)
	{
		if (fCopyAllFromRecord)
		{
			Assert(m_iTables == 1); // all these operations are allowed on 1 table only
			(m_rgTableDefn[1].piCursor)->Reset();
		}
		int iColType = 0;
		for (int iCol = m_iColumns; iCol--;)
		{

			if(fCopyAllFromRecord || riRecord.IsChanged(iCol + 1))
			{
				if(!m_rgColumnDefn[iCol].iTableIndex)
					// not a table column
					continue;			

				// set the cursors
				iColType = ((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->
						  GetColumnType(m_rgColumnDefn[iCol].iColumnIndex));
				
				if ((iModify & iKeysOnly) && ((iColType & icdPrimaryKey) != icdPrimaryKey))
					continue; // only want keys
				
				switch (iColType & icdTypeMask)
				{
				case icdLong:// integer
				case icdShort: //!!needed?
				{
					int iData = riRecord.GetInteger(iCol + 1);
					if(iData != (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetInteger(m_rgColumnDefn[iCol].iColumnIndex))
					{
						if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->PutInteger(m_rgColumnDefn[iCol].iColumnIndex, iData) == fFalse)
							return m_riDatabase.PostError(Imsg(idbgDbUpdateBadType), iCol);
					}
					break;
				}
				case icdObject: 
				{
					// IMsiData interface pointer (temp. columns or persisten streams, database code handles the difference transparantly)
					// temp variable necessary for correct refcnt
					PMsiData piData = riRecord.GetMsiData(iCol + 1);
					if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->PutMsiData(m_rgColumnDefn[iCol].iColumnIndex, piData) != fTrue)
						return m_riDatabase.PostError(Imsg(idbgDbUpdateBadType), iCol);
					break;
				}
				case icdString:// index to database string cache
				{
					// temp variable necessary for correct refcnt
					MsiString strStr = riRecord.GetMsiString(iCol + 1);
					if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->PutString(m_rgColumnDefn[iCol].iColumnIndex, *strStr) != fTrue)
						return m_riDatabase.PostError(Imsg(idbgDbUpdateBadType), iCol);
					break;
				}
				}
			}
		}
	}

	if (iModify & ~iValidation)
	{
		for(unsigned int iTable = 1; iTable <= m_iTables; iTable++)
		{
			if (iModify == iModifyBit(irmSeek) && riRecord.GetFieldCount() < m_iColumns)
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData)); //!! need new msg: Record too small

			// call correct fn
			Bool fSuccess = (((CMsiCursor*)(m_rgTableDefn[iTable].piCursor))->*(s_rgAction[(int(irmAction) + 1)]))();			
			if (iModify & iNeedStamp)
			{
				if (iModify == iModifyBit(irmInsertTemporary))
					AssertNonZero(m_riDatabase.LockIfNotPersisted(m_rgTableDefn[iTable].iTable));
				m_piRecord = &riRecord;
				m_piRecord->AddRef(); // we keep a reference so we can reuse it
#ifdef _WIN64	// !merced
				m_piRecord->SetHandle(0, (HANDLE)this); // stamp this record with the this pointer
#else
				m_piRecord->SetInteger(0, (int)this); // stamp this record with the this pointer
#endif
			}
			if (iModify & iFetchRecInfo)
				FetchRecordInfoFromCursors();
			
			if (fSuccess == fFalse)
				return m_riDatabase.PostError(Imsg(idbgDbUpdateFailed));
			if (iModify == iModifyBit(irmDelete))
				m_piRecord = 0; // last record fetched
		}
		return 0;
	}
	else
	{
		// Validation can't occur across joins so iTable always = 1
		Bool fValidate = (iModify == iModifyBit(irmValidate)) ? fTrue : fFalse;
		if (iModify == iModifyBit(irmValidate) || iModify == iModifyBit(irmValidateNew))
		{
			PMsiTable pValidationTable(0);
			IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(sztblValidation), 0, *&pValidationTable);
			if (piError)
				return piError;
			PMsiCursor pValidationCursor(pValidationTable->CreateCursor(fFalse));
			Assert(pValidationCursor);
			int iCol = (fValidate ? 0 : -1);
			piError = (m_rgTableDefn[1].piCursor)->Validate(*pValidationTable, *pValidationCursor, iCol);
			if (piError != 0 && piError->GetInteger(0) == 0)
			{
				piError->Release();
				return m_riDatabase.PostError(Imsg(idbgDbWrongState));
			}
			else if (piError != 0)
			{
				// Validation invalid data record. Error stored in index based on column in view, 
				// not column in underlying table.
				int iNumFields = GetFieldCount();
				bool fError = false;
				for (int i = 1; i <= iNumFields; i++)
				{
					char chError = (char)(piError->GetInteger(m_rgColumnDefn[i-1].iColumnIndex));
					if (chError != 0)
					{
						m_rgchError[i] = chError;
						m_fErrorRefreshed = fFalse;
						fError = true;
					}
				}
				piError->Release();

				// there was an error in the record, but not in any column visible by this view.
				// so return success
				if (!fError)
					return 0;
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData));
			}
			return 0;
		}
		else if (iModify == iModifyBit(irmValidateField))
		{	
			PMsiTable pValidationTable(0);
			IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(sztblValidation), 0, *&pValidationTable);
			if (piError)
				return piError;
			PMsiCursor pValidationCursor(pValidationTable->CreateCursor(fFalse));
			Assert(pValidationCursor);
			int cFields = GetFieldCount();
			for (int i = 0; i < cFields; i++)
			{
				piError = (m_rgTableDefn[1].piCursor)->Validate(*pValidationTable, *pValidationCursor, m_rgColumnDefn[i].iColumnIndex);
				if (piError != 0 && piError->GetInteger(0) == 0)
				{
					piError->Release();
					return m_riDatabase.PostError(Imsg(idbgDbWrongState));
				}
				else if (piError != 0)
				{
					// error stored in index based on column in view, not column in underlying table
					m_fErrorRefreshed = fFalse;
					m_rgchError[i+1] = (char)(piError->GetInteger(m_rgColumnDefn[i].iColumnIndex));
					piError->Release();
				}
			}
			if (!m_fErrorRefreshed)
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData));
			return 0;
		}
		else // irmValidateDelete
		{
			PMsiTable pValidationTable(0);
			IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(sztblValidation), 0, *&pValidationTable);
			if (piError)
				return piError;
			PMsiCursor pValidationCursor(pValidationTable->CreateCursor(fFalse));
			Assert(pValidationCursor);
			piError = (m_rgTableDefn[1].piCursor)->Validate(*pValidationTable, *pValidationCursor, -2 /*Validate preDelete*/);
			if (piError != 0 && piError->GetInteger(0) == 0)
			{
				piError->Release();
				return m_riDatabase.PostError(Imsg(idbgDbWrongState));
			}
			else if (piError != 0)
			{
				// Validation invalid data record. Error stored in index based on column in view, 
				// not column in underlying table.
				int iNumFields = GetFieldCount();
				bool fError = false;
				for (int i = 1; i <= iNumFields; i++)
				{
					char chError = (char)(piError->GetInteger(m_rgColumnDefn[i-1].iColumnIndex));
					if (chError != 0)
					{
						m_rgchError[i] = chError;
						m_fErrorRefreshed = fFalse;
						fError = true;
					}
				}
				piError->Release();

				// there was an error in the record, but not in any column visible by this view.
				// so return success
				if (!fError)
					return 0;
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData));
			}
			return 0;
		}
	}
}

iveEnum __stdcall CMsiView::GetError(const IMsiString*& rpiColumnName)
{
	rpiColumnName = &CreateString();
	int cViewColumns = GetFieldCount();
	int iCol = m_iFirstErrorIndex - 1;
	for (int i = m_iFirstErrorIndex; i <= cViewColumns; i++, iCol++)
	{
		if (m_rgchError[i] != 0 && m_rgColumnDefn[iCol].iTableIndex) // for fully specified columns
		{
			MsiString strCol = m_riDatabase.DecodeString((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->GetColumnName(m_rgColumnDefn[iCol].iColumnIndex));
			rpiColumnName->SetString((const ICHAR*)strCol, rpiColumnName);
			m_iFirstErrorIndex = i + 1; // Update for next call of method
			return (iveEnum)m_rgchError[i];
		}
		else if (m_rgchError[i] != 0 && m_rgColumnDefn[iCol].iTableIndex == 0) // not fully specified column
		{
			rpiColumnName->SetString(TEXT("Unspecified Column"), rpiColumnName);
			m_iFirstErrorIndex = i + 1; // Update for next call of metod
			return (iveEnum)m_rgchError[i];
		}
	}
	m_iFirstErrorIndex = 1; // Reset
	return iveNoError;
}

HRESULT CMsiView::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiView))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiView::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiView::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	PMsiServices piServices (&m_riServices); // release after delete
	PMsiDatabase pDatabase (&m_riDatabase); // release after delete
	delete this;
	return 0;
}


IMsiRecord* CMsiView::OpenView(const ICHAR* szSQL, ivcEnum ivcIntent)
{
	m_ivcIntent = ivcIntent;
	// create the table for managing bindstring
	if ((m_piBindTable = new CMsiTable(m_riDatabase, 0, 0, 0))==0) // temporary, not a catalog table
		return m_riDatabase.PostError(Imsg(idbgDbTableCreate), szInternal);
	MsiString strNull;

	if(m_piBindTable->CreateColumn(icdString + icdPrimaryKey + icdNullable, *strNull) != 1)
		return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
		
	AssertNonZero(m_piBindTableCursor = m_piBindTable->CreateCursor(fFalse));

	RETURN_ERROR_RECORD(CheckSQL(szSQL));

	// check if any of the o/p tables are read only
	#if 0 //!! JD commented out test, we must be able to update non-persistent rows & columns! Maybe we don't want the intent?
	//!! JD the cursor functions will error if attempting to write persistent data on a read-only table
	if(m_ivcIntent & ivcModify)
	{
		for (unsigned int iCol = m_iColumns; iCol--;)
			if(m_rgColumnDefn[iCol].iTableIndex)
				if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->IsReadOnly() == fTrue)
				{
					MsiString riTable = m_riDatabase.DecodeString(m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].iTable);
					return m_riDatabase.PostError(Imsg(idbgDbTableReadOnly),(const IMsiString& )riTable);
				}
	}
	#endif //!! JD commented out
	m_CursorState = dvcsPrepared;
	return 0;
}

// function to prefetch the result set
IMsiRecord* CMsiView::GetResult()
{
	if(m_piFetchTable)
		return 0;; // already fetched

	MsiString strNull;
	// create a table for the result, maybe in the order of the sort (m_iSortColumns will be 0 otherwise) + index (to prevent reordering of the rows in case of deletion/insertion
	if ((m_piFetchTable = new CMsiTable(m_riDatabase, 0, 0, 0))==0) // temporary, not a catalog table
		return m_riDatabase.PostError(Imsg(idbgDbTableCreate), szInternal);
	for(unsigned int iTmp = m_iSortColumns; iTmp--;)
	{
		if(!m_piFetchTable->CreateColumn(icdLong + icdPrimaryKey + icdNullable, *strNull))
			return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
	}


	if(!m_piFetchTable->CreateColumn(icdLong + icdPrimaryKey + icdNullable, *strNull))
		return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);

	for(iTmp = m_iTables; iTmp--;)
	{
		if(!m_piFetchTable->CreateColumn(icdLong + icdNullable, *strNull))
			return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
	}


	//!! need to check return
	AssertNonZero(m_piFetchCursor = m_piFetchTable->CreateCursor(fFalse));
	// fill in the table
	Bool fRetCode;
	if(m_CursorState == dvcsFetched)
	{
		// already fetched part of the result set fetch the remaining part

		// get the existing fetch into the table, so that we can maintain
		// the existing cursor states after all the fetches
		SetNextFetchRecord();
		while(FetchNext())
		{
			// put the values into the table
			if((FitCriteriaORExpr(m_iTreeParent) != fFalse) && (IsDistinct() != fFalse))
				SetNextFetchRecord();
		}
		m_piFetchCursor->Reset();
		GetNextFetchRecord();
		// current m_lRowCount count denotes rows already fetched
		m_lRowCount += m_piFetchTable->GetRowCount() - 1; // subtract 1 since we existing row in table as well
	}
	else
	{
		fRetCode = EvaluateConstExpressions();
		if(fRetCode == fTrue)
		{
			fRetCode = FetchFirst();
			while(fRetCode == fTrue)
			{
				// put the values into the table
				if((FitCriteriaORExpr(m_iTreeParent) != fFalse) && (IsDistinct() != fFalse))
					SetNextFetchRecord();
				fRetCode = FetchNext();
			}
		}
		m_piFetchCursor->Reset();
		m_lRowCount += m_piFetchTable->GetRowCount();
	}
	return 0;
}

// function to bind parameters in the SQL string
// also used to preprocess and execute query if an
// external sort required
IMsiRecord* __stdcall CMsiView::Execute(IMsiRecord* piParams)
{
	// we implicitly close the view if we can
	if (m_CursorState == dvcsBound || m_CursorState == dvcsFetched)
	{
		RETURN_ERROR_RECORD(Close());
	}
	else if (m_CursorState != dvcsPrepared)
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));

	// check that the number of parameters matches the record field count
	if (m_iParams && (!piParams || piParams->GetFieldCount() < m_iParams))
			return m_riDatabase.PostError(Imsg(idbgDbParamCount));
	// bind the insert/update values	
	unsigned int iTmp1 = m_iParamInputs;
	unsigned int iTmp2 = 1;
	unsigned int iTmp3 = 1;
	while(iTmp1)
	{
		Assert(m_piInsertUpdateRec);
		if(iTmp1 & 0x1)
		{

			if(piParams->IsInteger(iTmp3))
				m_piInsertUpdateRec->SetInteger(iTmp2, piParams->GetInteger(iTmp3));
			else
				m_piInsertUpdateRec->SetMsiData(iTmp2, PMsiData(piParams->GetMsiData(iTmp3)));
			iTmp3 ++;
		}
		iTmp2 ++;
		iTmp1 = iTmp1 >> 1;
	}
	// bind o/p parameters
	iTmp1 = m_iParamOutputs;
	iTmp2 = 0;
	while(iTmp1)
	{
		Assert(m_piInsertUpdateRec == 0);
		if(iTmp1 & 0x1)
		{

			if(piParams->IsInteger(iTmp3))
			{
				m_rgColumnDefn[iTmp2].iColumnIndex = piParams->GetInteger(iTmp3);
				m_rgColumnDefn[iTmp2].itdType = icdLong;
			}
			else
			{
				MsiString aString = piParams->GetMsiString(iTmp3);
				m_rgColumnDefn[iTmp2].iColumnIndex = BindString(aString);
				m_rgColumnDefn[iTmp2].itdType = icdString;
			}
			iTmp3 ++;
		}
		iTmp2 ++;
		iTmp1 = iTmp1 >> 1;
	}
	// bind statement parameters
	iTmp1 = m_iParamExpressions;
	iTmp2 = 1;
	while(iTmp1)
	{
		if(iTmp1 & 0x1)
		{
			switch(m_rgExpressionDefn[iTmp2].itdType)
			{
			case icdLong:
			case icdShort: //!!needed?
				if(piParams->IsNull(iTmp3))
					m_rgExpressionDefn[iTmp2].iColumn2 = (unsigned int)iMsiNullInteger;
				else if (piParams->IsInteger(iTmp3))
					m_rgExpressionDefn[iTmp2].iColumn2 = piParams->GetInteger(iTmp3);
				else
					return m_riDatabase.PostError(Imsg(idbgParamMismatch), iTmp3);
				break;
			case icdString:
			{
				MsiString aString = piParams->GetMsiString(iTmp3);
				m_rgExpressionDefn[iTmp2].iColumn2 = BindString(aString);
				break;
			}
			default:
				return m_riDatabase.PostError(Imsg(idbgParamMismatch), iTmp3);
			}
			iTmp3 ++;
		}
		iTmp2 ++;
		iTmp1 = iTmp1 >> 1;
	}
	// reset all the cursors
	if((m_ivcIntent != ivcCreate) && (m_ivcIntent != ivcAlter))
	for(iTmp1 = m_iTables + 1; --iTmp1 != 0;)
		(m_rgTableDefn[iTmp1].piCursor)->Reset();
	m_CursorState = dvcsExecuted;
	if (m_ivcIntent == ivcNoData)
		return Close();    // all done, force close
	m_CursorState = dvcsBound;
	// need to set up distinct table, if required
	if(m_fDistinct != fFalse)
	{
		if ((m_piDistinctTable = new CMsiTable(m_riDatabase, 0, 0, 0))==0) // temporary, not a catalog table
			return m_riDatabase.PostError(Imsg(idbgDbTableCreate), szInternal);
		for (unsigned int iCol = 1; iCol <= m_iColumns; iCol++)
		{
			if(m_piDistinctTable->CreateColumn(icdPrimaryKey | icdLong | icdNullable, *MsiString(*TEXT(""))) != iCol)
				return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
		}
	}
	// need to execute if sorting required or if we intend to modify the result set
	if((m_iSortColumns) || (m_ivcIntent & ivcModify))
		RETURN_ERROR_RECORD(GetResult());
	switch(m_ivcIntent)
	{
	case ivcDelete:
	{
		PMsiRecord piRecord(0);
		while((piRecord = _Fetch()) != 0)
		{
			RETURN_ERROR_RECORD(Modify(*piRecord, irmDelete));
		}
		return Close();
	}
	case ivcUpdate:
	{
		PMsiRecord piRecord(0);
		while((piRecord = _Fetch()) != 0)
		{
			Assert(m_piInsertUpdateRec != 0);

			for (int iCol = 1; iCol <= m_iColumns; iCol++)
			{
				if(m_piInsertUpdateRec->IsNull(iCol))
					piRecord->SetNull(iCol);
				else
				{
					if(m_piInsertUpdateRec->IsInteger(iCol))
						piRecord->SetInteger(iCol, m_piInsertUpdateRec->GetInteger(iCol));
					else
						piRecord->SetMsiData(iCol, PMsiData(m_piInsertUpdateRec->GetMsiData(iCol)));
				}
			}
			RETURN_ERROR_RECORD(Modify(*piRecord, irmUpdate));
		}
		return Close();
	}
	case ivcInsert:
	{
		Assert(m_piInsertUpdateRec != 0);
		RETURN_ERROR_RECORD(Modify(*m_piInsertUpdateRec, irmInsert));
		return Close();
	}
	case ivcInsertTemporary:
	{
		Assert(m_piInsertUpdateRec != 0);
		RETURN_ERROR_RECORD(Modify(*m_piInsertUpdateRec, irmInsertTemporary));
		return Close();
	}
	case ivcCreate:
	{
		RETURN_ERROR_RECORD(m_riDatabase.CreateTable(*MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable)), 0, *&m_rgTableDefn[m_iTables].piTable));
		// and fall through
	}
	case ivcAlter:
	{
		for (unsigned int iCol = 0; iCol < m_iColumns; iCol++)
		{
			MsiString strColumn = m_riDatabase.DecodeString(m_rgColumnDefn[iCol].iColumnIndex);
			if(!m_rgTableDefn[m_iTables].piTable->CreateColumn(m_rgColumnDefn[iCol].itdType, *strColumn))
				return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), strColumn, (const ICHAR*)MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable)));
		}
		if(m_fLock != -1) // we need to lock/unlock the table
			m_riDatabase.LockTable(*MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable)), (Bool)m_fLock);
		return Close();
	}
	case ivcDrop:
	{
		RETURN_ERROR_RECORD(m_riDatabase.DropTable(MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable))));
		return Close();
	}
	default:
		// ivcFetch is set, SELECT stmt
		break;
	}
	return 0;
}

// function to get the size of the result set
IMsiRecord* __stdcall CMsiView::GetRowCount(long& lRowCount)
{
	if (m_CursorState != dvcsFetched && m_CursorState != dvcsBound)
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
	if(!m_piFetchTable)
	{
		// rows have not been pre-fetched
		RETURN_ERROR_RECORD(GetResult());
	}
	lRowCount = m_lRowCount;
	return 0;
}

// local factory for IMsiView
IMsiRecord* CreateMsiView(CMsiDatabase& riDatabase, IMsiServices& riServices, const ICHAR* szQuery, ivcEnum ivcIntent,IMsiView*& rpiView)
{
	CMsiView* piView = new CMsiView(riDatabase, riServices);
	IMsiRecord* piError = piView->OpenView(szQuery, ivcIntent);
	if(piError)
	{
		// delete the object, 
		// the convention is to keep "rpiView" untouched
		// if error
		piView->Release();
	}
	else
		rpiView = piView;
	return piError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\dgtlsig.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       digtlsig.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include "tables.h"
#include "_engine.h"
#include "_dgtlsig.h"
#include "eventlog.h"

icrCompareResult MsiCompareSignatureCertificates(IMsiStream *piSignatureCert, CERT_CONTEXT const *psCertContext, const IMsiString& riFileName);
icrCompareResult MsiCompareSignatureHashes(IMsiStream *piSignatureHash, CRYPT_DATA_BLOB& sEncryptedHash, const IMsiString& riFileName);
void ReleaseWintrustStateData(GUID *pgAction, WINTRUST_DATA& sWinTrustData);

iesEnum GetObjectSignatureInformation(IMsiEngine& riEngine, const IMsiString& riTable, const IMsiString& riObject, IMsiStream*& rpiCertificate, IMsiStream*& rpiHash)
/*----------------------------------------------------------------------------------------------------------------------------------------------------------------
Checks if the given object needs a signature check and returns the certificate and hash streams in rpiCertificate and rpiHash

  Arguments:
	riEngine       -- [IN]  Installer engine object
	riTable        -- [IN]  Table to which object belongs (only Media is allowed)
	riObject       -- [IN]  Name of possibly signed object
	rpiCertificate -- [OUT] Certificate stream for signed object (un-modified if iesNoAction or iesFailure)
	rpiHash        -- [OUT] Hash stream for signed object (un-modified if iesNoAction or iesFailure)

  Return Values:
	iesNoAction   >> no signature check required
	iesSuccess    >> signature check required
	iesFailure    >> problem occurred

  Notes:
	1.  If the Table-Object pair is present in the MsiDigitalSignature table, the object must be signed (verified via WVT)
	2.  If a hash is present for the Table-Object pair, then the object must be signed AND its hash must match that authored in the MsiDigitalSignature table
	3.  The object must be signed AND its certificate must match that authored in the MsiDigitalSignature table
	4.  The presence of a hash in the MsiDigitalSignature table is optional
	5.  The certificate is required in the MsiDigitalSignature table.
----------------------------------------------------------------------------------------------------------------------------------------------------------------*/
{
	PMsiTable pDigSigTable(0);
	PMsiRecord pError(0);
	PMsiDatabase pDatabase = riEngine.GetDatabase();

	// init to 0 for none found
	rpiCertificate = 0;
	rpiHash = 0;

	// load the DigitalSignature table
	if ((pError = pDatabase->LoadTable(*MsiString(sztblDigitalSignature),0,*&pDigSigTable)) != 0)
	{
		if (idbgDbTableUndefined == pError->GetInteger(1))
			return iesNoAction; // DigitalSignature table not present so no signature verification required
		else
			return iesFailure; // fatal error loading table, fail to secure more
	}
	
	// determine the columns for the MsiDigitalSignature table
	int iColSigTable, iColSigObject, iColSigCert, iColSigHash;
	iColSigTable  = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colTable));
	iColSigObject = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colObject));
	iColSigCert   = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colCertificate));
	iColSigHash   = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colHash));
	if (0 == iColSigTable || 0 == iColSigObject || 0 == iColSigCert || 0 == iColSigHash)
	{
		// table definition error
		// non-ignorable authoring error (security reasons)
		PMsiRecord precError(PostError(Imsg(idbgTableDefinition), *MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// set up filter on cursor to look for this table-object pair in the MsiDigitalSignature table
	PMsiCursor pDigSigCursor = pDigSigTable->CreateCursor(fFalse);
	pDigSigCursor->PutString(iColSigTable, riTable);
	pDigSigCursor->PutString(iColSigObject, riObject);
	pDigSigCursor->SetFilter(iColumnBit(iColSigTable) | iColumnBit(iColSigObject));

	if (!pDigSigCursor->Next())
		return iesNoAction; // table-object not listed in MsiDigitalSignature table
	
	// all signed objects require a certificate check
	MsiStringId idCertificateKey = pDigSigCursor->GetInteger(iColSigCert);
	if (0 == idCertificateKey)
	{
		// non-nullable column -- must have a value
		// this is a non-ignorable authoring error (security reasons)
		MsiString strPrimaryKey(riTable.GetString());
		strPrimaryKey += TEXT(".");
		strPrimaryKey += riObject.GetString();
		PMsiRecord precError(PostError(Imsg(idbgNullInNonNullableColumn), *strPrimaryKey, 
			*MsiString(*sztblDigitalSignature_colCertificate), *MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// load the MsiDigitalCertificate table
	PMsiTable pDigCertTable(0);
	if((pError = pDatabase->LoadTable(*MsiString(sztblDigitalCertificate),0,*&pDigCertTable)) != 0)
	{
		// there is a foreign key to the MsiDigitalCertificate table, but the table is missing.
		// this is a non-ignorable authoring error (security reasons)
		PMsiRecord precError(PostError(Imsg(idbgBadForeignKey), pDatabase->DecodeString(idCertificateKey),
			*MsiString(*sztblDigitalSignature_colCertificate),*MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// determine columns of MsiDigitalCertificate table
	int iColCertCert, iColCertData;
	iColCertCert = pDigCertTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalCertificate_colCertificate));
	iColCertData = pDigCertTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalCertificate_colData));
	if (0 == iColCertCert || 0 == iColCertData)
	{
		// table definition error
		// non-ignorable authoring error (security reasons)
		PMsiRecord precError(PostError(Imsg(idbgTableDefinition), *MsiString(*sztblDigitalCertificate)));
		return riEngine.FatalError(*precError);
	}

	// set up filter on cursor to look for this certificate in the MsiDigitalCertificate table
	PMsiCursor pDigCertCursor = pDigCertTable->CreateCursor(fFalse);
	pDigCertCursor->PutInteger(iColCertCert, idCertificateKey);
	pDigCertCursor->SetFilter(iColumnBit(iColCertCert));
	if (!pDigCertCursor->Next())
	{
		// there is a foreign key to the MsiDigitalCertificate table, but the entry is missing.
		// This is a non-ignorable authoring error (security reasons).
		PMsiRecord precError(PostError(Imsg(idbgBadForeignKey), pDatabase->DecodeString(idCertificateKey),
			*MsiString(*sztblDigitalSignature_colCertificate),*MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// retrieve stream
	rpiCertificate = pDigCertCursor->GetStream(iColCertData);

	if (!rpiCertificate)
	{
		// table definition error -- this should be a non-nullable column
		// non-ignorable authoring error (security reasons)
		PMsiRecord precError(PostError(Imsg(idbgTableDefinition), *MsiString(*sztblDigitalCertificate)));
		return riEngine.FatalError(*precError);
	}

	// retrieve hash
	rpiHash = pDigSigCursor->GetStream(iColSigHash);

	return iesSuccess;
}

icrCompareResult MsiCompareSignatureHashes(IMsiStream *piSignatureHash, CRYPT_DATA_BLOB& sEncryptedHash, const IMsiString& riFileName)
/*-----------------------------------------------------------------------------------------------------------------------------------
Returns the result of a comparision of two digital signature hashes

  Arguments:
	piSignatureHash -- [IN] Hash stream from MsiDigitalSignature table
	sEncryptedHash  -- [IN] Hash from signed object
	riFileName     -- [IN] Name of Signed Cabinet

  Returns:
	icrMatch       >> hashes match
	icrSizesDiffer >> hashes differ in size (precludes hash comparison)
	icrDataDiffer  >> hashes differ (sizes are the same)
	icrError       >> some error occurred
-----------------------------------------------------------------------------------------------------------------------------------*/
{
	// ensure at start of hash stream
	piSignatureHash->Reset();

	// get encoded hash sizes
	DWORD cbHash = sEncryptedHash.cbData;
	unsigned int cbMsiStoredHash = piSignatureHash->Remaining();

	// compare sizes
	if (cbHash != cbMsiStoredHash)
	{
		// hashes are different --> sizes do not match
		DEBUGMSGV1(TEXT("Hash of signed cab '%s' differs in size with the hash of the cab in the MsiDigitalSignature table"), riFileName.GetString());
		return icrSizesDiffer;
	}

	// set up data buffer
	BYTE *pbMsiStoredHash = new BYTE[cbMsiStoredHash];

	if (!pbMsiStoredHash)
	{
		// out of memory
		DEBUGMSGV(TEXT("Failed allocation -- Out of Memory"));
		return icrError;
	}

	// init to error
	icrCompareResult icr = icrError;

	// get encoded hashes
	piSignatureHash->GetData((void*)pbMsiStoredHash, cbMsiStoredHash);

	// compare hashes
	if (0 != memcmp((void*)sEncryptedHash.pbData, (void*)pbMsiStoredHash, cbHash))
	{
		// hashes don't match
		DEBUGMSGV1(TEXT("Hash of signed cab '%s' does not match hash authored in the MsiDigitalSignature table"), riFileName.GetString());
		icr = icrDataDiffer;
	}
	else
		icr = icrMatch;

	// clean-up
	delete [] pbMsiStoredHash;

	return icr;
}

icrCompareResult MsiCompareSignatureCertificates(IMsiStream *piSignatureCert, CERT_CONTEXT const *psCertContext, const IMsiString& riFileName)
/*-----------------------------------------------------------------------------------------------------------------------------------
Returns the result of a comparision of two digital signature certificates

  Arguments:
	piSignatureCert -- [IN] Certificate stream from MsiDigitalCertificate table
	psCertContext   -- [IN] Certificate from signed object
	riFileName     -- [IN] Name of Signed Cabinet

  Returns:
	icrMatch       >> certificates match
	icrSizesDiffer >> certificates differ in size (precludes certificate comparison)
	icrDataDiffer  >> certificates differ (sizes are the same)
	icrError       >> some error occurred
-----------------------------------------------------------------------------------------------------------------------------------*/
{
	// ensure at start of cert stream
	piSignatureCert->Reset();

	// get encoded cert sizes
	DWORD cbCert = psCertContext->cbCertEncoded;
	unsigned int cbMsiStoredCert = piSignatureCert->Remaining();

	// compare sizes
	if (cbCert != cbMsiStoredCert)
	{
		// certs are different -->> sizes do not match
		DEBUGMSGV1(TEXT("Certificate of signed cab '%s' differs in size with the certificate of the cab in the MsiDigitalCertificate table"), riFileName.GetString());
		return icrSizesDiffer;
	}

	// set up data buffers
	BYTE *pbMsiStoredCert = new BYTE[cbMsiStoredCert];

	if (!pbMsiStoredCert)
	{
		// out of memory
		DEBUGMSGV(TEXT("Failed allocation -- Out of Memory"));
		return icrError;
	}

	// init to error
	icrCompareResult icr = icrError;

	// get encoded certs
	piSignatureCert->GetData((void*)pbMsiStoredCert, cbMsiStoredCert);

	// compare certificates
	if (0 != memcmp((void*)psCertContext->pbCertEncoded, (void*)pbMsiStoredCert, cbCert))
	{
		// certs don't match
		DEBUGMSGV1(TEXT("Certificate of signed cab '%s' does not match certificate authored in the MsiDigitalCertificate table"), riFileName.GetString());
		icr = icrDataDiffer;
	}
	else
		icr = icrMatch;

	// clean-up
	delete [] pbMsiStoredCert;

	return icr;
}

void ReleaseWintrustStateData(GUID *pgAction, WINTRUST_DATA& sWinTrustData)
/*------------------------------------------------------------------------
Calls WinVerifyTrust (WVT) to release the WintrustStateData that had been
 preserved via a call to WVT with dwStateAction = WTD_STATEACTION_VERIFY

  Arguments:
	pgAction      -- [IN] Action Identifier
	sWinTrustData -- [IN] WinTrust data structure

  Returns:
	none
------------------------------------------------------------------------*/
{
	// update WINTRUST data struct
	sWinTrustData.dwUIChoice    = WTD_UI_NONE;           // no UI
	sWinTrustData.dwStateAction = WTD_STATEACTION_CLOSE; // release state

	// perform trust action w/ no interactive user
	WINTRUST::WinVerifyTrust(/*UI Window Handle*/(HWND)INVALID_HANDLE_VALUE, pgAction, &sWinTrustData);
}

icsrCheckSignatureResult MsiVerifyNonPackageSignature(const IMsiString& riFileName, HANDLE hFile, IMsiStream& riSignatureCert, IMsiStream * piSignatureHash, HRESULT& hrWVT)
/*-------------------------------------------------------------------------------------------------------------------------------------------------------
Determines whether or not the signed object is trusted.  A trusted object must pass two trust tests. . .
	1.  WinVerifyTrust validates the signature on the object (hash matches that in signature, certificate is properly formed)
	2.  Hash and Certificate of object match that stored in the MsiDigitalSignature and MsiDigitalCertificate tables in the package

  Arguments:
	riFileName      -- [IN] file name of object to verify (name of cabinet)
	hFile           -- [IN] handle to file to verify (can be INVALID_HANDLE_VALUE)
	riSignatureCert -- [IN] certificate stream stored in MsiDigitalCertificate table for object
	piSignatureHash -- [IN] hash stream stored in MsiDigitalSignature table for object

  Returns:
	icsrTrusted            >> signed object is trusted
	icsrNotTrusted         >> signed object is not trusted (least specific error)
	icsrNoSignature        >> object does not have a signature
	icsrBadSignature       >> signed object's hash or certificate are invalid (as determined by WVT)
	icsrWrongCertificate   >> signed object's certificate does not match that authored in MSI
	icsrWrongHash          >> signed object's hash does not match that authored in MSI
	icsrBrokenRegistration >> crypto registration is broken
	icsrMissingCrypto      >> crypto is not available on the machine

	hrWVT                  >> HRESULT return value from WinVerifyTrust
--------------------------------------------------------------------------------------------------------------------------------------------------------*/
{
	DEBUGMSGV1(TEXT("Authoring of MsiDigitalSignature table requires a trust check for CAB '%s'"), riFileName.GetString());

	// initialize trust
	icsrCheckSignatureResult icsrTrustValue = icsrNotTrusted; // init to an untrusted state

	// start impersonating -- needed because WVT policy state data is per-user
	CImpersonate Impersonate(true);

	// 
	// WVT is called twice
	//	1.  Actual trust verification with additional specification to hold onto the state data
	//  2.  Tell WVT to release the state data
	//

	//-------------------------------------------------------------
	// Step 1: Initialize WVT structure
	//-------------------------------------------------------------
	WINTRUST_DATA       sWinTrustData;
	WINTRUST_FILE_INFO  sFileData;

	const GUID guidCabSubject = WIN_TRUST_SUBJTYPE_CABINET;
	const GUID guidAction     = WINTRUST_ACTION_GENERIC_VERIFY_V2;

	// initialize structures to all 0
	memset((void*)&sWinTrustData, 0x00, sizeof(WINTRUST_DATA));
	memset((void*)&sFileData, 0x00, sizeof(WINTRUST_FILE_INFO));

	// set size of structures
	sWinTrustData.cbStruct = sizeof(WINTRUST_DATA);
	sFileData.cbStruct = sizeof(WINTRUST_FILE_INFO);

	// initialize WINTRUST_FILE_INFO struct -->> so Authenticode knows what it is verifying
	sFileData.pgKnownSubject = 0; // const_cast<GUID *>(&guidCabSubject); -->> shortcut
	sFileData.pcwszFilePath = CConvertString(riFileName.GetString());
	sFileData.hFile = hFile;

	// initialize WINTRUST_DATA struct
	sWinTrustData.pPolicyCallbackData = NULL;
	sWinTrustData.pSIPClientData = NULL;

	// set file information (cabinet)
	sWinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
	sWinTrustData.pFile = &sFileData;

	sWinTrustData.dwUIChoice = WTD_UI_NONE;	// no UI
	sWinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE; // no additional revocation checks are needed, those by provider are fine

	// save state
	sWinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;


	//-------------------------------------------------------------
	// Step 2: 1st call to WVT, saving state data.  WVT will verify
	//   signature on signed cab (including whether hashes match
	//   and cert chain builds to a trusted root)
	//   * Use NO UI.
	//-------------------------------------------------------------
	hrWVT = WINTRUST::WinVerifyTrust(/*UI Window Handle*/(HWND)INVALID_HANDLE_VALUE, const_cast<GUID *>(&guidAction), &sWinTrustData);
	switch (hrWVT)
	{
	case ERROR_SUCCESS: // subject trusted according to WVT
		{
			icsrTrustValue =  icsrTrusted;
			break;
		}
	case TRUST_E_NOSIGNATURE: // subject is not signed
		{
			icsrTrustValue = icsrNoSignature;
			DEBUGMSGV1(TEXT("Cabinet '%s' does not have a digital signature."), riFileName.GetString());
			break;
		}
	case TRUST_E_BAD_DIGEST: // hash does not verify
		{
			DEBUGMSGV1(TEXT("Cabinet '%s' has an invalid hash.  It is possibly corrupted."), riFileName.GetString());
			icsrTrustValue = icsrBadSignature;
			break;
		}
	case TRUST_E_NO_SIGNER_CERT: // signer cert is missing
	case TRUST_E_SUBJECT_NOT_TRUSTED:
	case CERT_E_MALFORMED: // certificate is invalid
		{
			DEBUGMSGV2(TEXT("Digital signature on the '%s' cabinet is invalid.  WinVerifyTrust returned 0x%X"), riFileName.GetString(), (const ICHAR*)(INT_PTR)hrWVT);
			icsrTrustValue = icsrBadSignature;
			break;
		}
	case TRUST_E_PROVIDER_UNKNOWN:      // registration is broken
	case TRUST_E_ACTION_UNKNOWN:        // ...
	case TRUST_E_SUBJECT_FORM_UNKNOWN : // ...
		{
			DEBUGMSGV1(TEXT("Crypt registration is broken.  WinVerifyTrust returned 0x%X"), (const ICHAR*)(INT_PTR)hrWVT);
			icsrTrustValue = icsrBrokenRegistration;
			break;
		}
	case CERT_E_EXPIRED: // certificate has expired
		{
			// we have to trust the certificate (as long as it matches the authoring) because the MSI package could
			// have an extended lifetime
			icsrTrustValue = icsrTrusted;
			break;
		}
	case CERT_E_REVOKED: // certificate has been revoked
		{
			// not a common scenario, but it means that the certificate has ended up on a revocation list
			// this means that the private key of the certificate has been compromised
			DEBUGMSGV1(TEXT("The certificate in the digital signature for the '%s' cabinet has been revoked by its issuer"), riFileName.GetString());
			icsrTrustValue = icsrBadSignature;
			break;
		}
	case CERT_E_UNTRUSTEDROOT: // the root cert is not trusted
	case CERT_E_UNTRUSTEDTESTROOT: // the root cert which is the test root is not trusted
	case CERT_E_UNTRUSTEDCA: // one of the CA certs is not trusted
		{
			// we trust here because our trust relationship is determined by the trust of the toplevel object
			// as long as the certificate matches that which is authored (checked below), we are okay
			icsrTrustValue = icsrTrusted;
			break;
		}
	case TYPE_E_DLLFUNCTIONNOTFOUND: // failed to call WVT
		{
			// crypto is not installed on the machine and we couldn't call WinVerifyTrust
			if (MinimumPlatformWindows2000())
			{
				// this should not happen on Win2K and above
				DEBUGMSGV(TEXT("Cabinet is not trusted.  Unable to call WinVerifyTrust"));
				icsrTrustValue = icsrNotTrusted;
			}
			else
			{
				DEBUGMSGE(EVENTLOG_WARNING_TYPE, EVENTLOG_TEMPLATE_WINVERIFYTRUST_UNAVAILABLE, riFileName.GetString());
				return icsrMissingCrypto;
			}
		}
	default:
		{
			// must FAIL in the default case!
			DEBUGMSGV2(TEXT("Cabinet '%s' is not trusted.  WinVerifyTrust returned 0x%X"), riFileName.GetString(), (const ICHAR*)(INT_PTR)hrWVT);
			icsrTrustValue = icsrNotTrusted;
		}
	}

	//-------------------------------------------------------------
	// Step 3: Release State Data if subject is not trusted
	//-------------------------------------------------------------
	if (icsrTrusted != icsrTrustValue)
	{
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		return icsrTrustValue;
	}
	
	//-------------------------------------------------------------
	// Step 4: Obtain provider data
	//-------------------------------------------------------------
	CRYPT_PROVIDER_DATA const *psProvData     = NULL;
	CRYPT_PROVIDER_SGNR       *psProvSigner   = NULL;
	CRYPT_PROVIDER_CERT       *psProvCert     = NULL;
	CMSG_SIGNER_INFO          *psSigner       = NULL;

	// grab the provider data
	psProvData = WINTRUST::WTHelperProvDataFromStateData(sWinTrustData.hWVTStateData);
	if (psProvData)
	{
		// grab the signer data from the CRYPT_PROV_DATA
		psProvSigner = WINTRUST::WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA)psProvData, 0 /*first signer*/, FALSE /* not a counter signer */, 0);

		if (psProvSigner)
		{
			// grab the signer cert from CRYPT_PROV_SGNR (pos 0 = signer cert; pos csCertChain-1 = root cert)
			psProvCert = WINTRUST::WTHelperGetProvCertFromChain(psProvSigner, 0);
		}
	}

	//----------------------------------------------------------------
	// Step 5: Verify state data obtained, return and release if not
	//----------------------------------------------------------------
	if (!psProvData || !psProvSigner || !psProvCert)
	{
		// no state data! -- fail to secure mode
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		DEBUGMSGV(TEXT("Unable to obtain the saved state data from WinVerifyTrust"));
		return icsrNotTrusted;
	}

	//----------------------------------------------------------------
	// Step 6: Compare Signed CAB cert to MSI stored cert
	//----------------------------------------------------------------
	if (icrMatch != MsiCompareSignatureCertificates(&riSignatureCert, psProvCert->pCert, riFileName))
	{
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		return icsrWrongCertificate;
	}

	//----------------------------------------------------------------
	// Step 7: Compare Signed CAB hash to MSI stored hash
	//----------------------------------------------------------------
	if (!piSignatureHash)
	{
		DEBUGMSGV1(TEXT("Skipping Signed CAB hash to MSI stored hash comparison --> No authored hash in MsiDigitalSignature table for cabinet '%s'"), riFileName.GetString());
	}
	else if (icrMatch != MsiCompareSignatureHashes(piSignatureHash, psProvSigner->psSigner->EncryptedHash, riFileName))
	{
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		return icsrWrongHash;
	}

	//----------------------------------------------------------------
	// Step 8: Release State Data and Return trusted
	//----------------------------------------------------------------
	DEBUGMSGV1(TEXT("CAB '%s' is a validly signed cab and validates according to authoring of MSI package"), riFileName.GetString());
	ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
	return icsrTrusted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\diagnose.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       diagnose.cpp
//
//--------------------------------------------------------------------------

/* diagnose.cpp - diagnostic output facilities
____________________________________________________________________________*/

#include "precomp.h"
#include "_msiutil.h"
#include "_msinst.h"
#include "_assert.h"
#include "_diagnos.h"
#include "eventlog.h"
#include "_engine.h"

int g_dmDiagnosticMode         = -1; // -1 until set, then DEBUGMSG macro skips fn call if 0

extern scEnum g_scServerContext;
extern Bool   g_fCustomActionServer;
extern HINSTANCE        g_hInstance;     // Global:  Instance of DLL

const int cchOutputBuffer = 1100;

// forward declarations
void ReportToEventLogW(WORD wEventType, int iEventLogTemplate, const WCHAR* szLogMessage, const WCHAR* szArg1, const WCHAR* szArg2, const WCHAR* szArg3, DWORD dwDataSize=0, LPVOID argRawData=NULL);

void SetDiagnosticMode()
{
	g_dmDiagnosticMode = 0; // disable debugmsg's from GetIntegerPolicyValue
	int iDebugPolicy = GetIntegerPolicyValue(szDebugValueName, fTrue);
	if ( (iDebugPolicy & dpVerboseDebugOutput) == dpVerboseDebugOutput )
		g_dmDiagnosticMode = dmDebugOutput | dmVerboseDebugOutput; // iVerboseDebugOutput implies iDebugOutput
	else if ( (iDebugPolicy & dpDebugOutput) == dpDebugOutput )
		g_dmDiagnosticMode = dmDebugOutput;

	if(g_dwLogMode & INSTALLLOGMODE_VERBOSE)
		g_dmDiagnosticMode |= dmVerboseLogging;

	if(g_dmDiagnosticMode & dmVerboseLogging || g_dwLogMode & INSTALLLOGMODE_INFO)
		g_dmDiagnosticMode |= dmLogging;

	Assert((g_dmDiagnosticMode & dmDebugOutput) || !(g_dmDiagnosticMode & dmVerboseDebugOutput)); // verbose debugout => debugout
	Assert((g_dmDiagnosticMode & dmLogging) || !(g_dmDiagnosticMode & dmVerboseLogging));         // verbose logging => logging
}

bool FDiagnosticModeSet(int iMode)
{
	if(g_dmDiagnosticMode == -1)
		SetDiagnosticMode();
	return (g_dmDiagnosticMode & iMode) != 0;
}

bool WriteLog(const ICHAR* szText);

const int cDebugStringArgs = 7; // number of argument strings to DebugString (including szMsg)


// CApiConvertString is a large consumer of stack when performing conversion to unicode. Event reports
// are uncommon, so stack consumption is isolated to its own child function.
static void ReportToEventLogA(WORD wEventType, int iEventLogTemplate, const char* szLogMessage, const char* szArg1, const char* szArg2, 
	const char* szArg3, DWORD dwDataSize, LPVOID argRawData)
{
	ReportToEventLogW(wEventType,iEventLogTemplate, CApiConvertString(szLogMessage), CApiConvertString(szArg1),
		CApiConvertString(szArg2), CApiConvertString(szArg3), dwDataSize, argRawData);
}

void DebugString(int iMode, WORD wEventType, int iEventLogTemplate,
					  LPCSTR szMsg, LPCSTR arg1, LPCSTR arg2, LPCSTR arg3, LPCSTR arg4, LPCSTR arg5, LPCSTR arg6,
					  DWORD dwDataSize, LPVOID argRawData)
{
	if(g_dmDiagnosticMode == -1)
	{
		SetDiagnosticMode();

		if(g_dmDiagnosticMode == 0)
			return;
	}

	if(((g_dmDiagnosticMode|dmEventLog) & iMode) == 0)
		return;

	static DWORD dwProcId = GetCurrentProcessId() & 0xFF;
	DWORD dwThreadId = GetCurrentThreadId() & 0xFF;
	DWORD dwEffectiveThreadId = MsiGetCurrentThreadId() & 0xFF;

	const int cchPreMessage = 17; // "MSI (s) (##:##): "
	char szPreMessage[cchPreMessage+1];
	const char rgchServ[] = "MSI (s)";
	const char rgchCAServer[] = "MSI (a)";
	const char rgchClient[] = "MSI (c)";
	const char *pszContextString = NULL;
	switch (g_scServerContext)
	{
	case scService:
	case scServer:
		pszContextString = rgchServ;
		break;
	case scCustomActionServer:
		pszContextString = rgchCAServer;
		break;
	case scClient:
		pszContextString = rgchClient;
		break;
	}
	
	if (FAILED(
		StringCchPrintfA(szPreMessage, ARRAY_ELEMENTS(szPreMessage), "%s (%.2X%c%.2X): ",
							  pszContextString, dwProcId, dwThreadId == dwEffectiveThreadId ? ':' : '!',
							  dwEffectiveThreadId)))
	{
		Assert(0);
		return;
	}

	CAPITempBuffer<char, 256> szBuffer;
	AssertSz(szBuffer.GetSize() > cchPreMessage+1, "Debug Output initial buffer size too small.");
	
	if(iMode & dmEventLog)
	{
		const char* rgszArgs[cDebugStringArgs] = {szMsg, arg1, arg2, arg3, arg4, arg5, arg6};
		bool fEndLoop = false;
		WORD wLanguage = g_MessageContext.GetCurrentUILanguage();
		int iRetry = (wLanguage == 0) ? 1 : 0;
		while ( !fEndLoop )
		{
			if ( !MsiSwitchLanguage(iRetry, wLanguage) )
			{
				fEndLoop = true;
				*(static_cast<char*>(szBuffer)+cchPreMessage) = L'\0';
			}
			else
			{
				if (0 == WIN::FormatMessageA(
											FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
											g_hInstance, iEventLogTemplate, wLanguage,
											static_cast<char*>(szBuffer)+cchPreMessage,
											szBuffer.GetSize() - cchPreMessage,
											(va_list*)rgszArgs))
				{
					// formatmessage failed, could be out of space
					if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
					{
						// resize the buffer to the maximum size for a debug message
						if (szBuffer.SetSize(cchOutputBuffer))
						{
							// allocation succeeded, retry the format call
							if (0 != WIN::FormatMessageA(
														FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
														g_hInstance, iEventLogTemplate, wLanguage,
														static_cast<char*>(szBuffer)+cchPreMessage,
														szBuffer.GetSize() - cchPreMessage,
														(va_list*)rgszArgs))
								fEndLoop = true;
						}
					}						
				}
				else
					fEndLoop = true;
			}
		}
	}
	else
	{
		// attempt to format the message into an output buffer.
		DWORD dwRes = StringCchPrintfA(static_cast<char*>(szBuffer)+cchPreMessage, szBuffer.GetSize()-cchPreMessage,
						 szMsg, arg1, arg2, arg3, arg4, arg5, arg6);
		if (STRSAFE_E_INSUFFICIENT_BUFFER == dwRes)
		{
			// resize buffer to maximum log line size. If resize fails, use the truncated log message
			// rather than nothing at all.
			if (szBuffer.SetSize(cchOutputBuffer))
			{
				// The string might get truncated here but that's okay.
				StringCchPrintfA(static_cast<char*>(szBuffer)+cchPreMessage, szBuffer.GetSize()-cchPreMessage,
								 szMsg, arg1, arg2, arg3, arg4, arg5, arg6);
			}
		}
	}

	// prepend the MSI context data to the string, do not null terminate in this operation
	// the entire string should be null terminated.
	memcpy(szBuffer, szPreMessage, cchPreMessage*sizeof(char));

	if(g_dmDiagnosticMode & (dmDebugOutput|dmVerboseDebugOutput) & iMode)
	{
		OutputDebugStringA(szBuffer);
		OutputDebugStringA("\r\n");
	}

	if((g_dmDiagnosticMode & (dmLogging|dmVerboseLogging) & iMode))
	{
		int iOldMode = g_dmDiagnosticMode;
		g_dmDiagnosticMode = 0; // disable debugmsg's from Invoke
		WriteLog(CApiConvertString(szBuffer));
		g_dmDiagnosticMode = iOldMode;
	}

	if(iMode & dmEventLog)
	{
		// event log messages in MSI have at most 3 arguments. There is a significant cost associated
		// with each argument in the ANSI case, so only three arguments are accepted. The others are
		// assumed to be the default "(NULL)" value.
		Assert(0 == strcmp(arg4, "(NULL)"));
		Assert(0 == strcmp(arg5, "(NULL)"));
		Assert(0 == strcmp(arg6, "(NULL)"));
		ReportToEventLogA(wEventType,iEventLogTemplate, szMsg, arg1, arg2, arg3, dwDataSize, argRawData);
	}
}

void DebugString(int iMode, WORD wEventType, int iEventLogTemplate,
					  LPCWSTR szMsg, LPCWSTR arg1, LPCWSTR arg2, LPCWSTR arg3, LPCWSTR arg4, LPCWSTR arg5, LPCWSTR arg6,
					  DWORD dwDataSize, LPVOID argRawData)
{
	if(g_dmDiagnosticMode == -1)
	{
		SetDiagnosticMode();

		if(g_dmDiagnosticMode == 0)
			return;
	}

	if(((g_dmDiagnosticMode|dmEventLog) & iMode) == 0)
		return;

	static DWORD dwProcId = GetCurrentProcessId() & 0xFF;
	DWORD dwThreadId = GetCurrentThreadId() & 0xFF;
	DWORD dwEffectiveThreadId = MsiGetCurrentThreadId() & 0xFF;
	
	const int cchPreMessage = 17; // "MSI (s) (##:##): "
	WCHAR szPreMessage[cchPreMessage+1];
	const WCHAR *pszContextString = NULL;
	const WCHAR rgchServ[] =     L"MSI (s)";
	const WCHAR rgchCAServer[] = L"MSI (a)";
	const WCHAR rgchClient[] =   L"MSI (c)";
	switch (g_scServerContext)
	{
	case scService:
	case scServer:
		pszContextString = rgchServ;
		break;
	case scCustomActionServer:
		pszContextString = rgchCAServer;
		break;
	case scClient:
		pszContextString = rgchClient;
		break;
	}
	
	// this part of the operation should never fail, the lengths of the substrings are
	// known to be limited.
	if (FAILED(
		StringCchPrintfW(szPreMessage, ARRAY_ELEMENTS(szPreMessage),
							  L"%s (%.2X%c%.2X): ", pszContextString, dwProcId,
							  dwThreadId == dwEffectiveThreadId ? L':' : L'!',
							  dwEffectiveThreadId)))
	{
		Assert(0);
		return;
	}
	
	// the majority of log messages are less than 256 characters.
	CAPITempBuffer<WCHAR, 256> szBuffer;
	AssertSz(szBuffer.GetSize() > cchPreMessage+1, "Debug Output initial buffer size too small.");

	if(iMode & dmEventLog)
	{
		const WCHAR* rgszArgs[cDebugStringArgs] = {szMsg, arg1, arg2, arg3, arg4, arg5, arg6};
		bool fEndLoop = false;
		WORD wLanguage = g_MessageContext.GetCurrentUILanguage();
		int iRetry = (wLanguage == 0) ? 1 : 0;
		while ( !fEndLoop )
		{
			if ( !MsiSwitchLanguage(iRetry, wLanguage) )
			{
				fEndLoop = true;
				*(static_cast<WCHAR*>(szBuffer)+cchPreMessage) = L'\0';
			}
			else
			{
				if (0 == WIN::FormatMessageW(
											FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
											g_hInstance, iEventLogTemplate, wLanguage,
											static_cast<WCHAR*>(szBuffer)+cchPreMessage,
											szBuffer.GetSize() - cchPreMessage,
											(va_list*)rgszArgs))
				{
					// formatmessage failed, could be out of space
					if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
					{
						// resize the buffer to the maximum size for a debug message
						if (szBuffer.SetSize(cchOutputBuffer))
						{
							// allocation succeeded, retry the format call
							if (0 != WIN::FormatMessageW(
														FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
														g_hInstance, iEventLogTemplate, wLanguage,
														static_cast<WCHAR*>(szBuffer)+cchPreMessage,
														szBuffer.GetSize() - cchPreMessage,
														(va_list*)rgszArgs))
								fEndLoop = true;
						}
					}						
				}
				else
					fEndLoop = true;
			}
		}
	}
	else
	{
		// attempt to format the message into an output buffer.
		DWORD dwRes = StringCchPrintfW(static_cast<WCHAR*>(szBuffer)+cchPreMessage, szBuffer.GetSize()-cchPreMessage,
						 szMsg, arg1, arg2, arg3, arg4, arg5, arg6);
		if (STRSAFE_E_INSUFFICIENT_BUFFER == dwRes)
		{
			// resize buffer to maximum log line size. If resize fails, use the truncated log message
			// rather than nothing at all.
			if (szBuffer.SetSize(cchOutputBuffer))
			{
				// The string might get truncated here but that's okay.
				StringCchPrintfW(static_cast<WCHAR*>(szBuffer)+cchPreMessage, szBuffer.GetSize()-cchPreMessage,
								 szMsg, arg1, arg2, arg3, arg4, arg5, arg6);
			}
		}
	}

	// prepend the MSI context data to the string, do not null terminate in this operation
	// the entire string should be null terminated.
	memcpy(szBuffer, szPreMessage, cchPreMessage*sizeof(WCHAR));

	if(g_dmDiagnosticMode & (dmDebugOutput|dmVerboseDebugOutput) & iMode)
	{
		OutputDebugStringW(szBuffer);
		OutputDebugStringW(L"\r\n");
	}

	if((g_dmDiagnosticMode & (dmLogging|dmVerboseLogging) & iMode))
	{
		int iOldMode = g_dmDiagnosticMode;
		g_dmDiagnosticMode = 0; // disable debugmsg's from Invoke
		WriteLog(szBuffer);
		g_dmDiagnosticMode = iOldMode;
	}

	if(iMode & dmEventLog)
	{
		// event log messages in MSI have at most 3 arguments. There is a significant cost associated
		// with each argument in the ANSI case, so only three arguments are accepted. The others are
		// assumed to be the default "(NULL)" value.
		Assert(0 == wcscmp(arg4, L"(NULL)"));
		Assert(0 == wcscmp(arg5, L"(NULL)"));
		Assert(0 == wcscmp(arg6, L"(NULL)"));
		ReportToEventLogW(wEventType, iEventLogTemplate, szMsg, arg1, arg2, arg3,
								  dwDataSize, argRawData);
	}
}

const ICHAR* szFakeEventLog = TEXT("msievent.log");

HANDLE CreateFakeEventLog(bool fDeleteExisting=false)
{
	CAPITempBuffer<ICHAR, MAX_PATH> rgchTempDir;
	GetTempDirectory(rgchTempDir);
	rgchTempDir.Resize(rgchTempDir.GetSize() + sizeof(szFakeEventLog)/sizeof(ICHAR) + 1);
	RETURN_THAT_IF_FAILED(StringCchCat(rgchTempDir, rgchTempDir.GetSize(), szDirSep), INVALID_HANDLE_VALUE);
	RETURN_THAT_IF_FAILED(StringCchCat(rgchTempDir, rgchTempDir.GetSize(), szFakeEventLog), INVALID_HANDLE_VALUE);

	HANDLE hFile = CreateFile(rgchTempDir, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, 
									  0, fDeleteExisting ? CREATE_ALWAYS : OPEN_ALWAYS, (FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
	if (hFile == INVALID_HANDLE_VALUE)
		return INVALID_HANDLE_VALUE;

	if (WIN::SetFilePointer(hFile, 0, NULL, FILE_END) == 0xFFFFFFFF)
	{
		WIN::CloseHandle(hFile);
		return INVALID_HANDLE_VALUE;
	}
	return hFile;
}

void ReportToEventLogW(WORD wEventType, int iEventLogTemplate, const WCHAR* szLogMessage, const WCHAR* szArg1, const WCHAR* szArg2, const WCHAR* szArg3,
							 DWORD dwDataSize, LPVOID argRawData)
{
	if (!g_fWin9X)
	{
		// Event log reporting is Windows NT only
		HANDLE hEventLog = RegisterEventSourceW(NULL,L"MsiInstaller");
		if (hEventLog)
		{
			const WCHAR* szLog[cDebugStringArgs] = {szLogMessage, szArg1, szArg2, szArg3};
			ReportEventW(hEventLog,wEventType,0,iEventLogTemplate,NULL,4,dwDataSize,(LPCWSTR*) szLog,argRawData);
			DeregisterEventSource(hEventLog);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\except.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       except.cpp
//
//--------------------------------------------------------------------------

/* except.cpp - Exception handling implementation

Functions in this file support catching exceptions that are raised in 
our server. Most of this code comes from "Under the Hood" articles
by Matt Pietrek in the April and May 1997 issues of MSJ.
____________________________________________________________________________*/

#include "precomp.h" 
#include "_engine.h"
#include <eh.h>

#define _IMAGEHLP_SOURCE_  // prevent import def error
#include "imagehlp.h"

#ifndef NOEXCEPTIONS

void GenerateExceptionReport(EXCEPTION_RECORD* pExceptionRecord, CONTEXT* pCtx);
void GenerateExceptionReport(LPEXCEPTION_POINTERS pExceptionInfo);
int HandleException(LPEXCEPTION_POINTERS pExceptionInfo);
void ImagehlpStackWalk( PVOID lAddr, PCONTEXT pContext,ICHAR *pszBuf, int cchBuf );

typedef BOOL (__stdcall * STACKWALKPROC)
           ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
            PREAD_PROCESS_MEMORY_ROUTINE,PFUNCTION_TABLE_ACCESS_ROUTINE,
            PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );

typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, DWORD );

typedef DWORD (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, DWORD );

void GenerateExceptionReport(LPEXCEPTION_POINTERS pExceptionInfo)
{
        GenerateExceptionReport(pExceptionInfo->ExceptionRecord, pExceptionInfo->ContextRecord);
}

int HandleException(LPEXCEPTION_POINTERS /*pExceptionInfo*/)
{
        return EXCEPTION_CONTINUE_SEARCH;
}


//======================================================================
// Given an exception code, returns a pointer to a static string with a 
// description of the exception                                         
//======================================================================
LPTSTR GetExceptionString( DWORD dwCode )
{
    #define EXCEPTION( x ) case EXCEPTION_##x: return TEXT(#x);

    switch ( dwCode )
    {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
    }

    // If not one of the "known" exceptions, try to get the string
    // from NTDLL.DLL's message table.

    static TCHAR szBuffer[512] = { 0 };

    FormatMessage(  FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                    GetModuleHandle( TEXT("NTDLL.DLL") ),
                    dwCode, 0, szBuffer, ARRAYSIZE( szBuffer ), 0 );

    return szBuffer;
}


//==============================================================================
// Given a linear address, locates the module, section, and offset containing  
// that address.                                                               
//                                                                             
// Note: the szModule paramater buffer is an output buffer of length specified 
// by the len parameter (in characters!)                                       
//==============================================================================
BOOL GetLogicalAddress(
        PVOID addr, PTSTR szModule, DWORD len, DWORD& section, DWORD& offset )
{
    MEMORY_BASIC_INFORMATION mbi;

    if ( !VirtualQuery( addr, &mbi, sizeof(mbi) ) )
        return FALSE;

    UINT_PTR hMod = (UINT_PTR)mbi.AllocationBase;                               //--merced: changed DWORD to UINT_PTR, twice.
        
        if (!hMod)
                return FALSE;

    if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
    {
        *szModule = L'\0';
        return FALSE;
    }

    // Point to the DOS header in memory
    PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)hMod;

    // From the DOS header, find the NT (PE) header
    PIMAGE_NT_HEADERS pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);

    PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION( pNtHdr );

    UINT_PTR rva = (UINT_PTR)addr - hMod; // RVA is offset from module load address                             //--merced: changed DWORD to UINT_PTR, twice.

    // Iterate through the section table, looking for the one that encompasses
    // the linear address.
    for (   unsigned i = 0;
            i < pNtHdr->FileHeader.NumberOfSections;
            i++, pSection++ )
    {
        DWORD sectionStart = pSection->VirtualAddress;
        DWORD sectionEnd = sectionStart
                    + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);

        // Is the address in this section???
        if ( (rva >= (UINT_PTR)sectionStart) && (rva <= (UINT_PTR)sectionEnd) )         //--merced: added UINT_PTR, twice.
        {
            // Yes, address is in the section.  Calculate section and offset,
            // and store in the "section" & "offset" params, which were
            // passed by reference.
            section = i+1;
            offset = (unsigned long)(rva - (UINT_PTR)sectionStart);             //--merced: okay to convert. changed from <offset = rva - sectionStart;>
            return TRUE;
        }
    }

    return FALSE;   // Should never get here!
}

void GenerateExceptionReport(
    EXCEPTION_RECORD* pExceptionRecord, CONTEXT* pCtx)
{
    DEBUGMSG("Generating exception report.");
    ICHAR szDebugBuf[sizeof(g_MessageContext.m_rgchExceptionInfo)/sizeof(ICHAR)];
    ICHAR szShortBuf[255];

    // Start out with a banner
    if ( FAILED(StringCchCopy(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), TEXT("=====================================================\r\n") )) )
    {
        goto PrintOut;
    }

    // First print information about the type of fault
    if ( FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf),
                                TEXT("Exception code: %08X %s\r\n"),
                                pExceptionRecord->ExceptionCode,
                                GetExceptionString(pExceptionRecord->ExceptionCode))) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) )
    {
        goto PrintOut;
    }

    // Now print the module

    ICHAR szFaultingModule[MAX_PATH];
    DWORD section, offset;
    if (GetLogicalAddress(  pExceptionRecord->ExceptionAddress,
                        szFaultingModule,
                        sizeof( szFaultingModule )/sizeof(ICHAR),
                        section, offset ))
    {
        if ( FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf),
                                    TEXT("Module: %s\r\n"), szFaultingModule)) ||
             FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) )
        {
            goto PrintOut;
        }
    }

    // Now print the function name
    if ( FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), TEXT("Function: "))) )
    {
       goto PrintOut;
    }

    Assert((LONG_PTR)pExceptionRecord->ExceptionAddress <= UINT_MAX);       //--merced: we typecast to long below, it better be in range
#ifdef DEBUG
    SzFromFunctionAddress(szShortBuf, ARRAY_ELEMENTS(szShortBuf), (long)(LONG_PTR)(pExceptionRecord->ExceptionAddress));        //--merced: okay to typecast
    if ( 
#else // SHIP
    if ( FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf), TEXT("0x%x"), (long)(LONG_PTR)pExceptionRecord->ExceptionAddress)) ||         //--merced: okay to typecast
#endif
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), TEXT("\r\n=====================================================\r\n"))) )
    {
       goto PrintOut;
    }

    // Show the registers
#ifdef _X86_  // Intel Only!
    if ( FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf), TEXT("\r\nRegisters:\r\n"))) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) ||
         FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf), TEXT("EAX:%08X  EBX:%08X  ECX:%08X  EDX:%08X  ESI:%08X  EDI:%08X\r\n"),
                pCtx->Eax, pCtx->Ebx, pCtx->Ecx, pCtx->Edx, pCtx->Esi, pCtx->Edi )) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) ||
         FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf), TEXT("CS:EIP:%04X:%08X "), pCtx->SegCs, pCtx->Eip)) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) ||
         FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf), TEXT("SS:ESP:%04X:%08X  EBP:%08X\r\n"),
                pCtx->SegSs, pCtx->Esp, pCtx->Ebp )) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) ||
         FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf), TEXT("DS:%04X  ES:%04X  FS:%04X  GS:%04X\r\n"),
                pCtx->SegDs, pCtx->SegEs, pCtx->SegFs, pCtx->SegGs )) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) ||
         FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf), TEXT("Flags:%08X\r\n"), pCtx->EFlags )) ||
         FAILED(StringCchCat(szDebugBuf, ARRAY_ELEMENTS(szDebugBuf), szShortBuf)) )
    {
       goto PrintOut;
    }
#endif

    ImagehlpStackWalk( pExceptionRecord->ExceptionAddress, pCtx, szDebugBuf + IStrLen(szDebugBuf), sizeof(szDebugBuf)/sizeof(ICHAR) - IStrLen(szDebugBuf));

PrintOut:
    LogAssertMsg(szDebugBuf);
    IStrCopyLen(g_MessageContext.m_rgchExceptionInfo, szDebugBuf, sizeof(g_MessageContext.m_rgchExceptionInfo)/sizeof(ICHAR) - 1);
}

//============================================================
// Walks the stack, and returns the results in a string
// Mostly taken from Matt Pietrek's MSJ article
// 
// N.B. This entire stack walk is broken for 64-bit platforms.
//          It compiles, but that is about all.
//
//============================================================
void ImagehlpStackWalk( PVOID lAddr, PCONTEXT pContext,ICHAR *pszBuf, int cchBuf )
{   

#if defined(_X86_)

        STACKWALKPROC   _StackWalk = 0;
        SYMFUNCTIONTABLEACCESSPROC      _SymFunctionTableAccess = 0;
        SYMGETMODULEBASEPROC    _SymGetModuleBase = 0;
        ICHAR szShortBuf[255];
        BOOL fQuit = 0;
        
        HMODULE hModImagehlp = LoadLibrary( TEXT("Imagehlp.dll"));
        if (hModImagehlp == 0)
                return;
                
        _StackWalk = (STACKWALKPROC)GetProcAddress( hModImagehlp, "StackWalk" );
        if ( !_StackWalk )
            return;

        _SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC)
                            GetProcAddress( hModImagehlp, "SymFunctionTableAccess" );

        if ( !_SymFunctionTableAccess )
            return;

        _SymGetModuleBase=(SYMGETMODULEBASEPROC)GetProcAddress( hModImagehlp,
                                                                "SymGetModuleBase");
        if ( !_SymGetModuleBase )
            return;
            
    if ( FAILED(StringCchCopy(pszBuf, cchBuf, TEXT("\r\nCall stack:\r\n"))) ||
         FAILED(StringCchCat(pszBuf, cchBuf,  TEXT("Address   Frame\r\n"))) )
        return;

    // Could use SymSetOptions here to add the SYMOPT_DEFERRED_LOADS flag

    STACKFRAME sf;
    memset( &sf, 0, sizeof(sf) );

     Assert((UINT_PTR) lAddr < UINT_MAX);                                    //--merced: we typecast below to DWORD, lAddr better be in range
    // Initialize the STACKFRAME structure for the first call.  This is only
    // necessary for Intel CPUs, and isn't mentioned in the documentation.
    sf.AddrPC.Offset       = (DWORD)(UINT_PTR)lAddr;            //--merced: added (UINT_PTR). okay to typecast.
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->Esp;
    sf.AddrStack.Mode      = AddrModeFlat;
    sf.AddrFrame.Offset    = pContext->Ebp;
    sf.AddrFrame.Mode      = AddrModeFlat;
    while ( !fQuit )
    {
        if ( ! _StackWalk(  
                            IMAGE_FILE_MACHINE_I386,
                            GetCurrentProcess(),
                            GetCurrentThread(),
                            &sf,
                            pContext,
                            0,
                            _SymFunctionTableAccess,
                            _SymGetModuleBase,
                            0 ) )
            break;

        if ( 0 == sf.AddrFrame.Offset ) // Basic sanity check to make sure
            break;                      // the frame is OK.  Bail if not.

        // IMAGEHLP is wacky, and requires you to pass in a pointer to an
        // IMAGEHLP_SYMBOL structure.  The problem is that this structure is
        // variable length.  That is, you determine how big the structure is
        // at runtime.  This means that you can't use sizeof(struct).
        // So...make a buffer that's big enough, and make a pointer
        // to the buffer.  We also need to initialize not one, but TWO
        // members of the structure before it can be used.

        BYTE symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
        PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLength = 512;
        ICHAR szSymName[256];
                        
        DWORD symDisplacement = 0;  // Displacement of the input address,
                                    // relative to the start of the symbol

#ifdef DEBUG
        SzFromFunctionAddress(szSymName, ARRAY_ELEMENTS(szSymName), sf.AddrPC.Offset);
        if ( 
#else // SHIP
        if ( FAILED(StringCchPrintf(szSymName, ARRAY_ELEMENTS(szSymName), TEXT("0x%x"), sf.AddrPC.Offset)) ||
#endif
             FAILED(StringCchPrintf(szShortBuf, ARRAY_ELEMENTS(szShortBuf),
                                   TEXT("%08X  %08X %s\r\n -- 0x%08X 0x%08X 0x%08X 0x%08X\r\n"),
                                   sf.AddrPC.Offset, sf.AddrFrame.Offset, szSymName,
                                   sf.Params[0], sf.Params[1], sf.Params[2], sf.Params[3])) ||
             FAILED(StringCchCat(pszBuf, cchBuf, szShortBuf)) )
        {
            return;
        }
    }
#else
    UNREFERENCED_PARAMETER(lAddr);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(pszBuf);
    UNREFERENCED_PARAMETER(cchBuf);
#endif
}


#endif // NOEXCEPTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\fdidll.c ===
/*
 *  FDIDLL.C -- FDI interface using CABINET.DLL
 *
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1997
 *  All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      21-Jan-1997 msliger Initial version
 *      24-Jan-1997 msliger Changed to public include file
 *      18-Sep-1997 malcolmh Changed to support UNICODE
 *
 *  Overview:
 *      This code is a wrapper which provides access to the actual FDI code
 *      in CABINET.DLL.  CABINET.DLL dynamically loads/unloads as needed.
 */
 
#include <windows.h>

#include "fdi.h"

static HINSTANCE hCabinetDll;   /* DLL module handle */

/* pointers to the functions in the DLL */

static HFDI (FAR DIAMONDAPI *pfnFDICreate)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf);
static BOOL (FAR DIAMONDAPI *pfnFDIIsCabinet)(
        HFDI                hfdi,
        INT_PTR             hf,
        PFDICABINETINFO     pfdici);
static BOOL (FAR DIAMONDAPI *pfnFDICopy)(
        HFDI                hfdi,
        char                *pszCabinet,
        char                *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser);
static BOOL (FAR DIAMONDAPI *pfnFDIDestroy)(
        HFDI                hfdi);


/*
 *  FDICreate -- Create an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;

    hCabinetDll = LoadLibrary(TEXT("CABINET"));
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = (void *) GetProcAddress(hCabinetDll,"FDICreate");
    pfnFDICopy = (void *) GetProcAddress(hCabinetDll,"FDICopy");
    pfnFDIIsCabinet = (void *) GetProcAddress(hCabinetDll,"FDIIsCabinet");
    pfnFDIDestroy = (void *) GetProcAddress(hCabinetDll,"FDIDestroy");

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);

        return(NULL);
    }

    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return(hfdi);
}


/*
 *  FDIIsCabinet -- Determines if file is a cabinet, returns info if it is
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFDIIsCabinet(hfdi,hf,pfdici));
}


/*
 *  FDICopy -- extracts files from a cabinet
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char         *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


/*
 *  FDIDestroy -- Destroy an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);
    if (rc == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\fdisvr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       fdisvr.cpp
//
//--------------------------------------------------------------------------

//														
// File: fdisvsr.cpp
// Purpose: Implements the FDI Server thread
// Notes:
//____________________________________________________________________________

//////////////////////////////////////////////////////////////////////////////
// Includes and #defines
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "_assert.h"
#include "callback.h"
#include "fdisvr.h"
#include "notify.h"
#include "_dgtlsig.h"

//////////////////////////////////////////////////////////////////////////////
// Global data
//////////////////////////////////////////////////////////////////////////////

// We use events for starting\blocking threads in Win32
static HANDLE		s_hInterfaceEvent=INVALID_HANDLE_VALUE;
static HANDLE		s_hServerEvent=INVALID_HANDLE_VALUE;

HANDLE g_hCallbackInterfaceEvent = NULL;
HANDLE g_hCallbackServerEvent = NULL;

extern HANDLE g_hInterfaceInterfaceEvent;
extern HANDLE g_hInterfaceServerEvent;

// Pointer to shared FDI data -- this is what we use to exchange information between
// the FDI Server and the FDI Interface
FDIShared*          g_pFDIs = NULL; // Not static because callback.cpp needs access

// Handle to FDI
static HFDI			g_hfdi = NULL;

// Error data structures
ERF					g_erf;					// Errors from FDI
FDIServerResponse	g_fdirCallbackError;	// Additional errors from our callbacks
HANDLE              g_hCurDestFile;         // Handle to destination file currently open
IStream* g_pDestFile;				        // Handle to destination stream of Assembly currently open


//////////////////////////////////////////////////////////////////////////////
// Forward function declarations
//////////////////////////////////////////////////////////////////////////////

int					Initialize();
FDIServerCommand	ProcessNextEvent();	
FDIServerCommand	CheckFDIs();
void				DoOpenCabinet();
void				DoClose();
void				DoExtractFileFromCabinet();
void				MainEventLoop();
void				Finish();

//////////////////////////////////////////////////////////////////////////////
// externs function declarations
//////////////////////////////////////////////////////////////////////////////
extern Bool StartFdiImpersonating(bool fNonWrapperCall);
extern void StopFdiImpersonating(bool fNonWrapperCall);


	/* M A I N   /   S T A R T  F D I  S E R V E R*/
/*----------------------------------------------------------------------------
	%%Function: Main / StartFDIServer

	This is the entry-point to the FDI server.This function is started as a
	separate thread by the copy object.
----------------------------------------------------------------------------*/
DWORD WINAPI StartFDIServer(LPVOID fdis)
{
	// Initialize g_pFDIs with pointer to the FDI Interface objects internal
	// shared data
	OLE32::CoInitialize(0);
	g_pFDIs = (FDIShared*)fdis;
	g_pFDIs->fdir = fdirNoResponse;
	
	if (Initialize())
	{
		MainEventLoop();
	}
	else
	{
		// Set an error so we know we failed
		g_pFDIs->fdir = fdirServerDied;
	}

	Finish();
	OLE32::CoUninitialize();
	return 0;
}

/* I N I T I A L I Z E*/
/*----------------------------------------------------------------------------
	%%Function: Initialize
	
	Establishes an FDI context.
----------------------------------------------------------------------------*/
int Initialize()
{
	if (s_hServerEvent == INVALID_HANDLE_VALUE)
	{
		if(!DuplicateHandle(GetCurrentProcess(), g_hInterfaceServerEvent, 
							GetCurrentProcess(), &s_hServerEvent, 
							0, 0, DUPLICATE_SAME_ACCESS))
			return 0;
		else
			MsiRegisterSysHandle(s_hServerEvent);
	}
	if (s_hInterfaceEvent == INVALID_HANDLE_VALUE)
	{
		if(!DuplicateHandle(GetCurrentProcess(), g_hInterfaceInterfaceEvent, 
							GetCurrentProcess(), &s_hInterfaceEvent, 
							0, 0, DUPLICATE_SAME_ACCESS))
			return 0;
		else
			MsiRegisterSysHandle(s_hInterfaceEvent);
	}

	// Get a handle to an FDI context
	g_hfdi = FDICreate(pfnalloc, pfnfree, pfnopen, 
				     pfnread, pfnwrite, pfnclose,
					 pfnseek, cpuUNKNOWN, &g_erf);

	if (g_pFDIs->fServerIsImpersonated)
		StartFdiImpersonating(false /*wrapper call*/);

	return (g_hfdi != NULL);
}


/* P R O C E S S  N E X T  E V E N T*/
/*----------------------------------------------------------------------------
	%%Function: ProcessNextEvent

	Waits for a command from the FDI interface, and then processes the command.
	
	Returns the FDI server command that was processed.
	Doesn't reset g_pFDIs->fdic
----------------------------------------------------------------------------*/
FDIServerCommand ProcessNextEvent()
{
	// Wait for the FDI Interface to send us an event
	SetEvent(s_hServerEvent);
	DWORD dw = WaitForSingleObject(s_hInterfaceEvent, INFINITE);
	// See if there was any thing for us to do
	return CheckFDIs();
}

/* D O  O P E N  C A B I N E T*/
/*----------------------------------------------------------------------------
	%%Function: DoOpenCabinet

	Opens the cabinet specified by g_pFDIs->achCabinetName and 
	g_pFDIs->achCabinetPath. 
	
	g_pFDIs->fdir is set with the server's response.

----------------------------------------------------------------------------*/
void DoOpenCabinet()
{
	BOOL	fCopyOK;					// FDICopy return value
	ICHAR	achLastCabinetName[256];	// Copy of last cabinet name

	g_pFDIs->fPendingExtract = 0; // No pending extracts


	// FDICopy returns only when it has finished copying all the files
	// beginning in the cabinet we pointed it at.  However, we don't
	// want to return until we've finished an entire *set* of cabinets.
	// So we keep a copy of the last cabinet that we opened, and if we ended
	// up in a different cabinet we know that there are possibly more files
	// in this last cabinet that have not been extracted by FDICopy(), so we
	// call FDICopy() on the last cabinet again.
	// Note: g_pFDIs->achCabinetName will change when FDICopy() requests a 
	// new cabinet (in callback.cpp)
	BOOL fFdiError = FALSE;
	do
	{
		if (g_pFDIs->fSignatureRequired)
		{
			// verify the signature on the CAB to open.
			MsiString strCAB = g_pFDIs->achCabinetPath;
			strCAB += g_pFDIs->achCabinetName;
			
			HRESULT hrWVT = S_OK;
			icsrCheckSignatureResult icsr;

			if (!g_pFDIs->piSignatureCert)
			{
				// something bad has happened!!  The Cert is required, but it is null here
				AssertSz(0, "The certificate is required, but it is null here!");
				g_pFDIs->fdir = fdirBadSignature;
				return;
			}

			icsr = MsiVerifyNonPackageSignature(*strCAB, INVALID_HANDLE_VALUE, *(g_pFDIs->piSignatureCert), g_pFDIs->piSignatureHash, hrWVT);
			
			// if the cabinet signature verifies or crypto is not installed on the machine, we will continue with our attempt to 
			// crack open the cabinet
			//   MsiVerifyNonPackageSignature handles posting to the EventLog in the crypto not installed case
			if (icsrTrusted != icsr && icsrMissingCrypto != icsr)
			{
				// there are 2 different error messages, 1 for Signature Missing, 1 for Invalid Signature
				// we must distinguish here and store the value for the eventual post of the error

				if (icsrNoSignature == icsr) // cabinet did not have signature
					g_pFDIs->fdir = fdirMissingSignature;
				else // cabinet's signature was invalid
					g_pFDIs->fdir = fdirBadSignature;
				
				// store the WVT return code (helps with error message)
				g_pFDIs->hrWVT = hrWVT;
				return;
			}
		}

		g_pFDIs->fdir = fdirNetError;

		// Keep copy of cabinet we're opening
		StringCbCopy(achLastCabinetName, sizeof(achLastCabinetName), g_pFDIs->achCabinetName);

		// FDI forgets to initialize erfOper on re-entry, so we've got to
		g_erf.erfOper = FDIERROR_NONE;

		fCopyOK = FDICopy(g_hfdi,
						const_cast<char*>((const char*) CConvertString(g_pFDIs->achCabinetName)),
						const_cast<char*>((const char*) CConvertString(g_pFDIs->achCabinetPath)),
						0,		// Flags currently appear to be unused.
						fdinotify,
						NULL,	// No decryption routine supplied
						NULL);

		// Our host is done copying files out of the current cabinet, so we can
		// exit now.
		if (!fCopyOK && g_fdirCallbackError == fdirClose)
		{
			DoClose();
			break;
		}

		if (g_fdirCallbackError == fdirUserAbort || g_fdirCallbackError == fdirNetError)
			break;

		// If we had some kind of error we want to get out of this loop - but if g_fdirCallbackError is
		// fdirNeedNextCabinet && erfOper is FDIERROR_USER_ABORT, this is NOT an error - we just need
		// to switch to the next cabinet.
		if ((!fCopyOK) && g_fdirCallbackError != fdirNeedNextCabinet || (g_erf.erfOper != FDIERROR_NONE &&
			g_erf.erfOper != FDIERROR_USER_ABORT))
		{
			fFdiError = TRUE;
			break;
		}
	} while (IStrComp(achLastCabinetName, g_pFDIs->achCabinetName));
	// If all was fine and dandy, ie.
	//	1. There are no files that were requested but not extracted
	//		(g_pFDIs->fPendinfExtract == 0)
	//	2. FDI returned no Errors (g_erf.erfOper == FDIERROR_NONE)
	//	3. Our user aborted with fdicClose and FDI reports FDIERROR_USER_ABORT
	// then we return fdirSuccessfulCompletion
	if (g_fdirCallbackError == fdirUserAbort)
	{
		g_pFDIs->fdir = fdirUserAbort;
	}
	else if (g_fdirCallbackError == fdirNetError)
	{
		g_pFDIs->fdir = fdirNetError;
	}
	else if (!g_pFDIs->fPendingExtract && !fFdiError) 
	{
		g_pFDIs->fdir = fdirSuccessfulCompletion;
	}
	else
	{ 
		// Okay, some kind of error
		// If we had a pending extract and didn't get a create, write or read error
		// then that means that we simply scanned through the whole cabinet
		// ie. a missing file
		if ((g_pFDIs->fPendingExtract) && (g_fdirCallbackError == fdirNoResponse) && fCopyOK)
		{
			g_pFDIs->fdir = fdirFileNotFound;
		}
		else
		{
			// Determine error return code from fdirCallbackError and g_erf.erfOper
			HandleError();
		}
	}
}


/* D O  C L O S E*/
/*----------------------------------------------------------------------------
	%%Function: DoClose

	Destroys the FDI context.
	
	g_pFDIs->fdir is set to fdirSuccessfulCompletion

----------------------------------------------------------------------------*/
void DoClose()
{
	if (g_hfdi)
	{
		FDIDestroy(g_hfdi);
		g_hfdi = NULL;
	}
	g_pFDIs->fdir = fdirSuccessfulCompletion;
}

/* D O  E X T R A C T  F I L E  F R O M  C A B I N E T*/
/*----------------------------------------------------------------------------
	%%Function: DoExtractFileFromCabinet

	We're only supposed to receive this inside an FDICopy call!
----------------------------------------------------------------------------*/
void DoExtractFileFromCabinet()
{
	g_pFDIs->fdir = fdirNoCabinetOpen;
}

/* C H E C K  F D I S*/
/*----------------------------------------------------------------------------
	%%Function: CheckFDIs

	Processes a pending FDI command, if there is one.
----------------------------------------------------------------------------*/
FDIServerCommand CheckFDIs()
{
	if (g_pFDIs)
	{
		//NotifyUser("FDI Server: Checking for command");
		switch (g_pFDIs->fdic)
		{
			case fdicOpenCabinet:
			{
				DoOpenCabinet();
				break;
			}
			case fdicClose:
			case fdicCancel:
			{
				DoClose();
				break;
			}
			case fdicExtractFile:
			{
				DoExtractFileFromCabinet();
				break;
			}
			case fdicNoCommand:
			{
				break;
			}
			default:
			{
				// ought to crash and burn horribly if we ever get here
				NotifyUser("FDI Server:Illegal FDI command received");
				g_pFDIs->fdir = fdirIllegalCommand;
			}
		}
		return g_pFDIs->fdic;
	}
	else return fdicNoCommand;
}

/* M A I N  E V E N T  L O O P*/
/*----------------------------------------------------------------------------
	%%Function: MainEventLoop

	Processes events until the FDI server is given the "close" 
	command.
----------------------------------------------------------------------------*/
void MainEventLoop()
{
	FDIServerCommand fdic;

	do
	{
		fdic = ProcessNextEvent();
		// Clear command now that we've handled it
		g_pFDIs->fdic = fdicNoCommand;
	} while (fdic != fdicClose);
}


/* F I N I S H */
/*----------------------------------------------------------------------------
	%%Function: Finish

	Does any necessary cleanup before the server is shut down.
----------------------------------------------------------------------------*/
void Finish()
{	
	if (g_pFDIs->fServerIsImpersonated)
			StopFdiImpersonating(false /*wrapper call*/);

	if (g_pFDIs->hClientToken != INVALID_HANDLE_VALUE)
		AssertNonZero(MsiCloseSysHandle(g_pFDIs->hClientToken));
	if (g_pFDIs->hImpersonationToken != INVALID_HANDLE_VALUE)
		AssertNonZero(MsiCloseSysHandle(g_pFDIs->hImpersonationToken));

	g_pFDIs->hClientToken = INVALID_HANDLE_VALUE;
	g_pFDIs->hImpersonationToken = INVALID_HANDLE_VALUE;

	SetEvent(s_hServerEvent);

	// We must reset the event handles, because FDIServer
	// can be launched again via automation without 
	// unloading the Services DLL.
	if (s_hInterfaceEvent != INVALID_HANDLE_VALUE)
	{
		AssertNonZero(MsiCloseSysHandle(s_hInterfaceEvent));
		s_hInterfaceEvent = INVALID_HANDLE_VALUE;
	}
	if (s_hServerEvent != INVALID_HANDLE_VALUE)
	{
		AssertNonZero(MsiCloseSysHandle(s_hServerEvent));
		s_hServerEvent = INVALID_HANDLE_VALUE;
	}

	if (g_hCallbackInterfaceEvent != NULL)
	{
		AssertNonZero(MsiCloseSysHandle(g_hCallbackInterfaceEvent));
		g_hCallbackInterfaceEvent = NULL;
	}
	if (g_hCallbackServerEvent != NULL)
	{
		AssertNonZero(MsiCloseSysHandle(g_hCallbackServerEvent));
		g_hCallbackServerEvent = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\execute.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       execute.cpp
//
//--------------------------------------------------------------------------

 /* execute.cpp - IMsiExecute implementation

____________________________________________________________________________*/

#include "precomp.h" 

#include "_execute.h"
#include "eventlog.h"
#include "_srcmgmt.h"
#include <accctrl.h>
#include "_camgr.h"
#define REG_SELFREG_INFO // remove if self registration info unnecessary
#define MAX_NET_RETRIES 5

extern const IMsiString& g_riMsiStringNull;

//____________________________________________________________________________
//
// helper functions useful for clean up.
//____________________________________________________________________________

class CDeleteFileOnClose
{
 public:
	CDeleteFileOnClose(IMsiString const& ristrFileName) : m_ristrName(ristrFileName) { m_ristrName.AddRef(); }
	~CDeleteFileOnClose()
		{
			BOOL fDeleted = WIN::DeleteFile(m_ristrName.GetString());
			DWORD dwLastError = WIN::GetLastError();
	
			m_ristrName.Release();
			if (!fDeleted)
			{
				if (ERROR_FILE_NOT_FOUND == dwLastError)
					return;
				else
					AssertNonZero(fDeleted);
			}
		}
 protected:
	IMsiString const &m_ristrName;
};

class CDeleteEmptyDirectoryOnClose
{
 public:
	CDeleteEmptyDirectoryOnClose(IMsiString const& ristrName) : m_ristrName(ristrName) { m_ristrName.AddRef(); }
	~CDeleteEmptyDirectoryOnClose() { WIN::RemoveDirectory(m_ristrName.GetString()); m_ristrName.Release(); }
 protected:
	IMsiString const &m_ristrName;
};

// class that allows random IUnknown objects to be stored in columns of msi tables
// is derived from IMsiData, since database implementation expects object to be 
// derived from IMsiData

// smart pointer to wrap the CMsiDataWrapper pointer
class CMsiDataWrapper;typedef CComPointer<CMsiDataWrapper>  PMsiDataWrapper;

class CMsiDataWrapper: public IMsiData
{
public:
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj)
	{
		if (MsGuidEqual(riid, IID_IUnknown)
		 || MsGuidEqual(riid, IID_IMsiData))
		{
			*ppvObj = this;
			AddRef();
			return NOERROR;
		}
		*ppvObj = 0;
		return E_NOINTERFACE;
	}

	unsigned long __stdcall AddRef()
	{
		return ++m_iRefCnt;
	}
	unsigned long  __stdcall Release()
	{
		if (--m_iRefCnt != 0)
			return m_iRefCnt;
		if(m_pObj) // release member IUnknown object that we wrap
			m_pObj->Release();
		delete this;
		return 0;
	}
	const IMsiString& __stdcall GetMsiStringValue() const
	{
		return g_riMsiStringNull;// return irrelevant
	}

	int __stdcall GetIntegerValue() const
	{
		return iMsiNullInteger;// return irrelevant
	}

#ifdef USE_OBJECT_POOL
	unsigned int __stdcall GetUniqueId() const
	{
		return m_iCacheId;
	}

	void __stdcall SetUniqueId(unsigned int id)
	{
		Assert(m_iCacheId == 0);
		m_iCacheId = id;
	}
#endif //USE_OBJECT_POOL
	IUnknown* GetObject() const
	{
		if(m_pObj)
		{
			m_pObj->AddRef();
		}
		return m_pObj;
	}
	// helper fn to decipher the IUnknown object held by a CMsiDataWrapper object
	static IUnknown* GetWrappedObject(const IMsiData* piData)
	{
		CMsiDataWrapper* piDataWrapper = const_cast<CMsiDataWrapper*>(static_cast<const CMsiDataWrapper*> (piData));
		if(!piDataWrapper)
			return 0;
		else
			return piDataWrapper->GetObject();
	}

	friend CMsiDataWrapper* CreateMsiDataWrapper(IUnknown* piUnk);
protected:
	CMsiDataWrapper(IUnknown* piUnk)
	{
		m_iRefCnt = 1;     // we're returning an interface, passing ownership
		m_pObj = piUnk;
		if(m_pObj) // hold on to the IUnknown object we wrap
			m_pObj->AddRef();
#ifdef USE_OBJECT_POOL
		m_iCacheId = 0;
#endif //USE_OBJECT_POOL
	}
	int  m_iRefCnt;
	IUnknown* m_pObj;
#ifdef USE_OBJECT_POOL
    unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
};

// CMsiDataWrapper creator fn.
CMsiDataWrapper* CreateMsiDataWrapper(IUnknown* piUnk)
{
	return new CMsiDataWrapper(piUnk);
}


#define LODWORD(d)           ((DWORD)(d))
#define HIDWORD(d)           ((DWORD)(((DWORDLONG)(d) >> 32) & 0xFFFFFFFF))
BOOL CALLBACK CMsiOpExecute::SfpProgressCallback(IN PFILEINSTALL_STATUS pFileInstallStatus, IN DWORD_PTR Context)
{
	CMsiOpExecute* pMsiOpExecute = (CMsiOpExecute*) Context;
	MsiString strFilePath = CConvertString(pFileInstallStatus->FileName);
	strFilePath.LowerCase();
	pMsiOpExecute->m_pFileCacheCursor->Reset();
	AssertNonZero(pMsiOpExecute->m_pFileCacheCursor->PutString(pMsiOpExecute->m_colFileCacheFilePath,*strFilePath));
	if (!pMsiOpExecute->m_pFileCacheCursor->Next())
	{
		DEBUGMSG1(TEXT("SFP has installed a file not found in our file cache - File installed: %s"), strFilePath);
		return true;
	}

	MsiString strPackageVersion = pMsiOpExecute->m_pFileCacheCursor->GetString(pMsiOpExecute->m_colFileCacheVersion);
	DWORD dwProtectedMS = HIDWORD(pFileInstallStatus->Version);
	DWORD dwProtectedLS = LODWORD(pFileInstallStatus->Version);
	MsiString strProtectedVersion = CreateVersionString(dwProtectedMS, dwProtectedLS);
	if (pFileInstallStatus->Win32Error == NO_ERROR)
	{
		DWORD dwPackageMS, dwPackageLS;
		AssertNonZero(ParseVersionString(strPackageVersion, dwPackageMS, dwPackageLS));
		if (CompareVersions(dwProtectedMS, dwProtectedLS, dwPackageMS, dwPackageLS) == icfvExistingLower)
		{
			imsEnum imsResult = pMsiOpExecute->DispatchError(imtEnum(imtError+imtOkCancel+imtDefault1), Imsg(imsgCannotUpdateProtectedFile),
				*strFilePath, *strPackageVersion, *strProtectedVersion);
			if (imsResult == imsCancel)
			{
				pMsiOpExecute->m_fSfpCancel = true;
			}
		}
		else
		{
			DEBUGMSG2(TEXT("File installed by SFP: %s, version: %s"), strFilePath, strProtectedVersion);
		}
	}
	else
	{
		imsEnum imsResult = pMsiOpExecute->DispatchError(imtEnum(imtError+imtOk), Imsg(imsgErrorUpdatingProtectedFile),
			*strFilePath, *strPackageVersion, *strProtectedVersion, pFileInstallStatus->Win32Error);
	}

	PMsiPath pPath(0);
	MsiString strFileName;
	iesEnum ies;
	if((ies = pMsiOpExecute->CreateFilePath(strFilePath, *&pPath, *&strFileName)) == iesSuccess)
	{
		unsigned int uiFileSize;
		PMsiRecord pRecErr(0);
		if ((pRecErr = pPath->FileSize(strFileName, uiFileSize)) == 0)
		{
			if(pMsiOpExecute->DispatchProgress(uiFileSize) == imsCancel)
				pMsiOpExecute->m_fSfpCancel = true;
		}
	}
	return pMsiOpExecute->m_fSfpCancel ? false : true;
}


Bool FGetTTFTitle(const ICHAR* szFile, const IMsiString*& rpiTitle); // from path.cpp
Bool GetExpandedProductInfo(const ICHAR* szProductCode, const ICHAR* szProperty,
										  CTempBufferRef<ICHAR>& rgchExpandedInfo, bool fPatch); // from engine.cpp

IMsiRecord* EnsureShortcutExtension(MsiString& rstrShortcutPath, IMsiServices& riServices); // from services.cpp

bool PrepareHydraRegistryKeyMapping(bool fTSPerMachineInstall); // from engine.cpp

static const ICHAR* DIR_CACHE               = TEXT("Installer");
static const ICHAR* DIR_SECURE_TRANSFORMS   = TEXT("SecureTransforms");

// constant strings used during registration
const ICHAR* g_szDefaultValue = TEXT("");
const ICHAR* g_szExtension = TEXT("Extension");
const ICHAR* g_szClassID = TEXT("CLSID");
const ICHAR* g_szContentType = TEXT("Content Type");
const ICHAR* g_szAssembly = TEXT("Assembly");
const ICHAR* g_szCodebase = TEXT("CodeBase");


// shortcut creation strings
const ICHAR szGptShortcutPrefix[] = TEXT("::{9db1186e-40df-11d1-aa8c-00c04fb67863}:");
const ICHAR szGptShortcutSuffix[] = TEXT("::");

// global strings for this file
const ICHAR szSessionManagerKey[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager");
const ICHAR szPendingFileRenameOperationsValue[] = TEXT("PendingFileRenameOperations");
const ICHAR szBackupFolder[] = TEXT("Config.Msi"); // not localized

// strings that define the data type of the value written by ProcessRegInfo
const ICHAR g_chTypeIncInteger = 'n';
const ICHAR g_szTypeIncInteger[] = TEXT("n");
const ICHAR g_chTypeInteger = 'i'; // integer
const ICHAR g_szTypeInteger[] = TEXT("i");
const ICHAR g_chTypeString = 's'; // string
const ICHAR g_szTypeString[] = TEXT("s");
const ICHAR g_chTypeExpandString = 'e';// expand string
const ICHAR g_szTypeExpandString[] = TEXT("e");
const ICHAR g_chTypeMultiSzStringPrefix = 'b';// multisz prefix
const ICHAR g_szTypeMultiSzStringPrefix[] = TEXT("b");
const ICHAR g_chTypeMultiSzStringSuffix = 'a';// multisz suffix
const ICHAR g_szTypeMultiSzStringSuffix[] = TEXT("a");
const ICHAR g_chTypeMultiSzStringDD = 'd';// multisz prefix DD - special logic to break out of removing if not last
const ICHAR g_szTypeMultiSzStringDD[] = TEXT("d");

void CreateCustomActionManager(bool fRemapHKCU);

//____________________________________________________________________________
//
// IMsiExecute factory implementation - all member data zeroed by new operator
//____________________________________________________________________________

extern Bool IsTerminalServerInstalled(); // from services.cpp

CMsiOpExecute::CMsiOpExecute(IMsiConfigurationManager& riConfigurationManager,
									  IMsiMessage& riMessage, IMsiDirectoryManager* piDirectoryManager,
									  Bool fRollbackEnabled, unsigned int fFlags, HKEY* phKey)
 : m_riServices(riConfigurationManager.GetServices()),
	m_riConfigurationManager(riConfigurationManager),m_piDirectoryManager(piDirectoryManager),
	m_pProgressRec(0),
	m_riMessage(riMessage), m_pConfirmCancelRec(0), m_iWriteFIFO(0),m_iReadFIFO(0),
	m_pRollbackAction(0), m_pCleanupAction(0),
	m_pCachePath(0), m_pActionThreadData(0), m_fFlags(fFlags),
	m_pEnvironmentWorkingPath95(0), m_pEnvironmentPath95(0),
	m_pDatabase(0), m_pFileCacheTable(0), m_pFileCacheCursor(0), m_fShellRefresh(fFalse),
	m_fEnvironmentRefresh(fFalse), m_pShellNotifyCacheTable(0), m_pShellNotifyCacheCursor(0),
	m_fSfpCancel(false), m_fRunScriptElevated(false), m_pAssemblyCacheTable(0), m_pAssemblyUninstallTable(0), m_iMaxNetSource(0), m_iMaxURLSource(0),
	m_fUserChangedDuringInstall(false), m_pUrlLocalCabinet(0), m_fRemapHKCU(true)
{
	m_fReverseADVTScript = m_fFlags & SCRIPTFLAGS_REVERSE_SCRIPT ? fTrue: fFalse; // flag to force the reversal of the script operations
	m_piProductInfo = &m_riServices.CreateRecord(0); // in case accessors called without ProductInfo record
	if(phKey && *phKey)
	{
		m_fKey = fFalse;
		m_hOLEKey = *phKey;
		m_hOLEKey64 = *phKey;
	}
	else
	{
		m_fKey = fTrue;
	}
	GetRollbackPolicy(m_irlRollbackLevel);
	if(fRollbackEnabled == fFalse)
		m_irlRollbackLevel = irlNone; // passed in value overrides policy
	m_cSuppressProgress = g_MessageContext.IsOEMInstall() ? 1 : 0; // for OEM installs we do not display progress

	m_hUserDataKey = 0;

	m_rgDisplayOnceMessages[0] = MAKELONG(0, imsgCannotUpdateProtectedFile);
	m_rgDisplayOnceMessages[1] = 0;

	// since there is no TS transaction window for advertise scripts, there is no point in doing any 
	// registry mapping work for per-machine advertisements on TS machines. If the script is being run
	// as part of an actual install, the header opcode contains the correct state.
}

CMsiOpExecute::~CMsiOpExecute()
{
	WaitForCustomActionThreads(0, fTrue, m_riMessage);
	IMsiRecord* piFileRec;
	while ((piFileRec = PullRecord()) != 0)
	{
		piFileRec->Release();
	}
}


// constructor used internally
CMsiExecute::CMsiExecute(IMsiConfigurationManager& riConfigurationManager, IMsiMessage& riMessage,
								 IMsiDirectoryManager* piDirectoryManager, Bool fRollbackEnabled, unsigned int fFlags, HKEY* phKey)
	: CMsiOpExecute(riConfigurationManager, riMessage, piDirectoryManager, fRollbackEnabled, fFlags, phKey)
	, m_iRefCnt(1)
{
	riConfigurationManager.AddRef();  // services addref by configmgr
	riMessage.AddRef();
	if(piDirectoryManager)
		piDirectoryManager->AddRef();
	m_pProgressRec = &m_riServices.CreateRecord(ProgressData::imdNextEnum);
	Assert(m_pProgressRec);
}


// factory called from OLE class factory, either client or standalone instance
IUnknown* CreateExecutor()
{
	PMsiMessage pMessage = (IMsiMessage*)ENG::CreateMessageHandler();
	PMsiConfigurationManager pConfigManager(ENG::CreateConfigurationManager());
	if (!pConfigManager)
		return 0;  // should happen only if out of memory
	return ENG::CreateExecutor(*pConfigManager, *pMessage, 0, fTrue);
}

IMsiExecute* CreateExecutor(IMsiConfigurationManager& riConfigurationManager, IMsiMessage& riMessage,
									 IMsiDirectoryManager* piDirectoryManager,
									 Bool fRollbackEnabled, unsigned int fFlags, HKEY* phKey)
{
	return new CMsiExecute(riConfigurationManager, riMessage, piDirectoryManager, fRollbackEnabled, fFlags, phKey);
}


inline CMsiExecute::~CMsiExecute()
{
	Assert(m_piProductInfo);
	m_piProductInfo->Release();

	if (m_pUrlLocalCabinet)
	{
		delete m_pUrlLocalCabinet;
		m_pUrlLocalCabinet = 0;
	}
	if(m_hKey)
		WIN::RegCloseKey(m_hKey);
	if(m_hKeyRm)
		WIN::RegCloseKey(m_hKeyRm);
	if(m_fKey)
	{
		if(m_hOLEKey)
			WIN::RegCloseKey(m_hOLEKey);
		if(m_hOLEKey64 && m_hOLEKey64 != m_hOLEKey)
			WIN::RegCloseKey(m_hOLEKey64);
	}
	if(m_hUserDataKey)
		WIN::RegCloseKey(m_hUserDataKey);
}

IMsiServices& CMsiExecute::GetServices()
//----------------------------------------------
{
	return (m_riServices.AddRef(), m_riServices);
}

//____________________________________________________________________________
//
// OpCode dispatch table - array of member function pointers
//____________________________________________________________________________

CMsiExecute::FOpExecute CMsiExecute::rgOpExecute[] =
{
#define MSIXO(op,type,args) ixf##op,
#include "opcodes.h"
};

int CMsiExecute::rgOpTypes[] =
{
#define MSIXO(op,type,args) type,
#include "opcodes.h"
};


//____________________________________________________________________________
//
// IMsiExecute virtual function implementation
//____________________________________________________________________________

HRESULT CMsiExecute::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiExecute))
		return (*ppvObj = (IMsiExecute*)this, AddRef(), NOERROR);
	else
		return (*ppvObj = 0, E_NOINTERFACE);
}

unsigned long CMsiExecute::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiExecute::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	for (int iRecord = 0; iRecord <= cMaxSharedRecord+1; iRecord++)
		if (m_rgpiSharedRecords[iRecord])
			m_rgpiSharedRecords[iRecord]->Release();

	m_riServices.Release();
	m_riMessage.Release();
	if(m_piDirectoryManager)
		m_piDirectoryManager->Release();
	
	PMsiConfigurationManager pConfigMgr(&m_riConfigurationManager);
	delete this;  // configmgr freed after memory released
	return 0;
}

#ifndef UNICODE
// construct the secure transform path
IMsiRecord* GetSecureTransformCachePath(IMsiServices& riServices, 
										const IMsiString& riProductKey, 
										IMsiPath*& rpiPath)
{
	IMsiRecord* piError = 0;

	// On Win9x the path is to %WINDOWS%\Installer\{ProductCode}\SecureTransforms

	MsiString strCachePath = GetMsiDirectory();
	Assert(strCachePath.TextSize());
	piError = riServices.CreatePath(strCachePath, rpiPath);
	if(!piError)
		piError = rpiPath->AppendPiece(riProductKey);
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(*DIR_SECURE_TRANSFORMS));
	return piError;
}
#endif

/*inline*/LONG GetPublishKey(iaaAppAssignment iaaAsgnType, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey)
{
	return GetPublishKeyByUser(NULL, iaaAsgnType, rhKey, rhOLEKey, rpiPublishSubKey, rpiPublishOLESubKey);
}

LONG GetPublishKeyByUser(const ICHAR* szUserSID, iaaAppAssignment iaaAsgnType, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey)
{
	MsiString strPublishSubKey;
	MsiString strPublishOLESubKey;
	MsiString strUserSID;

	if (g_fWin9X == false)
	{
		if (szUserSID)
		{
			strUserSID = szUserSID;
			AssertSz(iaaAsgnType != iaaUserAssign, TEXT("Attempted to get per-user non-managed publish key for another user. Not allowed due to roaming issues."));
		}
		else
		{
			DWORD dwError = GetCurrentUserStringSID(*&strUserSID);
			if (ERROR_SUCCESS != dwError)
				return dwError;
		}
	}

	if(iaaAsgnType == iaaMachineAssign || IsDarwinDescriptorSupported(iddOLE) == fFalse)
	{
		rhOLEKey = HKEY_LOCAL_MACHINE;
		strPublishOLESubKey = szClassInfoSubKey;
	}
	else
	{
		if (strUserSID.TextSize())
		{
			rhOLEKey = HKEY_USERS;
			strPublishOLESubKey = strUserSID + MsiString(TEXT("\\"));
		}
		else
		{
			rhOLEKey = HKEY_CURRENT_USER;
		}
		strPublishOLESubKey += szClassInfoSubKey;
	}
	
	switch(iaaAsgnType)
	{
	case iaaMachineAssign:
		rhKey = HKEY_LOCAL_MACHINE;
		strPublishSubKey = _szMachineSubKey;
		break;
	case iaaUserAssign:
		if(g_fWin9X)
			return ERROR_FILE_NOT_FOUND; //!! random error
		Assert(strUserSID.TextSize());
		rhKey = HKEY_LOCAL_MACHINE;
		strPublishSubKey = MsiString(MsiString(*_szManagedUserSubKey) + TEXT("\\")) + strUserSID;
		break;
	case iaaUserAssignNonManaged:
		if (strUserSID.TextSize())
		{
			rhKey = HKEY_USERS;
			strPublishSubKey = MsiString(strUserSID + TEXT("\\")) + MsiString(*_szNonManagedUserSubKey);
		}
		else
		{
			rhKey = HKEY_CURRENT_USER;
			strPublishSubKey = _szNonManagedUserSubKey;
		}
		break;
	default:
		Assert(0);
	}

	strPublishSubKey.ReturnArg(rpiPublishSubKey);
	strPublishOLESubKey.ReturnArg(rpiPublishOLESubKey);
	return ERROR_SUCCESS;
}


bool VerifyProduct(iaaAppAssignment iaaAsgnType, const ICHAR* szProductKey, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey)
{
	MsiString strPublishSubKey;
	MsiString strPublishOLESubKey;

	MsiString strProductKeySQUID = GetPackedGUID(szProductKey);

	CRegHandle HProductKey;
	DWORD dwRet = GetPublishKey(iaaAsgnType, rhKey, rhOLEKey, *&strPublishSubKey, *&strPublishOLESubKey);
	if (ERROR_SUCCESS != dwRet)
		return false;

	MsiString strSubKey = strPublishSubKey;
	strSubKey += TEXT("\\") _szGPTProductsKey TEXT("\\");
	strSubKey += strProductKeySQUID;

	dwRet = MsiRegOpen64bitKey(rhKey, strSubKey, 0, KEY_READ | (g_fWinNT64 ? KEY_WOW64_64KEY : 0), &HProductKey);
	if (ERROR_SUCCESS != dwRet)
		return false;

	if(!g_fWin9X && iaaAsgnType != iaaUserAssignNonManaged)
	{
		// get the owner
		bool fIsManaged = false;

		DWORD dwRet = FIsKeySystemOrAdminOwned(HProductKey, fIsManaged);
	
		if ((ERROR_SUCCESS != dwRet) || !fIsManaged)
			return false;
	}

	// get the assignment
	int iAssignment;
	DWORD dwType, dwSize = sizeof(iAssignment);
	dwRet = RegQueryValueEx(HProductKey,szAssignmentTypeValueName,
								  0,&dwType,(LPBYTE)&iAssignment,&dwSize);

	if (ERROR_SUCCESS != dwRet || (iAssignment != (iaaAsgnType == iaaMachineAssign ? 1:0)))
		return false;

	strPublishSubKey.ReturnArg(rpiPublishSubKey);
	strPublishOLESubKey.ReturnArg(rpiPublishOLESubKey);
	return true;        
}


//!! currently ConvertPathName expected to be called with "cpToLong" on Win2k only
//!! KERNEL32::GetLongPathName supported on Win2k and Win98 only
Bool ConvertPathName(const ICHAR* pszPathFormatIn, CTempBufferRef<ICHAR>& rgchPathFormatOut, cpConvertType cpTo)
{
	extern bool GetImpersonationFromPath(const ICHAR* szPath);
	CImpersonate impersonate((g_scServerContext == scService && GetImpersonationFromPath(pszPathFormatIn)) ? fTrue: fFalse); // impersonate, if accessing the net and are a service

	DWORD dwResult;
	if(cpTo == cpToShort)
		dwResult = WIN::GetShortPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
	else
		dwResult = KERNEL32::GetLongPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
	if(!dwResult)
	{
		return fFalse;
	}
	if(dwResult > rgchPathFormatOut.GetSize() - 1)
	{
		rgchPathFormatOut.SetSize(dwResult + 1);
		if(cpTo == cpToShort)
			dwResult = WIN::GetShortPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
		else
			dwResult = KERNEL32::GetLongPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
		if(!dwResult || dwResult > rgchPathFormatOut.GetSize() - 1)
		{
			Assert(0);
			return fFalse;
		}
	}
	return fTrue;
}

// DetermineLongFileNameOnly returns in rgchFileNameOut the LFN form of the file referenced by the full
// path input pszPathFormatIn. rgchFileNameOut does NOT include the path. Returns true on success. 
// The file must exist. The function will impersonate if necessary to access network shares. The function
// does NOT try to convert each segment of th path, and thus does NOT require list rights to any directory 
// in the tree above the file except the deepest. (This is in contrast to GetLongPathName, which converts 
// each segment and thus requires either explicit list right on each directory.)
bool DetermineLongFileNameOnly(const ICHAR* pszPathFormatIn, CTempBufferRef<ICHAR>& rgchFileNameOut)
{
	extern bool GetImpersonationFromPath(const ICHAR* szPath);

	// determine if impersonation is needed and impersonate if required
	CImpersonate impersonate((g_scServerContext == scService && GetImpersonationFromPath(pszPathFormatIn)) ? fTrue: fFalse); // impersonate, if accessing the net and are a service

	DWORD dwLength = 0;

	WIN32_FIND_DATA FindData;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	hFind = FindFirstFile(pszPathFormatIn, &FindData);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
		dwLength = IStrLen(FindData.cFileName);
		if (!dwLength)
			return false;
	}
	else
		return false;

	// if the provided input buffer is too small to hold the LFN, resize it.
	if(dwLength > rgchFileNameOut.GetSize() - 1)
	{
		// no error detection on resizing function, to detect failure, check that the pointer
		// is valid and that the size is what is expected.
		rgchFileNameOut.SetSize(dwLength + 1);
		if ((rgchFileNameOut.GetSize() != (dwLength+1)) || !static_cast<const ICHAR*>(rgchFileNameOut))
			return false;
	}
	// copy the long file name into the output buffer.
	return (IStrCopyLen(rgchFileNameOut, FindData.cFileName, rgchFileNameOut.GetSize()) != NULL);
}

const IMsiString& GetSFN(const IMsiString& riValue, IMsiRecord& riParams, int iBegin)
{
	CTempBuffer<ICHAR, 1> rgchOut(512);
	CTempBuffer<ICHAR, 1> rgchLFN(512);
	CTempBuffer<ICHAR, 1> rgchSFN(512);

	int cch = 0;
	int iStart = iBegin;
	while(!riParams.IsNull(iBegin))
	{
		// copy text between the sfns
		const ICHAR* psz = riValue.GetString();
		if(iBegin != iStart)
		{
			psz = psz + riParams.GetInteger(iBegin - 2) + riParams.GetInteger(iBegin - 1);
		}
		const ICHAR* pszBeginLFN = riValue.GetString() + riParams.GetInteger(iBegin);
		unsigned int cchLen = (unsigned int)(pszBeginLFN - psz);
		ResizeTempBuffer(rgchOut,  cchLen + cch);
		if ( ! (ICHAR *) rgchOut )
			return g_riMsiStringNull;
		memcpy(&rgchOut[cch], psz,cchLen * sizeof(ICHAR));
		cch += cchLen;

		// get the sfn string
		cchLen = riParams.GetInteger(iBegin + 1);
		rgchLFN.SetSize(cchLen + 1);
		if ( ! (ICHAR *) rgchLFN )
			return g_riMsiStringNull;
		memcpy((ICHAR* )rgchLFN, pszBeginLFN, cchLen * sizeof(ICHAR));
		rgchLFN[cchLen] = 0;

		if(ConvertPathName(rgchLFN, rgchSFN, cpToShort))
		{
			int cchSFNLen = IStrLen(rgchSFN);
			ResizeTempBuffer(rgchOut, cch + cchSFNLen);
			memcpy(&rgchOut[cch], rgchSFN,cchSFNLen * sizeof(ICHAR));
			cch += cchSFNLen;
		}
		else
		{
			//?? else use LFN
			ResizeTempBuffer(rgchOut, cch + cchLen);
			memcpy(&rgchOut[cch], rgchLFN,cchLen * sizeof(ICHAR));
			cch += cchLen;
		}
		iBegin += 2;
	}
	if(iBegin != iStart)
	{
		// copy text after the last sfn
		const ICHAR* psz = riValue.GetString() + riParams.GetInteger(iBegin - 2) + riParams.GetInteger(iBegin - 1);
		unsigned int cchLen = (unsigned int)((riValue.GetString() + riValue.TextSize()) - psz);
		ResizeTempBuffer(rgchOut,  cchLen + cch);
		memcpy(&rgchOut[cch], psz, cchLen * sizeof(ICHAR));
		cch += cchLen;
	}
	MsiString istrOut;
	// we take the perf hit on Win9X to be able to handle DBCS, on UNICODE -- fDBCS arg is ignored
	memcpy(istrOut.AllocateString(cch, /*fDBCS=*/fTrue), (ICHAR*) rgchOut, cch * sizeof(ICHAR));
	return istrOut.Return();
}

IMsiRecord* CMsiOpExecute::GetCachePath(IMsiPath*& rpiPath, const IMsiString** ppistrEncodedPath=0)
{
	IMsiRecord* piError = 0;

	// we place the Msi folder in the user's app data folder
	MsiString strCachePath;
	piError = GetShellFolder(CSIDL_APPDATA, *&strCachePath);
	if(!piError)
		piError = m_riServices.CreatePath(strCachePath,rpiPath);
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(TEXT("Microsoft")));
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(DIR_CACHE));
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(GetProductKey()));

	if (ppistrEncodedPath)
	{
		MsiString strPath = rpiPath->GetPath();
		strPath.Remove(iseFirst, strCachePath.CharacterCount());
		MsiString strEncodedPath = MsiChar(SHELLFOLDER_TOKEN);
		strEncodedPath += CSIDL_APPDATA;
		strEncodedPath += MsiChar(SHELLFOLDER_TOKEN);
		strEncodedPath += strPath;
		strEncodedPath.ReturnArg(*ppistrEncodedPath);
	}

	return piError;
}

void BuildFullRegKey(const HKEY hRoot, const ICHAR* rgchSubKey,
							const ibtBinaryType iType, const IMsiString*& strFullKey);

iesEnum CMsiOpExecute::EnsureClassesRootKeyRW()
{
	if(m_fKey)
	{
		DWORD lResult;

		if ( !m_hOLEKey )
		{
			REGSAM dwSam = KEY_READ| KEY_WRITE;
			if ( g_fWinNT64 )
				dwSam |= KEY_WOW64_32KEY;
			lResult = RegCreateKeyAPI(m_hPublishRootOLEKey, m_strPublishOLESubKey, 0, 0,
													0, dwSam, 0, &m_hOLEKey, 0);
			if(lResult != ERROR_SUCCESS)
			{
				MsiString strFullKey;
				BuildFullRegKey(m_hPublishRootOLEKey, m_strPublishOLESubKey, ibt32bit, *&strFullKey);
				PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *strFullKey, (int)lResult);
				return FatalError(*pError);
			}
		}
		if ( !m_hOLEKey64 )
		{
			if ( !g_fWinNT64 )
				m_hOLEKey64 = m_hOLEKey;
			else
			{
				lResult = RegCreateKeyAPI(m_hPublishRootOLEKey, m_strPublishOLESubKey, 0, 0,
														0, KEY_READ| KEY_WRITE | KEY_WOW64_64KEY, 0, &m_hOLEKey64, 0);
				if(lResult != ERROR_SUCCESS)
				{
					MsiString strFullKey;
					BuildFullRegKey(m_hPublishRootOLEKey, m_strPublishOLESubKey, ibt64bit, *&strFullKey);
					PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *strFullKey, (int)lResult);
					return FatalError(*pError);
				}
			}
		}
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::DoMachineVsUserInitialization()
{
	PMsiRecord pError(0);
	HRESULT lResult;
	// set the appropriate control flags for the execution of the script
	// where do we write our product information
	if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
	{
		// have we machine assigned before?
		m_fAssigned = VerifyProduct(iaaMachineAssign, MsiString(GetProductKey()), m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
		if(!m_fAssigned)
		{
			// are we app deploying or admin?
			//BUGBUG 9558: this check is bogus, as it doesn't allow non-localadmins to deploy an app via the MMC
			if((!IsImpersonating(true) || IsAdmin()) || ((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem()))
			{
				m_fAssigned = true;
				lResult = GetPublishKey(iaaMachineAssign, m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
				if (lResult != ERROR_SUCCESS)
					return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
			}
			else
			{
				// cannot machine assign
				DispatchError(imtError, Imsg(imsgInsufficientUserPrivileges));
				return iesFailure;
			}
		}
		else // m_fAssigned == true
		{
			if (m_istScriptType == istAdvertise)
			{
				if (m_fKey && !((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem()))
				{
					// cannot re-advertise an app unless either
					// 1) you've given an external reg key (deploying via MMC) OR
					// 2) you're app deployment (advertising during winlogon)

					DispatchError(imtError, Imsg(imsgInsufficientUserPrivileges));
					return iesFailure;
				}
			}
		}
	}
	else // user assignment
	{
		if (GetIntegerPolicyValue(szDisableUserInstallsValueName, fTrue))// policy set to ignore user installs 
		{
			DispatchError(imtError, Imsg(imsgUserInstallsDisabled));
			return iesFailure;
		}

		// have we user assigned (managed) before?
		m_fAssigned = VerifyProduct(iaaUserAssign, MsiString(GetProductKey()), m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);

		if(!m_fAssigned)
		{
			// are we app deploying?
			if((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem())
			{
				m_fAssigned = true;
				lResult = GetPublishKey(iaaUserAssign, m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
				if (lResult != ERROR_SUCCESS)
					return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
			}
			else
			{
				// have we user assigned (non-managed) before?
				if(!VerifyProduct(iaaUserAssignNonManaged, MsiString(GetProductKey()), m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey))
				{
					// open new non-managed app key
					lResult = GetPublishKey(iaaUserAssignNonManaged, m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
					if (lResult != ERROR_SUCCESS)
						return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
				}
			}
		}
		if(m_fAssigned)
		{
			if (m_istScriptType == istAdvertise)
			{
				if (m_fKey && !((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem()))
				{
					// cannot re-advertise an app unless either
					// 1) you've given an external reg key (deploying via MMC) OR
					// 2) you're app deployment (advertising during winlogon)
					DispatchError(imtError, Imsg(imsgInsufficientUserPrivileges));
					return iesFailure;
				}
			}

			// get the auxiliary keys to publish the roaming info
			HKEY hkeyTmp;
			MsiString strTmp;
			lResult = GetPublishKey(iaaUserAssignNonManaged, m_hPublishRootKeyRm, hkeyTmp, *&m_strPublishSubKeyRm, *&strTmp);
			if (lResult != ERROR_SUCCESS)
				return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
		}
	}

	m_fUserSpecificCache = true;

	if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
	{
		// we place the Installer folder below the Windows directory, in a per-product folder
		MsiString strCachePath = GetMsiDirectory();
		Assert(strCachePath.TextSize());
		pError = m_riServices.CreatePath(strCachePath,*&m_pCachePath);
		if(!pError)
			pError = m_pCachePath->AppendPiece(*MsiString(GetProductKey()));

		m_fUserSpecificCache = false;
	}
	else
	{
		// use the appdata folder
		pError = GetCachePath(*&m_pCachePath);
	}

	if(pError)
		return FatalError(*pError);
	if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we do darwin config data
	{
		if(m_hKey)
			WIN::RegCloseKey(m_hKey), m_hKey = 0; // close key, if not 0 - might get called twice if validating transform
		lResult = MsiRegCreate64bitKey(m_hPublishRootKey, m_strPublishSubKey, 0, 0,
												 0, KEY_READ| KEY_WRITE, 0, &m_hKey, 0);
		if(lResult != ERROR_SUCCESS)
		{
			PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *m_strPublishSubKey, lResult);
			return FatalError(*pError);
		}

		// if we are writing to assigned user, we also write to the roaming part
		if(m_fAssigned && !(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN))
		{
			if(m_hKeyRm)        
				WIN::RegCloseKey(m_hKeyRm), m_hKeyRm = 0; // close key, if not 0 - might get called twice if validating transform
			lResult = MsiRegCreate64bitKey(m_hPublishRootKeyRm, m_strPublishSubKeyRm, 0, 0,
													 0, KEY_READ| KEY_WRITE, 0, &m_hKeyRm, 0);
			if(lResult != ERROR_SUCCESS)
			{
				PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *m_strPublishSubKeyRm, lResult);
				return FatalError(*pError);
			}
		}
	}

	if(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO) // do we do app data
	{
		if(!m_fKey)// REGKEY - externally provided
		{
			Assert(m_irlRollbackLevel == irlNone); // should have been set this way in GetRollbackPolicy
		}
		else
		{
			if(m_hOLEKey)
				WIN::RegCloseKey(m_hOLEKey); // close key, if not 0 - might get called twice if validating transform
			if(m_hOLEKey64 && m_hOLEKey64 != m_hOLEKey)
				WIN::RegCloseKey(m_hOLEKey64); // close key, if not 0 - might get called twice if validating transform
			m_hOLEKey = m_hOLEKey64 = 0;
		}
	}

	return iesSuccess;
}

iesEnum CMsiExecute::GetTransformsList(IMsiRecord& riProductInfoParams, IMsiRecord& riProductPublishParams, const IMsiString*& rpiTransformsList)
{
	iesEnum iesRet = ixfProductInfo(riProductInfoParams);
	if (iesSuccess == iesRet)
	{
		iesRet = ProcessPublishProduct(riProductPublishParams, fFalse, &rpiTransformsList);
	}

	return iesRet;
}

IMsiStream* CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize);

iesEnum CMsiExecute::RunScript(const ICHAR* szScriptFile, bool fForceElevation)
{
	// fForceElevation means to elevate even if script header does not have Elevate attribute
	AssertSz(fForceElevation || IsImpersonating(), TEXT("Elevated at start of RunScript"));

	m_fRunScriptElevated = fForceElevation;  // may be set to true when reading script header below
	g_fRunScriptElevated = fForceElevation;

	iesEnum iesResult = iesSuccess;
	Assert(m_ixsState == ixsIdle);

	PMsiStream pStream(0);
	PMsiStream pRollbackStream(0);

	// Elevate this block... may not want to elevate when running the script
	{
		CElevate elevate;

		// open script
		PMsiRecord pError(0);
		pError = m_riServices.CreateFileStream(szScriptFile, fFalse, *&pStream);
		if (pError)
		{
			Message(imtError, *pError);
			return iesFailure;
		}

		// read script header
		PMsiRecord pParams(0);
		PMsiRecord pPrevParams(0);
		pParams = m_riServices.ReadScriptRecord(*pStream, *&pPrevParams, 0);
		if (!pParams) // file error or premature end of file
		{
			DispatchError(imtError, Imsg(idbgReadScriptRecord), *MsiString(szScriptFile));
			return iesFailure;
		}
		if((ixoEnum)pParams->GetInteger(0) != ixoHeader)
		{
			DispatchError(imtError, Imsg(idbgMissingScriptHeader), *MsiString(szScriptFile));
			return iesFailure;
		}

		pStream->Reset();
		pStream->Seek(pStream->Remaining() - sizeof(int));
		m_iProgressTotal = pStream->GetInt32();
		pStream->Reset();

		// check if this script version is supported
		m_iScriptVersion = pParams->GetInteger(IxoHeader::ScriptMajorVersion);
		m_iScriptVersionMinor = pParams->GetInteger(IxoHeader::ScriptMinorVersion);
		if(m_iScriptVersion == iMsiStringBadInteger)
			m_iScriptVersion = 0;
		if(m_iScriptVersion < iScriptVersionMinimum || m_iScriptVersion > iScriptVersionMaximum)
		{
			DispatchError(imtError, Imsg(idbgOpScriptVersionUnsupported), szScriptFile, m_iScriptVersion,
							  iScriptVersionMinimum, iScriptVersionMaximum);
			return (iesEnum)iesUnsupportedScriptVersion;
		}
		
		WORD iPackagePlatform = HIWORD((istEnum)pParams->GetInteger(IxoHeader::Platform));
		if (((iPackagePlatform == (WORD)PROCESSOR_ARCHITECTURE_IA64) ||
		     (iPackagePlatform == (WORD)PROCESSOR_ARCHITECTURE_AMD64)) && !g_fWinNT64 )
		{
			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SCRIPT_PLATFORM_UNSUPPORTED, szScriptFile);
			DispatchError(imtEnum(imtError), Imsg(idbgScriptPlatformUnsupported), *MsiString(szScriptFile));
			return iesFailure;
		}
	
		m_istScriptType = (istEnum)pParams->GetInteger(IxoHeader::ScriptType);

		if(!pParams->IsNull(IxoHeader::ScriptAttributes))
		{
			isaEnum isaScriptAttributes = (isaEnum)pParams->GetInteger(IxoHeader::ScriptAttributes);
			if(isaScriptAttributes & isaElevate)
			{
				m_fRunScriptElevated = true;
				g_fRunScriptElevated = true;
			}
		
			// if the script is marked with the TS registry attribute, remap the appropriate HKCU
			// key and initialize the CA servers. Do NOT respect this attribute if the script is
			// called via the advertise API (told not to respect script settings).
			if (MinimumPlatformWindows2000() && IsTerminalServerInstalled() && (m_fFlags & SCRIPTFLAGS_MACHINEASSIGN_SCRIPTSETTINGS))
			{
				m_fRemapHKCU = (isaScriptAttributes & isaUseTSRegistry) ? false : true;
				PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/!m_fRemapHKCU);
			}
		}

		MsiString strRollbackScriptFullPath, strRollbackScriptName;
		PMsiPath pRollbackScriptDir(0);
		// create rollback script if rollback enabled
		if(m_irlRollbackLevel != irlNone && m_istScriptType != istRollback)
		{
			// create secured rollback script
			if((iesResult = GenerateRollbackScriptName(*&pRollbackScriptDir, *&strRollbackScriptName)) != iesSuccess)
				return iesResult;
			if((pError = pRollbackScriptDir->GetFullFilePath(strRollbackScriptName,*&strRollbackScriptFullPath)) != 0)
			{
				Message(imtError, *pError);
				return iesFailure;
			}

			pError = m_riServices.CreateFileStream(strRollbackScriptFullPath,fTrue, *&pRollbackStream);
			if (pError)
			{
				Message(imtError, *pError);
				return iesFailure;
			}

			DWORD isaRollbackScriptAttributes = 0;
			// if we are elevating for this script, then we should elevate for the rollback as well
			if(m_fRunScriptElevated)
				isaRollbackScriptAttributes = isaElevate;
			
			// if using the TS registry propagation system for this script, must also use it for
			// rollback
			if (!m_fRemapHKCU)
				isaRollbackScriptAttributes |= isaUseTSRegistry;
				
			m_pRollbackScript = new CScriptGenerate(*pRollbackStream,
													pParams->GetInteger(IxoHeader::LangId),
													GetCurrentDateTime(),
													istRollback, static_cast<isaEnum>(isaRollbackScriptAttributes),
													m_riServices);
			if (!m_pRollbackScript)
			{
				DispatchError(imtError, Imsg(idbgInitializeRollbackScript),*strRollbackScriptFullPath);
				return iesFailure;
			}


			// package platform for rollback script same as for install script
			while (m_pRollbackScript->InitializeScript(iPackagePlatform) == false)
			{
				if (PostScriptWriteError(m_riMessage) == fFalse)
					return iesFailure;
			}

			// register rollback script - if we should abort abnormally, rollback script will be registered
			// to undo changes made up to that point
			AssertRecord(m_riConfigurationManager.RegisterRollbackScript(strRollbackScriptFullPath));
		}
	}

	// elevate if necessary for this script execution
	CElevate elevate(m_fRunScriptElevated);

	// run script
	switch (m_istScriptType)
	{
	case istAdvertise:
	case istInstall:
	case istPostAdminInstall:
	case istAdminInstall:
		m_ixsState = ixsRunning;
		iesResult = RunInstallScript(*pStream, szScriptFile);
		// if we are successful, do the commiting of the assemblies
		if(iesResult == iesSuccess || iesResult == iesNoAction || iesResult == iesFinished)
			iesResult = CommitAssemblies();
		m_ixsState = ixsIdle;
		break;
	case istRollback:
	{
		// disable cancel button on dialog
		PMsiRecord pControlMessage = &m_riServices.CreateRecord(2);
		AssertNonZero(pControlMessage->SetInteger(1,(int)icmtCancelShow));
		AssertNonZero(pControlMessage->SetInteger(2,(int)fFalse));
		Message(imtCommonData, *pControlMessage);

		m_ixsState = ixsRollback;
		
		// drop the ShellNotifyCache deferral tables
		m_pShellNotifyCacheTable = 0;
		m_pShellNotifyCacheCursor = 0;

		iesResult = RunRollbackScript(*pStream, szScriptFile);

		// if we are successful, do the commiting of the assemblies
		if(iesResult == iesSuccess || iesResult == iesNoAction || iesResult == iesFinished)
			iesResult = CommitAssemblies();
		m_ixsState = ixsIdle;

		// re-enable cancel button on dialog
		AssertNonZero(pControlMessage->SetInteger(2,(int)fTrue));
		Message(imtCommonData, *pControlMessage);
		break;
	}
	default:
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfHeader"),
						  (int)IxoHeader::ScriptType);
		iesResult = iesFailure;
		break;
	};

	if(m_pRollbackScript)
	{
		delete m_pRollbackScript; // release hold of script
		m_pRollbackScript = 0;

		pRollbackStream = 0; // release
	}

	ClearExecutorData();
	
	Bool fReboot = m_fRebootReplace;
	m_fRebootReplace = fFalse;
	if(iesResult == iesSuccess || iesResult == iesNoAction || iesResult == iesFinished)
	{
		PMsiRecord pParams = &m_riServices.CreateRecord(istcfSHChangeNotify);
		AssertNonZero(pParams->SetInteger(1, istcSHChangeNotify));
		if(m_fShellRefresh)
		{
			ShellNotifyProcessDeferred();
			AssertNonZero(pParams->SetInteger(2, SHCNE_ASSOCCHANGED)); // per reinerf in NT to refresh associations
			AssertNonZero(pParams->SetInteger(3, SHCNF_DWORD));
			AssertNonZero(pParams->SetString(4, 0));
			AssertNonZero(pParams->SetString(5, 0));
			Message(imtCustomServiceToClient, *pParams); // SHChangeNotify is of void type, so it's OK to ignore return
		}

		if(m_fFontRefresh)
			WIN::PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0); // font change notification

		if (m_fEnvironmentRefresh && !g_fWin9X && !fReboot)
		{
			// environment variables
			ULONG_PTR dwResult = 0;

			// Notifies top level windows that an environment setting has changed.  This gives the shell
			// the opportunity to spawn new command shells with correct settings, for example.  Without this,
			// the changes do not take affect until a reboot.

			MsiDisableTimeout();
			// this call may pause an amount of time (see call in milliseconds), per top level window.
			// This normally shouldn't happen, unless someone isn't pumping their messages.
			AssertNonZero(WIN::SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM) TEXT("Environment"), SMTO_ABORTIFHUNG, 5*1000, &dwResult));
			MsiEnableTimeout();
		}

		// Let the start menu and ARP know that something's changed. If we're uninstalling completely
		// then we pass SCHNEE_MSI_UNINSTALL so they don't have to query the state of every feature

		if ( !g_fWin9X && g_iMajorVersion >= 5 )
		{
			//  eugend: NT5 specific, fix to bug # 5296.
			//  updated for bug 9404 so the shell can actually handle it
			MsiString strProdKey(GetProductKey());
			if ( strProdKey.CharacterCount() <= 38 )
			{
				SHChangeProductKeyAsIDList pkidl;
				memset(&pkidl, 0, sizeof(pkidl));
				pkidl.cb = sizeof(pkidl) - sizeof(pkidl.cbZero);
				StringCbCopy((ICHAR*) pkidl.wszProductKey, sizeof(pkidl.wszProductKey), (const ICHAR*)strProdKey);

				SHChangeDWORDAsIDList dwidl;
				memset(&dwidl, 0, sizeof(dwidl));
				dwidl.cb = sizeof(dwidl) - sizeof(dwidl.cbZero);
				dwidl.dwItem1 = m_fStartMenuUninstallRefresh ?
					  SHCNEE_MSI_UNINSTALL : SHCNEE_MSI_CHANGE;

				PMsiStream pFirstStream = CreateStreamOnMemory((const char*)&pkidl, sizeof(pkidl));
				PMsiStream pSecondStream = CreateStreamOnMemory((const char*)&dwidl, sizeof(dwidl));
				
				AssertNonZero(pParams->SetInteger(2, SHCNE_EXTENDED_EVENT));
				AssertNonZero(pParams->SetInteger(3, 0));
				AssertNonZero(pParams->SetMsiData(4, pFirstStream));
				AssertNonZero(pParams->SetMsiData(5, pSecondStream));
				Message(imtCustomServiceToClient, *pParams); // SHChangeNotify is of void type, so it's OK to ignore return
			}
		}
		if(fReboot)
			iesResult = iesSuspend;
	}	
	return iesResult;
}


iesEnum CMsiExecute::CommitAssemblies()
{
	// we commit the assemblies we are installing
	if(m_pAssemblyCacheTable)
	{
		PMsiCursor pCacheCursor = m_pAssemblyCacheTable->CreateCursor(fFalse);
		while(pCacheCursor->Next())
		{
			PAssemblyCacheItem pASM = static_cast<IAssemblyCacheItem*>(CMsiDataWrapper::GetWrappedObject(PMsiData(pCacheCursor->GetMsiData(m_colAssemblyMappingASM))));
			if(pASM) 
			{
				//we made a new copy of the assembly
				// check if the assembly already exists
				bool fInstalled = false;
				PMsiRecord pRecErr = IsAssemblyInstalled(	*MsiString(pCacheCursor->GetString(m_colAssemblyUninstallComponentId)), 
															*MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), 
															(iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyMappingAssemblyType), 
															fInstalled, 
															0, 
															0);
				if (pRecErr)
					return FatalError(*pRecErr);

				HRESULT hr = pASM->Commit(fInstalled ? IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH : 0, NULL);
				if(!SUCCEEDED(hr))
				{
						return FatalError(*PMsiRecord(PostAssemblyError(MsiString(pCacheCursor->GetString(m_colAssemblyMappingComponentId)), hr, TEXT("IAssemblyCacheItem"), TEXT("Commit"), MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), (iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyMappingAssemblyType))));
				}
			}
			// else do nothing, the assembly is already present in the GAC
		}
	}

	// we also uninstall any assemblies that we are unregistering, if there are no clients
	if(m_pAssemblyUninstallTable)
	{
		PMsiCursor pCacheCursor = m_pAssemblyUninstallTable->CreateCursor(fFalse);
		while(pCacheCursor->Next())
		{
			MsiString strComponentId = pCacheCursor->GetString(m_colAssemblyUninstallComponentId);

			// check if there are any other clients of this assembly that we know of
			// the same assembly may be published under some other componentid
			// following MsiProvideAssemblyCall will catch all instances
			iatAssemblyType iat = (iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyUninstallAssemblyType);
			DWORD dwAssemblyInfo = (iatWin32Assembly == iat) ? MSIASSEMBLYINFO_WIN32ASSEMBLY : MSIASSEMBLYINFO_NETASSEMBLY;
			DWORD dwRet = MsiProvideAssemblyW(CApiConvertString(MsiString(pCacheCursor->GetString(m_colAssemblyUninstallAssemblyName))), 0, INSTALLMODE_NODETECTION_ANY, dwAssemblyInfo, 0, 0);
			if((ERROR_UNKNOWN_COMPONENT == dwRet) || (ERROR_INDEX_ABSENT == dwRet))
			{
				// no more clients, need to Uninstall as far as WI is concerned
				// make backup of the installed assembly so that we can put the assembly back, if need be, during rollback
				iesEnum iesRet = BackupAssembly(*strComponentId, *MsiString(pCacheCursor->GetString(m_colAssemblyUninstallAssemblyName)), iat);
				if(iesRet != iesSuccess)
					return iesRet;
				PMsiRecord pRecErr = UninstallAssembly(*strComponentId, *MsiString(pCacheCursor->GetString(m_colAssemblyUninstallAssemblyName)), iat);
				//we dont treat uninstalls as errors, simply log
				if(pRecErr)
					Message(imtInfo,*pRecErr);
			}//else do nothing, there are other clients for this assembly, they must simply be under another componentid
		}
	}
	return iesSuccess;
}

void CMsiExecute::ClearExecutorData()
{
	if (m_strEnvironmentWorkingFile95.TextSize())
	{
		RemoveFile(*m_pEnvironmentWorkingPath95, *m_strEnvironmentWorkingFile95, fFalse,/*fBypassSFC*/ false, false);
		m_pEnvironmentWorkingPath95 = 0;
		m_strEnvironmentWorkingFile95 = MsiString(TEXT(""));
	}

	IMsiRecord* piRec = m_piProductInfo;
	while(piRec)
	{
#ifdef _WIN64       // !merced
		IMsiRecord *piRecHold = !piRec->IsNull(0) ? (IMsiRecord*)piRec->GetHandle(0) : 0;
#else
		IMsiRecord *piRecHold = !piRec->IsNull(0) ? (IMsiRecord*)piRec->GetInteger(0) : 0;
#endif

		piRec->Release();
		piRec = piRecHold;
	}

	m_piProductInfo = &m_riServices.CreateRecord(0);
}

#define DEBUGMSGIXO(ixo,rec) if (FDiagnosticModeSet(dmDebugOutput|dmLogging)) DebugDumpIxo(ixo,rec)

extern const ICHAR* rgszixo[];

void DebugDumpIxo(ixoEnum ixo, IMsiRecord& riRecord)
{
	Assert(riRecord.GetInteger(0) == ixo);
	riRecord.SetString(0, rgszixo[ixo]);
	int iSwappedField1, iSwappedField2;
	iSwappedField1 = iSwappedField2 = 0;
	switch (ixo)
	{
	case ixoServiceInstall:
		iSwappedField1 = IxoServiceInstall::Password;
		break;
	case ixoCustomActionSchedule:
	case ixoCustomActionCommit:
	case ixoCustomActionRollback:
		if ( (riRecord.GetInteger(IxoCustomActionSchedule::ActionType) & msidbCustomActionTypeHideTarget) == msidbCustomActionTypeHideTarget )
		{
			iSwappedField1 = IxoCustomActionSchedule::Target;
			iSwappedField2 = IxoCustomActionSchedule::CustomActionData;
		}
		break;
	};
	MsiString strSwappedValue1;
	MsiString strSwappedValue2;
	if ( iSwappedField1 && riRecord.GetFieldCount() >= iSwappedField1 )
	{
		strSwappedValue1 = riRecord.GetMsiString(iSwappedField1);
		AssertNonZero(riRecord.SetString(iSwappedField1, IPROPVALUE_HIDDEN_PROPERTY));
	}
	else
		iSwappedField1 = 0;

	if ( iSwappedField2 && riRecord.GetFieldCount() >= iSwappedField2 )
	{
		strSwappedValue2 = riRecord.GetMsiString(iSwappedField2);
		AssertNonZero(riRecord.SetString(iSwappedField2, IPROPVALUE_HIDDEN_PROPERTY));
	}
	else
		iSwappedField2 = 0;
	
	MsiString strArgs = riRecord.FormatText(fFalse);
	DEBUGMSG1(TEXT("Executing op: %s"), (const ICHAR*)strArgs);
	riRecord.SetInteger(0, ixo);
	if ( iSwappedField1 )
		AssertNonZero(riRecord.SetMsiString(iSwappedField1, *strSwappedValue1));
	if ( iSwappedField2 )
		AssertNonZero(riRecord.SetMsiString(iSwappedField2, *strSwappedValue2));
}

iesEnum CMsiExecute::RunInstallScript(IMsiStream& riScript, const ICHAR* szScriptFile)
{
	PMsiRecord pParams(0);
	Assert(m_ixsState == ixsRunning);
	iesEnum iesResult = iesNoAction;
	int cRecords = 0;
#ifdef DEBUG
	ixoEnum ixoLastOpCode = ixoNoop;
#endif
	IMsiRecord *piPrevRecord = 0;

	do
	{
		pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			DispatchError(imtError, Imsg(idbgReadScriptRecord), *MsiString(szScriptFile));
			iesResult = iesFailure;
			break;
		}
		ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
		if (cRecords++ == 0 && ixoOpCode != ixoHeader)
		{
			DispatchError(imtError, Imsg(idbgMissingScriptHeader), *MsiString(szScriptFile));
			iesResult = iesFailure;
			break;
		}
		DEBUGMSGIXO(ixoOpCode, *pParams);

		iesResult = (this->*rgOpExecute[ixoOpCode])(*pParams);

		if(iesResult == iesErrorIgnored)
			iesResult = iesSuccess; // non-fatal error occurred - continue running script
		
		if(m_fCancel && (iesResult == iesNoAction || iesResult == iesSuccess))
		{
			AssertSz(0,"Didn't catch cancel message in RunInstallScript");
			iesResult = iesUserExit;
		}

	} while (iesResult == iesSuccess || iesResult == iesNoAction); // end record processing loop

	if (piPrevRecord != 0)
		piPrevRecord->Release();
	return iesResult;
}

void AddOpToList(int& cOpCount, CTempBufferRef<int>& rgBuff, int cbOffset)
{
	cOpCount++;
	if(cOpCount > rgBuff.GetSize())
		rgBuff.Resize(rgBuff.GetSize()*2);
	rgBuff[cOpCount-1] = cbOffset;
}

iesEnum CMsiExecute::RunRollbackScript(IMsiStream& riScript, const ICHAR* /*szScriptFile*/)
{
	Assert(m_ixsState == ixsRollback);

	// populate 3 buffers with init, update and finalize ops
	int cUpdateOps = 0, cInitOps = 0, cFinalizeOps = 0, cFirstUpdateOps = 0, cLastUpdateOps = 0;
	CTempBuffer<int, 1> rgUpdateOps(500);
	memset((void*)(int*)rgUpdateOps,0,sizeof(int)*(rgUpdateOps.GetSize()));
	CTempBuffer<int, 10> rgInitOps;
	memset((void*)(int*)rgInitOps,0,sizeof(int)*(rgInitOps.GetSize()));
	CTempBuffer<int, 1> rgFinalizeOps;
	memset((void*)(int*)rgFinalizeOps,0,sizeof(int)*(rgFinalizeOps.GetSize()));
	CTempBuffer<int, 50> rgFirstUpdateOps;
	memset((void*)(int*)rgFirstUpdateOps,0,sizeof(int)*(rgFirstUpdateOps.GetSize()));
	CTempBuffer<int, 50> rgLastUpdateOps;
	memset((void*)(int*)rgLastUpdateOps,0,sizeof(int)*(rgLastUpdateOps.GetSize()));
	
	CTempBuffer<int, ixoOpCodeCount> rgStateOps; // cache for state ops that must be moved
	memset((void*)(int*)rgStateOps,0,sizeof(int)*(rgStateOps.GetSize()));

	ixoEnum ixoOpCode = ixoNoop;
	PMsiRecord pParams(0);
	IMsiRecord* piPrevRecord = 0;
	riScript.Reset();
	Bool fFirstUpdateOpAdded = fFalse, fLastUpdateOpAdded = fFalse;
	int i;
	//!! logic below does not guarantee ixoProductInfo will be executed right away - it could be after some
	//!! other state operations - is this a problem?
	while(ixoOpCode != ixoEnd)
	{
		int cbOffset = riScript.GetIntegerValue() - riScript.Remaining();
		pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			// we make no assumptions that a rollback file is a valid script file
			// (e.g. that it ends with a complete record or with an ixoEnd operation)
			// if we can't read a script record, assume it is the end of the script
			
			// set ixoOpCode to ixoEnd to force flushing of cached ops
			ixoOpCode = ixoEnd;
		}
		else
			ixoOpCode = (ixoEnum)pParams->GetInteger(0);

		switch (rgOpTypes[(int)ixoOpCode])
		{
		case XOT_INIT:
			AddOpToList(cInitOps,rgInitOps,cbOffset);
			break;
		case XOT_FINALIZE:
			// flush state ops cache, ActionStart last
			for(i=0;i<ixoOpCodeCount;i++)
			{
				if((i != (int)ixoActionStart) && rgStateOps[i] != 0)
				{
					AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[i]-1);
					if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[i]-1);
					if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[i]-1);
					rgStateOps[i] = 0;
				}
			}
			if(rgStateOps[(int)ixoActionStart] != 0)
			{
				AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[(int)ixoActionStart]-1);
				if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[(int)ixoActionStart]-1);
				if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[(int)ixoActionStart]-1);
				rgStateOps[(int)ixoActionStart] = 0;
			}

			if(pParams) // we read an actual finalization op, not just eof and flushing ops
				AddOpToList(cFinalizeOps,rgFinalizeOps,cbOffset);
			break;
		case XOT_STATE:
		case XOT_GLOBALSTATE:
			if(ixoOpCode == ixoActionStart)
			{
				// special case - need to flush all cached state ops - ActionStart last
				for(i=0;i<ixoOpCodeCount;i++)
				{
					if((i != (int)ixoActionStart) && rgStateOps[i] != 0 && rgOpTypes[i] != XOT_GLOBALSTATE)
					{
						AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[i]-1);
						if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[i]-1);
						if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[i]-1);
						rgStateOps[i] = 0;
					}
				}
			}
			// flush previous cached op, if there is one
			if(rgStateOps[(int)ixoOpCode] != 0)
			{
				AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[(int)ixoOpCode]-1);
				if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[(int)ixoOpCode]-1);
				if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[(int)ixoOpCode]-1);
			}
			// cache this op
			rgStateOps[(int)ixoOpCode] = cbOffset + 1; // add 1 to prevent 0 offset
			if(ixoOpCode == ixoActionStart)
			{
				fFirstUpdateOpAdded = fFalse;
				fLastUpdateOpAdded = fFalse;
			}
			break;

		case XOT_UPDATEFIRST:
			fFirstUpdateOpAdded = fTrue;
			AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,cbOffset);
			break;
		case XOT_UPDATELAST:
			fLastUpdateOpAdded = fTrue;
			AddOpToList(cLastUpdateOps,rgLastUpdateOps,cbOffset);
			break;
		case XOT_COMMIT:
			break; // commit opcodes don't run during rollback
		default: // XOT_UPDATE, XOT_MSG, XOT_ADVT
			AddOpToList(cUpdateOps,rgUpdateOps,cbOffset);
			break;
		};
	}
	riScript.Reset();
	iesEnum iesReturn = iesNoAction;
	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}

#ifdef DEBUG
//  PMsiStream pTempStream(0);
//  AssertZero(m_riServices.CreateFileStream("c:\\winnt\\msi\\rollback.scr",fTrue, *&pTempStream));
//  CScriptGenerate sgTempScript(*pTempStream,0,istRollback, m_riServices);
#endif

	// run script
	// execute initialization ops
	for(i=0; i<cInitOps; i++)
	{
		riScript.Seek(rgInitOps[i]);
		PMsiRecord pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			Assert(0); // this should never happen - we have already read through the entire script above
		}
		else
		{
			ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
			DEBUGMSGIXO(ixoOpCode,*pParams);
			iesReturn = (this->*rgOpExecute[ixoOpCode])(*pParams);

			if(iesReturn == iesErrorIgnored)
				iesReturn = iesSuccess; // non-fatal error occurred - continue running script
		
			if (iesReturn != iesSuccess && iesReturn != iesNoAction)
			{
				// Bug #6500 - No failures in rollback - just keep on going.
				DEBUGMSG1(TEXT("Error in rollback skipped.  Return: %d"), (const ICHAR*)(INT_PTR) iesReturn);
			}
		}
	}

	// setup progress - don't call through Message, which suppresses progress during rollback
	// action start 
	if(!m_pRollbackAction)
		m_pRollbackAction = &m_riServices.CreateRecord(3);
	AssertZero(m_riMessage.Message(imtActionStart, *m_pRollbackAction) == imsCancel);

	// progress
	PMsiRecord pProgress = &m_riServices.CreateRecord(ProgressData::imdNextEnum);
	AssertNonZero(pProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscMasterReset));
	AssertNonZero(pProgress->SetInteger(ProgressData::imdProgressTotal,cUpdateOps+cFirstUpdateOps+cLastUpdateOps));
	AssertNonZero(pProgress->SetInteger(ProgressData::imdDirection,ProgressData::ipdBackward));
	AssertNonZero(pProgress->SetInteger(ProgressData::imdEventType,ProgressData::ietTimeRemaining));
	AssertZero((m_riMessage.Message(imtProgress, *pProgress)) == imsCancel);

	// action data
	PMsiRecord pActionData = &m_riServices.CreateRecord(1);
	
	for(int j=0; j<3; j++)
	{
		// execute first update, update, and last update operations, in that order
		int* rgOps = 0;
		int cOps = 0;
		switch(j)
		{
		case 0:
			rgOps = rgFirstUpdateOps; cOps = cFirstUpdateOps; break;
		case 1:
			rgOps = rgUpdateOps; cOps = cUpdateOps; break;
		case 2:
			rgOps = rgLastUpdateOps; cOps = cLastUpdateOps; break;
		default:
			Assert(0);
		};

		if (piPrevRecord != 0)
		{
			piPrevRecord->Release();
			piPrevRecord = 0;
		}

		if ( ! rgOps )
			return iesFailure;

		for(i=cOps-1; i>=0; i--)
		{
			riScript.Seek(rgOps[i]);
			PMsiRecord pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
#ifdef DEBUG
//          Assert(pParams);
//          ixoEnum ixoTemp = (ixoEnum)pParams->GetInteger(0);
//          AssertNonZero(sgTempScript.WriteRecord((ixoEnum)pParams->GetInteger(0),pParams));
#endif
			if (!pParams) // file error or premature end of file
			{
				Assert(0); // this should never happen since we have already read through the entire script
							  // above
			}
			else
			{
				ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
				if(ixoOpCode == ixoActionStart)
				{
					// setup and send ActionData record
					MsiString strActionDescription = pParams->GetMsiString(IxoActionStart::Description);
					if(strActionDescription.TextSize() == 0)
						strActionDescription = pParams->GetMsiString(IxoActionStart::Name);

					AssertNonZero(pActionData->SetMsiString(1, *strActionDescription));
					AssertZero((m_riMessage.Message(imtActionData, *pActionData)) == imsCancel);
				}
				// dispatch progress
				AssertNonZero(pProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscProgressReport));
				AssertNonZero(pProgress->SetInteger(ProgressData::imdIncrement, 1));
				AssertZero((m_riMessage.Message(imtProgress, *pProgress)) == imsCancel);

				// execute op
				DEBUGMSGIXO(ixoOpCode,*pParams);
				iesReturn = (this->*rgOpExecute[ixoOpCode])(*pParams);

				if(iesReturn == iesErrorIgnored)
					iesReturn = iesSuccess; // non-fatal error occurred - continue running script
		
				if (iesReturn != iesSuccess && iesReturn != iesNoAction)
				{
					// Bug #6500 - No failures in rollback - just keep on going.
					DEBUGMSG1(TEXT("Error in rollback skipped.  Return: %d"), (const ICHAR*)(INT_PTR) iesReturn);
				}
			}
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	// execute finalization ops
	for(i=0; i<cFinalizeOps; i++)
	{
		riScript.Seek(rgFinalizeOps[i]);
		PMsiRecord pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			Assert(0); // this should never happen - we have already read through the entire script above
		}
		else
		{
			ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
			DEBUGMSGIXO(ixoOpCode,*pParams);
			iesReturn = (this->*rgOpExecute[ixoOpCode])(*pParams);

			if(iesReturn == iesErrorIgnored)
				iesReturn = iesSuccess; // non-fatal error occurred - continue running script
		
			if (iesReturn != iesSuccess && iesReturn != iesNoAction)
			{
				// Bug #6500 - No failures in rollback - just keep on going.
				DEBUGMSG1(TEXT("Error in rollback skipped.  Return: %d"), (const ICHAR*)(INT_PTR) iesReturn);
			}
		}
	}
	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	return iesReturn;
}

iesEnum CMsiExecute::GenerateRollbackScriptName(IMsiPath*& rpiPath, const IMsiString*& rpistr)
{
	CElevate elevate; // use high privileges for this function

	PMsiRecord pRecErr(0);
	iesEnum iesRet;
	PMsiPath pBackupFolder(0);
	PMsiPath pMsiFolder(0);
	MsiString strFile;

	if((iesRet = GetBackupFolder(0,*&pBackupFolder)) != iesSuccess)
		return iesRet;

	if((pRecErr = pBackupFolder->TempFileName(0,szRollbackScriptExt,fTrue, *&strFile, &CSecurityDescription(true, false))) != 0)
		return FatalError(*pRecErr);
	rpiPath = pBackupFolder;
	rpiPath->AddRef();
	strFile.ReturnArg(rpistr);
	return iesSuccess;
}

struct RBSInfo
{
	const IMsiString* pistrRollbackScript;
	MsiDate date;
	RBSInfo* pNext;

	RBSInfo(const IMsiString& ristr, MsiDate d);
	~RBSInfo();
};

RBSInfo::RBSInfo(const IMsiString& ristr, MsiDate d) : pistrRollbackScript(&ristr), date(d)
{
	pistrRollbackScript->AddRef();
}

RBSInfo::~RBSInfo()
{
	pistrRollbackScript->Release();
}

IMsiRecord* CMsiExecute::GetSortedRollbackScriptList(MsiDate date, Bool fAfter, RBSInfo*& rpListHead)
{
	PEnumMsiString pScriptEnum(0);
	PMsiRecord pError(0);
	if((pError = m_riConfigurationManager.GetRollbackScriptEnumerator(date,fAfter,*&pScriptEnum)) != 0)
		return pError;
      
	// place dates and scripts into a linked list - sort as we go
	rpListHead = 0;
	MsiString strRBSInfo;
	while((pScriptEnum->Next(1, &strRBSInfo, 0)) == S_OK)
	{
		MsiDate dScriptDate = (MsiDate)(int)MsiString(strRBSInfo.Extract(iseUpto, '#'));
		MsiString strScriptFile = strRBSInfo;
		strScriptFile.Remove(iseIncluding, '#');
		RBSInfo* pNewNode = new RBSInfo(*strScriptFile, dScriptDate);
		if ( ! pNewNode )
			return PostError(Imsg(idbgInitializeRollbackScript), *strScriptFile );
		
		RBSInfo* pTemp = 0;
		
		// place in linked list
		if(!rpListHead ||
			(fAfter ? ((int)rpListHead->date < (int)dScriptDate) : ((int)rpListHead->date > (int)dScriptDate)))
		{
			// need to place at start of list
			pTemp = rpListHead;
			rpListHead = pNewNode;
			pNewNode->pNext = pTemp;
		}
		else
		{
			for(RBSInfo* p = rpListHead;
				 p->pNext && (fAfter ? ((int)(p->pNext->date) > (int)dScriptDate) : ((int)(p->pNext->date) < (int)dScriptDate));
				 p = p->pNext);
			// place after node pointed to by p
			pTemp = p->pNext;
			p->pNext = pNewNode;
			pNewNode->pNext = pTemp;
		}
		
#ifdef DEBUG
		for(RBSInfo* pt = rpListHead;pt;pt=pt->pNext)
		{
		}
#endif

	}
	return 0;
}

void CMsiExecute::DeleteRollbackScriptList(RBSInfo* pListHead)
{
	for(RBSInfo* p = pListHead; p;)
	{
		RBSInfo* pTemp = p->pNext;
		delete p;
		p = pTemp;
	}
}

iesEnum CMsiExecute::RollbackFinalize(iesEnum iesState, MsiDate date, bool fUserChangedDuringInstall)
{
	enum iefrtEnum
	{
		iefrtNothing, // save rollback files if they exist
		iefrtRollback, // rollback to date
		iefrtPurge, // remove all rollback files to current date
	};
	
	iefrtEnum iefrt = iefrtNothing;
	
	Bool fRollbackScriptsDisabled = fFalse;
	PMsiRecord pError = m_riConfigurationManager.RollbackScriptsDisabled(fRollbackScriptsDisabled);
	if(pError)
		return FatalError(*pError);

	if(fRollbackScriptsDisabled)
		iesState = iesSuccess; // force cleanup - not rollback
	
	switch(iesState)
	{
	// success
	case iesSuccess:
	case iesFinished:
	case iesNoAction:
		if(m_irlRollbackLevel == irlRollbackNoSave)
			iefrt = iefrtPurge;
		else
			iefrt = iefrtNothing;
		break;
	
	// suspend
	case iesSuspend:
		iefrt = iefrtNothing;
		break;

	// failure
	default: // iesWrongState, iesBadActionData, iesInstallRunning
		Assert(0); // fall through
	case iesUserExit:
	case iesFailure:
		if(m_irlRollbackLevel == irlNone)
			iefrt = iefrtNothing;
		else
			iefrt = iefrtRollback;
		break;
	};

	iesEnum iesRet = iesSuccess;
	if(iefrt == iefrtPurge)
	{
		// purge rollback files to now

		// disable cancel button on dialog
		PMsiRecord pControlMessage = &m_riServices.CreateRecord(2);
		AssertNonZero(pControlMessage->SetInteger(1,(int)icmtCancelShow));
		AssertNonZero(pControlMessage->SetInteger(2,(int)fFalse));
		Message(imtCommonData, *pControlMessage);
		
		iesRet = RemoveRollbackFiles(ENG::GetCurrentDateTime());

		// re-enable cancel button on dialog
		AssertNonZero(pControlMessage->SetInteger(2,(int)fTrue));
		Message(imtCommonData, *pControlMessage);

		if (iesRet == iesFailure && fRollbackScriptsDisabled == fFalse) //!! which errors should force rollback? only Commit errors?
			iefrt = iefrtRollback;  // commit failed, force rollback
	}
	if(iefrt == iefrtRollback)
	{
		// rollback to date
		//FUTURE: we should disable the cancel button here, instead of around the running of each
		// rollback script
		iesRet = Rollback(date, fUserChangedDuringInstall);
	}

	if(fRollbackScriptsDisabled)
	{
		AssertRecord(m_riConfigurationManager.DisableRollbackScripts(fFalse)); // re-enable rollback scripts
	}
	
	return iesRet;
}

void CMsiOpExecute::GetRollbackPolicy(irlEnum& irlLevel)
{
	irlLevel = irlNone;

	if(!m_fKey)
	{
		// we were passed in an external hKey, rollback is disabled
		return;
	}

	// check registry for level of rollback support
	if(GetIntegerPolicyValue(szDisableRollbackValueName, fFalse) == 1 ||
	   GetIntegerPolicyValue(szDisableRollbackValueName, fTrue) == 1)
		irlLevel = irlNone;
	else
		irlLevel = irlRollbackNoSave;
}

iesEnum CMsiExecute::Rollback(MsiDate date, bool fUserChangedDuringInstall)
{
	RBSInfo* pListHead = 0;
	PMsiRecord pError = 0;
	
	if((pError = GetSortedRollbackScriptList(date,fTrue,pListHead)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	
	// run rollback scripts
	iesEnum iesRet = iesSuccess; //?? Is this initialization correct?
	Bool fReboot = fFalse;
	m_fUserChangedDuringInstall = fUserChangedDuringInstall;
	MsiString strRollbackScriptFullPath, strRollbackScriptName;
	PMsiPath pRollbackScriptPath(0);
	for(RBSInfo* p = pListHead; p; p=p->pNext)
	{
		Assert(p->pistrRollbackScript);
		strRollbackScriptFullPath = *(p->pistrRollbackScript);
		p->pistrRollbackScript->AddRef();

		// unregister rollback script
		pError = m_riConfigurationManager.UnregisterRollbackScript(strRollbackScriptFullPath); // ignore failure
		
		pError = m_riServices.CreateFilePath(strRollbackScriptFullPath,*&pRollbackScriptPath,*&strRollbackScriptName);
		if(pError)
		{
			// invalid path syntax, continue without error
			AssertRecordNR(pError);
			Message(imtInfo,*pError);
			continue;
		}
		
		iesRet = RunScript(strRollbackScriptFullPath, false);
		if (iesRet == iesFailure)
		{
			pError = PostError(Imsg(imsgRollbackScriptError));
			Message(imtError, *pError);
			iesRet = iesSuccess;
		}

		if(iesRet == iesUnsupportedScriptVersion)
			iesRet = iesFailure;
		
		if(iesRet == iesSuspend)
			fReboot = fTrue;

		if(iesRet != iesSuccess && iesRet != iesFinished && iesRet != iesNoAction && iesRet != iesSuspend) // failure
			continue; // continue without error

		// remove rollback script
		{
			CElevate elevate;
			RemoveFile(*pRollbackScriptPath,*strRollbackScriptName,fFalse,/*fBypassSFC*/ false,false); // ignore failure
		}
	}
	m_fUserChangedDuringInstall = false;

	DeleteRollbackScriptList(pListHead);

	if(fReboot)
		return iesSuspend;
	return iesRet;
}

iesEnum CMsiExecute::RemoveRollbackFiles(MsiDate date)
{
	Assert(m_ixsState == ixsIdle);
	
	RBSInfo* pListHead = 0;
	PMsiRecord pError = 0;
	
	Bool fAfter = fFalse;
	if((int)date == 0)
		fAfter = fTrue; // remove all rollback files - after 0
	if((pError = GetSortedRollbackScriptList(date,fAfter,pListHead)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	
	// run rollback scripts
	iesEnum iesRet = iesSuccess;
	for(RBSInfo* p = pListHead; p; p=p->pNext)
	{
		Assert(p->pistrRollbackScript);
		m_ixsState = ixsCommit;
		iesRet = RemoveRollbackScriptAndBackupFiles(*(p->pistrRollbackScript));
		m_ixsState = ixsIdle;
		if(iesRet != iesSuccess && iesRet != iesFinished && iesRet != iesNoAction)
			break;
		// unregister rollback script
		if((pError = m_riConfigurationManager.UnregisterRollbackScript(p->pistrRollbackScript->GetString())) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	DeleteRollbackScriptList(pListHead);

	return iesRet;
}
	
iesEnum CMsiExecute::RemoveRollbackScriptAndBackupFiles(const IMsiString& ristrScriptFile)
{
	int cBackupFiles = 0;
	CTempBuffer<int, 1> rgBackupFileOps(500);
	int cCommitOps = 0;
	CTempBuffer<int, 20>  rgCommitOps;
	memset((void*)(int*)rgBackupFileOps,0,sizeof(int)*(rgBackupFileOps.GetSize()));
	
	// open script
	PMsiRecord pError(0);
	PMsiStream pStream(0);
	
	{
		CElevate elevate; // elevate to read rollback script
		pError = m_riServices.CreateFileStream(ristrScriptFile.GetString(), fFalse, *&pStream);
	}
	
	if (pError)
	{
		// rollback script is missing or invalid, log warning and continue without failure
		Message(imtInfo, *pError);
		return iesSuccess;
	}

	// script is not elevated unless the header of the script is marked with isaElevate
	m_fRunScriptElevated = false;
	g_fRunScriptElevated = false;

	Assert(pStream);
	PMsiRecord pParams(0);
	iesEnum iesResult = iesNoAction;
	int cRecords = 0;
	ixoEnum ixoOpCode = ixoNoop;
	MsiString strPath, strFileName;
	PMsiPath pPath(0);
	IMsiRecord* piPrevRecord = 0;
	
	while(ixoOpCode != ixoEnd)
	{
		int cbOffset = pStream->GetIntegerValue() - pStream->Remaining();
		pParams = m_riServices.ReadScriptRecord(*pStream, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			// we make no assumptions that a rollback file is a valid script file
			// (e.g. that it ends with a complete record or with an ixoEnd operation)
			// if we can't read a script record, assume it is the end of the script
			break;
		}
		ixoOpCode = (ixoEnum)pParams->GetInteger(0);
		if (ixoOpCode == ixoHeader)
		{
			// determine if this script should run elevated
			if(!pParams->IsNull(IxoHeader::ScriptAttributes))
			{
				DWORD isaScriptAttributes = pParams->GetInteger(IxoHeader::ScriptAttributes);
				if(isaScriptAttributes & isaElevate)
				{
					m_fRunScriptElevated = true;
					g_fRunScriptElevated = true;
				}

				// if the script is marked with the TS registry attribute, remap the appropriate HKCU
				// key and initialize the CA servers. Always respect rollback/commit script attributes.
				if (MinimumPlatformWindows2000() && IsTerminalServerInstalled())
				{
					m_fRemapHKCU = (isaScriptAttributes & isaUseTSRegistry) ? false : true;
					PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/!m_fRemapHKCU);
				}
			}
		}
		if (rgOpTypes[(int)ixoOpCode] == XOT_COMMIT)
		{
			AddOpToList(cCommitOps,rgCommitOps,cbOffset);
		}
		if(ixoOpCode == ixoRollbackInfo)
		{
			ixfRollbackInfo(*pParams); // set m_pCleanupAction
		}
		if(ixoOpCode == ixoRegisterBackupFile)
		{
			AddOpToList(cBackupFiles,rgBackupFileOps,cbOffset);
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	pStream->Reset();

	// setup progress - don't call through Message, which suppresses progress during rollback
	// action start 
	if(!m_pCleanupAction)
		m_pCleanupAction = &m_riServices.CreateRecord(3);
	AssertZero((m_riMessage.Message(imtActionStart, *m_pCleanupAction)) == imsCancel);

	{
		// elevate if necessary for this script execution
		CElevate elevate(m_fRunScriptElevated);
	
		// commit ops, if any returns failure then force rollback
		for(int iOp=0; iOp < cCommitOps; iOp++)
		{
			pStream->Seek(rgCommitOps[iOp]);
			pParams = m_riServices.ReadScriptRecord(*pStream, *&piPrevRecord, m_iScriptVersion);
			if (!pParams) // file error or premature end of file
			{
				Assert(0); // this should never happen - we have already read through the entire script above
				if (piPrevRecord != 0)
					piPrevRecord->Release();
				return iesFailure;
			}
			ixoOpCode = (ixoEnum)pParams->GetInteger(0);
			iesResult = (this->*rgOpExecute[ixoOpCode])(*pParams);
	
			if(iesResult == iesErrorIgnored)
				iesResult = iesSuccess; // non-fatal error occurred - continue running script
			
			if (iesResult == iesFailure)  //!! what should kill the install at this point?
			{
				if (piPrevRecord != 0)
					piPrevRecord->Release();
				return iesResult;
			}
			//!! would like progress here? but how to do it? by op count?
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	// progress
	using namespace ProgressData;
	PMsiRecord pProgress = &m_riServices.CreateRecord(ProgressData::imdNextEnum);
	AssertNonZero(pProgress->SetInteger(imdSubclass, iscMasterReset));
	AssertNonZero(pProgress->SetInteger(imdProgressTotal,cBackupFiles));
	AssertNonZero(pProgress->SetInteger(imdDirection,ipdForward));
	AssertNonZero(pProgress->SetInteger(imdEventType,ietTimeRemaining));
	AssertZero((m_riMessage.Message(imtProgress,*pProgress)) == imsCancel);

	// action data
	PMsiRecord pActionData = &m_riServices.CreateRecord(1);

	// remove backup files
	for(int i=0; i<cBackupFiles; i++)
	{
		pStream->Seek(rgBackupFileOps[i]);
		pParams = m_riServices.ReadScriptRecord(*pStream, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			Assert(0); // this should never happen - we have already read through the entire script above
			// we make no assumptions that a rollback file is a valid script file
			// (e.g. that it ends with a complete record or with an ixoEnd operation)
			// if we can't read a script record, assume it is the end of the script
			break;
		}
		Assert((ixoEnum)pParams->GetInteger(0) == ixoRegisterBackupFile);
		strPath = pParams->GetMsiString(IxoRegisterBackupFile::File);

		// dispatch progress
		AssertNonZero(pActionData->SetMsiString(1,*strPath));
		AssertZero((m_riMessage.Message(imtActionData, *pActionData)) == imsCancel);
		AssertNonZero(pProgress->SetInteger(imdSubclass,iscProgressReport));
		AssertNonZero(pProgress->SetInteger(imdIncrement,1));
		AssertZero((m_riMessage.Message(imtProgress, *pProgress)) == imsCancel);

		if((pError = m_riServices.CreateFilePath(strPath, *&pPath, *&strFileName)) != 0)
		{
			AssertRecordNR(pError);
			Message(imtInfo, *pError);
		}
		else
		{
			CElevate elevate; // elevate to remove rollback files
			
			RemoveFile(*pPath, *strFileName, fFalse/*no rollback*/,/*fBypassSFC*/ false,false); // Ignore error
			RemoveFolder(*pPath); // Nothing we can do if it fails, so ignore error
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	// remove rollback script
	pStream = 0; // release
	
	if((pError = m_riServices.CreateFilePath(ristrScriptFile.GetString(),*&pPath,*&strFileName)) != 0)
	{
		AssertRecordNR(pError);
		Message(imtInfo, *pError);
	}
	else
	{
		CElevate elevate; // elevate to remove rollback script
		RemoveFile(*pPath,*strFileName,fFalse,/*fBypassSFC*/ false,false); //!! suppress error dialogs?
	}
	return iesSuccess;
}


iesEnum CMsiOpExecute::ixfDisableRollback(IMsiRecord& riParams)
{
	// disable rollback for remainder of script and remainder of install
	using namespace IxoDisableRollback;

	if(!RollbackRecord(Op,riParams))
		return iesFailure;

	Assert(m_ixsState != ixsRollback); // shouldn't be running a rollback script that contains this op
	Assert(m_pRollbackScript); // shouldn't have this op if rollback was disabled already

	if(m_pRollbackScript)
	{
		// close rollback script - will prevent future rollback processing
		delete m_pRollbackScript;
		m_pRollbackScript = 0;
	}
	
	m_irlRollbackLevel = irlNone;

	PMsiRecord pError = m_riConfigurationManager.DisableRollbackScripts(fTrue);
	if(pError)
		return FatalError(*pError);

	return iesSuccess;
}

IMsiRecord* CMsiOpExecute::SetSecureACL(IMsiPath& riPath, bool fHidden)
{
	// locks down a folder, but only when we don't own it already.
	// Note that locking down a folder does not necessarily protect the files within.
	// See LockdownPath to secure our configuration files.

	DWORD dwError = 0;
	char* rgchSD;
	if (ERROR_SUCCESS != (dwError = ::GetSecureSecurityDescriptor(&rgchSD, /*fAllowDelete*/fTrue, fHidden)))
		return PostError(Imsg(idbgOpSecureSecurityDescriptor), dwError);

	Bool fSetACL = fTrue;

	// an initial guess at the size of the descriptor.
	// This is slightly larger than machines I've tried this on.
	CTempBuffer<char, 1> rgchFileSD(3072);
	DWORD cLengthSD = 3072;

	BOOL fRet = ADVAPI32::GetFileSecurity((const ICHAR*)MsiString(riPath.GetPath()), DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
		(PSECURITY_DESCRIPTOR) rgchFileSD, cLengthSD, &cLengthSD);

	if (!fRet)
	{
		DWORD dwLastError = WIN::GetLastError();
		if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
		{
			rgchFileSD.SetSize(cLengthSD);
			fRet = ADVAPI32::GetFileSecurity((const ICHAR*)MsiString(riPath.GetPath()), DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
				(PSECURITY_DESCRIPTOR) rgchFileSD, cLengthSD, &cLengthSD);
			dwLastError = WIN::GetLastError();
		}
		else fRet = FALSE;

		if (!fRet)
			return PostError(Imsg(imsgGetFileSecurity), dwLastError, MsiString(riPath.GetPath()));
	}

	// Check the current SD on the file; don't bother setting our SD if we already own object
	if (FIsSecurityDescriptorSystemOrAdminOwned(rgchFileSD))
	{
		fSetACL = fFalse;
	}

	CRefCountedTokenPrivileges(itkpSD_WRITE, fSetACL);
	if (fSetACL && !WIN::SetFileSecurity(MsiString(riPath.GetPath()),
		  DACL_SECURITY_INFORMATION|OWNER_SECURITY_INFORMATION, (char*)rgchSD))
		return PostError(Imsg(imsgOpSetFileSecurity), GetLastError(), MsiString(riPath.GetPath()));

	return 0;
}


iesEnum CMsiOpExecute::GetBackupFolder(IMsiPath* piRootPath, IMsiPath*& rpiFolder)
{
	//!! TODO: fairly expensive function that is called quite a bit
	//!! TODO: cache backup folder when determined and compare volumes in next call
	
	CElevate elevate; // use high privileges for this function

	PMsiRecord pRecErr(0);
	rpiFolder = 0;
	Bool fMakeHidden = fTrue;
	PMsiPath pPath(0);

	PMsiPath pRootPath(0);

	// if piRootPath not specific, use drive holding our temp directory
	if(piRootPath == 0)
	{
		MsiString strMsiDir = ENG::GetTempDirectory();
		if((pRecErr = m_riServices.CreatePath(strMsiDir,*&pRootPath)) != 0)
			return FatalError(*pRecErr);
	}
	else
	{
		pRootPath = piRootPath;
		piRootPath->AddRef();
	}
	
	// use riPath - first, check if "Config.Msi" folder on volume is writable,
	PMsiVolume pVolume(&(pRootPath->GetVolume()));
	idtEnum idtType = pVolume->DriveType();

	AssertRecord(m_riServices.CreatePath(MsiString(pVolume->GetPath()),
													 *&pPath));
	AssertRecord(pPath->AppendPiece(*MsiString(szBackupFolder)));
	Bool fWritable = fFalse;

	// We should only secure the config.msi directory.
	Bool fSecurable = fFalse;

	// Also, on a remote drive, don't try creating the config.msi directory.
	if((pRecErr = pPath->Writable(fWritable)) != 0 || fWritable == fFalse || idtRemote == idtType)
	{
		// try path itself -- this is a user owned directory, so be careful with its
		// permission settings or deleting extra stuff.
		if((pRecErr = pRootPath->Writable(fWritable)) != 0 || fWritable == fFalse)
		{
			// error
			DispatchError(imtError,Imsg(imsgDirectoryNotWritable),
							  *MsiString(pRootPath->GetPath()));
			return iesFailure;
		}
		else
		{
			rpiFolder = pRootPath;
			rpiFolder->AddRef();
		}
	}
	else
	{
		fSecurable = fTrue;
		rpiFolder = pPath;
		rpiFolder->AddRef();
	}

	Bool fExists;
	if((pRecErr = rpiFolder->Exists(fExists)) != 0)
	{
		rpiFolder->Release();
		rpiFolder = 0;
		return FatalError(*pRecErr);
	}
	if(fExists)
	{
		if (RunningAsLocalSystem())
		{
			if (fSecurable && (pRecErr = SetSecureACL(*rpiFolder, /*fHidden=*/true)) != 0)
				return FatalError(*pRecErr);
		}
		return iesSuccess;
	}
	iesEnum iesRet;

	PMsiStream pSecurityDescriptorStream(0);
	if (RunningAsLocalSystem())
	{
		if (fSecurable && (pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptorStream, /*fHidden=*/true)) != 0)
			return FatalError(*pRecErr);
	}

	if((iesRet = CreateFolder(*rpiFolder, fFalse, fFalse, pSecurityDescriptorStream)) != iesSuccess)
	{
		rpiFolder->Release();
		rpiFolder = 0;
		return iesRet;
	}

	if(fMakeHidden)
	{
		// set folder attributes
		AssertRecord(rpiFolder->SetAllFileAttributes(0,FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM));
	}
	return iesSuccess;
}

iesEnum CMsiExecute::ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	if ((unsigned)ixoOpCode >= ixoOpCodeCount)
		return iesNoAction;

	return (this->*rgOpExecute[ixoOpCode])(riParams);
}

IMsiRecord* CMsiExecute::EnumerateScript(const ICHAR* szScriptFile, IEnumMsiRecord*& rpiEnumerator)
{
	return ::CreateScriptEnumerator(szScriptFile, m_riServices, rpiEnumerator);
}

const IMsiString& ComposeDescriptor(const IMsiString& riProductCode, const IMsiString& riFeature, const IMsiString& riComponent, bool fComClassicInteropForAssembly)
{
	int cchFeatureLen = riFeature.TextSize();
	int cchComponentLen = riComponent.TextSize();

	if(!cchFeatureLen || !cchComponentLen)
		return g_MsiStringNull; // empty string

	int cchLen = IStrLen(riComponent.GetString());
	MsiString strMsiDesc;
	int iOptimization = 0;
	if(cchComponentLen != cchLen) // multi_sz
	{
		iOptimization = MsiString(*(riComponent.GetString() + cchLen + 1));
	}

	if(iOptimization & ofSingleComponent)
	{
		cchComponentLen = 0; // can skip the component
	}
	else
	{
		// feature has multiple components, need to use compressed guid
		cchComponentLen = cchComponentIdCompressed;
	}
	if(iOptimization & ofSingleFeature)
	{
		cchFeatureLen = 0; // can skip the feature
	}

	// no expectation of DBCS characters (Feature names follow identifier rules, GUID is hex)
	ICHAR* szBuf = strMsiDesc.AllocateString((fComClassicInteropForAssembly ? 1 : 0) /* for chGUIDCOMToCOMPlusInteropToken */ + (cchProductCodeCompressed + cchFeatureLen + cchComponentLen + 1/* for the chGUIDAbsentToken OR the chComponentGUIDSeparatorToken*/), /*fDBCS=*/fFalse);
	if(fComClassicInteropForAssembly)
	{
		szBuf[0] = chGUIDCOMToCOMPlusInteropToken;
		szBuf++;
	}
	if(!PackGUID(riProductCode.GetString(), szBuf, ipgCompressed)) // product code
	{
		return g_MsiStringNull; // empty string
	}

	if(cchFeatureLen)
	{
		memcpy(szBuf + cchProductCodeCompressed, riFeature.GetString(), cchFeatureLen* sizeof(ICHAR)); // feature
	}
	if(cchComponentLen)
	{
		// feature has multiple components, need to use compressed guid
		szBuf[cchProductCodeCompressed + cchFeatureLen] = chComponentGUIDSeparatorToken;
		AssertNonZero(PackGUID(riComponent.GetString(), szBuf + cchProductCodeCompressed + cchFeatureLen + 1, ipgCompressed)); // component id
	}
	else
	{
		szBuf[cchProductCodeCompressed + cchFeatureLen] = chGUIDAbsentToken;
		szBuf[cchProductCodeCompressed + cchFeatureLen + 1] = 0;
	}
	return strMsiDesc.Return();
}

// this function may also be used in case we have a darwin descriptor referring to an alien product (for rollback)
// here the feature string is empty
const IMsiString& CMsiOpExecute::ComposeDescriptor(const IMsiString& riFeature, const IMsiString& riComponent, bool fComClassicInteropForAssembly)
{
	return ::ComposeDescriptor(*MsiString(GetProductKey()), riFeature, riComponent, fComClassicInteropForAssembly);
}


IMsiRecord* CMsiOpExecute::GetShellFolder(int iFolderId, const IMsiString*& rpistrLocation)
{
	// we have a shell folder id
	// we may need to translate the folderid from personal to all users
	// OR vice versa depending on the SCRIPTFLAGS_MACHINEASSIGN flag

	// ALLUSER shell folders dont exist on Win9X so  always use personal folders
	const ShellFolder* pShellFolder = 0;
	if(!g_fWin9X && (m_fFlags & SCRIPTFLAGS_MACHINEASSIGN))
	{
		pShellFolder = rgPersonalProfileShellFolders;
	}
	else
	{
		pShellFolder = rgAllUsersProfileShellFolders;
	}
	for (; pShellFolder->iFolderId >= 0; pShellFolder++)
	{
		if(iFolderId == pShellFolder->iFolderId)
		{
			iFolderId = pShellFolder->iAlternateFolderId;
			break;
		}
	}
	return m_riServices.GetShellFolderPath(iFolderId, !g_fWin9X && (m_fFlags & SCRIPTFLAGS_MACHINEASSIGN), rpistrLocation);
}

//____________________________________________________________________________
//
// EnumerateScript implementation - enumerates operation records without execution
//____________________________________________________________________________

class CEnumScriptRecord : public IEnumMsiRecord
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall Next(unsigned long cFetch, IMsiRecord** rgpi, unsigned long* pcFetched);
	HRESULT __stdcall Skip(unsigned long cSkip);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumMsiRecord** ppiEnum);
 public: // constructor
	CEnumScriptRecord(IMsiServices& riServices, IMsiStream& riStream);
 protected:
  ~CEnumScriptRecord(); // protected to prevent creation on stack
	unsigned long    m_iRefCnt;      // reference count
	IMsiStream&      m_riScript;     // ref count transferred at construction
	IMsiServices&    m_riServices;   // owns a ref count to prevent destruction
	IMsiRecord*      m_piPrevRecord;
	int              m_iScriptVersion;
};

CEnumScriptRecord::CEnumScriptRecord(IMsiServices& riServices, IMsiStream& riStream)
 : m_riScript(riStream),
	m_riServices(riServices),
	m_piPrevRecord(0),
	m_iScriptVersion(0),
	m_iRefCnt(1)
{
	riServices.AddRef();  // riStream already refcnt'd by creator
}

CEnumScriptRecord::~CEnumScriptRecord()
{
	if (m_piPrevRecord != 0)
		m_piPrevRecord->Release();
}

HRESULT CEnumScriptRecord::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumMsiRecord)
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumScriptRecord::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumScriptRecord::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	PMsiServices pServices(&m_riServices); // release after delete
	m_riScript.Release();
	delete this;
	return 0;
}

HRESULT CEnumScriptRecord::Next(unsigned long cFetch, IMsiRecord** rgpi, unsigned long* pcFetched)
{
	unsigned long cFetched = 0;

	if (rgpi)
	{
		while (cFetched < cFetch)
		{
			IMsiRecord* piRecord = m_riServices.ReadScriptRecord(m_riScript, *&m_piPrevRecord, m_iScriptVersion);
			if (!piRecord)     // end of file or error
				break;
			if (piRecord->GetInteger(0) == ixoHeader)
			{
				m_iScriptVersion = piRecord->GetInteger(IxoHeader::ScriptMajorVersion);
			}
			*rgpi = piRecord;  // transfers refcnt
			rgpi++;
			cFetched++;
		}
	}
	if (pcFetched)
		*pcFetched = cFetched;
	return (cFetched == cFetch ? S_OK : S_FALSE);
}

HRESULT CEnumScriptRecord::Skip(unsigned long cSkip)
{
	while (cSkip--)
	{
		IMsiRecord* piRecord = m_riServices.ReadScriptRecord(m_riScript, *&m_piPrevRecord, m_iScriptVersion);
		if (!piRecord)
			return S_FALSE;
		if (piRecord->GetInteger(0) == ixoHeader)
		{
			m_iScriptVersion = piRecord->GetInteger(IxoHeader::ScriptMajorVersion);
		}
		piRecord->Release();
	}
	return S_OK;
}

HRESULT CEnumScriptRecord::Reset()
{
	m_riScript.Reset();
	return S_OK;
}

HRESULT CEnumScriptRecord::Clone(IEnumMsiRecord** /*ppiEnum*/)
{
	return E_NOTIMPL; // need to implement Clone on underlying stream first
}

IMsiRecord* CreateScriptEnumerator(const ICHAR* szScriptFile, IMsiServices& riServices, IEnumMsiRecord*& rpiEnum)
{
	IMsiStream* piStream;
	IMsiRecord* piError = riServices.CreateFileStream(szScriptFile, fFalse, piStream);
	if (piError)
		return piError;
	rpiEnum = new CEnumScriptRecord(riServices, *piStream);
	return 0;
}


//____________________________________________________________________________
//
// IMsiOpExecute helper functions
//____________________________________________________________________________

// GetSharedRecord: returns one of cached records - caller should not hold reference to record
IMsiRecord& CMsiOpExecute::GetSharedRecord(int cParams)
{
	int iRecord = cParams;  // index into record cache
	if (cParams > cMaxSharedRecord)
	{
		iRecord = cMaxSharedRecord + 1;  // overflow record
		if (m_rgpiSharedRecords[cMaxSharedRecord+1])
		{
			if (m_rgpiSharedRecords[cMaxSharedRecord+1]->GetFieldCount() != cParams)
			{
				m_rgpiSharedRecords[cMaxSharedRecord+1]->Release();
				m_rgpiSharedRecords[cMaxSharedRecord+1] = 0;
			}
		}
	}
	if (!m_rgpiSharedRecords[iRecord])
		m_rgpiSharedRecords[iRecord] = &m_riServices.CreateRecord(cParams);

	if(m_rgpiSharedRecords[iRecord]->ClearData() == fFalse)
	{
		// failed to clear record, probably because something else is holding a reference
		// need to release this record and create a new one
		m_rgpiSharedRecords[iRecord]->Release();
		m_rgpiSharedRecords[iRecord] = &m_riServices.CreateRecord(cParams);
	}
	return *m_rgpiSharedRecords[iRecord];
}

imsEnum CMsiOpExecute::Message(imtEnum imt, IMsiRecord& riRecord)
{

	if(m_cSuppressProgress > 0 && (imt == imtActionData || imt == imtProgress))
		return imsNone;

	if (m_ixsState == ixsRollback || m_ixsState == ixsCommit)
	{


		// suppress progress messages if running rollback script - progress handles externally
		if (imt == imtActionStart || imt == imtActionData || imt == imtProgress)
			return imsNone;

		// Bug #6500:  Suppress any error messages during rollback.
		int imsg = (unsigned)(imt & ~iInternalFlags) >> imtShiftCount;
		switch (imsg)
		{
			case imtInfo        >> imtShiftCount: 
			case imtWarning        >> imtShiftCount:
			case imtError          >> imtShiftCount:
			case imtUser           >> imtShiftCount:
			case imtFatalExit      >> imtShiftCount:
			case imtOutOfDiskSpace >> imtShiftCount:
				imt = imtInfo;
				break;
			default:
				break;
		}

	}

	imsEnum ims = m_riMessage.Message(imt, riRecord);
	if(ims == imsCancel && (m_ixsState != ixsRollback))
		m_fCancel = fTrue;
	return ims;
}

bool ShouldGoToEventLog(imtEnum imtArg);

imsEnum CMsiOpExecute::DispatchMessage(imtEnum imt, IMsiRecord& riRecord, Bool fConfirmCancel)
{
	int i;
	bool fFound;
	int iError;
	for ( i = 0, fFound = false, iError = riRecord.GetInteger(1);
			m_rgDisplayOnceMessages[i] && !fFound; i++ )
	{
		if ( HIWORD(m_rgDisplayOnceMessages[i]) == iError )
		{
			fFound = true;
			if ( !LOWORD(m_rgDisplayOnceMessages[i]) )
				// it's OK to display the message this time and I signal that
				// it had been displayed.
				m_rgDisplayOnceMessages[i] |= MAKELONG(1, 0);
			else
				// the message had already been displayed, I make it go into the log
				// and possibly into the eventlog.
				imt = (imtEnum)((ShouldGoToEventLog(imt) ? imtSendToEventLog : 0) | imtInfo);
		}
	}

	MsiString strError = riRecord.GetMsiString(0);
	for(;;)
	{
		imsEnum ims = Message(imt, riRecord);
		if(fConfirmCancel && (ims == imsAbort || ims == imsCancel))
		{
			if(!m_pConfirmCancelRec)
			{
				m_pConfirmCancelRec = &m_riServices.CreateRecord(1);
			}
			ISetErrorCode(m_pConfirmCancelRec, Imsg(imsgConfirmCancel)); // have to do this each time
			switch(Message(imtEnum(imtUser+imtYesNo+imtDefault2), *m_pConfirmCancelRec))
			{
			case imsNo:
				AssertNonZero(riRecord.SetMsiString(0,*strError)); // set error string and number again, since Message always
																				  // pre-pends "Error [1]. " to the message string
				m_fCancel = fFalse; // it was set by Message
				continue;
			default: // imsNone, imsYes
				if(ims == imsCancel) //!! should handle imsAbort here also
					m_fCancel = fTrue;
				return ims;
			}
		}
		else
		{
			if(ims == imsCancel) //!! should handle imsAbort here also
				m_fCancel = fTrue;
			return ims;
		}
	}
}


imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg)
{
	IMsiRecord& riError = GetSharedRecord(1);
	ISetErrorCode(&riError, imsg);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr)
{
	IMsiRecord& riError = GetSharedRecord(2);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, int i)
{
	IMsiRecord& riError = GetSharedRecord(2);
	ISetErrorCode(&riError, imsg);
	riError.SetInteger(2, i);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, int i, const ICHAR* sz)
{
	IMsiRecord& riError = GetSharedRecord(3);
	ISetErrorCode(&riError, imsg);
	riError.SetInteger(2, i);
	riError.SetString(3, sz);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2)
{
	IMsiRecord& riError = GetSharedRecord(3);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2, const IMsiString& riStr3)
{
	IMsiRecord& riError = GetSharedRecord(4);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	riError.SetMsiString(4, riStr3);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2,
									 const IMsiString& riStr3, int i)
{
	IMsiRecord& riError = GetSharedRecord(5);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	riError.SetMsiString(4, riStr3);
	riError.SetInteger(5, i);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1,
												 const IMsiString& riStr2, const IMsiString& riStr3,
												 const IMsiString& riStr4, const IMsiString& riStr5)
{
	IMsiRecord& riError = GetSharedRecord(6);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	riError.SetMsiString(4, riStr3);
	riError.SetMsiString(5, riStr4);
	riError.SetMsiString(6, riStr5);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const ICHAR* sz, int i)
{
	IMsiRecord& riError = GetSharedRecord(3);
	ISetErrorCode(&riError, imsg);
	riError.SetString(2, sz);
	riError.SetInteger(3,i);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const ICHAR* sz, int i1,int i2,int i3)
{
	IMsiRecord& riError = GetSharedRecord(5);
	ISetErrorCode(&riError, imsg);
	riError.SetString(2, sz);
	riError.SetInteger(3,i1);
	riError.SetInteger(4,i2);
	riError.SetInteger(5,i3);
	return DispatchMessage(imtType, riError, fTrue);
}

bool CMsiOpExecute::WriteRollbackRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	return WriteScriptRecord(m_pRollbackScript, ixoOpCode, riParams, true, m_riMessage);
}

// Rollback script handling
bool CMsiOpExecute::RollbackRecord(ixoEnum ixoOpcode, IMsiRecord& riParams)
{
	return m_pRollbackScript ? WriteRollbackRecord(ixoOpcode, riParams) : true;
}

Bool CMsiOpExecute::RollbackEnabled(void)
{
	return m_pRollbackScript ? fTrue : fFalse;
}

// accessors for current ProductInfo record

const IMsiString& CMsiOpExecute::GetProductKey()        {return m_piProductInfo->GetMsiString(IxoProductInfo::ProductKey);}
const IMsiString& CMsiOpExecute::GetProductName()       {return m_piProductInfo->GetMsiString(IxoProductInfo::ProductName);}
const IMsiString& CMsiOpExecute::GetPackageName()       {return m_piProductInfo->GetMsiString(IxoProductInfo::PackageName);}
int               CMsiOpExecute::GetProductLanguage()   {return m_piProductInfo->GetInteger(  IxoProductInfo::Language);}
int               CMsiOpExecute::GetProductVersion()    {return m_piProductInfo->GetInteger(  IxoProductInfo::Version);}
int               CMsiOpExecute::GetProductAssignment() {return m_piProductInfo->GetInteger(  IxoProductInfo::Assignment);}
int               CMsiOpExecute::GetProductInstanceType(){return m_piProductInfo->IsNull(IxoProductInfo::InstanceType) ? 0 : m_piProductInfo->GetInteger( IxoProductInfo::InstanceType);}
const IMsiString& CMsiOpExecute::GetProductIcon()       {return m_piProductInfo->GetMsiString(IxoProductInfo::ProductIcon);}
const IMsiString& CMsiOpExecute::GetPackageMediaPath()  {return m_piProductInfo->GetMsiString(IxoProductInfo::PackageMediaPath);}
const IMsiString& CMsiOpExecute::GetPackageCode()       {return m_piProductInfo->GetMsiString(IxoProductInfo::PackageCode);}
bool              CMsiOpExecute::GetAppCompatCAEnabled(){return (!m_piProductInfo->IsNull(IxoProductInfo::AppCompatDB) && !m_piProductInfo->IsNull(IxoProductInfo::AppCompatID));}

// convert a stored GUID string in the product info record at iField into a GUID and
// store it in the provided buffer. Returns a pointer to the provided buffer if
// successful and NULL if the field is NULL or on error.
const GUID* CMsiOpExecute::GUIDFromProdInfoData(GUID* pguidOutputBuffer, int iField)
{
	// check field for NULL
	if (m_piProductInfo->IsNull(iField))
		return NULL;

	// retrieve stream pointer
	PMsiData piData(m_piProductInfo->GetMsiData(iField));
	if (!piData)
		return NULL;
	PMsiStream piStream(0);
	if(piData->QueryInterface(IID_IMsiStream, (void**)&piStream) != S_OK)
		return NULL;
	if (!piStream)
		return NULL;
	
	// extract GUID from stream
	piStream->Reset();
	if (sizeof(GUID) != piStream->GetData(pguidOutputBuffer, sizeof(GUID)))
		return NULL;

	// return GUID buffer.
	return pguidOutputBuffer; 
}

const GUID* CMsiOpExecute::GetAppCompatDB(GUID* pguidOutputBuffer) { return GUIDFromProdInfoData(pguidOutputBuffer, IxoProductInfo::AppCompatDB); };
const GUID* CMsiOpExecute::GetAppCompatID(GUID* pguidOutputBuffer) { return GUIDFromProdInfoData(pguidOutputBuffer, IxoProductInfo::AppCompatID); };


//____________________________________________________________________________
//
// IMsiOpExecute operator functions, all of type FOpExecute
//____________________________________________________________________________

// Script management operations

iesEnum CMsiOpExecute::ixfFail(IMsiRecord& /*riParams*/)
{
	return iesFailure;
}

iesEnum CMsiOpExecute::ixfNoop(IMsiRecord& /*riParams*/)
{
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFullRecord(IMsiRecord& /*riParams*/)
{
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfHeader(IMsiRecord& riParams)
{
	using namespace IxoHeader;
	using namespace ProgressData;
	if (riParams.GetInteger(Signature) != iScriptSignature)
		return iesBadActionData;
	int iMsiVersion = riParams.GetInteger(Version);
	MsiDate iDate = MsiDate(riParams.GetInteger(Timestamp));
	int iLangId = riParams.GetInteger(LangId);
	istEnum istScriptType = (istEnum)riParams.GetInteger(ScriptType);

	AssertNonZero(m_pProgressRec->SetInteger(imdSubclass, iscMasterReset));
	AssertNonZero(m_pProgressRec->SetInteger(imdProgressTotal, m_iProgressTotal));
	AssertNonZero(m_pProgressRec->SetInteger(imdDirection, ipdForward));
	AssertNonZero(m_pProgressRec->SetInteger(imdEventType,ietTimeRemaining));
	if(Message(imtProgress, *m_pProgressRec) == imsCancel)
		return iesUserExit;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfEnd(IMsiRecord& /*riParams*/)
{
	using namespace IxoEnd;
//!! validate checksum?
//  if (ixsState == ixsRunning)
	return iesFinished;
}

UINT IsProductManaged(const ICHAR* szProductKey, bool &fIsProductManaged)
{
	Assert(szProductKey && *szProductKey);

	fIsProductManaged = false;
	DWORD dwRet = ERROR_SUCCESS;

	if (g_fWin9X == false)
	{
		MsiString strProductKeySQUID = GetPackedGUID(szProductKey);
		CRegHandle HProductKey;
		iaaAppAssignment iType = iaaNone;
		dwRet = GetProductAssignmentType(strProductKeySQUID, iType, HProductKey);
		if (ERROR_SUCCESS == dwRet && (iType == iaaUserAssign || iType == iaaMachineAssign))
		{
			// check for the security on the key if context is "managed"
			char* rgchSD;
			dwRet = ::GetSecureSecurityDescriptor(&rgchSD);
			if (ERROR_SUCCESS == dwRet)
			{
						
				if ((ERROR_SUCCESS == FIsKeySystemOrAdminOwned(HProductKey, fIsProductManaged)) && fIsProductManaged)
				{                   
					DEBUGMSG1(TEXT("Product %s is admin assigned: LocalSystem owns the publish key."), szProductKey);
				}
			}
		}
		Assert(ERROR_SUCCESS == dwRet || ERROR_FILE_NOT_FOUND == dwRet);
	}
	else
		fIsProductManaged = true;


	DEBUGMSG2(TEXT("Product %s %s."), szProductKey && *szProductKey ? szProductKey : TEXT("first-run"), fIsProductManaged ? TEXT("is managed") : TEXT("is not managed"));
	return dwRet;
}

bool IsProductManaged(const ICHAR* szProductKey)
{
	bool fManaged=false;
	IsProductManaged(szProductKey, fManaged);
	return fManaged;
}

iesEnum CMsiOpExecute::ixfProductInfo(IMsiRecord& riParams)
{
	using namespace IxoProductInfo;
	//!! TODO: make sure the record parameters are valid

#ifdef DEBUG
	const ICHAR* szProductName = riParams.GetString(ProductName);
#endif //DEBUG
	
	if(riParams.GetFieldCount())
	{
		if (m_piProductInfo->GetFieldCount() == 0)
		{
			// null record, not saved on stack
			m_piProductInfo->Release();
			m_piProductInfo = 0;
		}
#ifdef _WIN64       // !merced
		riParams.SetHandle(0, (HANDLE)m_piProductInfo);  // keeps ref-counted object in field 0
#else
		riParams.SetInteger(0, (int)m_piProductInfo);  // keeps ref-counted object in field 0
#endif
		//!! do we have to clear any other variables in prep. for nested install?
		m_piProductInfo = &riParams, riParams.AddRef();
		if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN_SCRIPTSETTINGS)
		{
			// we need to preserve the request in the script
			(!riParams.IsNull(Assignment) && riParams.GetInteger(Assignment)) ? m_fFlags |= SCRIPTFLAGS_MACHINEASSIGN : m_fFlags &= ~SCRIPTFLAGS_MACHINEASSIGN;
		}

		// this is the time to initialise the per machine vs per user variables
		iesEnum iesRet  = DoMachineVsUserInitialization();
		if(iesRet != iesSuccess)
			return iesRet;
	}
	else
	{
		// restore previous product info
		PMsiRecord pOldInfo = m_piProductInfo;  // force release of old record
#ifdef _WIN64       // !merced
		m_piProductInfo = (IMsiRecord*)pOldInfo->GetHandle(0);
#else
		m_piProductInfo = (IMsiRecord*)pOldInfo->GetInteger(0);
#endif
		Assert(m_piProductInfo != (IMsiRecord*)((INT_PTR)iMsiNullInteger));
	}

	// generate undo operation
	Assert(m_piProductInfo && m_piProductInfo->GetFieldCount());
	
#ifdef DEBUG
	szProductName = riParams.GetString(ProductName);
#endif //DEBUG

	if (!RollbackRecord(Op, *m_piProductInfo))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfDialogInfo(IMsiRecord& riParams)
{
	using namespace IxoDialogInfo;
	Message(imtCommonData, riParams);
	
	// generate undo operation
	if((icmtEnum)riParams.GetInteger(1) == icmtCancelShow)
	{
		// in rollback script, always disable cancel button
		riParams.SetInteger(2, (int)fFalse);
	}
	if (!RollbackRecord(Op, riParams))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfRollbackInfo(IMsiRecord& riParams)
{
	using namespace IxoRollbackInfo;
	if(!m_pRollbackAction)
		m_pRollbackAction = &m_riServices.CreateRecord(3);
	if(!m_pCleanupAction)
		m_pCleanupAction = &m_riServices.CreateRecord(3);
	AssertNonZero(m_pRollbackAction->SetMsiString(1,*MsiString(riParams.GetMsiString(RollbackAction))));
	AssertNonZero(m_pRollbackAction->SetMsiString(2,*MsiString(riParams.GetMsiString(RollbackDescription))));
	AssertNonZero(m_pRollbackAction->SetMsiString(3,*MsiString(riParams.GetMsiString(RollbackTemplate))));
	AssertNonZero(m_pCleanupAction->SetMsiString(1,*MsiString(riParams.GetMsiString(CleanupAction))));
	AssertNonZero(m_pCleanupAction->SetMsiString(2,*MsiString(riParams.GetMsiString(CleanupDescription))));
	AssertNonZero(m_pCleanupAction->SetMsiString(3,*MsiString(riParams.GetMsiString(CleanupTemplate))));

	if (!RollbackRecord(ixoRollbackInfo, riParams))
		return iesFailure;

	return iesSuccess;
}

// Notification operations

iesEnum CMsiOpExecute::ixfInfoMessage(IMsiRecord& riParams)
{
	using namespace IxoInfoMessage;
	Message(imtInfo, riParams);
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfActionStart(IMsiRecord& riParams)
{
	using namespace IxoActionStart;
#ifdef DEBUG
	const ICHAR* sz = riParams.GetString(Name);
	const ICHAR* sz2 = riParams.GetString(Description);
#endif //DEBUG

	// reset state variables
	delete &m_state;
	m_state = *(new (&m_state) CActionState);

	iesEnum iesReturn = iesSuccess;
	AssertNonZero(m_pProgressRec->SetMsiString(3, *MsiString(riParams.GetMsiString(Name)))); // set action name
	if(Message(imtActionStart, riParams) == imsCancel)
		return iesUserExit;

	// generate undo operation - undo op will reset state, but message will not be displayed
	// since progress is handled by RunRollbackScript, so we don't need to change the parameters
	if (!RollbackRecord(ixoActionStart,riParams))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfProgressTotal(IMsiRecord& riParams)
{
	using namespace IxoProgressTotal;
	using namespace ProgressData;
	iesEnum iesReturn = iesNoAction;
	AssertNonZero(m_pProgressRec->SetInteger(imdSubclass, iscActionInfo)); // Action progress init
	AssertNonZero(m_pProgressRec->SetInteger(imdPerTick, riParams.GetInteger(ByteEquivalent)));
	AssertNonZero(m_pProgressRec->SetInteger(imdType, riParams.GetInteger(Type)));
	if(Message(imtProgress, *m_pProgressRec) == imsCancel)
		iesReturn = iesUserExit;
	else

		iesReturn = iesSuccess;
	
	// no undo operation for ixoProgressTotal - RunRollbackScript handles progress
	
	return iesReturn;
}

// eat up a progress tick in an action
iesEnum CMsiOpExecute::ixfProgressTick(IMsiRecord& /*riParams*/)
{
	return (DispatchProgress(1) == imsCancel) ? iesUserExit:iesSuccess;
}


/*---------------------------------------------------------------------------
   DispatchProgress: increments m_pProgressRec[1] by cIncrement and
		dispatches progress message
---------------------------------------------------------------------------*/
imsEnum CMsiOpExecute::DispatchProgress(unsigned int cIncrement)
{
	using namespace ProgressData;
	if(m_cSuppressProgress > 0) // don't increment progress or send message if suppressing progress
		return imsNone;
	AssertNonZero(m_pProgressRec->SetInteger(imdSubclass, iscProgressReport));
	AssertNonZero(m_pProgressRec->SetInteger(imdIncrement, cIncrement));
	return Message(imtProgress, *m_pProgressRec);
}

void CMsiOpExecute::GetProductClientList(const ICHAR* szParent, const ICHAR* szRelativePackagePath, unsigned int uiDiskId, const IMsiString*& rpiClientList)
{
	PMsiRegKey pProductKey(0);
	MsiString strProductKey = GetProductKey();
	CTempBuffer<ICHAR, 256> rgchProductInfo;


	MsiString strClients;
	if(szParent && *szParent)
	{
		// child install
		strClients = szParent;
		strClients += MsiString(MsiChar(';'));
		strClients += szRelativePackagePath;
		strClients += MsiString(MsiChar(';'));
		strClients += (int)uiDiskId;
	}
	else // parent
		strClients = szSelfClientToken;
	strClients.ReturnArg(rpiClientList);
}

// Configuration manager operations

iesEnum CMsiOpExecute::ixfProductRegister(IMsiRecord& riParams)
{
	using namespace IxoProductRegister;

	MsiString strProductKey = GetProductKey();
	
	// are we in sequence
	if(!strProductKey.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductRegister")));
		return iesFailure;
	}
						
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pRecErr(0);
	return ProcessRegisterProduct(riParams, fFalse);
}

iesEnum CMsiOpExecute::ixfUserRegister(IMsiRecord& riParams)
{
	// are we in sequence
	MsiString strProductKey = GetProductKey();
	if(!strProductKey.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfUserRegister")));
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	return ProcessRegisterUser(riParams, fFalse);
}

iesEnum CMsiOpExecute::ixfProductUnregister(IMsiRecord& riParams)
{
	using namespace IxoProductUnregister;

	// are we in sequence
	MsiString strProductKey = GetProductKey();
	if(!strProductKey.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductUnregister")));
		return iesFailure;
	}
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	iesEnum iesRet = iesSuccess;

	PMsiRecord pParams(0);

	// remove any cached secure transforms
#ifdef UNICODE
	MsiString strSecureTransformsKey;
	PMsiRecord pError = GetProductSecureTransformsKey(*&strSecureTransformsKey);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);
	PMsiRegKey pSecureTransformsKey = &pHKLM->CreateChild(strSecureTransformsKey);
	// enumerate through the secure transforms
	PEnumMsiString pEnum(0);
	if((pError = pSecureTransformsKey->GetValueEnumerator(*&pEnum)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strValueName, strValue;
	PMsiPath pTransformPath(0);
	while((pEnum->Next(1, &strValueName, 0)) == S_OK)
	{
		if((pError = pSecureTransformsKey->GetValue(strValueName,*&strValue)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}

		// set up the transform file for deletion
		if(!pTransformPath)
		{
			MsiString strCachePath = GetMsiDirectory();
			Assert(strCachePath.TextSize());
			if((pError = m_riServices.CreatePath(strCachePath,*&pTransformPath)))
				return FatalError(*pError);
		}
		MsiString strTransformFullPath;
		if((pError = pTransformPath->GetFullFilePath(strValue,*&strTransformFullPath)))
			return FatalError(*pError);

		if(iesSuccess != DeleteFileDuringCleanup(strTransformFullPath, true))
		{
			DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove),*strTransformFullPath);
		}
	}


	// remove any cached secure transforms registration
	{
		CElevate elevate; // so we can remove the feature usage key

		// Remove feature usage key
		pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
		
#ifdef _WIN64	// !merced
			AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hUserDataKey));
#else			// win-32
			AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root,(int)m_hUserDataKey));
#endif
		AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strSecureTransformsKey));
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

		m_cSuppressProgress++;  
		iesRet = ixfRegOpenKey(*pParams);
		if (iesRet == iesSuccess || iesRet == iesNoAction)
			iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		
		m_cSuppressProgress--;
	}
#else
	WIN32_FIND_DATA fdFileData;
	HANDLE hFindFile = INVALID_HANDLE_VALUE;

	PMsiPath pTransformPath(0);
	PMsiRecord pError = GetSecureTransformCachePath(m_riServices, 
													*MsiString(GetProductKey()), 
													*&pTransformPath);
	if (pError)
		return FatalError(*pError);

	Assert(pTransformPath);

	MsiString strSearchPath = pTransformPath->GetPath();
	strSearchPath += TEXT("*.*");

	bool fContinue = true;

	hFindFile = WIN::FindFirstFile(strSearchPath, &fdFileData);
	if (hFindFile != INVALID_HANDLE_VALUE)
	{
		for (;;)
		{
			if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				// add file to the list of temporary files to be deleted when install packages
				// are released
				MsiString strFullFilePath;
				AssertRecord(pTransformPath->GetFullFilePath(fdFileData.cFileName,
																							 *&strFullFilePath));

				if(iesSuccess != DeleteFileDuringCleanup(strFullFilePath, true))
				{
					DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove),*strFullFilePath);
				}
			}
			
			if (!WIN::FindNextFile(hFindFile, &fdFileData))
			{
				Assert(ERROR_NO_MORE_FILES == GetLastError());
				WIN::FindClose(hFindFile);
				break;
			}
		}
	}
#endif

	// if there's a cached database then we need to remove it
	// since its probably in use, we can't remove it now so just schedule it for delete after reboot
	// NOTE: we could call RemoveFile() which would schedule it for deletion
	// but that will try to backup the file and make a copy without
	// removing the original since the file is held in place
	// its safe to not backup this file since no one will try to install over it
	// (cached msis always have unique names)

	// get the appropriate cached database key/ value
	MsiString strLocalPackageKey;
	HKEY hKey = 0; // will be set to global key, do not close
	if((pError = GetProductInstalledPropertiesKey(hKey, *&strLocalPackageKey)) != 0)
		return FatalError(*pError);

	PMsiRegKey pHRoot = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hKey, ibtCommon);

	PMsiRegKey pCachedDatabaseKey = &pHRoot->CreateChild(strLocalPackageKey);
	MsiString strCachedDatabase;
	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);

	if((pError = pCachedDatabaseKey->GetValue(iaaAsgnType == iaaUserAssign ? szLocalPackageManagedValueName : szLocalPackageValueName,*&strCachedDatabase)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	if (strCachedDatabase.TextSize())
	{
		if(iesSuccess != DeleteFileDuringCleanup(strCachedDatabase,false))
		{
			// not a fatal error - just log it
			DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strCachedDatabase);
		}
	}

	if ((iesRet = ProcessRegisterProduct(riParams, fTrue)) != iesSuccess)
		return iesRet;

	{
		CElevate elevate; // so we can remove the feature usage key

		// Remove feature usage key
		MsiString strFeatureUsage;
		if ((pError = GetProductFeatureUsageKey(*&strFeatureUsage)) != 0)
			return FatalError(*pError);

		pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
		
#ifdef _WIN64	// !merced
			AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hUserDataKey));
#else			// win-32
			AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root,(int)m_hUserDataKey));
#endif
		AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strFeatureUsage));
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

		m_cSuppressProgress++;  
		iesRet = ixfRegOpenKey(*pParams);
		if (iesRet == iesSuccess || iesRet == iesNoAction)
			iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		
		m_cSuppressProgress--;
	}

	if (iesRet == iesSuccess || iesRet == iesNoAction)
	{
		// Remove user registration
		pParams = &m_riServices.CreateRecord(IxoUserRegister::Args);
		iesRet = ProcessRegisterUser(*pParams, fTrue);
	}

	return iesRet;
}


/*---------------------------------------------------------------------------
ixfProductCPDisplayInfoRegister
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductCPDisplayInfoRegister(IMsiRecord& riParams)
{
	using namespace IxoProductCPDisplayInfoRegister;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductCPDisplayInfoRegister")));
		return iesFailure;
	}

	return ProcessRegisterProductCPDisplayInfo(riParams, fFalse);
}

/*---------------------------------------------------------------------------
ixfProductCPDisplayInfoUnregister
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductCPDisplayInfoUnregister(IMsiRecord& riParams)
{
	using namespace IxoProductCPDisplayInfoUnregister;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductCPDisplayInfoUnregister")));
		return iesFailure;
	}
	
	return ProcessRegisterProductCPDisplayInfo(riParams, fTrue);
}

// FN: checks to see if a product is registered for any user
bool FProductRegisteredForAUser(const ICHAR* szProductCode)
{
	bool fRegistered = false;
	unsigned uiUser = 0;
	CRegHandle hKey;
	DWORD dwResult;
	extern DWORD OpenEnumedUserInstalledProductInstallPropertiesKey(unsigned int uiUser, const ICHAR* szProduct, CRegHandle& rhKey); // from msinst.cpp

	while(!fRegistered && (ERROR_NO_MORE_ITEMS != (dwResult = OpenEnumedUserInstalledProductInstallPropertiesKey(uiUser++, szProductCode, hKey))))
	{
		if((ERROR_SUCCESS == dwResult && ERROR_SUCCESS == (dwResult = WIN::RegQueryValueEx(hKey, szWindowsInstallerValueName, 0, 0, 0, 0))) ||
			(ERROR_FILE_NOT_FOUND != dwResult))
			fRegistered = true;	// non-expected error from OpenEnumedUserInstalledProductInstallPropertiesKey, err on the side of safety
								// and prevent legacy stuff from being removed AND also prevent infinite loop on the side
	}
	return fRegistered;
}


iesEnum CMsiOpExecute::ProcessRegisterProductCPDisplayInfo(IMsiRecord& /*riParams*/, Bool fRemove)
{
	CElevate elevate; // elevate this entire function

	MsiString strDisplayName = GetProductName();

	MsiString strProductInstalledPropertiesKey;
	HKEY hKey = 0; // will be set to global key, do not close
	PMsiRecord pRecErr(0);
	if((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strProductInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	CTempBuffer<ICHAR,1> rgchInstallPropertiesLocation(MAX_PATH * 2);
	if (FAILED(StringCchCopy(rgchInstallPropertiesLocation, rgchInstallPropertiesLocation.GetSize(), strProductInstalledPropertiesKey)))
		return FatalError(*PMsiRecord(PostError(Imsg(imsgCreateKeyFailed), *strProductInstalledPropertiesKey, ERROR_INSUFFICIENT_BUFFER)));

	const ICHAR* rgszProductInfoRegData[] = 
	{
		TEXT("%s"), rgchInstallPropertiesLocation, 0, 0,
		szDisplayNameValueName,     (const ICHAR*)strDisplayName,             g_szTypeString,
		0,
		0,
	};

	PMsiStream pSecurityDescriptor(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesEnum iesRet = ProcessRegInfo(rgszProductInfoRegData, hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
    if (iesRet != iesSuccess)
        return iesRet;

#ifdef UNICODE
	// update the legacy location
	MsiString strProductKey = GetProductKey();
	if (FAILED(StringCchPrintf(rgchInstallPropertiesLocation, rgchInstallPropertiesLocation.GetSize(), TEXT("%s\\%s"), szMsiUninstallProductsKey_legacy, (const ICHAR*)strProductKey)))
		return FatalError(*PMsiRecord(PostError(Imsg(imsgCreateKeyFailed), szMsiUninstallProductsKey_legacy, ERROR_INSUFFICIENT_BUFFER)));

	if(!fRemove)
	{
        iesRet = CreateUninstallKey();
        if (iesRet != iesSuccess)
            return iesRet;
	}

	if(!fRemove || !FProductRegisteredForAUser(strProductKey))
		iesRet = ProcessRegInfo(rgszProductInfoRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
#endif
	return iesRet;
}


bool FIsRegistryOrAssemblyKeyPath(const IMsiString& riPath, bool fRegistryOnly)
{
	ICHAR ch = 0;

	if(!fRegistryOnly && (*(riPath.GetString()) == chTokenFusionComponent || *(riPath.GetString()) == chTokenWin32Component))
		return true;

	if (riPath.TextSize() > 2)
		ch = ((const ICHAR*)riPath.GetString())[2];
		
	if ((ch == TEXT(':')) || (ch == TEXT('*'))) // look for registry tokens
		return true;
	else
		return false;
}


const IMsiString& GetSourcePathForRollback(const IMsiString& ristrPath)
{
	ristrPath.AddRef();
	MsiString strRet = ristrPath;

	if(!FIsRegistryOrAssemblyKeyPath(ristrPath, false))
		strRet.Remove(iseFirst, 2);

	return strRet.Return();
}

IMsiRecord* AreAssembliesEqual(const IMsiString& ristrAssemblyName1, const IMsiString& ristrAssemblyName2, iatAssemblyType iatAT, bool& rfAssemblyEqual)
{
	// create the assembly name object
	PAssemblyName pAssemblyName1(0);
	PAssemblyName pAssemblyName2(0);

	for(int cCount = 0; cCount < 2; cCount++)
	{
		LPCOLESTR szAssemblyName;
#ifndef UNICODE
		CTempBuffer<WCHAR, MAX_PATH>  rgchAssemblyName;
		ConvertMultiSzToWideChar(cCount ? ristrAssemblyName2 : ristrAssemblyName1, rgchAssemblyName);
		szAssemblyName = rgchAssemblyName;
#else
		szAssemblyName = cCount ? ristrAssemblyName2.GetString() : ristrAssemblyName1.GetString();
#endif
		HRESULT hr;
		if(iatAT == iatURTAssembly)
		{
			hr = FUSION::CreateAssemblyNameObject(cCount ? &pAssemblyName2 : &pAssemblyName1, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
		}
		else
		{
			Assert(iatAT == iatWin32Assembly);
			hr = SXS::CreateAssemblyNameObject(cCount ? &pAssemblyName2 : &pAssemblyName1, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
		}
		if(!SUCCEEDED(hr))
			return PostAssemblyError(TEXT(""), hr, TEXT(""), TEXT("CreateAssemblyNameObject"), cCount ? ristrAssemblyName2.GetString() : ristrAssemblyName1.GetString(), iatAT);
	}
	rfAssemblyEqual = (S_OK == pAssemblyName1->IsEqual(pAssemblyName2, ASM_CMPF_DEFAULT)) ? true:false;
	return 0;
}

iesEnum CMsiOpExecute::ixfComponentRegister(IMsiRecord& riParams)
{
	using namespace IxoComponentRegister;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentRegister")));
		return iesFailure;
	}

	MsiString istrComponent = riParams.GetMsiString(ComponentId);
	MsiString istrKeyPath = riParams.GetMsiString(KeyPath);
	INSTALLSTATE iState = (INSTALLSTATE)riParams.GetInteger(State);
	int iSharedDllRefCount = riParams.GetInteger(SharedDllRefCount);
	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	MsiString strProduct;
	
	if (riParams.IsNull(ProductKey))
		strProduct = GetProductKey();
	else
		strProduct = riParams.GetMsiString(ProductKey);

	AssertNonZero(riActionData.SetMsiString(1, *strProduct));
	AssertNonZero(riActionData.SetMsiString(2, *istrComponent));
	AssertNonZero(riActionData.SetMsiString(3, *istrKeyPath));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// gather info for undo op
	// determine if component is already registered, and get key path
	PMsiRecord pError(0);
	PMsiRecord pComponentInfo(0);
	Bool fRegistered = fTrue;
	MsiString strOldKeyPath;
	MsiString strOldAuxPath;
	int iOldInstallState = 0;
	Bool fOldSharedDllRefCount = fFalse;

	// read previous component information from the appropriate location
	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);
	if((pError = GetComponentPath(m_riServices, 0, *strProduct,*istrComponent,*&pComponentInfo, &iaaAsgnType)) != 0)
		// component not registered
		fRegistered = fFalse;
	else
	{
		iOldInstallState = pComponentInfo->GetInteger(icmlcrINSTALLSTATE_Static);
		if(INSTALLSTATE_UNKNOWN == iOldInstallState)
			fRegistered = fFalse;
		else
		{
			// use the raw path for registry paths (for bug fix 9006) and assembly paths
			// else use the actual path
			strOldKeyPath = pComponentInfo->GetMsiString(icmlcrRawFile);
			if(!FIsRegistryOrAssemblyKeyPath(*strOldKeyPath, false))
				strOldKeyPath = pComponentInfo->GetMsiString(icmlcrFile);
			if(INSTALLSTATE_SOURCE == iOldInstallState)
			{
				strOldKeyPath = GetSourcePathForRollback(*strOldKeyPath);
			}
			strOldAuxPath = pComponentInfo->GetMsiString(icmlcrRawAuxPath);
			if(strOldAuxPath.TextSize())
			{
				Assert(FIsRegistryOrAssemblyKeyPath(*strOldAuxPath, true)); // aux key path can only be a registry
				if(INSTALLSTATE_SOURCE == iOldInstallState)
				{
					strOldAuxPath = GetSourcePathForRollback(*strOldAuxPath);
				}
				// append the auxiliary key path to the key path
				strOldKeyPath = strOldKeyPath + MsiString(MsiChar(0));
				strOldKeyPath += strOldAuxPath;
			}
			fOldSharedDllRefCount = (Bool)(pComponentInfo->GetInteger(icmlcrSharedDllCount) == fTrue);
		}
	}
	
	int iDisk = riParams.GetInteger(Disk);
	if (iMsiStringBadInteger == iDisk)
		iDisk = 1;
	iesEnum iesRet = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
	{
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
		Assert(iType == ibt32bit || iType == ibt64bit);
	}

	while(fRetry)  // retry loop
	{
		pError = 0;
		//check for Fusion components
		iatAssemblyType iatOld;
		MsiString strAssemblyName;
		iatAssemblyType iatNew;
		iatNew = *(const ICHAR* )istrKeyPath == chTokenFusionComponent ? iatURTAssembly : 
			(*(const ICHAR* )istrKeyPath == chTokenWin32Component ? iatWin32Assembly : iatNone);
		if(iatURTAssembly == iatNew || iatWin32Assembly == iatNew)
		{
			// create the component id to assembly mapping for files to come

			// Extract upto the first '\\', the rest is the assembly name
			strAssemblyName = istrKeyPath;
			strAssemblyName.Remove(iseIncluding, '\\');
			// save off the Assembly info about the component in a temp table
			pError = CacheAssemblyMapping(*istrComponent, *strAssemblyName, iatNew);
		}
		if(!pError && fRegistered)
		{
			// check the type of old registration

			iatOld = *(const ICHAR* )strOldKeyPath == chTokenFusionComponent ? iatURTAssembly : 
			(*(const ICHAR* )strOldKeyPath == chTokenWin32Component ? iatWin32Assembly : iatNone);
			if(iatURTAssembly == iatOld || iatWin32Assembly == iatOld)
			{
				// if the old registration does not match the new, then possibly uninstall the old assembly
				bool fAssemblyUnchanged = true;
				MsiString strAssemblyNameOld = strOldKeyPath;
				strAssemblyNameOld.Remove(iseIncluding, '\\');
				if(iatOld != iatNew)
					fAssemblyUnchanged = false;
				else
					pError = AreAssembliesEqual(*strAssemblyName, *strAssemblyNameOld, iatOld, fAssemblyUnchanged);
				if(!pError && !fAssemblyUnchanged)
 					pError = CacheAssemblyForUninstalling(*istrComponent, *strAssemblyNameOld, iatOld);
			}
		}
		if(!pError)
			pError = RegisterComponent(*strProduct,*istrComponent, iState, *istrKeyPath, (unsigned int)iDisk, iSharedDllRefCount, iType);
		if (pError)
		{
			switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3), Imsg(idbgOpCompRegister),*istrComponent))
			{
			case imsAbort: iesRet = iesFailure; fRetry = fFalse; break;
			case imsRetry: continue;
			default:       iesRet = iesSuccess; fRetry = fFalse;//!!?? imsIgnore, imsNone
			};
		}
		else
		{
			iesRet = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	if(fSuccess)
	{
		// generate rollback op
		if(fRegistered == fTrue)
		{
			// register old component on rollback
			IMsiRecord& riUndoParams = GetSharedRecord(Args);
			AssertNonZero(riUndoParams.SetMsiString(ComponentId,*istrComponent));
			AssertNonZero(riUndoParams.SetMsiString(KeyPath,*strOldKeyPath));
			AssertNonZero(riUndoParams.SetInteger(State,iOldInstallState));         
			AssertNonZero(riUndoParams.SetInteger(SharedDllRefCount,fOldSharedDllRefCount));
			AssertNonZero(riUndoParams.SetMsiString(ProductKey,*strProduct));
			AssertNonZero(riUndoParams.SetInteger(BinaryType,iType));
			if (!RollbackRecord(ixoComponentRegister,riUndoParams))
				return iesFailure;

			// don't need to unregister new component
		}
		else
		{
			// unregister component on rollback
			IMsiRecord& riUndoParams = GetSharedRecord(IxoComponentUnregister::Args);
			AssertNonZero(riUndoParams.SetMsiString(IxoComponentUnregister::ComponentId,*istrComponent));
			AssertNonZero(riUndoParams.SetMsiString(IxoComponentUnregister::ProductKey,*strProduct));
			AssertNonZero(riUndoParams.SetInteger(IxoComponentUnregister::BinaryType,iType));
			// if this is rollback, then check if we were installed prior to this install
			// if yes then we skip the Uninstallning 
			// this is to catch scenarios where the assembly was installed via some other
			// user
			if(	*(const ICHAR* )istrKeyPath == chTokenFusionComponent || 
				*(const ICHAR* )istrKeyPath == chTokenWin32Component)
			{
				iatAssemblyType iatAT = (*(const ICHAR* )istrKeyPath == chTokenFusionComponent) ? iatURTAssembly : iatWin32Assembly;
				bool fInstalled = false;
				// Extract upto the first '\\', the rest is the assembly name
				MsiString strAssemblyName = istrKeyPath;
				strAssemblyName.Remove(iseIncluding, '\\');
				pError = IsAssemblyInstalled(*istrComponent, *strAssemblyName, iatAT, fInstalled, 0, 0);
				if (pError)
					return FatalError(*pError);
				if(fInstalled)
				{
					AssertNonZero(riUndoParams.SetInteger(IxoComponentUnregister::PreviouslyPinned, 1));
				}
			
			}
			if (!RollbackRecord(ixoComponentUnregister,riUndoParams))
				return iesFailure;
		}
	}
	return iesRet;
}

iesEnum CMsiOpExecute::ixfComponentUnregister(IMsiRecord& riParams)
{
	using namespace IxoComponentUnregister;
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentUnregister")));
		return iesFailure;
	}
	MsiString istrComponent = riParams.GetMsiString(ComponentId);
	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	MsiString strProduct;
	
	if (riParams.IsNull(ProductKey))
		strProduct = GetProductKey();
	else
		strProduct = riParams.GetMsiString(ProductKey);

	AssertNonZero(riActionData.SetMsiString(1, *strProduct));
	AssertNonZero(riActionData.SetMsiString(2, *istrComponent));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// gather info for undo op
	// determine if component is already registered, and get key path
	PMsiRecord pError(0);
	PMsiRecord pComponentInfo(0);
	Bool fRegistered = fTrue;
	MsiString strOldKeyPath;
	MsiString strOldAuxPath;
	int iOldInstallState = 0;
	Bool fOldSharedDllRefCount = fFalse;

	//read info from the appropriate components location
	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);
	if((pError = GetComponentPath(m_riServices, 0, *strProduct,*istrComponent,*&pComponentInfo, &iaaAsgnType)) != 0)
		fRegistered = fFalse;
	else
	{
		iOldInstallState = pComponentInfo->GetInteger(icmlcrINSTALLSTATE_Static);
		if(INSTALLSTATE_UNKNOWN == iOldInstallState)
			fRegistered = fFalse;
		else
		{
			// use the raw path for registry paths (for bug fix 9006) and assembly paths
			// else use the actual path
			strOldKeyPath = pComponentInfo->GetMsiString(icmlcrRawFile);
			if(!FIsRegistryOrAssemblyKeyPath(*strOldKeyPath, false))
				strOldKeyPath = pComponentInfo->GetMsiString(icmlcrFile);
			if(INSTALLSTATE_SOURCE == iOldInstallState)
			{
				strOldKeyPath = GetSourcePathForRollback(*strOldKeyPath);
			}
			strOldAuxPath = pComponentInfo->GetMsiString(icmlcrRawAuxPath);
			if(strOldAuxPath.TextSize())
			{
				Assert(FIsRegistryOrAssemblyKeyPath(*strOldAuxPath, true)); // aux key path can only be a registry
				if(INSTALLSTATE_SOURCE == iOldInstallState)
				{
					strOldAuxPath = GetSourcePathForRollback(*strOldAuxPath);
				}
				// append the auxiliary key path to the key path
				strOldKeyPath = strOldKeyPath + MsiString(MsiChar(0));
				strOldKeyPath += strOldAuxPath;
			}
			fOldSharedDllRefCount = (Bool)(pComponentInfo->GetInteger(icmlcrSharedDllCount) == fTrue);
		}
	}
	
	iesEnum iesRet = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
	{
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
		Assert(iType == ibt32bit || iType == ibt64bit);
	}

	while(fRetry)  // retry loop
	{
		PMsiRecord pError(0);
		// we treat 
		if(*(const ICHAR* )strOldKeyPath == chTokenFusionComponent || *(const ICHAR* )strOldKeyPath == chTokenWin32Component)
		{
			// set up the unclienting of assembly components at the end
			// get assembly name
			MsiString strAssemblyName = strOldKeyPath;
			strAssemblyName.Remove(iseIncluding, '\\');

			// set for Uninstallning only if not previously pinned
			if(riParams.GetInteger(PreviouslyPinned) == iMsiNullInteger)
				CacheAssemblyForUninstalling(*istrComponent, *strAssemblyName, *(const ICHAR* )strOldKeyPath == chTokenFusionComponent ?  iatURTAssembly : iatWin32Assembly);
		}

		if(!pError)
		pError = UnregisterComponent(*strProduct, *istrComponent, iType);
		if (pError)
		{
			switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3), Imsg(idbgOpCompUnregister),*istrComponent))
			{
			case imsAbort: iesRet = iesFailure; fRetry = fFalse; break;
			case imsRetry: continue;
			default:       iesRet = iesSuccess; fRetry = fFalse; // imsIgnore, imsNone
			};
		}
		else
		{
			iesRet = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	if(fSuccess && fRegistered == fTrue)
	{
		// generate rollback op
		// register component on rollback
		IMsiRecord& riUndoParams = GetSharedRecord(IxoComponentRegister::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoComponentRegister::ProductKey,*strProduct));
		AssertNonZero(riUndoParams.SetInteger(IxoComponentRegister::State,iOldInstallState));           
		AssertNonZero(riUndoParams.SetInteger(IxoComponentRegister::SharedDllRefCount,fOldSharedDllRefCount));          
		AssertNonZero(riUndoParams.SetMsiString(IxoComponentRegister::ComponentId,*istrComponent));
		AssertNonZero(riUndoParams.SetMsiString(IxoComponentRegister::KeyPath,*strOldKeyPath));
		AssertNonZero(riUndoParams.SetInteger(IxoComponentRegister::BinaryType,iType));
		if (!RollbackRecord(ixoComponentRegister,riUndoParams))
			return iesFailure;
	}
	return iesRet;
}

// increment guid to get the next guid to represent the system client
// dependant on the fact that PackGUID switches the guid around as shown
// {F852C27C-F690-11d2-94A1-006008993FDF} => C72C258F096F2d11491A00068099F3FD
bool GetNextSystemGuid(ICHAR* szProductKeyPacked)
{
	int iPos = 0;
	while(iPos < 2) // we support a max of FF (2 digits) different locations
	{
		if(*(szProductKeyPacked + iPos) == 'F') // last digit
			*(szProductKeyPacked + iPos++) = '0'; // reset
		else
		{
			if(*(szProductKeyPacked + iPos) == '9')
				(*(szProductKeyPacked + iPos)) = 'A'; // jump to A if at 9
			else
				(*(szProductKeyPacked + iPos))++;
			return true;
		}
	}
	AssertSz(0, "Limit for number of locations possible for a permanent component reached"); // never expect us to reach the FF limit for FF possible locations for the same permanent component
	// GUID has laready been reset back to the starting guid
	return false; // no more 
}

IMsiRecord* CMsiOpExecute::RegisterComponent(const IMsiString& riProductKey, const IMsiString& riComponentsKey, INSTALLSTATE iState, const IMsiString& riKeyPath, unsigned int uiDisk, int iSharedDllRefCount, const ibtBinaryType iType)
{
	MsiString strSubKey;
	IMsiRecord* piError = 0;
	if((piError = GetProductInstalledComponentsKey(riComponentsKey.GetString(), *&strSubKey)) != 0)
		return piError;

	bool fIsSystemClient = (riProductKey.Compare(iscExact, szSystemProductKey) != 0);

	ICHAR szProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(riProductKey.GetString(),    szProductKeyPacked));

	PMsiRegKey pRootKey(0);
#ifdef UNICODE
	if(!fIsSystemClient)
#endif
	{
		// choose install location for config data based on installation type
		pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)
	}
#ifdef UNICODE
	else
	{
		// permanant components registered globally in per machine location
		PMsiRegKey pLocalMachine = &m_riServices.GetRootKey(rrkLocalMachine, ibtCommon);

		MsiString strLocalMachineData = szMsiUserDataKey;
		strLocalMachineData += szRegSep;
		strLocalMachineData += szLocalSystemSID;
		pRootKey = &pLocalMachine->CreateChild(strLocalMachineData);
	}
#endif

	PMsiRegKey pComponentIdKey = &pRootKey->CreateChild(strSubKey);
	{
		CElevate elevate;
		if((piError = pComponentIdKey->Create()) != 0)
			return piError;
	}

	const ICHAR* szKeyPath = riKeyPath.GetString();

	Assert(*(riKeyPath.GetString()) != 0 || iState == INSTALLSTATE_NOTUSED); // installstate should be not used for disabled components
	
	if(!FIsRegistryOrAssemblyKeyPath(riKeyPath, false))
	{		
		// we have a key file. 

		PMsiRecord pSharedDllCompatibilityError(0);
		// pSharedDllCompatibilityError will be set if we error while doing shared dll compatibility stuff
		//!! currently ignored as non fatal, this will get logged when we have implicit logging in PostError in services

		MsiString strOldKey;
		bool fOldRefcounted;

		// if this is the system client, AND the current GUID that represents the system is already registered to a 
		// different location than where we wish to register, we increment the GUID and try again (and again)
		do{
			fOldRefcounted = false;
			if((piError = pComponentIdKey->GetValue(szProductKeyPacked, *&strOldKey)) != 0)
				return piError;

			if(strOldKey.TextSize() && !*(const ICHAR* )strOldKey) // we have a multi_sz
				strOldKey.Remove(iseFirst, 1); // drop the beginning null

			if(strOldKey.TextSize() > 1 && *((const ICHAR*)strOldKey + 1) == chSharedDllCountToken)
			{
				fOldRefcounted = true;
				ICHAR chSecond = *((const ICHAR*)strOldKey) == '\\' ? '\\' : ':'; // replace the chSharedDllCountToken
				strOldKey = MsiString(MsiString(strOldKey.Extract(iseFirst, 1)) + MsiString(MsiChar(chSecond))) + MsiString(strOldKey.Extract(iseLast, strOldKey.CharacterCount() - 2));
			}
		}while(fIsSystemClient && strOldKey.TextSize() && !riKeyPath.Compare(iscExactI, strOldKey) 
				&& ((fOldRefcounted = GetNextSystemGuid(szProductKeyPacked)) == true));

		// decrement any old reg count, will be re-incremented if doing a reinstall
		if(fOldRefcounted)
		{
			Assert(strOldKey.TextSize());
			pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strOldKey, iType, *MsiString(*szDecrementValue));
		}

		MsiString strKeyPath;
		if (iState == INSTALLSTATE_SOURCE)
		{
			Assert(uiDisk >= 1 && uiDisk <= 99);
			if (uiDisk < 10)
				strKeyPath = TEXT("0");
			
			strKeyPath += MsiString((int)uiDisk);
		}

		strKeyPath += riKeyPath;

		// increment the reg count, if file
		// !! we would remove this check when we explicitly pass in the fact as to whether 
		// !! we have a file or a folder as the key path

		// skip disabled components, run from source components, folder paths
		if(iState != INSTALLSTATE_NOTUSED && iState != INSTALLSTATE_SOURCE && *((const ICHAR*)strKeyPath + IStrLen(strKeyPath) - 1) != chDirSep)
		{
			Bool fLegacyFileExisted = iSharedDllRefCount & ircenumLegacyFileExisted ? fTrue:fFalse;
			Bool fSharedDllRefCount = iSharedDllRefCount & ircenumRefCountDll ? fTrue:fFalse;
			pSharedDllCompatibilityError = GetSharedDLLCount(m_riServices, szKeyPath, iType, *&strOldKey);

			if(!pSharedDllCompatibilityError)
			{
				strOldKey.Remove(iseFirst, 1);
				bool fPrevRefcounted = (strOldKey != iMsiStringBadInteger && strOldKey >= 1);
				if(fSharedDllRefCount || fPrevRefcounted) // need to refcount
				{
					MsiString strIncrementValue(*szIncrementValue);
					pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strKeyPath, iType, *strIncrementValue);
					if(!pSharedDllCompatibilityError && fLegacyFileExisted && !fPrevRefcounted) // need to doubly refcount
					{
						pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strKeyPath, iType, *strIncrementValue);
					}
					if(!pSharedDllCompatibilityError) // we managed to refcount 
						strKeyPath = MsiString(MsiString(strKeyPath.Extract(iseFirst, 1)) + MsiString(MsiChar(chSharedDllCountToken))) + MsiString(strKeyPath.Extract(iseLast, strKeyPath.CharacterCount() - 2));
				}
			}
		}

		{
			CElevate elevate;
			// set the key file
			if((piError = pComponentIdKey->SetValue(szProductKeyPacked, *strKeyPath)) != 0)
				return piError;
		}
	}
	else // should be a reg key
	{
		{
			CElevate elevate;
			if((piError = pComponentIdKey->SetValue(szProductKeyPacked, riKeyPath)) != 0)
				return piError;
		}
	}

	return 0;
}



IMsiRecord* CMsiOpExecute::UnregisterComponent(	const IMsiString& riProductKey, const IMsiString& riComponentsKey, const ibtBinaryType iType)
{
	MsiString strSubKey;
	IMsiRecord* piError = 0;
	if((piError = GetProductInstalledComponentsKey(riComponentsKey.GetString(), *&strSubKey)) != 0)
		return piError;

	PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)

	ICHAR szProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(riProductKey.GetString(),    szProductKeyPacked));

	PMsiRegKey pComponentIdKey = &pRootKey->CreateChild(strSubKey);

	MsiString strOldKey;
	if((piError = pComponentIdKey->GetValue(szProductKeyPacked, *&strOldKey)) != 0)
		return piError;

	DWORD dwProductIndex = 0;
	ICHAR szProductBuf[39];
	{
		CElevate elevate;
		// remove client entry
		if((piError = pComponentIdKey->RemoveValue(szProductKeyPacked, 0)) != 0)
			return piError;
	}

	// decrement the reg count if any for file key paths	
    if(strOldKey.TextSize() && !*(const ICHAR* )strOldKey) // we have a multi_sz
        strOldKey.Remove(iseFirst, 1); // drop the beginning null

	if(strOldKey.TextSize() && !FIsRegistryOrAssemblyKeyPath(*strOldKey, false))
	{
		if(strOldKey.TextSize() > 1 && *((const ICHAR* )strOldKey + 1) == chSharedDllCountToken)
		{
			ICHAR chSecond = *((const ICHAR*)strOldKey) == '\\' ? '\\' : ':'; // replace the chSharedDllCountToken
			strOldKey = MsiString(MsiString(strOldKey.Extract(iseFirst, 1)) + MsiString(MsiChar(chSecond))) + MsiString(strOldKey.Extract(iseLast, strOldKey.CharacterCount() - 2));
			PMsiRecord pSharedDllCompatibilityError(0);
			// pSharedDllCompatibilityError will be set if we error while doing shared dll compatibility stuff
			//!! currently ignored as non fatal, this will get logged when we have implicit logging in PostError in services
			pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strOldKey, iType, *MsiString(*szDecrementValue));
		}
	}
	return 0;
}

// Registry operations

/*---------------------------------------------------------------------------
	ixoRegOpenKey: opens RegKey as sub key of RootRegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegOpenKey(IMsiRecord& riParams)
{
	using namespace IxoRegOpenKey;
	
	rrkEnum rrkRoot = (rrkEnum)riParams.GetInteger(Root);
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
	{
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
		if ( iType == ibtCommon )
			iType = g_fWinNT64 ? ibt64bit : ibt32bit;
	}
	PMsiRegKey pRootRegKey(0);
	MsiString strRootRegKey;
	
	MsiString strSIDKey;
	if(rrkRoot == rrkClassesRoot)
	{
		// HKCR is HKLM\S\C for machine assigned OR non DDSupportOLE machines
		// else HKCR is HKCU\S\C
		if((m_fFlags & SCRIPTFLAGS_MACHINEASSIGN) || IsDarwinDescriptorSupported(iddOLE) == fFalse)
			rrkRoot = rrkLocalMachine;
		else
			rrkRoot = rrkCurrentUser;
		m_state.strRegSubKey = szClassInfoSubKey;
	}
	else
	{
		if(rrkRoot == rrkUserOrMachineRoot)
		{
			// HKLM for machine assigned else HKCU
			if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
				rrkRoot = rrkLocalMachine;
			else
				rrkRoot = rrkCurrentUser;
		}
		m_state.strRegSubKey = TEXT("");
	}
	
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		// don't change HKCU
		if (rrkRoot == rrkCurrentUser)
		{
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			m_state.pRegKey = NULL;
			return iesNoAction;
		}
	}
	if(m_state.strRegSubKey.TextSize())
		m_state.strRegSubKey += szRegSep;
	m_state.strRegSubKey += MsiString(riParams.GetMsiString(Key));
	pRootRegKey = &m_riServices.GetRootKey(rrkRoot, iType);
	strRootRegKey = pRootRegKey->GetKey();
	
#ifdef DEBUG
	MsiString strSpace = TEXT(" ");
	if(m_state.strRegSubKey.Compare(iscStart, strSpace) ||
		m_state.strRegSubKey.Compare(iscEnd, strSpace))
		AssertSz(0, "Debug Warning...Key begins or ends with white space");
#endif // DEBUG
	m_state.rrkRegRoot = rrkRoot;
	m_state.iRegBinaryType = iType;
	m_state.pRegKey = &pRootRegKey->CreateChild(m_state.strRegSubKey, PMsiStream((IMsiStream*) riParams.GetMsiData(SecurityDescriptor)));       
	Assert(m_state.pRegKey);
	m_state.strRegKey = strRootRegKey; // strRegRootKey may not be the same key as pRegRootKey->GetKey()
	m_state.strRegKey += szRegSep;
	m_state.strRegKey += m_state.strRegSubKey;

	// generate undo record
	if(RollbackEnabled())
	{
		if((HKEY)rrkRoot == m_hKey || (m_hOLEKey && (HKEY)rrkRoot == m_hOLEKey) || 
			(m_hOLEKey64 && (HKEY)rrkRoot == m_hOLEKey64) || (m_hKeyRm && (HKEY)rrkRoot == m_hKeyRm) ||
			(m_hUserDataKey && (HKEY)rrkRoot == m_hUserDataKey))
		{
			// our/OLE  root for advertising
			// use m_hPublishRootKey/ m_hPublishRootKeyRm/ m_hPublishRootOLEKey and m_strPublishSubKey/ m_strPublishSubKeyRm/ m_strPublishOLESubKey to get true root and subkey
			IMsiRecord& riUndoParams = GetSharedRecord(Args);
			MsiString strSubKey;
			if((HKEY)rrkRoot == m_hKey)
			{
				Assert(m_hPublishRootKey);
#ifdef _WIN64   // !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)m_hPublishRootKey));
#else           // win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)m_hPublishRootKey));
#endif
				strSubKey = m_strPublishSubKey;
			}
			else if(m_hOLEKey && (HKEY)rrkRoot == m_hOLEKey ||
					  (m_hOLEKey64 && (HKEY)rrkRoot == m_hOLEKey64))
			{
				Assert(m_hPublishRootOLEKey);
#ifdef _WIN64   // !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)m_hPublishRootOLEKey));
#else           // win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)m_hPublishRootOLEKey));
#endif
				strSubKey = m_strPublishOLESubKey;
			}
			else if(m_hUserDataKey && (HKEY)rrkRoot == m_hUserDataKey)
			{
#ifdef _WIN64	// !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)HKEY_LOCAL_MACHINE));
#else			// win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)HKEY_LOCAL_MACHINE));
#endif
				strSubKey = m_strUserDataKey;
			}
			else
			{
				Assert(m_hKeyRm && (HKEY)rrkRoot == m_hKeyRm);
				Assert(m_hPublishRootKeyRm);
#ifdef _WIN64   // !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)m_hPublishRootKeyRm));
#else           // win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)m_hPublishRootKeyRm));
#endif
				strSubKey = m_strPublishSubKeyRm;
			}
			if(strSubKey.TextSize())
				strSubKey += szRegSep;
			strSubKey += MsiString(riParams.GetMsiString(Key));
			AssertNonZero(riUndoParams.SetMsiString(Key,*strSubKey));
			AssertNonZero(riUndoParams.SetInteger(BinaryType,iType));
			if (!RollbackRecord(Op,riUndoParams))
				return iesFailure;
		}
		else // assume rrkRoot is a valid root
		{
			if (!RollbackRecord(Op,riParams))
				return iesFailure;
		}
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixoRegAddValue: writes value to RegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegAddValue(IMsiRecord& riParams)
{
	using namespace IxoRegAddValue;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)

	CElevate elevate(m_istScriptType == istRollback);

	PMsiRecord pError(0);
	if(!m_state.pRegKey)
	{
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		// ixoRegOpenKey must not have been called
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegAddValue")));
		return iesFailure;
	}



	MsiString strName = riParams.GetMsiString(Name);
	MsiString strValue = riParams.GetMsiString(Value);
	int iAttributes = riParams.IsNull(Attributes) ? 0: riParams.GetInteger(Attributes);
	if(!riParams.IsNull(IxoRegAddValue::Args + 1))
	{
		strValue = GetSFN(*strValue, riParams, IxoRegAddValue::Args + 1);
	}

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetMsiString(2, *strName));
	AssertNonZero(riActionData.SetMsiString(3, *strValue));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	// get info for undo operation
	Bool fKeyExists = fFalse, fValueExists = fFalse;
	MsiString strOldValue;
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	if(fKeyExists)
	{
		if((pError = m_state.pRegKey->ValueExists(strName, fValueExists)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	if(fValueExists)
	{
		if(iAttributes & rwWriteOnAbsent) // we are writing info for a lesser component, skip if value already exists
			return iesNoAction;

		// get current value
		if((pError = m_state.pRegKey->GetValue(strName, *&strOldValue)) != 0) //!! need to determine if this is empty or null
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	// if we are writing to the per user HKCR (HKCU\S\C) AND the key under which we are creating the
	// value does not exist BUT the corr. key  in the per machine HKCR (HKLM\S\C) exists,
	// AND rwWriteOnAbsent attribute is set, then we should skip creating the key-value altogether
	// since this will then shadow the per machine HKCR.
	if(!fKeyExists && IsDarwinDescriptorSupported(iddOLE) && (iAttributes & rwWriteOnAbsent)
		&& m_state.rrkRegRoot == rrkCurrentUser && m_state.strRegSubKey.Compare(iscStartI, szClassInfoSubKey))
	{
		PMsiRegKey pRootRegKey = &m_riServices.GetRootKey(rrkLocalMachine, m_state.iRegBinaryType);
		PMsiRegKey pSubKey = &pRootRegKey->CreateChild(m_state.strRegSubKey);
		Bool fHKLMKeyExists = fFalse;
		if((pError = pSubKey->Exists(fHKLMKeyExists)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		if(fHKLMKeyExists)
			return iesNoAction;
	}


	iesEnum iesReturn = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry)
	{
		pError = m_state.pRegKey->SetValue(strName, *strValue);
		if(pError)
		{
			if(iAttributes & rwNonVital)
			{
				DispatchError(imtInfo, Imsg(imsgSetValueFailed), *strName, *m_state.strRegKey);
				iesReturn = iesSuccess; fRetry = fFalse;
			}
			else
			{
				switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), Imsg(imsgSetValueFailed),
											*strName,
											*m_state.strRegKey))
				{
				case imsRetry: continue;
				case imsIgnore:
					iesReturn = iesSuccess; fRetry = fFalse;
					break;
				default:
					iesReturn = iesFailure; fRetry = fFalse;  // imsAbort, imsNone
					break;
				};
			}
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	// generate undo operations
	
	if(fSuccess)
	{
		MsiString strSubKey = MsiString(m_state.pRegKey->GetKey());
		strSubKey.Remove(iseIncluding, chRegSep);
		
		IMsiRecord* piUndoParams = 0;
		
		if(fKeyExists)
		{
			// key existed
			if(fValueExists)
			{
				// value existed, write old value back - this will create the key also
				piUndoParams = &GetSharedRecord(IxoRegAddValue::Args);
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Name, *strName));
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Value, *strOldValue));  //!! need to specify null or empty
				if (!RollbackRecord(IxoRegAddValue::Op, *piUndoParams))
					return iesFailure;
			}
			else
			{
				// value didn't exist, but key did - create key to ensure it exists
				piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
				if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
					return iesFailure;
			}
		}
		else
		{
			// key didn't exist, remove key
			piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;
		}

		// remove new value
		piUndoParams = &GetSharedRecord(IxoRegRemoveValue::Args);
		AssertNonZero(piUndoParams->SetMsiString(IxoRegRemoveValue::Name, *strName));
		AssertNonZero(piUndoParams->SetMsiString(IxoRegRemoveValue::Value, *strValue));
		if (!RollbackRecord(IxoRegRemoveValue::Op, *piUndoParams))
			return iesFailure;
	}

	return iesReturn;
}

/*---------------------------------------------------------------------------
ixoRegRemoveValue: removes value from RegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegRemoveValue(IMsiRecord& riParams)
{
	using namespace IxoRegRemoveValue;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)
	CElevate elevate(m_istScriptType == istRollback);
	
	PMsiRecord pError(0);
	if(!m_state.pRegKey)
	{
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegRemoveValue")));
		return iesFailure;
	}
	MsiString strName = riParams.GetMsiString(Name);
	MsiString strValue = riParams.GetMsiString(Value);

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record

	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetMsiString(2, *strName));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// get info for undo operation
	Bool fKeyExists = fFalse, fValueExists = fFalse;
	MsiString strOldValue;
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	if(fKeyExists)
	{
		if((pError = m_state.pRegKey->ValueExists(strName, fValueExists)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}
	if(fValueExists)
	{
		// get current value
		if((pError = m_state.pRegKey->GetValue(strName, *&strOldValue)) != 0) //!! need to determine if this is empty or null
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	// remove value
	Bool fSuccess = fFalse;
	pError = m_state.pRegKey->RemoveValue(strName, strValue);
	if (pError)
	{
		DispatchError(imtInfo, Imsg(imsgRemoveValueFailed), *strName, *m_state.strRegKey);
	}
	else
		fSuccess = fTrue;

	// generate undo operations
	
	if(fSuccess)
	{
		MsiString strSubKey = MsiString(m_state.pRegKey->GetKey());
		strSubKey.Remove(iseIncluding, chRegSep);
		
		IMsiRecord* piUndoParams = 0;
		
		if(fKeyExists)
		{
			// key existed
			if(fValueExists)
			{
				// value existed, write old value back - this will create the key also
				piUndoParams = &GetSharedRecord(IxoRegAddValue::Args);
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Name, *strName));
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Value, *strOldValue));  //!! need to specify null or empty
				if (!RollbackRecord(IxoRegAddValue::Op, *piUndoParams))
					return iesFailure;
			}
			else
			{
				// value didn't exist, but key did - create key to ensure it exists
				piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
				if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
					return iesFailure;
			}
		}
		else
		{
			// key didn't exist, remove key
			piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;
		}
	}
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	ixoRegCreateKey: creates RegKey as sub key of RootRegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegCreateKey(IMsiRecord& /*riParams*/)
{
	using namespace IxoRegCreateKey;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)
	CElevate elevate(m_istScriptType == istRollback);
	
	if(!m_state.pRegKey)
	{
		// ixoRegOpenKey must not have been called
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegCreateKey")));
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetNull(2));
	AssertNonZero(riActionData.SetNull(3));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pError(0);
	Bool fKeyExists; // determines which undo op to use
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	iesEnum iesReturn = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry) // retry loop
	{
		pError = m_state.pRegKey->Create();
		if(pError)
		{
			switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), Imsg(imsgCreateKeyFailed),
										*m_state.strRegKey))
			{
			case imsRetry: continue;
			case imsIgnore:
				iesReturn = iesSuccess; fRetry = fFalse;
				break;
			default:
				iesReturn = iesFailure; fRetry = fFalse; //!!?? imsAbort, imsNone
				break;
			};
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	// generate undo operation
	if(fSuccess)
	{
		if(fKeyExists)
		{
			IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
			if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
				return iesFailure;
		}
		else
		{
			IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;

		}
	}
	return iesReturn;
}

iesEnum CMsiOpExecute::ixfRegRemoveKey(IMsiRecord& /*riParams*/)
{
	using namespace IxoRegRemoveKey;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)
	CElevate elevate(m_istScriptType == istRollback);

	if(!m_state.pRegKey)
	{
		// ixoRegOpenKey must not have been called
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegRemoveKey")));
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetNull(2));
	AssertNonZero(riActionData.SetNull(3));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pError(0);
	Bool fKeyExists; // determines which undo op to use
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	iesEnum iesReturn = iesNoAction;

	// traverse the key and put the undo ops in the rollback script
	if(fKeyExists && RollbackEnabled())
	{
		iesReturn = SetRemoveKeyUndoOps(*m_state.pRegKey);
		if(iesReturn != iesSuccess && iesReturn != iesNoAction)
			return iesReturn;
	}

	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry) // retry loop
	{
		pError = m_state.pRegKey->Remove();
		if(pError)
		{
			switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), Imsg(imsgRemoveKeyFailed),
										*m_state.strRegKey))
			{
			case imsRetry: continue;
			case imsIgnore:
				iesReturn = iesSuccess; fRetry = fFalse;
				break;
			default:
				iesReturn = iesFailure; fRetry = fFalse; //!!?? imsAbort, imsNone
				break;
			};
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	// generate undo operation
	if(fSuccess)
	{
		if(fKeyExists == fFalse)
		{
			// key didn't exist, undo operation should unsure it doesn't exist
			IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;
		}
		// else we did the CreateKey op in SetRemoveKeyUndoOps()
	}
	return iesReturn;
}

iesEnum CMsiOpExecute::ixfRegAddRunOnceEntry(IMsiRecord& riParams)
{
	// write 2 reg values:
	// szRunOnceKey:        value = Name, data = "/@ [Name]"
	// szRunOnceEntriesKey: value = Name, data = Command
	
	using namespace IxoRegAddRunOnceEntry;

	iesEnum iesRet = iesSuccess;
	PMsiRecord pError(0);

	// find server. If running on Win64, get the 64bit path, otherwise the 32 bit path. Because this is a service
	// opcode, we can always get the current type.
	MsiString strRunOnceCommand;
#ifdef _WIN64
	if((pError = GetServerPath(m_riServices, true, true, *&strRunOnceCommand)) != 0)
#else
	if((pError = GetServerPath(m_riServices, true, false, *&strRunOnceCommand)) != 0)
#endif
		return FatalError(*pError);
	Assert(strRunOnceCommand.TextSize());

	strRunOnceCommand += TEXT(" /");
	strRunOnceCommand += MsiChar(CHECKRUNONCE_OPTION);
	strRunOnceCommand += TEXT(" \"");
	strRunOnceCommand += MsiString(riParams.GetMsiString(Name));
	strRunOnceCommand += TEXT("\"");

	// write RunOnce entry
	PMsiRecord pOpenKeyParams = &CreateRecord(IxoRegOpenKey::Args);
	PMsiRecord pAddValueParams = &CreateRecord(IxoRegAddValue::Args);

	AssertNonZero(pOpenKeyParams->SetInteger(IxoRegOpenKey::Root, rrkLocalMachine));
	AssertNonZero(pOpenKeyParams->SetString(IxoRegOpenKey::Key, szRunOnceKey));
	if((iesRet = ixfRegOpenKey(*pOpenKeyParams)) != iesSuccess)
		return iesRet;

	AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Name, *MsiString(riParams.GetMsiString(Name))));
	AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Value, *strRunOnceCommand));
	if((iesRet = ixfRegAddValue(*pAddValueParams)) != iesSuccess)
		return iesRet;

	// write our own RunOnceEntries entry - so we know its OK to run the RunOnce command
	{

		CElevate elevate; // to write to our own key

		AssertNonZero(pOpenKeyParams->SetInteger(IxoRegOpenKey::Root, rrkLocalMachine));
		AssertNonZero(pOpenKeyParams->SetString(IxoRegOpenKey::Key, szMsiRunOnceEntriesKey));
		if((iesRet = ixfRegOpenKey(*pOpenKeyParams)) != iesSuccess)
			return iesRet;

		AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Name, *MsiString(riParams.GetMsiString(Name))));
		AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Value, *MsiString(riParams.GetMsiString(Command))));
		if((iesRet = ixfRegAddValue(*pAddValueParams)) != iesSuccess)
			return iesRet;
	
	}

	return iesSuccess;
}

iesEnum CMsiOpExecute::SetRegValueUndoOps(rrkEnum rrkRoot, const ICHAR* szKey,
														const ICHAR* szName, ibtBinaryType iType)
{
	// generates rollback ops to delete/restore a registry value
	// call before removing or overwriting a reg value

	PMsiRecord pError(0);
	
	PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkRoot, iType);
	PMsiRegKey pEntry = &pRoot->CreateChild(szKey);
	Bool fKeyExists = fFalse;
	pError = pEntry->Exists(fKeyExists); // ignore error

	IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegOpenKey::Args);
	AssertNonZero(piUndoParams->SetInteger(IxoRegOpenKey::Root, rrkRoot));
	AssertNonZero(piUndoParams->SetInteger(IxoRegOpenKey::BinaryType, iType));
	AssertNonZero(piUndoParams->SetString(IxoRegOpenKey::Key, szKey));
	if (!RollbackRecord(ixoRegOpenKey, *piUndoParams))
		return iesFailure;
	
	if(fKeyExists)
	{
		// key existed
		Bool fValueExists = fFalse;
		pError = pEntry->ValueExists(szName,fValueExists);
		if(fValueExists)
		{
			MsiString strOldValue;
			pError = pEntry->GetValue(szName,*&strOldValue);
			if(pError)
				return FatalError(*pError);

			// value existed, write old value back - this will create the key also
			piUndoParams = &GetSharedRecord(IxoRegAddValue::Args);
			AssertNonZero(piUndoParams->SetString(IxoRegAddValue::Name, szName));
			AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Value, *strOldValue));
			if (!RollbackRecord(IxoRegAddValue::Op, *piUndoParams))
				return iesFailure;
		}
		else
		{
			// value didn't exist, but key did - create key to ensure it exists
			piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
			if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
				return iesFailure;
		}
	}
	else
	{
		// key didn't exist, remove key
		piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
		if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
			return iesFailure;
	}

	// remove new value during rollback - not needed if just removing the value now but it doesn't hurt
	piUndoParams = &GetSharedRecord(IxoRegRemoveValue::Args);
	AssertNonZero(piUndoParams->SetString(IxoRegRemoveValue::Name, szName));
	if (!RollbackRecord(IxoRegRemoveValue::Op, *piUndoParams))
		return iesFailure;

	return iesSuccess;
}


iesEnum CMsiOpExecute::SetRemoveKeyUndoOps(IMsiRegKey& riRegKey)
{
	// assumes key exists
	
	if(RollbackEnabled() == fFalse)
		return iesSuccess;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	// An existing value causes an implied create on this regkey object,
	// allowing security to be set.
	// However, creating a subkey does not necessarily create this *object*
	// and security will not be set.  You must have the object created to
	// allow the security to be applied.
	bool fValue = false;
	
	PEnumMsiString pEnum(0);
	if((pError = riRegKey.GetSubKeyEnumerator(*&pEnum)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strTemp;
	while((pEnum->Next(1, &strTemp, 0)) == S_OK)
	{
		PMsiRegKey pKey = &riRegKey.CreateChild(strTemp);
		if((iesRet = SetRemoveKeyUndoOps(*pKey)) != iesSuccess) // recursive call
			return iesRet;
	}

	// generate undo ops for this key
	IMsiRecord& riParams = GetSharedRecord(IxoRegOpenKey::Args);

	MsiString strSubKey = riRegKey.GetKey();
	strSubKey.Remove(iseIncluding, chRegSep);
	
	//!! we can probably do this more efficiently
	if((HKEY)m_state.rrkRegRoot == m_hKey || (m_hOLEKey && (HKEY)m_state.rrkRegRoot == m_hOLEKey) ||
		(m_hOLEKey64 && (HKEY)m_state.rrkRegRoot == m_hOLEKey64) ||(m_hKeyRm && (HKEY)m_state.rrkRegRoot == m_hKeyRm))
	{
		// our/OLE  root for advertising
		// use m_hPublishRootKey/ m_hPublishRootKeyRm/ m_hPublishRootOLEKey and m_strPublishSubKey/ m_strPublishSubKeyRm/ m_strPublishOLESubKey to get true root and subkey
		MsiString strTrueSubKey;
		if((HKEY)m_state.rrkRegRoot == m_hKey)
		{
			Assert(m_hPublishRootKey);
#ifdef _WIN64   // !merced
			AssertNonZero(riParams.SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hPublishRootKey));
#else           // win-32
			AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root,(int)m_hPublishRootKey));
#endif
			strTrueSubKey = m_strPublishSubKey;
		}
		else if((m_hOLEKey && (HKEY)m_state.rrkRegRoot == m_hOLEKey) ||
				  (m_hOLEKey64 && (HKEY)m_state.rrkRegRoot == m_hOLEKey64))
		{
			Assert(m_hPublishRootOLEKey);
#ifdef _WIN64   // !merced
			AssertNonZero(riParams.SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hPublishRootOLEKey));
#else           //  win-32
			AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root,(int)m_hPublishRootOLEKey));
#endif
			strTrueSubKey = m_strPublishOLESubKey;
		}
		else
		{
			Assert(m_hKeyRm && (HKEY)m_state.rrkRegRoot == m_hKeyRm);
			Assert(m_hPublishRootKeyRm);
#ifdef _WIN64   // !merced
			AssertNonZero(riParams.SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hPublishRootKeyRm));
#else           // win-32
			AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root,(int)m_hPublishRootKeyRm));
#endif
			strTrueSubKey = m_strPublishSubKeyRm;
		}
		if(strTrueSubKey.TextSize())
			strTrueSubKey += szRegSep;
		strTrueSubKey += strSubKey;
		AssertNonZero(riParams.SetMsiString(IxoRegOpenKey::Key,*strTrueSubKey));
	}
	else // assume rrkRoot is a valid root
	{
		AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root, m_state.rrkRegRoot));
		AssertNonZero(riParams.SetMsiString(IxoRegOpenKey::Key, *strSubKey));
		PMsiStream piSD(0);
		pError = riRegKey.GetSelfRelativeSD(*&piSD);
		AssertNonZero(riParams.SetMsiData(IxoRegOpenKey::SecurityDescriptor, piSD));
	}
	AssertNonZero(riParams.SetInteger(IxoRegOpenKey::BinaryType, m_state.iRegBinaryType));
	if (!RollbackRecord(IxoRegOpenKey::Op, riParams))
		return iesFailure;
	
	if((pError = riRegKey.GetValueEnumerator(*&pEnum)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strValue;
	while((pEnum->Next(1, &strTemp, 0)) == S_OK)
	{
		if((pError = riRegKey.GetValue(strTemp,*&strValue)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		AssertNonZero(riParams.ClearData());
		AssertNonZero(riParams.SetMsiString(IxoRegAddValue::Name, *strTemp));
		AssertNonZero(riParams.SetMsiString(IxoRegAddValue::Value, *strValue));
		if (!RollbackRecord(IxoRegAddValue::Op, riParams))
			return iesFailure;
		fValue = true;
	}

	if(!fValue)
	{
		// no values on this key.  It would be created by a subkey,
		// but it might not have had its security applied.

		AssertNonZero(riParams.ClearData());
		if (!RollbackRecord(IxoRegCreateKey::Op, riParams))
			return iesFailure;
	}
	
	return iesSuccess;
}

iesEnum CMsiOpExecute::ProcessSelfReg(IMsiRecord& riParams, Bool fReg)
{
	using namespace IxoRegSelfReg;
	if(!m_state.pTargetPath)
	{  // must not have called ixoSetTargetFolder
		// this is never done during rollback, so we don't need to worry about checking for a changed user
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
			(fReg != fFalse) ? *MsiString(*TEXT("ixoRegSelfReg")) : *MsiString(*TEXT("ixoRegSelfUnReg")));
		return iesFailure;
	}
	PMsiRecord pError(0);

	IMsiRecord& riActionData = GetSharedRecord(2);  // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *MsiString(riParams.GetMsiString(1))));
	AssertNonZero(riActionData.SetMsiString(2, *MsiString(m_state.pTargetPath->GetPath())));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	MsiString strFullFileName;
	if((pError = m_state.pTargetPath->GetFullFilePath(MsiString(riParams.GetMsiString(1)),
																	  *&strFullFileName)))
	{
		return FatalError(*pError);
	}

	// per bug 5342 we elevate self-reg (icaNoImpersonate) for managed apps.
	// Note: this will cause selfregs that access the net to fail. if a self-reg
	// needs to access the net it must be written as a custom action

	iesEnum iesRet = iesSuccess;
	Bool fRetry = fTrue;
	while(fRetry)
	{
		IMsiRecord& riCARec = GetSharedRecord(IxoCustomActionSchedule::Args);
		int icaFlags = icaNoTranslate | icaInScript | icaExe | icaProperty;

		// set the File_ value from the File table for use in AppCompat checks
		MsiString strFileId;
		strFileId += (fReg ? TEXT("+") : TEXT("-"));
		strFileId += MsiString(riParams.GetMsiString(2));
		riCARec.SetMsiString(IxoCustomActionSchedule::Action, *strFileId);

		if (!IsImpersonating()) // if we're not impersonating then we don't want the self-reg to impersonate
		{
			if(FVolumeRequiresImpersonation(*PMsiVolume(&m_state.pTargetPath->GetVolume())))
				icaFlags |= icaSetThreadToken; // so we can access the net from msiexec.exe

			icaFlags |= icaNoImpersonate;
		}

		riCARec.SetInteger(IxoCustomActionSchedule::ActionType, icaFlags);

		// determine if the self-reg DLL is 64bit or 32bit. Don't need to do this check on non-64 platforms.
		bool fIs64Bit = false;
		if (g_fWinNT64)
		{
			if ((pError = m_state.pTargetPath->IsPE64Bit(MsiString(riParams.GetMsiString(1)), fIs64Bit)) != 0 &&
				 // for appcompat reasons (Windows bug 645929), we better ignore this error here
				 !(pError->GetInteger(1) == idbgErrorOpeningFile && pError->GetInteger(2) == ERROR_FILE_NOT_FOUND))
			{
				return FatalError(*pError);
			}
		}

		MsiString strServerPath;
		if((pError = GetServerPath(m_riServices,false,fIs64Bit,*&strServerPath)) != 0)
		{
			return FatalError(*pError);
		}
		Assert(strServerPath.TextSize());
		riCARec.SetMsiString(IxoCustomActionSchedule::Source, *strServerPath);

		
		MsiString strCommandLine = MsiChar('/');
		if(fReg)
			strCommandLine += MsiChar(SELF_REG_OPTION);
		else
			strCommandLine += MsiChar(SELF_UNREG_OPTION);
		
		strCommandLine += TEXT(" \"");
		strCommandLine += strFullFileName;
		strCommandLine += TEXT("\"");
		riCARec.SetMsiString(IxoCustomActionSchedule::Target, *strCommandLine);

		GUID guidAppCompatID;
		GUID guidAppCompatDB;
		HRESULT hr = (HRESULT) ENG::ScheduledCustomAction(riCARec, *MsiString(GetProductKey()), (LANGID)GetProductLanguage(), m_riMessage, m_fRunScriptElevated, GetAppCompatCAEnabled(), GetAppCompatDB(&guidAppCompatDB), GetAppCompatID(&guidAppCompatID));
		if(!SUCCEEDED(hr)) //!! is this the right check - maybe we should ceck NOERROR (0)
		{
			IErrorCode imsg;
			if(fReg)
				imsg = Imsg(imsgOpRegSelfRegFailed);
			else
				imsg = Imsg(imsgOpRegSelfUnregFailed);
			if(!fReg)
			{
				// simply log the failure
				DispatchError(imtInfo, imsg, (const ICHAR*)strFullFileName, hr);
				fRetry = fFalse;
			}
			else
			{
				switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore), imsg,
						 (const ICHAR*)strFullFileName, hr))
				{
				case imsRetry: break; // will continue, but may need to FreeLibrary before retry
				case imsIgnore:
					iesRet = iesSuccess; fRetry = fFalse; break;
				default:
					iesRet = iesFailure; fRetry = fFalse; break; // imsAbort, imsNone
				}
			}
		}
		else
			fRetry = fFalse;
	}
	
	return iesRet;
}

bool CMsiOpExecute::IsChecksumOK(IMsiPath& riFilePath, const IMsiString& ristrFileName,
											IErrorCode iErr, imsEnum* imsUsersChoice,
											bool fErrorDialog, bool fVitalFile, bool fRetryButton)
{
	bool fReturn = true;
	PMsiRecord pError(0);
	DWORD dwHeaderSum, dwComputedSum;
	bool fDamagedFile = false;

	pError = riFilePath.GetFileChecksum(ristrFileName.GetString(), &dwHeaderSum, &dwComputedSum);
	if ( pError && pError->GetInteger(1) == idbgErrorNoChecksum )
	{
		// this can happen in the case when there's no checksum in the file
		// or the file is badly damaged.
		pError = 0;
		fDamagedFile = true;
	}
	if ( pError )
	{
		fReturn = false;
		if ( !fErrorDialog )
		{
			DispatchError(imtInfo, Imsg(idbgOpCRCCheckFailed), ristrFileName);
			pError = 0; // prevents the error dialog from getting displayed below.
		}
	}
	else if ( dwHeaderSum != dwComputedSum ||
				 fDamagedFile )
	{
		fReturn = false;
		if ( !fErrorDialog )
			DispatchError(imtInfo, Imsg(idbgInvalidChecksum), ristrFileName,
							  *MsiString((int)dwHeaderSum), *MsiString((int)dwComputedSum));
		else
			// causes the error dialog to get displayed.
			pError = PostError(iErr, ristrFileName.GetString());
	}
	
	imsEnum imsRet = imsNone; // initialized for the above cases where !fErrorDialog
	if ( pError )
	{
		Assert(!fReturn);
		imtEnum imtButtons;
		if ( fRetryButton )
			imtButtons = imtEnum(fVitalFile ? imtRetryCancel + imtDefault1 :
														 imtAbortRetryIgnore + imtDefault2);
		else
			imtButtons = imtEnum((fVitalFile ? imtOk : imtOkCancel) + imtDefault1);
		imsRet = DispatchMessage(imtEnum(imtError+imtButtons), *pError, fTrue);
	}
	
	if ( !fReturn && imsUsersChoice )
		*imsUsersChoice = imsRet;

	return fReturn;
}

/*---------------------------------------------------------------------------
ixoRegSelfReg: calls SelfReg function of file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegSelfReg(IMsiRecord& riParams)
{
	return ProcessSelfReg(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ixoRegSelfReg: calls SelfUnreg function of file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegSelfUnreg(IMsiRecord& riParams)
{
	return ProcessSelfReg(riParams, fFalse);
}

/*---------------------------------------------------------------------------
ixoFileBindImage: calls BindImage function of services
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFileBindImage(IMsiRecord& riParams)
{
	using namespace IxoFileBindImage;
	if(!m_state.pTargetPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoBindImage")));
		return iesFailure;
	}
	PMsiRecord pError(0);

	// determine if the target file was previously copied to a temporary location
	MsiString strTemp;
	if((pError = m_state.pTargetPath->GetFullFilePath(riParams.GetString(File),*&strTemp)) != 0)
		return FatalError(*pError);

	MsiString strTempLocation;
	icfsEnum icfsFileState = (icfsEnum)0;
	Bool fRes = GetFileState(*strTemp, &icfsFileState, &strTempLocation, 0, 0);

	// if we didn't install or patch this file, skip the binding
	// (its assumed it was done when the file WAS installed or patched last)
	if(((icfsFileState & icfsFileNotInstalled) != 0) &&
		((icfsFileState & icfsPatchFile) == 0))
	{
		// didn't actually install this file, so we assume it has already been bound
		DEBUGMSG1(TEXT("Not binding file %s because it wasn't installed or patched in this install session"),strTemp);
		return iesNoAction;
	}

	// if file is protected, don't bind - SFP would replace file anyway
	if (icfsFileState & icfsProtected)
	{
		DEBUGMSG1(TEXT("Not binding file %s because it is protected by Windows"),strTemp);
		return iesNoAction;
	}
		
	PMsiPath pTargetPath(0);
	MsiString strTargetFileName;
	
	if(strTempLocation.TextSize())
	{
		DEBUGMSG2(TEXT("File %s actually installed to %s, binding temp copy."),strTemp,strTempLocation);
		if((pError = m_riServices.CreateFilePath(strTempLocation,*&pTargetPath,*&strTargetFileName)) != 0)
			return FatalError(*pError);
	}
	else
	{
		pTargetPath = m_state.pTargetPath;
		strTargetFileName = riParams.GetMsiString(File);
	}

	// now pTargetPath and strTargetFileName point to the correct target file
	IMsiRecord& riActionData = GetSharedRecord(2);  // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strTargetFileName));
	AssertNonZero(riActionData.SetMsiString(2, *MsiString(pTargetPath->GetPath())));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord piError(0);
	if ( msidbFileAttributesChecksum == 
		  (riParams.GetInteger(FileAttributes) & msidbFileAttributesChecksum) )
	{
		if ( !IsChecksumOK(*pTargetPath, *strTargetFileName,
								 0, 0,
								 /* fErrorDialog = */ false, /* fVitalFile = */ false,
								 /* fRetryButton = */ false) )
		{
			DispatchError(imtInfo, Imsg(idbgOpImageNotBound), *strTargetFileName);
			return (iesEnum)iesErrorIgnored;
		}
	}

	MsiDisableTimeout();
	piError = pTargetPath->BindImage(*strTargetFileName,
												*MsiString(riParams.GetMsiString(Folders)));
	MsiEnableTimeout();
	if (piError)//?? only in the debug mode
	{
		//AssertSz(0, TEXT("Could not BindImage file"));
		DispatchError(imtInfo, Imsg(idbgOpBindImage), *strTargetFileName);
	}
	return iesSuccess;
}

// Shortcut operations

iesEnum CMsiOpExecute::CreateFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation, IMsiStream* pSD)
{
	int cCreatedFolders = 0;
	// create any non-existent folders
	PMsiRecord pRecErr(0);

	while((pRecErr = riPath.EnsureExists(&cCreatedFolders)) != 0)
	{

		switch(DispatchMessage(imtEnum(imtError+imtRetryCancel+imtDefault1), *pRecErr, fTrue))
		{
		case imsRetry:  continue;
		case imsCancel: return iesUserExit;
		default:        return iesFailure;
		};
		break;
	}

	if (pSD)
	{
		// set security on the folder
		CTempBuffer<char, cbDefaultSD> pchSD;
		
		pSD->Reset();

		int cbSD = pSD->GetIntegerValue();
		if (cbDefaultSD < cbSD)
			pchSD.SetSize(cbSD);
			
		// Self Relative Security Descriptor
		pSD->GetData(pchSD, cbSD);
		AssertNonZero(WIN::IsValidSecurityDescriptor(pchSD));


		SECURITY_INFORMATION siAvailable = GetSecurityInformation(pchSD);
		BOOL fSuccess = TRUE;
		MsiString strPath = riPath.GetPath();
		if (m_ixsState == ixsRollback)
		{
			CElevate elevate;
			CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);
			
			fSuccess = WIN::SetFileSecurity((const ICHAR*) strPath, siAvailable, pchSD);
		}
		else
		{
			fSuccess = WIN::SetFileSecurity((const ICHAR*) strPath, siAvailable, pchSD);
		}
		if(!fSuccess)
		{
			DispatchError(imtError,Imsg(imsgOpSetFileSecurity), GetLastError(), strPath);
			return iesFailure;
		}
	}

	// register created folders
	if(cCreatedFolders && !fForeign && !(istAdminInstall == m_istScriptType))
	{
		PMsiPath pTempPath(0);
		pRecErr = riPath.ClonePath(*&pTempPath);
		if (pRecErr)
		{
			Message(imtError, *pRecErr);
			return iesFailure;
		}
		for(int i=0;i<cCreatedFolders;i++)
		{
			pRecErr = m_riConfigurationManager.RegisterFolder(*pTempPath, fExplicitCreation);
			if (pRecErr)
			{
				Message(imtInfo, *pRecErr);

				// Bug 9966
				// when we run out of space under a key in Win9X, the register folder is going to start
				// dying.  For simplicity, we'll ignore this error on all platforms.
				// The lResult returned in the error record is ERROR_OUTOFMEMORY
				Assert(g_fWin9X);
			}
			AssertZero(pTempPath->ChopPiece());
		}
	}
	//!! do we do any cleanup if RegisterFolder fails?
	return iesSuccess;
}

iesEnum RemoveFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation,
							IMsiConfigurationManager& riConfigManager, IMsiMessage& riMessage)
{
	PMsiPath pTempPath(0);
	PMsiRecord pRecErr = riPath.ClonePath(*&pTempPath);
	if (pRecErr)
	{
		riMessage.Message(imtError, *pRecErr);
		return iesFailure;
	}
	MsiString strFolder = pTempPath->GetEndSubPath();
	while(strFolder.TextSize())
	{
		Bool fRemovable = fTrue;
		if (!fForeign)
			pRecErr = riConfigManager.IsFolderRemovable(*pTempPath, fExplicitCreation, fRemovable);

		if (pRecErr)
		{
			riMessage.Message(imtError, *pRecErr);
			return iesFailure;
		}
		if(fRemovable)
		{
			Bool fRetry = fTrue;
			while(fRetry)
			{
				pRecErr = pTempPath->Remove(0);
				if (pRecErr)
				{
					pRecErr = &CreateRecord(2);
					ISetErrorCode(pRecErr, Imsg(idbgOpRemoveFolder));
					pRecErr->SetMsiString(2, *MsiString(pTempPath->GetPath()));
					riMessage.Message(imtInfo, *pRecErr);
					fRetry = fFalse;
/*                  switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3),
												Imsg(idbgOpRemoveFolder),
												*MsiString(pTempPath->GetPath())))
					{
					case imsAbort:  return iesUserExit;
					case imsRetry:  continue;
					case imsIgnore: fRetry = fFalse; break;  //!! schedule for deletion on reboot???
					default:        fRetry = fFalse; break;  // imsNone //!! do we want to fail here?
					};
*/
				}
				else
					fRetry = fFalse;
			}
		}

		Bool fExists = fFalse;
		pRecErr = pTempPath->Exists(fExists);
		if (pRecErr)
		{
			riMessage.Message(imtError, *pRecErr);
			return iesFailure;
		}
		if(fRemovable && !fExists)
		{
			pRecErr = riConfigManager.UnregisterFolder(*pTempPath);
			if (pRecErr)
			{
				riMessage.Message(imtError, *pRecErr);
				return iesFailure;
			}
		}
		if(fExists || fForeign)
			break; // folder still exists, can't remove any parent folders

		pTempPath->ChopPiece();
		strFolder = pTempPath->GetEndSubPath();
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::RemoveFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation)
{
	return ::RemoveFolder(riPath, fForeign, fExplicitCreation, m_riConfigurationManager, m_riMessage);
}
	
iesEnum CMsiOpExecute::FileCheckExists(const IMsiString& ristrName, const IMsiString& ristrPath)
{
	PMsiPath piPath(0);
	PMsiRecord pRecErr = m_riServices.CreatePath(ristrPath.GetString(), *&piPath);
	if (pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	Bool fExists;
	pRecErr = piPath->FileExists(ristrName.GetString(), fExists);
	if (pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	if (!fExists)
	{
		MsiString strFullPath;
		PMsiRecord(piPath->GetFullFilePath(ristrName.GetString(), *&strFullPath));
		DispatchError(imtError, Imsg(idbgOpFileMissing),
						  *strFullPath);
		return iesFailure;
	}
	return iesSuccess;
}



//!! for fonts registration - should be put in central location!!
static const ICHAR* WIN_INI = TEXT("WIN.INI");
static const ICHAR* REGKEY_WIN_95_FONTS = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fonts");
static const ICHAR* REGKEY_WIN_NT_FONTS = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts");

iesEnum CMsiOpExecute::ixfFontRegister(IMsiRecord& riParams)
{
	using namespace IxoFontRegister;
	// m_state.pTargetPath may be 0 to indicate the file is in the default font folder
	if (!m_state.pTargetPath && (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback)))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}
	return ProcessFont(riParams, fFalse);
}

iesEnum CMsiOpExecute::ixfFontUnregister(IMsiRecord& riParams)
{
	using namespace IxoFontUnregister;
	
	if (!m_state.pTargetPath && (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback)))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}
	return ProcessFont(riParams, fTrue);
}

iesEnum CMsiOpExecute::ProcessFont(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoFontRegister; // same as IxoFontUnregister

	MsiString strTitle = riParams.GetMsiString(Title);
	MsiString strFont = riParams.GetMsiString(File);
	IMsiRecord& riActionData = GetSharedRecord(1);
	AssertNonZero(riActionData.SetMsiString(1, *strFont));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pRecErr(0);
		
	iesEnum iesRet = iesNoAction;
	bool fSuccess = true;
	MsiString strOldFont; // old font for rollback
	bool fRegistered = false;
	PMsiPath pOldFontPath(0);

	for(;;)
	{
		fSuccess = true;
		//!! fInUse is a misnomer - should actually be called fFileNotCopied
		bool fInUse = false;
		// if font title not specified, get the font title from the file
		if(!strTitle.TextSize())
		{
			Assert(strFont.TextSize()); // we expect the font file to have been specified
			MsiString strFullFilePath;
			MsiString strTitleInTTFFile;
			if((pRecErr = (m_state.pTargetPath)->GetFullFilePath(strFont, *&strFullFilePath)) != 0)
			{
				Message(imtInfo, *pRecErr);
				fSuccess = false;
			}
			else
			{
				if(!fRemove)
				{
					icfsEnum icfsFileState = (icfsEnum)0;
					MsiString strTempLocation;
					AssertNonZero(GetFileState(*strFullFilePath, &icfsFileState, &strTempLocation, 0, 0));
					if(icfsFileState & icfsFileNotInstalled) // was the file actually copied???
						fInUse = true;

					if(strTempLocation.TextSize())
					{
						DEBUGMSG2(TEXT("Font File %s actually installed to %s, getting font title from temp copy."),strFullFilePath,strTempLocation);
						strFullFilePath = strTempLocation;
						fInUse = true;
					}
				}

				if(FGetTTFTitle(strFullFilePath, *&strTitleInTTFFile) && strTitleInTTFFile.TextSize())
					strTitle = strTitleInTTFFile;
				else
				{
					// cannot set the font title
					DEBUGMSG1(TEXT("Cannot get the font title for %s."), strFont);
					fSuccess = false;
				}
			}
		}

		if(fSuccess)
		{
			// check if font is already registered
			const ICHAR* szKey = g_fWin9X ? REGKEY_WIN_95_FONTS : REGKEY_WIN_NT_FONTS;
			MsiString strOldFontPath;

			PMsiRegKey pRegKeyRoot = &m_riServices.GetRootKey(rrkLocalMachine, ibtCommon);
			PMsiRegKey pRegKey = &(pRegKeyRoot->CreateChild(szKey));
			if((pRecErr =  pRegKey->GetValue(strTitle, *&strOldFontPath)) == 0 && strOldFontPath.TextSize())
			{
				if(ENG::PathType(strOldFontPath) == iptFull)
				{
					if((pRecErr = m_riServices.CreateFilePath(strOldFontPath,*&pOldFontPath,*&strOldFont)) != 0)
						Message(imtInfo, *pRecErr);
					else
						fRegistered = true;
				}
				else
				{
					strOldFont = strOldFontPath;
					fRegistered = true;
				}
			}
		
			if(!fRemove)
				pRecErr = m_riServices.RegisterFont(strTitle,strFont, m_state.pTargetPath, fInUse);
			else
				pRecErr = m_riServices.UnRegisterFont(strTitle);
			if (pRecErr)
			{
				Message(imtInfo, *pRecErr);
				fSuccess = false;
			}
			else
			{
				m_fFontRefresh = true; // flag to send the font change message at the end of the install
				if(g_fWin9X && !m_fResetTTFCache) // we need to set up the deletion of the cached folder if fonts installed (on Win9x only)
				{
					// Construct the full pathname of the ttfCache file.
					TCHAR szPathnamettfCache[MAX_PATH];
					MsiGetWindowsDirectory(szPathnamettfCache, MAX_PATH);
					PMsiPath pPath(0);
					MsiString strttfCache = *TEXT("ttfCache");
					pRecErr = m_riServices.CreatePath(szPathnamettfCache, *&pPath);
					if (pRecErr)
					{
						Message(imtInfo, *pRecErr);
						fSuccess = false;
					}
					else
					{
						MsiString strFullPathttfCache;
						pRecErr = pPath->GetFullFilePath(strttfCache, *&strFullPathttfCache);
						if (pRecErr)
						{
							Message(imtInfo, *pRecErr);
							fSuccess = false;
						}
						else if(ReplaceFileOnReboot(strFullPathttfCache, 0)) //!!
							m_fResetTTFCache = true; // so that we dont do this again
						else
							fSuccess = false;
					}
				}
			}
		}

		if(!fSuccess)
		{
			if(!fRemove)
			{
				switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3),
						 Imsg(imsgOpRegFont),
						 *strTitle))
					{
					case imsRetry:  continue;
					case imsIgnore:
						iesRet = iesSuccess; break;
					default:
						iesRet = iesFailure; break; // imsAbort, imsNone
					}
			}
			else
			{
				DispatchError(imtInfo, Imsg(imsgOpUnregFont), *strTitle);
				iesRet = iesSuccess;
			}
		}
		break;
	}

	// generate undo op
	if(fSuccess)
	{
		if(fRegistered)
		{
			// re-register old font on rollback
			IMsiRecord* piSTFUndoParams = 0;
			if((pOldFontPath && !m_state.pTargetPath) ||
				(!pOldFontPath && m_state.pTargetPath) ||
				(pOldFontPath && m_state.pTargetPath &&
				(0 == MsiString(pOldFontPath->GetPath()).Compare(iscExactI, MsiString(m_state.pTargetPath->GetPath())))))
			{
				piSTFUndoParams = &GetSharedRecord(IxoSetTargetFolder::Args);
				if(pOldFontPath)
					AssertNonZero(piSTFUndoParams->SetMsiString(IxoSetTargetFolder::Folder,
																			  *MsiString(pOldFontPath->GetPath())));
				else
					AssertNonZero(piSTFUndoParams->SetNull(IxoSetTargetFolder::Folder));
				if (!RollbackRecord(ixoSetTargetFolder, *piSTFUndoParams))
					return iesFailure;
			}

			IMsiRecord* piFRUndoParams = &GetSharedRecord(IxoFontRegister::Args);
			AssertNonZero(piFRUndoParams->SetMsiString(IxoFontRegister::Title,*strTitle));
			AssertNonZero(piFRUndoParams->SetMsiString(IxoFontRegister::File,*strOldFont));
			if (!RollbackRecord(ixoFontRegister, *piFRUndoParams))
				return iesFailure;

			if(piSTFUndoParams)
			{
				if(m_state.pTargetPath)
				AssertNonZero(piSTFUndoParams->SetMsiString(IxoSetTargetFolder::Folder,
																		  *MsiString(m_state.pTargetPath->GetPath())));
				else
					AssertNonZero(piSTFUndoParams->SetNull(IxoSetTargetFolder::Folder));
				if (!RollbackRecord(ixoSetTargetFolder, *piSTFUndoParams))
					return iesFailure;
			}
		}
		if(!fRemove)
		{
			// unregister new font on rollback
			IMsiRecord* piFUUndoParams = &GetSharedRecord(IxoFontUnregister::Args);
			AssertNonZero(piFUUndoParams->SetMsiString(IxoFontUnregister::Title,*strTitle));
			AssertNonZero(piFUUndoParams->SetMsiString(IxoFontUnregister::File,*strFont));
			if (!RollbackRecord(ixoFontUnregister, *piFUUndoParams))
				return iesFailure;
		}
	}

	return iesRet;
}


// Ini file operations

Bool IniKeyExists(IMsiPath* piPath, const ICHAR* szFile, const ICHAR* szSection, const ICHAR* szKey)
{
    Assert(szFile && szSection && szKey);
    if(!(*szKey))
        return fFalse;
    PMsiRecord pError(0);
    Bool fWinIni;
    int icurrLen = 100;
    CTempBuffer<ICHAR,100> rgBuffer;
    ICHAR* szDefault = TEXT("");
    MsiString strFullFilePath;
    if((!IStrCompI(szFile, WIN_INI)) && (piPath == 0))
    {
        // WIN.INI
        fWinIni = fTrue;
    }
    else
    {
        // not WIN.INI
        fWinIni = fFalse;
        if(piPath != 0)
        {
            pError = piPath->GetFullFilePath(szFile, *&strFullFilePath);
            if(pError != 0)
                return fFalse;
        }
    }
    for(;;)
    {
        rgBuffer.SetSize(icurrLen); // add space to append new value
		if ( ! (ICHAR *) rgBuffer )
			return fFalse;
        int iret;
        if(fWinIni)
        {
            iret = GetProfileString(szSection,       // address of section name
                                    0,   // address of key name
                                    szDefault,       // address of default string
                                    rgBuffer,        // address of destination buffer
                                    icurrLen); // size of destination buffer
        }
        else
        {
            iret = GetPrivateProfileString(szSection,       // address of section name
                                            0,   // address of key name
                                            szDefault,       // address of default string
                                            rgBuffer,        // address of destination buffer
                                            icurrLen, // size of destination buffer
                                            strFullFilePath); // .INI file
        }
        if((icurrLen - 2) != iret)
            // sufficient memory
            break;
        icurrLen += 100;
    }

	// check if key exists in section
	MsiString strCurrentKey;
	ICHAR* pch = rgBuffer;
	while(*pch != 0)
	{
		if(IStrCompI(pch, szKey) == 0)
			return fTrue;
		else
			pch += IStrLen(pch) + 1;
	}
	return fFalse;
}

/*---------------------------------------------------------------------------
ixoIniWriteRemoveValue: writes or removes value from .ini file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIniWriteRemoveValue(IMsiRecord& riParams)
{
	using namespace IxoIniWriteRemoveValue;
	PMsiRecord pError(0);
	
	MsiString strSection = riParams.GetMsiString(Section);
	MsiString strKey = riParams.GetMsiString(Key);
	MsiString strValue = riParams.GetMsiString(Value);
	if(!riParams.IsNull(IxoIniWriteRemoveValue::Args + 1))
	{
		strValue = GetSFN(*strValue, riParams, IxoIniWriteRemoveValue::Args + 1);
	}

	iifIniMode iif = (iifIniMode)riParams.GetInteger(Mode);

	// m_state.pIniPath may be null, and that's OK
	IMsiRecord& riActionData = GetSharedRecord(4);
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strIniFile)));
	AssertNonZero(riActionData.SetMsiString(2, *strSection));
	AssertNonZero(riActionData.SetMsiString(3, *strKey));
	AssertNonZero(riActionData.SetMsiString(4, *strValue));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// gather information for undo op
	Bool fKeyExists = fFalse, fTagExists = fFalse;
	MsiString strOldLine;
	// check if key exists
	if((pError = m_riServices.ReadIniFile(m_state.pIniPath,
													  m_state.strIniFile,
													  strSection,
													  strKey,
													  0, *&strOldLine)) != 0)
	{
		Message(imtError, *pError); //!!
		return iesFailure;
	}
	if(strOldLine.TextSize() || IniKeyExists(m_state.pIniPath,m_state.strIniFile,strSection,strKey))
	{
		fKeyExists = fTrue;
	}
	if(fKeyExists && (iif == iifIniAddTag || iif == iifIniRemoveTag))
	{
		MsiString strValueStart = strValue;
		strValueStart += TEXT(",");
		MsiString strValueEnd = TEXT(",");
		strValueEnd += strValue;
		MsiString strValueMiddle = strValueEnd;
		strValueMiddle += TEXT(",");
		if(strOldLine.Compare(iscExactI,strValue) ||
			strOldLine.Compare(iscStartI,strValueStart) ||
			strOldLine.Compare(iscEndI,strValueEnd) ||
			strOldLine.Compare(iscWithinI,strValueMiddle))
			fTagExists = fTrue;
	}

	iesEnum iesRet = iesSuccess;
	if((iif == iifIniAddLine || iif == iifIniCreateLine || iif == iifIniAddTag) && (m_state.pIniPath))
	{
		iesRet = CreateFolder(*m_state.pIniPath);
	}
	
	MsiString strPath;
	if(m_state.pIniPath)
		strPath = m_state.pIniPath->GetPath();
	Bool fRetry = fTrue, fSuccess = fFalse;
	if(iesRet == iesSuccess)
	{
		while(fRetry)
		{
			pError = m_riServices.WriteIniFile(m_state.pIniPath,
														  m_state.strIniFile,
														  strSection,
														  strKey,
														  strValue,
														  iif);
			if(pError)
			{
				switch(DispatchError(imtEnum(imtError+imtRetryCancel+imtDefault1), Imsg(imsgOpUpdateIni),
											*strPath,
											*m_state.strIniFile))
				{
				case imsRetry: continue;
				default:
					iesRet = iesFailure; fRetry = fFalse;  // imsCancel, imsNone
					break;
				};
			}
			else
			{
				iesRet = iesSuccess;
				fSuccess = fTrue;
				fRetry = fFalse;
			}
		}
	}
	
	if (fSuccess && IsTerminalServerInstalled() && g_iMajorVersion >= 5 && m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
	{
		MsiString strFullPath;
		TCHAR szWindowsFolder[MAX_PATH];
		MsiGetWindowsDirectory(szWindowsFolder, MAX_PATH);
		strFullPath += szWindowsFolder;

		// NT5 Hydra installs should notify the system if the INI file is in the WindowsFolder
		// so it can be propogated to each user's private Windows folder.
		bool fIsWindowsFolder = (m_state.pIniPath == 0);
		if (!fIsWindowsFolder)
		{
			PMsiPath pWinPath(0);
			if (PMsiRecord(m_riServices.CreatePath(szWindowsFolder, *&pWinPath)) == 0)
			{
				ipcEnum ipcWinDir;
				m_state.pIniPath->Compare(*pWinPath, ipcWinDir);
				fIsWindowsFolder = (ipcEqual == ipcWinDir);
			}
		}

		if (fIsWindowsFolder)
		{
			// generate the full filename
			if (!strFullPath.Compare(iscEnd, TEXT("\\")))
				strFullPath += TEXT("\\");
			strFullPath += m_state.strIniFile;

			TSAPPCMP::TermsrvLogInstallIniFileEx(CConvertString(strFullPath));
		}
	}

	if(fSuccess && (iif == iifIniRemoveLine || iif == iifIniRemoveTag) && (m_state.pIniPath))
	{
		if((iesRet = RemoveFolder(*m_state.pIniPath)) != iesSuccess)
			return iesRet;
	}

	// generate undo op
	if(fSuccess) // everything worked
	{
		IMsiRecord& riUndoParams = GetSharedRecord(Args);
		AssertNonZero(riUndoParams.SetMsiString(Section, *strSection));
		AssertNonZero(riUndoParams.SetMsiString(Key, *strKey));
		if(iif == iifIniAddLine || iif == iifIniCreateLine || iif == iifIniRemoveLine)
		{
			if(fKeyExists && iif != iifIniCreateLine)
			{
				// generate op to add back old line
				AssertNonZero(riUndoParams.SetMsiString(Value,*strOldLine));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniAddLine));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
			if(iif != iifIniRemoveLine)
			{
				// generate op to remove line we just added
				AssertNonZero(riUndoParams.SetMsiString(Value,*strValue));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniRemoveLine));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
		}
		else // iifIniAddTag, iifIniRemoveTag
		{
			if(fTagExists)
			{
				// generate op to add back old tag //!! don't need this
				AssertNonZero(riUndoParams.SetMsiString(Value,*strValue));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniAddTag));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
			if(iif != iifIniRemoveTag)
			{
				// generate op to remove tag we just added
				AssertNonZero(riUndoParams.SetMsiString(Value,*strValue));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniRemoveTag));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
		}
	}

	return iesRet;
}

/*---------------------------------------------------------------------------
ixoIniFilePath - sets .ini filename and path, path may be NULL
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIniFilePath(IMsiRecord& riParams)
{
	using namespace IxoIniFilePath;
	PMsiRecord pError(0);
	if(MsiString(riParams.GetMsiString(2)).TextSize())
	{
		if((pError = m_riServices.CreatePath(riParams.GetString(2),*&m_state.pIniPath)) != 0)
		{
			Message(imtError, *pError); //!! reformat error message
			return iesFailure;
		}
	}
	else
	{
		m_state.pIniPath = 0;
	}
	m_state.strIniFile = riParams.GetMsiString(1);
	
	// generate undo operation
	if (!RollbackRecord(Op, riParams))
		return iesFailure;
	
	return iesSuccess;
}


iesEnum CMsiOpExecute::ixfResourceUpdate(IMsiRecord& )
{
	// OBSELETE
	AssertSz(0, TEXT("UpdateResource functionality not supported"));
	return iesFailure;
}

// File system operations

/*---------------------------------------------------------------------------
ixoSetSourceFolder: Sets the source path for ixoCopyTo
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSetSourceFolder(IMsiRecord& riParams)
{
	using namespace IxoSetSourceFolder;

	m_state.pCurrentSourcePathPrivate = 0;
	m_state.strCurrentSourceSubPathPrivate = g_MsiStringNull;
	m_state.iCurrentSourceTypePrivate = -1;
	m_state.fSourcePathSpecified = true;

	MsiString strEncodedPath = riParams.GetMsiString(IxoSetTargetFolder::Folder); // the path may be encoded
	int cch = 0;
	if((cch = strEncodedPath.Compare(iscStart, szUnresolvedSourceRootTokenWithBS)) != 0)
	{
		strEncodedPath.Remove(iseFirst, cch);
		m_state.strCurrentSourceSubPathPrivate = strEncodedPath;

		// will determine full source path and type when GetCurrentSourcePathAndType is called
	}
	else
	{
		Assert(PathType(strEncodedPath) == iptFull);

		int cSilentRetries = 0;
		bool fRetry;
		do
		{
			fRetry = false;
			PMsiRecord pRecErr = m_riServices.CreatePath(strEncodedPath,*&(m_state.pCurrentSourcePathPrivate));
			if (pRecErr)
			{
				int iError = pRecErr->GetInteger(1);
				if (iError == imsgPathNotAccessible && cSilentRetries < MAX_NET_RETRIES)
				{
					Sleep(1000);
					cSilentRetries++;
					fRetry = true;
					continue;
				}
				else
				{
					switch(DispatchMessage(imtEnum(imtError+imtRetryCancel+imtDefault1), *pRecErr, fTrue))
					{
					case imsRetry:
						fRetry = true;
						continue;
					default:  // imsCancel
						return iesFailure;
					};
				}
			}
		}while (fRetry);

		Assert(m_state.pCurrentSourcePathPrivate);

		// set current source type
		// since this is not a path to the original source, the type of source is determined by
		// just the volume attributes, not the package settings
		m_state.iCurrentSourceTypePrivate = (m_state.pCurrentSourcePathPrivate->SupportsLFN()) ? 0 : msidbSumInfoSourceTypeSFN;
	}

	// NOTE: we don't put SetSourceFolder operation in rollback script
	// it is never used and could potentially cause problems when one user tries to
	// access a source used by another user

	return iesSuccess;
}

iesEnum CMsiOpExecute::GetSourceRootAndType(IMsiPath*& rpiSourceRoot, int& iSourceType)
{
	if(!m_piDirectoryManager)
	{
		DispatchError(imtError, Imsg(idbgOpNoDirMgr));
		return iesFailure;
	}
	
	PMsiRecord pError = m_piDirectoryManager->GetSourceRootAndType(rpiSourceRoot, iSourceType);
	if(pError)
	{
		if (pError->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return FatalError(*pError);
	}

	return iesSuccess;
}

// GetCurrentSourcePath: returns the path set by the ixoSetSourcePath operation
//                       because source resolution may be necessary to fully resolve
//                       that path, this function should be called when the path
//                       is needed
iesEnum CMsiOpExecute::GetCurrentSourcePathAndType(IMsiPath*& rpiSourcePath, int& iSourceType)
{
	if(!m_state.fSourcePathSpecified)
	{  // must not have called ixoSetSourceFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoSetSourceFolder")));
		return iesFailure;
	}
	
	if(m_state.pCurrentSourcePathPrivate == 0)
	{
		// we need to get the source root (which may require resolving the source)
		// and tack on the current sub-path
		PMsiPath pSourceRootPath(0);
		iesEnum iesRet = GetSourceRootAndType(*&pSourceRootPath, m_state.iCurrentSourceTypePrivate);
		if(iesRet != iesSuccess)
			return iesRet;

		// append path and subpath
		PMsiRecord pError(0);
		if((pError = pSourceRootPath->ClonePath(*&m_state.pCurrentSourcePathPrivate)) != 0)
		{
			return FatalError(*pError);
		}

		// if source type is compressed, return just the root (all files live at the root)
		if((!(m_state.iCurrentSourceTypePrivate & msidbSumInfoSourceTypeCompressed) ||
			  (m_state.iCurrentSourceTypePrivate & msidbSumInfoSourceTypeAdminImage)) &&
			m_state.strCurrentSourceSubPathPrivate.TextSize())
		{
			// sub-path may be short|long pair (where each half is the entire sub-path)
			Bool fLFN = ToBool(FSourceIsLFN(m_state.iCurrentSourceTypePrivate,
													  *(m_state.pCurrentSourcePathPrivate)));
			
			MsiString strExtractedSubPath = m_state.strCurrentSourceSubPathPrivate.Extract(fLFN ? iseAfter : iseUpto,
																								  chFileNameSeparator);
			
			if((pError = m_state.pCurrentSourcePathPrivate->AppendPiece(*strExtractedSubPath)) != 0)
			{
				return FatalError(*pError);
			}
		}
	}

	rpiSourcePath = m_state.pCurrentSourcePathPrivate;
	rpiSourcePath->AddRef();

	iSourceType = m_state.iCurrentSourceTypePrivate;

	return iesSuccess;
}


/*---------------------------------------------------------------------------
ixoSetTargetFolder: Sets the target path for ixoCopyTo and ixoFileRemove
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSetTargetFolder(IMsiRecord& riParams)
{
	using namespace IxoSetTargetFolder;

	// If the cabinet copier notified us that a media change is required,
	// we must defer any set target folders until a media change is executed.
	if (m_state.fWaitingForMediaChange)
	{
		PushRecord(riParams);
		return iesSuccess;
	}

	if(riParams.IsNull(IxoSetTargetFolder::Folder))
	{
		m_state.pTargetPath = 0;
		return iesSuccess;
	}

	PMsiRecord pError(0);
	MsiString strEncodedPath = riParams.GetMsiString(IxoSetTargetFolder::Folder); // the path may be encoded
	MsiString strLocation = strEncodedPath.Extract(iseUpto, MsiChar(chDirSep));
	CTempBuffer<ICHAR, MAX_PATH> rgchPath;
	if(strLocation != iMsiStringBadInteger)
	{
		int iFolderId = strLocation;
		pError = GetShellFolder(iFolderId, *&strLocation);
		
		// must prevent writes to the shell folders during rollback initiated by a changed user.
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			m_state.pTargetPath = NULL;
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		if (pError)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		if(strEncodedPath.Remove(iseUpto, MsiChar(chDirSep)))
		{
			//?? ugly
			MsiString strDirSep = MsiChar(chDirSep);
			if(strLocation.Compare(iscEnd, strDirSep))
				strLocation.Remove(iseLast, 1); // chop off the separator, if present
			strLocation += strEncodedPath;
		}
	}
	else
	{
		strLocation = strEncodedPath;
	}

	GetEnvironmentStrings(strLocation,rgchPath);

	pError = m_riServices.CreatePath(rgchPath,*&(m_state.pTargetPath));
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	// generate undo operation
	if (!RollbackRecord(Op, riParams))
		return iesFailure;

	return iesSuccess;
}


iesEnum CMsiOpExecute::CreateFilePath(const ICHAR* szPath, IMsiPath*& rpiPath, const IMsiString*& rpistrFileName)
{
	bool fRetry;
	do
	{
		PMsiRecord pRecErr(0);
		fRetry = false;
		if((pRecErr = m_riServices.CreateFilePath(szPath,rpiPath,rpistrFileName)) != 0)
		{
			switch (DispatchMessage(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), *pRecErr, fTrue))
			{
			case imsRetry:
				fRetry = true;
				continue;
			case imsIgnore:
				return iesSuccess;
			default:
			return iesFailure;
			}
		}
	}while (fRetry);
	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixoFileRemove: Remove the specified file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFileRemove(IMsiRecord& riParams)
{
	using namespace IxoFileRemove;

	PMsiPath pPath(0);
	MsiString strFileName, strFilePath = riParams.GetMsiString(FileName);
	// check if files is full or relative path
	if(ENG::PathType(strFilePath) == iptFull)
	{
		iesEnum iesResult = CreateFilePath(strFilePath,*&pPath,*&strFileName);
		if (iesResult != iesSuccess)
			return iesResult;

		AssertNonZero(riParams.SetMsiString(FileName,*strFileName)); // replace full path with file name
	}
	else
	{
		pPath = m_state.pTargetPath;
		strFileName = strFilePath;
	}

	
	if(!pPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoFileRemove")));
		return iesFailure;
	}

	// check if file is part of Assembly
	bool fFusionComponent = false;
	MsiString strComponentId = riParams.GetMsiString(ComponentId);
	if(strComponentId.TextSize() && m_pAssemblyUninstallTable)
	{
		PMsiCursor pCacheCursor = m_pAssemblyUninstallTable->CreateCursor(fFalse);
		pCacheCursor->SetFilter(iColumnBit(m_colAssemblyUninstallComponentId));
		AssertNonZero(pCacheCursor->PutString(m_colAssemblyUninstallComponentId, *strComponentId));
		if(pCacheCursor->Next())
		{
			// a fusion component
			fFusionComponent = true;
		}
	}

	IMsiRecord& riActionData = GetSharedRecord(9);
	AssertNonZero(riActionData.SetMsiString(1, *strFileName));
	if(!fFusionComponent)
		AssertNonZero(riActionData.SetMsiString(9, *MsiString(pPath->GetPath())));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	if(fFusionComponent)
	{
		// do not attempt to remove the files ourselves
		DEBUGMSG1(TEXT("delegating uninstallation of assembly file : %s to Fusion"), (const ICHAR*)strFileName);
		return iesNoAction;
	}


#ifdef CONFIGDB
	if (!riParams.IsNull(ComponentId))
	{
		icdrEnum icdr = m_riConfigurationManager.UnregisterFile(MsiString(pPath->GetPath()), strFileName, MsiString(riParams.GetMsiString(ComponentId)));
		if (icdr == icdrMore)
			return iesNoAction;
		Assert(icdr == icdrOk);
	}
#endif
	
	// elevate if necessary
	bool fElevate = (!riParams.IsNull(Elevate) && riParams.GetInteger(Elevate) != 0) ? true : false;
	CElevate elevate(fElevate);

	return RemoveFile(*pPath, *strFileName, fTrue, /*fBypassSFC*/ false);
}

// RemoveFile: helper function to remove a file and handle rollback - called by ixfFileRemove
//  and ixfFileCopy when moving a file
iesEnum CMsiOpExecute::RemoveFile(IMsiPath& riPath, const IMsiString& ristrFileName, Bool fHandleRollback, bool fBypassSFC,
									bool fRebootOnRenameFailure, Bool fRemoveFolder, iehEnum iehErrorMode, bool fWillReplace)
{
	bool fRetry;
	Bool fExists;
	DWORD dwExistError;
	PMsiRecord pRecErr(0);
	do
	{
		fRetry = false;
		if((pRecErr = riPath.FileExists(ristrFileName.GetString(),fExists,&dwExistError)) != 0)
		{
			if (iehErrorMode == iehSilentlyIgnoreError)
			{
				Message(imtInfo, *pRecErr);
				return (iesEnum) iesErrorIgnored;
			}

			switch (DispatchMessage(imtEnum(imtError+imtAbortRetryIgnore+imtDefault2), *pRecErr, fTrue))
			{
			case imsIgnore:
				return (iesEnum) iesErrorIgnored;
			case imsRetry:
					fRetry = true;
					continue;
			default:
				return iesFailure;
			return iesFailure;
			}
		}
	}while (fRetry);

	if(!fExists)
	{
		if ((dwExistError != ERROR_FILE_NOT_FOUND) && (dwExistError != ERROR_PATH_NOT_FOUND))
		{
			DEBUGMSG2(TEXT("Error %d attempting to delete file %s"), (const ICHAR *)(INT_PTR)dwExistError, ristrFileName.GetString()); 
		}
		return fRemoveFolder ? RemoveFolder(riPath) : iesSuccess;
	}

	// Do not attempt to delete any file protected by SFP
	MsiString strFullPath;
	if ((pRecErr = riPath.GetFullFilePath(ristrFileName.GetString(), *&strFullPath)) == 0)
	{
		AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
					g_szNoSFCMessage);
		BOOL fProtected = fFalse;
 		if (!fBypassSFC && g_MessageContext.m_hSfcHandle )
			fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strFullPath));
		if (fProtected)
		{
			DEBUGMSG1(TEXT("This following file was not removed, because it is protected by Windows: %s"), strFullPath);
			return iesSuccess;
		}
	}

	iesEnum iesRet = iesNoAction;
	if(fHandleRollback && RollbackEnabled())
	{
		// create a backup file - essentially removes file as well
		if((iesRet = BackupFile(riPath,ristrFileName,fTrue,fRemoveFolder,iehErrorMode,fRebootOnRenameFailure,fWillReplace)) != iesSuccess)
			return iesRet;
	}
	else
	{
		// attempt to delete file
		fRetry = false;
		pRecErr = riPath.RemoveFile(ristrFileName.GetString());
		if(pRecErr)
		{
			// failed to remove file
			// either access denied or sharing violation
			iesRet = VerifyAccessibility(riPath, ristrFileName.GetString(), DELETE, iehErrorMode); //!! doesn't catch case where dir has DELETE access but file doesn't
			if(iesRet != iesSuccess)
				return iesRet;
			
			// access verified - must be sharing violation
			
			MsiString strFileFullPath;
			if((pRecErr = riPath.GetFullFilePath(ristrFileName.GetString(),
															 *&strFileFullPath)) != 0)
			{
				Message(imtError, *pRecErr);
				return iesFailure;
			}

			bool fRenameSuccess = false;
			if(fRebootOnRenameFailure)
			{
				// we are attempting to remove this in-use file to put another in its place
				// rather than install the new file to a temporary location, check if we can
				// move this file to a temp location and install the new file to the correct
				// location

				MsiString strTempFilePath, strTempFileName;
				if((pRecErr = riPath.TempFileName(TEXT("TBD"),0,fTrue,*&strTempFileName, 0)) != 0)
					return FatalError(*pRecErr);

				if((pRecErr = riPath.GetFullFilePath(strTempFileName, *&strTempFilePath)) != 0)
					return FatalError(*pRecErr);

				if((pRecErr = riPath.RemoveFile(strTempFileName)) != 0)
					return FatalError(*pRecErr);

				if(WIN::MoveFile(strFileFullPath, strTempFilePath))
				{
					// successfully moved file - schedule temp file for delete on reboot instead
					strFileFullPath = strTempFilePath;
					fRenameSuccess = true;
				}
				else
				{
					// can't rename file, so the file is in the original spot and will be scheduled to be deleted
					// need to prompt for reboot to a subsequent install won't think file exists when it is
					// really going away after the next reboot - bug 7687

					// NOTE: it is assumed that if fRebootOnRenameFailure is FALSE, we don't care if the file is in use
					// i.e. it has a unique name already like an .rbf file.
					m_fRebootReplace = fTrue;
				}

			}
			
			// bug 8906: on Win9X don't write a delete line to wininit.ini followed by a rename line
			// for the same file, since in some rare cases wininit.ini may be processed twice, and
			// the second time through we would delete files and not replace them
			
			// so, if NT, or we are deleting this file without subsequently replacing
			// then write the wininit.ini delete operation
			// NOTE: if we renamed the file to TBD* above, we won't be replacing the TBD file, so we
			// still schedule a delete for it
			if(g_fWin9X == false || fWillReplace == false || fRenameSuccess == true)
			{
				if(ReplaceFileOnReboot(strFileFullPath,0) == fFalse)
				{
					DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove),*strFileFullPath);
					return iesSuccess;
				}
			}
		}
	}
	return fRemoveFolder ? RemoveFolder(riPath) : iesSuccess;
}

/*---------------------------------------------------------------------------
ixoChangeMedia: verify that the source volume and file are present and
accounted for.
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfChangeMedia(IMsiRecord& riParams)
{
	// set m_pCurrentMediaRec
	m_state.pCurrentMediaRec = &riParams;
	riParams.AddRef();
	m_state.fPendingMediaChange = fTrue;
	m_state.fCompressedSourceVerified = fFalse; // new change media, haven't verified source yet
	m_state.fUncompressedSourceVerified = fFalse; // new change media, haven't verified source yet

	// reset data for last copied file, since this isn't applicable across cabinets
	m_state.strLastFileKey = g_MsiStringNull;
	m_state.strLastFileName = g_MsiStringNull;
	m_state.pLastTargetPath = 0;

	// If there are any file records that were waiting for a media
	// change before being executed, we'll now pull them out and
	// let them fly.

	// ixfFileCopy will use m_pCurrentMediaRec
	m_state.fWaitingForMediaChange = fFalse;
	IMsiRecord* piFileRec;
	while (m_state.fWaitingForMediaChange == fFalse && (piFileRec = PullRecord()) != 0)
	{
		ixoEnum ixoOpCode = (ixoEnum)piFileRec->GetInteger(0);
		iesEnum ies;
		if(ixoOpCode == ixoFileCopy)
			ies = ixfFileCopy(*piFileRec); // Can change fWaitingForMediaChange state
		else if(ixoOpCode == ixoAssemblyCopy)
			ies = ixfAssemblyCopy(*piFileRec);
		else if(ixoOpCode == ixoSetTargetFolder)
			ies = ixfSetTargetFolder(*piFileRec);
		else
		{
			ies = iesFailure;
			Assert(0);
		}
		piFileRec->Release();
		if (ies != iesSuccess)
			return ies;
	}

	return iesSuccess;
}

iesEnum CMsiOpExecute::ResolveMediaRecSourcePath(IMsiRecord& riMediaRec, int iIndex)
{
	// if no path, nothing to resolve
	if(riMediaRec.IsNull(iIndex))
		return iesSuccess;
	
	MsiString strEncodedPath = riMediaRec.GetMsiString(iIndex);
	int cch = 0;
	if((cch = strEncodedPath.Compare(iscStart, szUnresolvedSourceRootTokenWithBS)) != 0)
	{
		strEncodedPath.Remove(iseFirst, cch);

		PMsiPath pSourceRootPath(0);
		int iSourceType = 0;
		iesEnum iesRet = GetSourceRootAndType(*&pSourceRootPath, iSourceType);
		if(iesRet != iesSuccess)
			return iesRet;

		PMsiRecord pError(0);
		PMsiPath pSourcePath(0);
		if((pError = pSourceRootPath->ClonePath(*&pSourcePath)) != 0)
		{
			return FatalError(*pError);
		}

		if((pError = pSourcePath->AppendPiece(*strEncodedPath)) != 0)
		{
			return FatalError(*pError);
		}

		strEncodedPath = pSourcePath->GetPath();
		// remove trailing dirsep since this is a file path
		strEncodedPath.Remove(iseLast, 1);

		AssertNonZero(riMediaRec.SetMsiString(iIndex, *strEncodedPath));
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
InitCopier: does 3 things:

	1) verify that source is accessible (if floppy or cd)
	2) creates appropriate copier object if not already created
	3) calls ChangeMedia on copier object if necessary
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::InitCopier(Bool fCabinetCopier, int cbPerTick,
									const IMsiString& ristrFileName,
									IMsiPath* piSourcePath,
									Bool fVerifyMedia) // ristrFileName used for error msgs only
{
	using namespace IxoChangeMedia;

	PMsiRecord pRecErr(0);
	iesEnum iesResult = iesSuccess;
	
	PMsiPath pSourcePath(0);
	MsiString strMediaCabinet;

	if (fVerifyMedia)
	{
		// fVerifyMedia: true if we need to validate the media and call ChangeMedia for the copier object
		fVerifyMedia = (m_state.fPendingMediaChange ||  // have a pending ChangeMedia operation
								(fCabinetCopier && !m_state.fCompressedSourceVerified) ||  // doing compressed copy but compressed source not verified yet
								(!fCabinetCopier && !m_state.fUncompressedSourceVerified)) // doing uncompressed copy but uncompressed source not verified yet
								? fTrue : fFalse;
	}   

	if(fVerifyMedia == fTrue)
	{
		if (m_pUrlLocalCabinet)
		{
			DEBUGMSGV(TEXT("Clearing local copy of URL cabinet"));
			// At most we'll have one cabinet, and the database in the cache.
			delete m_pUrlLocalCabinet;
			m_pUrlLocalCabinet = 0;
		}

		if(m_state.pCurrentMediaRec)
		{
			// there may be unresolved paths to cabinets or packages in the current media record
			// now that we know a file copy will happen, we can fully resolve those paths
			if((iesResult = ResolveMediaRecSourcePath(*(m_state.pCurrentMediaRec), IxoChangeMedia::MediaCabinet)) != iesSuccess)
				return iesResult;

			if((iesResult = ResolveMediaRecSourcePath(*(m_state.pCurrentMediaRec), IxoChangeMedia::ModuleFileName)) != iesSuccess)
				return iesResult;
		}
	
		// ensure that source is accessible

		// m_pCurrentMediaRec may not be set for uncompressed installs (ixoChangeMedia not required)
		if(m_state.pCurrentMediaRec)
		{
			m_state.strMediaLabel = m_state.pCurrentMediaRec->GetString(MediaVolumeLabel);
			m_state.strMediaPrompt = m_state.pCurrentMediaRec->GetString(MediaPrompt);
		}

		// set the source path to verify
		if(!fCabinetCopier)
		{
			if(!piSourcePath)
			{
				// not set - error
				DispatchError(imtError, Imsg(idbgOpSourcePathNotSet), ristrFileName);
				return iesFailure;
			}
			pSourcePath = piSourcePath;
			piSourcePath->AddRef();
		}
		else
		{
			if(!m_state.pCurrentMediaRec)
			{
				// attempting to copy compressed file but ixoChangeMedia never executed
				DispatchError(imtError, Imsg(idbgOpCompressedCopyWithoutCabinet), ristrFileName);
				return iesFailure;
			}
			// cabinet copier
			int iPathIndex;
			ictEnum ictCopierType = (ictEnum)m_state.pCurrentMediaRec->GetInteger(CopierType);
			if(ictCopierType == ictStreamCabinetCopier)
			{
				// source dir is directory containing storage module (database)
				iPathIndex = IxoChangeMedia::ModuleFileName;
			}
			else  // file cabinet
			{
				// source dir is directory containing cabinet
				iPathIndex = IxoChangeMedia::MediaCabinet;
			}
		
			MsiString strFullFilePath = m_state.pCurrentMediaRec->GetMsiString(iPathIndex);


			if (ictCopierType != ictStreamCabinetCopier)
			{
				MsiString pPackagePath;
				bool fFileUrl = false;
				bool fUrl = IsURL(strFullFilePath, fFileUrl);
				DWORD iStat = ERROR_SUCCESS;
				bool fUsedWinHttp = true;

				// IsURL only tells us if it looks like a URL.  DownloadUrlFile does
				// further processing and canonicalization to make sure...

				if (fFileUrl)
				{
					Assert(fUrl);

					// need to canonicalize file url path and create DOS path
					CTempBuffer<ICHAR, 1> rgchFullPath(cchExpectedMaxPath+1);
					DWORD cchFullPath = rgchFullPath.GetSize();
					if (MsiConvertFileUrlToFilePath((const ICHAR*) strFullFilePath, rgchFullPath, &cchFullPath, 0))
					{
						// use new canonicalized DOS path version
						strFullFilePath = static_cast<const ICHAR*>(rgchFullPath);
					}
					// else fall through to failure below when attempting to open full file path
				}
				else if (fUrl)
				{
					for(;;)
					{
						iStat = DownloadUrlFile((const ICHAR*) strFullFilePath, *&pPackagePath, fUrl, -1, &fUsedWinHttp);

						if (ERROR_SUCCESS == iStat)
						{
							Assert(pPackagePath);
							m_pUrlLocalCabinet = new CDeleteUrlLocalFileOnClose(fUsedWinHttp ? *pPackagePath : *strFullFilePath, /*fDeleteFromIECache = */ !fUsedWinHttp);

							strFullFilePath = pPackagePath;
							AssertNonZero(m_state.pCurrentMediaRec->SetMsiString(iPathIndex, *strFullFilePath));
							
							break;
						}
						else
						{
							// warn user, and retry.
							
							pRecErr = PostError(Imsg(imsgErrorCreateNetPath), *strFullFilePath);
							switch (DispatchMessage(imtEnum(imtError + imtRetryCancel + imtDefault1), *pRecErr, fTrue))
							{
								case imsRetry:
									continue;
								default:
									return iesFailure;
							}
						}
					}
				}
			}

			if(PathType(strFullFilePath) != iptFull)
			{
				DispatchError(imtError, Imsg(idbgOpSourcePathNotSet), ristrFileName);
				return iesFailure;
			}
			MsiString strFileName;

			iesResult = CreateFilePath(strFullFilePath,*&pSourcePath,*&strFileName);
			if (iesResult != iesSuccess)
				return iesResult;

			if(ictCopierType == ictStreamCabinetCopier)
			{
				strMediaCabinet = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::MediaCabinet);
			}
			else
			{
				strMediaCabinet = strFileName;
			}
		}
		
		Assert(pSourcePath);
		m_state.pMediaPath = pSourcePath;
		PMsiVolume pNewVolume(0);
		UINT uiDisk = 0;
		if (m_state.pCurrentMediaRec)
			uiDisk = m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::IsFirstPhysicalMedia);
		if (!VerifySourceMedia(*m_state.pMediaPath, m_state.strMediaLabel, m_state.strMediaPrompt, uiDisk, *&pNewVolume))
			return iesUserExit;
		if (pNewVolume)
			pSourcePath->SetVolume(*pNewVolume);

		// what source did we just verify?
		if(!fCabinetCopier)
			m_state.fUncompressedSourceVerified = fTrue;
		else
			m_state.fCompressedSourceVerified = fTrue;
	}

	// create appropriate copier object if not already created
	if(fCabinetCopier == fFalse)
	{
		// initialize file copier
		if (m_state.pFileCopier == 0)
		{
			PMsiRecord pRecErr = m_riServices.CreateCopier(ictFileCopier,0,*&(m_state.pFileCopier));
			if (pRecErr)
			{
				Message(imtError, *pRecErr);
				return iesFailure;
			}
		}
		m_state.piCopier = m_state.pFileCopier;
	}
	else
	{
		ictEnum ictCopierType;
		if(!m_state.pCurrentMediaRec ||
			(ictCopierType = (ictEnum)m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::CopierType)) == ictFileCopier)
		{
			// attempting to copy compressed file but ixoChangeMedia never executed (or does not specify cabinet)
			DispatchError(imtError, Imsg(idbgOpCompressedCopyWithoutCabinet), ristrFileName);
			return iesFailure;
		}
		// initialize cabinet copier if necessary
		MsiString strModuleFileName = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::ModuleFileName);
		MsiString strModuleSubStorageList = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::ModuleSubStorageList);
		if(m_state.pCabinetCopier == 0 || ictCopierType != m_state.ictCabinetCopierType ||
			(ictCopierType == ictStreamCabinetCopier &&
			 (m_state.strMediaModuleFileName.Compare(iscExact,strModuleFileName) == 0 ||
			  m_state.strMediaModuleSubStorageList.Compare(iscExact,strModuleSubStorageList) == 0)))
		{
			Assert(m_state.pCurrentMediaRec);
			Assert(ictCopierType != ictFileCopier);

			PMsiStorage pCabinetStorage(0);
			if(ictCopierType == ictStreamCabinetCopier)
			{
				// need to pass storage object to CreateCopier
				// file should be accessible since we called VerifySourceMedia above

				//!!?? post better error when ModuleFileName is empty string?
				// we are cracking open the storage in order to extract an embedded cabinet

				//
				// SAFER: we need to make sure the package is still valid.  This package is at the source as the embedded cabinets
				//          are stripped from the local cached package.  However, we should limit this check to as few times as
				//          possible, so once will suffice when we open the package for the first time.  If the strModuleFileName is
				//          still the same, no further WVT checks are needed.  But, if strModuleFileName is different, we need to
				//          perform a SAFER check again
				//

				bool fCallSAFER = false;
				if (m_state.strMediaModuleFileName.Compare(iscExact, strModuleFileName) == 0)
				{
					//
					// SAFER: package is new, SAFER check is required
					//

					fCallSAFER = true;
				}

				SAFER_LEVEL_HANDLE hSaferLevel = 0;
				pRecErr = OpenAndValidateMsiStorageRec(strModuleFileName,stIgnore, m_riServices,*&pCabinetStorage,fCallSAFER,strModuleFileName,/* phSaferLevel = */ fCallSAFER ? &hSaferLevel : NULL);
				if (pRecErr)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}

				MsiString strTempSubStorageList = strModuleSubStorageList;

				while(strTempSubStorageList.TextSize())
				{
					// storage is sub-storage, possible many levels deep
					MsiString strSubStorageName = strTempSubStorageList.Extract(iseUpto, ':');

					IMsiStorage* piParentStorage = pCabinetStorage;
					piParentStorage->AddRef();

					pRecErr = piParentStorage->OpenStorage(strSubStorageName, ismReadOnly, *&pCabinetStorage);

					piParentStorage->Release();
					
					if(pRecErr)
						return FatalError(*pRecErr);


					if(strTempSubStorageList.TextSize() != strSubStorageName.TextSize()) // done with list
						strTempSubStorageList.Remove(iseIncluding, ':');
					else
						break;
				}
			}
			
			pRecErr = m_riServices.CreateCopier(ictCopierType,pCabinetStorage,
														   *&m_state.pCabinetCopier);
			if (pRecErr)
			{
				Message(imtError, *pRecErr);
				return iesFailure;
			}
			m_state.ictCabinetCopierType = ictCopierType;
		}
		m_state.piCopier = m_state.pCabinetCopier;
		m_state.strMediaModuleFileName = strModuleFileName;
		m_state.strMediaModuleSubStorageList = strModuleSubStorageList;
	}

	if(fVerifyMedia == fTrue)
	{
		Assert(pSourcePath); // should have been set above for VerifySourceMedia
		Assert(m_state.pMediaPath);
		// call ChangeMedia for copier  
		for (;;)
		{
			// when passing ChangeMedia to a cabinet copier, we might need signature information
			Bool fSignatureRequired = fFalse;
			PMsiStream pCertificate(0);
			PMsiStream pHash(0);

			if (m_state.pCurrentMediaRec)
			{
				fSignatureRequired = (m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::SignatureRequired) == 1) ? fTrue : fFalse;
				pCertificate = const_cast<IMsiStream*>(static_cast<const IMsiStream *>(m_state.pCurrentMediaRec->GetMsiData(IxoChangeMedia::SignatureCert)));
				pHash = const_cast<IMsiStream*>(static_cast<const IMsiStream *>(m_state.pCurrentMediaRec->GetMsiData(IxoChangeMedia::SignatureHash)));
			}

			// doesn't do anything for file copier
			pRecErr = m_state.piCopier->ChangeMedia(*pSourcePath, strMediaCabinet, fSignatureRequired, pCertificate, pHash);
			if (pRecErr)
			{
				int iError = pRecErr->GetInteger(1);
				if (iError == idbgDriveNotReady)
				{
					Assert(m_state.strMediaLabel.TextSize() > 0);
					Assert(m_state.strMediaPrompt.TextSize() > 0);
					PMsiVolume pNewVolume(0);
					UINT uiDisk = 0;
					if (m_state.pCurrentMediaRec)
						uiDisk = m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::IsFirstPhysicalMedia);

					if (!VerifySourceMedia(*m_state.pMediaPath, m_state.strMediaLabel,m_state.strMediaPrompt, uiDisk, *&pNewVolume))
						return iesUserExit;
					else
						continue;
				}
				else
				{
					// if error is imsgCABSignatureRejected or imsgCABSignatureMissing, simply FAIL -- there is nothing the user can do and we don't
					//  want to spin on a retry
					imtEnum imtMsg = (iError == imsgCABSignatureRejected || iError == imsgCABSignatureMissing) ? imtEnum(imtError + imtOk + imtDefault1) : imtEnum(imtError + imtRetryCancel + imtDefault1);
					switch (DispatchMessage(imtMsg, *pRecErr, fTrue))
					{
					case imsRetry: continue;
					default: return iesFailure;
					};
				}
			}
			break;
		}

	}
	
	m_state.fPendingMediaChange = fFalse;
	Assert(m_state.piCopier);
	int iRemainder = m_state.piCopier->SetNotification(0, 0);
	m_state.piCopier->SetNotification(cbPerTick, iRemainder);

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixoSetCompanionParent: Indicates that the installation state of the next
file to (potentially) be copied by ixoFileCopy should be determined by
the install state of a 'companion parent' - i.e. the filename and version
of a parent file.  ixoSetCompanionParent sets the file path, name, and
version of the parent.
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSetCompanionParent(IMsiRecord& riParams)
{
	using namespace IxoSetCompanionParent;
	PMsiRecord pRecErr = m_riServices.CreatePath(riParams.GetString(ParentPath),
		*&(m_state.pParentPath));
	if (pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	m_state.strParentFileName = riParams.GetMsiString(ParentName);
	m_state.strParentVersion = riParams.GetMsiString(ParentVersion);
	m_state.strParentLanguage = riParams.GetMsiString(ParentLanguage);
	return iesSuccess;
}


void CMsiOpExecute::PushRecord(IMsiRecord& riParams)
/*---------------------------------------------------------------------------
Stores the given record on the first-in, first-out stack.
---------------------------------------------------------------------------*/
{
	Assert(m_iWriteFIFO < MAX_RECORD_STACK_SIZE);
	if (m_iWriteFIFO < MAX_RECORD_STACK_SIZE)
	{
		m_piStackRec[m_iWriteFIFO++] = &riParams;
		riParams.AddRef();
	}
}

void CMsiOpExecute::InsertTopRecord(IMsiRecord& riParams)
/*---------------------------------------------------------------------------
Stores the given record as the next record to Pull on the first-in, first-out stack.
---------------------------------------------------------------------------*/
{
	Assert(m_iWriteFIFO < MAX_RECORD_STACK_SIZE);
	if (m_iWriteFIFO >= MAX_RECORD_STACK_SIZE)
		return;
		
	int iInsert = 0;
	if (m_iWriteFIFO == 0)
		m_iWriteFIFO++;
	else if (m_iReadFIFO > 0)
		iInsert = --m_iReadFIFO;
	else
	{
		Assert(fFalse);
		int i;
		for (i = m_iWriteFIFO; i > 0 ; i--)
			m_piStackRec[i] = m_piStackRec[i - 1];
		m_iWriteFIFO++;
	}

	m_piStackRec[iInsert] = &riParams;
	riParams.AddRef();
}


IMsiRecord* CMsiOpExecute::PullRecord()
/*---------------------------------------------------------------------------
Pulls a record out of the first-in, first-out stack.
---------------------------------------------------------------------------*/
{
	if (m_iWriteFIFO > m_iReadFIFO)
	{
		int iReadFIFO = m_iReadFIFO++;
		if (m_iReadFIFO == m_iWriteFIFO)
			m_iReadFIFO = m_iWriteFIFO = 0;

		return m_piStackRec[iReadFIFO];
	}
	return 0;
}

imsEnum CMsiOpExecute::ShowFileErrorDialog(IErrorCode err,const IMsiString& riFullPathString,Bool fVital)
/*---------------------------------------------------------------------------
Displays an error dialog based on the code passed in the err parameter. The
string passed in riFullPathString will replace the [2] parameter within the
error string.  If fVital is fTrue, the 'Ignore' button in the dialog will
be suppressed.

Returns: imsEnum value specifying the button pressed by the user.
---------------------------------------------------------------------------*/
{
	PMsiRecord pRecErr = &m_riServices.CreateRecord(2);
	ISetErrorCode(pRecErr, err);
	pRecErr->SetMsiString(2, riFullPathString);

	imtEnum imtButtons = fVital ? imtRetryCancel : imtAbortRetryIgnore;
	return DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue);
}

IMsiRecord* CMsiOpExecute::CacheFileState(const IMsiString& ristrFilePath,
														icfsEnum* picfsState,
														const IMsiString* pistrTempLocation,
														const IMsiString* pistrVersion,
														int* pcRemainingPatches,
														int* pcRemainingPatchesToSkip)
{
	IMsiRecord* piError = 0;
	if(!m_pDatabase)
	{
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	if(!m_pFileCacheTable)
	{
		MsiString strTableName = m_pDatabase->CreateTempTableName();
		piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pFileCacheTable);
		if(piError)
			return piError;

		MsiString strNull;
		m_colFileCacheFilePath     = m_pFileCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary,*strNull);
		m_colFileCacheState        = m_pFileCacheTable->CreateColumn(icdLong + icdTemporary + icdNullable,*strNull);
		m_colFileCacheTempLocation = m_pFileCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,*strNull);
		m_colFileCacheVersion      = m_pFileCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,*strNull);
		m_colFileCacheRemainingPatches = m_pFileCacheTable->CreateColumn(icdLong + icdTemporary + icdNullable,*strNull);
		m_colFileCacheRemainingPatchesToSkip = m_pFileCacheTable->CreateColumn(icdLong + icdTemporary + icdNullable,*strNull);

		Assert(m_colFileCacheFilePath && m_colFileCacheState && m_colFileCacheTempLocation && m_colFileCacheVersion && m_colFileCacheRemainingPatches && m_colFileCacheRemainingPatchesToSkip);

		m_pFileCacheCursor = m_pFileCacheTable->CreateCursor(fFalse);
		m_pFileCacheCursor->SetFilter(iColumnBit(m_colFileCacheFilePath)); // permanent setting, effects get but no put
	}

	MsiString strFilePath;
	ristrFilePath.LowerCase(*&strFilePath);
	m_pFileCacheCursor->Reset();
	AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheFilePath,*strFilePath));
	int iNext = m_pFileCacheCursor->Next();
	if(!iNext)
		AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheFilePath,*strFilePath));

	if(picfsState)
		AssertNonZero(m_pFileCacheCursor->PutInteger(m_colFileCacheState,(int)*picfsState));
	if(pistrTempLocation)
		AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheTempLocation,*pistrTempLocation));
	if(pistrVersion)
		AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheVersion,*pistrVersion));
	if(pcRemainingPatches)
		AssertNonZero(m_pFileCacheCursor->PutInteger(m_colFileCacheRemainingPatches,(int)*pcRemainingPatches));
	if(pcRemainingPatchesToSkip)
		AssertNonZero(m_pFileCacheCursor->PutInteger(m_colFileCacheRemainingPatchesToSkip,(int)*pcRemainingPatchesToSkip));

	if(iNext)
		// primary key exists, need to update
		AssertNonZero(m_pFileCacheCursor->Update());
	else
		// primary key doesn't exist, need to insert
		AssertNonZero(m_pFileCacheCursor->InsertTemporary());

	return 0;
}

// fn: create a temporary table to manage the assemblies creation/ removal for this session
IMsiRecord* CMsiOpExecute::CreateAssemblyCacheTable()
{
	IMsiRecord* piError = 0;

	if(m_pAssemblyCacheTable)
		return 0;// table already created

	if(!m_pDatabase)
	{
		// create temp database
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	MsiString strTableName = m_pDatabase->CreateTempTableName();
	piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pAssemblyCacheTable);
	if(piError)
		return piError;

	// table has 4 columns
	//1 = component id
	//2 = assembly name
	//3 = manifest file
	//4 = column to store IAssemblyCacheItem object

	MsiString strNull;
	m_colAssemblyMappingComponentId = m_pAssemblyCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary, *strNull);
	m_colAssemblyMappingAssemblyName= m_pAssemblyCacheTable->CreateColumn(icdString + icdTemporary, *strNull);
	m_colAssemblyMappingAssemblyType = m_pAssemblyCacheTable->CreateColumn(icdShort  + icdTemporary, *strNull);
	m_colAssemblyMappingASM         = m_pAssemblyCacheTable->CreateColumn(icdObject + icdTemporary + icdNullable, *strNull);
	Assert(m_colAssemblyMappingComponentId && m_colAssemblyMappingAssemblyName  && m_colAssemblyMappingAssemblyType && m_colAssemblyMappingASM);

	return 0;
}

IMsiRecord* CMsiOpExecute::CacheAssemblyMapping(const IMsiString& ristrComponentId,
												const IMsiString& ristrAssemblyName,
												iatAssemblyType iatType)
{
	IMsiRecord* piError;
	piError = CreateAssemblyCacheTable();
	if(piError)
		return piError;

	Assert(m_pAssemblyCacheTable);

	PMsiCursor pCacheCursor = m_pAssemblyCacheTable->CreateCursor(fFalse);

	// cache the entries
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyMappingComponentId, ristrComponentId));
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyMappingAssemblyName,ristrAssemblyName));
	AssertNonZero(pCacheCursor->PutInteger(m_colAssemblyMappingAssemblyType, (int)iatType));	
	AssertNonZero(pCacheCursor->Insert());
	return 0;
}

iesEnum CMsiOpExecute::ixfAssemblyMapping(IMsiRecord& riParams)
{
	using namespace IxoAssemblyMapping;
	PMsiRecord pErr = CacheAssemblyMapping(*MsiString(riParams.GetMsiString(IxoAssemblyMapping::ComponentId)), *MsiString(riParams.GetMsiString(IxoAssemblyMapping::AssemblyName)), (iatAssemblyType) riParams.GetInteger(IxoAssemblyMapping::AssemblyType));
	if(pErr)
		return FatalError(*pErr);
	return iesSuccess;
}


IMsiRecord* CMsiOpExecute::CreateTableForAssembliesToUninstall()
{
	IMsiRecord* piError = 0;

	if(m_pAssemblyUninstallTable)
		return 0;// table already created

	if(!m_pDatabase)
	{
		// create temp database
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	MsiString strTableName = m_pDatabase->CreateTempTableName();
	piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pAssemblyUninstallTable);
	if(piError)
		return piError;

	// table has 2 columns
	//1 = component id
	//2 = assembly name

	MsiString strNull;

	m_colAssemblyUninstallComponentId  = m_pAssemblyUninstallTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary, *strNull);
	m_colAssemblyUninstallAssemblyName = m_pAssemblyUninstallTable->CreateColumn(icdString + icdTemporary, *strNull);
	m_colAssemblyUninstallAssemblyType = m_pAssemblyUninstallTable->CreateColumn(icdShort + icdTemporary, *strNull);

	Assert(m_colAssemblyUninstallComponentId  && m_colAssemblyUninstallAssemblyName && m_colAssemblyUninstallAssemblyType);
	return 0;

}

IMsiRecord* CMsiOpExecute::CacheAssemblyForUninstalling(const IMsiString& ristrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT)
{
	IMsiRecord* piError;
	piError = CreateTableForAssembliesToUninstall();
	if(piError)
		return piError;

	Assert(m_pAssemblyUninstallTable);

	PMsiCursor pCacheCursor = m_pAssemblyUninstallTable->CreateCursor(fFalse);

	// cache the entries
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyUninstallComponentId, ristrComponentId));
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyUninstallAssemblyName, ristrAssemblyName));
	AssertNonZero(pCacheCursor->PutInteger(m_colAssemblyUninstallAssemblyType, (int)iatAT));	
	AssertNonZero(pCacheCursor->Insert());
	return 0;
}



//fn: Gets info for a particular assembly as to whether it is installed
IMsiRecord*   CMsiOpExecute::IsAssemblyInstalled(const IMsiString& rstrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT, bool& rfInstalled, IAssemblyCache** ppIAssemblyCache, IAssemblyName** ppIAssemblyName)
{
	// create the assembly name object
	PAssemblyName pAssemblyName(0);
	LPCOLESTR szAssemblyName;
#ifndef UNICODE
	CTempBuffer<WCHAR, MAX_PATH>  rgchAssemblyName;
	ConvertMultiSzToWideChar(ristrAssemblyName, rgchAssemblyName);
	szAssemblyName = rgchAssemblyName;
#else
	szAssemblyName = ristrAssemblyName.GetString();
#endif
	HRESULT hr;
	if(iatAT == iatURTAssembly)
	{
		hr = FUSION::CreateAssemblyNameObject(&pAssemblyName, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
	}
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyNameObject(&pAssemblyName, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
	}
	if(!SUCCEEDED(hr))
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyNameObject"), ristrAssemblyName.GetString(), iatAT);

	// create the assembly interface
	PAssemblyCache pCache(0);
	if(iatAT == iatURTAssembly)
	{
		hr = FUSION::CreateAssemblyCache(&pCache, 0); 
	}
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyCache(&pCache, 0); 
	}
	if(!SUCCEEDED(hr))
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), ristrAssemblyName.GetString(), iatAT);

	hr = pCache->QueryAssemblyInfo(0, szAssemblyName, NULL);
	if(SUCCEEDED(hr))
		rfInstalled = true;
	else
		rfInstalled = false;

	// check if we need to return the interfaces we have created
	if(ppIAssemblyCache)
	{
		*ppIAssemblyCache = pCache;
		(*ppIAssemblyCache)->AddRef();
	}
	if(ppIAssemblyName)
	{
		*ppIAssemblyName = pAssemblyName;
		(*ppIAssemblyName)->AddRef();
	}
	return 0;
}

//fn: uninstalls the assembly for the WI
IMsiRecord* CMsiOpExecute::UninstallAssembly(const IMsiString& rstrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT)
{
	PAssemblyCache pCache(0);
	HRESULT hr=S_OK;

	LPCOLESTR szAssemblyName;
#ifndef UNICODE
	CTempBuffer<WCHAR, MAX_PATH>  rgchAssemblyName;
	ConvertMultiSzToWideChar(ristrAssemblyName, rgchAssemblyName);
	szAssemblyName = rgchAssemblyName;
#else
	szAssemblyName = ristrAssemblyName.GetString();
#endif

	if(iatAT == iatURTAssembly)
		hr = FUSION::CreateAssemblyCache(&pCache, 0);
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyCache(&pCache, 0);
	}

	if(!SUCCEEDED(hr))
	{
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), ristrAssemblyName.GetString(), iatAT);
	}
  	hr = pCache->UninstallAssembly(0, szAssemblyName, NULL, NULL);
	if(!SUCCEEDED(hr))
	{
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT("IAssemblyCache"), TEXT("UninstallAssembly"), ristrAssemblyName.GetString(), iatAT);
	}
    	return 0;
}


Bool CMsiOpExecute::GetFileState(const IMsiString& ristrFilePath,
											icfsEnum* picfsState,
											const IMsiString** ppistrTempLocation,
											int* pcPatchesRemaining,
											int* pcPatchesRemainingToSkip)
{
	if(!m_pFileCacheCursor)
		return fFalse;

	MsiString strFilePath;
	ristrFilePath.LowerCase(*&strFilePath);
	m_pFileCacheCursor->Reset();
	AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheFilePath,*strFilePath));
	if(!m_pFileCacheCursor->Next())
		return fFalse;

	if(picfsState)
		*picfsState = (icfsEnum)m_pFileCacheCursor->GetInteger(m_colFileCacheState);

	if(ppistrTempLocation)
		*ppistrTempLocation = &m_pFileCacheCursor->GetString(m_colFileCacheTempLocation);

	if(pcPatchesRemaining)
	{
		*pcPatchesRemaining = m_pFileCacheCursor->GetInteger(m_colFileCacheRemainingPatches);
		if(*pcPatchesRemaining == iMsiNullInteger)
			*pcPatchesRemaining = 0;
	}
	
	if(pcPatchesRemainingToSkip)
	{
		*pcPatchesRemainingToSkip = m_pFileCacheCursor->GetInteger(m_colFileCacheRemainingPatchesToSkip);
		if(*pcPatchesRemainingToSkip == iMsiNullInteger)
			*pcPatchesRemainingToSkip = 0;
	}

	return fTrue;
}

/*---------------------------------------------------------------------------
ixoFileCopy: Copy a file from source to target (depends upon the internal
state previously set up by preceding actions).
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFileCopy(IMsiRecord& riParams)
{
	using namespace IxoFileCopy;

	// If the cabinet copier notified us that a media change is required,
	// we must defer any file copy requests until a media change is executed.
	if (m_state.fWaitingForMediaChange)
	{
		PushRecord(riParams);
		return iesSuccess;
	}

	int fInstallModeFlags = riParams.GetInteger(InstallMode);
	ielfEnum ielfCurrentElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate :
												  (ielfEnum)riParams.GetInteger(ElevateFlags);

	if (fInstallModeFlags & icmRunFromSource)
	{
		//!! Log RunFromSource install state, as soon as we decide how
		/*IMsiRecord& riLogRec = GetSharedRecord(3);
		ISetErrorCode(&riLogRec, Imsg(imsgLogFileRunFromSource));
		AssertNonZero(riLogRec.SetMsiString(1,strDestName)));
		Message(imtInfo,riLogRec);*/
		return iesSuccess;
	}

	PMsiRecord pRecErr(0);
	PMsiPath pTargetPath(0);
	MsiString strDestPath = riParams.GetMsiString(DestName);
	MsiString strDestName;
	
	// check if files are full or relative paths
	if(ENG::PathType(strDestPath) == iptFull)
	{
			iesEnum iesResult = CreateFilePath(strDestPath,*&pTargetPath,*&strDestName);
			if (iesResult != iesSuccess)
				return iesResult;

		AssertNonZero(riParams.SetMsiString(DestName, *strDestName)); // replace full path with file name
	}
	else
	{
		pTargetPath = m_state.pTargetPath;
		strDestName = strDestPath;
	}

	if(!pTargetPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoFileCopy")));
		return iesFailure;
	}
	
	// target name and path may be redirected below, but we want the action data message to contain
	// the original file information, so we'll store that away here
	MsiString strActionDataDestName = strDestName;
	MsiString strActionDataDestPath = pTargetPath->GetPath();

	iesEnum iesRet = iesNoAction;
#ifdef DEBUG
	ICHAR rgchDestName[256];
	strDestName.CopyToBuf(rgchDestName,255);
#endif
	if(!strDestName.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam),
						  MsiString(*TEXT("ixoFileCopy")),(int)DestName);
		return iesFailure;
	}

	// STEP 1: version check existing file
	
	// If we're in the middle of copying a split file, we know the install verification
	// state has already been determined - don't want to check it again (especially since
	// the partial new file is now sitting in the dest directory!).

	Bool fShouldInstall = fFalse;

	static iehEnum s_iehErrorMode = iehShowNonIgnorableError;
	if (m_state.fSplitFileInProgress)
	{
		fShouldInstall = fTrue;
	}
	else
	{
		MsiString strVersion(riParams.GetMsiString(Version));
		MsiString strLanguage(riParams.GetMsiString(Language));
		MsiString strTargetFullPath;
		if((pRecErr = pTargetPath->GetFullFilePath(strDestName,*&strTargetFullPath)) != 0)
			return FatalError(*pRecErr);

		ifsEnum ifsState;
		int fBitVersioning;
		Bool fCompanionFile = fFalse;
		Bool fCompanionFileHashOverride = fFalse;
		MsiString strLogParentFileName;

		MD5Hash hHash;
		MD5Hash* pHash = 0;
		if(riParams.IsNull(HashOptions) == fFalse)
		{
			hHash.dwFileSize = riParams.GetInteger(FileSize);
			hHash.dwPart1    = riParams.GetInteger(HashPart1);
			hHash.dwPart2    = riParams.GetInteger(HashPart2);
			hHash.dwPart3    = riParams.GetInteger(HashPart3);
			hHash.dwPart4    = riParams.GetInteger(HashPart4);

			pHash = &hHash;
		}

		// If a CompanionParent has been set up for this file, we'll use that parent's
		// name and version for our InstallState verification check.
		for (;;)
		{
			if (m_state.strParentFileName.TextSize())
			{
				fCompanionFile = fTrue;
				pRecErr = m_state.pParentPath->GetCompanionFileInstallState(*(m_state.strParentFileName),
																					*(m_state.strParentVersion),
																					*(m_state.strParentLanguage),
																					*pTargetPath,
																					*strDestName,
																					pHash,
																					ifsState,fShouldInstall,0,0,fInstallModeFlags,
																					&fBitVersioning);
				strLogParentFileName = m_state.strParentFileName;
				m_state.strParentFileName = TEXT("");
				m_state.strParentVersion = TEXT("");
				m_state.strParentLanguage = TEXT("");

			}
			else
			{
				pRecErr = pTargetPath->GetFileInstallState(*strDestName,*strVersion,*strLanguage,pHash,ifsState,
																		 fShouldInstall,0,0,fInstallModeFlags,&fBitVersioning);
			}
			if (pRecErr)
			{
				if (pRecErr->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
			}

			// We've got 3 potential modes if/when an error occurs:
			// - if our source file is unversioned, is NOT a companion file, and there's an existing
			//   version of the file at the destination, AND the reinstall mode doesn't specify that all
			//   files must be replaced, then we'll silently ignore the error, and go on.
			// - Otherwise, we go by the fVital flag to determine whether an ignore button appears on
			//   the resulting error dialog
			Bool fVital = riParams.GetInteger(Attributes) & msidbFileAttributesVital ? fTrue : fFalse;
			if (!(fBitVersioning & ifBitNewVersioned) && !fCompanionFile && (ifsState & ifsBitExisting) && ifsState != ifsExistingAlwaysOverwrite)
				s_iehErrorMode = iehSilentlyIgnoreError;
			else
				s_iehErrorMode = fVital ? iehShowNonIgnorableError : iehShowIgnorableError;

			if (ifsState == ifsExistingFileInUse)
			{
				MsiString strFullPath;
				if (m_state.strParentFileName.TextSize())
					m_state.pParentPath->GetFullFilePath(m_state.strParentFileName,*&strFullPath); //!! error record leak
				else
					strFullPath = strTargetFullPath;

				if (s_iehErrorMode == iehSilentlyIgnoreError)
				{
					// Just log the error and go on
					DispatchError(imtInfo, Imsg(imsgSharingViolation), *strFullPath);
					return (iesEnum) iesErrorIgnored;
				}

				switch (ShowFileErrorDialog(Imsg(imsgSharingViolation),*strFullPath,fVital))
				{
				case imsIgnore:
					return (iesEnum) iesErrorIgnored;
				case imsRetry:
					continue;
				default:  // imsCancel
					return iesFailure;
				};
			}
			else
				break;
		}

		int iCachedState = 0;
		if (fShouldInstall)
		{
			AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
						g_szNoSFCMessage);
			BOOL fProtected = false;
			if ( g_MessageContext.m_hSfcHandle && !(ielfCurrentElevateFlags & ielfBypassSFC))
				fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strTargetFullPath));
			if (fProtected)
			{
				iCachedState |= icfsProtected;

				MsiString strProtectedVersion;
				PMsiRecord(pTargetPath->GetFileVersionString(strDestName, *&strProtectedVersion));
				if (ifsState == ifsExistingEqualVersion || ifsState == ifsExistingNewerVersion ||
					ifsState == ifsExistingAlwaysOverwrite)
				{
					DEBUGMSG3(TEXT("The Installer did not reinstall the file %s, because it is protected by Windows. ")
						TEXT("Either the existing file is an equal or greater version, or the installer was requested ")
						TEXT("to re-install all files regardless of version.  Package version: %s, ")
						TEXT("existing version: %s"), strTargetFullPath, strVersion, strProtectedVersion);
				}
				else if (ifsState & ifsBitExisting)
				{
					imtEnum imtButtons = imtEnum(imtError + imtOkCancel);
					imsEnum imsResponse = DispatchError(imtButtons, Imsg(imsgCannotUpdateProtectedFile), *strTargetFullPath,
														*strVersion, *strProtectedVersion);
					if (imsResponse == imsCancel)
						return iesFailure;
				}
				else
				{
					// set bit for use by ixfInstallProtectedFiles
					iCachedState |= icfsProtectedInstalledBySFC;
				}

				pRecErr = CacheFileState(*strTargetFullPath,(icfsEnum*)&iCachedState,
												 0, strVersion, 0, 0);
				if(pRecErr)
					return FatalError(*pRecErr);

				return iesSuccess;
			}
		}

		// if this file is to be patched (patch headers have been passed in riParams)
		// then test the patches
		Bool fShouldPatch = fFalse;
		bool fPatches = (!riParams.IsNull(TotalPatches) && riParams.GetInteger(TotalPatches) > 0) ? true : false;
		int cPatchesToSkip = 0;
		if(fShouldInstall && fPatches)
		{
			if(FFileExists(*pTargetPath,*strDestName))
			{
			
				icpEnum icpPatchTest;
				int iPatchIndex = 0;
				if((iesRet = TestPatchHeaders(*pTargetPath, *strDestName, riParams, icpPatchTest, iPatchIndex)) != iesSuccess)
					return iesRet;

				if(icpPatchTest == icpCanPatch || icpPatchTest == icpUpToDate)
				{
					// file can already be patched, so don't need to install file
					fShouldInstall = fFalse;
					fShouldPatch = icpPatchTest == icpCanPatch ? fTrue : fFalse;

					cPatchesToSkip = iPatchIndex - 1; // iPatchIndex is the index of the first patch that could be applied
																 // properly to this file.  so we need to skip the patches that come
																 // before it.
				}
				else if(icpPatchTest == icpCannotPatch)
				{
					// can't patch the file as it stands
					// but fShouldInstall is true so we'll recopy the source file first which should be patchable
					fShouldPatch = fTrue;

					cPatchesToSkip = 0; // need to copy source file and apply all patches
				}
				else
				{
					AssertSz(0, "Invalid return from TestPatchHeaders()");
				}
			}
			else
			{
				fShouldPatch = fTrue;
			}
		}

		// If in verbose mode, log the results of file version checking
		if (FDiagnosticModeSet(dmVerboseDebugOutput|dmVerboseLogging))
		{
			enum iverEnum
			{
				iverAbsent = 0,
				iverExistingLower,
				iverExistingEqual,
				iverExistingNewer,
				iverExistingCorrupt,
				iverOverwriteAll,
				iverNewVersioned,
				iverOldVersioned,
				iverOldUnmodifiedHashMatch,
				iverOldModified,
				iverExistingLangSubset,
				iverOldUnmodifiedHashMismatch,
				iverOldUnmodifiedNoHash,
				iverUnknown,
				iverNextEnum
			};
			const ICHAR szVer[][96] = {TEXT("No existing file"),
								  TEXT("Existing file is a lower version"),
								  TEXT("Existing file is of an equal version"),
								  TEXT("Existing file has a newer version"),
								  TEXT("Existing file is corrupt (invalid checksum)"),
								  TEXT("REINSTALLMODE specifies all files to be overwritten"),
								  TEXT("New file versioned - existing file unversioned"),
								  TEXT("New file unversioned - existing file versioned"),
								  TEXT("Existing file is unversioned and unmodified - hash matches source file"),
								  TEXT("Existing file is unversioned but modified"),
								  TEXT("New file supports language(s) the existing file doesn't support"),
								  TEXT("Existing file is unversioned and unmodified - hash doesn't match source file"),
								  TEXT("Existing file is unversioned and unmodified - no source file hash provided to compare"),
								  TEXT("")};

			enum iomEnum
			{
				iomInstall = 0,
				iomNoOverwrite,
				iomOverwrite,
				iomNextEnum
			};
			const ICHAR szOverwrite[][20] = {TEXT("To be installed"),
											 TEXT("Won't Overwrite"),
											 TEXT("Overwrite")};
			enum ipmEnum
			{
				ipmNoPatch = 0,
				ipmWillPatch,
				ipmWontPatch,
				ipmNextEnum
			};
			const ICHAR szPatchMsg[][20] = {TEXT("No patch"),
													  TEXT("Will patch"),
													  TEXT("Won't patch")};

			const ICHAR szCompanion[] = TEXT("  (Checked using version of companion: %s)");

			iverEnum iver = iverUnknown;
			if (ifsState == ifsAbsent)
				iver = iverAbsent;
			else if (ifsState == ifsExistingAlwaysOverwrite)
				iver = iverOverwriteAll;
			else if ((fBitVersioning & ifBitNewVersioned) && !(fBitVersioning & ifBitExistingVersioned))
				iver = iverNewVersioned;
			else if (!(fBitVersioning & ifBitNewVersioned) && (fBitVersioning & ifBitExistingVersioned))
				iver = iverOldVersioned;
			else if (!(fBitVersioning & ifBitNewVersioned) && !(fBitVersioning & ifBitExistingVersioned))
			{
				// both files unversioned
				if(ifsState == ifsExistingEqualVersion)
				{
					Assert((fBitVersioning & ifBitExistingModified) == 0);
					iver = iverOldUnmodifiedHashMatch;					
				}
				else if(ifsState == ifsExistingLowerVersion)
				{
					Assert((fBitVersioning & ifBitExistingModified) == 0);
					if(fBitVersioning & ifBitUnversionedHashMismatch)
						iver = iverOldUnmodifiedHashMismatch;
					else
						iver = iverOldUnmodifiedNoHash;
				}
				else if(ifsState == ifsExistingNewerVersion)
				{
					Assert((fBitVersioning & ifBitExistingModified));
					iver = iverOldModified;
				}
			}
			else
			{
				// both files versioned
				Assert((fBitVersioning & ifBitNewVersioned) && (fBitVersioning & ifBitExistingVersioned));
				
				if (fBitVersioning & ifBitExistingLangSubset)
					iver = iverExistingLangSubset;
				else
				{
					switch (ifsState)
					{
						case ifsExistingLowerVersion:  iver = iverExistingLower;break;
						case ifsExistingEqualVersion:  iver = iverExistingEqual;break;
						case ifsExistingNewerVersion:  iver = iverExistingNewer;break;
						case ifsExistingCorrupt:       iver = iverExistingCorrupt;break;
						default:Assert(0);iver = iverUnknown;break;
					}
				}
			}
			CTempBuffer<ICHAR,1> rgchCompanion(MAX_PATH);
			rgchCompanion[0] = 0;
			if (fCompanionFile && iver != iverAbsent && iver != iverOverwriteAll)
			{
				MsiString strCompanionFullPath;
				if((pRecErr = m_state.pParentPath->GetFullFilePath(strLogParentFileName,*&strCompanionFullPath)) != 0)
					return FatalError(*pRecErr);
				if (strCompanionFullPath.TextSize() + IStrLen(szCompanion) < MAX_PATH)
				{
					if (FAILED(StringCchPrintf(rgchCompanion, rgchCompanion.GetSize(), szCompanion,(const ICHAR*) strCompanionFullPath)))
						return FatalError(*PMsiRecord(PostError(Imsg(idbgNoCompanionParent), szCompanion, ERROR_INSUFFICIENT_BUFFER)));
				}
			}
			iomEnum iomOverwriteMode = iomInstall;
			if (iver != iverAbsent)
				iomOverwriteMode = fShouldInstall ? iomOverwrite : iomNoOverwrite;
			ipmEnum ipmPatchMode = ipmNoPatch;
			if (fPatches)
				ipmPatchMode = fShouldPatch ? ipmWillPatch : ipmWontPatch;
			DEBUGMSG5(TEXT("File: %s;  %s;  %s;  %s%s"), (const ICHAR*) strTargetFullPath,
						  szOverwrite[iomOverwriteMode],
						  szPatchMsg[ipmPatchMode],
						  szVer[iver],rgchCompanion);
		}

		if(!fShouldInstall)
			iCachedState |= icfsFileNotInstalled;


		MsiString strTempFileFullPathForPatch;
		if(fShouldPatch)
		{
			iCachedState |= icfsPatchFile;

			if(fShouldInstall)
			{
				// we are copying a file that will be subsequently patched
				// we will delay overwriting the existing file until we have a fully patched file
				// this is done by copying the file to a temp location (\config.msi folder, random name)
				// and patching that file.  the patch opcode will then copy the patched file to the
				// correct name

				PMsiPath pTempFolder(0);
				if((iesRet = GetBackupFolder(pTargetPath, *&pTempFolder)) != iesSuccess)
					return iesRet;

				MsiString strTempFileNameForPatch;

				{ // scope elevation
					CElevate elevate; // elevate to create temp file on secure temp folder
					if((pRecErr = pTempFolder->TempFileName(TEXT("PT"),0,fTrue,*&strTempFileNameForPatch, 0)) != 0)
						return FatalError(*pRecErr);
				}

				if((pRecErr = pTempFolder->GetFullFilePath(strTempFileNameForPatch,*&strTempFileFullPathForPatch)) != 0)
					return FatalError(*pRecErr);
				
				// we need to keep this file around as a placeholder for the name
				// filecopy will back this file up and restore it on rollback, so we need another rollback op to delete this file
				IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
				AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName, *strTempFileFullPathForPatch));

				if (!RollbackRecord(ixoFileRemove, riUndoParams))
					return iesFailure;

				// reset copy arguments to reflect new file copy - new path, new filename, and since
				// the file is being copied into the secured config folder, we need to elevate for the target
				// NOTE: we aren't changing strDestName, which is used below
				//       for those uses it is correct to use the original dest name
				AssertNonZero(riParams.SetMsiString(DestName,*strTempFileNameForPatch));
				pTargetPath = pTempFolder;
 
				AssertNonZero(riParams.SetInteger(ElevateFlags, ielfCurrentElevateFlags | ielfElevateDest));

				DEBUGMSG2(TEXT("Redirecting file copy of '%s' to '%s'.  A subsequent patch will update the intermediate file, and then copy over the original."),
									(const ICHAR*)strTargetFullPath, (const ICHAR*)strTempFileFullPathForPatch);
			}

		}

		int iTotalPatches = riParams.IsNull(TotalPatches) ? 0 : riParams.GetInteger(TotalPatches);
		
		pRecErr = CacheFileState(*strTargetFullPath,(icfsEnum*)&iCachedState,
										 strTempFileFullPathForPatch, strVersion,
										 &iTotalPatches, &cPatchesToSkip);
		if(pRecErr)
			return FatalError(*pRecErr);
	}
	
	if(!fShouldInstall && !(fInstallModeFlags & icmRemoveSource))
	{
		// not moving the file, and not installing the file, so there is nothing left to do
		return iesSuccess;
	}

	// end of version/patch checking.  if we got this far, it means the sourcepath is required
	// to continue  determine source path now...


	// STEP 2: resolve source path and type
	
	PMsiPath pSourcePath(0);
	bool fCabinetCopy = false;
	bool fMoveFile    = false;

	if(m_state.fSplitFileInProgress)
	{
		// must be a cabinet copy
		fCabinetCopy = true;
	}
	else
	{
		if((iesRet = ResolveSourcePath(riParams, *&pSourcePath, fCabinetCopy)) != iesSuccess)
			return iesRet;

		fMoveFile = ((fInstallModeFlags & icmRemoveSource) && (fCabinetCopy == false)) ? fTrue : fFalse;
	}


	// STEP 3: perform copy/move operation
	
	if (!fShouldInstall)
	{
		if(fMoveFile)
		{
			// won't copy new file but still need to remove source file 
			Assert(pSourcePath);
			return RemoveFile(*pSourcePath, *MsiString(riParams.GetMsiString(SourceName)), fTrue, /*fBypassSFC*/ false);
		}
		return iesSuccess;
	}
	else if(!fCabinetCopy)
	{
		// if source and target paths and filenames are the same, skip file copy
		// NOTE: this will happen when patching an admin image - this check prevents us from
		//       attempting to install files over themselves
		//       we must make this check here instead of InstallFiles since the version check
		//       above is required for patching in the subsequent ixoPatchApply operation

		// a quick check is to compare the serial numbers of the two volumes
		// if they are the same then we will compare the SFN versions of each path
		if(PMsiVolume(&pSourcePath->GetVolume())->SerialNum() ==
			PMsiVolume(&pTargetPath->GetVolume())->SerialNum())
		{
			// volumes most likely match, now let's check SFN paths
			MsiString strSourceFullPath, strTargetFullPath;
			CTempBuffer<ICHAR,1> rgchSourceFullPath(MAX_PATH);
			CTempBuffer<ICHAR,1> rgchTargetFullPath(MAX_PATH);
			
			if((pRecErr = pSourcePath->GetFullFilePath(MsiString(riParams.GetMsiString(SourceName)),
																	 *&strSourceFullPath)) == 0 &&
				(pRecErr = pTargetPath->GetFullFilePath(strDestName, *&strTargetFullPath)) == 0 &&
				ConvertPathName(strSourceFullPath, rgchSourceFullPath, cpToShort) &&
				ConvertPathName(strTargetFullPath, rgchTargetFullPath, cpToShort) &&
				(IStrCompI(rgchSourceFullPath, rgchTargetFullPath) == 0))
			{
				// short names match
				return iesSuccess;
			}
		}
	}

	// action data
	// NOTE: the action data is sent here so we don't say we are copying a file before
	// we really know if we will copy it or not (fShouldInstall == fFalse)
	IMsiRecord& riActionData = GetSharedRecord(9);
	AssertNonZero(riActionData.SetMsiString(1, *strActionDataDestName));
	AssertNonZero(riActionData.SetInteger(6,riParams.GetInteger(FileSize)));
	AssertNonZero(riActionData.SetMsiString(9, *strActionDataDestPath));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// perform operation
	bool fForever = true;
	while ( fForever )
	{
		if(fMoveFile)
		{
			Assert(!m_state.fSplitFileInProgress);
			iesRet = MoveFile(*pSourcePath, *pTargetPath, riParams, fTrue, fTrue, true, false,iehShowNonIgnorableError); // handles rollback
		}
		else
		{
			iesRet = CopyFile(*pSourcePath, *pTargetPath, riParams, /*fHandleRollback=*/ fTrue, s_iehErrorMode, fCabinetCopy);
		}
		if ( iesRet != iesSuccess || 
			  m_state.fSplitFileInProgress ||
			  riParams.GetInteger(CheckCRC) == iMsiNullInteger ||
			  !riParams.GetInteger(CheckCRC) )
			return iesRet;

		// we go ahead and check the checksum
		MsiString strDestFile;
		PMsiPath pDestPath(0);

		pRecErr = pTargetPath->GetFullFilePath(strDestName, *&strDestFile);
		if ( !pRecErr )
		{
			MsiString strTemp;
			Bool fRes = GetFileState(*strDestFile, 0, &strTemp, 0, 0);
			if ( fRes && strTemp.TextSize() )
			{
				// the file landed into a temp location: we need to check that temporary copy.
				pRecErr = m_riServices.CreateFilePath(strTemp, *&pDestPath, *&strDestFile);
				if ( !pRecErr )
					DEBUGMSG2(TEXT("File %s actually installed to %s; checking CRC of temporary copy."),
								 strDestName, strTemp);
			}
			else
			{
				//  the file didn't land in a temporary location
				strDestFile = strDestName;
				pDestPath = pTargetPath;
			}
		}
		if ( pRecErr )
			return (iesEnum)iesErrorIgnored;

		imsEnum imsClickedButton;
		bool fVitalFile = 
			((riParams.GetInteger(Attributes) & msidbFileAttributesVital) == 
			msidbFileAttributesVital) ? true : false;
		if ( !IsChecksumOK(*pDestPath, *strDestFile,
								 fMoveFile ? Imsg(imsgOpBadCRCAfterMove) : Imsg(imsgOpBadCRCAfterCopy),
								 &imsClickedButton, /* fErrorDialog = */ true,
								 fVitalFile, /* fRetryButton = */ !fCabinetCopy && !fMoveFile) )
		{
			switch (imsClickedButton)
			{
				case imsRetry:
					continue;
				case imsIgnore:
					return (iesEnum)iesErrorIgnored;
				case imsAbort:
				case imsCancel:
					return iesUserExit;
				default:
					Assert(imsClickedButton == imsNone || imsClickedButton == imsOk);
					return fVitalFile ? iesFailure : (iesEnum)iesErrorIgnored;
			};
		}
		else
			return iesSuccess;
	}  // while ( true )

	return iesSuccess;  // should never get here: it's for the compiler
}


iesEnum CMsiOpExecute::VerifyAccessibility(IMsiPath& riPath, const ICHAR* szFile, DWORD dwAccess, iehEnum iehErrorMode)
{
	// will return iesErrorIgnored if file cannot be accessed and the user either ignores the error, or
	// iehSilentlyIgnoreError is passed in for the iehErrorMode parameter.
	
	if(g_fWin9X)
		return iesSuccess; // all files accessible on Win9X

	for (;;)
	{
		DEBUGMSGV1(TEXT("Verifying accessibility of file: %s"), szFile);
		
		bool fVerified = false;
		PMsiRecord pRecErr = riPath.FileCanBeOpened(szFile, dwAccess, fVerified);
		
		if (pRecErr == 0 && fVerified)
		{
			break;
		}

		MsiString strFullPath;
		riPath.GetFullFilePath(szFile, *&strFullPath);

		if (!fVerified)
			pRecErr = PostError(Imsg(imsgAccessToFileDenied), *strFullPath);

		if (iehErrorMode == iehSilentlyIgnoreError)
		{
			Message(imtInfo, *pRecErr);
			return (iesEnum) iesErrorIgnored;
		}
		
		imtEnum imtButtons = iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore;
		switch(DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue))
		{
		case imsIgnore:
			return (iesEnum) iesErrorIgnored;
		case imsRetry:
			continue;
		default:  // imsCancel
			return iesFailure;
		};
	}

	return iesSuccess;
}

#ifndef DEBUG
inline
#endif
bool IsRetryableError(const int iError)
{
	return (iError == imsgNetErrorReadingFromFile || iError == imsgErrorReadingFromFile ||
			  iError == imsgNetErrorOpeningCabinet || iError == imsgErrorOpeningCabinet ||
			  iError == imsgErrorOpeningFileForRead || iError == imsgCorruptCabinet);
}

iesEnum CMsiOpExecute::CopyFile(IMsiPath& riSourcePath, IMsiPath& riTargetPath, IMsiRecord& riParams,
								Bool fHandleRollback, iehEnum iehErrorMode, bool fCabinetCopy)
{
	return _CopyFile(riSourcePath, &riTargetPath, 0,  false, riParams, fHandleRollback, iehErrorMode, fCabinetCopy);
}

iesEnum CMsiOpExecute::CopyFile(IMsiPath& riSourcePath, IAssemblyCacheItem& riASM, bool fManifest, IMsiRecord& riParams,
								Bool fHandleRollback, iehEnum iehErrorMode, bool fCabinetCopy)
{
	return _CopyFile(riSourcePath, 0, &riASM, fManifest, riParams, fHandleRollback, iehErrorMode, fCabinetCopy);

}

iesEnum CMsiOpExecute::_CopyFile(IMsiPath& riSourcePath, IMsiPath* piTargetPath, IAssemblyCacheItem* piASM,  bool fManifest, IMsiRecord& riParams,
								Bool fHandleRollback, iehEnum iehErrorMode, bool fCabinetCopy)

{
	// NOTE: riSourcePath may be a reference to a NULL pointer if cabinet copy
	// NOTE: piTargetPath will be NULL if invoked by ixfAssemblyCopy and piASM will not be NULL for assembly copies only
	
	using namespace IxoFileCopyCore;
	
    int iNetRetries = 0;
	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;

	// for uncompressed files, the source path is passed in, for compressed copies riSourcePath is invalid
	//!! should fix that, shouldn't pass in reference to null pointer
	PMsiPath pSourcePath(0);
	if(!fCabinetCopy)
	{
		pSourcePath = &riSourcePath;
		riSourcePath.AddRef();
	}

	MsiString strKeyName = riParams.GetMsiString(SourceName);
	if (fCabinetCopy && strKeyName.Compare(iscExactI, m_state.strLastFileKey))
	{
		//?? Will not work if the file is installed to a fusion assembly
		//?? dont think we need to support duplicate file copy for files belonging to fusion assemblies
		//!! need validation to prevent this from happening
		pSourcePath = m_state.pLastTargetPath;
		riParams.SetMsiString(SourceName, *m_state.strLastFileName);
		fCabinetCopy = fFalse;
	}
	
	if(pSourcePath && piTargetPath && !fCabinetCopy)
	{
		// if source and target paths and filenames are the same, skip file copy
		// a quick check is to compare the serial numbers of the two volumes
		// if they are the same then we will compare the SFN versions of each path
		if(PMsiVolume(&pSourcePath->GetVolume())->SerialNum() ==
			PMsiVolume(&piTargetPath->GetVolume())->SerialNum())
		{
			// volumes most likely match, now let's check SFN paths
			MsiString strSourceFullPath, strTargetFullPath;
			CTempBuffer<ICHAR,1> rgchSourceFullPath(MAX_PATH);
			CTempBuffer<ICHAR,1> rgchTargetFullPath(MAX_PATH);
			
			if((pRecErr = pSourcePath->GetFullFilePath(MsiString(riParams.GetMsiString(SourceName)),
													   *&strSourceFullPath)) == 0 &&
			   (pRecErr = piTargetPath->GetFullFilePath(MsiString(riParams.GetMsiString(DestName)),
													   *&strTargetFullPath)) == 0 &&
			   ConvertPathName(strSourceFullPath, rgchSourceFullPath, cpToShort) &&
			   ConvertPathName(strTargetFullPath, rgchTargetFullPath, cpToShort) &&
			   (IStrCompI(rgchSourceFullPath, rgchTargetFullPath) == 0))
			{
				// short names match
				return iesSuccess;
			}
		}
	}

	CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // will set file name if actually downloaded

	ielfEnum ielfElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate : (ielfEnum)riParams.GetInteger(ElevateFlags);
	
	if (!m_state.fSplitFileInProgress)
	{
		m_state.cbFileSoFar = 0;

		// skip security acls, rollback for existing file and folder creation stuff for fusion files
		if(piTargetPath)
		{
			bool fNoSecurityDescriptor = riParams.IsNull(SecurityDescriptor) == fTrue;
			MsiString strDestFullFilePath;

			if (fNoSecurityDescriptor || fHandleRollback)
			{
				pRecErr = piTargetPath->GetFullFilePath(riParams.GetString(DestName),
																	*&strDestFullFilePath);

				if (pRecErr)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
			}

			// we need to preserve the destination ACL if we're not already applying a descriptor to the dest file
			if (fNoSecurityDescriptor)
			{
				Assert(strDestFullFilePath.TextSize());

				Bool fExists = fFalse;
				pRecErr = piTargetPath->FileExists(MsiString(riParams.GetString(DestName)), fExists);
				if (pRecErr)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}

				if (fExists)
				{
					PMsiStream pSecurityDescriptor(0);

					DEBUGMSGV("Re-applying security from existing file.");
					if ((iesRet = GetSecurityDescriptor(strDestFullFilePath, *&pSecurityDescriptor)) != iesSuccess)
						return iesRet;

					AssertNonZero(riParams.SetMsiData(SecurityDescriptor, pSecurityDescriptor));
				}
			}

			// HandleExistingFile may change the value of riParams[IxoFileCopy::DestFile] if the existing file
			// cannot be moved
			bool fFileExists = false;
			if((iesRet = HandleExistingFile(*piTargetPath,riParams,fHandleRollback,iehErrorMode, fFileExists)) != iesSuccess)
				return iesRet;

			if(fHandleRollback && !fFileExists)
			{
				// if we aren't overwriting an existing file, generate undo op to remove new file
				// otherwise the undo op to put the backup file back will overwrite the new file
				// NOTE: to fix bug 7376, we avoid doing a remove then replace during rollback

				// do this before the copy begins in case the copy fails part way through

				Assert(strDestFullFilePath.TextSize());

				IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
				AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName,
																	 *strDestFullFilePath));

				if(ielfElevateFlags & ielfElevateDest)
				{
					// if we will elevate to copy this file, it means we will have to elevate
					// to remove the file on rollback
					AssertNonZero(riUndoParams.SetInteger(IxoFileRemove::Elevate,1));
				}
				
				if (!RollbackRecord(ixoFileRemove, riUndoParams))
					return iesFailure;
			}

			// scope elevate
			{
				CElevate elevate(Tobool(ielfElevateFlags & ielfElevateDest));

				if((iesRet = CreateFolder(*piTargetPath)) != iesSuccess)
					return iesRet;
			}
		}
	}
	

#ifdef DEBUG
	const ICHAR* szDebug = riParams.GetString(DestName);
#endif DEBUG
	m_state.fSplitFileInProgress = fFalse;  
	unsigned int cbFileSize = riParams.GetInteger(FileSize);
	int iPerTick = riParams.GetInteger(PerTick);

	

	// for URL downloads, the source name may be re-directed.
	// if it is, we will change pSourcePath and riParams[SourceName]

	PMsiVolume piSourceVolume(0);
	if (pSourcePath)
		piSourceVolume = &(pSourcePath->GetVolume());

	imtEnum imtButtons = iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore;

	int iCopyAttributes = riParams.GetInteger(Attributes);

	if (piSourceVolume && piSourceVolume->IsURLServer())
	{
		int cAutoRetry = 0;
		for(;;)
		{
			// download the file to the cache, and redirect the source name and path.
			// downloading cabs are handled elsewhere...
			
			// check if absent source file = zero-length target file
			int iCopyAttrib = riParams.GetInteger(IxoFileCopyCore::Attributes);
			if ((iCopyAttrib & (ictfaNoncompressed | ictfaCompressed)) == (ictfaNoncompressed | ictfaCompressed))
				break;

			MsiString strSourceURL;
			pSourcePath->GetFullFilePath(riParams.GetString(SourceName), *&strSourceURL);
			Assert(strSourceURL);
			MsiString strCacheFileName;
 
			bool fFileUrl = true;

			bool fUrl = IsURL((const ICHAR*)strSourceURL, fFileUrl);
			if (fFileUrl)
			{
				// canonicalize and convert
				CTempBuffer<ICHAR, 1> rgchFullFilePath(cchExpectedMaxPath + 1);
				DWORD cchFullFilePath = rgchFullFilePath.GetSize();
				if (MsiConvertFileUrlToFilePath((const ICHAR*)strSourceURL, rgchFullFilePath, &cchFullFilePath, 0))
				{
					MsiString strSourceName;
					AssertRecord(m_riServices.CreateFilePath(rgchFullFilePath, *&pSourcePath, *&strSourceName));
					AssertNonZero(riParams.SetMsiString(SourceName,*strSourceName));
				}
				break;
			}

			bool fUsedWinHttp = true;
			UINT iStat = DownloadUrlFile((const ICHAR*) strSourceURL, *&strCacheFileName, fUrl, -1, &fUsedWinHttp);

			if (ERROR_SUCCESS == iStat)
			{
				MsiString strSourceName;
				AssertRecord(m_riServices.CreateFilePath((const ICHAR*) strCacheFileName, *&pSourcePath, *&strSourceName));
				AssertNonZero(riParams.SetMsiString(SourceName,*strSourceName));
				cDeleteUrlLocalFileOnClose.SetFileName(fUsedWinHttp ? *strCacheFileName : *strSourceURL, /* fDeleteFromIECache = */ !fUsedWinHttp);
				break;
			}
			else
			{
				pRecErr = PostError(Imsg(imsgErrorSourceFileNotFound), (const ICHAR*) strSourceURL);

				if (iehErrorMode == iehSilentlyIgnoreError)
				{
					Message(imtInfo, *pRecErr); // Make sure we write to the non-verbose log
					return (iesEnum) iesErrorIgnored;
				}

				
				// give the download 3 retries, then give up and prompt the user.  They can always keep retrying
				// or ignore themselves.
				if (cAutoRetry < 2)
				{
					cAutoRetry++;
					DispatchMessage(imtInfo, *pRecErr, fTrue);
					continue;
				}
				else
				{
					cAutoRetry = 0;
				}

				switch(DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue))
				{
				case imsRetry:
					continue;

				case imsIgnore:
					return (iesEnum) iesErrorIgnored;
				
				case imsCancel:
				case imsAbort:
					return iesUserExit;

				case imsNone:
				default:  //imsNone
					return iesFailure;
				}
			}
		}
	}

	iesRet = InitCopier(ToBool(fCabinetCopy),iPerTick,*MsiString(riParams.GetMsiString(SourceName)), pSourcePath, Bool(riParams.GetInteger(VerifyMedia)));
	if (iesRet != iesSuccess)
	{
		return iesRet;
	}

	// if elevating for source or dest exclusively, need to make sure we aren't letting the user do something
	// they couldn't normally do
	if (!fCabinetCopy && ((ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateDest))
	{
		// if we want to elevate for the dest only we still have to elevate for the source.
		// if this is the case then we'd better be sure that, *before* we elevate, we have GENERIC_READ access
		// to the source file

		// SECURITY:  Could this open us to reading from a cabinet the user doesn't have access to?

		iesRet = VerifyAccessibility(*pSourcePath, riParams.GetString(SourceName), GENERIC_READ, iehErrorMode);
		if (iesRet != iesSuccess)
			return iesRet;
	}

	if (piTargetPath && (ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateSource)
	{
		// if we want to elevate for the source only we still have to elevate for the desination.
		// if this is the case then we'd better be sure that, *before* we elevate, we have GENERIC_WRITE access
		// to the destination file

		iesRet = VerifyAccessibility(*piTargetPath, riParams.GetString(DestName), GENERIC_WRITE, iehErrorMode);
		if (iesRet != iesSuccess)
			return iesRet;
	}


	CElevate elevate(Tobool(ielfElevateFlags & (ielfElevateDest|ielfElevateSource)));
	int iPrevError = 0;
	int cSameError = 0;
	bool fDoCopy = true;
	for (;;)
	{
		if ( fDoCopy )
		{
			if(piTargetPath)
				pRecErr = m_state.piCopier->CopyTo(*pSourcePath, *piTargetPath, riParams);
			else
			{
				Assert(piASM);
				pRecErr = m_state.piCopier->CopyTo(*pSourcePath, *piASM, fManifest, riParams);
			}
		}
		else
			pRecErr = 0;

		if (pRecErr)
		{
			int iError = pRecErr->GetInteger(1);
			if ( iError == iPrevError )
				cSameError++;
			else
				cSameError = 0;
			iPrevError = iError;

			// If the copier reported that it needs the next cabinet,
			// we've got to wait until a media change operation
			// executes before continuing with file copying.
			if (iError == idbgNeedNextCabinet)
			{
				// Do this record again right after the media change
				InsertTopRecord(riParams);
				m_state.fSplitFileInProgress = fTrue;
				m_state.fWaitingForMediaChange = fTrue;
				break;
			}
			else if (iError == idbgCopyNotify)
			{
				if(DispatchProgress(iPerTick) == imsCancel)
					return iesUserExit;
				m_state.cbFileSoFar += iPerTick;
			}
			else if (iError == idbgErrorSettingFileTime ||
						iError == idbgCannotSetAttributes)
			{
				// non-critical error - log warning message and end copy
				Message(imtInfo, *pRecErr);
				if(DispatchProgress(cbFileSize - m_state.cbFileSoFar) == imsCancel)
					return iesUserExit;
				break;
			}
			else if (iError == idbgDriveNotReady)
			{
				Assert(m_state.strMediaLabel.TextSize() > 0);
				Assert(m_state.strMediaPrompt.TextSize() > 0);
				PMsiVolume pNewVolume(0);

				UINT uiDisk = 0;
				if (m_state.pCurrentMediaRec)
					uiDisk = m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::IsFirstPhysicalMedia);

				if (!VerifySourceMedia(*m_state.pMediaPath,m_state.strMediaLabel,m_state.strMediaPrompt,
					uiDisk, *&pNewVolume))
				{
					riParams.SetInteger(Attributes, iCopyAttributes | ictfaCancel);
				}
			}
			else if (iError == idbgUserAbort)
			{
				return iesUserExit;
			}
			else if (iError == idbgUserIgnore)
			{
				return (iesEnum) iesErrorIgnored;
			}
			else if (iError == idbgUserFailure)
			{
				return iesFailure;
			}
			else if ( IsRetryableError(iError) &&
						 iNetRetries < MAX_NET_RETRIES )
			{
				iNetRetries++;
				riParams.SetInteger(Attributes, iCopyAttributes | ictfaRestart);
				continue;
			}
			else
			{
				if (iehErrorMode == iehSilentlyIgnoreError)
				{
					Message(imtInfo, *pRecErr);
					if ( cSameError < MAX_NET_RETRIES )
						riParams.SetInteger(Attributes, iCopyAttributes | ictfaIgnore);
					else
						// iError already showed up MAX_NET_RETRIES consecutive times.
						// We need to make sure we do not enter into an infinite loop.
						fDoCopy = false;
					continue;
				}

				if (iError == idbgStreamReadError)
				{
					MsiString strModuleFileName = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::ModuleFileName);
					pRecErr = PostError(Imsg(imsgOpFileCopyStreamReadErr), *strModuleFileName);
					imtButtons = imtRetryCancel; // Can't ignore if we can't access the source stream cabinet
				}
				else if (iError == imsgDiskFull || iError == imsgErrorWritingToFile || iError == imsgErrorReadingFromFile)
					imtButtons = imtRetryCancel; // Can't ignore errors when accessing an open file
				else if (iError == imsgFileNotInCabinet || iError == imsgCABSignatureMissing || iError == imsgCABSignatureRejected)
					imtButtons = imtOk; // Can't continue the install if file not found in cabinet or cabinet's signature rejected
				else
					imtButtons = iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore;

				switch(DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue))
				{
				case imsIgnore:
					riParams.SetInteger(Attributes, iCopyAttributes | ictfaIgnore);
					continue;
				case imsRetry:
					if ( IsRetryableError(iError) )
					{
						iNetRetries = 0;
						riParams.SetInteger(Attributes, iCopyAttributes | ictfaRestart);
					}
					continue;
				case imsOk:
					return iesFailure;
				default:  // imsCancel or imsAbort
					riParams.SetInteger(Attributes, iCopyAttributes | ictfaFailure);
					continue;
				};
			}
		}
		else
		{
			// Dispatch remaining progress for this file
			if(DispatchProgress(cbFileSize - m_state.cbFileSoFar) == imsCancel)
				return iesUserExit;

			if (fCabinetCopy)
			{
				m_state.strLastFileKey = riParams.GetMsiString(SourceName);
				m_state.strLastFileName = riParams.GetMsiString(DestName);
				m_state.pLastTargetPath = piTargetPath;
				if(piTargetPath)
					piTargetPath->AddRef();
			}
			
			break;
		}
	}
	return iesSuccess;
}


iesEnum CMsiOpExecute::BackupFile(IMsiPath& riPath, const IMsiString& ristrFile, Bool fRemoveOriginal,
											 Bool fRemoveFolder, iehEnum iehErrorMode, bool fRebootOnRenameFailure,
											 bool fWillReplace, const IMsiString* pistrAssemblyComponentId, bool fManifest)
{
	Assert(RollbackEnabled());
	PMsiRecord pRecErr(0);
	MsiString strFileFullPath;
	if((pRecErr = riPath.GetFullFilePath(ristrFile.GetString(),
													 *&strFileFullPath)) != 0)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}

	iesEnum iesRet;
	PMsiPath pBackupFolder(0);
	if((iesRet = GetBackupFolder(&riPath,*&pBackupFolder)) != iesSuccess)
		return iesRet;
	
	MsiString strBackupFileFullPath, strBackupFile;
	{
		CElevate elevate;
		if((pRecErr = pBackupFolder->TempFileName(0, szRollbackFileExt, fTrue, *&strBackupFile, 0)) != 0)
			return FatalError(*pRecErr);
	}

	if((pRecErr = pBackupFolder->GetFullFilePath(strBackupFile,*&strBackupFileFullPath)) != 0)
		return FatalError(*pRecErr);
	
	// generate op to register backup file
	{
	using namespace IxoRegisterBackupFile;
	IMsiRecord& riUndoParams = GetSharedRecord(Args);
	AssertNonZero(riUndoParams.SetMsiString(File,*strBackupFileFullPath));
	if (!RollbackRecord(ixoRegisterBackupFile,riUndoParams))
		return iesFailure;
	}

	{
		CElevate elevate;
		// remove temp file so that MoveFile won't attempt to back up old file
		if((pRecErr = pBackupFolder->RemoveFile(strBackupFile)) != 0)
		{
			Message(imtError, *pRecErr);  //!! how do we handle this?
			return iesFailure;
		}
	}

	m_cSuppressProgress++; // suppress progress messages from MoveFile
	iesRet = CopyOrMoveFile(riPath, *pBackupFolder, ristrFile, *strBackupFile,
									fRemoveOriginal, fRemoveFolder, fTrue, iehErrorMode, 0, ielfElevateDest, /* fCopyACL = */ true,
									fRebootOnRenameFailure, fWillReplace);
	m_cSuppressProgress--;

	// hide the files, so we don't have to look at them when they happen to be on the desk top.
	// The rollback in CopyOrMoveFile manages the attributes for when we put it back, so mucking with it here
	// won't hurt.
	{
		CElevate elevate;
		if((iesRet == iesSuccess) && (pRecErr = pBackupFolder->SetAllFileAttributes(strBackupFile, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)) != 0)
		{                               
			Message(imtError, *pRecErr); // should never happen.
			return iesFailure;
		}
	}

	// is the file part of an assembly?
	// for assemblies we have passed in the componentid
	
	Assert(!pistrAssemblyComponentId || !fRemoveOriginal); // we should never be called to remove the original file in case of assemblies

	
	if (!fRemoveOriginal)
	{
		// It's not automatic to put the old one back during rollback, so we'll have to do it.

		// When we're not removing the original, we use CopyOrMoveFile to just copy the file.
		// Copying creates a rollback to remove the copy, but *not* to copy it back over the
		// original file.

		// This semantic gives us the chance to copy a file, muck with it, and have rollback
		// restore to its original state.
		using namespace IxoFileCopyCore;
		IMsiRecord& riUndoParams = GetSharedRecord(pistrAssemblyComponentId ? IxoAssemblyCopy::Args : IxoFileCopy::Args);
		PMsiRecord pRecErr(0);

		MsiString strFilePath(0);
		if((pRecErr = riPath.GetFullFilePath(ristrFile.GetString(), *&strFilePath)) != 0)
			return FatalError(*pRecErr);
		AssertNonZero(riUndoParams.SetMsiString(SourceName, *strBackupFileFullPath));

		int iAttribs = 0;
		riPath.GetAllFileAttributes(ristrFile.GetString(), iAttribs);
		AssertNonZero(riUndoParams.SetInteger(Attributes, iAttribs));

		unsigned int uiFileSize = 0;
		if ((pRecErr = riPath.FileSize(ristrFile.GetString(),uiFileSize)) != 0)
			AssertNonZero(riUndoParams.SetInteger(FileSize,uiFileSize));
		else
			AssertNonZero(riUndoParams.SetInteger(FileSize,0));

		AssertNonZero(riUndoParams.SetInteger(PerTick,0));
		AssertNonZero(riUndoParams.SetInteger(VerifyMedia,fFalse));

		int ielfElevateFlags = ielfElevateSource; // since rollback op is copying from backup folder,
																	  // need to elevate source
		if(!IsImpersonating())
		{
			// we are currently elevated to backup this file
			// which means we need to elevate during rollback to restore the file
			ielfElevateFlags |= ielfElevateDest;
		}

		AssertNonZero(riUndoParams.SetInteger(ElevateFlags, ielfElevateFlags));

		if(!pistrAssemblyComponentId)
		{
			AssertNonZero(riUndoParams.SetInteger(IxoFileCopy::InstallMode, icmOverwriteAllFiles));
			AssertNonZero(riUndoParams.SetMsiString(DestName, *strFilePath));
			RollbackRecord(ixoFileCopy, riUndoParams);
		}
		else
		{
			AssertNonZero(riUndoParams.SetMsiString(DestName, ristrFile));
			AssertNonZero(riUndoParams.SetMsiString(IxoAssemblyCopy::ComponentId, *pistrAssemblyComponentId));
			if(fManifest)
			{
				AssertNonZero(riUndoParams.SetInteger(IxoAssemblyCopy::IsManifest, fTrue)); // need to know the manifest file during assembly installation
			}
			RollbackRecord(ixoAssemblyCopy, riUndoParams);
		}
	}


	return iesRet;
}

// call this MoveFile if all you have are the names of the files
iesEnum CMsiOpExecute::CopyOrMoveFile(IMsiPath& riSourcePath, IMsiPath& riDestPath,
										  const IMsiString& ristrSourceName,
										  const IMsiString& ristrDestName,
										  Bool fMove,
										  Bool fRemoveFolder,
										  Bool fHandleRollback,
										  iehEnum iehErrorMode,
										  IMsiStream* pSecurityDescriptor,
										  ielfEnum ielfElevateFlags,
										  bool fCopyACL,
										  bool fRebootOnSourceRenameFailure,
										  bool fWillReplace)
{
	using namespace IxoFileCopyCore;

	PMsiRecord pRecErr(0);
	PMsiRecord pCopyOrMoveFileRec = &m_riServices.CreateRecord(Args);
	unsigned int uiFileSize = 0;
	int iFileAttributes = 0;

	// scope elevate
	{
		CElevate elevate(Tobool(ielfElevateFlags & ielfElevateSource));
		pRecErr = riSourcePath.GetAllFileAttributes(ristrSourceName.GetString(),iFileAttributes);
		if(!pRecErr)
			pRecErr = riSourcePath.FileSize(ristrSourceName.GetString(),uiFileSize);
	}
	
	if(pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}

	if(iFileAttributes == FILE_ATTRIBUTE_NORMAL)
		// set to 0, this value is interpreted as something else by CMsiFileCopy::CopyTo
		iFileAttributes = 0;

	if (fCopyACL)
		iFileAttributes |= ictfaCopyACL;
	
	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(SourceName,ristrSourceName));
	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(DestName,ristrDestName));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(FileSize,uiFileSize));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(Attributes,iFileAttributes)); //!! are these the correct attributes?
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(PerTick,0));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(VerifyMedia,fFalse));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(ElevateFlags,ielfElevateFlags));
	
	if (pSecurityDescriptor)
		AssertNonZero(pCopyOrMoveFileRec->SetMsiData(SecurityDescriptor, pSecurityDescriptor));


	return fMove ? MoveFile(riSourcePath, riDestPath, *pCopyOrMoveFileRec, fRemoveFolder, fHandleRollback, fRebootOnSourceRenameFailure, fWillReplace, iehErrorMode) :
				   CopyFile(riSourcePath, riDestPath, *pCopyOrMoveFileRec, fHandleRollback, iehErrorMode, /*fCabinetCopy=*/false);
}

iesEnum CMsiOpExecute::CopyASM(IMsiPath& riSourcePath, const IMsiString& ristrSourceName,
										 IAssemblyCacheItem& riASM, const IMsiString& ristrDestName, bool fManifest, 
										 Bool fHandleRollback, iehEnum iehErrorMode, ielfEnum ielfElevateFlags)
{
	using namespace IxoFileCopyCore;

	PMsiRecord pRecErr(0);
	PMsiRecord pCopyOrMoveFileRec = &m_riServices.CreateRecord(Args);
	unsigned int uiFileSize = 0;
	int iFileAttributes = 0;

	// scope elevate
	{
		CElevate elevate(Tobool(ielfElevateFlags & ielfElevateSource));
		pRecErr = riSourcePath.GetAllFileAttributes(ristrSourceName.GetString(),iFileAttributes);
		if(!pRecErr)
			pRecErr = riSourcePath.FileSize(ristrSourceName.GetString(),uiFileSize);
	}
	
	if(pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}

	if(iFileAttributes == FILE_ATTRIBUTE_NORMAL)
		// set to 0, this value is interpreted as something else by CMsiFileCopy::CopyTo
		iFileAttributes = 0;

	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(SourceName,ristrSourceName));
	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(DestName,ristrDestName));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(FileSize,uiFileSize));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(Attributes,iFileAttributes)); //!! are these the correct attributes?
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(PerTick,0));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(VerifyMedia,fFalse));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(ElevateFlags,ielfElevateFlags));

	return CopyFile(riSourcePath, riASM, fManifest, *pCopyOrMoveFileRec, fHandleRollback, iehErrorMode, /*fCabinetCopy=*/false);
}

iesEnum CMsiOpExecute::MoveFile(IMsiPath& riSourcePath, IMsiPath& riDestPath,
										  IMsiRecord& riParams, Bool fRemoveFolder, Bool fHandleRollback,
										  bool fRebootOnSourceRenameFailure,
										  bool fWillReplaceSource, iehEnum iehErrorMode)
{
	using namespace IxoFileCopyCore;
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;

	ielfEnum ielfElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate : (ielfEnum)riParams.GetInteger(ElevateFlags);

	// backup or delete existing file
	// HandleExistingFile may change the value of riParams[IxoFileCopy::DestFile] if the existing file
	// cannot be moved
	bool fFileExists = false;
	if((iesRet = HandleExistingFile(riDestPath,riParams,fHandleRollback,iehErrorMode,fFileExists)) != iesSuccess)
		return iesRet;
	
	MsiString strSourceFileFullPath, strDestFileFullPath;
	if(((pError = riSourcePath.GetFullFilePath(riParams.GetString(SourceName),*&strSourceFileFullPath)) != 0) ||
		((pError = riDestPath.GetFullFilePath(riParams.GetString(DestName),*&strDestFileFullPath)) != 0))
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	// scope elevate
	{
		CElevate elevate(Tobool(ielfElevateFlags & ielfElevateDest));
		// create folder
		if((iesRet = CreateFolder(riDestPath)) != iesSuccess)
			return iesRet;
	}

	// create undo record
	PMsiRecord pUndoParams = 0;
	if(fHandleRollback && RollbackEnabled())
	{
		// use IxoFileCopy args for rollback op
		pUndoParams = &m_riServices.CreateRecord(IxoFileCopy::Args);
		AssertNonZero(pUndoParams->SetMsiString(IxoFileCopy::SourceName,*strDestFileFullPath));
		AssertNonZero(pUndoParams->SetMsiString(IxoFileCopy::DestName,*strSourceFileFullPath));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::FileSize,riParams.GetInteger(FileSize)));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::Attributes,riParams.GetInteger(Attributes))); //!! use these attributes?
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::PerTick,0));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::InstallMode,icmRemoveSource | icmOverwriteAllFiles));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::VerifyMedia,fFalse));
		
		// determine elevation flags for rollback op
		int ielfRollbackElevateFlags = ielfNoElevate;
		if(!IsImpersonating())
		{
			// we are currently elevated, which means its safe to elevate for src and dest during rollback
			ielfRollbackElevateFlags = ielfElevateSource|ielfElevateDest;
		}
		else
		{
			// if currently elevating for source, rollback needs to elevate for dest
			if(ielfElevateFlags & ielfElevateSource)
				ielfRollbackElevateFlags |= ielfElevateDest;

			// if currently elevating for dest, rollback needs to elevate for source
			if(ielfElevateFlags & ielfElevateDest)
				ielfRollbackElevateFlags |= ielfElevateSource;
		}

		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::ElevateFlags,ielfRollbackElevateFlags));
		// don't need to set version or language - install mode says always overwrite
	}

	// attempt to move file

	// if elevating for source or dest exclusively, need to make sure we aren't letting the user do something
	// they couldn't normally do
	if ((ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateDest)
	{
		// if we want to elevate for the dest only we still have to elevate for the source.
		// if this is the case then we'd better be sure that, *before* we elevate, we have DELETE access
		// to the source file

		iesRet = VerifyAccessibility(riSourcePath, riParams.GetString(SourceName), DELETE, iehErrorMode); //!! doesn't catch case where dir has DELETE access but file doesn't
		if (iesRet != iesSuccess)
			return iesRet;
	}

	if ((ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateSource)
	{
		// if we want to elevate for the source only we still have to elevate for the desination.
		// if this is the case then we'd better be sure that, *before* we elevate, we have GENERIC_WRITE access
		// to the destination file

		iesRet = VerifyAccessibility(riDestPath, riParams.GetString(DestName), GENERIC_WRITE, iehErrorMode);
		if (iesRet != iesSuccess)
			return iesRet;
	}

	BOOL fRes = FALSE;

	bool fDestSupportsACLs = (PMsiVolume(&riDestPath.GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;

	if (!fDestSupportsACLs || riParams.IsNull(SecurityDescriptor)) // if we have security descriptor to apply then we need to do a copy and remove
	{
		// scope elevate
		CElevate elevate(Tobool(ielfElevateFlags & (ielfElevateDest|ielfElevateSource)));

		//!! MoveFile *will* copy the ACLs on same-drive moves; we don't respect the ictfaCopyACL attributes in this case. this is spec issue bug #6546
		FILETIME ftLastWrite;
		DWORD dwResult = GetFileLastWriteTime(strSourceFileFullPath, ftLastWrite);

		fRes = WIN::MoveFile(strSourceFileFullPath,strDestFileFullPath);
		if (fRes && dwResult == NO_ERROR)
		{
			// Not fatal if file time can't be set, so don't throw error
			if ((pError = riDestPath.SetAllFileAttributes(riParams.GetString(DestName), FILE_ATTRIBUTE_NORMAL)) == 0)
				dwResult = MsiSetFileTime(strDestFileFullPath, &ftLastWrite);
		}

	}

	if(fRes)
	{
		if(pUndoParams)
			if (!RollbackRecord(ixoFileCopy, *pUndoParams))
				return iesFailure; //!! is this the correct place?

		// scope elevate
		{
			CElevate elevate(Tobool(ielfElevateFlags & ielfElevateDest));

			// set appropriate file attributes
			if((pError = riDestPath.SetAllFileAttributes(riParams.GetString(DestName),
																		riParams.GetInteger(Attributes))) != 0)
			{
				// If we can't set the file attributes, it's not a fatal error.
				Message(imtInfo, *pError);
			}
		}
		// Dispatch remaining progress for this file
		if(DispatchProgress(riParams.GetInteger(FileSize)) == imsCancel)
			return iesUserExit;

		if(fRemoveFolder)
		{
			CElevate elevate(Tobool(ielfElevateFlags & ielfElevateSource));
			return RemoveFolder(riSourcePath);
		}
		else
			return iesSuccess;
	}
	else
	{
		// move failed
		// copy and remove file
		iesRet = CopyFile(riSourcePath, riDestPath, riParams, fFalse, iehShowNonIgnorableError,
								/*fCabinetCopy=*/false);
		if(iesRet == iesSuccess)
		{
			if(pUndoParams)
				if (!RollbackRecord(ixoFileCopy, *pUndoParams))
					return iesFailure; //!! is this the correct place?
			// remove source file
			return RemoveFile(riSourcePath, *MsiString(riParams.GetMsiString(IxoFileCopy::SourceName)), fFalse, /*fBypassSFC*/ false,
									fRebootOnSourceRenameFailure, fRemoveFolder, iehErrorMode, fWillReplaceSource);
		}
		return iesRet;
	}
}

iesEnum CMsiOpExecute::HandleExistingFile(IMsiPath& riTargetPath, IMsiRecord& riParams,Bool fHandleRollback,
										  iehEnum iehErrorMode, bool& fFileExisted)
{
	// this function may change the value of riParams[IxoFileCopy::DestFile] if the existing file
	// cannot be moved
	using namespace IxoFileCopyCore;

	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;
	MsiString strDestFileName = riParams.GetMsiString(DestName);

	ielfEnum ielfCurrentElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate :
												  (ielfEnum)riParams.GetInteger(ElevateFlags);

	bool fBypassSFC = (ielfCurrentElevateFlags & ielfBypassSFC) ? true : false;
	
	fFileExisted = false;

	// we may be copying over an existing file
	Bool fFileExists = FFileExists(riTargetPath,*strDestFileName);
	if(fFileExists)
	{
		fFileExisted = true;
		
		Bool fInUse = fFalse;
		// note: FileInUse doesn't catch every file in use, such as fonts
		// the worst that can happen from this is that we don't reboot when copying over a font
		if((pRecErr = riTargetPath.FileInUse(strDestFileName,fInUse)) == 0 && fInUse == fTrue)
		{
			// existing file is in use - make sure we prompt for reboot - we may not actually schedule
			// a file for reboot but since the existing file is in use we need to reboot so that
			// the installed file will be used rather than the existing file
			
			DispatchError(imtInfo, Imsg(imsgFileInUseLog),
							  *MsiString(riTargetPath.GetPath()), *strDestFileName);
			m_fRebootReplace = fTrue;
		}

		//!!?? check if source file exists before removing target file???
		if((iesRet = RemoveFile(riTargetPath,*strDestFileName,fHandleRollback, fBypassSFC, true,fTrue,iehErrorMode,true)) != iesSuccess)
			return iesRet;

		// check if file still exists.  If so, we need to install to a different spot
		// and schedule the replacement on reboot
		if(FFileExists(riTargetPath,*strDestFileName))
		{
			// since remove file succeeded, we must have delete access for the existing file
			// which means it is safe to schedule a rename to that spot after reboot
			// we also assume we have ADD_FILE access to this directory, since if we don't, we
			// will fail the file copy when that is attempted
			MsiString strDestFullPath,strTempFileFullPath,strTempFileName;
			if((pRecErr = riTargetPath.GetFullFilePath(strDestFileName,*&strDestFullPath)) != 0)
				return FatalError(*pRecErr);

			if((pRecErr = riTargetPath.TempFileName(TEXT("TBM"),0,fTrue,*&strTempFileName, 0)) != 0)
				return FatalError(*pRecErr);

			if((pRecErr = riTargetPath.GetFullFilePath(strTempFileName,*&strTempFileFullPath)) != 0)
				return FatalError(*pRecErr);
			
			if((pRecErr = CacheFileState(*strDestFullPath,0,strTempFileFullPath, 0, 0, 0)) != 0)
				return FatalError(*pRecErr);
			
			AssertNonZero(riParams.SetMsiString(DestName,*strTempFileName));

			for(;;)
			{
				if(ReplaceFileOnReboot(strTempFileFullPath,strDestFullPath) == fFalse)
				{
					if (iehErrorMode == iehSilentlyIgnoreError)
					{
						// Just log the error and go on
						DispatchError(imtInfo, Imsg(imsgOpScheduleRebootReplace), *strTempFileFullPath, *strDestFullPath);
						return (iesEnum) iesErrorIgnored;
					}

					imtEnum imtButtons = imtEnum(imtError + (iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore));
					switch(DispatchError(imtButtons,Imsg(imsgOpScheduleRebootReplace),
												*strTempFileFullPath,
												*strDestFullPath))
					{
					case imsRetry:
						continue;

					case imsIgnore:
						return (iesEnum) iesErrorIgnored;

					case imsAbort:
					case imsCancel:
					case imsNone:
					default:
						return iesFailure;
					};
				}
				else
					break;
			}
		}
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfRegisterBackupFile(IMsiRecord& /*riParams*/)
{
	// do nothing, only purpose is to show backup file for Rollback script cleanup
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFileUndoRebootReplace(IMsiRecord& riParams)
{
	using namespace IxoFileUndoRebootReplace;
	
	PMsiRecord pRecErr(0);
	MsiString strExistingFile = riParams.GetMsiString(ExistingFile);
	if(!strExistingFile.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfFileUndoRebootReplace"),
						  (int)ExistingFile);
		return iesFailure;
	}
	MsiString strNewFile = riParams.GetMsiString(NewFile);

	Bool fWindows = riParams.GetInteger(Type) == 0 ? fTrue : fFalse;
	if(fWindows) // Win95
	{
		AssertSz(0, TEXT("unicode build attempting to operate on wininit.ini"));
   }
	else // NT
	{
		MsiString strExistingFileEntry = MsiString(*TEXT("??\\")) + strExistingFile;
		MsiString strNewFileEntry;
		if(strNewFile.TextSize())
			strNewFileEntry = MsiString(*TEXT("??\\")) + strNewFile;

		// remove entry from registry
		HKEY hKey;
		//!! eugend: there's an error here waiting to happen if szSessionManager
		// key ever gets redirected/replicated on Win64: if this code is
		// run in a 32-bit process, it will attempt to open the 32-bit copy
		// of the key, whereas the 64-bit process will open the 64-bit one.
		LONG lRes = RegOpenKeyAPI(HKEY_LOCAL_MACHINE, szSessionManagerKey, 0, KEY_READ|KEY_WRITE, &hKey);
		if(lRes != ERROR_SUCCESS)
			return iesSuccess; // not a fatal error

		CTempBuffer<ICHAR, 200> rgBuffer;
		DWORD dwType, dwSize = 200;

		lRes = RegQueryValueEx(hKey,szPendingFileRenameOperationsValue,
									  0,&dwType,(LPBYTE)(ICHAR*)rgBuffer,&dwSize);
		if(lRes == ERROR_MORE_DATA)
		{
			rgBuffer.SetSize(dwSize);
			lRes = RegQueryValueEx(hKey,szPendingFileRenameOperationsValue,
										  0,&dwType,(LPBYTE)(ICHAR*)rgBuffer,&dwSize);
		}
		if(lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			return iesSuccess; // not a fatal error
		}

		ICHAR* pch = rgBuffer; // pointer to move around data
		unsigned int cchTotal = dwSize/sizeof(ICHAR);
		ICHAR* pchEndOfBuffer = (ICHAR*)rgBuffer+cchTotal;
	
		MsiString strFirstEntry, strSecondEntry;
		int cch=0;
		for(;;)
		{
			strFirstEntry = ((const ICHAR&)*pch);
			if(!strFirstEntry.TextSize())
			{
				// we have reached the end of the entries
				Assert((pch - (ICHAR*)rgBuffer) == cchTotal);
				break;
			}
			if(strFirstEntry.Compare(iscEndI, strExistingFileEntry))
			{
				// first in pair matches, check next entry
				cch = IStrLen(pch)+1;
				if((pch - (ICHAR*)rgBuffer + cch) >= (cchTotal - 1))
					break;
				strSecondEntry = (const ICHAR&)*(pch+cch);
				if(((strSecondEntry.TextSize() == 0) && (strNewFileEntry.TextSize() == 0)) ||
					  strSecondEntry.Compare(iscEndI, strNewFileEntry))
				{
					// found it!  now delete these two entries
					// get the size of the two entries combined
					int cchEntries = strFirstEntry.TextSize()+strSecondEntry.TextSize()+2;
					// move up the data past the two entries

					ICHAR* pchEndOfEntries = pch+cchEntries;
					Assert((UINT_PTR) (pchEndOfBuffer-pchEndOfEntries) <= UINT_MAX);    //--merced: we typecast below to uint, it better be in range
					memmove((void*)pch, pchEndOfEntries, (unsigned int)(pchEndOfBuffer-pchEndOfEntries)*sizeof(ICHAR));     //--merced: added (unsigned int)

					// write value back
					RegSetValueEx(hKey,szPendingFileRenameOperationsValue,0,REG_MULTI_SZ,
									  (LPBYTE)(ICHAR*)rgBuffer,(cchTotal-cchEntries)*sizeof(ICHAR));  // nothing we can do if this fails
					break;
				}
			}
			// done checking this pair, go to next pair
			// move pch to next pair - be sure not to advance past buffer
			cch = IStrLen(pch)+1;
			if((pch - (ICHAR*)rgBuffer + cch) >= (cchTotal - 1))
				break;
			pch += cch;
			cch = IStrLen(pch)+1;
			if((pch - (ICHAR*)rgBuffer + cch) >= (cchTotal - 1))
				break;
			pch += cch;
		}
		RegCloseKey(hKey);
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFolderCreate(IMsiRecord& riParams)
{
	using namespace IxoFolderCreate;
	PMsiPath pPath(0);
	PMsiRecord pError(m_riServices.CreatePath(riParams.GetString(IxoFolderCreate::Folder), *&pPath));
	if (pError)  // happens only if invalid systax, retry won't help
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(1);
	AssertNonZero(riActionData.SetMsiString(1,*MsiString(pPath->GetPath())));
	if(Message(imtActionData,riActionData) == imsCancel)
		return iesUserExit;

	Bool fForeign = riParams.GetInteger(Foreign) == 1 ? fTrue : fFalse;

	iesEnum iesRet = iesNoAction;
	if((iesRet = CreateFolder(*pPath, fForeign, fTrue, PMsiStream((IMsiStream*) riParams.GetMsiData(SecurityDescriptor)))) != iesSuccess)
		return iesRet;
	
	// generate undo operation
	IMsiRecord& riUndoParams = GetSharedRecord(IxoFolderRemove::Args);
	riUndoParams.SetMsiString(IxoFolderRemove::Folder, *MsiString(riParams.GetMsiString(IxoFolderCreate::Folder)));
	riUndoParams.SetInteger(IxoFolderRemove::Foreign, fForeign ? 1 : 0);
	if (!RollbackRecord(ixoFolderRemove,riUndoParams))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFolderRemove(IMsiRecord& riParams)
{
	using namespace IxoFolderRemove;
	PMsiPath pPath(0);
	PMsiRecord pError(m_riServices.CreatePath(riParams.GetString(IxoFolderRemove::Folder), *&pPath));
	if (pError)
	{
		// happens only if invalid systax, retry won't help
		Message(imtWarning, *pError);
		return iesFailure; //!!
	}
		
	IMsiRecord& riActionData = GetSharedRecord(1);
	AssertNonZero(riActionData.SetMsiString(1,*MsiString(pPath->GetPath())));
	if(Message(imtActionData,riActionData) == imsCancel)
		return iesUserExit;

	Bool fForeign = (riParams.GetInteger(Foreign) == 1) ? fTrue : fFalse;

	// determine what folders actually exist before we remove
	PMsiPath pPath2(0);
	pError = m_riServices.CreatePath(riParams.GetString(IxoFolderRemove::Folder), *&pPath2);
	if (pError)
	{
		// happens only if invalid systax, retry won't help
		Message(imtWarning, *pError);
		return iesFailure; //!!
	}

	Bool fExists = fFalse;
	MsiString strSubPath;
	for(;;)
	{
		strSubPath = pPath2->GetEndSubPath();
		if(strSubPath.TextSize() == 0)
		{
			// no sub path, just volume - no rollback necessary
			break;
		}
		
		if((pError = pPath2->Exists(fExists)) != 0)
		{
			Message(imtWarning, *pError);
			return iesFailure; //!!
		}

		if(fExists == fTrue || fForeign)
			break;  // folder exists, this is the folder we put in the rollback script to re-create
		else
			AssertRecord(pPath2->ChopPiece());
	}

	// even if there is no folder to remove, we may still need to unregister the folders
	// so call RemoveFolder even if fExists = fFalse
	iesEnum iesRet = iesNoAction;

	PMsiStream piSD(0);

	bool fFolderSupportsACLs = (PMsiVolume(&pPath2->GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;
	
	if (fFolderSupportsACLs)
	{
		if ((pError = pPath2->GetSelfRelativeSD(*&piSD)) != 0)
		{
			return FatalError(*pError);
		}
	}

	if((iesRet = RemoveFolder(*pPath, fForeign, fTrue)) != iesSuccess)
		return iesRet;
	
	// generate undo operation
	if(fExists)
	{
		IMsiRecord& riUndoParams = GetSharedRecord(IxoFolderCreate::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoFolderCreate::Folder, *MsiString(pPath2->GetPath())));
		AssertNonZero(riUndoParams.SetInteger(Foreign, fForeign ? 1 : 0));
		AssertNonZero(riUndoParams.SetMsiData(IxoFolderCreate::SecurityDescriptor,piSD));
		if (!RollbackRecord(ixoFolderCreate,riUndoParams))
			return iesFailure;
	}

	return iesSuccess;
}

Bool CMsiOpExecute::FFileExists(IMsiPath& riPath, const IMsiString& ristrFile)
{
	PMsiRecord pError(0);
	Bool fExists = fFalse;
	if(((pError = riPath.FileExists(ristrFile.GetString(),fExists)) != 0) || fExists == fFalse)
		return fFalse;
	else
		return fTrue;
}


iesEnum CMsiOpExecute::GetSecurityDescriptor(const ICHAR* szFile, IMsiStream*& rpiSecurityDescriptor)
{
	bool fNetPath = FIsNetworkVolume(szFile);
	rpiSecurityDescriptor = 0;

	if (!g_fWin9X && !fNetPath)
	{
		CElevate elevate; // so we can always read the security info

		CTempBuffer<char, 1> rgchFileSD(3072);
		DWORD cbFileSD = 3072;

		// reads a self-relative security descriptor
		if (!ADVAPI32::GetFileSecurity(szFile,OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION,
				(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD))
		{
			DWORD dwLastError = WIN::GetLastError();
			BOOL fRet = FALSE;
			if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
			{
				rgchFileSD.SetSize(cbFileSD);
				fRet = ADVAPI32::GetFileSecurity(szFile,OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION,
					(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD);
				dwLastError = WIN::GetLastError();
			}
			if (!fRet)
			{
				PMsiRecord pRecord = PostError(Imsg(imsgGetFileSecurity), dwLastError, szFile);
				return FatalError(*pRecord);
			}
		}

		Assert(IsValidSecurityDescriptor((PSECURITY_DESCRIPTOR) rgchFileSD));
		DWORD dwLength = GetSecurityDescriptorLength((PSECURITY_DESCRIPTOR) rgchFileSD);
	
		char* pbstrmSD = m_riServices.AllocateMemoryStream(dwLength, rpiSecurityDescriptor);
		Assert(pbstrmSD);
		memcpy(pbstrmSD, rgchFileSD, dwLength);
	}
	return iesSuccess;
}

// patching operations

/*---------------------------------------------------------------------------
ixoPatchApply: applies a patch to file in m_pTargetPath with m_pFilePatch
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfPatchApply(IMsiRecord& riParams)
{
	using namespace IxoPatchApply;
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	if(!m_state.pFilePatch)
	{
		// create FilePatch object
		if((pError = m_riServices.CreatePatcher(*&(m_state.pFilePatch))) != 0)
		{
			Message(imtError,*pError);
			return iesFailure;
		}
	}
	Assert(m_state.pFilePatch);

	// the following steps may be taken by this operation:
	//
	// 1) file is already up-to-date, or newer than what would be patched to
	//     determined: FileState contains no icfsPatchFile bit
	//     action:     do nothing
	//
	// 2) file was NOT copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this is NOT the last patch for this file
	//     determined: FileState contains no temporary file path, cRemainingPatches > 1
	//     action:     patch against target file, mark output file as new temporary file
	//
	// 3) file was NOT copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this IS the last patch for this file
	//     determined: FileState contains no temporary file path, cRemainingPatches == 1
	//     action:     patch against target file, copy over target file
	//
	// 4) file was copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this is NOT the last patch for this file
	//     determined: FileState contains temporary file path
	//     action:     patch against temp file, delete old temp file, mark output file as new temporary file
	//
	// 5) file was copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this IS the last patch for this file
	//     determined: FileState contains temporary file path
	//     action:     patch against temp file, delete old temp file, copy over target file

	
	// file to apply patch against
	PMsiPath pPatchTargetPath(0);
	MsiString strPatchTargetFileName;

	// file to overwrite with resultant file after patch
	PMsiPath pCopyTargetPath(0);
	MsiString strCopyTargetFileName = riParams.GetMsiString(TargetName);

	if(PathType(strCopyTargetFileName) == iptFull)
	{
		MsiString strTemp;
		if((pError = m_riServices.CreateFilePath(strCopyTargetFileName,*&pCopyTargetPath,*&strTemp)) != 0)
			return FatalError(*pError);
		strCopyTargetFileName = strTemp;
	}
	else
	{
		if(!m_state.pTargetPath)
		{  // must not have called ixoSetTargetFolder
			DispatchError(imtError, Imsg(idbgOpOutOfSequence),
							  *MsiString(*TEXT("ixoPatchApply")));
			return iesFailure;
		}

		pCopyTargetPath = m_state.pTargetPath;
	}

	// by default, the file to apply patch against and the file to overwrite are the same
	// but the file to apply patch against may be changed below
	pPatchTargetPath = pCopyTargetPath;
	strPatchTargetFileName = strCopyTargetFileName;
	
	// get any cached state for the target file
	MsiString strCopyTargetFilePath;
	if((pError = pCopyTargetPath->GetFullFilePath(strCopyTargetFileName,*&strCopyTargetFilePath)) != 0)
		return FatalError(*pError);
	
	MsiString strPatchTargetFilePath = strCopyTargetFilePath;

	icfsEnum icfsFileState = (icfsEnum)0;
	MsiString strTempLocation;
	int cRemainingPatches = 0;
	int cRemainingPatchesToSkip = 0;
	Bool fRes = GetFileState(*strCopyTargetFilePath, &icfsFileState, &strTempLocation, &cRemainingPatches, &cRemainingPatchesToSkip);

	if(!fRes || !(icfsFileState & icfsPatchFile))
	{
		// don't patch file
		DEBUGMSG1(TEXT("Skipping all patches for file '%s'.  File does not need to be patched."),
					 (const ICHAR*)strCopyTargetFilePath);
		return iesSuccess;
	}

	Assert(cRemainingPatches > 0);

	if(cRemainingPatchesToSkip > 0)
	{
		// skip this patch, but reset cached file state first
		cRemainingPatches--;
		cRemainingPatchesToSkip--;

		DEBUGMSG3(TEXT("Skipping this patch for file '%s'.  Number of remaining patches to skip for this file: '%d'.  Number of total remaining patches: '%d'."),
					 (const ICHAR*)strCopyTargetFilePath, (const ICHAR*)(INT_PTR)cRemainingPatchesToSkip, (const ICHAR*)(INT_PTR)cRemainingPatches);

		if((pError = CacheFileState(*strCopyTargetFilePath, 0, 0, 0, &cRemainingPatches, &cRemainingPatchesToSkip)) != 0)
			return FatalError(*pError);

		return iesSuccess;
	}
	
	if(strTempLocation.TextSize())
	{
		// file was actually copied to temp location.  this is the copy we want to apply the patch against
		DEBUGMSG2(TEXT("Patch for file '%s' is redirected to patch '%s' instead."),
					 (const ICHAR*)strCopyTargetFilePath,(const ICHAR*)strTempLocation);
		if((pError = m_riServices.CreateFilePath(strTempLocation,*&pPatchTargetPath,*&strPatchTargetFileName)) != 0)
			return FatalError(*pError);
	
		strPatchTargetFilePath = strTempLocation;
	}

	unsigned int cbFileSize = riParams.GetInteger(TargetSize);
	bool fVitalFile = (riParams.GetInteger(FileAttributes) & msidbFileAttributesVital) != 0;
	bool fVitalPatch = (riParams.GetInteger(PatchAttributes) & msidbPatchAttributesNonVital) == 0;

	// dispatch ActionData message
	IMsiRecord& riActionData = GetSharedRecord(3);
	AssertNonZero(riActionData.SetMsiString(1, *strCopyTargetFileName));
	AssertNonZero(riActionData.SetMsiString(2, *MsiString(pCopyTargetPath->GetPath())));
	AssertNonZero(riActionData.SetInteger(3, cbFileSize));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	PMsiPath pTempFolder(0);
	if((iesRet = GetBackupFolder(pPatchTargetPath, *&pTempFolder)) != iesSuccess)
		return iesRet;

	MsiString strOutputFileName;
	MsiString strOutputFileFullPath;
	if((iesRet = ApplyPatchCore(*pPatchTargetPath, *pTempFolder, *strPatchTargetFileName,
										 riParams, *&strOutputFileName, *&strOutputFileFullPath)) != iesSuccess)
	{
		return iesRet;
	}

	MsiString strNewTempLocation;
	if(cRemainingPatches > 1)
	{
		// there is at least one more patch to be done on this file
		// therefor we will reset the temporary name for this file to be the patch output file
		// but won't overwrite the original file yet
		strNewTempLocation = strOutputFileFullPath;
	}
	else
	{
		// this is the last patch - time to finally overwrite the original file
		
		// we always need to handle rollback.  we wouldn't if a previous filecopy operation wrote to the same
		// target that we are copying over now, but that should never happen since when patching will happen
		// filecopy should be writing to an intermediate file
		Assert(strTempLocation.TextSize() || (icfsFileState & icfsFileNotInstalled));

		// get acl for file after its moved
		// if existing file, use existing acl.
		// otherwise create a temp file and grab acl from it (yes, its ugly)
		PMsiStream pSecurityDescriptor(0);
		if(!g_fWin9X)
		{
			MsiString strFileForACL;
			bool fTempFileForACL = false;
			if(FFileExists(*pCopyTargetPath, *strCopyTargetFileName))
			{
				strFileForACL = strCopyTargetFilePath;
			}
			else
			{
				if((iesRet = CreateFolder(*pCopyTargetPath)) != iesSuccess)
					return iesRet;

				if((pError = pCopyTargetPath->TempFileName(TEXT("PT"),0,fFalse,*&strFileForACL, 0 /* use default ACL for folder*/)) != 0)
					return FatalError(*pError);

				fTempFileForACL = true;
			}

			CSecurityDescription security(strFileForACL);

			if(fTempFileForACL)
				AssertNonZero(WIN::DeleteFile(strFileForACL));

			if (!security.isValid())
			{
				return FatalError(*PMsiRecord(PostError(Imsg(imsgGetFileSecurity), WIN::GetLastError(), strFileForACL)));
			}

			security.SecurityDescriptorStream(m_riServices, *&pSecurityDescriptor);
		}

		// move output file over target file - handles file in use case
		iesRet = CopyOrMoveFile(*pTempFolder, *pCopyTargetPath, *strOutputFileName, *strCopyTargetFileName, fTrue, fTrue,
			fTrue, fVitalFile ? iehShowNonIgnorableError : iehShowIgnorableError, pSecurityDescriptor, ielfElevateSource);

		if ( iesRet == iesSuccess && 
  			riParams.GetInteger(CheckCRC) != iMsiNullInteger && 
  			riParams.GetInteger(CheckCRC) )
		{
			imsEnum imsClickedButton;
			if ( !IsChecksumOK(*pCopyTargetPath, *strCopyTargetFileName,
 									Imsg(imsgOpBadCRCAfterPatch), &imsClickedButton,
 									/* fErrorDialog = */ true, fVitalFile, /* fRetryButton = */ false) )
			{
				switch (imsClickedButton)
				{
					case imsIgnore:
						iesRet = (iesEnum)iesErrorIgnored;
						break;
					case imsCancel:
						iesRet = iesUserExit;
						break;
					default:
						Assert(imsClickedButton == imsNone || imsClickedButton == imsOk);
						iesRet = fVitalFile ? iesFailure : (iesEnum)iesErrorIgnored;
						break;
				};
			}
		}
	}

	// if we patched a temp file, remove that file
	if(strTempLocation.TextSize())
	{
		if((pError = pPatchTargetPath->RemoveFile(strPatchTargetFileName)) != 0) // non-critical error
		{
			Message(imtInfo,*pError);
		}
	}

	// reset cached file state
	// one fewer remaining patch now, and we may either have a new temporary location, or no temporary location
	cRemainingPatches--;
	Assert(cRemainingPatchesToSkip == 0);
	if((pError = CacheFileState(*strCopyTargetFilePath, 0, strNewTempLocation, 0, &cRemainingPatches, 0)) != 0)
		return FatalError(*pError);

	return iesRet;
}

iesEnum CMsiOpExecute::TestPatchHeaders(IMsiPath& riPath, const IMsiString& ristrFile, IMsiRecord& riParams,
													 icpEnum& icpResult, int& iPatch)
{
	// assumes the target file exists - don't call if it doesn't
	using namespace IxoFileCopy;
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	MsiString strTargetFilePath;
	if((pError = riPath.GetFullFilePath(ristrFile.GetString(), *&strTargetFilePath)) != 0)
		return FatalError(*pError);
	
	if(!m_state.pFilePatch)
	{
		// create FilePatch object
		if((pError = m_riServices.CreatePatcher(*&(m_state.pFilePatch))) != 0)
		{
			Message(imtError,*pError);
			return iesFailure;
		}
	}
	Assert(m_state.pFilePatch);

	int cHeaders = riParams.IsNull(TotalPatches) ? 0 : riParams.GetInteger(TotalPatches);

	if(cHeaders == 0)
		return iesSuccess;

	int iHeadersStart = riParams.IsNull(PatchHeadersStart) ? 0 : riParams.GetInteger(PatchHeadersStart);
	int iLastHeader = iHeadersStart + cHeaders - 1;
	
	icpResult = icpCannotPatch;
	iPatch = 1;
	for(int i = iHeadersStart; i <= iLastHeader; i++, iPatch++)
	{
		//!! should be able to pass memory pointer to CanPatchFile rather than extracting file from script
		MsiString strTempName;
		if((pError = riPath.TempFileName(0, 0,fTrue, *&strTempName, &CSecurityDescription(strTargetFilePath))) != 0)
		{
			// telling the user about the temporary file being unwritable isn't useful,
			// the real problem is that the original file is unwritable due to its security
			// settings.
			if (imsgErrorWritingToFile == (pError->GetInteger(1)))
			{
				pError->SetMsiString(2, *strTargetFilePath);
			}
		
			return FatalError(*pError);
		}
		
		if((iesRet = CreateFileFromData(riPath,*strTempName,PMsiData(riParams.GetMsiData(i)), 0)) != iesSuccess)
			return iesRet;
	
		if((pError = m_state.pFilePatch->CanPatchFile(riPath,ristrFile.GetString(),riPath,strTempName,icpResult)) != 0)
			return FatalError(*pError);

		RemoveFile(riPath,*strTempName,fFalse,/*fBypassSFC*/ false,false);
		
		if(icpResult == icpCanPatch)
		{
			// can patch file with this patch, assume remaining patches will work also
			break;
		}
	}
	
	// icpResult will either be:
	//    icpCanPatch: file can be patched with patch iPatch, assume that remaining patches will work as well
	//    icpCannotPatch: file could not be patched by any patches
	//    icpUpToDate: file already up to date by all patches
	
	return iesSuccess;
}

bool CMsiOpExecute::PatchHasClients(const IMsiString& ristrPatchCode, const IMsiString& ristrUpgradingProductCode)
{
	Assert(ristrPatchCode.TextSize());
	
	// check if any product currently has this patch registered.  If not, unregister global patch info
	
	// product defined by UpgradingProductCode may not be installed yet but may still
	// require the global patch registration.  If it is not yet installed, skip patch unregistration
	INSTALLSTATE is = INSTALLSTATE_UNKNOWN;
	if(ristrUpgradingProductCode.TextSize() &&
		((is = MsiQueryProductState(ristrUpgradingProductCode.GetString())) != INSTALLSTATE_DEFAULT) &&
		(is != INSTALLSTATE_ADVERTISED))
	{
		return true;
	}
	else
	{
		PMsiRecord pError(0);
		ICHAR rgchBuffer[MAX_PATH];
		MsiString strPatchCodeSQUID =  GetPackedGUID(ristrPatchCode.GetString());
		PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hKey, ibtCommon);        //--merced: changed (int) to (INT_PTR)
		PMsiRegKey pProductsKey = &pRootKey->CreateChild(_szGPTProductsKey);

		rgchBuffer[0] = 0;
		int iIndex = 0;

		ICHAR rgchProductKey[cchProductCode + 1];
		while(MsiEnumProducts(iIndex,rgchProductKey) == ERROR_SUCCESS)
		{
			iIndex++;
			if(MsiString(GetProductKey()).Compare(iscExact,rgchProductKey))
				continue; // skip check if this product
			
			AssertNonZero(PackGUID(rgchProductKey, rgchBuffer));
			StringCbCat(rgchBuffer, sizeof(rgchBuffer), TEXT("\\") szPatchesSubKey);
			PMsiRegKey pPatchesKey = &pProductsKey->CreateChild(rgchBuffer);
			Bool fExists;
			if(((pError = pPatchesKey->ValueExists(strPatchCodeSQUID, fExists)) == 0) && fExists == fTrue)
			{
				return true;
			}
		}
	}
	return false;
}

iesEnum CMsiOpExecute::ProcessPatchRegistration(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoPatchRegister;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	ICHAR rgchBuffer[MAX_PATH];

	MsiString strPatchCode = riParams.GetMsiString(PatchId);
	if(!strPatchCode.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam),fRemove ? TEXT("ixfPatchUnregister") : TEXT("ixoPatchRegister"), PatchId);
		return iesFailure;
	}
	
	const ICHAR* szSourceList = 0;
	const ICHAR* szTransformList = 0;
	if(fRemove == fFalse)
	{
		szTransformList = riParams.GetString(TransformList);
		if(!szTransformList || !*szTransformList)
		{
			DispatchError(imtError,Imsg(idbgOpInvalidParam),fRemove ? TEXT("ixfPatchUnregister") : TEXT("ixoPatchRegister"), TransformList);
			return iesFailure;
		}
	}
	
	// per-product patch registration

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID = GetPackedGUID(MsiString(GetProductKey()));
	MsiString strPatchCodeSQUID =  GetPackedGUID(strPatchCode);
	const ICHAR* rgszPerUserProductPatchRegData[] =
	{
		TEXT("%s\\%s\\%s"), _szGPTProductsKey, strProductKeySQUID, szPatchesSubKey,
		szPatchesValueName,  strPatchCodeSQUID,  g_szTypeMultiSzStringSuffix,
		strPatchCodeSQUID,   szTransformList,    g_szTypeString,
		0,
		0,
	};

	{
		CElevate elevate;
		if((iesRet = ProcessRegInfo(rgszPerUserProductPatchRegData, m_hKey, fRemove,
											 pSecurityDescriptor, 0, ibtCommon)) != iesSuccess)
			return iesRet;
	}

	if(fRemove &&
		false == PatchHasClients(*strPatchCode,
										*MsiString(riParams.GetMsiString(IxoPatchUnregister::UpgradingProductCode))))
	{
		// remove per-machine patch registration (this information is written by ixoPatchCache)
		// delete patch package if it exists

		MsiString strLocalPatchKey;
		if((pError = GetInstalledPatchesKey(strPatchCode, *&strLocalPatchKey)) != 0)
			return FatalError(*pError);
		
		PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);
		PMsiRegKey pPatchKey = &pHKLM->CreateChild(strLocalPatchKey);
		
		MsiString strPackagePath;
		pError = pPatchKey->GetValue(szLocalPackageValueName,*&strPackagePath);
		if(pError == 0) // ignore failure
		{
			PMsiPath pPackagePath(0);
			MsiString strPackageName;
		
			// schedule file for deletion once we let go of install packages/transforms
			if(iesSuccess != DeleteFileDuringCleanup(strPackagePath, false))
			{
				DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strPackagePath);
			}
				
			// remove per-machine patch information
			// ProcessRegInfo handles rollback
			const ICHAR* rgszPerMachinePatchRegData[] =
			{
				TEXT("%s"), strLocalPatchKey, 0, 0,
				szLocalPackageValueName, strPackagePath,  g_szTypeString,
				0,
				0,
			};

			{
				CElevate elevate;
				if((iesRet = ProcessRegInfo(rgszPerMachinePatchRegData, m_hUserDataKey, fRemove,
													 pSecurityDescriptor, 0, ibtCommon)) != iesSuccess)
					return iesRet;
			}
		}
	}
	return iesRet;
}

iesEnum CMsiOpExecute::ixfPatchRegister(IMsiRecord& riParams)
{
	return ProcessPatchRegistration(riParams,fFalse);
}

iesEnum CMsiOpExecute::ixfPatchUnregister(IMsiRecord& riParams)
{
	return ProcessPatchRegistration(riParams,fTrue);
}

iesEnum CMsiOpExecute::ixfPatchCache(IMsiRecord& riParams)
{
	using namespace IxoPatchCache;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	MsiString strPatchCode = riParams.GetMsiString(PatchId);
	MsiString strPatchCodeSQUID = GetPackedGUID(strPatchCode);
	if(!strPatchCodeSQUID.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfPatchCache"), PatchId);
		return iesFailure;
	}

	MsiString strPatchPath = riParams.GetMsiString(PatchPath);
	if(!strPatchPath.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfPatchCache"), PatchId);
		return iesFailure;
	}

	// Generate a unique name for patch

	PMsiPath pSourcePath(0), pDestPath(0);
	MsiString strSourceName, strDestName, strCachedPackagePath;

	if((pError = m_riServices.CreateFilePath(strPatchPath,*&pSourcePath,*&strSourceName)) != 0)
		return FatalError(*pError);

	CElevate elevate; // elevate for remainder of function

	MsiString strMsiDirectory = GetMsiDirectory();
	Assert(strMsiDirectory.TextSize());

	if (((pError = m_riServices.CreatePath(strMsiDirectory, *&pDestPath)) != 0) ||
		((pError = pDestPath->EnsureExists(0)) != 0) ||
		((pError = pDestPath->TempFileName(0, szPatchExtension, fTrue, *&strDestName, 0)) != 0)
		)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	// remove temp file so that CopyOrMoveFile won't attempt to back up old file
	if((pError = pDestPath->RemoveFile(strDestName)) != 0)
		return FatalError(*pError);

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	// move patch package to cached package folder
	if((iesRet = CopyOrMoveFile(*pSourcePath,*pDestPath,*strSourceName,*strDestName,
										 fFalse,fTrue,fTrue,iehShowNonIgnorableError, pSecurityDescriptor)) != iesSuccess)
		return iesRet;

	// register local package path
	if((pError = pDestPath->GetFullFilePath(strDestName,*&strCachedPackagePath)) != 0)
		return FatalError(*pError);

	MsiString strLocalPatchKey;
	if((pError = GetInstalledPatchesKey(strPatchCode, *&strLocalPatchKey)) != 0)
		return FatalError(*pError);

	const ICHAR* rgszPerMachinePatchRegData[] =
	{
		TEXT("%s"), strLocalPatchKey, 0, 0,
		szLocalPackageValueName, strCachedPackagePath, g_szTypeString,
		0,
		0,
	};

	return ProcessRegInfo(rgszPerMachinePatchRegData, m_hUserDataKey, fFalse,
								 pSecurityDescriptor, 0, ibtCommon);
}


Bool CMsiOpExecute::ReplaceFileOnReboot(const ICHAR* pszExisting, const ICHAR* pszNew)
/*----------------------------------------------------------------------------
Local function that replaces or deletes an existing file on reboot.  Most
useful for replacing or deleting a file that is in-use at the time of install.
To delete a file on reboot, pass NULL for pszNew.

Returns:
	fTrue if the function is successful.

Original source: MSJ 1/96

NOTE: it is assumed that the proper access checks have been made on NT
	  before calling this function.  we do not want to schedule a file for
		delete or rename that the user doesn't have access to since that is
		done with system priviledges and we elevate before calling MoveFileEx
----------------------------------------------------------------------------*/
{
	Bool fDelete = (pszNew == 0 || *pszNew == 0) ? fTrue : fFalse;
	// generate the undo operation for this
	using namespace IxoFileUndoRebootReplace;
	PMsiRecord pUndoParams = &m_riServices.CreateRecord(Args);
	
	if(fDelete)
		DispatchError(imtInfo, Imsg(imsgOpDeleteFileOnReboot), *MsiString(pszExisting));
	else
		DispatchError(imtInfo, Imsg(imsgOpMoveFileOnReboot), *MsiString(pszExisting), *MsiString(pszNew));

	// on NT we use the MoveFileEx function.
	if(g_fWin9X == false)
	{
		CElevate elevate; // assume this is safe - access checks made already
		
		if(MoveFileEx(pszExisting, pszNew, MOVEFILE_DELAY_UNTIL_REBOOT))
		{
			AssertNonZero(pUndoParams->SetString(ExistingFile,pszExisting));
			AssertNonZero(pUndoParams->SetString(NewFile,pszNew));
			AssertNonZero(pUndoParams->SetInteger(Type,1));
			if (!RollbackRecord(ixoFileUndoRebootReplace, *pUndoParams))
				return fFalse;

			if(fDelete == fFalse) // don't reboot when removing file
				m_fRebootReplace = fTrue;
			return fTrue;
		}
		else
			return fFalse;
	}

	// on Win9X we write to the wininit.ini file
	
	// get short names of files - wininit.ini processed in DOS, LFN doesn't work
	CTempBuffer<ICHAR,1> rgchNewFile(MAX_PATH);
	CTempBuffer<ICHAR,1> rgchExistingFile(MAX_PATH);
	
	DWORD dwSize = 0;
	int cchFile = 0;
	if(pszNew && *pszNew)
	{
		if(ConvertPathName(pszNew,rgchNewFile, cpToShort) == fFalse)
		{
			// if GetShortPathName fails, use path we already have
			// this is to handle non-existent files - see bug 8721
			// FUTURE: chop off filename and get short path of folder
			rgchNewFile.SetSize(IStrLen(pszNew)+1); // +1 for null terminator
			StringCchCopy(rgchNewFile, rgchNewFile.GetSize(),pszNew);
		}
	}
	else
	{
		rgchNewFile[0] = 0;
	}

	Assert(pszExisting && *pszExisting);
	if(ConvertPathName(pszExisting,rgchExistingFile, cpToShort) == fFalse)
	{
		// if GetShortPathName fails, use path we already have
		// this is to handle non-existent files - see bug 8721
		// FUTURE: chop off filename and get short path of folder
		rgchExistingFile.SetSize(IStrLen(pszExisting)+1); // +1 for null terminator
		StringCchCopy(rgchExistingFile, rgchExistingFile.GetSize(),pszExisting);
	}

	AssertNonZero(pUndoParams->SetString(ExistingFile,rgchExistingFile));
	AssertNonZero(pUndoParams->SetString(NewFile,rgchNewFile));
	AssertNonZero(pUndoParams->SetInteger(Type,0));
	if (!RollbackRecord(ixoFileUndoRebootReplace, *pUndoParams))
		return fFalse;

	Bool fOk = fFalse;
	// If MoveFileEx failed, we are running on Windows 95 and need to add
	// entries to the WININIT.INI file (an ANSI file).
	// Start a new scope for local variables.
	{
		//FUTURE:  Combine this and similar section in ixfFileUndoRebootReplace
		AssertSz(0, TEXT("unicode build attempting to operate on wininit.ini"));
	}

	return(fOk);
}

iesEnum CMsiOpExecute::ixfCleanupTempFiles(IMsiRecord& riParams)
{
	using namespace IxoCleanupTempFiles;

	MsiString strFileList = riParams.GetMsiString(TempFiles);

	while (strFileList.TextSize() != 0)
	{
		MsiString strFile = strFileList.Extract(iseUpto, ';');

		if (strFile.TextSize() == 0)
		{
			//
			// Maybe this is a malformed list and there are multiple consecutive
			// semicolons. So we must remove any such semicolons and continue
			// If strFile.TextSize == 0 because of a memory allocation failure,
			// we might end up leaving some temp files behind.
			//
			if (!strFileList.Remove(iseIncluding, ';'))
				break;

			continue;
		}

		if (iesSuccess != DeleteFileDuringCleanup(strFile, false))
		{
			// not a fatal error, just log it
			DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove),*strFile);
		}


		if (!strFileList.Remove(iseIncluding, ';'))
			break;
	}

	return iesSuccess;
}

iesEnum CMsiOpExecute::DeleteFileDuringCleanup(const ICHAR* szFile, bool fDeleteEmptyFolderToo)
{
	if(!szFile || !*szFile)
	{
		Assert(0);
		return iesFailure;
	}
	
	PMsiRecord pRecErr(0);
	PMsiStream pSecurityDescriptor(0);
	if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	DEBUGMSG1(TEXT("Scheduling file '%s' for deletion during post-install cleanup (not post-reboot)."), szFile);
	
	int iOptions = 0;
	if(fDeleteEmptyFolderToo)
		iOptions |= TEMPPACKAGE_DELETEFOLDER;

	MsiString strOptions = iOptions;

	const ICHAR* rgszRegData[] =
	{
		TEXT("%s"), szMsiTempPackages, 0, 0,
		szFile,     (const ICHAR*)strOptions,     g_szTypeInteger,
		0,
		0,
	};

	CElevate elevate;
	return ProcessRegInfo(rgszRegData, HKEY_LOCAL_MACHINE, fFalse, pSecurityDescriptor, 0, ibtCommon);
}


HANDLE CreateDiskPromptMutex()
/*---------------------------------------------------------------------------------------
Global function that creates a "Prompt for disk" mutex object, allowing active non-Darwin
processes to know when Darwin is prompting for a disk.  This function should be called
just prior to putting up a "please insert disk dialog" prompt.  After the dialog is taken
down, the CloseDiskPromptMutex called must be called.

Returns:
	A handle to the created mutex.  CloseDiskPromptMutex must be called to dispose of
	this handle when disk prompting is over.
---------------------------------------------------------------------------------------*/
{
	HANDLE hMutex;
	if (!g_fWin9X)
	{
		SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
		SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;

		CSIDAccess SIDAccess[3];

		// set up the SIDs for Local System, Everyone, and Administrators
		if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[0].pSID))) ||
			(!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[1].pSID))) ||
			(!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[2].pSID))))
		{
#ifdef DEBUG
			ICHAR rgchBuffer[MAX_PATH];
			StringCbPrintf(rgchBuffer, sizeof(rgchBuffer), TEXT("GetLastError returned: %d"),
						WIN::GetLastError());
			AssertSz(0, rgchBuffer);
#endif
			return INVALID_HANDLE_VALUE;
		}
		SIDAccess[0].dwAccessMask = GENERIC_ALL;  /* Local System   */ 
		SIDAccess[1].dwAccessMask = GENERIC_ALL;  /* Everyone       */
		SIDAccess[2].dwAccessMask = GENERIC_ALL;  /* Administrators */

		CSecurityDescription secdesc(NULL, (PSID) NULL, SIDAccess, 3);
		Assert(secdesc.isValid());

		hMutex = CreateMutex(secdesc.SecurityAttributes(),
									FALSE, TEXT("__MsiPromptForCD"));
	}
	else
	{
		hMutex = CreateMutex(NULL, FALSE, TEXT("__MsiPromptForCD"));
	}
	MsiRegisterSysHandle(hMutex);
	return hMutex;
}

void CloseDiskPromptMutex(HANDLE hMutex)
/*--------------------------------------------------------------------------------------
Closes the handle created by a call to CreateDiskPromptMutex.  If called with a NULL
handle, CloseDiskPromptMutex does nothing.
---------------------------------------------------------------------------------------*/
{
	if (hMutex)
		MsiCloseSysHandle(hMutex);
}


// verifies that the source is valid by checking the package code of the package at the location 
// (for physical disk 1) or that the volume label is correct (for all other disks). Returns
// true if the source is valid, false otherwise. Patches are never disk 1, so no danger there
bool CMsiOpExecute::ValidateSourceMediaLabelOrPackage(IMsiVolume* pSourceVolume, const unsigned int uiDisk, const ICHAR* szLabel)
{
	AssertSz(pSourceVolume, "No Source Volume in ValidateSourceMediaLabelOrPackage");

	if (!pSourceVolume)
		return false;

	if (uiDisk == 1)
	{
		PMsiPath pPath(0);
		PMsiRecord pError(0);

		// create path to volume
		if ((pError = m_riServices.CreatePath(MsiString(pSourceVolume->GetPath()), *&pPath)) != 0)
		{
			return false;
		}
		
		// ensure path was created successfully
		if (!pPath)
		{
			return false;
		}

		// append relative path to package
		MsiString strMediaRelativePath;
		strMediaRelativePath = MsiString(GetPackageMediaPath());
		if ((pError = pPath->AppendPiece(*strMediaRelativePath)) != 0)
		{
			return false;
		}

		// append package name to path
		MsiString strPackageName;
		strPackageName = MsiString(GetPackageName());

		MsiString strPackageFullPath;
		AssertRecord(pPath->GetFullFilePath(strPackageName, *&strPackageFullPath));

		
		PMsiStorage pStorage(0);

		// SAFER check does not occur when validating source
		UINT uiStat = ERROR_SUCCESS;
		if (ERROR_SUCCESS != (uiStat = OpenAndValidateMsiStorage(strPackageFullPath, stDatabase, m_riServices, *&pStorage, /*fCallSAFER = */false, /*szFriendlyName = */NULL, /* phSaferLevel = */ NULL)))
		{
			// unable to open package
			DEBUGMSG1(TEXT("Source is incorrect. Unable to open or validate MSI package %s."), strPackageFullPath);
			return false;
		}

		if (!pStorage)
		{
			return false;
		}
	
		MsiString strExistingPackageCode = GetPackageCode();	
	
		// grab the package code from the MSI and compare it to the expected package code. 
		ICHAR szPackageCode[39];
		uiStat = GetPackageCodeAndLanguageFromStorage(*pStorage, szPackageCode);
		if (0 != IStrCompI(szPackageCode, strExistingPackageCode))
		{
			DEBUGMSG1(TEXT("Source is incorrect. Package code of %s is incorrect."), strPackageFullPath);
			return false;
		}
		return true;
	}
	else
	{
		// for all non-disk1 media, the volume label is sufficient for verification
		MsiString strMediaLabel(szLabel);
		MsiString strCurrLabel(pSourceVolume->VolumeLabel());
		if (strMediaLabel.Compare(iscExactI,strCurrLabel) == fFalse)
		{
			DEBUGMSG2(TEXT("Source is incorrect. Volume label should be %s but is %s."), strMediaLabel, strCurrLabel);
			return false;
		}
		return true;
	}
	return false;
}


bool CMsiOpExecute::VerifySourceMedia(IMsiPath& riSourcePath, const ICHAR* szLabel,
									const ICHAR* szPrompt, const unsigned int uiDisk, IMsiVolume*& rpiNewVol)
/*--------------------------------------------------------------------------------------
Internal function that attempts to locate a removable drive having the volume label
matching the szLabel parameter.  The volume associated with riSourcePath is first
checked - if this volume doesn't match (or no disk is in that drive), VerifySourceMedia
next inspects all volumes that are of the same type as riSourcePath's volume.  If no
matches are found, a message is sent back to the engine to prompt the user to insert
the proper disk; the string passed in the szPrompt parameter is displayed as the text
for the prompt dialog.

After the engine message call returns, VerifySourceMedia searches again to see if the
required disk has been mounted.  If not, the Message call is repeated until either
the proper disk is found, or the user cancels.

If a matching volume is found, a volume object representing the located volume (which
may be different than that associated with riSourcePath) is returned in the rpiNewVol
parameter.  Note: rpiNewVol will be returned as NULL if the required volume was found
immediately as matching riSourcPath's volume.

Returns:
	fTrue if the required volume is found, or if riSourcePath's volume is not
	removable.  fFalse if the user cancels without the required volume having been
	located.
---------------------------------------------------------------------------------------*/
{
	// initialize output volume to NULL
	rpiNewVol = 0;
	
	PMsiVolume pSourceVolume(&riSourcePath.GetVolume());
	idtEnum idtDriveType = pSourceVolume->DriveType();

	// Prompt only if the source is a removable disk.
	if (idtDriveType == idtFloppy || idtDriveType == idtCDROM)
	{
		// If disk is in the drive, and the label matches, we're OK
		if (pSourceVolume->DiskNotInDrive() == fFalse)
		{
			if (ValidateSourceMediaLabelOrPackage(pSourceVolume, uiDisk, szLabel))
				return true;
		}

		// Ok, the drive referenced by riSourcePath does not have a matching label 
		// (or package). Let's look for a mounted drive of the same type that does match.
		HANDLE hMutex = NULL;
		PMsiRecord pRec(&m_riServices.CreateRecord(1));
	
		// keep searching and prompting as long as the user keeps pressing "OK"
		do
		{
			// obtain an enumerator for all volumes of the relevant type (CDROM or Floppy)
			IEnumMsiVolume& riEnum = m_riServices.EnumDriveType(idtDriveType);
	
			// loop through all volume objects of that type
			PMsiVolume piVolume(0);
			for (int iMax = 0; riEnum.Next(1, &piVolume, 0) == S_OK; )
			{
				if (!piVolume)
					continue;
	
				#define DISK_RETRIES 10 // Give the poor CDROM a chance to spin up.
				int cRetries = 0;
				bool fVolumeValid = false;
				for(cRetries = 0; cRetries < DISK_RETRIES; cRetries++)
				{
					if (!piVolume->DiskNotInDrive())
					{
						fVolumeValid = true;
						break;
					}
					Sleep(1000);
				}
	
				if (fVolumeValid)
				{
					if (ValidateSourceMediaLabelOrPackage(piVolume, uiDisk, szLabel))
					{
						CloseDiskPromptMutex(hMutex);
						piVolume->AddRef();
						rpiNewVol = piVolume;
						return true;
					}
				}
			}

			riEnum.Release();
	
			// no removable media in the system matched the required disk. Dispatch a message
			// to prompt the user
			if (pRec)
				pRec->SetString(0, szPrompt);
			if (hMutex == NULL)
				hMutex = CreateDiskPromptMutex();
		}
		while (pRec && (DispatchMessage((imtEnum) (imtUser + imtOkCancel + imtDefault1), *pRec, fTrue) == imsOk));
	
		// user hit cancel to get here.
		CloseDiskPromptMutex(hMutex);
		return fFalse;
	}
	else // Non-removable drive
		return fTrue;
}


/*---------------------------------------------------------------------------
ixoSummaryInfoUpdate: Update summary information for database
---------------------------------------------------------------------------*/

iesEnum CMsiOpExecute::ixfSummaryInfoUpdate(IMsiRecord& riParams)
{
	using namespace IxoSummaryInfoUpdate;
	PMsiRecord pError(0);

	PMsiPath pDatabasePath(0);
	MsiString strDatabaseName;
	if((pError = m_riServices.CreateFilePath(riParams.GetString(Database),*&pDatabasePath,*&strDatabaseName)) != 0)
		return FatalError(*pError);

	int iOldAttribs = -1;
	if((pError = pDatabasePath->EnsureOverwrite(strDatabaseName, &iOldAttribs)) != 0)
		return FatalError(*pError);
	
	PMsiStorage pStorage(0);
	pError = m_riServices.CreateStorage(riParams.GetString(Database), ismDirect, *&pStorage);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	PMsiSummaryInfo pSummary(0);
	pError = pStorage->CreateSummaryInfo(Args, *&pSummary);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	if (!riParams.IsNull(LastUpdate))
		pSummary->SetTimeProperty(PID_LASTSAVE_DTM, MsiDate(riParams.GetInteger(LastUpdate)));
	if (!riParams.IsNull(LastAuthor))
		pSummary->SetStringProperty(PID_LASTAUTHOR, *MsiString(riParams.GetMsiString(LastAuthor)));
	if (!riParams.IsNull(InstallDate))
		pSummary->SetTimeProperty(PID_LASTPRINTED, MsiDate(riParams.GetInteger(InstallDate)));
	if (!riParams.IsNull(SourceType))
		pSummary->SetIntegerProperty(PID_MSISOURCE, riParams.GetInteger(SourceType));
	if (!riParams.IsNull(Revision))
		pSummary->SetStringProperty(PID_REVNUMBER, *MsiString(riParams.GetMsiString(Revision)));
	if (!riParams.IsNull(Subject))
		pSummary->SetStringProperty(PID_SUBJECT, *MsiString(riParams.GetMsiString(Subject)));
	if (!riParams.IsNull(Comments))
		pSummary->SetStringProperty(PID_COMMENTS, *MsiString(riParams.GetMsiString(Comments)));

	if (!pSummary->WritePropertyStream())
	{
		pError = PostError(Imsg(imsgErrorWritingToFile),riParams.GetString(Database));
		return FatalError(*pError);
	}

	// NOTE: if a failure happened after removing the read-only attribute but before this point, rollback will
	// restore the proper attributes when restoring the file
	// this op doesn't generate the rollback op, but a previous op (ixoDatabaseCopy or ixoDatabasePatch) will
	if((pError = pDatabasePath->SetAllFileAttributes(strDatabaseName, iOldAttribs)) != 0)
		return FatalError(*pError);

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfStreamsRemove(IMsiRecord& riParams)
{
	// doesn't handle rollback - only used when copying the database
	using namespace IxoStreamsRemove;
	PMsiStorage pStorage(0);
	PMsiRecord pError = m_riServices.CreateStorage(riParams.GetString(File), ismTransact, *&pStorage);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strStreams = riParams.GetMsiString(Streams);
	MsiString strStreamName;
	while(strStreams.TextSize())
	{
		strStreamName = strStreams.Extract(iseUpto,';');
		if(strStreamName.TextSize() == strStreams.TextSize())
			strStreams = TEXT("");
		else
			strStreams.Remove(iseFirst,strStreamName.TextSize()+1);
		if((pError = pStorage->RemoveElement(strStreamName, fFalse)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}
	if((pError = pStorage->Commit()) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfStreamAdd(IMsiRecord& riParams)
{
	// doesn't handle rollback - only used when copying the database
	// Trivial to add, just add a ixoStreamsRemove call.

	using namespace IxoStreamAdd;
	PMsiStorage pStorage(0);
	PMsiRecord pError = m_riServices.CreateStorage(riParams.GetString(File), ismTransact, *&pStorage);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strStream = riParams.GetMsiString(Stream);
	PMsiStream pData((IMsiStream*) riParams.GetMsiData(Data));
	PMsiStream pOutData(0);

	if (!(pError = pStorage->OpenStream(strStream, fTrue, *&pOutData)))
	{
		const int cchBuffer = 4096;
		CTempBuffer<char,1> rgchBuffer(cchBuffer);
		int cchRemaining = pData->Remaining();
		int cchInUse;
		while(cchRemaining)
		{
			cchInUse = (cchRemaining > cchBuffer) ? cchBuffer : cchRemaining;
			pData->GetData(rgchBuffer, cchInUse);
			pOutData->PutData(rgchBuffer, cchInUse);
			cchRemaining -= cchInUse;
		}
	}
	else
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	if((pError = pStorage->Commit()) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}   
	return iesSuccess;
}

//**************************************************************************//
//ADVERTISE OPCODES
//**************************************************************************//

/*---------------------------------------------------------------------------
ixfPackageCodePublish: Advertise package code
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfPackageCodePublish(IMsiRecord& riParams)
{
	using namespace IxoPackageCodePublish;

	if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we write/delete the registry
	{
		MsiString strPackageCodeSQUID = GetPackedGUID(MsiString(riParams.GetMsiString(PackageKey)));
		MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));

		PMsiRecord pRecErr(0);
		PMsiStream pSecurityDescriptor(0);
		if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
			return FatalError(*pRecErr);

		const ICHAR* rgszRegData[] =
		{
			TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
			szPackageCodeValueName,     (const ICHAR*)strPackageCodeSQUID,     g_szTypeString,
			0,
			0,
		};

		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
	}
	else
	{
		return iesNoAction;
	}
}

/*---------------------------------------------------------------------------
ixfUpgradeCodePublish: Advertise upgrade code
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfUpgradeCodePublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfUpgradeCodePublish")));
		return iesFailure;
	}

	return ProcessUpgradeCodePublish(riParams, m_fReverseADVTScript);
}

iesEnum CMsiOpExecute::ixfUpgradeCodeUnpublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfUpgradeCodeUnpublish")));
		return iesFailure;
	}

	return ProcessUpgradeCodePublish(riParams, fTrue);
}

iesEnum CMsiOpExecute::ProcessUpgradeCodePublish(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoUpgradeCodePublish;

	if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we write/delete the registry
	{
		MsiString strUpgradeCodeSQUID = GetPackedGUID(MsiString(riParams.GetMsiString(UpgradeCode)));
		MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));

		PMsiRecord pRecErr(0);
		PMsiStream pSecurityDescriptor(0);
		if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
			return FatalError(*pRecErr);

		const ICHAR* rgszRegData[] =
		{
			TEXT("%s\\%s"), _szGPTUpgradeCodesKey, strUpgradeCodeSQUID, 0,
			strProductKeySQUID,  0,   g_szTypeString,
			0,
			0,
		};  

		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
	else
	{
		return iesNoAction;
	}
}

/*---------------------------------------------------------------------------
ixfProductPublish: Advertise common product info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductPublish(IMsiRecord& riParams)
{
	using namespace IxoProductPublish;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductPublish")));
		return iesFailure;
	}

	return ProcessPublishProduct(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfProductUnpublish: Unadvertise common product info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductUnpublish(IMsiRecord& riParams)
{
	using namespace IxoProductUnpublish;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductUnpublish")));
		return iesFailure;
	}
	
	return ProcessPublishProduct(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ixfProductPublishUpdate: re-register common product info (product name and version)
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductPublishUpdate(IMsiRecord& /*riParams*/)
{
	using namespace IxoProductPublishUpdate;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesNoAction;

	PMsiRecord pRecErr(0);
	PMsiStream pSecurityDescriptor(0);
	if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));
	MsiString strProductName      = MsiString(GetProductName());
	MsiString strVersion          = MsiString(GetProductVersion());

	const ICHAR* rgszRegData[] =
	{
		TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
		szProductNameValueName,     (const ICHAR*)strProductName,       g_szTypeString,
		szVersionValueName,         (const ICHAR*)strVersion,           g_szTypeInteger,
		0,
		0,
	};

	CElevate elevate;
	return ProcessRegInfo(rgszRegData, m_hKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
}

/*---------------------------------------------------------------------------
ProcessPublishProduct: process common product Advertise info
---------------------------------------------------------------------------*/

inline bool IsStringField(IMsiRecord& riRec, unsigned int iField)
{
	PMsiData pData = riRec.GetMsiData(iField);
	IMsiString* piString;

	if (pData && (pData->QueryInterface(IID_IMsiString, (void**)&piString) == NOERROR))
	{
		piString->Release();
		return true;
	}

	return false;
}

iesEnum CMsiOpExecute::ProcessPublishProduct(IMsiRecord& riParams, Bool fRemove, const IMsiString** pistrTransformsValue)
{
	using namespace IxoProductPublish;

	// If pistrTransformsValue is set then we're simply building the list
	// of transforms that we _would_ publish, but we don't actually
	// publish anything. Why? Because MsiAdvertiseScript needs this.
	Assert(!(fRemove && pistrTransformsValue));
	
	MsiString strProductKey = GetProductKey();

	if (pistrTransformsValue == 0)
	{
		IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
		AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
		if(Message(imtActionData, riActionData) == imsCancel)
			return iesUserExit;
	}

	//!! TODO??: check that other values have been set
		
	MsiString strLanguage  = MsiString(GetProductLanguage());
	MsiString strVersion =   MsiString(GetProductVersion());
	MsiString strInstanceType = MsiString(GetProductInstanceType());

	if (fRemove) // if we're unpublishing then we can tell the start menu that this product is going away
		m_fStartMenuUninstallRefresh = true;

	PMsiRecord pRecErr(0);

	// process the transform information

	PMsiRecord pArgParams(0);
	int cFields = 0;

	if (fRemove)
	{
		// We're unpublishing. Instead of using the transform information that's
		// in the script we'll use the information that's been registered for
		// this product.

		// We'll create a dummy record that the rest of the opcode can use.
		
		int cDummyRecordFieldCount = 1 + 10; // PackageKey + guess of max 10 transforms
		bool fContinue = true;

		while (fContinue)
		{
			fContinue = false;
			pArgParams = &m_riServices.CreateRecord(cDummyRecordFieldCount);
			
			// grab the transforms list from the registry

			CTempBuffer<ICHAR, 100> szBuffer;
			MsiString strDummyTransformList;
			if (ENG::GetExpandedProductInfo(strProductKey, INSTALLPROPERTY_TRANSFORMS, szBuffer))
				strDummyTransformList = (const ICHAR*)szBuffer;

			// parse it and create a dummy record to use instead of riParams

			MsiString strDummyTransform;
			Assert(PackageKey == 1);
			pArgParams->SetString(PackageKey, MsiString(riParams.GetString(PackageKey)));
			int cDummyCount = 2;

			if (strDummyTransformList.TextSize())
			{
				for (;;)
				{
					strDummyTransform = strDummyTransformList.Extract(iseUpto, ';');

					pArgParams->SetString(cDummyCount++, strDummyTransform);
					if (!strDummyTransformList.Remove(iseIncluding, ';'))
						break;

					if (cDummyCount > pArgParams->GetFieldCount())
					{
						// our record isn't big enough; need to start again with a bigger record
						cDummyRecordFieldCount += 10;
						fContinue = true;
						break;
					}
				}
			}
			cFields = cDummyCount - 1;
		}
		
	}
	else
	{
		riParams.AddRef();
		pArgParams = &riParams;
		cFields = pArgParams->GetFieldCount();
	}

	int cCount = PackageKey + 1;
	
	MsiString strTransformList;
	tsEnum tsTransformsSecure = tsNo;

	while(cCount <= cFields)
	{
		MsiString strTransform = pArgParams->GetMsiString(cCount);
		
		if(strTransformList.TextSize())
			strTransformList += MsiString(*TEXT(";"));

		if (cCount == PackageKey+1) // first transform
		{
			// This is the first transform. If there's a secure token then it will
			// be prepended to this transform.
			//
			// We need to do two things:
			//
			// 1) Put the correct token at the head of our transforms list that we're
			//    going to store in the registry
			// 2) Determine whether we have secure transforms and, if so, what type
			
			ICHAR chFirst = *(const ICHAR*)strTransform;
			ICHAR chToken = 0;

			if (chFirst == SECURE_RELATIVE_TOKEN)
			{
				tsTransformsSecure = tsRelative;
				chToken = SECURE_RELATIVE_TOKEN;
			}
			else if (chFirst == SECURE_ABSOLUTE_TOKEN)
			{
				tsTransformsSecure = tsAbsolute;
				chToken = SECURE_ABSOLUTE_TOKEN;
			}
			else if (!fRemove &&
						(GetIntegerPolicyValue(szTransformsSecureValueName,   fTrue) ||
						 GetIntegerPolicyValue(szTransformsAtSourceValueName, fFalse)))
			{
				// Don't check policy when unpublishing. Policy isn't relevant then --
				// we simply rely on whatever tokens have been prepended to the transforms
				// list in was stored in the registry.
				//
				// If, however, we're publishing and one of the secure policies is set
				// _and_ no token was set then we know that transforms are secure, but
				// we don't know whether they're absolutley pathed or relatively pathed
				// (i.e. at-source). We'll determine this once we start looking at the
				// transforms lists.
				
				tsTransformsSecure = tsUnknown;
			}

			// If we did find a secure token at the front of our first transform
			// then we tack it onto the front of our transforms list that's
			// to be stored in the registry. We also remove the token from the
			// transform so as not to confuse ourselves below.
			if (chToken)
			{
				strTransformList += MsiString(MsiChar(chToken));
				strTransform.Remove(iseFirst, 1);
			}
		}

		cCount++;
		
		DEBUGMSG1(TEXT("Transforms are %s secure."), (tsTransformsSecure == tsNo) ? TEXT("not") : (tsTransformsSecure == tsAbsolute) ? TEXT("absolute") : (tsTransformsSecure == tsRelative) ? TEXT("relative") : (tsTransformsSecure == tsUnknown) ? TEXT("unknown") : TEXT("??"));

		// In the olden days we prepend the SECURE_RELATIVE_TOKEN
		// (formerly the source token) to _each_ transform in our list, e.g.
		// @foo1.mst;@foo2.mst;@foo3.mst. In case we run into transformed registered
		// in this way we strip off any extraneous "@" tokens that we find and
		// we're going through our transforms.

		if (*(const ICHAR*)strTransform == SECURE_RELATIVE_TOKEN)
			strTransform.Remove(iseFirst, 1);

		if((*(const ICHAR*)strTransform == SHELLFOLDER_TOKEN))
		{
			// Transforms that are cached in the user profile need to
			// be removed. We need to translate the shell folder syntax
			// (*26*....) into a real path and then remove the transform file.

			if (fRemove)
			{
				MsiString strFullPath;
				if ((pRecErr = ExpandShellFolderTransformPath(*strTransform, *&strFullPath, m_riServices)))
				{
					return FatalError(*pRecErr);
				}
				else
				{
					DEBUGMSGV1(TEXT("Removing shell-folder cached transform: %s"), strFullPath);
					// schedule file for deletion once we let go of install packages/transforms
					if(iesSuccess != DeleteFileDuringCleanup(strFullPath, true))
					{
						DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strFullPath);
					}
				}
			}
			else
			{
				AssertSz(0, TEXT("Encountered a shell-folder token in our transforms list in the script"));
			}
		}
		else if ((*(const ICHAR*)strTransform == STORAGE_TOKEN))
		{
			// Storage transforms don't need to be "removed". They do, however, need to
			// be registered.

			if (!fRemove)
			{
				strTransformList += strTransform;
				DEBUGMSGV1(TEXT("Registering storage transform: %s"), strTransform);
			}
		}
		else if(tsTransformsSecure != tsNo) // Transforms are secure
		{
			Assert(tsTransformsSecure == tsUnknown  ||
					 tsTransformsSecure == tsRelative ||
					 tsTransformsSecure == tsAbsolute);
			

			if (!pArgParams->IsNull(cCount) && !IsStringField(*pArgParams, cCount)) // skip data field, if any
			{
				cCount++;
			}

			// We decided above that we have a secure transform of some form. If
			// the exact type is unknown then we'll determine it now, based
			// on what type of path the transform has.

			if (tsTransformsSecure == tsUnknown)
			{
				if (ENG::PathType(strTransform) == iptFull)
				{
					tsTransformsSecure = tsAbsolute;
				}
				else
				{
					tsTransformsSecure = tsRelative;
				}
			}

			strTransformList += strTransform;
			DEBUGMSGV2(TEXT("%s secure transform: %s"), fRemove ? TEXT("Unregistering") : TEXT("Registering"), strTransform);
		}
		else // file transform that needs to be cached
		{
			// Ignore the full path if present. We only care about the file name.
			PMsiPath pPath(0);
			MsiString strFileName;
			if ((pRecErr = m_riServices.CreateFilePath(strTransform, *&pPath, *&strFileName)))
				return FatalError(*pRecErr);
			
			strTransform = strFileName;

			// We need to either dump the transforms from the script onto
			// the machine (ProductPublish) or simply remove the existing
			// transform (ProductUnpublish)

			if((m_fFlags & SCRIPTFLAGS_CACHEINFO))// do we process the cached icons/ transforms
			{
				// Determine where we're going to put the transform/where we're going to delete it from
				Assert(m_pCachePath);
				MsiString strTransformFullPath;
				if((pRecErr = m_pCachePath->GetFullFilePath(strTransform,*&strTransformFullPath)))
					return FatalError(*pRecErr);

				DEBUGMSGV1(TEXT("Processing cached transform: %s"), strTransformFullPath);

				
				{
					CElevate elevate; // elevate to create or remove files in secured folder

					iesEnum iesRet = iesNoAction;
					if(fRemove)
					{
						// schedule file for deletion once we let go of install packages/transforms
						if(iesSuccess != DeleteFileDuringCleanup(strTransformFullPath, true))
						{
							DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strTransformFullPath);
						}
					}
					else if (pistrTransformsValue != 0)
					{
						// we're only building the transforms list; simply skip the data
						cCount++;
					}
					else
					{
						// we create the file from the binary data
						LPSECURITY_ATTRIBUTES pAttributes;
						SECURITY_ATTRIBUTES saAttributes;
						if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
						{
							if (ERROR_SUCCESS != GetLockdownSecurityAttributes(saAttributes, false))
								return iesFailure;
							pAttributes = &saAttributes;
						}
						else
						{
							// do not attempt to secure the transform file in the  appdata folder
							// since it might not be local OR may move to the net later
							pAttributes = 0;
						}


						if((iesRet = ProcessFileFromData(*m_pCachePath,*strTransform,
							PMsiData(pArgParams->GetMsiData(cCount++)),
							pAttributes)) != iesSuccess)
							return iesRet;

						// mark transform read-only to dissuade users from
						// deleting it from their profile
						if((pRecErr = m_pCachePath->SetFileAttribute(strTransform, ifaReadOnly, fTrue)))
						{
							Message(imtInfo, *pRecErr);
						}
					}
				}
			}
			else
			{
				cCount++; // skip transform data
			}

			// Now that we've dumped the transform onto the machine (if needed)
			// we need to register the correct path for the transform. If
			// the path is user specific then we need to encode the path so
			// that instead of something like:
			//
			//    C:\Winnt\Profiles\JoeUser\Application Data\Microsoft...
			//
			// we have instead:
			//
			//    *26*\Microsoft...
			//
			// This is in case the user roams and the machine they roam to has
			// Application Data elsewhere.

			MsiString strPath;
			if(!m_fUserSpecificCache)
			{
				strPath = m_pCachePath->GetPath();
			}
			else
			{
				if ((pRecErr = GetCachePath(*&m_pCachePath, &strPath))) // get encoded cache path (shell ID at the beginning)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
			}

			strPath += strTransform;
			strTransformList += strPath;
			DEBUGMSGV1(TEXT("Registering cached transform: %s"), strPath);
		}
	}

	iesEnum iesRet = iesSuccess;

	// We need to mark the front of the transforms list with
	// the appropriate token if necessary

	if (strTransformList.TextSize())
	{
		if ((tsTransformsSecure == tsRelative) &&
			(*(const ICHAR*)strTransformList != SECURE_RELATIVE_TOKEN))
		{
			strTransformList = MsiString(MsiChar(SECURE_RELATIVE_TOKEN)) + strTransformList;
		}
		else if ((tsTransformsSecure == tsAbsolute) &&
			(*(const ICHAR*)strTransformList != SECURE_ABSOLUTE_TOKEN))
		{
			strTransformList = MsiString(MsiChar(SECURE_ABSOLUTE_TOKEN)) + strTransformList;
		}
	}

	if (pistrTransformsValue)
	{
		// we're not registering anything -- simple return the
		// transforms list htat we built
		strTransformList.ReturnArg(*pistrTransformsValue);
	}
	else if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we write/delete the registry
	{
		// published data needs to be secure

		PMsiStream pSecurityDescriptor(0);
		if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
			return FatalError(*pRecErr);

		MsiString strProductKeySQUID = GetPackedGUID(strProductKey);

		if ( !fRemove )
		{
			MsiString strAssignmentType;
			if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
				strAssignmentType = MsiString(1);
			else
				strAssignmentType = MsiString(0);

			MsiString strPackageKeySQUID = GetPackedGUID(MsiString(pArgParams->GetMsiString(PackageKey)));
			
			MsiString strProductIcon(GetProductIcon());
			bool fExpandProductIcon = false;

			// Convert the Product Icon to an actual path from the cache.
			// is this a full path or an index into the icon table
			if (strProductIcon.TextSize())
			{
				if(PathType(strProductIcon) != iptFull)
				{
					Assert(m_pCachePath);
					MsiString strIconPath = GetUserProfileEnvPath(*MsiString(m_pCachePath->GetPath()), fExpandProductIcon);
					strProductIcon = strIconPath + strProductIcon;
				}
			}
				
			MsiString strADVTFlags = MsiString((m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO) | (m_fFlags & SCRIPTFLAGS_SHORTCUTS)); // store off what we advertise the first time round
			int cLimit = fRemove ? 1 : 0;
			for (int cCount = 1; cCount >= cLimit; cCount--) // remove previous entries and then add any new entries
			{
				const ICHAR* rgszRegData[] =
				{
					TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
					szProductNameValueName,     cCount ? 0 : (const ICHAR*)MsiString(GetProductName()),       g_szTypeString,
					szPackageCodeValueName,     cCount ? 0 : (const ICHAR*)strPackageKeySQUID,     g_szTypeString,
					szLanguageValueName,        cCount ? 0 : (const ICHAR*)strLanguage,           g_szTypeInteger,
					szVersionValueName,         cCount ? 0 : (const ICHAR*)strVersion,            g_szTypeInteger,
					szTransformsValueName,      cCount ? 0 : (const ICHAR*)strTransformList,       g_szTypeExpandString,
					szAssignmentTypeValueName,  cCount ? 0 : (const ICHAR*)strAssignmentType,      g_szTypeInteger,
					szAdvertisementFlags,       cCount ? 0 : (const ICHAR*)strADVTFlags,           g_szTypeInteger,
					szProductIconValueName,     cCount ? 0 : (const ICHAR*)strProductIcon,         (fExpandProductIcon) ? g_szTypeExpandString : g_szTypeString,
					szInstanceTypeValueName,    cCount ? 0 : (const ICHAR*)strInstanceType,      g_szTypeInteger,
					0,
					0,
				};

				CElevate elevate;
				iesRet = ProcessRegInfo(rgszRegData, m_hKey, cCount ? fTrue : fFalse, pSecurityDescriptor, 0, ibtCommon);
				if(iesRet != iesSuccess && iesRet != iesNoAction)
					return iesRet;
			}
		}
		else
		{
			m_cSuppressProgress++;  

			MsiString strProductsKey = _szGPTProductsKey TEXT("\\");
			strProductsKey += strProductKeySQUID;

			MsiString strFeaturesKey = _szGPTFeaturesKey TEXT("\\");
			strFeaturesKey += strProductKeySQUID;

			PMsiRecord pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
			
			for (int cCount = 0; (iesRet == iesSuccess || iesRet == iesNoAction) && cCount < (m_hKeyRm ? 2:1);cCount++)
			{

#ifdef _WIN64   // !merced
				AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, cCount ? (HANDLE)m_hKeyRm : (HANDLE)m_hKey ));
#else
				AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, cCount ? (int)m_hKeyRm : (int)m_hKey));
#endif
				AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

				// clear product info
				AssertNonZero(pParams->SetString(IxoRegOpenKey::Key, strProductsKey));
				// we elevate this block to ensure that we're able to remove our key
				{
					CElevate elevate;
					iesRet = ixfRegOpenKey(*pParams);
					if (iesRet == iesSuccess || iesRet == iesNoAction)
						iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
				}
				
				if ( iesRet != iesSuccess && iesRet != iesNoAction )
					continue;

				// clear out any registered feature info, that may potentially remain for disabled features
				AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strFeaturesKey));
				// we elevate this block to ensure that we're able to remove our key
				{
					CElevate elevate;
					iesRet = ixfRegOpenKey(*pParams);
					if (iesRet == iesSuccess || iesRet == iesNoAction)
						iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
				}
			}
			m_cSuppressProgress--;  
		}
	}   
	return iesRet;
}

/*---------------------------------------------------------------------------
ixfAdvtFlagsUpdate
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfAdvtFlagsUpdate(IMsiRecord& riParams)
{
	using namespace IxoAdvtFlagsUpdate;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));
	MsiString strAdvtFlags = riParams.GetMsiString(Flags);

	const ICHAR* rgszRegData[] =
	{
		TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
				szAdvertisementFlags,    (const ICHAR*)strAdvtFlags,  g_szTypeInteger,
				0,
				0,
	};

	CElevate elevate;
	return ProcessRegInfo(rgszRegData, m_hKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
}

/*---------------------------------------------------------------------------
ixfProductPublishClient
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductPublishClient(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductPublishClient")));
		return iesFailure;
	}

	return ProcessPublishProductClient(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfProductUnpublishClient
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductUnpublishClient(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductUnpublishClient")));
		return iesFailure;
	}
	
	return ProcessPublishProductClient(riParams, fTrue);
}

iesEnum CMsiOpExecute::ProcessPublishProductClient(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoProductPublishClient;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID = GetPackedGUID(MsiString(GetProductKey()));

	MsiString strParent              = riParams.GetMsiString(Parent);
	MsiString strRelativePackagePath = riParams.GetMsiString(ChildPackagePath);
	unsigned int uiDiskId            = riParams.GetInteger(ChildDiskId);
	MsiString strClients;
	GetProductClientList(strParent, strRelativePackagePath, uiDiskId, *&strClients);

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;
		const ICHAR* rgszRegData[] =
		{
			TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
			szClientsValueName,         strClients,              g_szTypeMultiSzStringSuffix,
			0,
			0
		};

		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}

/*---------------------------------------------------------------------------
ixfFeaturePublish: advertise feature-component info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFeaturePublish(IMsiRecord& riParams)
{
	// Record description
	// 1 = Feature ID
	// 2 = Parent feature(optional)
	// 3 = Absent
	// 4 = Component#1
	// 5 = Component#2
	// 6 = Component#3
	// ...
	// ...

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfFeaturePublish")));
		return iesFailure;
	}
	return ProcessPublishFeature(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfFeatureUnpublish: unadvertise feature-component info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFeatureUnpublish(IMsiRecord& riParams)
{
	// Record description
	// 1 = Feature ID
	// 2 = Parent feature(optional)
	// 3 = Absent
	// 4 = Component#1
	// 5 = Component#2
	// 6 = Component#3
	// ...
	// ...

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfFeatureUnpublish")));
		return iesFailure;
	}
	return ProcessPublishFeature(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessPublishFeature: Process feature-component info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishFeature(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoFeaturePublish;
	// Record description
	// 1 = Feature ID
	// 2 = Parent feature(optional)
	// 3 = Absent
	// 4 = Component#1
	// 5 = Component#2
	// 6 = Component#3
	// ...
	// ...

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;


	MsiString strFeature = riParams.GetMsiString(Feature);
	MsiString strFeatureParent = riParams.GetMsiString(Parent);

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strFeature));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	// registration of features in CurrentUser - changed to omit component list
	MsiString strProductKeySQUID = GetPackedGUID(MsiString(GetProductKey()));
	// we elevate this block to ensure that we're able to write to our key
	{
		const ICHAR* szValue;
		bool fSetFeatureAbsent = false;
		ICHAR rgchTemp[MAX_FEATURE_CHARS + 16];
		if(riParams.GetInteger(Absent) & iPublishFeatureAbsent)  // flag feature as not advertised
		{
			fSetFeatureAbsent = true;
			// if we are (re)advertising then we should respect the fact that the
			// feature may have been previously explicitly made available by the user
			// prior to this logon
			if(m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT)
			{
				// read the previous registration
				MsiString strSubKey = _szGPTFeaturesKey TEXT("\\");
				strSubKey += strProductKeySQUID;
				PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hKey, ibtCommon);        //--merced: changed (int) to (INT_PTR)
				PMsiRegKey pFeaturesKey = &pRootKey->CreateChild(strSubKey);
				MsiString strOldValue;
				Bool bValueExists = fFalse;
				if((pRecErr = pFeaturesKey->ValueExists(strFeature, bValueExists)) != 0)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
				if(bValueExists == fTrue)
				{
					if((pRecErr = pFeaturesKey->GetValue(strFeature,*&strOldValue)) != 0)
					{
						Message(imtError, *pRecErr);
						return iesFailure;
					}
					if(!strOldValue.TextSize() || *(const ICHAR*)strOldValue != chAbsentToken)
						fSetFeatureAbsent = false;
				}
			}
		}
		if(fSetFeatureAbsent)
		{
			// set feature to absent
			rgchTemp[0] = chAbsentToken;
			IStrCopyLen(&rgchTemp[1], (const ICHAR*)strFeatureParent, sizeof(rgchTemp)/sizeof(ICHAR) - 1);
			szValue = rgchTemp;
		}
		else if (strFeatureParent.TextSize())
			szValue = strFeatureParent;
		else
			szValue = 0;  // force registry write (empty string suppresses)

		const ICHAR* rgszRegData[] = {
			TEXT("%s\\%s"), _szGPTFeaturesKey, strProductKeySQUID,0,
			strFeature, szValue, g_szTypeString,
			0,
			0,
		};
		CElevate elevate;
		iesEnum iesRet = ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
		if (iesRet != iesSuccess || !(riParams.GetInteger(Absent) & iPublishFeatureInstall))
			return iesRet;
	}

	if(strFeatureParent.TextSize())
	{
		// we have a parent feature. delimit
		strFeatureParent = MsiString(MsiChar(chFeatureIdTerminator)) + strFeatureParent;
	}
	MsiString strComponentsList;
	int cPos = Component;
	if(m_iScriptVersion < 21 || (m_iScriptVersion == 21 && m_iScriptVersionMinor < 3))
	{
		// components are not packed on the client side
		while(!riParams.IsNull(cPos))
		{
			ICHAR szSQUID[cchComponentIdCompressed+1];
			AssertNonZero(PackGUID(riParams.GetString(cPos++), szSQUID, ipgCompressed));
			strComponentsList += szSQUID;
		}
	}
	else
	{
		// components are packed on the client side
		strComponentsList += riParams.GetString(cPos++);
	}
	strComponentsList += strFeatureParent;
	const ICHAR* pszComponentsList = strComponentsList;

    // registration of features in LocalMachine
	MsiString strLocalFeaturesKey;
	if((pRecErr = GetProductInstalledFeaturesKey(*&strLocalFeaturesKey)) != 0)
		return FatalError(*pRecErr);

	// we elevate this block to ensure that we're able to write to our key
	{
		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strLocalFeaturesKey, 0,0,
			strFeature, *pszComponentsList ? pszComponentsList : 0 /* force the feature publish, whether or not the component list is empty*/, g_szTypeString,
			0,
			0,
		};
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hUserDataKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}

/*---------------------------------------------------------------------------
ixfComponentPublish: advertise component-factory info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfComponentPublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentPublish")));
		return iesFailure;
	}
	return ProcessPublishComponent(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfComponentUnpublish: unadvertise component-factory info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfComponentUnpublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentUnpublish")));
		return iesFailure;
	}
	return ProcessPublishComponent(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessPublishComponent: Process component info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishComponent(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoComponentPublish;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = Component ID
	// 4 = Qualifier
	// 5 = AppData

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strPublishComponent = riParams.GetString(ComponentId);
	MsiString strQualifier = riParams.GetMsiString(Qualifier);
	MsiString strServer    = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
												*MsiString(riParams.GetMsiString(Component)));
	strServer += MsiString(riParams.GetMsiString(AppData)); // we append the app data to the Darwin Descriptor

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strPublishComponent));
	AssertNonZero(riActionData.SetMsiString(2, *strQualifier));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	MsiString strPublishComponentSQUID = GetPackedGUID(strPublishComponent);

	const ICHAR* rgszRegData[] = {
		TEXT("%s\\%s"),      _szGPTComponentsKey, strPublishComponentSQUID ,0,
		strQualifier,        strServer,           g_szTypeMultiSzStringDD,
		0,
		0,
	};

	{
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}


/*---------------------------------------------------------------------------
ixfAssemblyPublish: advertise assembly info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfAssemblyPublish(IMsiRecord& riParams)
{
	return ProcessPublishAssembly(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfAssemblyUnpublish: unadvertise assembly info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfAssemblyUnpublish(IMsiRecord& riParams)
{
	return ProcessPublishAssembly(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessPublishAssembly: Process assembly info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishAssembly(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoAssemblyPublish;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = AssemblyType
	// 4 = AppCtx
	// 5 = AssemblyName

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strAppCtx = riParams.GetString(AppCtx);
	if(!strAppCtx.TextSize())
		strAppCtx = szGlobalAssembliesCtx; // this assembly is being advertised to the GAC
	else
	{
		// we need to replace the backslashes in the AppCtx with something else, since registry keys cannot
		// have backslashes
		CTempBuffer<ICHAR, MAX_PATH> rgchAppCtxWOBS;
		DWORD cchLen = strAppCtx.TextSize() + 1;
		rgchAppCtxWOBS.SetSize(cchLen);
		memcpy((ICHAR*)rgchAppCtxWOBS, (const ICHAR*)strAppCtx, cchLen*sizeof(ICHAR));
		ICHAR* lpTmp = rgchAppCtxWOBS;
		while(*lpTmp)
		{
			if(*lpTmp == '\\')
				*lpTmp = '|';
			lpTmp = ICharNext(lpTmp);
		}
		strAppCtx = (const ICHAR* )rgchAppCtxWOBS;
	}

	MsiString strAssemblyName = riParams.GetMsiString(AssemblyName);
	MsiString strServer    = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
												*MsiString(riParams.GetMsiString(Component)));

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strAppCtx));
	AssertNonZero(riActionData.SetMsiString(2, *strAssemblyName));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	iatAssemblyType iatType = (iatAssemblyType)riParams.GetInteger(AssemblyType);

	const ICHAR* rgszRegData[] = {
		TEXT("%s\\%s"),       (iatWin32Assembly == iatType || iatWin32AssemblyPvt == iatType) ? _szGPTWin32AssembliesKey : _szGPTNetAssembliesKey, strAppCtx,0,
		strAssemblyName,      strServer,        g_szTypeMultiSzStringDD,
		0,
		0,
	};

	{
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}


const idtEnum rgidtMediaTypes[] = {idtCDROM, idtRemovable}; //!! need to add floppy when it's distinguished from removable

iesEnum CMsiOpExecute::PopulateMediaList(const MsiString& strSourceListMediaKey, const IMsiRecord& riParams, int iFirstField, int iNumberOfMedia)
{
	MsiString strMediaInfo;
	MsiString strMediaNumber;
	unsigned int iMediaArg = iFirstField + 1;
	
	while (iNumberOfMedia--)
	{
		int iDisk          = riParams.GetInteger(iMediaArg);
		MsiString strLabel = riParams.GetString(iMediaArg + 1);
		strMediaNumber     = MsiString(iDisk);

		strMediaInfo  = strLabel;
		strMediaInfo += TEXT(";");
		strMediaInfo += MsiString(riParams.GetString(iMediaArg + 2));
		iMediaArg += 3;

		// we elevate this block to ensure that we're able to write to our key
		{
			CElevate elevate;
			const ICHAR* rgszMediaRegData[] = {
					TEXT("%s"), strSourceListMediaKey, 0, 0,
					strMediaNumber,      strMediaInfo,       g_szTypeString,
					0,
					0,
					};

			iesEnum iesRet = ProcessRegInfo(rgszMediaRegData, m_hKey, fFalse, 0, 0, ibtCommon);
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::PopulateNonMediaList(const MsiString& strSourceListKey, const IMsiRecord& riParams, int iFirstSource, int &iNetIndex, int &iURLIndex)
{
	enum {
		rdSourceListKey        = 1,
		rdIndex                = 4,
		rdSource               = 5,
		rdType                 = 6,
	};
	
	const ICHAR* rgszRegData[] = {
		TEXT("%s"), 0/*rdSourceListKey*/, 0, 0,
		0 /*rdIndex*/,  0 /*rdSource*/,  g_szTypeExpandString /*rdType*/ ,
		0,
		0,
	};
	
	MsiString strSourceListURLKey   = strSourceListKey;
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += MsiString(szSourceListURLSubKey);

	MsiString strSourceListNetKey   = strSourceListKey;
	strSourceListNetKey += MsiString(MsiChar(chRegSep));
	strSourceListNetKey += MsiString(szSourceListNetSubKey);

	for (int c = iFirstSource; !riParams.IsNull(c); c++)
	{
		MsiString strUnexpandedSourcePath = riParams.GetString(c);
		MsiString strSourceListSubKey;
		MsiString strIndex;

		bool fFileUrl = false;
		bool fIsURL = IsURL(strUnexpandedSourcePath, fFileUrl);

		if (fIsURL)
		{
			strIndex = MsiString(iURLIndex++);
			strSourceListSubKey = strSourceListURLKey;
		}
		else
		{
			strIndex = MsiString(iNetIndex++);
			strSourceListSubKey = strSourceListNetKey;
		}
			
		// elevate this block to ensure that we're able to write to our key
		{
			CElevate elevate;

			rgszRegData[rdSourceListKey] = strSourceListSubKey;
			rgszRegData[rdIndex]         = strIndex;
			// Note that we don't respect VolumePref here. We assume that the admin has specified the path in the form they desire.
			rgszRegData[rdSource]        = strUnexpandedSourcePath;

			iesEnum iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon);
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}
	return iesSuccess;
}


/*---------------------------------------------------------------------------
ProcessPublishSourceList:
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishSourceList(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoSourceListPublish;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesRet;

	MsiString strPatchCode = riParams.GetMsiString(PatchCode);

	// special check required for patch source list unregistration
	if(fRemove && strPatchCode.TextSize() &&
		true == PatchHasClients(*strPatchCode,
										*MsiString(riParams.GetMsiString(IxoSourceListUnpublish::UpgradingProductCode))))
	{
		return iesSuccess;
	}

	// delete existing source lists

	PMsiRecord pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
	
	// construct URL and Net source list subkey strings
	
	MsiString strPackageName;
	MsiString strSourceListKey;
	if (strPatchCode.TextSize())
	{
		strSourceListKey =  _szGPTPatchesKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(strPatchCode));
		strPackageName   =  riParams.GetMsiString(PatchPackageName);
	}
	else
	{
		strSourceListKey =  _szGPTProductsKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));   
		strPackageName   =  MsiString(GetPackageName());
	}

	strSourceListKey += MsiString(MsiChar(chRegSep));
	strSourceListKey += szSourceListSubKey;
	MsiString strSourceListMediaKey = strSourceListKey;
	strSourceListMediaKey += MsiString(MsiChar(chRegSep));
	strSourceListMediaKey += MsiString(szSourceListMediaSubKey);

	// always delete existing source list keys
	m_cSuppressProgress++;  
#ifdef _WIN64   // !merced
	AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, (HANDLE)m_hKey));
#else
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, (int)m_hKey));
#endif
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

	AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strSourceListKey));
	// we elevate this block to ensure that we're able to remove our key
	{
		CElevate elevate;
		iesRet = ixfRegOpenKey(*pParams);
		if (iesRet == iesSuccess || iesRet == iesNoAction)
			iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
	}
	m_cSuppressProgress--;  

	if(m_hKeyRm) // duplicate action for user assigned apps in the non-assigned (roaming) hive
	{
		if (iesRet != iesSuccess && iesRet != iesNoAction)
			return iesRet;

		m_cSuppressProgress++;  
#ifdef _WIN64   // !merced
		AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, (HANDLE)m_hKeyRm));
#else
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, (int)m_hKeyRm));
#endif
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

		AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strSourceListKey));
		// we elevate this block to ensure that we're able to remove our key
		{
			CElevate elevate;
			iesRet = ixfRegOpenKey(*pParams);
			if (iesRet == iesSuccess || iesRet == iesNoAction)
				iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		}
		m_cSuppressProgress--;  
	}
	
	if (fRemove || (iesRet != iesSuccess && iesRet != iesNoAction))
		return iesRet;

	// populate source list keys
	PMsiRecord pError(0);
	int cSources = riParams.GetFieldCount();

	enum {
		rdSourceListKey        = 1,
		rdIndex                = 4,
		rdSource               = 5,
		rdType                 = 6,
	};

	const ICHAR* rgszRegData[] = {
		TEXT("%s"), 0/*rdSourceListKey*/, 0, 0,
		0 /*rdIndex*/,  0 /*rdSource*/,  g_szTypeString /*rdType*/ ,
		0,
		0,
	};

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;
	
		rgszRegData[rdSourceListKey] = strSourceListKey;
		rgszRegData[rdIndex]         = szPackageNameValueName;
		rgszRegData[rdSource]        = strPackageName;
		
		iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon);
		if (iesRet != iesSuccess && iesRet != iesNoAction)
			return iesRet;
	}

	rgszRegData[rdType]          = g_szTypeExpandString;

	unsigned int cDisks = riParams.GetInteger(NumberOfDisks);
	
	m_iMaxNetSource = 1;
	m_iMaxURLSource = 1;

	// populate Net and URL source list
	if (iesSuccess != (iesRet = PopulateNonMediaList(strSourceListKey, riParams, IxoSourceListPublish::NumberOfDisks + 1 + (3*cDisks), m_iMaxNetSource, m_iMaxURLSource)))
		return iesRet;

	// Populate media entries

	MsiString strMediaPackagePath  = riParams.GetString(PackagePath);
	MsiString strDiskPromptTemplate = riParams.GetString(DiskPromptTemplate);

	// write the disk prompt template and the media package path    
	if (cDisks)
	{
		// we elevate this block to ensure that we're able to write to our key
		{
			CElevate elevate;
			const ICHAR* rgszMediaRelativePathRegData[] = {
				TEXT("%s"), strSourceListMediaKey, 0, 0,
				szMediaPackagePathValueName,      strMediaPackagePath,       g_szTypeString,
				szDiskPromptTemplateValueName,     strDiskPromptTemplate,      g_szTypeString,
				0,
				0
				};

			iesRet = ProcessRegInfo(rgszMediaRelativePathRegData, m_hKey, fFalse, 0, 0, ibtCommon);
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}

	// write the media entries
	iesRet = PopulateMediaList(strSourceListMediaKey, riParams, IxoSourceListPublish::NumberOfDisks, cDisks);
	
	return iesRet;
}

/*---------------------------------------------------------------------------
ProcessPublishSourceListEx: Registers additional sources for a product
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishSourceListEx(IMsiRecord& riParams)
{
	using namespace IxoSourceListAppend;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesRet;

	MsiString strPatchCode = riParams.GetMsiString(PatchCode);

	// construct URL and Net source list subkey strings
	
	MsiString strPackageName;
	MsiString strSourceListKey;
	if (strPatchCode.TextSize())
	{
		strSourceListKey =  _szGPTPatchesKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(strPatchCode));
	}
	else
	{
		strSourceListKey =  _szGPTProductsKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));   
	}

	strSourceListKey += MsiString(MsiChar(chRegSep));
	strSourceListKey += szSourceListSubKey;
	strSourceListKey += MsiString(MsiChar(chRegSep));
	MsiString strSourceListMediaKey = strSourceListKey + MsiString(szSourceListMediaSubKey);
	strSourceListKey.Remove(iseLast, 1);

	unsigned int cDisks = riParams.GetInteger(NumberOfMedia);

	// process additional net/URL sources. Additional sources should be added at the end of the list,
	// which requires retrieving the current largest source for both types.
	int iNetIndex = 0;
	int iURLIndex = 0;

	// if this is a patch, we have to open the sourcelist key for the patch and
	// enumerate through the values to ensure that we don't duplicate a source
	// index. For the product itself, we can use the stored state
	if (strPatchCode.TextSize())
	{
		PMsiRegKey pRegKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hKey, ibtCommon); // x86 and ia64 same location       

		MsiString strSourceListNetKey   = strSourceListKey;
		MsiString strSourceListURLKey   = strSourceListKey;
		strSourceListURLKey += MsiString(MsiChar(chRegSep)) + MsiString(szSourceListURLSubKey);
		strSourceListNetKey += MsiString(MsiChar(chRegSep)) + MsiString(szSourceListNetSubKey);

		int *piIndex = NULL;
		for (int iType =0; iType<2; iType++)
		{
			piIndex = iType ? &iURLIndex : &iNetIndex;
			
			// open subkey to determine max index for net and URL sources
			PMsiRegKey pFormatKey = &pRegKey->CreateChild(iType ? strSourceListURLKey : strSourceListNetKey);
			PEnumMsiString pEnumString(0);
			PMsiRecord piError = 0;
			if ((piError = pFormatKey->GetValueEnumerator(*&pEnumString)) != 0)
				continue;
				
			MsiString strIndex;
			while (S_OK == pEnumString->Next(1, &strIndex, 0))
			{
				int iIndex = strIndex;

				if (iIndex > *piIndex)
					*piIndex = iIndex;
			}
		}

		// increment the indicies by 1 so the first write doesn't overwrite the current maximum
		iNetIndex++;
		iURLIndex++;
	}
	else
	{
		iNetIndex = m_iMaxNetSource;
		iURLIndex = m_iMaxURLSource;
	}
	
	// actually populate the list
	if (iesSuccess != (iesRet = PopulateNonMediaList(strSourceListKey, riParams, IxoSourceListAppend::NumberOfMedia + 1 + (3*cDisks), iNetIndex, iURLIndex)))
		return iesRet;

	if (!strPatchCode.TextSize())
	{
		m_iMaxNetSource = iNetIndex;
		m_iMaxURLSource = iURLIndex;
	}

	// Populate additional media entries. ProcessPublishSourceList registers the disk
	// template and disk prompt template, so we just need to register disk IDs and labels.
	iesRet = PopulateMediaList(strSourceListMediaKey, riParams, IxoSourceListAppend::NumberOfMedia, cDisks);
	
	return iesRet;
}

/*---------------------------------------------------------------------------
ixfSourceListPublish:Publish source list
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListPublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfSourceListPublish")));
		return iesFailure;
	}
	return ProcessPublishSourceList(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfSourceListPublishEx:Publish additional source list entries
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListAppend(IMsiRecord& riParams)
{
	// for reverse-advertisement, removal is accomplished by the original
	// SourceListPublish operation.
	if (m_fReverseADVTScript)
		return iesSuccess;
		
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfSourceListAppend")));
		return iesFailure;
	}
	return ProcessPublishSourceListEx(riParams);
}

/*---------------------------------------------------------------------------
ixfSourceListUnpublish
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListUnpublish(IMsiRecord& riParams)
{
		// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfSourceListUnpublish")));
		return iesFailure;
	}
	return ProcessPublishSourceList(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ixfSourceListRegisterLastUsed
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListRegisterLastUsed(IMsiRecord& riParams)
{
	using namespace IxoSourceListRegisterLastUsed;
	
	PMsiRecord pError(0);
	iesEnum iesRet;
	MsiString strLastUsedSource = riParams.GetMsiString(LastUsedSource);
	MsiString strProductKey     = riParams.GetMsiString(SourceProduct);
	Assert(strProductKey.TextSize());

	MsiString strRawSource, strIndex, strType, strSource, strSourceListKey, strSourceListSubKey;
	


	if ((pError = m_riConfigurationManager.SetLastUsedSource(strProductKey, strLastUsedSource, /*fAddToList =*/ fTrue, fFalse,
		&strRawSource, &strIndex, &strType, &strSource, &strSourceListKey, &strSourceListSubKey)) != 0)
		return FatalError(*pError);

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;

		MsiString strLastUsedSource = strType;
		strLastUsedSource += MsiChar(';');
		strLastUsedSource += strIndex;
		strLastUsedSource += MsiChar(';');
		strLastUsedSource += strRawSource;

		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strSourceListKey, 0, 0,
			szLastUsedSourceValueName,      strLastUsedSource, g_szTypeExpandString,
			0,
			TEXT("%s"), strSourceListSubKey, 0, 0,
			strIndex,                       strSource,    g_szTypeExpandString,
			0,
			0,
		};

		if((iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfURLSourceTypeRegister
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfURLSourceTypeRegister(IMsiRecord& riParams)
{
	using namespace IxoURLSourceTypeRegister;

	PMsiRecord pError(0);
	iesEnum iesRet;

	MsiString strProductKey = riParams.GetMsiString(ProductCode);
	int iSourceType         = riParams.GetInteger(SourceType);
	MsiString strSourceType = iSourceType;

	Assert(strProductKey.TextSize());

	MsiString strSourceListURLKey;
	strSourceListURLKey =  _szGPTProductsKey;
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += MsiString(GetPackedGUID(strProductKey));   
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += szSourceListSubKey;
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += MsiString(szSourceListURLSubKey);

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;

		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strSourceListURLKey, 0, 0,
			szURLSourceTypeValueName,      (const ICHAR*)strSourceType, g_szTypeInteger,
			0,
			0,
		};

		if((iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfSecureTransformCache: Cache secure transform
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSecureTransformCache(IMsiRecord& riParams)
{
	using namespace IxoSecureTransformCache;
	// Record description
	// 1 = Transform // full path to transform to cache
	// 2 = Transform type (secure vs source)
	// 3 = Transform data

	// copy transform to the product's secure cache location

	PMsiRecord pError(0);
	iesEnum iesRet;

	PMsiPath pSourcePath(0);
	MsiString strFileName;
	pError = m_riServices.CreateFilePath(riParams.GetString(IxoSecureTransformCache::Transform), *&pSourcePath, *&strFileName);
	if (pError)
		return FatalError(*pError);

	PMsiPath pTransformPath(0);
	MsiString strDestFileName;

	// get the appropriate secure transforms cache key/ value
	MsiString strSecureTransformsKey;
	pError = GetProductSecureTransformsKey(*&strSecureTransformsKey);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	MsiString strCachePath = GetMsiDirectory();
	Assert(strCachePath.TextSize());
	if((pError = m_riServices.CreatePath(strCachePath,*&pTransformPath)) != 0)
		return FatalError(*pError);

	PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)
	PMsiRegKey pSecureTransformsKey = &pHKLM->CreateChild(strSecureTransformsKey);
	MsiString strValue;
	bool fSourceTransformType = !riParams.IsNull(IxoSecureTransformCache::AtSource);
	MsiString strValueName = fSourceTransformType ? strFileName : MsiString(riParams.GetMsiString(IxoSecureTransformCache::Transform));
	pError = pSecureTransformsKey->GetValue(strValueName, *&strValue);
	if ((pError == 0) && (strValue.TextSize() != 0))
	{
		MsiString strTransformFullPath;
		if((pError = pTransformPath->GetFullFilePath(strValue,*&strTransformFullPath)) == 0)
		{
			IMsiRecord& riFileRemove = GetSharedRecord(IxoFileRemove::Args);
			riFileRemove.SetMsiString(IxoFileRemove::FileName, *strTransformFullPath);
			if ((iesRet = ixfFileRemove(riFileRemove)) != iesSuccess)
				return iesRet;
		}
	}

	{
		// elevate for creating temp file in secure location
		CElevate elevate;

		// Generate a unique name for transform, create and secure the file.
		// set dest path and file name
		if (((pError = pTransformPath->EnsureExists(0)) != 0) ||
			((pError = pTransformPath->TempFileName(0, szTransformExtension, fTrue, *&strDestFileName, 0)) != 0))
		{
			return FatalError(*pError);
		}
		
		// remove temp file so that CopyOrMoveFile won't attempt to back up old file
		if((pError = pTransformPath->RemoveFile(strDestFileName)) != 0)
			return FatalError(*pError);
	}

	PMsiStream pSecurityDescriptor(0);
	if ((pError = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pError);

	if (!riParams.IsNull(Data) && !IsStringField(riParams, Data))
	{
		// use stored transform data to copy to file

		CElevate elevate; // elevate to access secure location

		PMsiData pData(0);
		pData = riParams.GetMsiData(Data);

		LPSECURITY_ATTRIBUTES pAttributes;
		SECURITY_ATTRIBUTES saAttributes;
		if (ERROR_SUCCESS != GetLockdownSecurityAttributes(saAttributes, false))
			return iesFailure;
		pAttributes = &saAttributes;

		if ((iesRet = ProcessFileFromData(*pTransformPath,*strDestFileName, pData, pAttributes)) != iesSuccess)
			return iesRet;
		if((pError = pTransformPath->SetFileAttribute(strDestFileName, ifaReadOnly, fTrue)))
		{
			Message(imtInfo, *pError);
		}
	}
	else // cache transform as originally performed
	{
		// copy transform to cached location
		if((iesRet = CopyOrMoveFile(*pSourcePath,*pTransformPath,*strFileName,*strDestFileName, fFalse,fFalse,fTrue,iehShowNonIgnorableError, pSecurityDescriptor, ielfElevateDest)) != iesSuccess)
			return iesRet;
	}

	// now register the transform against the temp file name

	// we elevate this block to ensure that we're able to write to our key
	{
		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strSecureTransformsKey, 0,0,
			strValueName, strDestFileName, g_szTypeString,
			0,
			0,
		};
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hUserDataKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
	}
}


/*---------------------------------------------------------------------------
ixfIconCreate: Create icon files
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIconCreate(IMsiRecord& riParams)
{
	using namespace IxoIconCreate;
	// Record description
	// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
	// 2 = IconData

	return ProcessIcon(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixoIconRemove: Remove icon files
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIconRemove(IMsiRecord& riParams)
{
	using namespace IxoIconRemove;
	// Record description
	// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL

	return ProcessIcon(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessIcon: Process icon info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessIcon(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoIconCreate;
	// Record description
	// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
	// 2 = IconData

	if(!(m_fFlags & SCRIPTFLAGS_CACHEINFO))// do we process the cached icons/ transforms
		return iesSuccess;
	PMsiRecord pRecErr(0);
	MsiString strIconFullPath = riParams.GetMsiString(Icon);
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strIconFullPath));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	PMsiPath pIconFolder(0);
	MsiString strIconName;
	if(PathType(strIconFullPath) == iptFull)
	{
		//!!SECURITY -- is it OK to elevate for this "full path" case?
		if((pRecErr = m_riServices.CreateFilePath(strIconFullPath,*&pIconFolder,*&strIconName)) != 0)
			return FatalError(*pRecErr);
	}
	else
	{
		pIconFolder = m_pCachePath;
		strIconName = strIconFullPath;

		if((pRecErr = pIconFolder->GetFullFilePath(strIconName, *&strIconFullPath)) != 0)
			return FatalError(*pRecErr);
	}

	PMsiData pData(0);
	if(fRemove == fFalse)
	{
		pData = riParams.GetMsiData(Data);
	}
//  IMsiData* piData = pData;

	// elevate this block so we can access our cached location
	{
		CElevate elevate;
		if(fRemove) // we simply remove the file
		{
			// schedule file for deletion once we let go of install packages/transforms
			if(iesSuccess != DeleteFileDuringCleanup(strIconFullPath, true))
			{
				DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strIconFullPath);
			}

			return iesSuccess;
		}
		else
		{
			LPSECURITY_ATTRIBUTES pAttributes;
			SECURITY_ATTRIBUTES saAttributes;
			if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
			{
				GetLockdownSecurityAttributes(saAttributes, false);
				pAttributes = &saAttributes;
			}
			else
			{
				// do not attempt to secure the icon file in the  appdata folder
				// since it might not be local OR may move to the net later
				pAttributes = 0;
			}

			iesEnum iesRet = ProcessFileFromData(*pIconFolder,*strIconName, pData, pAttributes);
			if((pRecErr = m_pCachePath->SetFileAttribute(strIconName, ifaReadOnly, fTrue)))
			{
				Message(imtInfo, *pRecErr);
			}
			return iesRet;
		}
	}
}

iesEnum CMsiOpExecute::ProcessFileFromData(IMsiPath& riPath, const IMsiString& ristrFileName, const IMsiData* piData, LPSECURITY_ATTRIBUTES pAttributes)
{
	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;
	MsiString strFileFullPath;
	if((pRecErr = riPath.GetFullFilePath(ristrFileName.GetString(),*&strFileFullPath)) != 0)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	Bool fExists;
	if((pRecErr = riPath.FileExists(ristrFileName.GetString(),fExists)) != 0)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	IMsiRecord* piUndoParams = 0;
	if(fExists && RollbackEnabled())
	{
		if((iesRet = BackupFile(riPath, ristrFileName, fTrue, fTrue, iehShowIgnorableError)) != iesSuccess)
			return iesRet;
	}

	Assert(piData);
	// generate rollback op to remove the new file
	piUndoParams = &GetSharedRecord(IxoFileRemove::Args);
	AssertNonZero(piUndoParams->SetMsiString(IxoFileRemove::FileName,*strFileFullPath));
	AssertNonZero(piUndoParams->SetInteger(IxoFileRemove::Elevate, true));
	if (!RollbackRecord(ixoFileRemove,*piUndoParams))
		return iesFailure;

	return CreateFileFromData(riPath,ristrFileName,piData, pAttributes);
}
	
iesEnum CMsiOpExecute::CreateFileFromData(IMsiPath& riPath, const IMsiString& ristrFileName, const IMsiData* piData, LPSECURITY_ATTRIBUTES pAttributes)
{
	Assert(piData);
	PMsiRecord pError(0);

	MsiString strFileFullPath;
	if((pError = riPath.GetFullFilePath(ristrFileName.GetString(),*&strFileFullPath)) != 0)
		return FatalError(*pError);
	
	PMsiStream piStream(0);
	if(piData->QueryInterface(IID_IMsiStream, (void**)&piStream) != NOERROR)
	{
		DispatchError(imtError,Imsg(idbgOpCreateFileFromData),*strFileFullPath);
		return iesFailure;
	}
	PMsiPath piPath(0);
	// make sure the icon path exists
	if(CreateFolder(riPath) != iesSuccess)
		return iesFailure;

	// make sure we can create the file
	if ((pError = riPath.EnsureOverwrite(ristrFileName.GetString(), 0)))
		return FatalError(*pError);

	bool fImpersonate = RunningAsLocalSystem() &&
						FVolumeRequiresImpersonation(*PMsiVolume(&riPath.GetVolume()));
			
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	
	HANDLE hFile = WIN::CreateFile(strFileFullPath, GENERIC_WRITE, FILE_SHARE_READ, pAttributes,
								CREATE_ALWAYS, 
								(  FILE_ATTRIBUTE_NORMAL 
								| (SECURITY_SQOS_PRESENT
								|SECURITY_ANONYMOUS)), 0);
    if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), strFileFullPath);
			WIN::CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}

	DWORD dwLastError = GetLastError();
	if (ERROR_ALREADY_EXISTS == dwLastError)
	{
		// when called from ProcessDataFromFile, the file is removed by the backup call.
		// The file is now locked, and truncated, so we'll just need to explicitly apply the ACL.
		dwLastError = 0;
		if (!g_fWin9X && pAttributes && pAttributes->lpSecurityDescriptor && RunningAsLocalSystem())
		{
			CElevate elevate;
			CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);

			if(!WIN::SetFileSecurity(strFileFullPath,
				GetSecurityInformation(pAttributes->lpSecurityDescriptor),
				pAttributes->lpSecurityDescriptor))
			{
				DispatchError(imtError,Imsg(imsgOpSetFileSecurity), GetLastError(), strFileFullPath);
				if(hFile != INVALID_HANDLE_VALUE)
					WIN::CloseHandle(hFile);
				return iesFailure;
			}

		}
	}

	if(fImpersonate)
		StopImpersonating();
	
	if((hFile == INVALID_HANDLE_VALUE) || dwLastError)
	{
		DispatchError(imtError,Imsg(idbgOpCreateFileFromData),(const ICHAR*)strFileFullPath,(int)dwLastError);
		return iesFailure;
	}

	MsiRegisterSysHandle(hFile);
	CTempBuffer<char,1> rgchBuf(1024);
	int cbRead, cbWrite;
	do
	{
		cbRead = rgchBuf.GetSize();
		cbWrite = piStream->GetData(rgchBuf, cbRead);
		if (cbWrite)
		{
			unsigned long cbFileWritten;
			if (!WIN::WriteFile(hFile, rgchBuf, cbWrite, &cbFileWritten, 0))
			{
				WIN::DeleteFile(strFileFullPath); // ignore error
				AssertNonZero(MsiCloseSysHandle(hFile));
				DWORD dwLastError = GetLastError();
				DispatchError(imtError,Imsg(idbgOpCreateFileFromData),(const ICHAR*)strFileFullPath,(int)dwLastError);
				return iesFailure;
			}
			Assert(cbWrite == cbFileWritten);
		}
	} while (cbWrite == cbRead);
	AssertNonZero(MsiCloseSysHandle(hFile));
	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfShortcutCreate: Create shortcut
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfShortcutCreate(IMsiRecord& riParams)
{
	using namespace IxoShortcutCreate;
	// Record description
	// 1 = Shortcut Name
	// 2 = Target/ Darwin Descriptor
	// 3 = Arguments
	// 4 = WorkingDir //?? how do we get this
	// 5 = IconName
	// 6 = IconIndex
	// 7 = Hotkey
	// 8 = ShowCmd

	return ProcessShortcut(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfShortcutRemove: Remove shortcut
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfShortcutRemove(IMsiRecord& riParams)
{
	// Record description
	// 1 = Shortcut Name
	return ProcessShortcut(riParams, fTrue);
}


/*---------------------------------------------------------------------------
ProcessShortcut: Manage shortcuts
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessShortcut(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoShortcutCreate;
	// Record description
	// 1 = Shortcut Name
	// 2 = Feature
	// 3 = Component
	// 4 = FileName
	// 3 = Arguments
	// 4 = WorkingDir //?? how do we get this
	// 5 = IconName
	// 6 = IconIndex
	// 7 = Hotkey
	// 8 = ShowCmd
	// 9 = Description

	if(!(m_fFlags & SCRIPTFLAGS_SHORTCUTS)) // we do not create/ delete shortcuts
		return iesSuccess;

	if(!m_state.pTargetPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						*MsiString(*TEXT("ixoShortcutCreate")));
		return iesFailure;
	}


	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *MsiString(riParams.GetMsiString(Name))));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord piError(0);
	iesEnum iesRet = iesNoAction;

	CTempBuffer<ICHAR, 1> rgchTemp(MAX_PATH);
	PMsiRecord pCurrentShortcutInfo = &m_riServices.CreateRecord(Args);
	MsiString strShortcutName;
	if((piError = m_riServices.ExtractFileName(riParams.GetString(Name),m_state.pTargetPath->SupportsLFN(),*&strShortcutName)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}

	if((piError = EnsureShortcutExtension(strShortcutName, m_riServices)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}

	// we can only create/ delete shortcuts that do not have the FileName, if the shell supports Darwin Descriptors
	Bool fDDSupport = IsDarwinDescriptorSupported(iddOLE);
	Bool fShellSupport = IsDarwinDescriptorSupported(iddShell); //smart shell
	CSecurityDescription security;

	MsiString strShortcutFullPath;
	if((piError = m_state.pTargetPath->GetFullFilePath(strShortcutName, *&strShortcutFullPath)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}
	Bool fExists = fFalse, fShortcut = fFalse;
	if((piError = m_state.pTargetPath->FileExists(strShortcutName, fExists)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}

	if (!g_fWin9X && fExists)
	{
		security.Set(strShortcutFullPath);
		if (!security.isValid())
		{
			// create an error record to get the verbose logging, but ignore the error
			PMsiRecord(PostError(Imsg(imsgGetFileSecurity), WIN::GetLastError(), strShortcutFullPath));
		}
	}

	if(fRemove && fExists && (fDDSupport || fShellSupport))
	{
		// is the existing shortcut a darwin descriptor shortcut and if so is it pointing to this product
		ICHAR szProductCode[cchGUID+1];
		if((GetShortcutTarget(strShortcutFullPath, szProductCode, 0, 0)) &&
			(IStrComp(szProductCode, MsiString(GetProductKey()))))
		{
			// dont delete the shortcut, not pointing to our product
			DEBUGMSG2(TEXT("Skipping shortcut %s removal, shortcut has been overwritten by another product %s"), (const ICHAR*)strShortcutName, szProductCode);
			return iesSuccess;
		}
	}

	if(RollbackEnabled())
	{
		if(fExists)
		{

			if((iesRet = BackupFile(*m_state.pTargetPath,*strShortcutName, fTrue, fFalse, iehShowIgnorableError)) != iesSuccess)
				return iesRet;
		}
		else if(!fRemove)
		{
			// remove new shortcut on rollback
			IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
			AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName, *strShortcutName));
			if (!RollbackRecord(ixoFileRemove,riUndoParams))
				return iesFailure;
		}
	}

	PMsiPath piPath1(0);
	if(fRemove == fFalse)
	{
		MsiString strServerFile = riParams.GetMsiString(FileName);

		if(!strServerFile.TextSize() && !fDDSupport && !fShellSupport)
			return iesRet;

		MsiString strServerDarwinDescriptor = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
											  *MsiString(riParams.GetMsiString(Component)));

		// how much of the path exists - (for shell notification)
		if((piError = m_state.pTargetPath->ClonePath(*&piPath1)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}

		Bool fExists = fFalse;
		while(((piError = piPath1->Exists(fExists)) == 0) && (fExists == fFalse))
		{
			AssertZero(piPath1->ChopPiece());
		}
		if(piError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}


		if((iesRet = CreateFolder(*m_state.pTargetPath)) != iesSuccess)
			return iesRet;

		// get a record for the shortcut info
		IMsiRecord& riShortcutInfoRec = GetSharedRecord(icsEnumCount); // don't change ref count - shared record
		// get the target location
		// get the working directory
		if(!riParams.IsNull(WorkingDir))
		{
			MsiString strEncodedPath = riParams.GetMsiString(WorkingDir);
			CTempBuffer<ICHAR, 1> rgchEnvironmentPath(MAX_PATH);
			MsiString strLocation = strEncodedPath.Extract(iseUpto, MsiChar(chDirSep));
			if(strLocation != iMsiStringBadInteger)
			{
				// we have a shell folder id
				int iFolderId = strLocation;
				piError = GetShellFolder(iFolderId, *&strLocation);
				if(piError)
				{
					DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
					return iesSuccess;
				}
				if(strEncodedPath.Remove(iseUpto, MsiChar(chDirSep)))
				{
					//?? ugly
					MsiString strDirSep = MsiChar(chDirSep);
					if(strLocation.Compare(iscEnd, strDirSep))
						strLocation.Remove(iseLast, 1); // chop off the separator, if present
					strLocation += strEncodedPath;
				}
			}
			else
			{
				strLocation = strEncodedPath;
			}


			GetEnvironmentStrings(strLocation,rgchEnvironmentPath);
#ifndef _WIN64
			riShortcutInfoRec.SetString(icsWorkingDirectory, rgchEnvironmentPath);
#else
			ICHAR rgchSubstitute[MAX_PATH+1] = {0};
			ICHAR* pszPath = rgchEnvironmentPath;
			if ( g_Win64DualFolders.ShouldCheckFolders() )
			{
				ieSwappedFolder iRes;
				iRes = g_Win64DualFolders.SwapFolder(ie64to32,
																 rgchEnvironmentPath,
																 rgchSubstitute,
																 ARRAY_ELEMENTS(rgchSubstitute));
				if ( iRes == iesrSwapped )
					pszPath = rgchSubstitute;
				else
					Assert(iRes != iesrError && iRes != iesrNotInitialized);
			}
			riShortcutInfoRec.SetString(icsWorkingDirectory, pszPath);
#endif // _WIN64
		}
		if(!riParams.IsNull(Arguments))
			riShortcutInfoRec.SetMsiString(icsArguments, *MsiString(riParams.GetMsiString(Arguments)));
		if(!riParams.IsNull(Icon))
		{
			MsiString strIconName = riParams.GetMsiString(Icon);
			// is this a full path or an index into the icon table
			if(PathType(strIconName) != iptFull)
			{
				MsiString strIconPath = m_pCachePath->GetPath();
				strIconName = strIconPath + strIconName;
			}
			riShortcutInfoRec.SetMsiString(icsIconFullPath, *strIconName);
		}
		if(!riParams.IsNull(IconIndex))
			riShortcutInfoRec.SetInteger(icsIconID, riParams.GetInteger(IconIndex));
		if(!riParams.IsNull(HotKey))
			riShortcutInfoRec.SetInteger(icsHotKey, riParams.GetInteger(HotKey));
		if(!riParams.IsNull(ShowCmd))
			riShortcutInfoRec.SetInteger(icsShowCmd, riParams.GetInteger(ShowCmd));
		if(!riParams.IsNull(Description))
			riShortcutInfoRec.SetMsiString(icsDescription, *MsiString(riParams.GetMsiString(Description)));

		MsiString strTarget;
		if(strServerDarwinDescriptor.TextSize() && (fShellSupport || fDDSupport))
		{
			strTarget = MsiString(*szGptShortcutPrefix);
			strTarget += strServerDarwinDescriptor;
			strTarget += MsiString(*szGptShortcutSuffix);
		}
		else
			 strTarget = strServerFile; // use the file

		piError = m_riServices.CreateShortcut(  *m_state.pTargetPath,
												*strShortcutName,
												0,
												strTarget,
												&riShortcutInfoRec,
												security.isValid() ? security.SecurityAttributes() : NULL);
		if (piError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}
		if((piError = DoShellNotifyDefer(*m_state.pTargetPath, strShortcutName, *piPath1, fRemove)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}
	}
	else
	{       
		piError = m_riServices.RemoveShortcut(*m_state.pTargetPath, *strShortcutName, 0, 0);
		if (piError)
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
		// remove folder if possible
		if((iesRet = RemoveFolder(*m_state.pTargetPath)) != iesSuccess)
			return iesRet;

		// how much of the path exists - (for shell notification)
		if((piError = m_state.pTargetPath->ClonePath(*&piPath1)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
			return iesSuccess;
		}

		Bool fExists = fFalse;
		while(((piError = piPath1->Exists(fExists)) == 0) && (fExists == fFalse))
		{
			AssertZero(piPath1->ChopPiece());
		}
		if(piError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
			return iesSuccess;
		}
		if((piError = DoShellNotifyDefer(*m_state.pTargetPath, strShortcutName, *piPath1, fRemove)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
			return iesSuccess;
		}
	}

	return iesSuccess;
}


IMsiRecord* CMsiOpExecute::DoShellNotifyDefer(IMsiPath& riShortcutPath, const ICHAR* szFileName, IMsiPath& riPath2, Bool fRemove)
{
	// fix for Darwin bug #8973
	if (fRemove)
		return DoShellNotify(riShortcutPath, szFileName, riPath2, fRemove);

	m_fShellRefresh = fTrue;

	IMsiRecord* piError;
	if (!m_pDatabase)
	{
		// create the database.
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	if(!m_pShellNotifyCacheTable)
	{
		MsiString strTableName = m_pDatabase->CreateTempTableName();
		piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pShellNotifyCacheTable);
		if(piError)
			return piError;

		MsiString strNull;
		m_colShellNotifyCacheShortcutPath     = m_pShellNotifyCacheTable->CreateColumn(icdPrimaryKey + icdObject + icdTemporary,
																						 *strNull);
		m_colShellNotifyCacheFileName         = m_pShellNotifyCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary,
																						 *strNull);
		m_colShellNotifyCachePath2            = m_pShellNotifyCacheTable->CreateColumn(icdPrimaryKey + icdObject + icdTemporary,
																						 *strNull);
		// Removes are not deferred.

		Assert(m_colShellNotifyCacheShortcutPath && m_colShellNotifyCacheFileName && m_colShellNotifyCachePath2);

		m_pShellNotifyCacheCursor = m_pShellNotifyCacheTable->CreateCursor(fFalse);
	}

	// cache the entries

	AssertNonZero(m_pShellNotifyCacheCursor->PutMsiData(m_colShellNotifyCacheShortcutPath, &riShortcutPath));
	AssertNonZero(m_pShellNotifyCacheCursor->PutString(m_colShellNotifyCacheFileName, *MsiString(szFileName)));
	AssertNonZero(m_pShellNotifyCacheCursor->PutMsiData(m_colShellNotifyCachePath2, &riPath2));
	AssertNonZero(m_pShellNotifyCacheCursor->Assign());
	
	return 0;
}
iesEnum CMsiOpExecute::ShellNotifyProcessDeferred()
{
	iesEnum iesRet = iesSuccess;
	
	// if there is no database or table, we must be done.
	if (!m_pDatabase || !m_pShellNotifyCacheTable)
		return iesSuccess;
	Assert(m_pShellNotifyCacheCursor);

	//process the entries.
	m_pShellNotifyCacheCursor->Reset();

	PMsiPath pShortcutPath(0);
	MsiString strFileName;
	PMsiPath pPath2(0);
	
	PMsiRecord pError(0);
	while(m_pShellNotifyCacheCursor->Next())
	{
		pShortcutPath     = (IMsiPath*) m_pShellNotifyCacheCursor->GetMsiData(m_colShellNotifyCacheShortcutPath);
		strFileName       = m_pShellNotifyCacheCursor->GetString(m_colShellNotifyCacheFileName);
		pPath2            = (IMsiPath*) m_pShellNotifyCacheCursor->GetMsiData(m_colShellNotifyCachePath2);

		pError = DoShellNotify(*pShortcutPath, (const ICHAR*) strFileName, *pPath2, fFalse);
		if (pError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
					  Imsg(imsgOpShortcutCreate),
					  *strFileName);
			iesRet = iesFailure;
		}
		AssertNonZero(m_pShellNotifyCacheCursor->Delete());
	}
	return iesRet;
}
IMsiRecord* CMsiOpExecute::DoShellNotify(IMsiPath& riShortcutPath, const ICHAR* szFileName, IMsiPath& riPath2, Bool fRemove)
// Please call DoShellNotifyDefer for normal shortcut notifications.  This allows deferral of the notification until
// all files necessary are in place. Darwin bug# 8973
//
// For shortcut creation we need to be sending something like:
// SHCNE_MKDIR C:\foo
// SHCNE_MKDIR C:\foo\bar
// SHCNE_CREATE w/|SHCNF_FLUSHNOWAIT C:\foo\bar\cow.lnk
//
// For shortcut removal we need to be sending something like:
// SHCNE_REMOVE C:\foo\bar\cow.lnk
// SHCNE_REMOVEDIR C:\foo\bar
// SHCNE_REMOVEDIR w/|SHCNF_FLUSHNOWAIT C:\foo
//
{
	IMsiRecord* piError = 0;
	// notify the shell of file removal/ creation
	PMsiPath pShortcutPath(0); // will be doing ChopPiece() on shortcut path so need a new path object
	if((piError = riShortcutPath.ClonePath(*&pShortcutPath)) != 0)
		return piError;
	
	MsiString strShortcutFullName;
	if((piError = pShortcutPath->GetFullFilePath(szFileName, *&strShortcutFullName)) != 0)
		return piError;

	IMsiRecord& riParams = GetSharedRecord(istcfSHChangeNotify); // don't change ref count - shared record
	AssertNonZero(riParams.SetInteger(1, istcSHChangeNotify));
	AssertNonZero(riParams.SetString(5, 0));
	if (fRemove)
	{
		int iNotificationType = SHCNF_PATH;
		DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_DELETE: %s"),(const ICHAR*)strShortcutFullName);
		ipcEnum ipcCompare;
		bool fContinue = (((piError = riPath2.Compare(*pShortcutPath, ipcCompare)) == 0) && (ipcCompare == ipcChild));

		//
		// Use the SHCNF_FLUSHNOWAIT flag to avoid the possibility of a hang due
		// to the synchronous nature of SHCNF_FLUSH
		//
		if(!fContinue) // we will not be removing the folder
			iNotificationType |= SHCNF_FLUSHNOWAIT;

		AssertNonZero(riParams.SetInteger(2, SHCNE_DELETE));
		AssertNonZero(riParams.SetInteger(3, iNotificationType));
		AssertNonZero(riParams.SetString(4, (const ICHAR*)strShortcutFullName));
		Message(imtCustomServiceToClient, riParams); // SHChangeNotify is of void type, so it's OK to ignore return
	
		AssertNonZero(riParams.SetInteger(2, SHCNE_RMDIR));
		while (fContinue)
		{
			MsiString strPath = pShortcutPath->GetPath();
			AssertZero(pShortcutPath->ChopPiece());
			if (((piError = riPath2.Compare(*pShortcutPath, ipcCompare)) != 0) || (ipcCompare != ipcChild))
			{
				//
				// This is our last time through the loop; gotta flush
				//
				// Use the SHCNF_FLUSHNOWAIT flag to avoid the possibility of
				// a hang due to the synchronous nature of SHCNF_FLUSH
				//
				iNotificationType |= SHCNF_FLUSHNOWAIT;
				fContinue = false;
			}

			// notify the shell of folder removal/ creation
			DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_RMDIR: %s"), (const ICHAR* )CConvertString((const ICHAR*)strPath));
			AssertNonZero(riParams.SetInteger(3, iNotificationType));
			AssertNonZero(riParams.SetString(4, (const ICHAR*)strPath));
			Message(imtCustomServiceToClient, riParams); // SHChangeNotify is of void type, so it's OK to ignore return
		}
	}
	else // !fRemove
	{
		
		ipcEnum ipcCompare;
		int cTotalPieces = 0;

		// determine how many pieces of the path we have to tell the shell about
		while (((piError = riPath2.Compare(*pShortcutPath, ipcCompare)) == 0) && (ipcCompare == ipcChild))
		{
			cTotalPieces++;
			AssertZero(pShortcutPath->ChopPiece());
		}

		AssertNonZero(riParams.SetInteger(2, SHCNE_MKDIR));
		AssertNonZero(riParams.SetInteger(3, SHCNF_PATH));
		// notify the shell starting with the parent folder and working our way down
		while (cTotalPieces--)
		{
			// we've chopped pShortcutPath to bits; we need the original back
			if((piError = riShortcutPath.ClonePath(*&pShortcutPath)) != 0)
				return piError;

			int cChopped = 0;
			while (cChopped++ < cTotalPieces)
				AssertZero(pShortcutPath->ChopPiece());

			MsiString strPath = pShortcutPath->GetPath();
			DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_MKDIR: %s"), (const ICHAR* )CConvertString((const ICHAR*)strPath));
			AssertNonZero(riParams.SetString(4, (const ICHAR*)strPath));
			Message(imtCustomServiceToClient, riParams); // SHChangeNotify is of void type, so it's OK to ignore return

		}
			
		//
		// Use the SHCNF_FLUSHNOWAIT flag to avoid the possibility of
		// a hang due to the synchronous nature of SHCNF_FLUSH
		//
		DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_CREATE: %s"),(const ICHAR*)strShortcutFullName);
		AssertNonZero(riParams.SetInteger(2, SHCNE_CREATE));
		AssertNonZero(riParams.SetInteger(3, SHCNF_PATH | SHCNF_FLUSHNOWAIT));
		AssertNonZero(riParams.SetString(4, (const ICHAR*)strShortcutFullName));
		Message(imtCustomServiceToClient, riParams); // SHChangeNotify is of void type, so it's OK to ignore return
	}

	return piError;
}

/*---------------------------------------------------------------------------
ixfClassInfoRegister: Register OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegClassInfoRegister64(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegClassInfoRegister(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfClassInfoUnregister: Unregister OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegClassInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegClassInfoUnregister(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, fTrue, ibt32bit);
}


/*---------------------------------------------------------------------------
ProcessClassInfo: common routine to Process OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessClassInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	using namespace IxoRegClassInfoRegister;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = FileName
	// 4 = CLSID
	// 5 = ProgId
	// 6 = VIProgId
	// 7 = Description
	// 8 = Context
	// 9 = Insertable
	//10 = Appid
	//11 = FileTypeMask
	//12 = IconName
	//13 = IconIndex
	//14 = DefInprocHandler
	//15 = Arguments
	//16 = AssemblyName
	//17 = AssemblyType

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CLASSINFO)) // do we write/delete the registry with COM Class stuff
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	// the registry structure
	MsiString strClsId   = riParams.GetMsiString(ClsId);//!! assume they come enclosed in the curly brackets
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strClsId));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	enum clsDefProc{
		clsDefProc16=1,
		clsDefProc32=2,
	};
	MsiString strProgId  = riParams.GetMsiString(ProgId);
	MsiString strVIProgId= riParams.GetMsiString(VIProgId);
	MsiString strDesc    = riParams.GetMsiString(Description);
	MsiString strContext = riParams.GetMsiString(Context);
	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	MsiString strDefInprocHandler16;
	MsiString strDefInprocHandler32;
	if(!riParams.IsNull(DefInprocHandler))
	{
		int iDefInprocHandler = riParams.GetInteger(DefInprocHandler);
		if(iDefInprocHandler != iMsiStringBadInteger)
		{
			if(iDefInprocHandler & clsDefProc16)
				strDefInprocHandler16 = TEXT("ole2.dll");
			if(iDefInprocHandler & clsDefProc32)
				strDefInprocHandler32 = TEXT("ole32.dll");
		}
		else
			strDefInprocHandler32 = riParams.GetMsiString(DefInprocHandler);
	}
	MsiString strArgs = riParams.GetMsiString(Argument);

	MsiString strAssembly = riParams.GetMsiString(AssemblyName);
	MsiString strCodebase;
	MsiString strServerDarwinDescriptor;
	if(IsDarwinDescriptorSupported(iddOLE))
	{
		strServerDarwinDescriptor = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
															*MsiString(riParams.GetMsiString(Component)), 
															strAssembly.TextSize() ? true: false);

	}


	MsiString strServerFile = riParams.GetMsiString(FileName);
	MsiString strDefault;

	//!! we never remove registration for "filename only" registrations
	//!! the "filename only" registrations allow sharing of com registration
	//!! such that each app has its own private copy of the server
	//!! fusion specs recommend that the registration itself be refcounted
	//!! so that we know when to remove it. this has been punted for 1.1
	if(fRemove)
	{
		PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hOLEKey, iType);       //--merced: changed (int) to (INT_PTR)
		ICHAR szRegData[255];
		StringCchPrintf(szRegData, (sizeof(szRegData)/sizeof(ICHAR)), TEXT("CLSID\\%s\\%s"), (const ICHAR*)strClsId, (const ICHAR*)strContext);
		PMsiRegKey pClassKey = &pRootKey->CreateChild(szRegData);
		pClassKey->GetValue(g_szDefaultValue, *&strDefault);
		if(strDefault.TextSize())
		{
			if(strContext.Compare(iscStartI, TEXT("LocalServer"))) // remove args if localserver*, this has to be a short path
			{
				strDefault.Remove(iseFrom, ' ');
			}
		}
		if(ENG::PathType(strDefault) != iptFull)
			strServerFile = g_MsiStringNull;
	}

	if(!strServerDarwinDescriptor.TextSize() && !strServerFile.TextSize())
		return iesSuccess; // would happen during advertisement on a non-dd supported system

	if(strServerFile.TextSize())
	{
		if(ENG::PathType(strServerFile) == iptFull && !strContext.Compare(iscStartI, TEXT("InProcServer")))
		{
			// we always use short file names for OLE servers other than inprocservers
			CTempBuffer<ICHAR,MAX_PATH> rgchSFN;
			DWORD dwSize = 0;
			int cchFile = 0;

			if(ConvertPathName(strServerFile,rgchSFN, cpToShort) != fFalse)
			{
				// success, use short file name in place of long
				strServerFile = (const ICHAR*)rgchSFN;
			}
		}

		// is this com classic to urt assembly interop?
		if(strAssembly.TextSize())
		{
			if(riParams.GetInteger(AssemblyType) == (int)iatURTAssemblyPvt)
				strCodebase = strServerFile; // for privately installed assemblies, set codebase to installed assembly location
			// the server is always <system32folder>\mscoree.dll
			CTempBuffer<ICHAR,1> rgchFullPath(MAX_PATH+1);
			AssertNonZero(::GetCOMPlusInteropDll(rgchFullPath, rgchFullPath.GetSize()));
			strServerFile = static_cast<ICHAR*>(rgchFullPath);
		}
	}
	if(strArgs.TextSize())
	{
		if(strServerDarwinDescriptor.TextSize())
		{
			strServerDarwinDescriptor += TEXT(" ");
			strServerDarwinDescriptor += strArgs;
		}
		if(strServerFile.TextSize())
		{
			strServerFile += TEXT(" ");
			strServerFile += strArgs;
		}
	}
	ICHAR* pszInsert=TEXT("");    // ugly, but this will prevent the key from being generated
	ICHAR* pszNotInsert=TEXT(""); // ugly, but this will prevent the key from being generated

	if(!riParams.IsNull(Insertable))
	{
		if(!riParams.GetInteger(Insertable))
			pszNotInsert = 0;
		else
			pszInsert = 0;
	}
	MsiString strAppId   = riParams.GetMsiString(AppID);
	MsiString strIconName;
	bool fExpandIconName = false;
	if(!riParams.IsNull(Icon)) //!! check for full path
	{
		MsiString strIconPath = m_pCachePath->GetPath();
		strIconName = strIconPath + MsiString(riParams.GetMsiString(Icon));
		strIconName = GetUserProfileEnvPath(*strIconName, fExpandIconName);
		strIconName += TEXT(",");
		if(riParams.IsNull(IconIndex))
			strIconName += MsiString((int)0);
		else
			strIconName += MsiString(riParams.GetInteger(IconIndex));
	}

	iesEnum iesRet = iesNoAction;

	const ICHAR* rgszRegData[] = {
		TEXT("CLSID\\%s\\%s"), strClsId,strContext,0,
		g_szDefaultValue,     strServerFile,             g_szTypeString,
		strContext,           strServerDarwinDescriptor, g_szTypeMultiSzStringDD,
		0,
		TEXT("CLSID\\%s\\%s"), strClsId,strContext,0,
		g_szAssembly,         strAssembly,               g_szTypeString,
		g_szCodebase,         strCodebase,               g_szTypeString,
		0,
		TEXT("CLSID\\%s"), strClsId,0,0,
		g_szDefaultValue,     strDesc,                   g_szTypeString,
		TEXT("AppID"),        strAppId,                  g_szTypeString,
		0,
		TEXT("CLSID\\%s\\ProgID"), strClsId,0,0,
		g_szDefaultValue,     strProgId,                 g_szTypeString,
		0,
		TEXT("CLSID\\%s\\VersionIndependentProgID"), strClsId,0,0,
		g_szDefaultValue,     strVIProgId,               g_szTypeString,
		0,
		TEXT("CLSID\\%s\\DefaultIcon"), strClsId,0,0,
		g_szDefaultValue,     strIconName,               (fExpandIconName) ? g_szTypeExpandString : g_szTypeString,
		0,
		TEXT("CLSID\\%s\\Insertable"), strClsId,0,0,
		g_szDefaultValue,     pszInsert,                 g_szTypeString,// note that when pszInsert = 0 it creates the key, otherwise if *pszInsert = 0 it skips it
		0,
		TEXT("CLSID\\%s\\NotInsertable"), strClsId,0,0,
		g_szDefaultValue,     pszNotInsert,              g_szTypeString,// note that when pszNotInsert = 0 it creates the key, otherwise if *pszNotInsert = 0 it skips it
		0,
		TEXT("CLSID\\%s\\InprocHandler32"),strClsId,0,0,
		g_szDefaultValue,     strDefInprocHandler32,     g_szTypeString,
		0,
		TEXT("CLSID\\%s\\InprocHandler"),strClsId,0,0,
		g_szDefaultValue,     strDefInprocHandler16,     g_szTypeString,
		0,
		0,
	};

	bool fAbortedDeletion = false;
	if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, &fAbortedDeletion, iType)) != iesSuccess)
		return iesRet;

	// if we removed both the default value as well as the multi_sz, delete the entire class key
	if(fRemove && !fAbortedDeletion && IsDarwinDescriptorSupported(iddOLE))
	{
		const ICHAR* rgSubKeys[] = { TEXT("CLSID\\%s"), strClsId,
									 TEXT("APPID\\%s"), strAppId,
									 0,
		}; // clean up the clsid and appid keys
		if((iesRet = RemoveRegKeys(rgSubKeys, hOLEKey, iType)) != iesSuccess)
			return iesRet;
	}

	const unsigned int iMaskDelimiter = ';';
	if(!riParams.IsNull(FileTypeMask))
	{
		// prepare a loop for the FileTypeMask
		MsiString strCombinedMask = riParams.GetMsiString(FileTypeMask);
		MsiString strFileMask;
		MsiString strCount = 0;
		do{
			strFileMask = strCombinedMask.Extract(iseUpto, iMaskDelimiter);
			const ICHAR* rgszRegData1[] = {
				TEXT("FileType\\%s\\%s"), strClsId, strCount,0,
				g_szDefaultValue,     strFileMask,      g_szTypeString,
				0,
				0,
			};
		if((iesRet = ProcessRegInfo(rgszRegData1, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
			return iesRet;

			strCount = (int)strCount + 1;           
		}while(strCombinedMask.Remove(iseIncluding, iMaskDelimiter));
	}
	return iesSuccess;
}


/*---------------------------------------------------------------------------
ixfRegProgIdInfoRegister: Register OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegProgIdInfoRegister64(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegProgIdInfoRegister(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfRegProgIdInfoRegister: Register OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegProgIdInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegProgIdInfoUnregister(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, fTrue, ibt32bit);
}

iesEnum CMsiOpExecute::ProcessProgIdInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	using namespace IxoRegProgIdInfoRegister;
	// Record description
	// 1 = ProgId
	// 2 = CLSID
	// 3 = Extension
	// 4 = Description
	// 5 = Icon
	// 6 = IconIndex
	// 7 = VIProgId
	// 8 = VIProgIdDescription
	// 9 = Insertable

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	// the registry structure
	MsiString strProgId = riParams.GetMsiString(ProgId);
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProgId));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	MsiString strClsId   = riParams.GetMsiString(ClsId);//!! assume they come enclosed in the curly brackets

	MsiString strDesc    = riParams.GetMsiString(Description);
	MsiString strIconName;
	bool fExpandIconName = false;
	if(!riParams.IsNull(Icon)) //!! check for full path
	{
		MsiString strIconPath = m_pCachePath->GetPath();
		strIconName = strIconPath + MsiString(riParams.GetMsiString(Icon));
		strIconName = GetUserProfileEnvPath(*strIconName, fExpandIconName);
		strIconName += TEXT(",");
		if(riParams.IsNull(IconIndex))
			strIconName += MsiString((int)0);
		else
			strIconName += MsiString(riParams.GetInteger(IconIndex));
	}

	MsiString strVIProgId= riParams.GetMsiString(VIProgId);
	MsiString strVIProgIdDescription= riParams.GetMsiString(VIProgIdDescription);

	ICHAR* pszInsert=TEXT("");    // ugly, but this will prevent the key from being generated
	ICHAR* pszNotInsert=TEXT(""); // ugly, but this will prevent the key from being generated

	if(!riParams.IsNull(Insertable))
	{
		if(!riParams.GetInteger(Insertable))
			pszNotInsert = 0;
		else
			pszInsert = 0;
	}

	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	MsiString strProgIdSubKey = strProgId;
	strProgIdSubKey += szRegSep;
	strProgIdSubKey += TEXT("Shell");

	// we add/ remove the information only if the extension and clsid keys have been corr. added/ removed
	// this implies that the class and extension information should be processed before
	// the info under consideration

	MsiString strClsIdSubKey;
	if (strClsId.TextSize())
	{
		strClsIdSubKey = TEXT("CLSID");
		strClsIdSubKey += szRegSep;
		strClsIdSubKey += strClsId;
		strClsIdSubKey += szRegSep;
		strClsIdSubKey += TEXT("ProgID");
	}

	const ICHAR* rgszRegKeys1[] = {
			strProgIdSubKey,
			0,
		};

	const ICHAR* rgszRegKeys2[] = {
			strClsIdSubKey,
			0,
		};

	Bool fExistsClassInfo = fFalse;
	Bool fExistsExtensionInfo = fFalse;

	PMsiRecord pError = LinkedRegInfoExists(rgszRegKeys1, fExistsExtensionInfo, iType);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	pError = LinkedRegInfoExists(rgszRegKeys2, fExistsClassInfo, iType);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}


	iesEnum iesRet = iesSuccess;
	if(fRemove && !fExistsClassInfo && !fExistsExtensionInfo)
	{
		// clear out the entire progid and viprogid keys in case we have any install time remnants underneath the key
		// we can do this when we know that both class and extension info has been removed
		const ICHAR* rgSubKeys[] = { TEXT("%s"), strProgId,
									 TEXT("%s"), strVIProgId,
									 0,
		}; // clean up the progid and viprogid subkeys

		if((iesRet = RemoveRegKeys(rgSubKeys, hOLEKey, iType)) != iesSuccess)
			return iesRet;
	}
	else
	{
		if(fExistsClassInfo^fRemove)
		{
			// pair the progid info with the class info
			const ICHAR* rgszRegData[] = {
				TEXT("%s\\CLSID"), strProgId,0,0,
				g_szDefaultValue,     strClsId,               g_szTypeString,
				0,
				TEXT("%s"), strVIProgId,0,0,
				g_szDefaultValue,     strVIProgIdDescription, g_szTypeString,
				0,
				TEXT("%s\\CLSID"), strVIProgId,0,0,
				g_szDefaultValue,     strClsId,               g_szTypeString,
				0,
				TEXT("%s\\CurVer"), strVIProgId,0,0,
				g_szDefaultValue,     strProgId,              g_szTypeString,
				0,
				TEXT("%s\\Insertable"), strProgId,0,0,
				g_szDefaultValue,     pszInsert,              g_szTypeString,// note that when pszInsert = 0 it creates the key, otherwise if *pszInsert = 0 it skips it
				0,
				TEXT("%s\\NotInsertable"), strProgId,0,0,
				g_szDefaultValue,     pszNotInsert,           g_szTypeString,// note that when pszNotInsert = 0 it creates the key, otherwise if *pszNotInsert = 0 it skips it
				0,
				0,
			};

			if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
				return iesRet;
		}
		if((fExistsClassInfo | fExistsExtensionInfo)^fRemove)
		{
			// pair the progid info with both class and extension info
			const ICHAR* rgszRegData[] = {
				TEXT("%s"), strProgId,0,0,
				g_szDefaultValue,     strDesc,                g_szTypeString,
				0,
				TEXT("%s\\DefaultIcon"), strProgId,0,0,
				g_szDefaultValue,     strIconName,            (fExpandIconName) ? g_szTypeExpandString : g_szTypeString,
				0,
				0,
			};

			if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
				return iesRet;
		}
	}
	return iesRet;
}

/*---------------------------------------------------------------------------
ixfMIMEInfoRegister: register MIME registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegMIMEInfoRegister64(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegMIMEInfoRegister(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfMIMEInfoUnregister: unregister MIME registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegMIMEInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegMIMEInfoUnregister(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, fTrue, ibt32bit);
}

/*---------------------------------------------------------------------------
ProcessMIMEInfo: common routine to process MIME registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessMIMEInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	using namespace IxoRegMIMEInfoRegister;
	// Record description
	// 1 = ContentType
	// 2 = Extension
	// 3 = CLSID

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	MsiString strContentType = riParams.GetMsiString(ContentType);
	MsiString strExtension = MsiString(MsiChar('.')) + MsiString(riParams.GetMsiString(Extension));
	MsiString strClassId = riParams.GetMsiString(ClsId);
	
	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strContentType));
	AssertNonZero(riActionData.SetMsiString(2, *strExtension));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);

	// we add/ remove the information only if the extension and clsid keys have been removed
	// this implies that the class and extension information should be processed before
	// the info under consideration
	{
		MsiString strClsIdSubKey;
		if (strClassId.TextSize())
		{
			strClsIdSubKey = TEXT("CLSID");
			strClsIdSubKey += szRegSep;
			strClsIdSubKey += strClassId;
		}
		const ICHAR* rgszRegKeys[] = {
			strExtension,
			strClsIdSubKey,
			0,
		};
		Bool fExists = fFalse;
		PMsiRecord pError = LinkedRegInfoExists(rgszRegKeys, fExists, iType);
		if(pError)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		if(!(fExists^fRemove))
			// pair the progid info with the class/ extension info
			return iesSuccess;
	}

	if(fRemove)
	{
		iesEnum iesRet = iesSuccess;
		// clear out the entire Contenttype key in case we have any install time remnants underneath the key
		// we can do this when we know that both class and extension info has been removed

		const ICHAR* rgSubKeys[] = { TEXT("MIME\\Database\\Content Type\\%s"), strContentType,
									 0,
		}; // clean up the content type

		return RemoveRegKeys(rgSubKeys, hOLEKey, iType);
	}
	else
	{
		//?? can Extension be null
		const ICHAR* rgszRegData[] = {
			TEXT("MIME\\Database\\Content Type\\%s"), strContentType,0,0,
			g_szDefaultValue,       0,              g_szTypeString,// force the key creation
			g_szExtension,          strExtension,   g_szTypeString,
			g_szClassID,            strClassId,     g_szTypeString,
			0,
			0,
		};
		return ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType);
	}
}

/*---------------------------------------------------------------------------
ixfExtensionInfoRegister: register Extension registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegExtensionInfoRegister64(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegExtensionInfoRegister(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfExtensionInfoUnregister: unregister Extension registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegExtensionInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegExtensionInfoUnregister(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, fTrue, ibt32bit);
}

/*---------------------------------------------------------------------------
ProcessExtensionInfo: common routine to process extension info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessExtensionInfo(IMsiRecord& riParams, Bool fRemove,
														  const ibtBinaryType iType)
{
	using namespace IxoRegExtensionInfoRegister;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = FileName
	// 4 = Extension
	// 5 = ProgId
	// 6 = ShellNew
	// 7 = ShellNewValue
	// 8 = ContentType
	// 9 = Order
	//10 = Verb1
	//11 = Command1
	//12 = Arguments1
	//13 = Verb2
	//14 = Command2
	//15 = Arguments2
	// ...
	// ...

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_EXTENSIONINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	MsiString strExtension = MsiString(MsiChar('.')) + MsiString(riParams.GetMsiString(Extension));

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strExtension));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	m_fShellRefresh = fTrue; // signal shell refresh at the end of the install

	MsiString strProgId = riParams.GetMsiString(ProgId);
	MsiString strShellNewValueName = riParams.GetMsiString(ShellNew);
	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	const ICHAR* szShellNewValue = riParams.IsNull(ShellNewValue) ? 0 : riParams.GetString(ShellNewValue);
	MsiString strVerb;
	MsiString strCommand;
	MsiString strArgs;
	MsiString strServerDarwinDescriptor;

	if(IsDarwinDescriptorSupported(iddShell))
	{
		strServerDarwinDescriptor = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
															*MsiString(riParams.GetMsiString(Component)));
	}

	MsiString strServerFile = riParams.GetMsiString(FileName);

	if(!strServerDarwinDescriptor.TextSize() && !strServerFile.TextSize())
		return iesSuccess; // would happen during advertisement on a non-dd supported system

	if(strServerFile.TextSize())
	{
		MsiString strQuotes = *TEXT("\"");
		strServerFile = MsiString(strQuotes + strServerFile) + strQuotes;
	}

	MsiString strServerDarwinDescriptorArgs;
	MsiString strServerFileArgs;

	iesEnum iesRet = iesNoAction;
	const ICHAR** rgszRegData;

	int cPos = Args + 1;

	#define NUM_VERB_FIELDS 3
	// the verb information is in triplets of verb+command+argument
	// however the argument or the command+argument fields could be null
	// hence to figure out how many verbs we have we use -
	// (riParams.GetFieldCount() - Args + NUM_VERB_FIELDS - 1)/NUM_VERB_FIELDS
	int iNotOrder = (riParams.GetFieldCount() - Args + NUM_VERB_FIELDS - 1)/NUM_VERB_FIELDS - (riParams.IsNull(Order) ? 0 : riParams.GetInteger(Order));
	MsiString strOrder; // ordering
	while(!(riParams.IsNull(cPos)))
	{
		// need to read the value afresh each time
		strServerDarwinDescriptorArgs = strServerDarwinDescriptor;
		strServerFileArgs = strServerFile;
		strVerb = riParams.GetMsiString(cPos++);
		strCommand = riParams.GetMsiString(cPos++);
		strArgs = riParams.GetMsiString(cPos++);

		if(strArgs.TextSize())
		{
			if(strServerDarwinDescriptorArgs.TextSize())
			{
				strServerDarwinDescriptorArgs += TEXT(" ");
				strServerDarwinDescriptorArgs += strArgs;
			}
			if(strServerFileArgs.TextSize())
			{
				strServerFileArgs += TEXT(" ");
				strServerFileArgs += strArgs;
			}
		}

		MsiString strDefault;
		//!! we never remove registration for "filename only" registrations
		//!! the "filename only" registrations allow sharing of com registration
		//!! such that each app has its own private copy of the server
		//!! fusion specs recommend that the registration itself be refcounted
		//!! so that we know when to remove it. this has been punted for 1.1
		if(fRemove)
		{
			PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hOLEKey, iType);       //--merced: changed (int) to (INT_PTR)
			ICHAR szRegData[255];
			if(strProgId.TextSize())
				StringCbPrintf(szRegData, sizeof(szRegData), TEXT("%s\\shell\\%s\\command"), (const ICHAR*)strProgId, (const ICHAR*)strVerb);
			else
				StringCbPrintf(szRegData, sizeof(szRegData), TEXT("%s\\shell\\%s\\command"), (const ICHAR*)strExtension, (const ICHAR*)strVerb);

			PMsiRegKey pClassKey = &pRootKey->CreateChild(szRegData);
			pClassKey->GetValue(g_szDefaultValue, *&strDefault);
			if(strDefault.TextSize())
			{
				// remove args and quotes
				if(*(const ICHAR*)strDefault == '\"')
				{
					// quoted server file name
					strDefault.Remove(iseFirst, 1);
					strDefault = strDefault.Extract(iseUpto, '\"');
				}
				else
				{
					strDefault.Remove(iseFrom, ' ');
				}
				if(ENG::PathType(strDefault) != iptFull)
					strServerFileArgs = g_MsiStringNull;
			}
		}

		if(!strServerDarwinDescriptorArgs.TextSize() && !strServerFileArgs.TextSize())
			continue; // would happen during advertisement on a non-dd supported system

		const ICHAR* rgszRegData1WithProgId[] = {
				TEXT("%s\\shell\\%s\\command"), strProgId, strVerb,0,
				g_szDefaultValue,      strServerFileArgs,             g_szTypeString,
				TEXT("command"),       strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
				0,
				TEXT("%s\\shell\\%s"), strProgId, strVerb,0,
				g_szDefaultValue,      strCommand,                    g_szTypeString,
				0,
				0,
		};

		const ICHAR* rgszRegData1WOProgId[] = {
				TEXT("%s\\shell\\%s\\command"), strExtension, strVerb,0,
				g_szDefaultValue,      strServerFileArgs,             g_szTypeString,
				TEXT("command"),       strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
				0,
				TEXT("%s\\shell\\%s"), strExtension, strVerb,0,
				g_szDefaultValue,      strCommand,                    g_szTypeString,
				0,
				0,
		};
		if(strProgId.TextSize())
			rgszRegData = rgszRegData1WithProgId;
		else
			rgszRegData = rgszRegData1WOProgId;

		if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
			return iesRet;      

		if(iNotOrder)
			iNotOrder--;
		else
		{
			if(strOrder.TextSize())
				strOrder += TEXT(",");
			strOrder += strVerb;
		}

	}
	if(strOrder.TextSize())
	{
		const ICHAR* rgszRegData2WithProgId[] = {
				TEXT("%s\\shell"), strProgId,0,0,
				g_szDefaultValue,        strOrder,        g_szTypeString,
				0,
				0,
		};

		const ICHAR* rgszRegData2WOProgId[] = {
				TEXT("%s\\shell"), strExtension,0,0,
				g_szDefaultValue,        strOrder,        g_szTypeString,
				0,
				0,
		};
		if(strProgId.TextSize())
			rgszRegData = rgszRegData2WithProgId;
		else
			rgszRegData = rgszRegData2WOProgId;

		if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
			return iesRet;
	}

	// we include the darwin descriptor we may have written in the verb loop above in order to
	// conditionalize the removal of the below information only if when the last darwin
	// descriptor is removed.
	// if there are no verbs then we cannot share (as there are no Darwin Descriptors to manage
	// the sharing), and hence we remove the info.

	MsiString strContentType = riParams.GetMsiString(ContentType);

	const ICHAR* rgszRegDataWithProgId[] = {
			TEXT("%s\\shell\\%s\\command"), strProgId, strVerb,0,
			TEXT("command"),       strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
			0,
			TEXT("%s\\%s\\ShellNew"), strExtension, strProgId,0,
			strShellNewValueName,     szShellNewValue,              g_szTypeString,
			0,
			TEXT("%s"), strExtension, 0,0,
			g_szContentType,          strContentType, g_szTypeString,
			0,
			0,
		};

	const ICHAR* rgszRegDataWOProgId[] = {
			TEXT("%s\\shell\\%s\\command"), strExtension, strVerb,0,
			TEXT("command"),          strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
			0,
			TEXT("%s\\ShellNew"),     strExtension, 0,0,
			strShellNewValueName,     szShellNewValue,              g_szTypeString,
			0,
			TEXT("%s"), strExtension, 0,0,
			g_szContentType,          strContentType, g_szTypeString,
			0,
			0,
		};



	if(strProgId.TextSize())
		rgszRegData = rgszRegDataWithProgId;
	else
		rgszRegData = rgszRegDataWOProgId;

	if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
		return iesRet;

	if(strProgId.TextSize())
	{
		if(fRemove)
		{
			// if Shell still exists, we should not be deleting
			// the extension

			MsiString strShell = strProgId;
			strShell += szRegSep;
			strShell += TEXT("Shell");

			const ICHAR* rgszRegKeys[] = {
				strShell,
				0,
			};

			Bool fExists = fFalse;
			PMsiRecord pError = LinkedRegInfoExists(rgszRegKeys, fExists, iType);
			if(pError)
			{
				Message(imtError, *pError);
				return iesFailure;
			}
			if(fExists)
				return iesSuccess;

			const ICHAR* rgSubKeys[] = { TEXT("%s"), strExtension,
										 0,
			}; // clean up the extension key

			if((iesRet = RemoveRegKeys(rgSubKeys, hOLEKey, iType)) != iesSuccess)
				return iesRet;
		}
		else
		{
			// write/ remove the progid
			const ICHAR* rgszRegData[] = {
			TEXT("%s"), strExtension, 0, 0,
				g_szDefaultValue,         strProgId,                     g_szTypeString,
				0,
				0,
			};
			if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
				return iesRet;
		}
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfTypeLibraryRegister: type library info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfTypeLibraryRegister(IMsiRecord& riParams)
{
	using namespace IxoTypeLibraryRegister;
	PMsiRecord pError(0);

	// determine if the target file was previously copied to a temporary location
	MsiString strTemp = riParams.GetMsiString(FilePath);

	MsiString strTempLocation;
	icfsEnum icfsFileState = (icfsEnum)0;
	Bool fRes = GetFileState(*strTemp, &icfsFileState, &strTempLocation, 0, 0);

	if((icfsFileState & icfsFileNotInstalled) != 0)
	{
		// didn't actually install this file, so we assume it has already been registered
		return iesNoAction;
	}

	return ProcessTypeLibraryInfo(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfTypeLibraryUnregister: unregisters a type library with the system
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfTypeLibraryUnregister(IMsiRecord& riParams)
{
	return ProcessTypeLibraryInfo(riParams, fTrue);
}

CMsiCustomActionManager *GetCustomActionManager(const ibtBinaryType iType, bool fRemoteIfImpersonating, bool& fSuccess);

/*---------------------------------------------------------------------------
ProcessTypeLibraryInfo: common routine to process type library info
---------------------------------------------------------------------------*/
#pragma warning(disable : 4706) // assignment within comparison
iesEnum CMsiOpExecute::ProcessTypeLibraryInfo(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoTypeLibraryRegister;
	// Record description
	// 1 = LibID
	// 2 = Version
	// 3 = Description
	// 4 = Language
	// 5 = Darwin Descriptor
	// 6 = Help Path
	// 7 = Full File Path
	// 8 = Binary Type

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;
	
	iesEnum iesRet = iesSuccess;
	MsiString strLibID = riParams.GetMsiString(LibID);

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strLibID));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	unsigned uiVersion = riParams.GetInteger(Version);
	unsigned short usMajorVersion = (unsigned short)((uiVersion & 0xFFFF00) >> 8);
	unsigned short usMinorVersion = (unsigned short)(uiVersion & 0xFF);
	ICHAR rgchTemp[20];
	StringCbPrintf(rgchTemp,sizeof(rgchTemp),TEXT("%x.%x"),usMajorVersion,usMinorVersion);
	MsiString strVersion = rgchTemp;
	LCID lcidLocale = MAKELCID(MsiString(riParams.GetMsiString(Language)), SORT_DEFAULT);
	StringCbPrintf(rgchTemp, sizeof(rgchTemp), TEXT("%x"), lcidLocale);
	MsiString strLocale = rgchTemp;
	MsiString strHelpPath = riParams.GetMsiString(HelpPath);
	MsiString strServerFile = riParams.GetMsiString(FilePath);
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, false /*fRemoteIfImpersonating*/, fSuccess);
	if ( !fSuccess )
		return iesFailure;

	if(fRemove == fFalse && strServerFile.TextSize())
	{
		// check if the type lib is currently registered
		IID iidLib;
	
		if( OLE32::IIDFromString(const_cast<WCHAR*>((const WCHAR*)CConvertString(strLibID)), &iidLib) == S_OK )
		{
			OLECHAR rgchTypeLibPath[MAX_PATH] = {0};
			HRESULT hRes = S_OK;
			if ( pManager )
				hRes = pManager->QueryPathOfRegTypeLib(iidLib,usMajorVersion,usMinorVersion,lcidLocale,rgchTypeLibPath,MAX_PATH-1);
			else
			{
				BSTR bstrTypeLibPath = OLEAUT32::SysAllocStringLen(NULL, MAX_PATH-1);
				hRes = OLEAUT32::QueryPathOfRegTypeLib(iidLib,usMajorVersion,usMinorVersion,lcidLocale,&bstrTypeLibPath);
				if ( hRes == S_OK )
					StringCbCopyW(rgchTypeLibPath, sizeof(rgchTypeLibPath), bstrTypeLibPath);
				OLEAUT32::SysFreeString(bstrTypeLibPath);
			}
			DEBUGMSG3(TEXT("QueryPathOfRegTypeLib returned %d in %s context.  Path is '%s'"), (const ICHAR*)(INT_PTR)hRes,
						 pManager ? TEXT("remote") : TEXT("local"), CConvertString(rgchTypeLibPath));
			if ( hRes == S_OK)
			{
				PMsiRecord pUnregTypeLibParams = &m_riServices.CreateRecord(Args);
				AssertNonZero(pUnregTypeLibParams->SetString(FilePath,CConvertString(rgchTypeLibPath)));
				AssertNonZero(pUnregTypeLibParams->SetInteger(Version,uiVersion));
				AssertNonZero(pUnregTypeLibParams->SetMsiString(LibID,*strLibID));
				AssertNonZero(pUnregTypeLibParams->SetMsiString(Language, *MsiString(riParams.GetMsiString(Language))));
				AssertNonZero(pUnregTypeLibParams->SetInteger(BinaryType,iType));

				// get help path
				PMsiRegKey pHKCR = &m_riServices.GetRootKey(rrkClassesRoot, iType);
				MsiString strTypeLibVersionSubKey = TEXT("TypeLib");
				strTypeLibVersionSubKey += szRegSep;
				strTypeLibVersionSubKey += strLibID;
				strTypeLibVersionSubKey += szRegSep;
				strTypeLibVersionSubKey += strVersion;
				MsiString strValue;
				PMsiRegKey pTypeLibVersionKey = &pHKCR->CreateChild(strTypeLibVersionSubKey);
				PMsiRecord pError(0);
				PMsiRegKey pTypeLibHelpKey = &pTypeLibVersionKey->CreateChild(TEXT("HELPDIR"));
				if((pError = pTypeLibHelpKey->GetValue(0,*&strValue)) == 0)
					AssertNonZero(pUnregTypeLibParams->SetString(HelpPath,strValue));
				if((iesRet = ProcessTypeLibraryInfo(*pUnregTypeLibParams,fTrue)) != iesSuccess)
					return iesRet; // rollback will be generated in the call
			}
		}
	}

	for(;;)// retry loop
	{
		if(fRemove)
		{
			// clean up old darwin descriptors
			const ICHAR* rgszRegData[] = {
				TEXT("TypeLib\\%s\\%s\\%s\\win32"), strLibID,strVersion,strLocale,
				TEXT("win32"), 0,       g_szTypeString, // darwin descriptor
				0,
				0,
			};

			iesRet = ProcessRegInfo(rgszRegData, g_fWinNT64 ? m_hOLEKey64 : m_hOLEKey, fRemove, 0, 0, iType);
			if(iesRet == iesSuccess && !strServerFile.TextSize()) // old advertise scripts that have type library registration
			{
				const ICHAR* rgszRegData[] = {
					TEXT("TypeLib\\%s\\%s"), strLibID,strVersion,0,
					g_szDefaultValue,    0,	       g_szTypeString, // description
					0,
					0,
				};
				iesRet = ProcessRegInfo(rgszRegData, g_fWinNT64 ? m_hOLEKey64 : m_hOLEKey, fRemove, 0, 0, iType);
			}
		}
		
		PMsiRecord pRecord(0);
		if(iesRet == iesSuccess && strServerFile.TextSize())
		{
			pRecord = fRemove ? m_riServices.UnregisterTypeLibrary(strLibID, lcidLocale, strServerFile, iType)
									: m_riServices.RegisterTypeLibrary(strLibID, lcidLocale, strServerFile, strHelpPath, iType);
			if(!pRecord)
			{
				IMsiRecord& riParams1 = GetSharedRecord(Args);
				AssertNonZero(riParams1.SetMsiString(LibID,*MsiString(riParams.GetMsiString(LibID))));
				AssertNonZero(riParams1.SetInteger(Version,riParams.GetInteger(Version)));
				AssertNonZero(riParams1.SetMsiString(Language,*MsiString(riParams.GetMsiString(Language))));
				AssertNonZero(riParams1.SetMsiString(HelpPath,*MsiString(riParams.GetMsiString(HelpPath))));
				AssertNonZero(riParams1.SetInteger(BinaryType,iType));

				// generate undo op to re-register or unregister this type lib
				AssertNonZero(riParams1.SetMsiString(FilePath,*MsiString(riParams.GetMsiString(FilePath))));
				if(fRemove)
				{
					if (!RollbackRecord(ixoTypeLibraryRegister,riParams1))
						return iesFailure;
				}
				else
				{
					if (!RollbackRecord(ixoTypeLibraryUnregister,riParams1))
						return iesFailure;
				}
			}
		}
		if(iesRet != iesSuccess || pRecord)
		{
			// if we failed unregistering a type lib that wasn't registered, only give info message
			if(fRemove)
			{
				DispatchError(imtInfo,Imsg(imsgOpUnregisterTypeLibrary),
								  *strServerFile);
			}
			else
			{
				switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1),
					Imsg(imsgOpRegisterTypeLibrary),
					*strServerFile))
				{
				case imsRetry:  continue;
				case imsIgnore: break;
				default:        return iesFailure;  // imsAbort or imsNone
				};
			}
		}
		break; // out of the for loop
	}
	return iesSuccess;
}
#pragma warning(default : 4706)

iesEnum CMsiOpExecute::ProcessRegInfo(const ICHAR** pszData, HKEY hkey, Bool fRemove, IMsiStream* pSecurityDescriptor, bool* pfAbortedRemoval, ibtBinaryType iType/*=ibtUndefined*/)
// NOTE: We do not restore the m_state regkey set by IxoRegOpenKey. It may be changed by this function.
{
	if(pfAbortedRemoval)
		*pfAbortedRemoval = false; // set to true if we encounter a DD list that is not empty OR the default value is not empty
	const ICHAR** pszDataIn = pszData;
	iesEnum iesRet = iesSuccess;
	if ( iType == ibtUndefined )
		iType = ibt32bit;
	else if ( iType == ibtCommon )
		iType = g_fWinNT64 ? ibt64bit : ibt32bit;

	m_cSuppressProgress++; // suppress progress from ixfReg* functions

	ICHAR szRegData[255];
	// write directly to the registry
	const ICHAR* pszTemplate = NULL;
	
	PMsiRecord pParams0 = &m_riServices.CreateRecord(0); // pass to ixfRegCreateKey
	PMsiRecord pParams2 = &m_riServices.CreateRecord(2); // pass to ixfRegAddValue, ixfRegRemoveValue
	PMsiRecord pParams3 = &m_riServices.CreateRecord(IxoRegOpenKey::Args); // pass to ixfRegOpenKey
#ifdef _WIN64   // !merced
	AssertNonZero(pParams3->SetHandle(IxoRegOpenKey::Root,(HANDLE)hkey));
#else
	AssertNonZero(pParams3->SetInteger(IxoRegOpenKey::Root,(int)hkey));
#endif
	AssertNonZero(pParams3->SetInteger(IxoRegOpenKey::BinaryType,(int)iType));
	if (pSecurityDescriptor)
		AssertNonZero(pParams3->SetMsiData(IxoRegOpenKey::SecurityDescriptor, pSecurityDescriptor));
	Bool fContinue = fTrue;

	CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE, pSecurityDescriptor != NULL);

	while(iesRet == iesSuccess && (pszTemplate = *pszData++) != 0 && fContinue)
	{
		// we assume atmost 3 arguments to the template
		// the strings structure needs to account for non-required arguments
		// by placing dumb strings there
		const ICHAR* pszArg1 = *pszData++;
		const ICHAR* pszArg2 = *pszData++;
		const ICHAR* pszArg3 = *pszData++;
		StringCchPrintf(szRegData, (sizeof(szRegData)/sizeof(ICHAR)), pszTemplate, pszArg1, pszArg2, pszArg3);
		AssertNonZero(pParams3->SetString(IxoRegOpenKey::Key,szRegData));
		if((iesRet = ixfRegOpenKey(*pParams3)) != iesSuccess)
			break;

		const ICHAR* pszName;
		while((pszName = *pszData++) != 0)
		{
			const ICHAR* pszValue = *pszData++;
			const ICHAR* pchType = *pszData++;
			// we skip everything if any of the passed in parameters for the key is empty (not 0 mind you)
			if((!pszArg1 || *pszArg1) && (!pszArg2 || *pszArg2) && (!pszArg3 || *pszArg3))
			{
				MsiString strValue = pszValue;

				if (pszValue)
				{
					switch(*pchType)
					{
					case g_chTypeString:
						if(strValue.TextSize() && *(const ICHAR* )strValue == '#')
							strValue = MsiString(*TEXT("#")) + strValue; // escape any "#" at beginning of string
						break;
					case g_chTypeInteger:
						strValue = MsiString(*TEXT("#")) + strValue;
						break;
					case g_chTypeIncInteger:
						if (strValue.Compare(iscExact,TEXT("0")))
							continue;
						else
							strValue = MsiString(*TEXT("#+")) + strValue;
						break;
					case g_chTypeExpandString:
						strValue = MsiString(*TEXT("#%")) + strValue;
						break;
					case g_chTypeMultiSzStringDD: // fall through
					case g_chTypeMultiSzStringPrefix:
						strValue = strValue + MsiString(MsiChar(0));
						break;
					case g_chTypeMultiSzStringSuffix:
						strValue = MsiString(MsiChar(0)) + strValue;
						break;
					default:
						Assert(0);
						break;
					}
				}

				// we skip the SetValue if the value to be set is empty
				// so if we wish to write the value it must be null or non-empty


				if(!pszValue || *pszValue)
				{
					if(fRemove == fFalse)
					{
						//?? to get over the problem of creating the default value with null
						if(pszValue || *pszName)
						{
							AssertNonZero(pParams2->SetString(IxoRegAddValue::Name,pszName));
							AssertNonZero(pParams2->SetMsiString(IxoRegAddValue::Value,*strValue));
							if((iesRet = ixfRegAddValue(*pParams2)) != iesSuccess)
								break;
						}
						else
						{
							if((iesRet = ixfRegCreateKey(*pParams0)) != iesSuccess)
								break;
						}
					}
					else
					{
						AssertNonZero(pParams2->SetString(IxoRegRemoveValue::Name,pszName));
						AssertNonZero(pParams2->SetMsiString(IxoRegRemoveValue::Value,*strValue));
						if((iesRet = ixfRegRemoveValue(*pParams2)) != iesSuccess)
							break;
					}
				}
				// we must skip the processing of the rest of the values in the structure
				// if we are of type Darwin Descriptor and we are in remove mode and
				// there still exist values in the registry
				if(fRemove == fTrue && *pchType == g_chTypeMultiSzStringDD)
				{
					// read the value
					PMsiRegKey pRegKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hkey, iType);      //--merced: changed (int) to (INT_PTR)
					pRegKey = &pRegKey->CreateChild(szRegData);

					// check the pszName as well as the default value
					for(int i = 2; i--;)
					{
						PMsiRecord pError = pRegKey->GetValue(i ? pszName : 0, *&strValue);
						if(pError)
							return FatalError(*pError);
						if(strValue.TextSize()) // value exists
						{
							if(pfAbortedRemoval)
								*pfAbortedRemoval = true;
							fContinue = fFalse;
							break;
						}
					}
				}
			}
		}
	}

	m_cSuppressProgress--;
	if(iesRet == iesSuccess && hkey == m_hKey && m_hKeyRm)  // duplicate action for user assigned apps in the non-assigned (roaming) hive
		iesRet = ProcessRegInfo(pszDataIn, m_hKeyRm, fRemove, pSecurityDescriptor, 0, ibtCommon);
	return iesRet;
}


const ICHAR* rgPredefined[] = { TEXT("APPID"),
								TEXT("CLSID"),
								TEXT("INTERFACE"),
								TEXT("MIME"),
								TEXT("TYPELIB"),
								TEXT("INSTALLER"),
								0,
}; // predefined keys that cannot be removed

iesEnum CMsiOpExecute::RemoveRegKeys(const ICHAR** pszData, HKEY hkey, ibtBinaryType iType)
// NOTE: We do not restore the m_state regkey set by IxoRegOpenKey. It may be changed by this function.
{
	// delete entire keys
	// passed in pairs of form format string (eg "CLSID\\%s") and arg (eg {guid})
	// the pairs end with a null string
	// note: if the arg is an empty string, we skip the key removal
	iesEnum iesRet = iesSuccess;

	m_cSuppressProgress++; // suppress progress from ixfReg* functions

	ICHAR szRegData[255];
	// write directly to the registry
	const ICHAR* pszTemplate;

	PMsiRecord pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);

#ifdef _WIN64   // !merced
	AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, (HANDLE)hkey));
#else
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, (int)hkey));
#endif      
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)iType));

	while(iesRet == iesSuccess && (pszTemplate = *pszData++) != 0)
	{
		Assert(*pszTemplate);
		// we assume 1 arg to the template
		const ICHAR* pszArg1 = *pszData++;
		// we skip removal if the passed in parameter for the key is empty
		if(pszArg1 && *pszArg1)
		{
			StringCchPrintf(szRegData, (sizeof(szRegData)/sizeof(ICHAR)), pszTemplate, pszArg1);

			// ensure that the keys are not one of the predefined keys
			const ICHAR**pszPredefined = rgPredefined;
			while(*pszPredefined)
				if(!IStrCompI(*pszPredefined++, szRegData))
					break;

			if(*pszPredefined)
				continue; // one of predefined keys, cannot remove
					
			AssertNonZero(pParams->SetString(IxoRegOpenKey::Key, szRegData));
			iesRet = ixfRegOpenKey(*pParams);
			if (iesRet == iesSuccess || iesRet == iesNoAction)
				iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		}
	}
	m_cSuppressProgress--;  
	return iesRet;
}


IMsiRecord* CMsiOpExecute::LinkedRegInfoExists(const ICHAR** rgszRegKeys, Bool& rfExists, const ibtBinaryType iType)
{
	rfExists = fFalse;

	const ICHAR* pszKey;
	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	while(!rfExists && ((pszKey = *rgszRegKeys++) != 0))
	{
		if(*pszKey) // will be empty string if entry not to be used, skip to next entry
		{
			IMsiRecord* piError;
			PMsiRegKey pKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hOLEKey, iType);           //--merced: changed (int) to (INT_PTR)
			pKey = &pKey->CreateChild(pszKey);
			if((piError = pKey->Exists(rfExists)) != 0)
				return piError;
		}
	}

	return 0;
}

void GetEnvironmentStrings(const ICHAR* sz,CTempBufferRef<ICHAR>& rgch)
{
	Assert(sz);
	DWORD dwSize = WIN::ExpandEnvironmentStrings(sz,(ICHAR*)rgch,rgch.GetSize());
	if(dwSize > rgch.GetSize())
	{
		// try again with the correct size
		rgch.SetSize(dwSize);
		dwSize = WIN::ExpandEnvironmentStrings(sz,(ICHAR*)rgch, dwSize);
	}
	Assert(dwSize && dwSize <= rgch.GetSize());
}

void GetEnvironmentVariable(const ICHAR* sz,CAPITempBufferRef<ICHAR>& rgch)
{
	Assert(sz);
	DWORD dwSize = WIN::GetEnvironmentVariable(sz,(ICHAR*)rgch,rgch.GetSize());
	if(dwSize > rgch.GetSize())
	{
		// try again with the correct size
		rgch.SetSize(dwSize);
		if ( ! (ICHAR *) rgch )
		{
			rgch.SetSize(1);
			((ICHAR *)rgch)[0] = 0;
			return;
		}

		dwSize = WIN::GetEnvironmentVariable(sz,(ICHAR*)rgch, dwSize);
	}
	Assert(dwSize == 0 || dwSize <= rgch.GetSize());
}
	
IMsiRecord* CMsiOpExecute::GetSecureSecurityDescriptor(IMsiStream*& rpiStream, bool fHidden)
{
	return ::GetSecureSecurityDescriptor(m_riServices, rpiStream, fHidden);
}

IMsiRecord* GetSecureSecurityDescriptor(IMsiServices& riServices, IMsiStream*& rpiStream, bool fHidden)
{
	if (RunningAsLocalSystem())
	{
		DWORD dwError = 0;
		char* rgchSD;
		if (ERROR_SUCCESS != (dwError = ::GetSecureSecurityDescriptor(&rgchSD, fTrue, fHidden)))
			return PostError(Imsg(idbgOpSecureSecurityDescriptor), (int)dwError);

		DWORD dwLength = GetSecurityDescriptorLength(rgchSD);
		char* pbstrmSid = riServices.AllocateMemoryStream(dwLength, rpiStream);
		Assert(pbstrmSid);
		memcpy(pbstrmSid, rgchSD, dwLength);
	}
	return 0;
}

IMsiRecord* CMsiOpExecute::GetUsageKeySecurityDescriptor(IMsiStream*& rpiStream)
{
	if (!RunningAsLocalSystem())
		return 0;

	DWORD dwError = 0;
	char* rgchSD;
	if (ERROR_SUCCESS != (dwError = ::GetUsageKeySecurityDescriptor(&rgchSD)))
		return PostError(Imsg(idbgOpSecureSecurityDescriptor), (int)dwError);

	DWORD dwLength = GetSecurityDescriptorLength(rgchSD);
	char* pbstrmSid = m_riServices.AllocateMemoryStream(dwLength, rpiStream);
	Assert(pbstrmSid);
	memcpy(pbstrmSid, rgchSD, dwLength);
	return 0;
}

const ICHAR* rgszUninstallKeyRegData[] =
{
    TEXT("%s"), szMsiUninstallProductsKey_legacy, 0, 0,
    TEXT(""),     0,             g_szTypeString,
    0,
    0,
};

iesEnum CMsiOpExecute::CreateUninstallKey()
{
    return ProcessRegInfo(rgszUninstallKeyRegData, HKEY_LOCAL_MACHINE, fFalse,
                                 0, 0, ibtCommon);
}

#ifndef UNICODE
void ConvertMultiSzToWideChar(const IMsiString& ristrFileNames, CTempBufferRef<WCHAR>& rgch)
{
	rgch.SetSize(ristrFileNames.TextSize() + 1);
	*rgch = 0;
	int iRet = MultiByteToWideChar(CP_ACP, 0, ristrFileNames.GetString(), ristrFileNames.TextSize() + 1, rgch, rgch.GetSize());
	if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
	{
		iRet = MultiByteToWideChar(CP_ACP, 0, ristrFileNames.GetString(), ristrFileNames.TextSize() + 1, 0, 0);
		if (iRet)
		{
			rgch.SetSize(iRet);
			*rgch = 0;
			iRet = MultiByteToWideChar(CP_ACP, 0, ristrFileNames.GetString(), ristrFileNames.TextSize() + 1, rgch, rgch.GetSize());
		}
	}
}
#endif


iesEnum CMsiOpExecute::ixfInstallProtectedFiles(IMsiRecord& riParams)
{
	AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
				g_szNoSFCMessage);

	// If no files in the cache at all, or couldn't load SFC.DLL, we're done.
	if(!m_pFileCacheCursor || !g_MessageContext.m_hSfcHandle)
		return iesSuccess;

	MsiString strMultiFilePaths;
	m_pFileCacheCursor->Reset();
	m_pFileCacheCursor->SetFilter(0); // temporarily remove filter to scan entire list
	int cProtectedFiles = 0;
	while (m_pFileCacheCursor->Next())
	{
		icfsEnum icfsFileState = (icfsEnum)m_pFileCacheCursor->GetInteger(m_colFileCacheState);
		if (icfsFileState & icfsProtectedInstalledBySFC)
		{
			MsiString strFilePath = m_pFileCacheCursor->GetString(m_colFileCacheFilePath);
			strMultiFilePaths += strFilePath;
			strMultiFilePaths += MsiString(MsiChar(0));
			DEBUGMSG1(TEXT("Protected file - requesting installation by SFP: %s"), strFilePath);

			cProtectedFiles++;
		}
	}
	m_pFileCacheCursor->SetFilter(iColumnBit(m_colFileCacheFilePath)); // Put back the permanent filter

	if (strMultiFilePaths.CharacterCount() > 0)
	{
		m_fSfpCancel = false;
		BOOL fAllowUI = riParams.GetInteger(IxoInstallProtectedFiles::AllowUI);
		MsiDisableTimeout();
#ifdef UNICODE
		BOOL fInstallSuccess = SFC::SfcInstallProtectedFiles(g_MessageContext.m_hSfcHandle, strMultiFilePaths, fAllowUI, NULL,
			NULL, SfpProgressCallback, (DWORD_PTR) this);
#else
		CTempBuffer<WCHAR, 256>  rgchFilePaths;
		ConvertMultiSzToWideChar(*strMultiFilePaths, rgchFilePaths);
		BOOL fInstallSuccess = SFC::SfcInstallProtectedFiles(g_MessageContext.m_hSfcHandle, rgchFilePaths, fAllowUI,
			NULL, NULL, SfpProgressCallback, (DWORD_PTR) this);
#endif
		MsiEnableTimeout();
		if (!fInstallSuccess)
		{
			int iLastError = GetLastError();

			// form list of files that is seperated by '\r\n' rather than '\0'
			// size of buffer is size of multi-sz list, plus 1 extra char for every file
			CTempBuffer<ICHAR, 256> rgchLogFilePaths;
			rgchLogFilePaths.Resize(strMultiFilePaths.TextSize() + cProtectedFiles + 2);

			const ICHAR* pchFrom = (const ICHAR*)strMultiFilePaths;
			ICHAR* pchTo = (ICHAR*)rgchLogFilePaths;

			int cch = 0;
			while((cch = lstrlen(pchFrom)) != 0)
			{
				Assert(pchFrom[cch] == 0);
				StringCchCopy(pchTo, rgchLogFilePaths.GetSize() - (pchTo - (ICHAR*)rgchLogFilePaths), pchFrom);
				pchTo[cch]   = '\r';
				pchTo[cch+1] = '\n';
				pchTo += cch + 2;
				
				pchFrom += cch + 1;
			}

			pchTo[0] = 0; // null-terminate

			DispatchError(imtEnum(imtError+imtOk), Imsg(imsgSFCInstallProtectedFilesFailed), iLastError, (const ICHAR*)rgchLogFilePaths);
			return iesFailure;
		}
		else
			return m_fSfpCancel ? iesUserExit : iesSuccess;
	}
	else
	{
		return iesSuccess;
	}
}


iesEnum CMsiOpExecute::ixfUpdateEstimatedSize(IMsiRecord& riParams)
{
	if ( g_MessageContext.IsOEMInstall() )
		return iesSuccess;

	CElevate elevate; // elevate this entire function

	Bool fRemove = fFalse;
	using namespace IxoUpdateEstimatedSize; 
	MsiString strProductKey = GetProductKey();

	MsiString strProductInstalledPropertiesKey;
	HKEY hKey = 0; // will be set to global key, do not close
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strProductInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	CTempBuffer<ICHAR,1> rgchInstallPropertiesLocation(MAX_PATH * 2);
	if (FAILED(StringCchCopy(rgchInstallPropertiesLocation, rgchInstallPropertiesLocation.GetSize(), strProductInstalledPropertiesKey)))
		return FatalError(*PMsiRecord(PostError(Imsg(imsgCreateKeyFailed), *strProductInstalledPropertiesKey, ERROR_INSUFFICIENT_BUFFER)));

	const ICHAR* rgszSizeInfoRegData[] = 
	{
		TEXT("%s"), rgchInstallPropertiesLocation, 0, 0,
		szEstimatedSizeValueName, riParams.GetString(EstimatedSize),      g_szTypeIncInteger,
		0,
		0,
	};

	PMsiStream pSecurityDescriptor(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesEnum iesRet;
	if((iesRet = ProcessRegInfo(rgszSizeInfoRegData, hKey, fRemove, pSecurityDescriptor, 0, ibtCommon)) != iesSuccess)
		return iesRet;

	// update the legacy location
	if (FAILED(StringCchPrintf(rgchInstallPropertiesLocation, rgchInstallPropertiesLocation.GetSize(), TEXT("%s\\%s"), szMsiUninstallProductsKey_legacy, (const ICHAR*)strProductKey)))
		return FatalError(*PMsiRecord(PostError(Imsg(imsgCreateKeyFailed), szMsiUninstallProductsKey_legacy, ERROR_INSUFFICIENT_BUFFER)));

    if (!fRemove)
    {
        iesRet = CreateUninstallKey();
        if (iesRet != iesSuccess)
            return iesRet;
    }
	iesRet = ProcessRegInfo(rgszSizeInfoRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
	
	return iesRet;
}

iesEnum CMsiOpExecute::ProcessRegisterProduct(IMsiRecord& riProductInfo, Bool fRemove)
// Handles registration and unregistration of product information.
// Also unregisters LocalPackage value written by IxoDatabaseCopy
{
	CElevate elevate; // elevate this entire function

	using namespace IxoProductRegister;

	MsiString strModifyString;
	MsiString strMinorVersion;
	MsiString strMajorVersion;
	ICHAR rgchDate[20];

	bool fARPNoModify        = !riProductInfo.IsNull(NoModify);
	bool fARPNoRemove        = !riProductInfo.IsNull(NoRemove);
	bool fARPNoRepair        = !riProductInfo.IsNull(NoRepair);
	bool fARPSystemComponent = !riProductInfo.IsNull(SystemComponent);

	if (!fRemove)
	{
		MsiDate dtDate = ENG::GetCurrentDateTime();
		StringCbPrintf(rgchDate, sizeof(rgchDate), TEXT("%4i%02i%02i"), ((unsigned)dtDate>>25) + 1980, (dtDate>>21) & 15, (dtDate>>16) & 31);
		AssertNonZero(8 == lstrlen(rgchDate));

		// Extract minor and major versions

		MsiString strVersion = riProductInfo.GetMsiString(VersionString);
		Assert(strVersion.Compare(iscWithin, TEXT(".")));
		
		strMajorVersion = MsiString(strVersion.Extract(iseUpto, '.'));
		strVersion.Remove(iseIncluding, '.');
		
		strMinorVersion = MsiString(strVersion.Extract(iseUpto, '.'));

		PMsiRecord pRecErr(0);
		
		// uninstall string is run by downlevel ARPs (NT4, Win95)
		// if remove not allowed, we don't write the uninstall string at all
		// else if modify not allowed, uninstall string will uninstall package
		// otherwise it will enter maintenance mode
		if(fARPNoRemove == false)
		{
			strModifyString = MSI_SERVER_NAME;
			strModifyString += TEXT(" /");

			if(fARPNoModify)
				strModifyString += MsiChar(UNINSTALL_PACKAGE_OPTION);
			else
				strModifyString += MsiChar(INSTALL_PACKAGE_OPTION);
				
			strModifyString += MsiString(GetProductKey());
		}

	}

	MsiString strProductKey = GetProductKey();
	MsiString strProductKeySQUID = GetPackedGUID(strProductKey);

	MsiString strVersion =   MsiString(GetProductVersion());
	MsiString strLanguage  = MsiString(GetProductLanguage());

	MsiString strProductInstalledPropertiesKey;
	PMsiRecord pRecErr(0);
	HKEY hKey = 0; // will be set to global key, do not close
	if ((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strProductInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	CTempBuffer<ICHAR,1> rgchInstallPropertiesLocation(MAX_PATH * 2);
	if (FAILED(StringCchCopy(rgchInstallPropertiesLocation, rgchInstallPropertiesLocation.GetSize(), strProductInstalledPropertiesKey)))
		return FatalError(*PMsiRecord(PostError(Imsg(imsgCreateKeyFailed), *strProductInstalledPropertiesKey, ERROR_INSUFFICIENT_BUFFER)));
	
	const ICHAR* rgszProductInfoRegData[] = 
	{
		TEXT("%s"), rgchInstallPropertiesLocation, 0, 0,
		szAuthorizedCDFPrefixValueName,      fRemove ? 0 : riProductInfo.GetString(AuthorizedCDFPrefix),   g_szTypeString,
		szCommentsValueName,        fRemove ? 0 : riProductInfo.GetString(Comments),        g_szTypeString,
		szContactValueName,         fRemove ? 0 : riProductInfo.GetString(Contact),         g_szTypeString,
		// (DisplayName is set by ProcessRegisterProductCPDisplayInfo)
		szDisplayVersionValueName,  fRemove ? 0 : riProductInfo.GetString(VersionString),   g_szTypeString,
		szHelpLinkValueName,        fRemove ? 0 : riProductInfo.GetString(HelpLink),        g_szTypeExpandString,
		szHelpTelephoneValueName,   fRemove ? 0 : riProductInfo.GetString(HelpTelephone),   g_szTypeString,
		szInstallDateValueName,     fRemove ? 0 : rgchDate,                                 g_szTypeString,
		szInstallLocationValueName, fRemove ? 0 : riProductInfo.GetString(InstallLocation), g_szTypeString,
		szInstallSourceValueName,   fRemove ? 0 : g_MessageContext.IsOEMInstall() ? TEXT("") : riProductInfo.GetString(InstallSource),   g_szTypeString,
		szLocalPackageManagedValueName, fRemove ? 0 : TEXT(""),                             g_szTypeString, // only process when fRemove == fTrue
		szLocalPackageValueName,    fRemove ? 0 : TEXT(""),                                 g_szTypeString, // only process when fRemove == fTrue
		szModifyPathValueName,      fRemove ? 0 : (const ICHAR*)strModifyString,            g_szTypeExpandString,
		szNoModifyValueName,        fRemove ? 0 : fARPNoModify ? TEXT("1") : TEXT(""),      g_szTypeInteger,
		szNoRemoveValueName,        fRemove ? 0 : fARPNoRemove ? TEXT("1") : TEXT(""),      g_szTypeInteger,
		szNoRepairValueName,        fRemove ? 0 : fARPNoRepair ? TEXT("1") : TEXT(""),      g_szTypeInteger,
		// (ProductId is set by ixfUserRegister)
		szPublisherValueName,       fRemove ? 0 : riProductInfo.GetString(Publisher),       g_szTypeString,
		szReadmeValueName,          fRemove ? 0 : riProductInfo.GetString(Readme),          g_szTypeExpandString,
		// (RegCompany is set by ixfUserRegister)
		// (RegOwner is set by ixfUserRegister)
		szSizeValueName,            fRemove ? 0 : riProductInfo.GetString(Size),            g_szTypeInteger,
		szEstimatedSizeValueName,   fRemove ? 0 : g_MessageContext.IsOEMInstall() ? TEXT("") : riProductInfo.GetString(EstimatedSize),   g_szTypeIncInteger,
		szSystemComponentValueName, fRemove ? 0 : fARPSystemComponent ? TEXT("1") : TEXT(""), g_szTypeInteger,
		szUninstallStringValueName, fRemove ? 0 : (const ICHAR*)strModifyString,            g_szTypeExpandString,
		szURLInfoAboutValueName,    fRemove ? 0 : riProductInfo.GetString(URLInfoAbout),    g_szTypeString,
		szURLUpdateInfoValueName,   fRemove ? 0 : riProductInfo.GetString(URLUpdateInfo),   g_szTypeString,
		// (ProductIcon is set by PublishProduct)
		szVersionMajorValueName,    fRemove ? 0 : (const ICHAR*)strMajorVersion,            g_szTypeInteger,
		szVersionMinorValueName,    fRemove ? 0 : (const ICHAR*)strMinorVersion,            g_szTypeInteger,
		szWindowsInstallerValueName,fRemove ? 0 : TEXT("1"),                                g_szTypeInteger,
		szVersionValueName,         fRemove ? 0 : (const ICHAR*)strVersion,                 g_szTypeInteger,
		szLanguageValueName,        fRemove ? 0 : (const ICHAR*)strLanguage,                g_szTypeInteger,
		0,
		0,
	};

	iesEnum iesRet;

	PMsiStream pSecurityDescriptor(0);
	
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesRet = ProcessRegInfo(rgszProductInfoRegData, hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	if (iesRet != iesSuccess)
		return iesRet;

	// update the legacy location
	if (FAILED(StringCchPrintf(rgchInstallPropertiesLocation, rgchInstallPropertiesLocation.GetSize(), TEXT("%s\\%s"), szMsiUninstallProductsKey_legacy, (const ICHAR*)strProductKey)))
		return FatalError(*PMsiRecord(PostError(Imsg(imsgCreateKeyFailed), szMsiUninstallProductsKey_legacy, ERROR_INSUFFICIENT_BUFFER)));

	if(!fRemove)
    {
        iesRet = CreateUninstallKey();
        if (iesRet != iesSuccess)
            return iesRet;
    }
    if (!fRemove || !FProductRegisteredForAUser(strProductKey))
		iesRet = ProcessRegInfo(rgszProductInfoRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
	if (iesRet != iesSuccess)
		return iesRet;
	
	if(!riProductInfo.IsNull(UpgradeCode))
	{
		MsiString strUpgradeCodeSQUID = GetPackedGUID(MsiString(riProductInfo.GetMsiString(UpgradeCode)));
		const ICHAR* rgszUpgradeCodeRegData[] =
		{
			TEXT("%s\\%s"), szMsiUpgradeCodesKey, strUpgradeCodeSQUID, 0,
			strProductKeySQUID,  0,   g_szTypeString,
			0,
			0,
		};

		iesRet = ProcessRegInfo(rgszUpgradeCodeRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
		if (iesRet != iesSuccess)
			return iesRet;
	}

	// create the usage key with read write access
	PMsiStream pReadWriteSecurityDescriptor(0);
	if ((pRecErr = GetUsageKeySecurityDescriptor(*&pReadWriteSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);
	
	MsiString strFeatureUsageKey;
	if ((pRecErr = GetProductFeatureUsageKey(*&strFeatureUsageKey)) != 0)
		return FatalError(*pRecErr);
	
	const ICHAR* rgszUsageRegData[] =
	{
		strFeatureUsageKey, 0, 0, 0,
		TEXT(""),     0,             g_szTypeString,
		0,
		0,
	};

	iesRet = ProcessRegInfo(rgszUsageRegData, m_hUserDataKey, fRemove, pReadWriteSecurityDescriptor, 0, ibtCommon);
	if (iesRet != iesSuccess)
		return iesRet;


	return iesSuccess;
}

iesEnum CMsiOpExecute::ProcessRegisterUser(IMsiRecord& riUserInfo, Bool fRemove)
//----------------------------------------------                                                        
{
	CElevate elevate; // elevate this entire function
	using namespace IxoUserRegister;
	
	// register user information
	// ProcessRegInfo handles rollback
	MsiString strInstalledPropertiesKey;
	PMsiRecord pRecErr(0);
	HKEY hKey = 0; // will be set to global key, do not close
	if((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	const ICHAR* rgszUserInfoRegData[] = 
	{
		TEXT("%s"), strInstalledPropertiesKey, 0, 0,
		szUserNameValueName, riUserInfo.GetString(Owner),      g_szTypeString,
		szOrgNameValueName,  riUserInfo.GetString(Company),    g_szTypeString,
		szPIDValueName,      riUserInfo.GetString(ProductId),  g_szTypeString,
		0,
		0,
	};

	PMsiStream pSecurityDescriptor(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesEnum iesRet;
	if((iesRet = ProcessRegInfo(rgszUserInfoRegData, hKey, fRemove, pSecurityDescriptor,
										 0, ibtCommon)) != iesSuccess)
		return iesRet;

	return iesSuccess;
}

IMsiRecord* CMsiOpExecute::EnsureUserDataKey()
{
	if(m_hUserDataKey)
	{
		return 0;
	}

	ICHAR szUserSID[cchMaxSID];

#ifdef UNICODE
	m_strUserDataKey = szMsiUserDataKey;
	m_strUserDataKey += szRegSep;

	if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
		m_strUserDataKey += szLocalSystemSID;
	else
	{
		CImpersonate impersonate(fTrue);
		DWORD dwError = GetCurrentUserStringSID(szUserSID);
		if (ERROR_SUCCESS != dwError)
		{
			return PostError(Imsg(idbgOpGetUserSID));
		}
		m_strUserDataKey += szUserSID;
	}
#else
	m_strUserDataKey = szMsiLocalInstallerKey;
#endif
	{
		CElevate elevate;
		REGSAM dwSam = KEY_READ| KEY_WRITE;
#ifndef _WIN64 
		if ( g_fWinNT64 )
			dwSam |= KEY_WOW64_32KEY;
#endif

		//?? do we need to explicitly ACL this key
		// Win64: this code runs in the 64-bit service
		long lResult = RegCreateKeyAPI(HKEY_LOCAL_MACHINE, m_strUserDataKey, 0, 0, 0, dwSam, 0, &m_hUserDataKey, 0);
		if(lResult != ERROR_SUCCESS)
		{
			MsiString strFullKey;
			BuildFullRegKey(HKEY_LOCAL_MACHINE, m_strUserDataKey, ibt64bit, *&strFullKey);
			return PostError(Imsg(imsgCreateKeyFailed), *strFullKey, (int)lResult);
		}
	}
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductFeatureUsageKey(const IMsiString*& rpiSubKey)
{
	MsiString strProductFeatureUsageKey;
	// get the appropriate installed properties key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strProductFeatureUsageKey = szMsiProductsSubKey;
	strProductFeatureUsageKey += szRegSep;
	strProductFeatureUsageKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
#ifdef UNICODE
	strProductFeatureUsageKey += szRegSep;
	strProductFeatureUsageKey += szMsiFeatureUsageSubKey;
#endif
	strProductFeatureUsageKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductInstalledPropertiesKey(HKEY& rRoot, const IMsiString*& rpiSubKey)
{
	MsiString strProductInstalledPropertiesKey;
	// get the appropriate installed properties key for the product
#ifdef UNICODE
	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	rRoot = m_hUserDataKey;

	strProductInstalledPropertiesKey = szMsiProductsSubKey;
	strProductInstalledPropertiesKey += szRegSep;
	strProductInstalledPropertiesKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
	strProductInstalledPropertiesKey += szRegSep;
	strProductInstalledPropertiesKey += szMsiInstallPropertiesSubKey;
#else
	rRoot = HKEY_LOCAL_MACHINE;

	strProductInstalledPropertiesKey = szMsiUninstallProductsKey_legacy;
	strProductInstalledPropertiesKey += szRegSep;
	strProductInstalledPropertiesKey += MsiString(GetProductKey());
#endif
	strProductInstalledPropertiesKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductInstalledFeaturesKey(const IMsiString*& rpiSubKey)
{
	MsiString strProductInstalledFeaturesKey;
	// get the appropriate features key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;
#ifdef UNICODE
	strProductInstalledFeaturesKey = szMsiProductsSubKey;
	strProductInstalledFeaturesKey += szRegSep;
	strProductInstalledFeaturesKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
	strProductInstalledFeaturesKey += szRegSep;
	strProductInstalledFeaturesKey += szMsiFeaturesSubKey;
#else
	strProductInstalledFeaturesKey = szMsiFeaturesSubKey;
	strProductInstalledFeaturesKey += szRegSep;
	strProductInstalledFeaturesKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
#endif
	strProductInstalledFeaturesKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductSecureTransformsKey(const IMsiString*& rpiSubKey)
{
	MsiString strProductSecureTransformsKey;

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strProductSecureTransformsKey = szMsiProductsSubKey;
	strProductSecureTransformsKey += szRegSep;
	strProductSecureTransformsKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
	strProductSecureTransformsKey += szRegSep;
	strProductSecureTransformsKey += szMsiTransformsSubKey;
	strProductSecureTransformsKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductInstalledComponentsKey(const ICHAR* szComponentId, const IMsiString*& rpiSubKey)
{
	MsiString strProductInstalledComponentsKey;
	// get the appropriate components key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strProductInstalledComponentsKey = szMsiComponentsSubKey;
	strProductInstalledComponentsKey += szRegSep;
	ICHAR szComponentIdPacked[cchComponentId + 1];
	AssertNonZero(PackGUID(szComponentId, szComponentIdPacked));
	strProductInstalledComponentsKey += szComponentIdPacked;
	strProductInstalledComponentsKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetInstalledPatchesKey(const ICHAR* szPatchCode, const IMsiString*& rpiSubKey)
{
	MsiString strPatchesKey;
	// get the appropriate installed properties key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strPatchesKey = szMsiPatchesSubKey;
	strPatchesKey += szRegSep;
	ICHAR szPatchCodePacked[cchPatchCodePacked + 1];
	AssertNonZero(PackGUID(szPatchCode, szPatchCodePacked));
	strPatchesKey += szPatchCodePacked;
	strPatchesKey.ReturnArg(rpiSubKey);
	return 0;
}

iesEnum CMsiOpExecute::ixfDatabaseCopy(IMsiRecord& riParams)
{
	using namespace IxoDatabaseCopy;
	
	PMsiRecord pRecErr(0);
	iesEnum iesRet;
	
	PMsiPath pDestPath(0);
	PMsiPath pSourcePath(0);
	MsiString strDestFileName;
	MsiString strSourceFileName;
	MsiString strLocalPackageKey;

	MsiString strAdminInstallPath = riParams.GetMsiString(AdminDestFolder);
	bool fCacheDatabase = !strAdminInstallPath.TextSize();

	CElevate elevate(fCacheDatabase); // elevate for this entire function when caching

	// set source path and file name
	if((pRecErr = m_riServices.CreateFilePath(riParams.GetString(DatabasePath), *&pSourcePath, *&strSourceFileName)) != 0)
		return FatalError(*pRecErr);

	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);
	HKEY hKey = 0; // will be set to global key, do not close
	if(fCacheDatabase)
	{
		// caching package in cache folder
		
		// Delete any existing cached database for this product

		// get the appropriate cached database key/ value
		if((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strLocalPackageKey)) != 0)
			return FatalError(*pRecErr);

		MsiString strCachedDatabase;
		PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)
		PMsiRegKey pProductKey = &pHKLM->CreateChild(strLocalPackageKey);

		pRecErr = pProductKey->GetValue(iaaAsgnType == iaaUserAssign ? szLocalPackageManagedValueName : szLocalPackageValueName, *&strCachedDatabase);
		if ((pRecErr == 0) && (strCachedDatabase.TextSize() != 0))
		{
			IMsiRecord& riFileRemove = GetSharedRecord(IxoFileRemove::Args);
			riFileRemove.SetMsiString(IxoFileRemove::FileName, *strCachedDatabase);
			if ((iesRet = ixfFileRemove(riFileRemove)) != iesSuccess)
				return iesRet;
		}

		// Generate a unique name for database, create and secure the file.
		MsiString strMsiDir = ENG::GetMsiDirectory();

		// set dest path and file name
		if (((pRecErr = m_riServices.CreatePath(strMsiDir, *&pDestPath)) != 0) ||
			((pRecErr = pDestPath->EnsureExists(0)) != 0) ||
			((pRecErr = pDestPath->TempFileName(0, szDatabaseExtension, fTrue, *&strDestFileName, &CSecurityDescription(true, false))) != 0) ||
			((pRecErr = pDestPath->SetAllFileAttributes(0,FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM))))
		{
			return FatalError(*pRecErr);
		}
	}
	else
	{
		// copying package to admin install point
		if((pRecErr = m_riServices.CreatePath(strAdminInstallPath, *&pDestPath)) != 0)
			return FatalError(*pRecErr);

		strDestFileName = strSourceFileName;

		if((iesRet = CreateFolder(*pDestPath)) != iesSuccess)
			return iesRet;
	}

	Assert(pSourcePath);
	Assert(pDestPath);
	Assert(strSourceFileName.TextSize());
	Assert(strDestFileName.TextSize());

	// Open storages on the source and destination databases

	MsiString strMediaLabel, strMediaPrompt;
	if (m_state.pCurrentMediaRec)
	{       
		using namespace IxoChangeMedia;
		strMediaLabel  = m_state.pCurrentMediaRec->GetString(MediaVolumeLabel);
		strMediaPrompt = m_state.pCurrentMediaRec->GetString(MediaPrompt);
	}

	// current assumption is that the package is always on disk 1.
	PMsiVolume pNewVolume(0);
	if (!VerifySourceMedia(*pSourcePath, strMediaLabel, strMediaPrompt, /*uiDisk=*/1, *&pNewVolume))
		return iesUserExit;

	if (pNewVolume)
		pSourcePath->SetVolume(*pNewVolume);

	MsiString strDbTargetFullFilePath = pDestPath->GetPath();
	strDbTargetFullFilePath += strDestFileName;

	PMsiStorage pDatabase(0);
	PMsiStorage pCachedDatabase(0);

	MsiString strPackagePath;
	if ((pRecErr = pSourcePath->GetFullFilePath(strSourceFileName, *&strPackagePath)) != 0)
		return FatalError(*pRecErr);

	// if it's from a URL, it should still be cached locally.

	if (PMsiVolume(&pSourcePath->GetVolume())->IsURLServer())
	{
		// in this case, the download code simply looks up the local one, and hands it back
		// to you.  This should not fail.

		MsiString strCacheFileName;
		bool fFileUrl = false;
		bool fUrl = IsURL((const ICHAR*)strPackagePath, fFileUrl);
		if (fFileUrl)
		{
			CTempBuffer<ICHAR, 1>rgchFullFilePath(cchExpectedMaxPath + 1);
			DWORD cchFullFilePath = rgchFullFilePath.GetSize();
			if (MsiConvertFileUrlToFilePath((const ICHAR*)strPackagePath, rgchFullFilePath, &cchFullFilePath, 0))
			{
				strPackagePath = static_cast<const ICHAR*>(rgchFullFilePath);
			}
		}
		else
		{
			UINT iStat = DownloadUrlFile((const ICHAR*) strPackagePath, *&strCacheFileName, fUrl, -1);

			if (ERROR_SUCCESS == iStat)
			{
				strPackagePath = strCacheFileName;
			}
		}
	}

	if (((pRecErr = m_riServices.CreateStorage(strPackagePath,
								ismReadOnly, *&pDatabase)) != 0) ||
		((pRecErr = m_riServices.CreateStorage(strDbTargetFullFilePath,
								ismCreateDirect, *&pCachedDatabase)) != 0))
	{
		return FatalError(*pRecErr);
	}


	// Create a record with the streams to be dropped

	MsiString strStreams = riParams.GetMsiString(IxoDatabaseCopy::CabinetStreams);
	MsiString strStreamName;
	unsigned int cStreams = 0;
	unsigned int cCurrentStream = 0;
	IMsiRecord* piRecStreams = NULL; // don't release -- it's shared!

	// first count how many streams we have to drop; then create a record
	// with the stream names

	for (int c = 1; c <= 2; c++)
	{
		while(strStreams.TextSize())
		{
			strStreamName = strStreams.Extract(iseUpto,';');
			if(strStreamName.TextSize() == strStreams.TextSize())
				strStreams = TEXT("");
			else
				strStreams.Remove(iseFirst,strStreamName.TextSize()+1);

			if (c == 1)
				cStreams++;
			else
				piRecStreams->SetMsiString(++cCurrentStream, *strStreamName);
		}
		if (c == 1)
		{
			piRecStreams = &GetSharedRecord(cStreams);
			strStreams = riParams.GetMsiString(IxoDatabaseCopy::CabinetStreams);
		}
	}

	// Cache the database

	for (;;)
	{
		MsiDisableTimeout();
		pRecErr = pDatabase->CopyTo(*pCachedDatabase, cStreams ? piRecStreams : 0);
		MsiEnableTimeout();

		if (pRecErr == 0)
			break;
		else
		{
			DispatchMessage(imtInfo, *pRecErr, fTrue);

			if (pRecErr->GetInteger(3) == STG_E_MEDIUMFULL)
				pRecErr = PostError(Imsg(imsgDiskFull), *strDbTargetFullFilePath);
			else
				pRecErr = PostError(Imsg(imsgOpPackageCache), *strPackagePath, pRecErr->GetInteger(3));
			
			switch(DispatchMessage(imtEnum(imtError+imtRetryCancel+imtDefault1), *pRecErr, fTrue))
			{
			case imsRetry:
				continue;
			default:
				Assert(0); // fall through
			case imsCancel:
				return iesFailure;
			};
		}
	}

	IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
	AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName,
														 *strDbTargetFullFilePath));

	// need to elevate during rollback to remove cached database
	AssertNonZero(riUndoParams.SetInteger(IxoFileRemove::Elevate, fCacheDatabase));

	if (!RollbackRecord(ixoFileRemove, riUndoParams))
		return iesFailure;

	if(fCacheDatabase)
	{
		Assert(strLocalPackageKey.TextSize() && hKey);
		
		// Write LocalPackage registry value
		// ProcessRegInfo handles rollback
		const ICHAR* rgszUserInfoRegData[] =
		{
			TEXT("%s"), strLocalPackageKey, 0, 0,
			iaaAsgnType == iaaUserAssign ? szLocalPackageManagedValueName : szLocalPackageValueName, strDbTargetFullFilePath, g_szTypeString,
			0,
			0,
		};

		return ProcessRegInfo(rgszUserInfoRegData, hKey, fFalse, 0, 0, ibtCommon);
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfDatabasePatch(IMsiRecord& riParams)
{
	using namespace IxoDatabasePatch;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	MsiString strDatabaseFullPath = riParams.GetMsiString(DatabasePath);

	PMsiPath pDatabasePath(0);
	MsiString strDatabaseName;
	if((pError = m_riServices.CreateFilePath(strDatabaseFullPath,*&pDatabasePath,*&strDatabaseName)) != 0)
		return FatalError(*pError);

	if((iesRet = BackupFile(*pDatabasePath,*strDatabaseName,fFalse,fFalse,iehShowNonIgnorableError)) != iesSuccess)
		return iesRet;

	int iOldAttribs = -1;
	if((pError = pDatabasePath->EnsureOverwrite(strDatabaseName, &iOldAttribs)) != 0)
		return FatalError(*pError);

	PMsiDatabase pDatabase(0);
	if((pError = m_riServices.CreateDatabase(strDatabaseFullPath,idoTransact,*&pDatabase)) != 0)
		return FatalError(*pError);

	int cIndex = DatabasePath + 1;
	int cFields = riParams.GetFieldCount();
	
	for(int i = DatabasePath + 1; i <= cFields; i++)
	{
		PMsiData pData = riParams.GetMsiData(i);
		if(!pData)
		{
			AssertSz(0, "couldn't get transform stream from riParams in ixoDatabasePatch");
			continue;
		}
		PMsiMemoryStream pStream((IMsiData&)*pData, IID_IMsiStream);
		Assert(pStream);

		// create transform storage
		PMsiStorage pTransformStorage(0);
		if((pError = ::CreateMsiStorage(*pStream, *& pTransformStorage)) != 0)
			return FatalError(*pError);

		PMsiSummaryInfo pTransSummary(0);
		if ((pError = pTransformStorage->CreateSummaryInfo(0, *&pTransSummary)))
		{
			pError = PostError(Imsg(idbgTransformCreateSumInfoFailed));
			return FatalError(*pError);
		}

		int iTransCharCount = 0;
		pTransSummary->GetIntegerProperty(PID_CHARCOUNT, iTransCharCount);
		
		// apply transform
		if((pError = pDatabase->SetTransform(*pTransformStorage, iTransCharCount & 0xFFFF)) != 0)
			return FatalError(*pError);
	}
		
	if((pError = pDatabase->Commit()) != 0)
		return FatalError(*pError);

	// NOTE: if a failure happened after removing the read-only attribute but before this point, rollback will
	// restore the proper attributes when restoring the file
	if((pError = pDatabasePath->SetAllFileAttributes(strDatabaseName, iOldAttribs)) != 0)
		return FatalError(*pError);

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfCustomActionSchedule: execute custom action or schedule it for commit or rollback
ixfCustomActionCommit:   call rollback custom action during commit
ixfCustomActionRollback: call rollback custom action during rollback
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfCustomActionSchedule(IMsiRecord& riParams)
{
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}

	if (riParams.GetInteger(IxoCustomActionSchedule::ActionType) & icaRollback)
	{
		if (!RollbackRecord(ixoCustomActionRollback, riParams))
			return iesFailure;

		return iesSuccess;
	}
	if (riParams.GetInteger(IxoCustomActionSchedule::ActionType) & icaCommit)
	{
		if (!RollbackRecord(ixoCustomActionCommit, riParams))
			return iesFailure;
		else
			return iesSuccess;
	}
	return ixfCustomActionRollback(riParams);
}

iesEnum CMsiOpExecute::ixfCustomActionCommit(IMsiRecord& riParams)
{
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}

	return ixfCustomActionRollback(riParams);
}

iesEnum CMsiOpExecute::ixfCustomActionRollback(IMsiRecord& riParams)
{
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}

	int icaFlags = riParams.GetInteger(IxoCustomActionSchedule::ActionType);
	if (!m_fRunScriptElevated || !(icaFlags & icaNoImpersonate))
		AssertNonZero(StartImpersonating());
	GUID guidAppCompatDB;
	GUID guidAppCompatID;
	iesEnum iesRet = ENG::ScheduledCustomAction(riParams, *MsiString(GetProductKey()), (LANGID)GetProductLanguage(), m_riMessage, m_fRunScriptElevated, GetAppCompatCAEnabled(), GetAppCompatDB(&guidAppCompatDB), GetAppCompatID(&guidAppCompatID));
	if (!m_fRunScriptElevated || !(icaFlags & icaNoImpersonate))
		StopImpersonating();
	return iesRet;
}

//!! do we need to create a separate IMsiMessage object to call CMsiOpExecute::Message?

void CreateCustomActionManager(bool fRemapHKCU)
{
	// in the service, the manager lives in the ConfigManager because there isn't
	// necessarily an engine

	IMsiConfigurationManager *piConfigMgr = CreateConfigurationManager();
	if (piConfigMgr)
	{
		piConfigMgr->CreateCustomActionManager(fRemapHKCU);
		piConfigMgr->Release();
	}
}

CMsiCustomActionManager *GetCustomActionManager(IMsiEngine *piEngine);

CMsiCustomActionManager *GetCustomActionManager(const ibtBinaryType iType, const bool fRemoteIfImpersonated, bool& fSuccess)
{
	CMsiCustomActionManager* pManager = NULL;
	bool fRemote = false;
	fSuccess = true;
#if defined(_WIN64)
	if ( iType == ibt32bit )
		fRemote = true;
#else
	ibtBinaryType i = iType;  // for the joy of the compiler
#endif

	if (g_scServerContext == scService)
	{
		if (fRemoteIfImpersonated && IsImpersonating(false))
			fRemote = true;
	}

#if defined(DEBUG)
	if ( !fRemote && GetTestFlag('J') )
		fRemote = true;
#endif
 
	if ( fRemote )
	{
		pManager = GetCustomActionManager(NULL);
		if ( !pManager )
		{
			const ICHAR szMessage[] = TEXT("Could not get CMsiCustomActionManager*");
			AssertSz(pManager, szMessage);
			DEBUGMSG(szMessage);
			fSuccess = false;
		}
	}
	return pManager;
}

#ifdef DEBUG
void LocalDebugOutput(const ICHAR* szAPI, int iRes, CMsiCustomActionManager* pManager)
{
	DEBUGMSG3(TEXT("%s returned %d in %s context."), szAPI, (const ICHAR*)(INT_PTR)iRes,
				 pManager ? TEXT("remote") : TEXT("local"));
}
#endif

BOOL LocalSQLInstallDriverEx(int cDrvLen, LPCTSTR szDriver, LPCTSTR szPathIn, LPTSTR szPathOut,
									  WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest,
									  DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLInstallDriverEx(cDrvLen, szDriver, szPathIn, szPathOut, cbPathOutMax,
														pcbPathOut, fRequest, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLInstallDriverEx(szDriver, szPathIn, szPathOut, cbPathOutMax,
															pcbPathOut, fRequest, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLConfigDriver(HWND hwndParent, WORD fRequest, LPCTSTR szDriver,
								  LPCTSTR szArgs, LPTSTR szMsg, WORD cbMsgMax, 
								  WORD* pcbMsgOut, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
	{
		Assert(hwndParent == 0);
		// since it's always called hwndParent = 0, I didn't bother marshaling hwndParent.
		iRes = pManager->SQLConfigDriver(fRequest, szDriver, szArgs,
											szMsg, cbMsgMax, pcbMsgOut);
	}
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLConfigDriver(hwndParent, fRequest, szDriver, szArgs,
											szMsg, cbMsgMax, pcbMsgOut);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLRemoveDriver(LPCTSTR szDriver, BOOL fRemoveDSN, DWORD* pdwUsageCount,
								  ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLRemoveDriver(szDriver, fRemoveDSN, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLRemoveDriver(szDriver, fRemoveDSN, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLInstallTranslatorEx(int cTranLen, LPCTSTR szTranslator, LPCTSTR szPathIn, LPTSTR szPathOut,
											WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest,
											DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLInstallTranslatorEx(cTranLen, szTranslator, szPathIn, szPathOut, cbPathOutMax,
															 pcbPathOut, fRequest, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLInstallTranslatorEx(szTranslator, szPathIn, szPathOut, cbPathOutMax,
																 pcbPathOut, fRequest, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLRemoveTranslator(LPCTSTR szTranslator, DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLRemoveTranslator(szTranslator, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLRemoveTranslator(szTranslator, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLConfigDataSource(HWND hwndParent, WORD fRequest, LPCTSTR szDriver,
										LPCTSTR szAttributes, DWORD cbAttrSize, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
	{
		Assert(hwndParent == 0);
		// since it's always called hwndParent = 0, I didn't bother marshaling hwndParent.
		iRes = pManager->SQLConfigDataSource(fRequest, szDriver,
														 szAttributes, cbAttrSize);
	}
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLConfigDataSource(hwndParent, fRequest, szDriver,
														 szAttributes);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLInstallDriverManager(LPTSTR szPath, WORD cbPathMax, WORD* pcbPathOut, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLInstallDriverManager(szPath, cbPathMax, pcbPathOut);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLInstallDriverManager(szPath, cbPathMax, pcbPathOut);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}
	
BOOL LocalSQLRemoveDriverManager(DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLRemoveDriverManager(pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLRemoveDriverManager(pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

short LocalSQLInstallerError(WORD iError, DWORD* pfErrorCode, LPTSTR szErrorMsg, WORD cbErrorMsgMax,
									  WORD* pcbErrorMsg, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	short iRes;
	if ( pManager )
	{
		iRes = pManager->SQLInstallerError(iError, pfErrorCode, szErrorMsg, cbErrorMsgMax, pcbErrorMsg);
		AssertSz(iRes != -2, TEXT("remote latebound call to SQLInstallerError failed"));
	}
	else
	{
		if ( fSuccess )
		{
			iRes = ODBCCP32::SQLInstallerError(iError, pfErrorCode, szErrorMsg, cbErrorMsgMax, pcbErrorMsg);
			AssertSz(iRes != -2, TEXT("local latebound call to SQLInstallerError failed"));
		}
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

/*---------------------------------------------------------------------------
ixfODBCInstallDriver:
ixfODBCRemoveDriver:
ixfODBCInstallTranslator:
ixfODBCRemoveTranslator:
ixfODBCDataSource:
ixfODBCDriverManager:
---------------------------------------------------------------------------*/

#define SQL_MAX_MESSAGE_LENGTH 512
#define SQL_NO_DATA            100
#define ODBC_INSTALL_INQUIRY     1
#define ODBC_INSTALL_COMPLETE    2
#define ODBC_ADD_DSN             1
#define ODBC_CONFIG_DSN          2
#define ODBC_REMOVE_DSN          3
#define ODBC_ADD_SYS_DSN         4
#define ODBC_CONFIG_SYS_DSN      5
#define ODBC_REMOVE_SYS_DSN      6
#define ODBC_INSTALL_DRIVER      1
#define ODBC_REMOVE_DRIVER       2

// ODBC 3.0 wants byte counts for buffer sizes, ODBC 3.5 and newer wants character counts
//   so we double the sizes of the buffers and pass the character count, 3.0 will use 1/2 the buffer on Unicode
#ifdef UNICODE
#define SQL_FIX 2
#else
#define SQL_FIX 1
#endif

iesEnum CMsiOpExecute::RollbackODBCEntry(const ICHAR* szName, rrkEnum rrkRoot,
													  ibtBinaryType iType)
{
	// generate rollback ops to delete/restore the following registration:
	// HK[CU|LM]\Software\ODBC\ODBC.INI\[szName] (entire key)
	// HK[CU|LM]\Software\ODBC\ODBC.INI\ODBC Data Sources  (szName value)

	if(RollbackEnabled() == fFalse)
		return iesSuccess;

	// basically just rollback a single named key from HKCU.
	PMsiRecord pErr(0);
	MsiString strODBC = TEXT("Software\\ODBC\\ODBC.INI\\");
	strODBC += szName;

	PMsiRegKey pODBCKey(0);

	iesEnum iesRet = iesSuccess;

	PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkRoot, iType);
	PMsiRegKey pEntry = &pRoot->CreateChild(strODBC);
	Bool fKeyExists = fFalse;
	pErr = pEntry->Exists(fKeyExists);

	IMsiRecord* piRollback = &GetSharedRecord(IxoRegOpenKey::Args);
	using namespace IxoRegOpenKey;
	AssertNonZero(piRollback->SetInteger(Root, rrkRoot));
	AssertNonZero(piRollback->SetMsiString(Key, *strODBC));
	AssertNonZero(piRollback->SetInteger(BinaryType, iType));
	if (!RollbackRecord(Op, *piRollback))
		return iesFailure;

	ixfRegOpenKey(*piRollback);

	if (fKeyExists)
	{
		// roll it back in.
		SetRemoveKeyUndoOps(*pEntry);
	}
	
	// get rid of any old values
	piRollback = &GetSharedRecord(IxoRegRemoveKey::Args);
	Assert(0 == IxoRegRemoveKey::Args);
	if (!RollbackRecord(IxoRegRemoveKey::Op, *piRollback))
		return iesFailure;

	// delete/restore "ODBC Data Sources" value
	return SetRegValueUndoOps(rrkRoot, TEXT("Software\\ODBC\\ODBC.INI\\ODBC Data Sources"), szName, iType);
}

iesEnum CMsiOpExecute::RollbackODBCINSTEntry(const ICHAR* szSection, const ICHAR* szName,
															ibtBinaryType iType)
{
	iesEnum iesStat = iesSuccess;
	PMsiRecord pErr(0);

	PMsiRegKey pLocalMachine = &m_riServices.GetRootKey(rrkLocalMachine, iType);
	if (!pLocalMachine)
		return iesFailure;

	MsiString strODBCKey = TEXT("Software\\ODBC\\ODBCINST.INI");
	
	PMsiRegKey pODBCKey = &pLocalMachine->CreateChild(strODBCKey);
	if (!pODBCKey)
		return iesFailure;

	PMsiRegKey pSectionKey = &pODBCKey->CreateChild(szSection);
	if (!pSectionKey)
		return iesFailure;

	PMsiRegKey pEntryKey = &pODBCKey->CreateChild(szName);
	if (!pEntryKey)
		return iesFailure;


	Bool fEntryExists = fFalse;
	pErr = pSectionKey->ValueExists(szName, fEntryExists);
	if (pErr)
		return iesFailure;
	
	PMsiRecord pRollbackOpenKey = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
	using namespace IxoRegOpenKey;
	AssertNonZero(pRollbackOpenKey->SetInteger(Root, rrkLocalMachine));
	AssertNonZero(pRollbackOpenKey->SetInteger(BinaryType, iType));

	MsiString strOpenKey = strODBCKey + szRegSep;
	strOpenKey += szSection;

	AssertNonZero(pRollbackOpenKey->SetMsiString(Key, *strOpenKey));
	if (!RollbackRecord(Op, *pRollbackOpenKey))
		return iesFailure;

	Assert(IxoRegAddValue::Args == IxoRegRemoveValue::Args);
	Assert(IxoRegAddValue::Name == IxoRegRemoveValue::Name);
	Assert(IxoRegAddValue::Value == IxoRegRemoveValue::Value);
	IMsiRecord& riValue = GetSharedRecord(IxoRegAddValue::Args);
	AssertNonZero(riValue.SetString(IxoRegAddValue::Name, szName));

	if (fEntryExists)
	{
		// reset to the old value
		MsiString strCurrentValue;
		pErr = pSectionKey->GetValue(szName, *&strCurrentValue);
		if (pErr)
			return iesFailure;

		using namespace IxoRegAddValue;
		AssertNonZero(riValue.SetMsiString(Value, *strCurrentValue));
		if (!RollbackRecord(IxoRegAddValue::Op, riValue))
			return iesFailure;
		
		// enumerate the values of the entry key, and write those as well.
		strOpenKey = strODBCKey + szRegSep;
		strOpenKey += szName;
		AssertNonZero(pRollbackOpenKey->SetMsiString(Key,*strOpenKey));

		// remove key undo ops relies on the key being open.
		// We don't actually want to remove the key now, just save off the old values.
		if (iesSuccess != (iesStat = ixfRegOpenKey(*pRollbackOpenKey)))
			return iesStat;

		// this doesn't need the key open in the rollback script.
		if (iesSuccess != (iesStat = SetRemoveKeyUndoOps(*pEntryKey)))
			return iesStat;
	}
	else
	{
		// remove any existing value in the section key.
		using namespace IxoRegRemoveValue;
		if (!RollbackRecord(IxoRegRemoveValue::Op, riValue))
			return iesFailure;
		
		// remove the entry key by that name.  Just whack whatever is there.
		strOpenKey = strODBCKey + szRegSep;
		strOpenKey += szName;
		AssertNonZero(pRollbackOpenKey->SetMsiString(Key, *strOpenKey));
		if (!RollbackRecord(IxoRegOpenKey::Op, *pRollbackOpenKey))
			return iesFailure;

		if (!RollbackRecord(IxoRegRemoveKey::Op, riValue))
			return iesFailure;
	}

	return iesStat;
}

iesEnum CMsiOpExecute::CheckODBCError(BOOL fResult, IErrorCode imsg, const ICHAR* sz, imsEnum imsDefault, ibtBinaryType iType)
{
	if (fResult == TRUE)
		return iesSuccess;
	else if(fResult == ERROR_INSTALL_SERVICE_FAILURE ||
			fResult == E_NOINTERFACE ||
			fResult == TYPE_E_DLLFUNCTIONNOTFOUND)
		// something failed along the custom action route
		return iesFailure;

	DWORD iErrorCode = 0;
	CTempBuffer<ICHAR,1> rgchMessage(SQL_MAX_MESSAGE_LENGTH * SQL_FIX);
	rgchMessage[0] = 0;
	WORD cbMessage;
	PMsiRecord pError = &m_riServices.CreateRecord(sz ? 4 : 3);
	int iStat = LocalSQLInstallerError(1, &iErrorCode, rgchMessage, static_cast<WORD>(rgchMessage.GetSize()-1), &cbMessage, iType);
	ISetErrorCode(pError, imsg);
	pError->SetInteger(2, iErrorCode);
	pError->SetString(3, rgchMessage);
	if (sz)
		pError->SetString(4, sz);

	bool fErrorIgnorable = false;
	imtEnum imt;
	switch (imsDefault)
	{
	default: Assert(0);  // coding error in caller, fall through
	case imsOk:     imt = imtEnum(imtError + imtOk); break;
	case imsAbort:  imt = imtEnum(imtError + imtAbortRetryIgnore + imtDefault1); fErrorIgnorable = true; break;
	case imsIgnore: imt = imtEnum(imtError + imtAbortRetryIgnore + imtDefault3); fErrorIgnorable = true; break;
	}
	switch (Message(imt, *pError))
	{
	case imsIgnore: return iesSuccess;  // ignore error
	case imsRetry:  return iesSuspend;  // retry (standard mapping)
	case imsNone:                       // quiet UI - ignore ignoreable errors
		if(fErrorIgnorable)
			return (iesEnum)iesErrorIgnored;
		else
			return iesFailure;
	default:        return iesFailure;  // imsOK or imsAbort
	}
}

static ICHAR* ComposeDriverKeywordList(IMsiRecord& riParams, int& cchAttr)
{
	using namespace IxoODBCInstallDriver;
	int iField;
	int cFields = riParams.GetFieldCount();
	int cbDriverKey = riParams.GetTextSize(DriverKey);
	const ICHAR* szDriverKey = riParams.GetString(DriverKey);
	cchAttr = cbDriverKey + 2;  // extra null at end of attribute string
	for (iField = Args - 2 + 1; iField <= cFields; iField++)
	{
		int cb = riParams.GetTextSize(iField++);
		if (cb)  // skip null attribute names
			cchAttr += cb + 1 + riParams.GetTextSize(iField) + 1;  // "attr=value\0"
	}
	ICHAR* szAttr = new ICHAR[cchAttr];
	if ( ! szAttr )
		return NULL;
	ICHAR* pch = szAttr;
	StringCchCopy(pch, cchAttr, szDriverKey);
	pch += cbDriverKey + 1;
	for (iField = Args - 2 + 1; iField <= cFields; iField++)
	{
		int cb = riParams.GetTextSize(iField++);
		if (cb)  // skip null attribute names
		{
			StringCchCopy(pch, cchAttr - (pch - szAttr), riParams.GetString(iField-1));
			pch += cb;
			*pch++ = '=';
			cb = riParams.GetTextSize(iField);
			if (cb)
				StringCchCopy(pch, cchAttr - (pch - szAttr), riParams.GetString(iField));
			else
				*pch = 0;
			pch += cb + 1; // keep null separator
		}
	}
	*pch = 0;  // double null terminator
	return szAttr;
}

iesEnum CMsiOpExecute::ixfODBCInstallDriver(IMsiRecord& riParams)
{
	return ODBCInstallDriverCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCInstallDriver64(IMsiRecord& riParams)
{
	return ODBCInstallDriverCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCInstallDriverCore(IMsiRecord& riParams, ibtBinaryType iType)
{
//  MSIXO(ODBCInstallDriver, XOT_UPDATE, MSIXA5(DriverKey, Component, Folder, Attribute_, Value_))
	using namespace IxoODBCInstallDriver;
//!! If we're replace the driver with a newer version
//!! somehow we need to remove the old driver first by calling SQLRemoveDriver repeatedly?
//!! or calling SQLConfigDriver(..ODBC_REMOVE_DRIVER..), then calling SQLRemoveDriver once?
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	const ICHAR* szDriverKey = riParams.GetString(DriverKey);
	int cchAttr;
	ICHAR* szAttr = ComposeDriverKeywordList(riParams, cchAttr);
	DWORD dwUsageCount;
	ICHAR rgchPathOut[MAX_PATH * SQL_FIX];  // we should have checked this already and set directory
	WORD cchPath = 0;

	if ( ! szAttr )
		return iesFailure;

	// Writes to HKLM\Software\ODBC\ODBCINST.INI\ODBC Drivers, <description>=Installed
	//                                          \Description, bunch of named value
	RollbackODBCINSTEntry(TEXT("ODBC Drivers"), szDriverKey, iType);

	iesEnum iesRet;
	WORD cbDummy;
	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLInstallDriverEx(cchAttr, szAttr, riParams.GetString(IxoODBCInstallDriver::Folder),
											rgchPathOut, MAX_PATH * SQL_FIX, &cbDummy, ODBC_INSTALL_COMPLETE, &dwUsageCount, iType),
											Imsg(imsgODBCInstallDriver), szDriverKey, imsAbort, iType))) ;
	if (dwUsageCount > 1 && riParams.IsNull(Component))   // reinstall, remove added refcount
		LocalSQLRemoveDriver(szDriverKey, FALSE, &dwUsageCount, iType);

	if (iesRet == iesSuccess)
		while (iesSuspend == (iesRet = CheckODBCError(LocalSQLConfigDriver((HWND)0, ODBC_INSTALL_DRIVER, szDriverKey, 0, rgchPathOut, MAX_PATH * SQL_FIX, &cbDummy, iType),
											Imsg(imsgODBCInstallDriver), szDriverKey, imsAbort, iType))) ;
	delete szAttr;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCRemoveDriver(IMsiRecord& riParams)
{
	return ODBCRemoveDriverCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCRemoveDriver64(IMsiRecord& riParams)
{
	return ODBCRemoveDriverCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCRemoveDriverCore(IMsiRecord& riParams, ibtBinaryType iType)
{
//  MSIXO(ODBCRemoveDriver, XOT_UPDATE, MSIXA2(DriverKey, Component))
// NOTE: this operator gets called only if the product is the last remaining client of the component    using namespace IxoODBCRemoveDriver;
	riParams.SetNull(0); // remove opcode
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	const ICHAR* szDriverKey = riParams.GetString(IxoODBCRemoveDriver::DriverKey);
	DWORD dwUsageCount;
	BOOL fRemoveDSN = FALSE;

	// Removes values from HKLM\Software\ODBC\ODBCINST.INI,,,  (see SQLInstallDriverEx)
	RollbackODBCINSTEntry(TEXT("ODBC Drivers"), szDriverKey, iType);

	iesEnum iesRet = iesSuccess;

	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLRemoveDriver(szDriverKey, fRemoveDSN, &dwUsageCount, iType),
									Imsg(imsgODBCRemoveDriver), szDriverKey, imsIgnore, iType))) ;
	return iesRet;
	// ODBC will automatically call SQLConfigDriver(..ODBC_REMOVE_DRIVER..) if ref count goes to 0
}

iesEnum CMsiOpExecute::ixfODBCInstallTranslator(IMsiRecord& riParams)
{
	return ODBCInstallTranslatorCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCInstallTranslator64(IMsiRecord& riParams)
{
	return ODBCInstallTranslatorCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCInstallTranslatorCore(IMsiRecord& riParams, ibtBinaryType iType)
{
	using namespace IxoODBCInstallTranslator;
//!! somehow we need to remove the old driver first by calling SQLRemoveDriver repeatedly?
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	int cchAttr;
	ICHAR* szAttr = ComposeDriverKeywordList(riParams, cchAttr);
	DWORD dwUsageCount;
	ICHAR rgchPathOut[MAX_PATH * SQL_FIX];  // we should have checked this already and set directory

	if ( ! szAttr )
		return iesFailure;

	// Writes to HKLM\Software\ODBC\ODBCINST.INI\ODBC Translators, named value
	RollbackODBCINSTEntry(TEXT("ODBC Translators"), riParams.GetString(TranslatorKey), iType);

	iesEnum iesRet;
	WORD cbDummy;
	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLInstallTranslatorEx(cchAttr, szAttr,
									riParams.GetString(IxoODBCInstallTranslator::Folder),
									rgchPathOut, MAX_PATH * SQL_FIX, &cbDummy, ODBC_INSTALL_COMPLETE, &dwUsageCount, iType),
									Imsg(imsgODBCInstallDriver), riParams.GetString(TranslatorKey), imsAbort, iType))) ;
	if (dwUsageCount > 1 && riParams.IsNull(Component))   // reinstall, remove added refcount
		LocalSQLRemoveTranslator(riParams.GetString(TranslatorKey), &dwUsageCount, iType);
	delete szAttr;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCRemoveTranslator(IMsiRecord& riParams)
{
	return ODBCRemoveTranslatorCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCRemoveTranslator64(IMsiRecord& riParams)
{
	return ODBCRemoveTranslatorCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCRemoveTranslatorCore(IMsiRecord& riParams, ibtBinaryType iType)
{
	using namespace IxoODBCRemoveTranslator;
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	const ICHAR* szTranslatorKey = riParams.GetString(TranslatorKey);
	DWORD dwUsageCount;
	BOOL fRemoveDSN = FALSE;

	// Writes to HKLM\Software\ODBC\ODBCINST.INI\ODBC Translators, named value
	RollbackODBCINSTEntry(TEXT("ODBC Translators"), riParams.GetString(TranslatorKey), iType);

	iesEnum iesRet;
	
	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLRemoveTranslator(szTranslatorKey, &dwUsageCount, iType),
								Imsg(imsgODBCRemoveDriver), szTranslatorKey, imsIgnore, iType))) ;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCDataSource(IMsiRecord& riParams)
{
	return ODBCDataSourceCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCDataSource64(IMsiRecord& riParams)
{
	return ODBCDataSourceCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCDataSourceCore(IMsiRecord& riParams, ibtBinaryType iType)
{
//  MSIXO(ODBCDataSource, XOT_UPDATE, MSIXA5(DriverKey, Component, Registration, Attribute_, Value_))
	using namespace IxoODBCDataSource;
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	int iRequest = riParams.GetInteger(Registration);
	ICHAR* szAttr = 0;
	int iField;
	int cFields = riParams.GetFieldCount();
	int cchAttrs = 1;  // extra null at end of attribute string
	for (iField = Args - 2 + 1; iField <= cFields; iField++)
	{
		int cb = riParams.GetTextSize(iField++);
		if (cb)  // skip null attribute names
			cchAttrs += cb + 1 + riParams.GetTextSize(iField) + 1;  // "attr=value\0"
	}
	if (cchAttrs > 1)
	{
		szAttr = new ICHAR[cchAttrs];
		if ( ! szAttr )
			return iesFailure;
		ICHAR* pch = szAttr;
		for (iField = Args - 2 + 1; iField <= cFields; iField++)
		{
			int cb = riParams.GetTextSize(iField++);
			if (cb)  // skip null attribute names
			{
				StringCchCopy(pch, cchAttrs - (pch - szAttr), riParams.GetString(iField-1));
				pch += cb;
				*pch++ = '=';
				cb = riParams.GetTextSize(iField);
				if (cb)
					StringCchCopy(pch, cchAttrs - (pch - szAttr), riParams.GetString(iField));
				else
					*pch = 0;
				pch += cb + 1; // keep null separator
			}
		}
		*pch = 0;  // double null terminator
	}

	const ICHAR* szDriverKey = riParams.GetString(DriverKey);

	// Writes to HKCU\Software\ODBC\ODBC.INI\<Value_>..   Contains subkeys and named values.
	rrkEnum rrkRollbackRoot = (iRequest == ODBC_ADD_DSN || iRequest == ODBC_REMOVE_DSN)
									  ? rrkCurrentUser : rrkLocalMachine;
	const ICHAR* szRollbackKey = riParams.GetString(Value_);
	RollbackODBCEntry(szRollbackKey, rrkRollbackRoot, iType);

	bool fRetry = false;
	iesEnum iesRet;
	BOOL fStat;
	if (iRequest == ODBC_REMOVE_DSN || iRequest == ODBC_REMOVE_SYS_DSN)
	{
		fStat = LocalSQLConfigDataSource((HWND)0, (WORD)iRequest, szDriverKey, 
													szAttr, cchAttrs, iType);
		if (fStat == FALSE)
			DEBUGMSG2(TEXT("Non-fatal error removing ODBC data source %s for driver %s"), szAttr, szDriverKey);
		iesRet = iesSuccess;
	}
	else // ODBC_ADD_DSN || ODBC_ADD_SYS_DSN
	{
		do
		{
			fStat = LocalSQLConfigDataSource((HWND)0, (WORD)iRequest, szDriverKey,
														szAttr, cchAttrs, iType);
			if (fStat == FALSE) // perhaps already exists and we have a old driver
				fStat = LocalSQLConfigDataSource((HWND)0, (WORD)(iRequest + ODBC_CONFIG_DSN - ODBC_ADD_DSN),
															szDriverKey, szAttr, cchAttrs, iType);
		} while (iesSuspend == (iesRet = CheckODBCError(fStat, Imsg(imsgODBCDataSource), riParams.GetString(Value_), imsIgnore, iType)));
	}
	delete [] szAttr;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCDriverManager(IMsiRecord& riParams)
{
	iesEnum iesStat = iesSuccess;
	Bool iState = (Bool)riParams.GetInteger(IxoODBCDriverManager::State);
	if (iState == iMsiNullInteger) // no action required, simply unbind
		return iesSuccess;

	ibtBinaryType iType;
	if ( riParams.GetInteger(IxoODBCDriverManager::BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
		iType = (ibtBinaryType)riParams.GetInteger(IxoODBCDriverManager::BinaryType);

	//this goes in HKLM\Software\ODBC\ODBCINST.INI
	PMsiRegKey pLocalMachine = &m_riServices.GetRootKey(rrkLocalMachine, iType);
	if (!pLocalMachine)
		return iesFailure;

	MsiString strODBCKey = TEXT("Software\\ODBC\\ODBCINST.INI\\ODBC Core");
	PMsiRegKey pODBCKey = &pLocalMachine->CreateChild(strODBCKey);
	if (!pODBCKey)
		return iesFailure;

	Bool fCoreExists = fFalse;
	PMsiRecord pErr = pODBCKey->Exists(fCoreExists);
	if (pErr)
		return iesFailure;

	IMsiRecord& riRollback = GetSharedRecord(IxoRegOpenKey::Args);
	AssertNonZero(riRollback.SetInteger(IxoRegOpenKey::Root, rrkLocalMachine));
	AssertNonZero(riRollback.SetMsiString(IxoRegOpenKey::Key, *strODBCKey));
	AssertNonZero(riRollback.SetInteger(IxoRegOpenKey::BinaryType, iType));
	if (!RollbackRecord(IxoRegOpenKey::Op, riRollback))
		return iesFailure;

	if (iesSuccess != (iesStat = ixfRegOpenKey(riRollback)))
			return iesStat;


	if (fCoreExists && RollbackEnabled())
	{
		// regenerate old values.
		if (iesSuccess != (iesStat = SetRemoveKeyUndoOps(*pODBCKey)))
			return iesStat;
	}

	// delete any new values
	Assert(0 == IxoRegRemoveKey::Args);
	if (!RollbackRecord(IxoRegRemoveKey::Op, riRollback))
		return iesFailure;

	if (iState) // install
	{
		ICHAR rgchPath[MAX_PATH * SQL_FIX];  // ignored, already determined location
		WORD cbDummy;
		return CheckODBCError(LocalSQLInstallDriverManager(rgchPath, MAX_PATH * SQL_FIX, &cbDummy, iType),
									 Imsg(imsgODBCInstallDriverManager), 0, imsOk, iType);
	}
	else  // remove -  we should never really remove it, but we probably want to call it to bump the ref count
	{
		DWORD dwUsageCount;  // we never remove the files, so do we care about this?
		BOOL fStat = LocalSQLRemoveDriverManager(&dwUsageCount, iType);
		return iesSuccess;
	}
}

/*---------------------------------------------------------------------------
ixfControlService: core for starting or stopping services.  
---------------------------------------------------------------------------*/

SC_HANDLE GetServiceHandle(const IMsiString& riMachineName, const IMsiString& riName, const DWORD dwDesiredAccess )
{
	SC_HANDLE hSCManager = WIN::OpenSCManager(riMachineName.GetString(), SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
	DWORD LastError;

	if (!hSCManager)
		return NULL;

	SC_HANDLE hSCService = WIN::OpenService(hSCManager, riName.GetString(), dwDesiredAccess);
	LastError = GetLastError();
	WIN::CloseServiceHandle(hSCManager);
	SetLastError(LastError);

	return hSCService;
}

const IMsiString& GetServiceDisplayName(const IMsiString& riMachineName, const IMsiString& riName)
{
	//It isn't really necessary to keep passing the machine name around.  However, there's no great
	// cost involved, and will allow for less re-engineering if we ever attempt to control services
	// on other machines.

	DWORD cbLength = 0;

	SC_HANDLE hSCManager = WIN::OpenSCManager(riMachineName.GetString(), SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
	if (!hSCManager)
		return MsiString(*TEXT("")).Return();


	WIN::GetServiceDisplayName(hSCManager, riName.GetString(), NULL, &cbLength);
	// should fail, to get size of buffer needed.

	

	// There looks to be a bug in WIN::GetServiceDisplayName.
	// in non-UNICODE builds on NT, it looks to be returning twice the expected number.
	// it could be returning the number of bytes stored internally (which is UNICODE)
	// This isn't particularly a problem, it's just wasted space.

	TCHAR* szDisplayName = new TCHAR[cbLength + sizeof(TCHAR)];

   WIN::GetServiceDisplayName(hSCManager, riName.GetString(), szDisplayName, &cbLength);
	MsiString strDisplayName(szDisplayName);

	delete[] szDisplayName;

	return strDisplayName.Return();
}

DWORD GetServiceState(SC_HANDLE hService)
{
	SERVICE_STATUS SSCurrent;

	WIN::ControlService(hService, SERVICE_CONTROL_INTERROGATE, &SSCurrent);
	
	if (WIN::QueryServiceStatus(hService,  &SSCurrent))
	{
		return SSCurrent.dwCurrentState;
	}
	else return 0;
}

bool CMsiOpExecute::WaitForService(const SC_HANDLE hService, const DWORD dwDesiredState, const DWORD dwFailedState)
{
	// caller is responsible for retrying if they think the other guy is doing work without signalling correctly.

	// WaitForService is responsible for eventually timing out if the service never goes to an expected state.
	DWORD dwCurrentState = 0;

	int cRetry = 0;
	while(dwDesiredState != dwCurrentState)
	{   

		g_MessageContext.DisableTimeout();
		if (!(dwCurrentState = GetServiceState(hService)))
		{
			DWORD dwLastError = WIN::GetLastError();
			g_MessageContext.EnableTimeout();
			return false;
		}
		g_MessageContext.EnableTimeout();

		if (dwFailedState == dwCurrentState)
		{
			return false;
		}

		Sleep(500);
		cRetry++;
		if (cRetry > (30 /*seconds*/ * 1000 /* milliseconds */ / 500 /* number from Sleep before */))
			return false;
	}

	return true;
}
bool CMsiOpExecute::RollbackServiceConfiguration(const SC_HANDLE hSCService, const IMsiString& ristrName, IMsiRecord& riParams)
{
	// Create rollback record before we actually do anything with it.
	// This does *not* include writing appropriate registry keys.
	
	const int cbConfigBuff = 512;
	CAPITempBuffer<char, cbConfigBuff> pchConfigBuff;
	LPQUERY_SERVICE_CONFIG QSCConfigBuff = (LPQUERY_SERVICE_CONFIG) (char*) pchConfigBuff;
	DWORD cbConfigBuffNeeded;

	if (!WIN::QueryServiceConfig(hSCService, QSCConfigBuff, cbConfigBuff, &cbConfigBuffNeeded))
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_FILE_NOT_FOUND == dwLastError)
			return false;
		Assert(ERROR_INSUFFICIENT_BUFFER == dwLastError);
		if (cbConfigBuff < cbConfigBuffNeeded)
		{
			if ( !pchConfigBuff.SetSize(cbConfigBuffNeeded) )
				return false;
			QSCConfigBuff = (LPQUERY_SERVICE_CONFIG) (char*) pchConfigBuff;
			WIN::QueryServiceConfig(hSCService, QSCConfigBuff, cbConfigBuffNeeded, &cbConfigBuffNeeded);
		}
	}


	// To get the description we have to use a different function. This function
	// came to life on Win2K

	const int cbDescriptionBuff = 512;
	CAPITempBuffer<char, cbDescriptionBuff> pchDescriptionBuff;
	LPSERVICE_DESCRIPTION QSCDescriptionBuff = (LPSERVICE_DESCRIPTION) (char*) pchDescriptionBuff;
	DWORD cbDescriptionBuffNeeded;
	MsiString strDescription;
	bool fQueriedDescription = false;
	if (!ADVAPI32::QueryServiceConfig2(hSCService, SERVICE_CONFIG_DESCRIPTION, (LPBYTE)(char*)QSCDescriptionBuff, cbDescriptionBuff, &cbDescriptionBuffNeeded))
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_INVALID_FUNCTION != dwLastError)
		{
			if (ERROR_FILE_NOT_FOUND == dwLastError)
				return false;
			Assert(ERROR_INSUFFICIENT_BUFFER == dwLastError);
			if (cbDescriptionBuff < cbDescriptionBuffNeeded)
			{
				if ( !pchDescriptionBuff.SetSize(cbDescriptionBuffNeeded) )
					return false;
				QSCDescriptionBuff = (LPSERVICE_DESCRIPTION) (char*) pchDescriptionBuff;
				if (ADVAPI32::QueryServiceConfig2(hSCService, SERVICE_CONFIG_DESCRIPTION, (LPBYTE)(char*)QSCDescriptionBuff, cbDescriptionBuffNeeded, &cbDescriptionBuffNeeded))
					fQueriedDescription = true;
			}
		}
	}
	else
	{
		fQueriedDescription = true;
	}
	if (fQueriedDescription)
	{
		strDescription = QSCDescriptionBuff->lpDescription;

		if (strDescription.TextSize() == 0)
		{
			// We need to replace empty string with an embedded NULL. This
			// will force the empty string to be written back during rollback.

			// no DBCS since using an embedded NULL as only char
			ICHAR* pchDescription = strDescription.AllocateString(1, /*fDBCS=*/fFalse);
			pchDescription[0] = 0;
		}
	}

	using namespace IxoServiceInstall;

	AssertNonZero(riParams.SetMsiString(Name, ristrName));
	AssertNonZero(riParams.SetMsiString(DisplayName, *MsiString(QSCConfigBuff->lpDisplayName)));
	AssertNonZero(riParams.SetMsiString(ImagePath, *MsiString(QSCConfigBuff->lpBinaryPathName)));
	AssertNonZero(riParams.SetInteger(ServiceType, QSCConfigBuff->dwServiceType));
	AssertNonZero(riParams.SetInteger(StartType, QSCConfigBuff->dwStartType));
	AssertNonZero(riParams.SetInteger(ErrorControl, QSCConfigBuff->dwErrorControl));
	AssertNonZero(riParams.SetMsiString(LoadOrderGroup, *MsiString(QSCConfigBuff->lpLoadOrderGroup)));
	AssertNonZero(riParams.SetMsiString(Description, *strDescription));

	// dependencies are a double null terminated list...
	ICHAR* pchCounter = QSCConfigBuff->lpDependencies;
	AssertSz(QSCConfigBuff->lpDependencies, "Services dependencies list unexpectedly null.");
	while(NULL != *pchCounter || NULL != *(pchCounter+1))
		pchCounter++;

	MsiString strDependencies;
//  Assert((UINT_PTR)(pchCounter - QSCConfigBuff->lpDependencies +2) < UINT_MAX);   //--merced: we typecast to uint below, it better be in range.
	unsigned int cchDependencies = (unsigned int)(pchCounter - QSCConfigBuff->lpDependencies +2);   //--merced: added (unsigned int)
	// we take the perf hit on Win9X to be able to handle DBCS, on UNICODE -- fDBCS arg is ignored
	// service names are not localized, but it is unknown as to whether or not a service name could start out containing DBCS char
	ICHAR* pchDependencies = strDependencies.AllocateString(cchDependencies, /*fDBCS=*/fTrue);
	memcpy(pchDependencies, QSCConfigBuff->lpDependencies, cchDependencies);
	AssertNonZero(riParams.SetMsiString(Dependencies, *strDependencies));

	// Note:  TagId is only used for purposes of rollback.
	AssertNonZero(riParams.SetInteger(TagId, QSCConfigBuff->dwTagId));
	AssertNonZero(riParams.SetMsiString(StartName, *MsiString(QSCConfigBuff->lpServiceStartName)));
	AssertNonZero(riParams.SetNull(Password));

	return true;
}

bool CMsiOpExecute::DeleteService(IMsiRecord& riInboundParams, IMsiRecord& riUndoParams, BOOL fRollback, IMsiRecord* piActionData)
{
	using namespace IxoServiceControl;
	MsiString strName(riInboundParams.GetMsiString(Name));
	bool fRet = true;

	if (fRollback)
	{
		AssertNonZero(riUndoParams.SetMsiString(Name, *strName));
		AssertNonZero(riUndoParams.SetInteger(Action, isoDelete));
		AssertNonZero(CMsiOpExecute::RollbackRecord(ixoServiceControl, riUndoParams));
	}

	// deleting a service implies you should stop it first...
	// An author may include an explicit stop service before they get to the delete,
	// but there's no sense in making it a requirement when we know the right thing
	// to do.

	// Also, we may not have waited for the service to actually completely stop,
	// so we need to be absolutely sure it's done.

	int iWait = riInboundParams.GetInteger(Wait);

	Bool fChangedInboundRecord = fFalse;
	PMsiRecord pParams(0);
	if (IxoServiceControl::Args != riInboundParams.GetFieldCount())
	{
		fChangedInboundRecord = fTrue;
		const int cFields = IxoServiceControl::Args;
		pParams = &m_riServices.CreateRecord(cFields);
		for (int cCounter = 0; cCounter <= cFields; cCounter++)
		{
			if (riInboundParams.IsInteger(cCounter))
				AssertNonZero(pParams->SetInteger(cCounter, riInboundParams.GetInteger(cCounter)));
			else
				AssertNonZero(pParams->SetMsiData(cCounter, PMsiData(riInboundParams.GetMsiData(cCounter))));
		}
	}
	else
	{
		riInboundParams.AddRef();
		pParams = &riInboundParams;
	}

	
	Assert(IxoServiceControl::Args == pParams->GetFieldCount());
	AssertNonZero(pParams->SetInteger(Wait, 1));
	fRet = StopService(*pParams, riUndoParams, fFalse, piActionData);
	AssertNonZero(pParams->SetInteger(Wait, iWait));
	if (fRet != true)
		return false;

	SC_HANDLE hSCService = GetServiceHandle(*MsiString(pParams->GetMsiString(MachineName)), *strName,
										(DELETE | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG));

	if (!hSCService)
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_SERVICE_DOES_NOT_EXIST == dwLastError)
			return true;
		else
			return false;
	}

#ifdef DEBUG
	ICHAR szRegData[255];
	StringCchPrintf(szRegData, (sizeof(szRegData)/sizeof(ICHAR)), TEXT("System\\CurrentControlSet\\Services\\%s"), (const ICHAR*) strName);
	PMsiRegKey pRegKey = &m_riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same location 
	pRegKey = &pRegKey->CreateChild(szRegData);
	Bool fServiceKeyExists = fFalse;
	PMsiRecord pErr = pRegKey->Exists(fServiceKeyExists);
	Assert(fServiceKeyExists);
#endif

	IMsiRecord& riInstallParams = GetSharedRecord(IxoServiceInstall::Args);
	bool fRollbackStatus = RollbackServiceConfiguration(hSCService, *strName, riInstallParams);

	if (WIN::DeleteService(hSCService))
	{
		// register the rollback
		if (fRollbackStatus)
			RollbackRecord(ixoServiceInstall, riInstallParams);
	}
	else
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_SERVICE_MARKED_FOR_DELETE != dwLastError)
			fRet = false;
	}

	WIN::CloseServiceHandle(hSCService);

	return fRet;
}

ICHAR** CMsiOpExecute::NewArgumentArray(const IMsiString& ristrArguments, int& cArguments)
{
	cArguments = 0;

	ICHAR* pchArguments = (ICHAR*) ristrArguments.GetString();
	int cchArguments = ristrArguments.CharacterCount();

	// First, determine number of arguments for size of array
	if (0 != cchArguments)
	{
		for (int cCounter = 0; cCounter <= cchArguments; cCounter++)
		{
			if (NULL != *pchArguments)
				pchArguments = INextChar(pchArguments);
			else
			{
				cArguments++;
				pchArguments++;
			}
		}
	}

	ICHAR** pszArguments;
	if (cArguments)
		pszArguments = new ICHAR*[cArguments];
	else
		pszArguments = NULL;

	// next, fill in the pointers to each substring within the packed string.
	if (cArguments)
	{
		if ( ! pszArguments )
			return NULL;
		pchArguments = (ICHAR*) ristrArguments.GetString();
		pszArguments[0] = pchArguments;
		for (int cCounter = 1; cCounter < cArguments; cCounter++)
		{
			while(NULL != *pchArguments)
			{
				pchArguments = INextChar(pchArguments);
			}
			pszArguments[cCounter] = ++pchArguments;
		}
	}
	return pszArguments;
}

bool CMsiOpExecute::StartService(IMsiRecord& riParams, IMsiRecord& riUndoParams, BOOL fRollback)
{   
	using namespace IxoServiceControl;

	MsiString strName(riParams.GetMsiString(Name));

	bool fRet = true;

	if (fRollback)
	{
		// create a rollback script to startup the described service
		AssertNonZero(riUndoParams.SetMsiString(Name, *strName));
		AssertNonZero(riUndoParams.SetInteger(Action, isoStart));
		AssertNonZero(CMsiOpExecute::RollbackRecord(ixoServiceControl,riUndoParams));

		return iesSuccess;
	}

	SC_HANDLE hSCService = GetServiceHandle(*MsiString(riParams.GetMsiString(MachineName)), *strName,
										(SERVICE_START | SERVICE_QUERY_STATUS));


	if (!hSCService)
		return false;

	int cArguments = 0;
	MsiString strArguments(riParams.GetMsiString(StartupArguments));
	ICHAR** pszArguments = NewArgumentArray(*strArguments, cArguments);

	UINT iCurrMode = WIN::SetErrorMode(0);
	WIN::SetErrorMode(iCurrMode & ~SEM_FAILCRITICALERRORS);
	if (WIN::StartService(hSCService, cArguments, (const ICHAR**) pszArguments))
	{
		// Rollback info.
		StopService(riParams, riUndoParams, fTrue);
	}
	else
	{
		DWORD dwLastError = WIN::GetLastError();

		if (ERROR_SERVICE_ALREADY_RUNNING != dwLastError)
		{
			delete[] pszArguments;
			AssertNonZero(WIN::CloseServiceHandle(hSCService));

			WIN::SetErrorMode(iCurrMode);
			WIN::SetLastError(dwLastError);
			return false;
		}
		// If the SCM is in a locked state, we'll wait and retry through the automated mechanism.
		
		// If the service startup times out (ERROR_SERVICE_REQUEST_TIMEOUT,) we'll
		// provide abort/retry/ignore mechanism through the main ixfServiceControl mechanism.
	}

	delete[] pszArguments;
	WIN::SetErrorMode(iCurrMode);
	
	if (riParams.GetInteger(Wait))
	{
		fRet = WaitForService(hSCService, SERVICE_RUNNING, SERVICE_STOPPED);
	}

	AssertNonZero(WIN::CloseServiceHandle(hSCService));

	return fRet;
}

bool CMsiOpExecute::StopService(IMsiRecord& riParams, IMsiRecord& riUndoParams, BOOL fRollback, IMsiRecord* piActionData)
{   
	using namespace IxoServiceControl;

	bool fRet = true;

	MsiString strName(riParams.GetMsiString(Name));

	if (fRollback)
	{
		// create a rollback script to stop the described service
		AssertNonZero(riUndoParams.SetMsiString(Name, *strName));
		AssertNonZero(riUndoParams.SetInteger(Action, isoStop));
		if (!RollbackRecord(ixoServiceControl,riUndoParams))
			return false;
		else
			return true;
	}

	SC_HANDLE hSCService = GetServiceHandle(*MsiString(riParams.GetMsiString(MachineName)), *strName,
										(SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS));  

	if (!hSCService)
	{
		if (ERROR_SERVICE_DOES_NOT_EXIST == WIN::GetLastError())
		{
			return true;
		}
		else
			return false;
	}

	SERVICE_STATUS SSControl;
	if (WIN::ControlService(hSCService, SERVICE_CONTROL_STOP, &SSControl))      
	{
		// Rollback info.
		StartService(riParams, riUndoParams, fTrue);
	}
	else
	{
		DWORD dwLastError = WIN::GetLastError();

		if  (   (ERROR_SERVICE_NOT_ACTIVE == dwLastError) ||
				(ERROR_SERVICE_NEVER_STARTED == dwLastError) ||
				(ERROR_SERVICE_DOES_NOT_EXIST == dwLastError)
			)
		{
			WIN::CloseServiceHandle(hSCService);
			return true;
		}


		// if there are any dependent services running, we need to shut those down first, and retry.

		if (ERROR_DEPENDENT_SERVICES_RUNNING == dwLastError)
		{
			// enumerate the dependent services, and call StopService on those.
			// Note that this becomes a recursive call, working its way through the tree.
			// This shouldn't be very deep.

			fRet = true;

			DWORD cbNeeded = 0;
			DWORD cServices = 0;

			WIN::EnumDependentServices(hSCService, SERVICE_ACTIVE, NULL, 0, &cbNeeded, &cServices);
			DWORD dwLastError = WIN::GetLastError();
			if ((ERROR_MORE_DATA==dwLastError) && cbNeeded)
			{
				ENUM_SERVICE_STATUS* ssServices= (ENUM_SERVICE_STATUS*) new byte[cbNeeded];
				
				MsiString strDisplayName(piActionData->GetMsiString(1));
				if (WIN::EnumDependentServices(hSCService, SERVICE_ACTIVE, ssServices, cbNeeded, &cbNeeded, &cServices))
				{
					Assert(cServices);
					MsiString strDisplayName(piActionData->GetMsiString(1));
					for (int cCounter = 0; cCounter < cServices; cCounter++)
					{
						AssertNonZero(riParams.SetString(Name, ssServices[cCounter].lpServiceName));
						AssertNonZero(piActionData->SetString(1, ssServices[cCounter].lpDisplayName));
						AssertNonZero(piActionData->SetString(2, ssServices[cCounter].lpServiceName));

						if (false == (fRet = StopService(riParams, riUndoParams, fFalse, piActionData)))
						{
							break;
						}
						
					}
				}
				else
				{
					DWORD dwLastError = WIN::GetLastError();
					Assert(ERROR_MORE_DATA != dwLastError);
					fRet = false;
					WIN::SetLastError(dwLastError);
				}

				delete[] ssServices;
				AssertNonZero(riParams.SetMsiString(Name, *strName));
				AssertNonZero(piActionData->SetMsiString(1, *strDisplayName));
				AssertNonZero(piActionData->SetMsiString(2, *strName));
			}

			// try calling ourself one last time.  One of the dependent services might have
			// failed to stop, but if we can stop the one we came here for, we consider
			// it a success.
			if (false == (fRet = StopService(riParams, riUndoParams, fFalse, piActionData)))
			{
				dwLastError = WIN::GetLastError();
				Assert(ERROR_DEPENDENT_SERVICES_RUNNING != dwLastError);
				WIN::SetLastError(dwLastError);
			}

		}
		// If the SCM is in a locked state, we'll wait and retry through the automated mechanism.
		// if the service request times out, we'll retry via the automatic retry mechanism.
	}
	
#ifdef DEBUG
	// This detects a service that did not properly update its status with the SCM.
	// The common repro scenario is that sometimes you'll hit this assert, sometimes you won't.
	// Generally retrying the failure will work the second time (as the service finishes
	// what it was doing, and the retry detects it as being stopped.)
	DWORD dwServiceState = WIN::GetServiceState(hSCService);
	//Assert((SERVICE_STOP_PENDING == dwServiceState) || (SERVICE_STOPPED == dwServiceState));
#endif
	

	if (riParams.GetInteger(Wait))
	{
		fRet = WaitForService(hSCService, SERVICE_STOPPED, SERVICE_RUNNING);
	}

	AssertNonZero(WIN::CloseServiceHandle(hSCService));

	return fRet;
}

iesEnum CMsiOpExecute::ixfServiceControl(IMsiRecord& riParams)
{
	// core function for start, stop

	// this needs to be a common function to keep as much information about a service
	// available when starting or stopping.

	// Example:  If you stop a service, and rollback wants to restart it, you need to have
	// the startup arguments available.

	using namespace IxoServiceControl;
	MsiString strName(riParams.GetMsiString(Name));
	int iWaitForService = riParams.GetInteger(Wait);
	bool fRet = true;
	isoEnum isoControl = isoEnum(riParams.GetInteger(Action));


	DWORD dwErrorControl = 0;
	Bool fServiceKeyExists = fFalse;

	PMsiRecord pError(0);

	ICHAR szRegData[255];
	StringCchPrintf(szRegData, (sizeof(szRegData)/sizeof(ICHAR)), TEXT("System\\CurrentControlSet\\Services\\%s"), (const ICHAR*) strName);
	PMsiRegKey pRegKey = &m_riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same location 
	pRegKey = &pRegKey->CreateChild(szRegData);

	pError = pRegKey->Exists(fServiceKeyExists);

	// a very quick short-circuit to avoid mucking around with the
	// service control manager.

	if (!fServiceKeyExists && (isoStop == isoControl || isoDelete == isoControl))
		return iesSuccess;


	MsiString strErrorControl;
	if (fServiceKeyExists)
		pError = pRegKey->GetValue(TEXT("ErrorControl"), *&strErrorControl);

	// the regkey object prefaces DWORD values with #
	if (strErrorControl.Compare(iscStart, TEXT("#")))
	{
		strErrorControl = strErrorControl.Extract(iseAfter, TEXT('#'));
		dwErrorControl = strErrorControl;
	}
	else
		dwErrorControl = 0;

	

	enum enumServiceSeverity
	{
		eServiceIgnorable,
		eServiceNormal,
		eServiceCritical
	} eServiceSeverity;

	if (iWaitForService)
		eServiceSeverity = eServiceCritical;
	else if (fServiceKeyExists)
	{
		switch (dwErrorControl)
		{
			case SERVICE_ERROR_IGNORE:
					eServiceSeverity = eServiceIgnorable;
					break;
			case SERVICE_ERROR_NORMAL:
					eServiceSeverity = eServiceNormal;
					break;
			default:
					eServiceSeverity = eServiceCritical;
					break;
		}
	}
	else
		eServiceSeverity = eServiceNormal;

	if ((eServiceCritical == eServiceSeverity) && (m_ixsState == ixsRollback))
	{
		// no critical errors in rollback
		eServiceSeverity = eServiceNormal;
	}
	
	// a common record passed through for Undo.
	// Based on the action taken, the Action will vary.
	IMsiRecord& riUndoParams = GetSharedRecord(Args);
	AssertNonZero(riUndoParams.SetMsiString(MachineName,*MsiString(riParams.GetMsiString(MachineName))));


	AssertNonZero(riUndoParams.SetNull(Name));
	AssertNonZero(riUndoParams.SetNull(Action));
	AssertNonZero(riUndoParams.SetInteger(Wait,iWaitForService));
	AssertNonZero(riUndoParams.SetMsiString(StartupArguments, *MsiString(riParams.GetMsiString(StartupArguments))));


	// Record for messages
	PMsiRecord pActionData = &m_riServices.CreateRecord(2);
	
	MsiString strDisplayName(GetServiceDisplayName(*MsiString(riParams.GetMsiString(MachineName)), *strName));  
	if (!strDisplayName.CharacterCount())
			strDisplayName = strName;

	AssertNonZero(pActionData->SetMsiString(1,*strDisplayName));
	AssertNonZero(pActionData->SetMsiString(2,*strName));

	Bool fRetry = fTrue;
	imsEnum imsResponse = imsNone;

	imtEnum imtButtons;
	
	switch(eServiceSeverity)
	{
		case eServiceIgnorable:
			imtButtons = imtEnum(imtInfo);
			break;
		case eServiceNormal:
			imtButtons = imtEnum(imtError + imtAbortRetryIgnore + imtDefault3);
			break;
		case eServiceCritical:
			imtButtons = imtEnum(imtError + imtRetryCancel + imtDefault1);
			break;
		default:
			imtButtons = imtEnum(imtInfo);
			Assert(0);
	}
	if(Message(imtActionData, *pActionData) == imsCancel)
		return iesUserExit;

	// counter for automated retry.
	// This gives services that do not update their status with the SCM correctly
	// a chance to finish before reporting an error to the user.
	int cRetry = 0;
	while (fRetry)
	{
		if (cRetry)
		{
			// in an automatic retry.
			// wait a little before trying again.

			// note that WaitForService can pause for a long time as well in the service
			// requests.  This gives a pause between tries if the service is immediately
			// going to the failure state.

			// WaitForService gives the service time to do its thing, and eventually gives
			// up waiting.

			// Scenarios:
			//      Service immediately reports failure to be controlled:
			//          WaitForService immediately returns, and we retry here for 30 seconds.
			//      Service reports an unexpected state, and never enters the expected states.
			//          WaitForService times out after 30 seconds,
			//          We retry here 6 times, plus the 30 second total delay for all the retries
			//              A total time out of 3 1/2 minutes.
			WIN::Sleep(5 * 1000);
		}
		cRetry++;
		fRetry = fFalse;
		imsResponse = imsNone;

		g_MessageContext.DisableTimeout();
		switch(isoControl)
		{
			case isoStart:
				fRet = StartService(riParams, riUndoParams, fFalse);
				break;
			case isoStop:
				fRet = StopService(riParams, riUndoParams, fFalse, pActionData);
				break;
			case isoDelete:
				fRet = DeleteService(riParams, riUndoParams, fFalse, pActionData);
				break;
			default:
				Assert(0);
				// ERROR!
				break;
		}
		g_MessageContext.EnableTimeout();

		if (false == fRet)
		{

			// Set up any specific information for the error message here.
			// One possibility is querying the service status for the Win32 exit codes, and the
			// service specific error code if we want to provide additional information about
			// why the service control failed.

			// after performing automated retry, ask the user for input.
			// reset the automated retry count.
			if (cRetry > 6)
			{
				cRetry = 0;
				switch(isoControl)
				{
					case isoStart:
						imsResponse = DispatchError(imtButtons, Imsg(imsgOpStartServiceFailed), *strDisplayName, *strName);
						break;
					case isoStop:
						imsResponse = DispatchError(imtButtons, Imsg(imsgOpStopServiceFailed), *strDisplayName, *strName);
						break;
					case isoDelete:
						imsResponse = DispatchError(imtButtons, Imsg(imsgOpDeleteServiceFailed), *strDisplayName, *strName);
						break;
					default:
						//ERROR!
						Assert(0);
						break;

				}
			}
			// automatically retry the first couple of times.
			else imsResponse = imsRetry;
		}

		switch (imsResponse)
		{
			case imsNone:
			case imsIgnore:
				fRet = true;
				break;
			case imsRetry:
				fRetry = fTrue;
			default:
				break;
		}
	}

	return fRet ? iesSuccess : iesFailure;
}

iesEnum CMsiOpExecute::ixfServiceInstall(IMsiRecord& riParams)
{
	
	using namespace IxoServiceInstall;
	MsiString strName(riParams.GetMsiString(Name));
	MsiString strDisplayName(riParams.GetMsiString(DisplayName));
	iesEnum iesStatus = iesFailure;
	Bool fServiceKeyExists = fFalse;
	Bool fServiceExists = fFalse;

	PMsiRecord pError(0);

	ICHAR szRegData[255];
	StringCchPrintf(szRegData, (sizeof(szRegData)/sizeof(ICHAR)), TEXT("System\\CurrentControlSet\\Services\\%s"), (const ICHAR*) strName);
	PMsiRegKey pRegKey = &m_riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same location 
	pRegKey = &pRegKey->CreateChild(szRegData);

	pError = pRegKey->Exists(fServiceKeyExists);

	SC_HANDLE hSCManager = WIN::OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

	if (!hSCManager)
	{
		imtEnum imtButtons = imtEnum(imtError + imtOk + imtDefault1);
		imsEnum imsResponse = DispatchError(imtButtons, Imsg(imsgOpInstallServiceFailed), *strDisplayName, *strName);

		return iesFailure;
	}

	DWORD dwErrorControl = riParams.GetInteger(ErrorControl);
	Bool fVital = (dwErrorControl & msidbServiceInstallErrorControlVital) ? fTrue : fFalse;
	if (fVital)
		dwErrorControl -= msidbServiceInstallErrorControlVital;

	Bool fRetry = fTrue;

#ifdef DEBUG
const ICHAR* szImagePath = riParams.GetString(ImagePath);
#endif

	const ICHAR* szStartName = riParams.GetString(StartName);

while(fRetry)
	{
		g_MessageContext.DisableTimeout();

		SC_HANDLE hService = GetServiceHandle(*MsiString(TEXT("")), *strName,
					(SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG)); 

		IMsiRecord* piRollbackParams = 0;
		bool fRollbackStatus = true;
		if (!hService)
		{
			fServiceExists = fFalse;
			// install a brand new service
			hService = WIN::CreateService(hSCManager, strName, strDisplayName, STANDARD_RIGHTS_REQUIRED|SERVICE_CHANGE_CONFIG,
				riParams.GetInteger(ServiceType), riParams.GetInteger(StartType), dwErrorControl,
				riParams.GetString(ImagePath), riParams.GetString(LoadOrderGroup), 0,
				riParams.GetString(Dependencies), szStartName, riParams.GetString(Password));

			if (hService)
			{
				// Need to now set the description

				SERVICE_DESCRIPTION serviceDescription;
				serviceDescription.lpDescription = const_cast<ICHAR*>(riParams.GetString(Description));

				BOOL fRet = ADVAPI32::ChangeServiceConfig2(hService,
																		 SERVICE_CONFIG_DESCRIPTION,
																		 &serviceDescription);
				if (!fRet && (ERROR_INVALID_FUNCTION != GetLastError()))
					DispatchError(imtInfo, Imsg(imsgServiceChangeDescriptionFailed), *strDisplayName, *strName);
				
			}
			// We can roll back later, since it's just a delete.
		}
		else
		{
			// We have to generate the rollback record now, so that we don't lose the current
			// information.

			fServiceExists = fTrue;
			piRollbackParams = &GetSharedRecord(IxoServiceInstall::Args);

			fRollbackStatus = RollbackServiceConfiguration(hService, *strName, *piRollbackParams);

			if (!WIN::ChangeServiceConfig(hService, riParams.GetInteger(ServiceType),
				riParams.GetInteger(StartType), dwErrorControl, riParams.GetString(ImagePath),
				riParams.GetString(LoadOrderGroup), 0, riParams.GetString(Dependencies),
				riParams.GetString(StartName), riParams.GetString(Password), strDisplayName))
			{
				WIN::CloseServiceHandle(hService);
				hService = 0;
			}
			else // first config succeeded
			{
				// Need to configure again to set the description

				MsiString strDescription = riParams.GetMsiString(Description);
				const ICHAR* szDescription = 0; // default to not touching the description
				if (strDescription.TextSize())
				{
					szDescription = (const ICHAR*)strDescription;
					if (*szDescription == 0)
						szDescription = TEXT(""); // we have an embedded null -- delete any existing description
				}

				SERVICE_DESCRIPTION serviceDescription;
				serviceDescription.lpDescription = const_cast<ICHAR*>(szDescription);

				BOOL fRet = ADVAPI32::ChangeServiceConfig2(hService,
																		 SERVICE_CONFIG_DESCRIPTION,
																		 &serviceDescription);
				if (!fRet && (ERROR_INVALID_FUNCTION != GetLastError()))
					DispatchError(imtInfo, Imsg(imsgServiceChangeDescriptionFailed), *strDisplayName, *strName);

			}
		}
		g_MessageContext.EnableTimeout();

		if (hService)
		{
			iesStatus = iesSuccess;
			fRetry = fFalse;
			if (!fServiceExists)
			{
				// Rollback
				// Basically, just deletes one if we actually installed it.  We don't currently
				// handle "configuring" and then "re-configuring"
				using namespace IxoServiceControl;
				piRollbackParams = &GetSharedRecord(IxoServiceControl::Args);
				AssertNonZero(piRollbackParams->SetNull(MachineName));
				AssertNonZero(piRollbackParams->SetMsiString(IxoServiceControl::Name, *strName));
				AssertNonZero(piRollbackParams->SetInteger(Action, isoDelete));
				AssertNonZero(piRollbackParams->SetNull(Wait));
				AssertNonZero(piRollbackParams->SetNull(StartupArguments));

				if (!RollbackRecord(ixoServiceControl, *piRollbackParams))
					iesStatus = iesFailure;
			}
			else
			{
				if (fRollbackStatus)
					if (!RollbackRecord(ixoServiceInstall, *piRollbackParams))
						iesStatus = iesFailure;
			}

			WIN::CloseServiceHandle(hService);
		}
		else
		{
			imtEnum imtButtons;
			
			DWORD dwLastError = WIN::GetLastError();

			if (szStartName && (m_ixsState == ixsRollback))
			{
				// in Rollback, failure to re-install a service with a user name
				// means that we probably lost the password.  The author should
				// have written a custom action that fired before this,
				// and our subsequent entry here would have automatically succeeded.
				imtButtons = imtEnum(imtInfo);
			}
			else if (fVital)
				imtButtons = imtEnum(imtError + imtRetryCancel + imtDefault1);
			else
			{
				switch(dwErrorControl)
				{
					case SERVICE_ERROR_IGNORE:
						imtButtons = imtEnum(imtInfo);
						break;
					case SERVICE_ERROR_NORMAL:          
						imtButtons = imtEnum(imtError + imtAbortRetryIgnore + imtDefault3);
						break;
					case SERVICE_ERROR_SEVERE:
					case SERVICE_ERROR_CRITICAL:
						imtButtons = imtEnum(imtError + imtRetryCancel + imtDefault1);
						break;
					default:
						AssertSz(0, "Services:  Bad Error Control value");
						imtButtons = imtEnum(imtInfo);
						break;
				}
			}

			imsEnum imsResponse = DispatchError(imtButtons, Imsg(imsgOpInstallServiceFailed), *strDisplayName, *strName);

			if (imsResponse != imsRetry)
				fRetry = fFalse;

			if ((imsIgnore == imsResponse) || (imsNone == imsResponse))
				iesStatus = iesSuccess;
			else
				iesStatus = iesFailure;
		}
	}


	WIN::CloseServiceHandle(hSCManager);
	return iesStatus;
}

iesEnum CMsiOpExecute::ixfRegAllocateSpace(IMsiRecord& riParams)
{
	using namespace IxoRegAllocateSpace;

	int iIncrementKB = riParams.GetInteger(Space);

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetInteger(1, iIncrementKB));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	if(!g_fWin9X && iIncrementKB != iMsiNullInteger) // only on WinNT
	{
		for(;;)
		{
			if(!IncreaseRegistryQuota(iIncrementKB))
			{
				switch(DispatchError(imtEnum(imtError + imtRetryCancel + imtDefault1), Imsg(imsgOutOfRegistrySpace), iIncrementKB))
				{
				case imsRetry:
					continue;
				default: // imsCancel, imsNone
					return iesFailure;
				}
			}
			break; // success
		}
	}
	return iesSuccess;
}

bool CMsiOpExecute::InitializeWindowsEnvironmentFiles(const IMsiString& ristrAutoExecPath, /*out*/ int &iFileAttributes)
{
	// make sure to protect the autoexec until the last possible moment.
	// If the system dies and we leave a corrupt autoexec, *very* bad things will
	// happen.

	// Logic to find the autoexec path is all located in shared.cpp.
	// There is also an environment variable WIN95_ENVIRONMENT_TEST that
	// allows this to be placed someplace else for testing or admin needs.

	// also, we should try to avoid copying the autoexec.bat over and over.  For the
	// moment, it's probably okay since they won't be making more than a few changes.
	// We'll save the autoexec.bat file off, and set the global state to make sure
	// we don't issue more than one rollback op, or make too many backups.

	PMsiRecord pErr(0);
	m_strEnvironmentFile95 = TEXT("AutoExec.bat");

	if ((pErr = m_riServices.CreatePath(ristrAutoExecPath.GetString(), *&m_pEnvironmentPath95)))
		return false;

	MsiString strAutoExec;
	pErr = m_pEnvironmentPath95->GetFullFilePath(m_strEnvironmentFile95, *&strAutoExec);
	Bool fAutoExecExists;
	Bool fWritable;

	if ((pErr = m_pEnvironmentPath95->FileExists(m_strEnvironmentFile95, fAutoExecExists)))
		return false;

	if (!fAutoExecExists)
	{
		HANDLE hAutoexec = INVALID_HANDLE_VALUE;
		if (INVALID_HANDLE_VALUE == (hAutoexec = WIN::CreateFile(strAutoExec, GENERIC_WRITE,
			0,
			NULL, CREATE_NEW, (FILE_ATTRIBUTE_ARCHIVE|(SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), NULL)))
			return false;

		WIN::CloseHandle(hAutoexec);
		if ((pErr = m_pEnvironmentPath95->FileExists(m_strEnvironmentFile95, fAutoExecExists)))
			return false;
	}
	AssertSz(fAutoExecExists, TEXT("AUTOEXEC.BAT should exist at this point!"));

	if ((pErr = m_pEnvironmentPath95->FileWritable(m_strEnvironmentFile95, fWritable)))
		return false;

	if (fAutoExecExists)
	{
		if ( RollbackEnabled() )
		{
			// backup file with its original file attributes intact.

			// this function might actually put up another error of their own, in which case we may
			// get two errors
			if (iesSuccess != BackupFile(*m_pEnvironmentPath95, *m_strEnvironmentFile95, fFalse, fFalse, iehShowNonIgnorableError))
				return false;
		}

		pErr = m_pEnvironmentPath95->GetAllFileAttributes(m_strEnvironmentFile95, iFileAttributes);
	}

	if (!(fAutoExecExists && fWritable))
	{
		// try making the autoexec file writable.
		const iUnwritableFlags = FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
		if (!pErr && (iFileAttributes & iUnwritableFlags))
		{
			int iNewFileAttributes = iFileAttributes &~ iUnwritableFlags;
			pErr = m_pEnvironmentPath95->SetAllFileAttributes(m_strEnvironmentFile95, iNewFileAttributes);
			if (!pErr)
			{
				pErr = m_pEnvironmentPath95->FileWritable(m_strEnvironmentFile95, fWritable);
			}
		}

		if (pErr || !fWritable)
		{
			Message(imtInfo, *PMsiRecord(PostError(Imsg(idbgFileNotWritable), *strAutoExec)));
			return false;
		}
	}

	m_pEnvironmentWorkingPath95 = m_pEnvironmentPath95;
	pErr = m_pEnvironmentWorkingPath95->TempFileName(TEXT("Auto"), NULL, fTrue, *&m_strEnvironmentWorkingFile95, 0);
	// !! this file will get cleaned up automatically by runscript completing (CMsiExecute::ClearExecutorData).  However, should we put it in the
	// rollback script as well, in case we crash?

	if (pErr)
		return false;

	if (fAutoExecExists)
	{
		// create a working copy of the file

		// this function might actually put up another error of their own, in which case we may
		// get two errors
		if (iesSuccess != CopyOrMoveFile(*m_pEnvironmentPath95, *m_pEnvironmentWorkingPath95,
						*m_strEnvironmentFile95, *m_strEnvironmentWorkingFile95, fFalse, fFalse, fFalse, iehShowNonIgnorableError))
			return false;
	}

	return true;
}

const ICHAR* SkipWhiteSpace(const ICHAR* const szBuf)
{
	const ICHAR* pchCurrent = szBuf;
	if (!pchCurrent)
		return NULL;

	while((' ' == *pchCurrent) || ('\t' == *pchCurrent))
				pchCurrent = ICharNext(pchCurrent);

	return pchCurrent;
}

bool CMsiOpExecute::UpdateWindowsEnvironmentStrings(IMsiRecord& riParams)
{
	// the 9X and NT versions are wildly different.
	// 9X must update the autoexec.bat
	PMsiRecord pErr(0);

	using namespace IxoUpdateEnvironmentStrings;
	MsiString strName(riParams.GetMsiString(Name));
	MsiString strValue(riParams.GetMsiString(Value));
	iueEnum iueAction = iueEnum(riParams.GetInteger(Action));

	// Note that we don't support multi-character delimiters.
	ICHAR chDelimiter = TEXT('\0');
	if (!riParams.IsNull(Delimiter))
		chDelimiter = *riParams.GetString(Delimiter);


	static int iFileAttributes = 0;
	if (0 == m_strEnvironmentWorkingFile95.TextSize())
	{
		if (!InitializeWindowsEnvironmentFiles(*MsiString(riParams.GetMsiString(AutoExecPath)), iFileAttributes))
		{
			DEBUGMSGV(TEXT("Cannot initialize the autoexec.bat and rollback files."));
			return false;
		}
	}

	CFileRead InFile(CP_ACP);
	if (!InFile.Open(*m_pEnvironmentPath95, m_strEnvironmentFile95))
	{
		MsiString strFile;
		AssertRecord(m_pEnvironmentPath95->GetFullFilePath(m_strEnvironmentFile95, *&strFile));
		Message(imtInfo, *PMsiRecord(PostError(Imsg(idbgErrorOpeningFileForRead), WIN::GetLastError(), strFile)));
		return false;
	}

	// open the working file.  It may not exist, in which case we can just simply create it on the fly.
	MsiString strWorkingFile;
	AssertRecord(m_pEnvironmentWorkingPath95->GetFullFilePath(m_strEnvironmentWorkingFile95, *&strWorkingFile));

	CFileWrite OutFile(CP_ACP);
	if (!OutFile.Open(*m_pEnvironmentWorkingPath95, m_strEnvironmentWorkingFile95))
	{
		Message(imtInfo, *PMsiRecord(PostError(Imsg(idbgErrorOpeningFileForWrite), WIN::GetLastError(), strWorkingFile)));
		return false;
	}


	// read the named value, copying the stuff we don't want over to the working file.
	MsiString strCurrentValue;
	MsiString strInFileLine;
	ICHAR chResult;

	const ICHAR chQuietPrefix = TEXT('@');
	const ICHAR *const szSetPrefix = TEXT("SET");

	MsiString strSetName;
	

	const int cchSetPrefix = IStrLen(szSetPrefix);

	// look for the line referring to the variable we want to change.
	// write everything else to the output file.

		// Format: [set] name = value
		//     note:  whitespace could be anywhere for robustness.

		// acceptable forms:
		//   path =foo
		//   path=foo
		//   set path =bar
		//   set path=bar
		//  note: a value name could contain spaces, but this is simply covered
		//        when comparing the value name.

		// unacceptable:
		//   comment comment comment
		//   set = foo
		//   path blah = foo

	bool fNameFound = false;
	bool fValid = true;

	while ((chResult = InFile.ReadString(*&strInFileLine)))
	{
		// fNameFound true when we have a name/value pair recognized to modify
		fNameFound = false;

		// fValid set to false if the line is malformed prior to the name=value pair
		// for example, when we skip over the "set" part, we need a space after it
		// valid:    set name=value
		// invalid:  setname=value
		fValid = true;


		const ICHAR* pchInString = strInFileLine;

		pchInString = SkipWhiteSpace(pchInString);
		
		// @ at the beginning of the line indicates that echo should
		// be off for the duration of the command.
		if (chQuietPrefix == *pchInString)
		{
			pchInString = CharNext(pchInString);
			pchInString = SkipWhiteSpace(pchInString);
		}

		// skip the set, and any blanks after it.
		if (MsiString(pchInString).Compare(iscStartI, szSetPrefix))
		{
				pchInString += cchSetPrefix;        

				const ICHAR* pchPreviousSpot = pchInString;
				pchInString = SkipWhiteSpace(pchInString);

				// require white space between the set and the name.
				// expects set <name>.  Avoids set<name>
				if (pchPreviousSpot == pchInString)
					fValid = false;
		}


		if (fValid && MsiString(pchInString).Compare(iscStartI, strName))
		{
			// now at the name, or it isn't what we're looking for.
			pchInString += strName.TextSize();
			pchInString = SkipWhiteSpace(pchInString);

			// now find the equal as the very next thing.
			if (TEXT('=') == *pchInString)
			{
				strSetName = strInFileLine.Extract(iseIncluding, TEXT('='));
				fNameFound = true;
			}
		}

		if (!fValid || !fNameFound)
		{
			if (!OutFile.WriteMsiString(*strInFileLine, fTrue))
			{
				Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
				return false;
			}
		}
		else
			break;
	}


	// if chResult, then we've found a line to modify.  Otherwise, we're at the end of the file.
	// strSetName contains the front half of the line, up to the value.
	if (chResult)
	{
		// munge it as necessary

		strCurrentValue = strInFileLine.Extract(iseAfter, TEXT('='));
		MsiString strResult;
		if (RewriteEnvironmentString(iueAction, chDelimiter, *strCurrentValue, *strValue, *&strResult))
		{   
			// write the named value back to the working file.
			if (strResult.TextSize())
			{
				strSetName+=strResult;
				if (!OutFile.WriteMsiString(*strSetName, fTrue))
				{
					Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
					return false;
				}
			}
			// else drop the line from the file.
		}

		// finish copying the rest of the file
		while (InFile.ReadString(*&strInFileLine))
		{
			if (!OutFile.WriteMsiString(*strInFileLine, fTrue))
			{
				Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
				return false;
			}
		}
	}
	else
	{
		// If the value wasn't found, add it as necessary.
		if (!(iueRemove & iueAction))
		{
			// there was no entry in the file, so
			// we have to create the
			//      SET name=
			strSetName = szSetPrefix;
			strSetName += MsiChar(' ');
			strSetName += strName;
			strSetName += MsiChar('=');

			if (iueAction & (iuePrepend | iueAppend))
			{
				// We expected to append or prepend something to the variable, but didn't find
				// one that we recognize.  Just in case, though, we'll create the new line to
				// reference any current value that might have snuck through.  Overwriting a valid
				// variable, especially the path, could leave the system unbootable.
				Assert(chDelimiter);
				
				if (iuePrepend & iueAction)
				{
					strSetName+=strValue;
					strSetName+= MsiChar(chDelimiter);
				}   

				strSetName += TEXT("%");
				strSetName += strName;
				strSetName += TEXT("%");

				if (iueAppend & iueAction)
				{
					strSetName += MsiChar(chDelimiter);
					strSetName += strValue;
				}
			}
			else
			{
				strSetName+=strValue;
			}

			if (!OutFile.WriteMsiString(*strSetName, fTrue))
			{
				Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
				return false;
			}
		}
	}

	if (!(InFile.Close() && OutFile.Close()))
		return false;

	// copy the working file over the current autoexec.
	if (iesSuccess != CopyOrMoveFile(*m_pEnvironmentWorkingPath95, *m_pEnvironmentPath95,
												*m_strEnvironmentWorkingFile95, *m_strEnvironmentFile95,
												fFalse,fFalse,fFalse,iehShowNonIgnorableError))
	{
		DEBUGMSGV("Cannot replace autoexec.bat file with working copy.");
		return false;
	}

	if (iFileAttributes)
	{
		// restore original file attributes to the autoexec.bat
		pErr = m_pEnvironmentPath95->SetAllFileAttributes(m_strEnvironmentFile95, iFileAttributes);
		if (pErr)
			return false;
	}
	return true;
}

bool CMsiOpExecute::UpdateRegistryEnvironmentStrings(IMsiRecord& riParams)
{
	// the 95 and NT versions are wildly different in the storage mechanism.
	// NT should store the values in the registry.
	
	// SYSTEM:   HKLM\System\CurrentControlSet\Control\Session Manager\Environment
	// USER:    HKCU\Environment

	iesEnum iesRet = iesSuccess;
	PMsiRecord pErr(0);

	using namespace IxoUpdateEnvironmentStrings;
	

	MsiString strName(riParams.GetMsiString(Name));
	MsiString strValue(riParams.GetMsiString(Value));
	iueEnum iueAction = iueEnum(riParams.GetInteger(Action));

	// Note that we don't support multi-character delimiters.
	ICHAR chDelimiter = TEXT('\0');
	if (!riParams.IsNull(Delimiter))
		chDelimiter = *riParams.GetString(Delimiter);

	rrkEnum rrkRoot;
	MsiString strSubKey;

	PMsiRegKey pEnvironmentKey(0);
	if (iueMachine & iueAction)
	{
		rrkRoot = rrkLocalMachine;
		strSubKey = szMachineEnvironmentSubKey;
	}
	else
	{
		rrkRoot = rrkCurrentUser;
		strSubKey = szUserEnvironmentSubKey;
	}

	PMsiRegKey pHU = &m_riServices.GetRootKey(rrkRoot, ibtCommon); // x86 and ia64 same location
	if (!pHU)
		return false;

	pEnvironmentKey = &pHU->CreateChild(strSubKey);
	if (!pEnvironmentKey)
	{
		Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgOpenKeyFailed), *strSubKey, WIN::GetLastError())));
		return false;
	}

	Assert(pEnvironmentKey);

	Bool fKeyExists = fFalse;
	Bool fValueExists = fFalse;

	MsiString strCurrentValue;
	
	// rollback the entire registry value, rather than trying to rebuild it with
	// the update environment.

	pErr = pEnvironmentKey->GetValue(strName, *&strCurrentValue);
	if (pErr)
	{
		Message(imtInfo, *pErr);
		return false;
	}

	MsiString strRawCurrentValue = strCurrentValue;
	
	if (strCurrentValue.Compare(iscStart, TEXT("#%")))
		strCurrentValue.Remove(iseFirst, 2);

	// might contain the value.  rewrite as necessary, and then shove it in.
	MsiString strResult;
	if (RewriteEnvironmentString(iueAction, chDelimiter, *strCurrentValue, *strValue, *&strResult))
	{   
		// new value may end up being blank.  We treat that as a remove.
		if (!strResult.Compare(iscExact, strCurrentValue))
		{
			if (strResult.TextSize())
			{
				MsiString strNewResult;
				if (strResult.Compare(iscWithin, TEXT("%")))
					strNewResult = *TEXT("#%");

				strNewResult += strResult;

				pErr = pEnvironmentKey->SetValue(strName, *strNewResult);
			}
			else
				pErr = pEnvironmentKey->RemoveValue(strName, NULL);
	
			if (pErr)
				return false;

			// Rollback
			// For efficiency, we should sort between user and machine values, and only issue
			// the open key once.  However, this is one of those really rare actions, and
			// better to be done with it.
			IMsiRecord* piParams = &GetSharedRecord(IxoRegOpenKey::Args);
			AssertNonZero(piParams->SetInteger(IxoRegOpenKey::Root, rrkRoot));
			AssertNonZero(piParams->SetMsiString(IxoRegOpenKey::Key, *strSubKey));
			if (!RollbackRecord(ixoRegOpenKey,*piParams))
				return false;
				
			Assert(IxoRegRemoveValue::Args == IxoRegAddValue::Args);
			Assert(IxoRegRemoveValue::Name == IxoRegAddValue::Name);
			Assert(IxoRegRemoveValue::Value == IxoRegAddValue::Value);

			piParams = &GetSharedRecord(IxoRegRemoveValue::Args);
			AssertNonZero(piParams->SetMsiString(IxoRegRemoveValue::Name, *strName));

			if (0 == strCurrentValue.TextSize())
			{
				if (!RollbackRecord(ixoRegRemoveValue, *piParams))
					return false;
			}
			else
			{
				AssertNonZero(piParams->SetMsiString(IxoRegAddValue::Value, *strRawCurrentValue));
				if (!RollbackRecord(ixoRegAddValue, *piParams))
					return false;
			}
		}
		return true;
	}
	else
		return false;   
}

bool CMsiOpExecute::RewriteEnvironmentString(const iueEnum iueAction, const ICHAR chDelimiter,
																const IMsiString& ristrCurrent, const IMsiString& ristrNew,
																const IMsiString*& rpiReturn)
{
	// this builds the new environment string after doing substring matching and replacement or removal.
	// If we do nothing, return out the old value, as it will be used absolutely.

	// All of these cases are no-ops except for remove
	// ;value<EOS>
	// <EOS>value;
	// ;value;
	// If there's a false hit, then we get to add it as needed.
	ristrCurrent.AddRef();
	ristrNew.AddRef();
	MsiString strCurrent(ristrCurrent);
	MsiString strNew(ristrNew);
	
	MsiString strReturn(strCurrent);
	Bool fConcatenation = ((iueAction & iueAppend) + (iueAction & iuePrepend)) ? fTrue : fFalse;
#ifdef DEBUG
	if (fConcatenation)
		Assert(chDelimiter);
	else
		Assert(TEXT('\0') == chDelimiter);
#endif

	// cases:
	//      no new value
	//          no concatenation
	//              Remove -- remove always
	//              Set -- effectively a remove
	//              SetIfAbsent -- no op
	//          concatenation
	//              Remove -- no op
	//              Set -- no op
	//              SetIfAbsent -- no op
			
	//      no concatenation
	//       Set --  absolute set
	//       SetIfAbsent -- set if the name doesn't exist.
	//          Remove -- get rid of it if the strings are the same


	//      concatenate a new string onto an existing value
	//          new value isn't found in string,
	//              Set -- insert as necessary, beggining or end
	//              SetIfAbsent -- same as Set
	//              Remove -- no op
	//          Value *is* found in string
	//              make sure it isn't a false hit on a substring.  If it is, go back to new value that isn't
	//          found in string.
	//                  Exact Match:
	//                      Remove --  remove entire string
	//                      Set -- no op
	//                   SetIfAbsent -- no op
	//                  Substring:
	//                      Remove -- remove piece
	//                      Set -- no op
	//                      SetIfAbsent -- no op

	
	if (0 == strNew.TextSize())
	{
		if ((iueRemove & iueAction) || (iueSet & iueAction))
			strReturn = MsiString();
	}
	else if (!fConcatenation)
	{
		// no concatenation
		if (iueSet & iueAction)
		{
			strReturn = strNew;
		}
		else if (iueSetIfAbsent & iueAction)
		{
			if (0 == strCurrent.TextSize())
				// the the value is absent
				strReturn = strNew;
		}
		else if (iueRemove & iueAction)
		{
			if (strCurrent.Compare(iscExactI, strNew))
				strReturn = MsiString();
		}
	}
	else
	{
		// concatenate a non-null value
		if (!strCurrent.Compare(iscWithinI, strNew))
		{
NewValue:
			// doesn't contain the substring, and concatenate a non-null new value
			// add the string as necessary
			if ((iueSet & iueAction) || (iueSetIfAbsent & iueAction))
			{
				if (iueAppend & iueAction)
				{
					
					if (strCurrent.TextSize())
					{
						const ICHAR* pchEnd = ((const ICHAR*)strCurrent) + strCurrent.TextSize();
						pchEnd = CharPrev((const ICHAR*)strCurrent, pchEnd);
						if (chDelimiter != *pchEnd)
							strReturn += MsiChar(chDelimiter);
					}
					strReturn += strNew;
				}
				else if (iuePrepend & iueAction)
				{
					if (strCurrent.TextSize())
						if (chDelimiter != *(const ICHAR*)strCurrent)
							strReturn = MsiString(MsiChar(chDelimiter)) + strCurrent;
					strReturn = strNew + strReturn;
				}
			}
		}
		else
		{
			// the value is probably there.
			// beware of false hits without delimiters
			Assert(chDelimiter);
			if (strCurrent.Compare(iscExactI, strNew))
			{
				if ((iueSet & iueAction) || (iueSetIfAbsent & iueAction))
				{
					// no op
				}
				else if (iueRemove & iueAction)
				{
					strReturn = MsiString();
				}
			}
			else
			{
				// might contain the value.  rewrite as necessary, and then shove it in.
					// new value may end up being blank.
				// There might not have been an exact match due to a bogus delimiter that we cleaned up.
				//  Watch out for NAME=blahblahVALUEblah;blahblah
				//  NAME=value;
				//  NAME=;value
				//  NAME=blah;value;blah
		
				MsiString strStart = strNew + MsiString(MsiChar(chDelimiter));
				MsiString strEnd = MsiString(MsiChar(chDelimiter)) + strNew;
				MsiString strMid = strEnd + MsiString(MsiChar(chDelimiter));
				if (strCurrent.Compare(iscStartI, strStart))
				{
					// start
					if (iueRemove & iueAction)
						AssertNonZero(strReturn.Remove(iseFirst, strStart.CharacterCount()));
				}
				else if (strCurrent.Compare(iscEndI, strEnd))
				{
					if (iueRemove & iueAction)
						AssertNonZero(strReturn.Remove(iseLast, strEnd.CharacterCount()));
					// at the end
				}
				else if (strCurrent.Compare(iscWithinI, strMid))
				{
					// in the middle
					//!! Compare returns a location of the match, we should just use that instead.
					if (iueRemove & iueAction)
					{
						CTempBuffer<ICHAR, MAX_PATH> rgchReturn;
						MsiString strWithin;
						if (strCurrent.TextSize() > MAX_PATH)
							rgchReturn.SetSize(strCurrent.TextSize());

						ICHAR* pchCurrent = (ICHAR*) (const ICHAR*) strCurrent;
						while(NULL != *pchCurrent)
						{
							if (*pchCurrent != chDelimiter)
								pchCurrent = INextChar(pchCurrent);
							else
							{
								strWithin = pchCurrent;
								if (!strWithin.Compare(iscStartI, strMid))
									pchCurrent = INextChar(pchCurrent);
								else
								{
									strEnd = strWithin.Extract(iseLast, strWithin.TextSize() - strMid.TextSize() + 1 /*chDelimiter*/);
									strStart = strCurrent.Extract(iseFirst, strCurrent.TextSize() - strWithin.TextSize());
									strReturn = strStart + strEnd;
									break;
								}
							}
						}           
					}
				}
				else
					goto NewValue;
			}
		}
	}
	strReturn.ReturnArg(rpiReturn);
	return true;
}

iesEnum CMsiOpExecute::ixfUpdateEnvironmentStrings(IMsiRecord &riParams)
{
	bool fReturn;

	using namespace IxoUpdateEnvironmentStrings;
	MsiString strName(riParams.GetMsiString(Name));
	MsiString strValue(riParams.GetMsiString(Value));
	iueEnum iueAction = iueEnum(riParams.GetInteger(Action));

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strName));
	AssertNonZero(riActionData.SetMsiString(2, *strValue));
	AssertNonZero(riActionData.SetInteger(3, iueAction));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	m_fEnvironmentRefresh = true;
	for(;;)
	{
		if (g_fWin9X)
			fReturn = UpdateWindowsEnvironmentStrings(riParams);
		else
			fReturn = UpdateRegistryEnvironmentStrings(riParams);

		// This may give a second error describing the overall problem of not being able
		// to update the environment variables.  Within the previous functions (Update*EnvironmentStrings,) only
		// specific remediable problems will get errors.
		if (!fReturn)
		{
			using namespace IxoUpdateEnvironmentStrings;
			MsiString strName(riParams.GetMsiString(Name));

			switch(DispatchError(imtEnum(imtError + imtAbortRetryIgnore + imtDefault3), Imsg(imsgUpdateEnvironment), *strName))
			{
				case imsRetry:
					continue;
				case imsAbort:
					return iesUserExit;
				case imsNone:
				case imsIgnore:
					return iesSuccess;
				default:
					Assert(0);
			}
		}
		else return iesSuccess;
	}
}



/*---------------------------------------------------------------------------
ixfAppIdInfoRegister: register AppId registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegAppIdInfoRegister64(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegAppIdInfoRegister(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfAppIdInfoUnregister: unregister AppId registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegAppIdInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegAppIdInfoUnregister(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, fTrue, ibt32bit);
}

/*---------------------------------------------------------------------------
ProcessAppIdInfo: common routine to process AppId registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessAppIdInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	// No action data, since this is really firing off the class registration...
	using namespace IxoRegAppIdInfoRegister;
	// Record description
	// 1 = AppId
	// 2 = CLSID
	// 3 = RemoteServerName
	// 4 = LocalService
	// 5 = ServiceParameters
	// 6 = DllSurrogate
	// 7 = ActivateAtStorage
	// 8 = RunAsInteractiveUser
	riParams; fRemove;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CLASSINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	MsiString strAppId = riParams.GetMsiString(AppId);
	MsiString strClassId = riParams.GetMsiString(ClsId);
	MsiString strRemoteServerName = riParams.GetMsiString(RemoteServerName);
	MsiString strLocalService = riParams.GetMsiString(LocalService);
	MsiString strDllSurrogate = riParams.GetMsiString(DllSurrogate);
	MsiString strServiceParameters = riParams.GetMsiString(ServiceParameters);
	const int iActivateAtStorage = riParams.GetInteger(ActivateAtStorage);
	const int iRunAsInteractiveUser = riParams.GetInteger(RunAsInteractiveUser);
	
	const ICHAR* rgszRegData[] = {
		TEXT("AppID\\%s"), strAppId,0,0,
		g_szDefaultValue,               0,                              g_szTypeString,// force the key creation
		TEXT("DllSurrogate"),       strDllSurrogate,            g_szTypeString,
		TEXT("LocalService"),       strLocalService,            g_szTypeString,
		TEXT("ServiceParameters"),  strServiceParameters,   g_szTypeString,
		TEXT("RemoteServerName"),   strRemoteServerName,        g_szTypeString,
		TEXT("ActivateAtStorage"),  ((iMsiStringBadInteger == iActivateAtStorage) || (0 == iActivateAtStorage)) ? TEXT("") : TEXT("Y"), g_szTypeString,
		TEXT("RunAs"),  ((iMsiStringBadInteger == iRunAsInteractiveUser) || (0 == iRunAsInteractiveUser)) ? TEXT("") : TEXT("Interactive User"), g_szTypeString,
		0,
		0,
	};
	
	return ProcessRegInfo(rgszRegData, iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey, fRemove, 0, 0, iType);
}

int GetScriptMajorVersionFromHeaderRecord(IMsiRecord* piRecord)
{
	return piRecord->GetInteger(IxoHeader::ScriptMajorVersion);
}

const IMsiString& CMsiOpExecute::GetUserProfileEnvPath(const IMsiString& ristrPath, bool& fExpand)
{
	
	ristrPath.AddRef();
	MsiString strRet = ristrPath;
	fExpand = false;


	// there is no %USERPROFILE% on 9X
	if (!g_fWin9X && !(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN))
	{
		PMsiRecord piError(0);
		if (!m_strUserAppData.TextSize())
			piError = GetShellFolder(CSIDL_APPDATA, *&m_strUserAppData);

		if(!m_strUserProfile.TextSize())
			m_strUserProfile = m_riServices.GetUserProfilePath();

		// search from the most specific (longest) match to the least.
		// FUTURE:  If we add more paths, consider initializing an array of the paths to search.
		if (!piError && (g_iMajorVersion >= 5 && g_iWindowsBuild >= 2042) && ristrPath.Compare(iscStartI, m_strUserAppData)) // NT5 ONLY
		{
			// APPDATA implemented in NT5 build 2042
			fExpand = true;
			strRet = TEXT("%APPDATA%\\");
			strRet += MsiString(ristrPath.Extract(iseLast, ristrPath.CharacterCount() - m_strUserAppData.CharacterCount()));
		}
		else if (ristrPath.Compare(iscStartI, m_strUserProfile))
		{
			// replace the string with a %USERPROFILE%
			fExpand = true;
			strRet = TEXT("%USERPROFILE%\\");
			strRet += MsiString(ristrPath.Extract(iseLast, ristrPath.CharacterCount() - m_strUserProfile.CharacterCount()));
		}
	}

	return strRet.Return();
}

iesEnum CMsiOpExecute::ixfInstallSFPCatalogFile(IMsiRecord& riParams)
{
	// This Windows-Millennium only code.
	// See spec at http://dartools/dardev/specs/SFP-Millennium.htm

	Assert(g_fWin9X);

	using namespace IxoInstallSFPCatalogFile;

	MsiString strName(riParams.GetMsiString(Name));
	PMsiData pCatalogData(riParams.GetMsiData(Catalog));
	MsiString strDependency(riParams.GetMsiString(Dependency));

	PMsiRecord pErr(0);
	iesEnum iesRet = iesSuccess;

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strName));
	AssertNonZero(riActionData.SetMsiString(2, *strDependency));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;


	// We use the cache path so that we can leave an explicitly named file
	// we can't rename the catalog, so it has to go in place.  
	PMsiPath pCachePath(0);
	pErr = GetCachePath(*&pCachePath);
	
	MsiString strCachePath(pCachePath->GetPath());
	if ((pErr = pCachePath->EnsureExists(0)))
	{
		Message(imtError, *pErr);
		return iesFailure;
	}
	CDeleteEmptyDirectoryOnClose cDeleteTempDir(*strCachePath);

	MsiString strCacheFile;
	pErr = pCachePath->GetFullFilePath(strName, *&strCacheFile);
	CDeleteFileOnClose cTempFile(*strCacheFile);

#ifdef DEBUG
	Bool fCacheFileExists = fFalse;
	Bool fCachePathExists = fFalse;

	pErr = pCachePath->Exists(fCachePathExists);
	Assert(fCachePathExists);

	pErr = pCachePath->FileExists(strName, fCacheFileExists);
	Assert(!fCacheFileExists);
#endif
	
	// create a temporary file to hold the old catalog, and to
	// hold a temporary copy of the new catalog for submission to the system.

	do
	{
		pErr = pCachePath->EnsureOverwrite(strName, 0);
		if (pErr)
		{
			// can't overwrite our own file.  Something seriously wrong.
			switch(Message(imtEnum(imtError+imtRetryCancel+imtDefault1), *pErr))
			{
				case imsRetry:  continue;
				default:        return iesFailure; // fail in quiet install.
			}
		}
	} while(pErr);
	
	// get information to set rollback info.
	PMsiRecord pRollbackParams = &m_riServices.CreateRecord(Args);
	AssertNonZero(pRollbackParams->SetMsiString(Name, *strName));
	AssertNonZero(pRollbackParams->SetMsiString(Dependency, *strDependency));

	DWORD dwResult = SFC::SfpDuplicateCatalog(strName, strCachePath);
	if (ERROR_SUCCESS == dwResult)
	{
		// stream the temp file into the rollback opcode,
		// with the Dependency from this new one, since there is no
		// other way to query the Dependency.

		DEBUGMSGV("Updating existing catalog.\n");
		PMsiStream pCatalogStream(0);
		do
		{
			pErr = m_riServices.CreateFileStream(strCacheFile, fFalse, *&pCatalogStream);
			if (!pErr)
			{
				AssertNonZero(pRollbackParams->SetMsiData(Catalog, pCatalogStream));

				// the file will now be persisted into the rollback script
				if (!CMsiOpExecute::RollbackRecord(ixoInstallSFPCatalogFile, *pRollbackParams))
					return iesFailure;

				// release the hold on the file so that we can re-use it.
				pRollbackParams->SetMsiData(Catalog, PMsiData(0));
			}
			else
			{
				switch(Message(imtEnum(imtError+imtRetryCancel+imtDefault1), *pErr))
				{
					case imsRetry:  continue;
					default:        return iesFailure;
						// fail in quiet install
						// The file copy probably wouldn't work, and yet the system wouldn't tell us
						// about it.  So this is really our only chance to know the files won't update.
				}
			}
		} while (pErr);
	}
	else if (ERROR_FILE_NOT_FOUND == dwResult)
	{
		// no catalog by this name exists
		if (pCatalogData)
		{
			// rollback is to delete
			DEBUGMSGV("Installing brand new catalog.\n");
			AssertNonZero(pRollbackParams->SetMsiData(Catalog, PMsiData(0)));
			if (!CMsiOpExecute::RollbackRecord(ixoInstallSFPCatalogFile, *pRollbackParams))
				return iesFailure;
		}
		// else do nothing - nothing was there, and we're not installing anything.
	}
	else
	{
		// something went wrong duplicating the file from the catalog.
		DispatchError(imtError, Imsg(idbgErrorSfpDuplicateCatalog), (const ICHAR*)strName, dwResult);
		return iesFailure;
	}

	iesEnum iesWrite = iesFailure;
	if (pCatalogData)
	{
		// must stream catalog into temporary file with correct file name, then
		// pass the entire path to the file into the API
		do
		{
			iesWrite = CreateFileFromData(*pCachePath, *strName, pCatalogData, NULL /*FUTURE:  Secure this*/);
			if (iesSuccess == iesWrite)
			{
				if (ERROR_SUCCESS != (dwResult = SFC::SfpInstallCatalog(strCacheFile, strDependency)))
				{
					DispatchError(imtError, Imsg(idbgErrorSfpInstallCatalog), (const ICHAR*)strName, dwResult);
					return iesFailure;
				}
			}
			else
			{
				// couldn't write from the memory stream to the file.
				switch(DispatchError(imtEnum(imtError+imtRetryCancel+imtDefault1), Imsg(imsgErrorWritingToFile), *strCacheFile))
				{
					case imsRetry:  continue;
					default:        return iesFailure; // fail in quiet install.
				}
			}
		} while (iesSuccess != iesWrite);
	}
	else
	{
		// nuke the old catalog.
		if (ERROR_SUCCESS != (dwResult = SFC::SfpDeleteCatalog(strName)))
		{
			DispatchError(imtInfo, Imsg(idbgErrorSfpDeleteCatalog), (const ICHAR*)strName, dwResult);
		}
	}

	return iesRet;
}

iesEnum CMsiOpExecute::ResolveSourcePath(IMsiRecord& riParams, IMsiPath*& rpiSourcePath, bool& fCabinetCopy)
{
	using namespace IxoFileCopyCore;

	iesEnum iesRet = iesSuccess;
	PMsiRecord pRecErr(0);

	rpiSourcePath = 0;
	MsiString strSourcePath = riParams.GetMsiString(SourceName);
	MsiString strSourceName;

	// check if files are full or relative paths
	if(ENG::PathType(strSourcePath) == iptFull)
	{
		iesRet = CreateFilePath(strSourcePath,rpiSourcePath,*&strSourceName);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	else
	{
		int iFileAttributes = riParams.GetInteger(Attributes);
		int iSourceType = 0;
		
		// PatchAdded files are always compressed and come from a secondary source that has already been resolved
		if(iFileAttributes & msidbFileAttributesPatchAdded)
		{
			rpiSourcePath = 0;
			iSourceType = msidbSumInfoSourceTypeCompressed;
		}
		else
		{
			iesRet = GetCurrentSourcePathAndType(rpiSourcePath, iSourceType); // may trigger source resolution
			if(iesRet != iesSuccess)
				return iesRet;
		}

		// file compression may have been determined on script generation side
		// if it has, respect it.  if it hasn't, determine compression using file attributes
		// and source type
		if(riParams.IsNull(IsCompressed))
		{
			fCabinetCopy = FFileIsCompressed(iSourceType, iFileAttributes);
		}
		else
		{
			fCabinetCopy = riParams.GetInteger(IsCompressed) == 1 ? true : false;
		}
		
		if(fCabinetCopy)
		{
			// set SourceName field in params to cabinet filekey
			strSourceName = riParams.GetMsiString(SourceCabKey);

			DEBUGMSG1(TEXT("Source for file '%s' is compressed"), (const ICHAR*)strSourceName);
		}
		else
		{
			// short|long file pair may have been supplied
			Bool fLFN = ToBool(FSourceIsLFN(iSourceType, *rpiSourcePath));
			pRecErr = m_riServices.ExtractFileName(strSourcePath, fLFN, *&strSourceName);
			if(pRecErr)
				return FatalError(*pRecErr);

			DEBUGMSG2(TEXT("Source for file '%s' is uncompressed, at '%s'."),
						 (const ICHAR*)strSourceName, (const ICHAR*)MsiString(rpiSourcePath->GetPath()));
		}
	}

	// put correct filename/key back into filecopy record
	Assert(strSourceName.TextSize());
	if(strSourceName.TextSize())
	{
		AssertNonZero(riParams.SetMsiString(SourceName, *strSourceName));
	}

	if(!fCabinetCopy && !rpiSourcePath)
	{  // must not have called ixoSetSourceFolder
		DispatchError(imtError, Imsg(idbgOpSourcePathNotSet), *strSourceName);
		return iesFailure;
	}
	// pSourcePath is validated for cab installs in CopyFile after calling InitCopier

	return iesSuccess;
}

INSTALLSTATE GetFusionPath(LPCWSTR szRegistration, LPWSTR lpPath, DWORD *pcchPath, CAPITempBufferRef<WCHAR>& rgchPathOverflow, int iDetectMode, iatAssemblyType iatAT, WCHAR* szManifest, DWORD cbManifestSize);

IMsiRecord* FindFusionAssemblyFolder(IMsiServices& riServices, const IMsiString& ristrAssemblyName,
												 iatAssemblyType iatAT, IMsiPath*& rpiPath, const IMsiString** ppistrManifest = 0)
{
	rpiPath = 0;
	
	MsiString strKeyPath = TEXT("\\");
	strKeyPath += ristrAssemblyName;
	
	WCHAR wszManifest[MAX_PATH];
	CAPITempBuffer<WCHAR, 256> rgchPath;	
	INSTALLSTATE is = GetFusionPath(CConvertString(strKeyPath), 0, 0, rgchPath, DETECTMODE_VALIDATEPATH, iatAT, ppistrManifest ? wszManifest : 0, ppistrManifest ? sizeof(wszManifest) : 0);

	if(is == INSTALLSTATE_LOCAL)
	{
		if(ppistrManifest)
		{
			// copy the manifest file to the out string
			MsiString strManifest = CConvertString(wszManifest);
			strManifest.ReturnArg(*ppistrManifest);
		}

		return riServices.CreatePath(CConvertString(rgchPath),rpiPath);
	}
	else
	{
		return 0; // missing file is not a failure
	}
}

/*---------------------------------------------------------------------------

BackupAssembly: back up the files of GA before Uninstalling it
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::BackupAssembly(const IMsiString& rstrComponentId, const IMsiString& rstrAssemblyName, iatAssemblyType iatType)
{
	if(RollbackEnabled())
	{
		// get the assembly installation folder
		PMsiPath pAssemblyFolder(0);
		MsiString strManifest;
		PMsiRecord pRecErr = FindFusionAssemblyFolder(m_riServices, rstrAssemblyName, iatType, *&pAssemblyFolder, &strManifest);
		if(pRecErr)
			return FatalError(*pRecErr);
		if(pAssemblyFolder)
		{
			// enumerate though all the files and copy to the backup folder
			iesEnum iesRet = iesSuccess;
			WIN32_FIND_DATA fdFileData;
			HANDLE hFindFile = INVALID_HANDLE_VALUE;

			MsiString strSearchPath = pAssemblyFolder->GetPath();
			strSearchPath += TEXT("*.*");

			bool fContinue = true;

			hFindFile = WIN::FindFirstFile(strSearchPath, &fdFileData);
			if (hFindFile != INVALID_HANDLE_VALUE)
			{
				for (;;)
				{
					if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
					{
						// backup the file and set it up so that it gets installed back to the assembly on rollback
						if((iesRet = BackupFile(*pAssemblyFolder, *MsiString(CConvertString(fdFileData.cFileName)), fFalse, fFalse, iehShowIgnorableError, false, false, &rstrComponentId, strManifest.Compare(iscExactI, fdFileData.cFileName) ? true:false)) != iesSuccess)
						{
							WIN::FindClose(hFindFile);
							return iesRet;
						}
					}
					
					if (!WIN::FindNextFile(hFindFile, &fdFileData))
					{
						Assert(ERROR_NO_MORE_FILES == GetLastError());
						WIN::FindClose(hFindFile);
						break;
					}
				}
			}
		}
		// generate opcode to create the assembly mapping
		IMsiRecord& riUndoParams = GetSharedRecord(IxoAssemblyMapping::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoAssemblyMapping::ComponentId, rstrComponentId));
		AssertNonZero(riUndoParams.SetMsiString(IxoAssemblyMapping::AssemblyName, rstrAssemblyName));
		AssertNonZero(riUndoParams.SetInteger(IxoAssemblyMapping::AssemblyType, iatType));
		if (!RollbackRecord(ixoAssemblyMapping, riUndoParams))
			return iesFailure;
	}
	return iesSuccess;
}


/*---------------------------------------------------------------------------
ixoAssemblyCopy: Copy a file to the Global Assembly Cache
---------------------------------------------------------------------------*/

enum iacdEnum
{
	iacdNoCopy,
	iacdGAC,
	iacdFileFolder,
};

iesEnum CMsiOpExecute::ixfAssemblyCopy(IMsiRecord& riParams)
{
	using namespace IxoAssemblyCopy;

	// If the cabinet copier notified us that a media change is required,
	// we must defer any file copy requests until a media change is executed.
	if (m_state.fWaitingForMediaChange)
	{
		PushRecord(riParams);
		return iesSuccess;
	}

	ielfEnum ielfCurrentElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate :
												  (ielfEnum)riParams.GetInteger(ElevateFlags);

	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;

	iacdEnum iacdCopyDestination = iacdGAC;
		
	MsiString strDestName = riParams.GetMsiString(DestName);
	PMsiPath pTargetPath(0);
	// target name and path may be redirected below, but we want the action data message to contain
	// the original file information, so we'll store that away here
	MsiString strActionDataDestName = strDestName;
	
	// check if file is part of Assembly
	MsiString strComponentId = riParams.GetMsiString(ComponentId);
	if(!strComponentId.TextSize() || m_pAssemblyCacheTable == 0)
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyCopy")));
		return iesFailure;
	}

	//
	// STEP 1: create/retrive AssemblyCacheItem for this file's assembly
	//

	PAssemblyCacheItem pASM(0);
	bool fManifest = riParams.IsNull(IsManifest) ? false: true;
	iatAssemblyType iatAT = iatNone;
	if((iesRet = GetAssemblyCacheItem(*strComponentId, *&pASM, iatAT)) != iesSuccess)
		return iesRet;

	//
	// STEP 2: if patching, look for target file in GAC and copy file to working directory
	//
	
	int cPatches          = riParams.IsNull(TotalPatches)       ? 0 : riParams.GetInteger(TotalPatches);
	int cOldAssemblyNames = riParams.IsNull(OldAssembliesCount) ? 0 : riParams.GetInteger(OldAssembliesCount);
	Assert(cOldAssemblyNames == 0 || cPatches != 0); // shouldn't have old assemblies w/o patches

	if(cPatches)
	{
		DEBUGMSG2(TEXT("FUSION PATCHING: Patching assembly file '%s' from component '%s'."), (const ICHAR*)strDestName,
					 (const ICHAR*)strComponentId);

		//
		// STEP 2a: we are patching, which means we will need an intermediate file to patch
		//          go ahead and determine the folder and filename for that file now
		//

		PMsiPath pPatchWorkingDir(0);
		MsiString strTempNameForPatch;

		// FUTURE: don't always use system drive as working directory - determine more appropriate drive
		if((iesRet = GetBackupFolder(0, *&pPatchWorkingDir)) != iesSuccess)
			return iesRet;

		{ // scope elevation
			CElevate elevate; // elevate to create temp file on secure temp folder
			if((pRecErr = pPatchWorkingDir->TempFileName(TEXT("PT"),0,fTrue,*&strTempNameForPatch, 0)) != 0)
				return FatalError(*pRecErr);
		}

		// we need to keep this file around as a placeholder for the name
		// filecopy will back this file up and restore it on rollback, so we need another rollback op to delete this file

		MsiString strTempFileFullPath;
		if((pRecErr = pPatchWorkingDir->GetFullFilePath(strTempNameForPatch,*&strTempFileFullPath)) != 0)
			return FatalError(*pRecErr);
		
		IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName, *strTempFileFullPath));

		if (!RollbackRecord(ixoFileRemove, riUndoParams))
			return iesFailure;
		
		//
		// STEP 2b: if old assembly names are supplied, look for an existing file in the GAC
		//

		bool fShouldPatch          = true;
		bool fCopyIntermediateFile = true;
		int  cPatchesToSkip = 0;

		if(cOldAssemblyNames)
		{
			// look for an existing file in the GAC to apply our patches against
			int iOldAssemblyNameStart = riParams.IsNull(OldAssembliesStart) ? 0 : riParams.GetInteger(OldAssembliesStart);

			PMsiPath pAssemblyFolder(0);
			bool fFoundAssembly = false;
			int i = 0;
			for(i = iOldAssemblyNameStart; i < cOldAssemblyNames + iOldAssemblyNameStart; i++)
			{
				pRecErr = FindFusionAssemblyFolder(m_riServices, *MsiString(riParams.GetMsiString(i)),
															  iatAT, *&pAssemblyFolder);
				if(pRecErr)
					return FatalError(*pRecErr);

				if(pAssemblyFolder && FFileExists(*pAssemblyFolder, *strDestName))
				{
					fFoundAssembly = true;
					break;
				}
			}

			if(fFoundAssembly)
			{
				
				Assert(pAssemblyFolder);

				DEBUGMSG2(TEXT("FUSION PATCHING: Found existing file to patch in assembly with name: '%s' in folder '%s'"),
							 (const ICHAR*)MsiString(riParams.GetMsiString(i)),
							 (const ICHAR*)MsiString(pAssemblyFolder->GetPath()));
							 

				//
				// STEP 2c: if old file found, copy from GAC to working folder
				//

				m_cSuppressProgress++; // suppress progress messages
				iesRet = CopyOrMoveFile(*pAssemblyFolder, *pPatchWorkingDir, *strDestName, *strTempNameForPatch,
												fFalse, fFalse, fTrue, iehShowNonIgnorableError, 0, ielfElevateDest,
												/* fCopyACL = */ false, false, false);
				m_cSuppressProgress--;
				
				if(iesRet != iesSuccess)
					return iesRet;

				//
				// STEP 2d: test patch headers against file
				//

				icpEnum icpPatchTest = icpCannotPatch;
				int iPatchIndex = 0;
				iesRet = TestPatchHeaders(*pPatchWorkingDir, *strTempNameForPatch, riParams, icpPatchTest, iPatchIndex);
				if(iesRet == iesSuccess)
				{
					if(icpPatchTest == icpCanPatch || icpPatchTest == icpUpToDate)
					{
						// file can already be patched, so don't need to install file
						fCopyIntermediateFile = false;
						fShouldPatch = icpPatchTest == icpCanPatch ? true : false;

						cPatchesToSkip = iPatchIndex - 1; // iPatchIndex is the index of the first patch that could be applied
																	 // properly to this file.  so we need to skip the patches that come
																	 // before it.
					}
					else if(icpPatchTest == icpCannotPatch)
					{
						// can't patch the file as it stands
						// but fCopyIntermediateFile is true so we'll recopy the source file first which should be patchable
						fCopyIntermediateFile = true;
						fShouldPatch = true;

						cPatchesToSkip = 0; // need to copy source file and apply all patches
					}
					else
					{
						AssertSz(0, "Invalid return from TestPatchHeaders()");
					}
				}
			}
		}

		//
		// STEP 2d: setup copy and/or patch
		//

		int iCachedState = 0;
		
		if(fShouldPatch)
		{
			if(fCopyIntermediateFile)
			{
				// need to copy file from source to temp location

				// reset copy arguments to reflect new file copy - new path, new filename, and since
				// the file is being copied into the secured config folder, we need to elevate for the target
				// NOTE: we aren't changing strDestName, which is used below
				//       for those uses it is correct to use the original dest name
				AssertNonZero(riParams.SetMsiString(DestName,*strTempNameForPatch));
				pTargetPath = pPatchWorkingDir;

				AssertNonZero(riParams.SetInteger(ElevateFlags, ielfCurrentElevateFlags | ielfElevateDest));

				iacdCopyDestination = iacdFileFolder;

				DEBUGMSG(TEXT("FUSION PATCHING: Either no existing file found to patch, or existing file is unpatchable.  Copying file from source."));
			}
			else
			{
				// the intermediate file we have already is patchable, so no need to copy the source file to the intermediate
				// location or to the GAC
				DEBUGMSG(TEXT("FUSION PATCHING: Existing file is patchable.  Source file will not be copied."));

				iacdCopyDestination = iacdNoCopy;
			}

			iCachedState |= icfsPatchFile;

			DEBUGMSG1(TEXT("FUSION PATCHING: Subsequent patch(es) will update file '%s', then copy file into Global Assembly Cache."),
						 (const ICHAR*)strTempFileFullPath);
		}

		// FileState index for assembly files is ComponentID + FileName
		MsiString strIndex = strComponentId;
		strIndex += strDestName;

		pRecErr = CacheFileState(*strIndex,(icfsEnum*)&iCachedState,
										 strTempFileFullPath, 0, &cPatches, &cPatchesToSkip);
		if(pRecErr)
			return FatalError(*pRecErr);
	}

	if(iacdCopyDestination == iacdNoCopy)
		return iesSuccess;
	
	// STEP 3: resolve source path and type
	
	PMsiPath pSourcePath(0);
	bool fCabinetCopy = false;

	if(m_state.fSplitFileInProgress)
	{
		// must be a cabinet copy
		fCabinetCopy = true;
	}
	else
	{
		if((iesRet = ResolveSourcePath(riParams, *&pSourcePath, fCabinetCopy)) != iesSuccess)
			return iesRet;
	}

	// STEP 4: perform copy/move operation
	
	// action data
	IMsiRecord& riActionData = GetSharedRecord(9);
	AssertNonZero(riActionData.SetMsiString(1, *strActionDataDestName));
	AssertNonZero(riActionData.SetInteger(6,riParams.GetInteger(FileSize)));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// perform operation
	if(iacdCopyDestination == iacdGAC)
	{
		return CopyFile(*pSourcePath, *pASM, fManifest, riParams, /*fHandleRollback=*/ fTrue, iehShowNonIgnorableError, fCabinetCopy);
	}
	else if(iacdCopyDestination == iacdFileFolder)
	{
		Assert(pTargetPath);
		return CopyFile(*pSourcePath, *pTargetPath, riParams, /*fHandleRollback=*/ fTrue, iehShowNonIgnorableError, fCabinetCopy);
	}
	else
	{
		Assert(0);
		return iesSuccess;
	}
}

iesEnum CMsiOpExecute::ApplyPatchCore(IMsiPath& riTargetPath, IMsiPath& riTempFolder, const IMsiString& ristrTargetName,
												  IMsiRecord& riParams, const IMsiString*& rpistrOutputFileName,
												  const IMsiString*& rpistrOutputFilePath)
{
	using namespace IxoFilePatchCore;	

	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	// the binary patch file is extracted into the config folder.  this requires elevation
	// also when the target file may be a temporary file in the secured config folder, this also requires elevation
	CElevate elevate;

	// get temp name for output file
	if((pError = riTempFolder.TempFileName(TEXT("PT"),0,fTrue,rpistrOutputFileName, 0 /* use default ACL for folder */)) != 0)
		return FatalError(*pError);
	
	// rollback for ApplyPatch call is to remove patch output file
	// below we will copy the output file over the existing file - the rollback for that operation
	// will move the output file back and this rollback operation will remove it
	if((pError = riTempFolder.GetFullFilePath(rpistrOutputFileName->GetString(), rpistrOutputFilePath)) != 0)
		return FatalError(*pError);

	IMsiRecord* piUndoParams = &GetSharedRecord(IxoFileRemove::Args);
	AssertNonZero(piUndoParams->SetMsiString(IxoFileRemove::FileName,*rpistrOutputFilePath));
	AssertNonZero(piUndoParams->SetInteger(IxoFileRemove::Elevate, true));
	if (!RollbackRecord(ixoFileRemove,*piUndoParams))
		return iesFailure;

	// get temp name for patch file -- it may be sensitive information, so hide it from the user.
	MsiString strPatchFileName;

	if((pError = riTempFolder.TempFileName(TEXT("PF"),0,fTrue,*&strPatchFileName, 0 /* use default ACL for folder*/)) != 0)
		return FatalError(*pError);

	unsigned int cbPerTick = riParams.GetInteger(PerTick);
	unsigned int cbFileSize = riParams.GetInteger(TargetSize);

	// extract patch file from cabinet into temp file
	// set up record for ixfFileCopy
	PMsiRecord pFileCopyRec = &m_riServices.CreateRecord(IxoFileCopyCore::Args);
	AssertNonZero(pFileCopyRec->SetMsiString(IxoFileCopyCore::SourceName,
														  *MsiString(riParams.GetMsiString(PatchName))));
	AssertNonZero(pFileCopyRec->SetMsiString(IxoFileCopyCore::DestName, *strPatchFileName));
	
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::Attributes,0));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::FileSize,riParams.GetInteger(PatchSize)));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::PerTick,cbPerTick));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::VerifyMedia,fTrue));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::ElevateFlags, ielfElevateDest));
	
	// don't need to set Version or Language

	iesRet = CopyFile(*PMsiPath(0)/* not used for cab installs*/,
					  riTempFolder,*pFileCopyRec,fFalse,iehShowNonIgnorableError,/*fCabinetCopy=*/true); // don't handle rollback
	if(iesRet != iesSuccess)
	{
		// remove patch file in case only part was copied
		pError = riTempFolder.RemoveFile(strPatchFileName); // ignore error
		return iesRet;
	}

	// after this point, don't return without deleting patch file

	// apply patch to target file
	int cbFileSoFar = 0;
	Bool fRetry = fTrue;
	bool fVitalFile = (riParams.GetInteger(FileAttributes) & msidbFileAttributesVital) != 0;
	bool fVitalPatch = (riParams.GetInteger(PatchAttributes) & msidbPatchAttributesNonVital) == 0;

	// ApplyPatch can sometimes be a long operation without a patch notify message
	// need to disable timeout until more frequent notification messages are added
	// NOTE: must not return before the next MsiEnableTimeout call below
	MsiDisableTimeout();

	// start patch application, continue if necessary with ContinuePatch
	while(fRetry)
	{
		pError = m_state.pFilePatch->ApplyPatch(riTargetPath, ristrTargetName.GetString(),
															 riTempFolder, rpistrOutputFileName->GetString(),
															 riTempFolder, strPatchFileName,
															 cbPerTick);
		Bool fContinue = fTrue;
		while(fContinue)  // both a retry loop and loop to call Continue until 0 is returned.
		{
			if(pError)
			{
				int iError = pError->GetInteger(1);
				if(iError == idbgPatchNotify)
				{
					int cb = pError->GetInteger(2);
					Assert((cb - cbFileSoFar) >= 0);
					if (DispatchProgress(cb - cbFileSoFar) == imsCancel)  // increment by difference from last update
					{
						fRetry = fFalse;
						fContinue = fFalse;
						iesRet = iesUserExit;
						// cancel patch if still in-progress
						pError = m_state.pFilePatch->CancelPatch();
						if(pError)
							Message(imtInfo,*pError);
					}
					else
						cbFileSoFar = cb;  // update
				}
				else
				{
					fContinue = fFalse;
					imtEnum imtType = imtInfo;
					if(fVitalPatch)
					{
						imtType = fVitalFile ? imtEnum(imtError+imtRetryCancel+imtDefault2) :
													  imtEnum(imtError+imtAbortRetryIgnore+imtDefault1);
					}

					switch(DispatchMessage(imtType,*pError,fTrue))
					{
					case imsRetry:
						continue;
					case imsIgnore:
						fRetry = fFalse;
						iesRet = (iesEnum) iesErrorIgnored;
						break;
					default:  // imsCancel, imsNone (for imtInfo)
						fRetry = fFalse;
						iesRet = iesFailure;
					};
				}
			}
			else
			{
				// file has been patched
				if (DispatchProgress(cbFileSize - cbFileSoFar) == imsCancel)
					iesRet = iesUserExit;
				else
					iesRet = iesSuccess;
				fRetry = fFalse;
				fContinue = fFalse;
			}
		
			if(fRetry)
			{
				// continue patch application
				pError = m_state.pFilePatch->ContinuePatch();
			}
		}
	}

	// re-enable timeout after patch application
	MsiEnableTimeout();

	// cleanup
	if((pError = riTempFolder.RemoveFile(strPatchFileName)) != 0) // non-critical error
	{
		Message(imtInfo,*pError);
	}

	return iesRet;
}


iesEnum CMsiOpExecute::ixfAssemblyPatch(IMsiRecord& riParams)
{
	using namespace IxoAssemblyPatch;

	//
	// STEP 0: check state, parameters for errors
	//
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	if(!m_state.pFilePatch)
	{
		// create FilePatch object
		if((pError = m_riServices.CreatePatcher(*&(m_state.pFilePatch))) != 0)
		{
			Message(imtError,*pError);
			return iesFailure;
		}
	}
	Assert(m_state.pFilePatch);

	// check if file is part of Assembly
	MsiString strComponentId = riParams.GetMsiString(ComponentId);
	if(!strComponentId.TextSize() || m_pAssemblyCacheTable == 0)
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyPatch")));
		return iesFailure;
	}

	//
	// STEP 1: create/retrieve assemblycacheitem object for this file's assembly
	//

	MsiString strCopyTargetFileName = riParams.GetMsiString(TargetName);

	PAssemblyCacheItem pASM(0);
	bool fManifest = riParams.IsNull(IsManifest) ? false: true;
	iatAssemblyType iatAT = iatNone;
	if((iesRet = GetAssemblyCacheItem(*strComponentId, *&pASM, iatAT)) != iesSuccess)
		return iesRet;

	//
	// STEP 2: retrieve cached state for this file
	//

	// FileState index for assembly files is ComponentID + FileName
	MsiString strIndex = strComponentId;
	strIndex += strCopyTargetFileName;
	
	icfsEnum icfsFileState = (icfsEnum)0;
	MsiString strTempLocation;
	int cRemainingPatches = 0;
	int cRemainingPatchesToSkip = 0;
	Bool fRes = GetFileState(*strIndex, &icfsFileState, &strTempLocation, &cRemainingPatches, &cRemainingPatchesToSkip);

	if(!fRes || !(icfsFileState & icfsPatchFile))
	{
		// don't patch file
		DEBUGMSG1(TEXT("Skipping all patches for assembly '%s'.  File does not need to be patched."),
					 (const ICHAR*)strIndex);
		return iesSuccess;
	}

	Assert(cRemainingPatches > 0);
	
	if(cRemainingPatchesToSkip > 0)
	{
		// skip this patch, but reset cached file state first
		cRemainingPatches--;
		cRemainingPatchesToSkip--;

		DEBUGMSG3(TEXT("Skipping this patch for assembly '%s'.  Number of remaining patches to skip for this file: '%d'.  Number of total remaining patches: '%d'."),
					 (const ICHAR*)strIndex, (const ICHAR*)(INT_PTR)cRemainingPatchesToSkip, (const ICHAR*)(INT_PTR)cRemainingPatches);

		if((pError = CacheFileState(*strIndex, 0, 0, 0, &cRemainingPatches, &cRemainingPatchesToSkip)) != 0)
			return FatalError(*pError);

		return iesSuccess;
	}
	

	if(strTempLocation.TextSize() == 0)
	{
		// error - there must be an intermediate copy of an assembly file to patch.  we won't patch the 
		// file directly in the GAC
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyPatch")));
		return iesFailure;
	}

	Assert(cRemainingPatches > 0);

	DEBUGMSG4(TEXT("FUSION PATCHING: Patching assembly file '%s' from component '%s'.  Intermediate file: '%s', remaining patches (including this one): %d"),
				 (const ICHAR*)strCopyTargetFileName, (const ICHAR*)strComponentId, (const ICHAR*)strTempLocation,
				 (const ICHAR*)(INT_PTR)cRemainingPatches);

	PMsiPath pPatchTargetPath(0);
	MsiString strPatchTargetFileName;
	
	// file was actually copied to temp location.  this is the copy we want to apply the patch against
	if((pError = m_riServices.CreateFilePath(strTempLocation,*&pPatchTargetPath,*&strPatchTargetFileName)) != 0)
		return FatalError(*pError);

	unsigned int cbFileSize = riParams.GetInteger(TargetSize);
	bool fVitalFile = (riParams.GetInteger(FileAttributes) & msidbFileAttributesVital) != 0;
	bool fVitalPatch = (riParams.GetInteger(PatchAttributes) & msidbPatchAttributesNonVital) == 0;

	// dispatch ActionData message
	IMsiRecord& riActionData = GetSharedRecord(3);
	AssertNonZero(riActionData.SetMsiString(1, *strCopyTargetFileName));
	AssertNonZero(riActionData.SetInteger(3, cbFileSize));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	//
	// STEP 3: create output file with patch and target files
	//

	PMsiPath pTempFolder(0);
	if((iesRet = GetBackupFolder(pPatchTargetPath, *&pTempFolder)) != iesSuccess)
		return iesRet;

	MsiString strOutputFileName;
	MsiString strOutputFileFullPath;
	if((iesRet = ApplyPatchCore(*pPatchTargetPath, *pTempFolder, *strPatchTargetFileName,
										 riParams, *&strOutputFileName, *&strOutputFileFullPath)) != iesSuccess)
	{
		return iesRet;
	}

	//
	// STEP 4: either setup output file for next patch, or copy output file into the GAC
	//
	
	MsiString strNewTempLocation;
	if(iesRet == iesSuccess)
	{
		if(cRemainingPatches > 1)
		{
			// there is at least one more patch to be done on this file
			// therefor we will reset the temporary name for this file to be the patch output file
			// but won't overwrite the original file yet
			strNewTempLocation = strOutputFileFullPath;
		}
		else
		{
			// this is the last patch - time to finally overwrite the original file
			
			// we always need to handle rollback.  we wouldn't if a previous filecopy operation wrote to the same
			// target that we are copying over now, but that should never happen since when patching will happen
			// filecopy should be writing to an intermediate file
			Assert(strTempLocation.TextSize() || (icfsFileState & icfsFileNotInstalled));

			iesRet = CopyASM(*pTempFolder, *strOutputFileName, *pASM, *strCopyTargetFileName, fManifest,
								  fTrue, fVitalFile ? iehShowNonIgnorableError : iehShowIgnorableError, ielfElevateSource);

			if(iesRet == iesSuccess)
			{
				CElevate elevate;
				// done copying file into GAC, now remove the output file
				if((pError = pTempFolder->RemoveFile(strOutputFileName)) != 0) // non-critical error
				{
					Message(imtInfo,*pError);
				}
			}
		}
	}
	else
	{
		CElevate elevate;
		// remove output file if failure
		if((pError = pTempFolder->RemoveFile(strOutputFileName)) != 0) // non-critical error
		{
			Message(imtInfo,*pError);
		}

		if(fVitalPatch == false)
		{
			// failed to apply vital patch - return success to allow script to continue
			iesRet = iesSuccess;
		}
	}

	// if we patched a temp file, remove that file
	if(strTempLocation.TextSize())
	{
		if((pError = pPatchTargetPath->RemoveFile(strPatchTargetFileName)) != 0) // non-critical error
		{
			Message(imtInfo,*pError);
		}
	}

	//
	// STEP 5: reset cached file state
	//         one fewer remaining patch now, and we may either have a new temporary location, or no temporary location
	//

	cRemainingPatches--;
	Assert(cRemainingPatchesToSkip == 0);
	if((pError = CacheFileState(*strIndex, 0, strNewTempLocation, 0, &cRemainingPatches, 0)) != 0)
		return FatalError(*pError);

	return iesRet;
}

iesEnum CMsiOpExecute::GetAssemblyCacheItem(const IMsiString& ristrComponentId,
														  IAssemblyCacheItem*& rpiASM,
														  iatAssemblyType& iatAT)
{
    Assert(m_pAssemblyCacheTable);
	if(!m_pAssemblyCacheTable)
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyCopy")));
		return iesFailure;
	}

	PMsiCursor pCacheCursor = m_pAssemblyCacheTable->CreateCursor(fFalse);
	pCacheCursor->SetFilter(iColumnBit(m_colAssemblyMappingComponentId));
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyMappingComponentId, ristrComponentId));
	if(pCacheCursor->Next())
	{
		// a fusion component
		rpiASM = static_cast<IAssemblyCacheItem*>(CMsiDataWrapper::GetWrappedObject(PMsiData(pCacheCursor->GetMsiData(m_colAssemblyMappingASM))));
		iatAT = (iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyMappingAssemblyType);
		if(!rpiASM) // no interface created as yet, create the interface
		{
			// create the assembly interface
			PAssemblyCache pCache(0);
			HRESULT hr;
			if(iatAT == iatURTAssembly)
				hr = FUSION::CreateAssemblyCache(&pCache, 0);
			else
			{
				Assert(iatAT == iatWin32Assembly);
				hr = SXS::CreateAssemblyCache(&pCache, 0);
			}
			if(!SUCCEEDED(hr))
			{
				return FatalError(*PMsiRecord(PostAssemblyError(ristrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), iatAT)));
			}

			hr = pCache->CreateAssemblyCacheItem(0, NULL, &rpiASM, NULL);
			if(!SUCCEEDED(hr))
			{
				return FatalError(*PMsiRecord(PostAssemblyError(ristrComponentId.GetString(), hr, TEXT("IAssemblyCache"), TEXT("CreateAssemblyCacheItem"), MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), iatAT)));
			}

			//add the interface to the table for future use
			AssertNonZero(pCacheCursor->PutMsiData(m_colAssemblyMappingASM, PMsiDataWrapper(CreateMsiDataWrapper(rpiASM))));
			AssertNonZero(pCacheCursor->Update());
		}

		Assert(rpiASM);
		return iesSuccess;
	}
	else
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyCopy"))); //!!
		return iesFailure;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\engine.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       engine.cpp
//
//--------------------------------------------------------------------------

/* engine.cpp - IMsiEngine implementation

IMsiSelectionManager and IMsiDirectoryManager implemented as part of CMsiEngine
____________________________________________________________________________*/

#include "precomp.h"
#include "msi.h"
#include "msidefs.h"
#include "eventlog.h"
#ifdef CONFIGDB
#include "configdb.h"
#endif
#include "vertrust.h"
#define AUTOAPI  // temp. until autoapi.cpp fully integrated
#ifdef AUTOAPI   // merge OLE registration
#define DllRegisterServer   DllRegisterServerTest
#define DllUnregisterServer DllUnregisterServerTest
#define DllGetClassObject   DllGetClassObjectTest
#endif // AUTOAPI
#ifdef AUTOAPI
#endif // AUTOAPI
// definitions required for module.h, for entry points and registration
// array order: services, debug services, engine, debug engine
#if defined(DEBUG)
#define SERVICES_CLSID_MULTIPLE 2
#else
#define SERVICES_CLSID_MULTIPLE 1
#endif
#define  SERVICES_CLSID_COUNT 2  // IMsiServices + IMsiServicesAsService
#define    ENGINE_CLSID_COUNT 8  // IMsiEngine + IMsiConfigurationManager + IMsiMessage + IMsiExecute + IMsiServerProxy + IMsiConfigManagerAsServer + IMsiCustomAction + IMsiRemoteAPI
# ifdef DEBUG
#define     DEBUG_CLSID_COUNT 3  // IMsiEngineDebug + IMsiConfigManagerDebug + IMsiConfigMgrAsServerDebug
# else
#define     DEBUG_CLSID_COUNT 0
# endif
#ifdef CONFIGDB
# define CLSID_COUNT (1 + ENGINE_CLSID_COUNT + DEBUG_CLSID_COUNT + SERVICES_CLSID_COUNT * SERVICES_CLSID_MULTIPLE)
#else
# define CLSID_COUNT (ENGINE_CLSID_COUNT + DEBUG_CLSID_COUNT + SERVICES_CLSID_COUNT * SERVICES_CLSID_MULTIPLE)
#endif // CONFIGDB
#define PROFILE_OUTPUT      "msiengd.mea";
#define MODULE_CLSIDS       rgCLSID         // array of CLSIDs for module objects
#define MODULE_PROGIDS      rgszProgId      // ProgId array for this module
#define MODULE_DESCRIPTIONS rgszDescription // Registry description of objects
#define MODULE_FACTORIES    rgFactory       // factory functions for each CLSID
#define cmitObjects  9
#define IN_SERVICES
#define MEM_SERVICES

#define MODULE_TERMINATE  TerminateModule
#define MODULE_INITIALIZE InitializeModule

extern "C" HRESULT __stdcall ProxyDllGetClassObject(const GUID& clsid, const IID& iid, void** ppvRet);
#define PRE_CLASS_FACTORY_HANDLER       ProxyDllGetClassObject

#define ASSERT_HANDLING  // instantiate assert services once per module

#include "module.h"   // self-reg and assert functions, includes version.h

#include "_assert.h"

#include "_engine.h"
#include "_msinst.h"
#include "_msiutil.h"
#include "_srcmgmt.h"
#include <srrestoreptapi.h>
#include "tables.h" // table and column name definitions
#include "fusion.h"
#include "_camgr.h"

const IMsiString& GetInstallerMessage(UINT iError);  // in action.cpp

INSTALLSTATE MapInternalInstallState(iisEnum iis);  // in msiquery.cpp

// MAINTAIN: compatibility with versions used to create database
// change project version by using SADMIN setpv MAJOR.minor
const int iVersionEngineMinimum = 30;            // 0.30
const int iVersionEngineMaximum = rmj*100 + rmm; // MAJOR.minor
const int iComponentCostWeight = 25;    // For the costing/script generation progress bar
const int iMinimumPackage64Schema = 150; // Intel64 packages must be minimum schema 150

// identifier prefix characters, else defaults to property name

const ICHAR ichFileTablePrefixSFN = TEXT('!');  // FormatText
const ICHAR ichFileTablePrefix = TEXT('#');  // FormatText
const ICHAR ichComponentPath   = TEXT('$');  // FormatText
const ICHAR ichComponentAction = TEXT('$');  // EvaluateCondition
const ICHAR ichComponentState  = TEXT('?');  // EvaluateCondition
const ICHAR ichFeatureAction   = TEXT('&');  // EvaluateCondition
const ICHAR ichFeatureState    = TEXT('!');  // EvaluateCondition
const ICHAR ichEnvirPrefix     = TEXT('%');  // FmtText, EvalCnd, Get/SetProperty
const ICHAR ichNullChar        = TEXT('~');  // FormatText

//____________________________________________________________________________

const GUID IID_IUnknown                 = GUID_IID_IUnknown;
const GUID IID_IClassFactory            = GUID_IID_IClassFactory;
const GUID IID_IMarshal                                 = GUID_IID_IMarshal;
const GUID IID_IMsiExecute = GUID_IID_IMsiExecute;
const GUID IID_IMsiServices             = GUID_IID_IMsiServices;
const GUID IID_IMsiServicesAsService    = GUID_IID_IMsiServicesAsService;
const GUID IID_IMsiMessage              = GUID_IID_IMsiMessage;
const GUID IID_IMsiSelectionManager     = GUID_IID_IMsiSelectionManager;
const GUID IID_IMsiDirectoryManager     = GUID_IID_IMsiDirectoryManager;
#ifdef CONFIGDB
const GUID IID_IMsiConfigurationDatabase= GUID_IID_IMsiConfigurationDatabase;
#endif // CONFIGDB
#ifdef DEBUG
const GUID IID_IMsiServicesDebug        = GUID_IID_IMsiServicesDebug;
const GUID IID_IMsiServicesAsServiceDebug=GUID_IID_IMsiServicesAsServiceDebug;
#endif //DEBUG

const GUID IID_IMsiServerUnmarshal              = GUID_IID_IMsiServerUnmarshal;

// Date formatting definitions
const int  rgcbDate[6] = { 7, 4, 5, 5, 6, 5 };  // bits for each date field
const char rgchDelim[6] = "// ::";

const int imtForceLogInfo     = imtInfo + imtIconError;      // forces info record to log, even if not logging info
const int imtDumpProperties   = imtInternalExit + imtYesNo;  // query for property dump log mode


const ICHAR szControlTypeEdit[]           = TEXT("Edit");

const ICHAR szPropertyDumpTemplate[]      = TEXT("Property(%c): [1] = [2]");

const ICHAR szTemporaryId[]               = TEXT("Temporary Id");
enum ircEnum
{
	ircFeatureClass,
	ircComponentClass,
	ircFileClass,
	ircNextEnum
};


const ICHAR * mpeftSz[ieftMax] =
{
	sztblFile_colFile,
	sztblFile_colComponent,
	sztblFile_colAttributes,
	sztblFile_colFileName
};

const ICHAR szFeatureSelection[]      = TEXT("_MSI_FEATURE_SELECTION");
const ICHAR szFeatureDoNothingValue[] = TEXT("_NONE_");

struct FeatureProperties
{
	const ICHAR* szFeatureActionProperty;
	ircEnum ircRequestClass;
	iisEnum iisFeatureRequest;
};

const FeatureProperties g_rgFeatures[] =
{
	IPROPNAME_FEATUREADDLOCAL,     ircFeatureClass,   iisLocal,
	IPROPNAME_FEATUREREMOVE,       ircFeatureClass,   iisAbsent,
	IPROPNAME_FEATUREADDSOURCE,    ircFeatureClass,   iisSource,
	IPROPNAME_FEATUREADDDEFAULT,   ircFeatureClass,   iisCurrent,
	IPROPNAME_REINSTALL,           ircFeatureClass,   iisReinstall,
	IPROPNAME_FEATUREADVERTISE,    ircFeatureClass,   iisAdvertise,
	IPROPNAME_COMPONENTADDLOCAL,   ircComponentClass, iisLocal,
	IPROPNAME_COMPONENTADDSOURCE,  ircComponentClass, iisSource,
	IPROPNAME_COMPONENTADDDEFAULT, ircComponentClass, iisLocal,
	IPROPNAME_FILEADDLOCAL,        ircFileClass,      iisLocal,
	IPROPNAME_FILEADDSOURCE,       ircFileClass,      iisSource,
	IPROPNAME_FILEADDDEFAULT,      ircFileClass,      iisLocal,
};

const int g_cFeatureProperties = sizeof(g_rgFeatures)/sizeof(FeatureProperties);

int		g_fSmartShell = -1;  // indicate unchecked as yet
bool	g_fRunScriptElevated = false; // This is exactly the same flag as
									  // CMsiEngine::m_fRunScriptElevated and
									  // CMsiExecute::m_fRunScriptElevated.
									  // It's needed by MsiGetDiskFreeSpace.
									  // It had to be set wherever m_fRunScriptElevated
									  // is set.

HINSTANCE g_hMsiMessage = 0;  // MSI message DLL, only if required
extern DWORD g_dwImpersonationSlot;
extern Bool IsTerminalServerInstalled();
extern bool LoadCurrentUserKey(bool fSystem);
IMsiRegKey* g_piSharedDllsRegKey    = 0;
IMsiRegKey* g_piSharedDllsRegKey32  = 0;	// initialized only on Win64 (to the redirected 32-bit key)
CWin64DualFolders g_Win64DualFolders;


#ifdef UNICODE
#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#else
#define _ttoi64     _atoi64
#define _i64tot     _i64toa
#endif // UNICODE


// components needed to be special cased for app compat fixes 350947 and 368867
const ICHAR TTSData_A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24[]          = TEXT("{EAE142B2-F460-44AB-903B-C25D81FC566E}");
const ICHAR SapiCplHelpEng_0880F209_45FA_42C5_92AE_5E620033E8EC[]	= TEXT("{E1ABFC3B-9E84-4099-A79F-E51EDE5368E2}");
const ICHAR SapiCplHelpJpn_0880F209_45FA_42C5_92AE_5E620033E8EC[]	= TEXT("{0D6004A4-1C6F-4095-B989-87D0001E4767}");
const ICHAR SapiCplHelpChs_0880F209_45FA_42C5_92AE_5E620033E8EC[]	= TEXT("{5F1AAAD1-7FD5-4A91-8973-C08881C9B602}");

//____________________________________________________________________________
//
// COM objects produced by this module's class factories
//____________________________________________________________________________

const GUID rgCLSID[CLSID_COUNT] =
{
	GUID_IID_IMsiServices,
	GUID_IID_IMsiServicesAsService,
#ifdef DEBUG
	GUID_IID_IMsiServicesDebug,
	GUID_IID_IMsiServicesAsServiceDebug,
#endif
	GUID_IID_IMsiEngine
 , GUID_IID_IMsiConfigurationManager
 , GUID_IID_IMsiMessage
 , GUID_IID_IMsiExecute
 , GUID_IID_IMsiServerProxy
 , GUID_IID_IMsiConfigManagerAsServer
 , GUID_IID_IMsiCustomActionProxy
 , GUID_IID_IMsiRemoteAPIProxy
#ifdef CONFIGDB
 , GUID_IID_IMsiConfigurationDatabase
#endif // CONFIGDB
#ifdef DEBUG
 , GUID_IID_IMsiEngineDebug
 , GUID_IID_IMsiConfigManagerDebug
 , GUID_IID_IMsiConfigMgrAsServerDebug
#endif
//  , GUID_IID_IMsiMessageUnmarshal
};
const GUID& IID_IMsiEngineShip  = rgCLSID[SERVICES_CLSID_COUNT * SERVICES_CLSID_MULTIPLE];
#ifdef DEBUG
const GUID& IID_IMsiEngineDebug = rgCLSID[CLSID_COUNT - DEBUG_CLSID_COUNT];
#endif //DEBUG

const ICHAR* rgszProgId[CLSID_COUNT] =
{
	SZ_PROGID_IMsiServices,
	SZ_PROGID_IMsiServices,
#ifdef DEBUG
	SZ_PROGID_IMsiServicesDebug,
	SZ_PROGID_IMsiServicesDebug,
#endif
	SZ_PROGID_IMsiEngine
 , SZ_PROGID_IMsiConfiguration
 , SZ_PROGID_IMsiMessage
 , SZ_PROGID_IMsiExecute
 , 0
 , SZ_PROGID_IMsiConfiguration
 , 0
 , 0
#ifdef CONFIGDB
 , SZ_PROGID_IMsiConfigurationDatabase
#endif // CONFIGDB
#ifdef DEBUG
 , SZ_PROGID_IMsiEngineDebug
 , SZ_PROGID_IMsiConfigDebug
 , SZ_PROGID_IMsiConfigDebug
#endif
};

const ICHAR* rgszDescription[CLSID_COUNT] =
{
	SZ_DESC_IMsiServices,
	SZ_DESC_IMsiServices,
#ifdef DEBUG
	SZ_DESC_IMsiServicesDebug,
	SZ_DESC_IMsiServicesDebug,
#endif
	SZ_DESC_IMsiEngine
 , SZ_DESC_IMsiConfiguration
 , SZ_DESC_IMsiMessage
 , SZ_DESC_IMsiExecute
 , SZ_DESC_IMsiServer
 , SZ_DESC_IMsiConfiguration
 , SZ_DESC_IMsiCustomAction
 , SZ_DESC_IMsiRemoteAPI
#ifdef CONFIGDB
 , SZ_DESC_IMsiConfigurationDatabase
#endif // CONFIGDB
 #ifdef DEBUG
 , SZ_DESC_IMsiEngineDebug
 , SZ_DESC_IMsiConfigDebug
 , SZ_DESC_IMsiConfigDebug
#endif
};

IUnknown* CreateServicesAsService();

ModuleFactory rgFactory[CLSID_COUNT] =
{
	(ModuleFactory)CreateServices,
	CreateServicesAsService,
#ifdef DEBUG
	(ModuleFactory)CreateServices,
	CreateServicesAsService,
#endif
	ENG::CreateEngine
 , (ModuleFactory)ENG::CreateConfigurationManager
 , (ModuleFactory)ENG::CreateMessageHandler
 , (ModuleFactory)ENG::CreateExecutor
 , (ModuleFactory)ENG::CreateMsiServerProxy
 , (ModuleFactory)ENG::CreateConfigManagerAsServer
 , (ModuleFactory)ENG::CreateCustomAction
 , (ModuleFactory)ENG::CreateMsiRemoteAPI
#ifdef CONFIGDB
 , (ModuleFactory)ENG::CreateConfigurationDatabase
#endif // CONFIGDB
#ifdef DEBUG
 , ENG::CreateEngine
 , (ModuleFactory)ENG::CreateConfigurationManager
 , (ModuleFactory)ENG::CreateConfigManagerAsServer
#endif
};

//____________________________________________________________________________
//
// MsiServices and MsiServerProxy factories
//____________________________________________________________________________

// used by engine, config mgr, and handle mgr to share instance of services

IMsiServices* g_piSharedServices = 0;
static int           g_cSharedServices = 0;
static int           g_iSharedServicesLock = 0;

IMsiServices* LoadServices()
{
	while (TestAndSet(&g_iSharedServicesLock) == true)
	{
		Sleep(100);
	}

	if (g_piSharedServices == 0)
	{
		g_piSharedServices = CreateServices();
		if (g_piSharedServices == 0)  //!! what to do if this fails?
		{
			g_iSharedServicesLock = 0;
			return 0;
		}
	}
	g_cSharedServices++;
	g_iSharedServicesLock = 0;
	return g_piSharedServices;
}

int FreeServices()
{
	while (TestAndSet(&g_iSharedServicesLock) == true)
	{
		Sleep(100);
	}

	Assert(g_cSharedServices > 0);
	if (--g_cSharedServices == 0)
	{
		if (g_piSharedDllsRegKey != 0)
		{
			g_piSharedDllsRegKey->Release();
			g_piSharedDllsRegKey = 0;
		}
#ifdef _WIN64
		if (g_piSharedDllsRegKey32 != 0)
		{
			g_piSharedDllsRegKey32->Release();
			g_piSharedDllsRegKey32 = 0;
		}
#endif

		g_piSharedServices->ClearAllCaches();  // release cached volume objects
		g_piSharedServices->Release(), g_piSharedServices = 0;
	}

	g_iSharedServicesLock = 0;
	return g_cSharedServices;
}


IMsiServer* CreateMsiServerProxy()
{
	// We never will succeed on Win9x
	if (g_fWin9X)
		return 0;
		
	IMsiServer* piUnknown = NULL;
	HRESULT hRes = S_OK;
	hRes = OLE32::CoCreateInstance(IID_IMsiServer, 
								   0, 
								   CLSCTX_LOCAL_SERVER, 
								   IID_IUnknown,
								   (void**)&piUnknown);
	
	if (FAILED(hRes))
	{
		// if the service is not registered, CoCreateInstance will return REGDB_E_CLASSNOTREG.
		// In that scenario we can fail immediately. However if the service has timed out and
		// is shutting down, we might get back E_NOINTERFACE or CO_E_SERVER_STOPPING. In that
		// case, retry the create. Similarly, an rpc error is most likely caused by the rpcss 
		// server not having started yet - see bug 8258. Retry once every 100 ms for 30 seconds
		int cAttempts = 1;
		while( (hRes == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) ||
				hRes == HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) ||
				hRes == E_NOINTERFACE ||
				hRes == CO_E_SERVER_STOPPING) &&
				cAttempts++ < 300)
		{
			Sleep(100);
			
			hRes = OLE32::CoCreateInstance(IID_IMsiServer, 0, CLSCTX_LOCAL_SERVER, IID_IUnknown,
													 (void**)&piUnknown);
		}
	}
	
	//
	// Explicitly set the proxy blanket so that we are not affected by the default DCOM settings
	// on the machine.
	//
	if (SUCCEEDED(hRes))
		hRes = SetMinProxyBlanketIfAnonymousImpLevel (piUnknown);
	
	CComPointer<IMsiServer> pDispatch(0);
	if (SUCCEEDED(hRes))
	{
		hRes = piUnknown->QueryInterface(IID_IMsiServer, (void**)&pDispatch);
	}
	
	IMsiServer* piServer = NULL;
	if (SUCCEEDED(hRes))
	{
		piServer = ENG::CreateMsiServerProxyFromRemote(*pDispatch);
		if (!piServer)
			hRes = E_FAIL;
	}
	
	if(FAILED(hRes))
	{
		ICHAR rgchBuf[15];
		StringCchPrintf(rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR),  TEXT("0x%X"), hRes);
		DEBUGMSGE(EVENTLOG_WARNING_TYPE,
					  EVENTLOG_TEMPLATE_CANNOT_CONNECT_TO_SERVER,
					  rgchBuf);
	}
	
	// Cleanup
	if (piUnknown)
	{
		piUnknown->Release();
		piUnknown = NULL;
	}
	
	return piServer;
}

IMsiServer* CreateMsiServer(void)
{
    IMsiServer* piServer = 0;

    if (FIsUpdatingProcess())
    {
        // Run in-proc if we are on Win9x or if we are already in the service.
        piServer = ENG::CreateConfigurationManager();
    }
    else
    {
        // Note: this will return 0 if we are unable to connect to the service
        // for some reason. In that case the installation will fail.
        piServer = ENG::CreateMsiServerProxy();
    }

    return piServer;
}

//
// Do we have access to the installer key
// If we don't, it means the service has run on this machine and
// we need to continue running as a service
bool FCanAccessInstallerKey()
{
	HKEY hKey;
	
	DWORD dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szMsiLocalInstallerKey, 0,
		KEY_WRITE, &hKey);

	if (dwResult == ERROR_SUCCESS || dwResult == ERROR_FILE_NOT_FOUND)
	{
		if (dwResult == ERROR_SUCCESS)
			RegCloseKey(hKey);
		return true;
	}

	Assert(dwResult == ERROR_ACCESS_DENIED);
	return false;
}

//____________________________________________________________________________
//
// CMsiEngine factory
//____________________________________________________________________________

// factory called from OLE class factory, either client or standalone instance, g_MessageContext not intialized
IUnknown* CreateEngine()
{
	//!!# should we set some UI level first?				  


	PMsiServer pServer(0);
	pServer = ENG::CreateMsiServer();
	if (NOERROR != g_MessageContext.Initialize(fTrue, (iuiEnum)iuiDefault))  // UI in child thread //?? Is iuiDefault correct?
		return 0;
	IMsiServices* piServices = ENG::LoadServices(); // must succeed if pServer valid
	if(piServices)
	{
		IMsiEngine* piEngine = new CMsiEngine(*piServices, pServer, 0, 0, 0);
		if (!piEngine)
			ENG::FreeServices();
		return piEngine;
	}
	return NULL;
}

// factory called from MsiEnableUIPreview

IMsiEngine* CreateEngine(IMsiDatabase& riDatabase)
{
	PMsiServer pConfigManager(ENG::CreateConfigurationManager());
	if (!pConfigManager)
		return 0;  // should happen only if out of memory
	if (NOERROR != g_MessageContext.Initialize(fTrue, iuiNextEnum)) // special case for no Basic UI
		return 0;
	IMsiServices* piServices = ENG::LoadServices(); // must succeed if config mgr
	if(piServices)
	{
		IMsiEngine* piEngine = new  CMsiEngine(*piServices, pConfigManager, 0, &riDatabase, 0);
		if (!piEngine)
			ENG::FreeServices();
		return piEngine;
	}
	else
		return NULL;
}

// factory called from RunEngine() - API layer or nested install action, g_MessageContext already initialized (?)
IMsiEngine*  CreateEngine(IMsiStorage* piStorage, IMsiDatabase* piDatabase, CMsiEngine* piParentEngine, BOOL fServiceRequired)
{
	PMsiServer pServer(0);
	pServer = ENG::CreateMsiServer();
	if (fServiceRequired && !pServer)
	    return 0;  // Must connect to the service (or be running as the service if fServiceRequired is TRUE.)
	IMsiServices* piServices = ENG::LoadServices(); // must succeed if proxy created
	if(piServices)
	{
		CMsiEngine* piEngine = new CMsiEngine(*piServices, pServer,
										piStorage, piDatabase, piParentEngine);
		if (!piEngine)
			ENG::FreeServices();
		return (IMsiEngine*)piEngine;
	}
	return NULL;
}

//____________________________________________________________________________
//
// CMsiServerConnMgr implementation
//____________________________________________________________________________

CMsiServerConnMgr::CMsiServerConnMgr(CMsiEngine* pEngine)
{
    m_fOleInitialized = FALSE;
    m_fCreatedConnection = FALSE;
    m_fObtainedConfigManager = FALSE;
    m_ppServer = NULL;
    m_ppConfigManager = NULL;

    if (pEngine)
    {
    m_ppServer = &(pEngine->m_piServer);
    m_ppConfigManager = &(pEngine->m_piConfigManager);

    if (NULL == (*m_ppServer))
    {
        if (FALSE == m_fOleInitialized &&
        SUCCEEDED(OLE32::CoInitialize(NULL))
        )
        {
        m_fOleInitialized = TRUE;
        }

        *m_ppServer = ENG::CreateMsiServer();
        if (*m_ppServer)
        m_fCreatedConnection = TRUE;
    }

    if (*m_ppServer && NULL == *m_ppConfigManager)
    {
        if (FALSE == m_fOleInitialized &&
        SUCCEEDED(OLE32::CoInitialize(NULL))
        )
        {
        m_fOleInitialized = TRUE;
        }

        (*m_ppServer)->QueryInterface(IID_IMsiConfigurationManager,
                      (void **)m_ppConfigManager);
        if (*m_ppConfigManager)
        m_fObtainedConfigManager = TRUE;
    }
    }
}

CMsiServerConnMgr::~CMsiServerConnMgr()
{
    if (m_fObtainedConfigManager && *m_ppConfigManager)
    {
    (*m_ppConfigManager)->Release();
    *m_ppConfigManager = NULL;
    }

    if (m_fCreatedConnection && *m_ppServer)
    {
    (*m_ppServer)->Release();
    *m_ppServer = NULL;
    }

    if (m_fOleInitialized)
    {
    OLE32::CoUninitialize();
    }
}

//____________________________________________________________________________
//
// CMsiEngine implementation
//____________________________________________________________________________

CMsiEngine::CMsiEngine(IMsiServices& riServices, IMsiServer* piServer,
			      IMsiStorage* piStorage, IMsiDatabase* piDatabase,
			      CMsiEngine* piParentEngine)
    : m_piServer(piServer)
    , m_riServices(riServices)
    , m_piExternalStorage(piStorage)
    , m_piExternalDatabase(piDatabase)
    , m_piParentEngine(piParentEngine)
    , m_pCachedActionStart(0)
    , m_pActionStartLogRec(0)
    , m_pActionProgressRec(0)
    , m_pScriptProgressRec(0)
    , m_pCostingCursor(0)
    , m_pPatchCacheTable(0)
    , m_pPatchCacheCursor(0)
	, m_pFolderCacheTable(0)
	, m_pFolderCacheCursor(0)
    , m_iioOptions((iioEnum)0)
    , m_pcmsiFile(0)
    , m_fcmsiFileInUse(0)
    , m_iSourceType(-1)
    , m_fRunScriptElevated(false)
    , m_pCustomActionManager(NULL)
    , m_fAssemblyTableExists(true)
    , m_pViewFusion(0), m_pViewFusionNameName (0), m_pViewFusionName (0)
	 , m_pViewOldPatchFusionNameName (0), m_pViewOldPatchFusionName (0)
	 , m_pTempCostsCursor(0)
	 , m_pFileHashCursor(0)
	 , m_fRestrictedEngine(false)
	 , m_fRemapHKCUInCAServers(false)
	 , m_fCAShimsEnabled(false)
	 , m_fNewInstance(false)

{  // all  members zeroed by operator new
	// We don't hold a ref to services, we must call ENG::FreeServices() at end
	m_iRefCnt = 1;  // factory does not do QueryInterface, no aggregation
	
	if (m_piServer)
            m_piServer->AddRef();
	
	g_cInstances++;
	m_scmScriptMode = scmIdleScript;
	if (piStorage)
		piStorage->AddRef();
	if (piDatabase)
		piDatabase->AddRef();
	if (piParentEngine)
		piParentEngine->AddRef();
    
	memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
	memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));

	InitializeCriticalSection(&m_csCreateProxy);
	AssertSz(g_MessageContext.IsInitialized(), "MessageContext not initialized");
}

CMsiEngine::~CMsiEngine()
{
	if (m_fInitialized)  // should never happen due to handler holding ref
	{
		// this can happen if no or basic UI, should never happen if system updated
		// will also happen in UI preview mode
//              AssertSz((m_iuiLevel == iuiNone || m_iuiLevel == iuiBasic) && (GetMode() & iefServerLocked) == 0,
//                                      "Engine not terminated");
		Terminate(iesNoAction); // if assert above doesn't fail, this is safe
	}

	DeleteCriticalSection(&m_csCreateProxy);

	if (m_piExternalStorage)
		m_piExternalStorage->Release();
	if (m_piExternalDatabase)
		m_piExternalDatabase->Release();
	if (m_piParentEngine)
		m_piParentEngine->Release();
	else if (g_MessageContext.ChildUIThreadExists())  // last one out turns off the lights
		g_MessageContext.Terminate(fFalse);  // if main engine in child thread, then called by UI thread
	g_cInstances--;
}

// Private function to clear member data, used by Terminate and Initialize failure

void CMsiEngine::ClearEngineData()
{
	for (int i = 0; i < cCachedHeaders; i++)
		if (m_rgpiMessageHeader[i])
		{
			m_rgpiMessageHeader[i]->Release();
			m_rgpiMessageHeader[i] = 0;
		}
	if (m_piProductKey)   m_piProductKey->Release(),     m_piProductKey = 0;
	if (m_pistrPlatform)  m_pistrPlatform->Release(),    m_pistrPlatform = 0;
	if (m_piPropertyCursor)
	{
		m_piPropertyCursor->Release(), m_piPropertyCursor = 0;
	}
	if (m_piActionTextCursor)
	{
		m_piActionTextCursor->Release(), m_piActionTextCursor = 0;
	}

	if (m_piActionDataFormat) m_piActionDataFormat->Release(), m_piActionDataFormat = 0;
	if (m_piActionDataLogFormat) m_piActionDataLogFormat->Release(), m_piActionDataLogFormat = 0;

	if (m_fSummaryInfo)
	{
		m_pistrSummaryComments->Release(), m_pistrSummaryComments = 0;
		m_pistrSummaryKeywords->Release(), m_pistrSummaryKeywords = 0;
		m_pistrSummaryTitle->Release(),    m_pistrSummaryTitle    = 0;
		m_pistrSummaryProduct->Release(),  m_pistrSummaryProduct  = 0;
		m_pistrSummaryPackageCode->Release(), m_pistrSummaryPackageCode = 0;
		m_fSummaryInfo = fFalse;
	}

	m_fRegistered = fFalse;
	m_fAdvertised = fFalse;
	m_fMode = 0;
	m_fCostingComplete = false;
	m_fSelManInitComplete = false;
	m_fForegroundCostingInProgress = false;
	m_fExclusiveComponentCost = fFalse;

	m_fSourceResolutionAttempted = false;
	
	m_fDisabledRollbackInScript = fFalse;

	if (m_pExecuteScript)  // execute script file left open, probably after a cancel
	{
		Assert(m_pistrExecuteScript);
		delete m_pExecuteScript, m_pExecuteScript = 0;
		WIN::DeleteFile(m_pistrExecuteScript->GetString());
	}
	if(m_pSaveScript)
	{
		delete m_pSaveScript;
		m_pSaveScript = 0;
	}
	m_scmScriptMode = scmIdleScript;

	if (m_pistrExecuteScript)
	{
		m_pistrExecuteScript->Release();
		m_pistrExecuteScript = 0;
	}
	if (m_pistrSaveScript)
	{
		m_pistrSaveScript->Release();
		m_pistrSaveScript = 0;
	}

	if (m_piRegistryActionTable)
	{
		m_piRegistryActionTable->Release();
		m_piRegistryActionTable = 0;
	}

	if (m_piFileActionTable)
	{
		m_piFileActionTable->Release();
		m_piFileActionTable = 0;
	}

	if(m_piDatabase)
		m_piDatabase->Release(), m_piDatabase = 0;

	m_iioOptions = (iioEnum)0;
	m_iSourceType = -1;

	Assert(!m_fcmsiFileInUse);
	if (m_pcmsiFile)
	{
		delete m_pcmsiFile;
		m_pcmsiFile = 0;
	}

	m_strPatchDownloadLocalCopy = g_MsiStringNull;

	memset(&m_ptsState, 0, sizeof(m_ptsState));

	// reset appcompat data
	m_fCAShimsEnabled = false;
	memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
	memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));

	// attempt to clean up any temp files that were created
	while (m_strTempFileCopyCleanupList.TextSize() != 0)
	{
		MsiString strFile = m_strTempFileCopyCleanupList.Extract(iseUpto, ';');

		if (strFile.TextSize() == 0)
		{
			//
			// Maybe this is a malformed list and there are multiple consecutive
			// semicolons. So we must remove any such semicolons and continue
			// If strFile.TextSize == 0 because of a memory allocation failure,
			// we might end up leaving some temp files behind.
			//
			if (!m_strTempFileCopyCleanupList.Remove(iseIncluding, ';'))
				break;
			continue;
		}

		if (g_scServerContext == scService)
		{
			CElevate elevate;
			DEBUGMSGV1(TEXT("Attempting to delete file %s"), strFile);
			if (!WIN::DeleteFile(strFile))
			{
				DEBUGMSGV1(TEXT("Unable to delete the file. LastError = %d"), (const ICHAR*)(INT_PTR)GetLastError());
			}
		}
		else
		{
			DEBUGMSGV1(TEXT("Attempting to delete file %s"), strFile);
			if (!WIN::DeleteFile(strFile))
			{
				DEBUGMSGV1(TEXT("Unable to delete the file. LastError = %d"), (const ICHAR*)(INT_PTR)GetLastError());
			}
		}

		if (!m_strTempFileCopyCleanupList.Remove(iseIncluding, ';'))
			break;
	}

	m_strTempFileCopyCleanupList = g_MsiStringNull;

}

HRESULT CMsiEngine::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiEngineShip))
		*ppvObj = (IMsiEngine*)this;
	else if (MsGuidEqual(riid, IID_IMsiMessage))
		*ppvObj = (IMsiMessage*)this;
#ifdef DEBUG
	else if (MsGuidEqual(riid, IID_IMsiEngineDebug))
		*ppvObj = (IMsiEngine*)this;
	else if (MsGuidEqual(riid, IID_IMsiDebug))
		*ppvObj = (IMsiDebug*)this;
#endif
	else if (MsGuidEqual(riid, IID_IMsiSelectionManager))
		*ppvObj = (IMsiSelectionManager*)this;
	else if (MsGuidEqual(riid, IID_IMsiDirectoryManager))
		*ppvObj = (IMsiDirectoryManager*)this;
	else
		return (*ppvObj = 0, E_NOINTERFACE);
	AddRef();
	return NOERROR;
}
unsigned long CMsiEngine::AddRef()
{
	return ++m_iRefCnt;
}
unsigned long CMsiEngine::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	
	if (m_piServer)
	    m_piServer->Release();
	
	if (m_piConfigManager)
		m_piConfigManager->Release();
	delete this;
	if (g_hMsiMessage)
		WIN::FreeLibrary(g_hMsiMessage), g_hMsiMessage = 0;
	ENG::FreeServices();
	return 0;
}

IMsiServices* CMsiEngine::GetServices()
{
	m_riServices.AddRef();
	return &m_riServices;
}

HRESULT CMsiEngine::SetLanguage(LANGID iLangId)
{
	m_iLangId = iLangId;
	return NOERROR;
}

LANGID CMsiEngine::GetLanguage()
{
	return m_iLangId;
}

IMsiServer* CMsiEngine::GetConfigurationServer()
{
    if (m_piServer)
	m_piServer->AddRef();
    
    return m_piServer;
}

IMsiDatabase* CMsiEngine::GetDatabase()
{
	if (m_piDatabase)
		m_piDatabase->AddRef();
	return m_piDatabase;
}

// formats MsiDate to MsiString
const IMsiString& DateTimeToString(int iDateTime)
{
	MsiString istrText;
	int iValue;
	int rgiDate[6];

	for (iValue = 5; iValue >= 0; iValue--)
	{
		rgiDate[iValue] = iDateTime & (( 1 << rgcbDate[iValue]) - 1);
		iDateTime >>= rgcbDate[iValue];
	}
	iValue = (rgiDate[0] == 0 && rgiDate[1] == 0 ? 3 : 0);
	rgiDate[0] += 1980;
	rgiDate[5] *= 2;
	for (;;)
	{
		int i = rgiDate[iValue];
		if (i < 10)
			istrText += TEXT("0");
		istrText += MsiString(i);
		if (rgchDelim[iValue] == 0)
			break;
		istrText += MsiString(MsiChar(rgchDelim[iValue++]));
	}
	return istrText.Return();
}

CMsiCustomActionManager *GetCustomActionManager(IMsiEngine *piEngine);
///////////////////////////////////////////////////////////////////////
// remaps the HKCU registry key to either HKCU (if not TS per machine)
// or HKU\.Default (if TS per machine). Also resets custom action server
bool PrepareHydraRegistryKeyMapping(bool fTSPerMachineInstall)
{
	if (g_fWin9X)
		return true;

	AssertSz(g_scServerContext == scService, "Wrong context for Registry Key Mapping");

	// close HKCU and reopen it as .Default. Without this, we'll actually use HKCU, and ODBC
	// will write to HKCU due to the preloaded key.
	LoadCurrentUserKey(/*fSystem=*/fTSPerMachineInstall);

	// ensure that the current custom action server state for mapped registry keys matches
	// what we expect
	CMsiCustomActionManager* pCustomActionManager = ::GetCustomActionManager(NULL);
	AssertSz(pCustomActionManager, "No custom action manager while preparing key mapping.");
	if (pCustomActionManager)
	{
		pCustomActionManager->EnsureHKCUKeyMappingState(/*fRemapHKCU=*/!fTSPerMachineInstall);
	}
	return true;
}

bool CMsiEngine::OpenHydraRegistryWindow(bool fNewTransaction)
{
	// If TS5 and installing per-machine, call the propogation API to notify Hydra that an
	// install is beginning, unless we're doing an Admin Install, or creating an advertise
	// script
	if (MinimumPlatformWindows2000() && IsTerminalServerInstalled())
	{
		if (!(GetMode() & (iefAdmin | iefAdvertise)) && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
		{
			PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/true);
	
			// only open the actual registry window in a new transaction, not after reboot
			if (fNewTransaction)
			{
				// must call Hydra APIs as system					  
				CElevate elevate;
		
				Assert(!m_fInParentTransaction);
				DEBUGMSG("Opening Terminal Server registry propogation window.");
		
				NTSTATUS lResult = STATUS_SUCCESS;
				for(int iContinueRetry = 3; iContinueRetry--;)// try thrice, prevent possibly endless recursion
				{
					if (NT_SUCCESS(lResult = TSAPPCMP::TermServPrepareAppInstallDueMSI()))
						break;
					if (iContinueRetry && (lResult == STATUS_INSUFFICIENT_RESOURCES))
					{
						// Hydra couldn't create a ref copy of the registry tree because we were
						// out of registry space. Increase quota and try again.
						if (!IncreaseRegistryQuota())
							break;
					}
					else
					{
						DEBUGMSG1(TEXT("Failed to open Terminal Server registry window. Status code 0x%08X"), (const ICHAR*)(INT_PTR)lResult);
						break;
					}
				}
				return NT_SUCCESS(lResult);
			}
			return true;
		}
		else
		{
			// ensure that the current custom action server state for mapped registry keys matches
			// what we expect.
			PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/false);
		}
	}

	// don't need to call Hydra.
	return true;
}

bool CMsiEngine::CloseHydraRegistryWindow(bool bCommit)
{
	// If TS5 and installing per-machine, call the propogation API to notify Hydra that an
	// install is done or aborted, unless we're doing an Admin Install, or creating an advertise
	// script
	if (IsTerminalServerInstalled() && g_iMajorVersion >= 5 && !(GetMode() & (iefAdmin | iefAdvertise)) &&
		MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
	{														  
		// must call Hydra API from system context
		CElevate elevate;

		Assert(!m_fInParentTransaction);
		DEBUGMSG1("Closing Terminal Server registry propogation window. %s", bCommit ? "Saving Changes." : "Discarding Changes.");

		NTSTATUS lResult = STATUS_SUCCESS;
		if (bCommit)
		{
			for(int iContinueRetry = 3; iContinueRetry--;)// try thrice, prevent possibly endless recursion
			{
				if (NT_SUCCESS(lResult = TSAPPCMP::TermServProcessAppInstallDueMSI(!bCommit)))
					break;
				if (iContinueRetry && (lResult == STATUS_INSUFFICIENT_RESOURCES))
				{
					// Hydra couldn't propogate the new keys to its private hive due to registry
					// limits. Try again.
					if (!IncreaseRegistryQuota())
						break;
				}
				else
				{
					DEBUGMSG1(TEXT("Failed to close Terminal Server registry window. Status code 0x%08X."), (const ICHAR*)(INT_PTR)lResult);
					break;
				}											  
			}
		}

		// must always call Process() with cleanup TRUE. Cleanup = FALSE (i.e. save changes)
		// will not destroy hive. Nothing to do if we fail.	  
		TSAPPCMP::TermServProcessAppInstallDueMSI(TRUE);

		// if we were successful in propogating registry information to the TS hive, trigger an immediate
		// propogation to HKCU. This ensures that the shell (a TS-aware app) doesn't continually try to 
		// repair shortcuts that need to detect HKCU keypaths which have not yet been propogated.
		if (NT_SUCCESS(lResult))
		{
			// these APIs must be called while impersonated for the correct HKCU to be used.
			CImpersonate impersonate;

			// trigger an immediate propogation. No return value
			TSAPPCMP::TermsrvCheckNewIniFiles();

			// if a registry key already existed in both HKCU and the TS hive, the first propogation
			// merely deletes the old keys, expecting on-demand propogation to replace them with the
			// new values. However the shell is TS-aware and does not trigger the propogation on demand.
			// Thus we force a second propogation to copy the new keys.

			// don't use HKEY_CURRENT USER because it might be cached as .Default for TS propogation.
			// Instead, since we are impersonated here, we can use the RegOpenCurrentUser API to explicitly
			// get the true HKCU for the user.
			HKEY hCurrentUserKey = 0;
			if (ERROR_SUCCESS == ADVAPI32::RegOpenCurrentUser(KEY_READ, &hCurrentUserKey))
			{
				// delete the TS timestamp to force a second refresh.
				HKEY hKey = 0;
				DWORD dwResult = RegOpenKeyAPI(hCurrentUserKey, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"), 0, KEY_ALL_ACCESS, &hKey);
				if (ERROR_SUCCESS == dwResult)
				{
					RegDeleteValue(hKey, TEXT("LastUserIniSyncTime"));
					RegCloseKey(hKey);
				
					// timestamp was deleted, force a second propogation
					TSAPPCMP::TermsrvCheckNewIniFiles();
				}
				RegCloseKey(hCurrentUserKey);
			}
		}

		return NT_SUCCESS(lResult);
	}
	return true;
}


const ICHAR rgchSRAPIfailed[] = TEXT("The call to SRSetRestorePoint API failed. Returned status: %d. ")
										  TEXT("GetLastError() returned: %d");
const ICHAR rgchSRAPIdisabled[] = TEXT("The System Restore service is disabled. Returned status: %d. ")
										  TEXT("GetLastError() returned: %d");

const ICHAR rgchCallingSRAPI[] = TEXT("Calling SRSetRestorePoint API. dwRestorePtType: %d, dwEventType: %d, ")
										   TEXT("llSequenceNumber: %s, szDescription: \"%s\".");
const ICHAR rgchSRAPISuccess[] = TEXT("The call to SRSetRestorePoint API succeeded. Returned status: %d.");
const ICHAR rgchSRAPISuccessAndNo[] = TEXT("The call to SRSetRestorePoint API succeeded. Returned status: %d, llSequenceNumber: %s.");

// returns the current install's type (advertise, install, uninstall, maintenance, deploy)
// NOTE: if not called after InstallValidate, may not return "uninstall" during an uninstall
iitEnum CMsiEngine::GetInstallType()
{
	if ( m_iioOptions & iioCreatingAdvertiseScript )
	{
		// creating an advertise script
		return iitDeployment;
	}
	else if( m_fAdvertised )
	{
		// maintenance mode
		if( MsiString(GetPropertyFromSz(IPROPNAME_FEATUREREMOVE)).Compare(iscExactI, IPROPVALUE_FEATURE_ALL) )
		{
			return iitUninstall;
		}
		else
		{
			return (m_fRegistered) ? iitMaintenance : iitFirstInstallFromAdvertised;
		}
	}
	else
	{
		// first install/advertise
		if( GetMode() & iefAdvertise )
		{
			return iitAdvertise;
		}
		else
		{
			return iitFirstInstall;
		}
	}
}

void CMsiEngine::BeginSystemChange()
{
	m_i64PCHEalthSequenceNo = 0;

	if (MinimumPlatformMillennium() || MinimumPlatformWindowsNT51())
	{
		// we're running on Millenium or later 
		iuiEnum iui = (iuiEnum)GetPropertyInt(*MsiString(IPROPNAME_CLIENTUILEVEL));
		if (g_MessageContext.IsOEMInstall() || 
			((iuiNone == iui) || (iuiDefault == iui)) || 
			(GetMode() & iefAdmin) ||
			(GetIntegerPolicyValue(szLimitSystemRestoreCheckpoint, fTrue) > 0))
		{
			// no check points during OEM install, No-UI modes, 
			// when LimitSystemRestoreCheckpoint policy is set, or administrative installs.
			DEBUGMSGV(TEXT("SRSetRestorePoint skipped for this transaction."));
			return;

		}

		ICHAR rgchBuffer[64];

		RESTOREPOINTINFO strPtInfo;
		strPtInfo.dwRestorePtType = -1;
		MsiString strMessage;


		MsiString strProduct(GetPropertyFromSz(IPROPNAME_PRODUCTNAME));
		PMsiRecord piRec(0);
		iitEnum iitInstallType = GetInstallType();
		if ( iitInstallType == iitFirstInstall ||
			 iitInstallType == iitFirstInstallFromAdvertised )
		{
			// we're installing a new product
			strPtInfo.dwRestorePtType = APPLICATION_INSTALL;
			piRec = PostError(Imsg(imsgSRRestorePointInstall), *strProduct);
			piRec->SetMsiString(0, *MsiString(GetErrorTableString(imsgSRRestorePointInstall)));
			strMessage = MsiString(piRec->FormatText(fTrue));
		}
		else if ( iitInstallType == iitUninstall )
		{
			// we're removing a product
			strPtInfo.dwRestorePtType = APPLICATION_UNINSTALL;
			piRec = PostError(Imsg(imsgSRRestorePointRemove), *strProduct);
			piRec->SetMsiString(0, *MsiString(GetErrorTableString(imsgSRRestorePointRemove)));
			strMessage = MsiString(piRec->FormatText(fTrue));
		}
		else if ( (iitInstallType == iitDeployment)  || 
                          (iitInstallType == iitAdvertise)   ||
                          (iitInstallType == iitMaintenance)   )
		{
			// These scenarios should not invoke system restore
			DEBUGMSGV(TEXT("SRSetRestorePoint skipped for this transaction."));
			return;
		}
		else
		{
			Assert(0);
			return;
		}

		if ( strMessage.TextSize() && strPtInfo.dwRestorePtType != -1 )
		{
			// we have work to do.
			int nLen = sizeof(strPtInfo.szDescription) / sizeof(ICHAR);
			if ( strMessage.TextSize() >= nLen ) // don't forget the NULL termination
				// the string is too long
				strMessage = strMessage.Extract(iseFirst, nLen-1);
#ifdef UNICODE
			strPtInfo.dwEventType = BEGIN_NESTED_SYSTEM_CHANGE;
#else
			int newLen = nLen-1;
			while(strMessage.TextSize() >= nLen)
			{
				strMessage = strMessage.Extract(iseFirst, --newLen);
			}

			strPtInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
#endif
			strPtInfo.llSequenceNumber = 0;
			ASSERT_IF_FAILED(StringCchCopy(strPtInfo.szDescription,
													 ARRAY_ELEMENTS(strPtInfo.szDescription),
													 (const ICHAR *)strMessage));

			STATEMGRSTATUS strStatus;
			memset(&strStatus, 0, sizeof(strStatus));

			DEBUGMSG4(rgchCallingSRAPI,
						 (const ICHAR *)(INT_PTR)strPtInfo.dwRestorePtType,
						 (const ICHAR *)(INT_PTR)strPtInfo.dwEventType,
						 _i64tot(strPtInfo.llSequenceNumber, rgchBuffer, 10),
						 strPtInfo.szDescription);

			if ( !SYSTEMRESTORE::SRSetRestorePoint(&strPtInfo, &strStatus) )
			{
				DWORD dwError = WIN::GetLastError();
				const ICHAR const* pszSRAPIresult = (ERROR_SERVICE_DISABLED == strStatus.nStatus) ? rgchSRAPIdisabled : rgchSRAPIfailed;

				DEBUGMSG2(pszSRAPIresult,
							 (const ICHAR *)(INT_PTR)strStatus.nStatus,
							 (const ICHAR *)(INT_PTR)dwError);
				m_i64PCHEalthSequenceNo = 0;
			}
			else
			{
				DEBUGMSG2(rgchSRAPISuccessAndNo,
							 (const ICHAR *)(INT_PTR)strStatus.nStatus,
							 _i64tot(strStatus.llSequenceNumber, rgchBuffer, 10));
				//Assert(strStatus.llSequenceNumber != 0);
				// Assert(strStatus.nStatus == 0);
				m_i64PCHEalthSequenceNo = strStatus.llSequenceNumber;
			}
		}
	}
	return;
}

const ICHAR rgchNoSRSequence[] = TEXT("No System Restore sequence number for this installation.");

void CMsiEngine::EndSystemChange(bool fCommitChange, const ICHAR *szSequenceNo)
{
	if ( !(MinimumPlatformMillennium() || MinimumPlatformWindowsNT51()) || g_MessageContext.IsOEMInstall() )
		// we're not running on Millenium/Whistler or later or we're running in FASTOEM mode.
		return;
	else if ( !szSequenceNo || !*szSequenceNo )
	{
		DEBUGMSG(rgchNoSRSequence);
		return;
	}

	EndSystemChange(fCommitChange, _ttoi64(szSequenceNo));
}

void CMsiEngine::EndSystemChange(bool fCommitChange, INT64 iSequenceNo)
{
	if ( !(MinimumPlatformMillennium() || MinimumPlatformWindowsNT51())|| g_MessageContext.IsOEMInstall() )
		// we're not running on Millenium/Whistler or later or we're running in FASTOEM mode.
		return;
	else if ( iSequenceNo == 0 )
	{
		DEBUGMSG(rgchNoSRSequence);
		return;
	}

	ICHAR rgchBuffer[64];

	RESTOREPOINTINFO strPtInfo;
#ifdef UNICODE
	strPtInfo.dwEventType = END_NESTED_SYSTEM_CHANGE;
#else
	strPtInfo.dwEventType = END_SYSTEM_CHANGE;
#endif
	strPtInfo.llSequenceNumber = iSequenceNo;
	strPtInfo.dwRestorePtType = fCommitChange ? 0 : CANCELLED_OPERATION;
	*strPtInfo.szDescription = 0;

	STATEMGRSTATUS strStatus;
	memset(&strStatus, 0, sizeof(strStatus));

	DEBUGMSG4(rgchCallingSRAPI,
				 (const ICHAR *)(INT_PTR)strPtInfo.dwRestorePtType,
				 (const ICHAR *)(INT_PTR)strPtInfo.dwEventType,
				 _i64tot(strPtInfo.llSequenceNumber, rgchBuffer, 10),
				 strPtInfo.szDescription);
	if ( !SYSTEMRESTORE::SRSetRestorePoint(&strPtInfo, &strStatus) )
	{
		DWORD dwError = WIN::GetLastError();
		const ICHAR const* pszSRAPIresult = (ERROR_SERVICE_DISABLED == strStatus.nStatus) ? rgchSRAPIdisabled : rgchSRAPIfailed;

		DEBUGMSG2(pszSRAPIresult,
					 (const ICHAR *)(INT_PTR)strStatus.nStatus,
					 (const ICHAR *)(INT_PTR)dwError);
	}
	else
		DEBUGMSG1(rgchSRAPISuccess,
					(const ICHAR *)(INT_PTR)strStatus.nStatus);
}


/*------------------------------------------------------------------------------
CMsiEngine::Initialize - paired with Terminate method, determines initialized state
------------------------------------------------------------------------------*/
const int ieiReInitialize          = -1;  // private return from DoInitialize
const int ieiResolveSourceAndRetry = -2;  // private return from InitializeTransforms

ieiEnum CMsiEngine::Initialize(const ICHAR* szDatabase, iuiEnum iuiLevel,
										 const ICHAR* szCommandLine, const ICHAR* szProductCode,
										 iioEnum iioOptions)
{
	ieiEnum ieiStat = ieiSuccess;
	if (m_fInitialized)
		return ieiAlreadyInitialized; // can't happen from launcher
	m_piErrorInfo = &g_MsiStringNull;   // force non-null pointer for duration of this function

	// get local config manager, fails if we're a client connected to server

	if (!m_piConfigManager && m_piServer)
		m_piServer->QueryInterface(IID_IMsiConfigurationManager, (void**)&m_piConfigManager);

	if (ieiStat == ieiSuccess)
	{
		// attempt to use supplied database, switch to maintenance database if installed
		ieiStat = DoInitialize(szDatabase, iuiLevel, szCommandLine, szProductCode, iioOptions);
		if (ieiStat == ieiReInitialize)  // suspended install rolled back, re-initialize
		{
			ClearEngineData(); // reset state information - doesn't release handler
			ieiStat = DoInitialize(szDatabase, iuiLevel, szCommandLine, szProductCode, iioOptions);
		}
	}
	if (ieiStat != ieiSuccess)
	{
		PMsiRecord pRecord = &m_riServices.CreateRecord(3);
		UINT uiStat = MapInitializeReturnToUINT(ieiStat);
		pRecord->SetInteger(1, uiStat);
		pRecord->SetMsiString(3, *m_piErrorInfo);
		MsiString istrError = ENG::GetInstallerMessage(uiStat);
		pRecord->SetMsiString(2, *istrError);
		pRecord->SetString(0, istrError.TextSize() == 0 ? TEXT("Install error [1]. [3]") // should never happen
																			: TEXT("[2]{\r\n[3]}"));
		Message(imtInfo, *pRecord);
		ClearEngineData();  // else data cleared by Terminate()
		ReleaseHandler();
		m_fInitialized = fFalse; //!! is this OK?
	}
	m_piErrorInfo->Release(), m_piErrorInfo = 0;
	m_lTickNextProgress = GetTickCount();
	return ieiStat;
}

Bool CMsiEngine::CreatePropertyTable(IMsiDatabase& riDatabase, const ICHAR* szSourceTable,
												 Bool fLoadPersistent)
{
	PMsiTable pPropertyTable(0);
	PMsiRecord pError(0);
	if(fLoadPersistent)
	{
		if ((pError = riDatabase.LoadTable(*MsiString(szSourceTable), 0, *&pPropertyTable)))
			return fFalse; // no property table
	}
	else
	{
		if ((pError = riDatabase.CreateTable(*MsiString(*sztblPropertyLocal), 0, *&pPropertyTable)))
			return fFalse;
		pPropertyTable->CreateColumn(icdString + icdPrimaryKey, *MsiString(*TEXT("")));
		pPropertyTable->CreateColumn(icdString + icdNoNulls,    *MsiString(*TEXT("")));
	}

	if(m_piPropertyCursor)
		m_piPropertyCursor->Release();
	
	if ((m_piPropertyCursor = pPropertyTable->CreateCursor(fFalse)) == 0)
		return fFalse;
	m_piPropertyCursor->SetFilter(1);  // permanent setting

	if(fLoadPersistent == fFalse)
	{
		if (szSourceTable)
		{
			PMsiTable pSourceTable(0);
			PMsiCursor pSourceCursor(0);
			if ((pError = riDatabase.LoadTable(*MsiString(*szSourceTable), 0, *&pSourceTable)))
				return fTrue; // OK if Property table doesn't exist (but some properties need to be defined to install)
			if ((pSourceCursor = pSourceTable->CreateCursor(fFalse)) == 0)
				return fFalse;
			while (pSourceCursor->Next())
			{
				MsiString istrName  = pSourceCursor->GetString(1);
				MsiString istrValue = pSourceCursor->GetString(2);
				AssertNonZero(m_piPropertyCursor->PutString(1, *istrName));
				AssertNonZero(m_piPropertyCursor->PutString(2, *istrValue));
				if (m_piPropertyCursor->Insert() == fFalse)
					return fFalse;
			}
			m_piPropertyCursor->Reset();
		}
	}
	return fTrue;
}

Bool GetProductInfo(const ICHAR* szProductKey, const ICHAR* szProperty, CTempBufferRef<ICHAR>& rgchInfo)
{
	DWORD cchBuffer = rgchInfo.GetSize();

	UINT uiStat = MSI::MsiGetProductInfo(szProductKey, szProperty, rgchInfo, &cchBuffer);

	if (ERROR_MORE_DATA == uiStat)
	{
		cchBuffer++;
		rgchInfo.SetSize(cchBuffer);
		uiStat = MSI::MsiGetProductInfo(szProductKey, szProperty, rgchInfo, &cchBuffer);
	}

	Assert(ERROR_MORE_DATA != uiStat);

	return (ERROR_SUCCESS == uiStat) ? fTrue : fFalse;
}


Bool GetPatchInfo(const ICHAR* szPatchCode, const ICHAR* szProperty, CTempBufferRef<ICHAR>& rgchInfo)
{
	DWORD cchBuffer = rgchInfo.GetSize();

	UINT uiStat = MSI::MsiGetPatchInfo(szPatchCode, szProperty, rgchInfo, &cchBuffer);

	if (ERROR_MORE_DATA == uiStat)
	{
		rgchInfo.SetSize(cchBuffer+1);
		uiStat = MSI::MsiGetPatchInfo(szPatchCode, szProperty, rgchInfo, &cchBuffer);
	}

	return (ERROR_SUCCESS == uiStat) ? fTrue : fFalse;
}


void ExpandEnvironmentStrings(const ICHAR* szString, const IMsiString*& rpiExpandedString)
/*----------------------------------------------------------------------------
	Expands szString using WIN::ExpandEnvironmentStrings.
------------------------------------------------------------------------------*/
{
	CTempBuffer<ICHAR, MAX_PATH> rgchExpandedInfo;
	
	DWORD dwSize1 = WIN::ExpandEnvironmentStrings(szString, rgchExpandedInfo, rgchExpandedInfo.GetSize());
	if (dwSize1 > rgchExpandedInfo.GetSize())
	{
		// try again with the correct size
		rgchExpandedInfo.SetSize(dwSize1);
		if(dwSize1 <= rgchExpandedInfo.GetSize())
			dwSize1 = WIN::ExpandEnvironmentStrings(szString, (ICHAR*)rgchExpandedInfo, dwSize1);
	}
	Assert(dwSize1 && dwSize1 <= rgchExpandedInfo.GetSize());

	if (dwSize1 && dwSize1 <= rgchExpandedInfo.GetSize())
		rpiExpandedString->SetString(rgchExpandedInfo, rpiExpandedString);
	else
		rpiExpandedString = &g_MsiStringNull ;
}

Bool GetExpandedProductInfo(const ICHAR* szProductCode, const ICHAR* szProperty,
										  CTempBufferRef<ICHAR>& rgchExpandedInfo, bool fPatch)
/*----------------------------------------------------------------------------
Gets an property value and expands the the value using ExpandEnvironmentStrings.

Arguments:
	szProductCode:          The product code of the product
	szProperty:                     The property to retrieve
	rgchExpandedInfo: The buffer for the expanded property value

Returns:        The error code returned from MsiGetProductInfo
------------------------------------------------------------------------------*/
{
	CTempBuffer<ICHAR, MAX_PATH> rgchUnexpandedInfo;
	if (fPatch)
	{
		if (!GetPatchInfo(szProductCode, szProperty, rgchUnexpandedInfo))
			return fFalse;
	}
	else
	{
		if (!GetProductInfo(szProductCode, szProperty, rgchUnexpandedInfo))
			return fFalse;
	}

	DWORD dwSize1 = WIN::ExpandEnvironmentStrings((const ICHAR*)rgchUnexpandedInfo,(ICHAR*)rgchExpandedInfo,rgchExpandedInfo.GetSize());
	if (dwSize1 > rgchExpandedInfo.GetSize())
	{
		// try again with the correct size
		rgchExpandedInfo.SetSize(dwSize1);
		if(dwSize1 <= rgchExpandedInfo.GetSize())
			dwSize1 = WIN::ExpandEnvironmentStrings(rgchUnexpandedInfo,(ICHAR*)rgchExpandedInfo, dwSize1);
	}
	if(!dwSize1 || dwSize1 > rgchExpandedInfo.GetSize())
		return fFalse;
	
	return fTrue;
}

bool CMsiEngine::TerminalServerInstallsAreAllowed(bool fAdminUser)
{
	bool fOnConsole = true;
	bool fCloseHandle = false;
	HANDLE hToken;
		
	if (ERROR_SUCCESS == GetCurrentUserToken(hToken, fCloseHandle))
	{
		fOnConsole = IsTokenOnTerminalServerConsole(hToken);
		if (fCloseHandle)
			WIN::CloseHandle(hToken);
	}

	if (!fOnConsole)
	{
		DEBUGMSG(TEXT("Running install from non-console Terminal Server session."));
		if (!fAdminUser || (GetIntegerPolicyValue(szEnableAdminTSRemote, fTrue) != 1))
		{
			DEBUGMSG(TEXT("Rejecting attempt to install from non-console Terminal Server Session"));
			return false;
		}
	}

	return true;
}


extern void CreateCustomActionManager(bool fRemapHKCU); // from execute.cpp

ieiEnum CMsiEngine::DoInitialize(const ICHAR* szOriginalDatabase,
											iuiEnum iuiLevel,
											const ICHAR* szCommandLine,
											const ICHAR* szProductCode,
											iioEnum iioOptions)
{
	PMsiRecord pError(0);
	MsiString istrLanguage;
	MsiString istrTransform;
	MsiString istrPatch;
	MsiString istrAction;
	MsiString istrProductKey;
	MsiString istrPackageKey;
	MsiString strCurrentDirectory;
	MsiString strNewInstance;
	MsiString strInstanceMst;
	MsiString strPackageDownloadLocalCopy;
	MsiString strPatchDownloadLocalCopy;
	Bool fAllUsers = (Bool)-1;

	// summary stream property values
	MsiString istrTemplate;
	MsiString istrPlatform;
//      int iUserChecksum = 0;

	ieiEnum ieiRet;
	Bool fUIPreviewMode = fFalse;
	if (iuiLevel == iuiNextEnum)  // next enum specifies a preview mode only
	{
		fUIPreviewMode = fTrue; // combination happens only with UI preview mode initialization
		iuiLevel = iuiFull;
	}

	// validate iuiLevel
	if (iuiLevel >= iuiNextEnum || iuiLevel < 0)
	{
		iuiLevel = iuiBasic;
		AssertSz(0, "Invalid iuiLevel");
	}

	// get database properties if MSI database
	PMsiDatabase pDatabase(0);
	PMsiStorage pStorage(0);
	
	m_iioOptions = iioOptions;

	if (m_iioOptions & iioRestrictedEngine)
		m_fRestrictedEngine = true;

	bool fIgnoreMachineState = IgnoreMachineState();

	DEBUGMSG1(TEXT("End dialog%s enabled"), m_iioOptions & iioEndDialog ? TEXT("") : TEXT(" not"));

	MsiSuppressTimeout();

	// We need to acquire a storage object if we're not in UI preview mode.

	if (!fUIPreviewMode)
	{
		if (m_piExternalDatabase)    // database supplied at constructor
		{
			pStorage = m_piExternalDatabase->GetStorage(1);
			Assert(m_piExternalStorage == 0);
		}
		else if (m_piExternalStorage) // storage supplied at constructor
		{
			m_piExternalStorage->AddRef();
			pStorage = m_piExternalStorage;
		}
		else
		{
			if (!szOriginalDatabase || !*szOriginalDatabase)  // no database given
			{
#ifdef DISALLOW_NO_DATABASE   //FUTURE: This seems to be test only code
				AssertSz(0, "No database was passed to Engine::Initialize, we have no storage, and we're not in UI Preview mode");
				return ieiDatabaseOpenFailed;
#endif
			}
			else
			{
				//FUTURE: This code seems to be for testing only. We should always be opening the storage on
				//FUTURE:  the outside if we're not in UI preview mode.  -- malcolmh
				if ((pError = m_riServices.CreateStorage(szOriginalDatabase, ismReadOnly, *&pStorage)) == 0)
				{
					// make sure this storage is an MSI storage
					if (!pStorage->ValidateStorageClass(ivscDatabase))
						return ieiDatabaseInvalid;
				}
				else // not IStorage
				{
					return ieiDatabaseOpenFailed;
				}
				//FUTURE:  End test-only code
			}
		}

		// look for command-line properties that we care about right now
		ProcessCommandLine(szCommandLine, &istrLanguage, &istrTransform, &istrPatch, &istrAction, 0, MsiString(*IPROPNAME_CURRENTDIRECTORY), &strCurrentDirectory, fTrue, &m_piErrorInfo,0);
		if((int)istrLanguage == LANG_NEUTRAL)// if the INSTALLPROPERTY_LANGUAGE property is passed on the command line but is 0 (LANG_NEUTRAL) then we let darwin choose the "best fit"
			istrLanguage = TEXT("");

		// check ACTION property - set appropriate mode bit;
		//   perform case insensitive locale invariant compare
		if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
										NORM_IGNORECASE, (const ICHAR*)istrAction, -1, IACTIONNAME_ADMIN, -1))
			SetMode(iefAdmin, fTrue);
		else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
										NORM_IGNORECASE, (const ICHAR*)istrAction, -1, IACTIONNAME_ADVERTISE, -1))
			SetMode(iefAdvertise, fTrue);
	}


	// By this time we're either in UI preview mode or we've gotten our hands on a storage object.
	
	MsiString istrOriginalDbPath = szOriginalDatabase;  // <-- i.e. the launched-from database, database on the source, or cached db (if we weren't launched from a db)
	MsiString istrRunningDbPath;                        // <-- either a temp file name (for removable) media, or the
																		 //     same as istrOriginalDbPath

	DEBUGMSG1(TEXT("Original package ==> %s"), istrOriginalDbPath);
	MsiString strSourceDir;
	MsiString strSourceDirProduct;
	Bool fRegistered = fFalse;
	Bool fAdvertised = fFalse;
	INSTALLSTATE iINSTALLSTATE = INSTALLSTATE_UNKNOWN; // used to set ProductState property

	if (m_piExternalDatabase)
		pDatabase = m_piExternalDatabase, m_piExternalDatabase->AddRef();

	if (fUIPreviewMode)
	{
		if (!CreatePropertyTable(*pDatabase, sztblProperty, fFalse))
			return ieiDatabaseInvalid;
		//!! get storage if available??

	}
#ifndef DISALLOW_NO_DATABASE   //FUTURE: This seems to be test only code
	else if ((!szOriginalDatabase || !*szOriginalDatabase) && m_piExternalDatabase == 0)  // no database given
	{
		if ((pError = m_riServices.CreateDatabase(0, idoCreate, *&pDatabase)))
			return ieiDatabaseOpenFailed;
		if (!CreatePropertyTable(*pDatabase, 0, fFalse))
			return ieiDatabaseOpenFailed;
	}
#endif
	else // !fUIPreviewMode
	{
		if ((pError = pStorage->GetName(*&istrRunningDbPath)) != 0)
			return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseOpenFailed);

		DEBUGMSG1(TEXT("Package we're running from ==> %s"), istrRunningDbPath);
		if(!istrOriginalDbPath.TextSize())
			istrOriginalDbPath = istrRunningDbPath;

		m_strPackagePath = istrRunningDbPath;
		
		if (m_piErrorInfo) m_piErrorInfo->Release();
		m_piErrorInfo = istrOriginalDbPath, m_piErrorInfo->AddRef();

		// summary info stuff
		PMsiSummaryInfo pSummary(0);
		m_idSummaryInstallDateTime = MsiDate(0);
		m_iDatabaseVersion = 0;

		if ((pError = pStorage->CreateSummaryInfo(0, *&pSummary)))
			return ieiDatabaseInvalid;

		CTempBuffer<ICHAR, 100> szBuffer;

		GetSummaryInfoProperties(*pSummary, *&istrTemplate, m_iCachedPackageSourceType);
		istrPackageKey = m_pistrSummaryPackageCode->Extract(iseFirst, 38);
		if(!istrPackageKey.TextSize())
			return ieiDatabaseInvalid;
		
		// check the engine and services versions against that required by database
		if (m_iDatabaseVersion < iVersionEngineMinimum || m_iDatabaseVersion > iVersionEngineMaximum
		 || !m_riServices.CheckMsiVersion(m_iDatabaseVersion))
			return ieiInstallerVersion;

		if (pDatabase == 0)
		{
			if ((pError = m_riServices.CreateDatabaseFromStorage(*pStorage, fTrue, *&pDatabase)))
				return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseInvalid);
		}
		
		// open persistent property table - used to grab properties before/during transform application
		Bool fPropertyTableExists = CreatePropertyTable(*pDatabase, sztblProperty, fTrue);

		// set product code and determine if this product is already registered
		if(szProductCode && *szProductCode)
		{
			istrProductKey = szProductCode;
			istrProductKey.UpperCase(); // make sure the product code is all upper case
		}
		else if(fPropertyTableExists)
		{
			// we weren't passed a product code but we may have a product code in the property table
			// this can happen if we have a new package for an existing product
			istrProductKey = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
		}

		//
		// MULTIPLE INSTANCE SUPPORT:
		// (1) look for presence of MSINEWINSTANCE on the command line to see if this is a new instance install
		// (2) MSINEWINSTANCE indicates use of instance mst to generate a "new" product
		// (3) strInstanceMst is first transform in list (instance transform must always be first)
		// (4) fRegistered=fAdvertised=fFalse for new instance
		//

		ProcessCommandLine(szCommandLine,0,0,0,0,0,MsiString(IPROPNAME_MSINEWINSTANCE),&strNewInstance,fTrue,0,0);
		if (strNewInstance.TextSize())
		{
			m_fNewInstance = true; // MSINEWINSTANCE specified on command line
			Assert(istrTransform.TextSize() != 0);
			strInstanceMst = istrTransform.Extract(iseUpto, ';');
			Assert(strInstanceMst.TextSize() != 0);
		}

		// don't set iefMaintenance or m_fRegistered until after transforms applied
		// we don't care about the product state if we don't care about the machine state
		// - if this is a new instance, then we also don't care about the product state -- this was already validated
		//    as an unknown product
		if(istrProductKey.TextSize() && !fIgnoreMachineState && !m_fNewInstance)
		{
			iINSTALLSTATE = GetProductState(istrProductKey, fRegistered, fAdvertised);
		}

		MsiString strClientUILevel;
		ProcessCommandLine(szCommandLine,0,0,0,0,0,
								 MsiString(IPROPNAME_CLIENTUILEVEL),&strClientUILevel,
								 fTrue, 0, 0);
		iuiEnum iuiAppCompat = iuiNone;
		if(g_scServerContext == scClient)
		{
			iuiAppCompat = iuiLevel;
		}
		else if(strClientUILevel.TextSize())
		{
			iuiAppCompat = (iuiEnum)(int)strClientUILevel;
		}

		m_iacsShimFlags = (iacsAppCompatShimFlags)0;
		bool fDontInstallPackage = false;
		bool fQuiet = false;
		if (iuiAppCompat == iuiNone || g_scServerContext == scService)
			fQuiet = true; // use quiet mode if no UI or we are running in the service

		ApplyAppCompatTransforms(*pDatabase, *istrProductKey, *istrPackageKey, iacpBeforeTransforms, m_iacsShimFlags,
										 fQuiet, /*fProductCodeChanged = */ false, fDontInstallPackage); // ignore failure

		if(fDontInstallPackage)
		{
			MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME);
			if(!strProductName.TextSize())
				strProductName = istrOriginalDbPath;

			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_APPHELP_REJECTED_PACKAGE, strProductName);
			return PostInitializeError(0, *istrOriginalDbPath, ieiApphelpRejectedPackage);
		}

		//
		// MULTIPLE INSTANCE SUPPORT:
		//  Obtain name of instance transform as this must be applied prior to applying any patches. Otherwise
		//  wrong target of multi-target patch may be chosen or patch application may fail if patch is a major patch
		//  which changes the product code. The multi-instance mst will include ProductCode validation.
		//

		// get the advertised language and transforms, if any
		if(fAdvertised && !fIgnoreMachineState)
		{
			if (ENG::GetExpandedProductInfo(istrProductKey, INSTALLPROPERTY_TRANSFORMS, szBuffer))
				istrTransform = (const ICHAR*)szBuffer;

			if (ENG::GetProductInfo(istrProductKey, INSTALLPROPERTY_LANGUAGE, szBuffer))
				istrLanguage = (const ICHAR*)szBuffer;

			if (ENG::GetProductInfo(istrProductKey, INSTALLPROPERTY_INSTANCETYPE, szBuffer))
			{
				if (MsiString(*(ICHAR*)szBuffer) == 1)
				{
					// this is a multi-instance install using an instance transform
					// the instance transform is always the first transform in the list
					strInstanceMst = istrTransform.Extract(iseUpto, ';');
					Assert(strInstanceMst.TextSize() != 0);
				}
			}
		}

		if (strInstanceMst.TextSize())
		{
			DEBUGMSGV(TEXT("Detected that this product uses a multiple instance transform."));
		}

		// Set the default install overwrite modes
		SetMode(iefOverwriteOlderVersions,fTrue);
		SetMode(iefInstallMachineData,fTrue);
		SetMode(iefInstallUserData,fTrue);
		SetMode(iefInstallShortcuts,fTrue);

		// set source type mode flags
		if (m_iCachedPackageSourceType & msidbSumInfoSourceTypeSFN)
			SetMode(iefNoSourceLFN, fTrue);
		if (m_iCachedPackageSourceType & msidbSumInfoSourceTypeCompressed)
			SetMode(iefCabinet, fTrue);

		// process install options
		if(iioOptions & iioUpgrade)
		{
			Assert(m_piParentEngine);
			m_fBeingUpgraded = true;
		}
		if(iioOptions & iioChild)
		{
			Assert(m_piParentEngine);
			m_fChildInstall = true;
		}
		if(iioOptions & iioEndDialog)
			m_fEndDialog = true;

		// process platform and language
		istrPlatform = istrTemplate.Extract(iseUpto, ISUMMARY_DELIMITER);
		istrTemplate.Remove(iseIncluding, ISUMMARY_DELIMITER);

		// always call ProcessPlatform, since it sets some flags, but if iioDisablePlatformValidation is set
		// (as it is when creating an advertise script) we will ignore the return value
		ieiRet = ProcessPlatform(*istrPlatform, m_wPackagePlatform);
		AssertSz(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL ||
			m_wPackagePlatform == PROCESSOR_ARCHITECTURE_IA64  ||
			m_wPackagePlatform == PROCESSOR_ARCHITECTURE_AMD64 ||
			m_wPackagePlatform == PROCESSOR_ARCHITECTURE_UNKNOWN /* mixed package */,
				TEXT("Invalid platform returned by ProcessPlatform!"));
		// mixed packages are not supported -- even if iioDisablePlatformValidation
		if (PROCESSOR_ARCHITECTURE_UNKNOWN == m_wPackagePlatform)
			return ieiDatabaseInvalid;

		// check for unsupported platform
		if(!(iioOptions & iioDisablePlatformValidation) && (ieiRet != ieiSuccess))
			return ieiRet;

		// enforce schema 150 with 64-bit packages
		if (((PROCESSOR_ARCHITECTURE_AMD64 == m_wPackagePlatform) || 
		     (PROCESSOR_ARCHITECTURE_IA64 == m_wPackagePlatform)) && 
		    (m_iDatabaseVersion < iMinimumPackage64Schema))
			return ieiDatabaseInvalid;

		unsigned short iBaseLangId = 0; // to avoid warning
		
		if ((ieiRet = ProcessLanguage(*istrTemplate, *istrLanguage, iBaseLangId, /*(iuiLevel == iuiNone) ?*/ fTrue /*: fFalse*/, fIgnoreMachineState)) != ieiSuccess)
		{
			// per bug 195470, distinguish case where language differs from registered language
			if ((fAdvertised && !fIgnoreMachineState) && istrLanguage.TextSize() && ieiLanguageUnsupported == ieiRet)
			{
				// product has already been installed, but was registered with a language that isn't supported by this package
				// you can't change the language without including a package code/product code change
				ieiRet = ieiProductAlreadyInstalled;
			}
			return ieiRet;
		}

		tsEnum tsTransformsSecure = tsNo;
		
		MsiString strTransformsSecure;
		MsiString strTransformsAtSource;

		ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_TRANSFORMSSECURE),   &strTransformsSecure, fTrue, &m_piErrorInfo,0);
		ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_TRANSFORMSATSOURCE), &strTransformsAtSource, fTrue, &m_piErrorInfo,0);

		// There are three ways that a transform can be considered secure:
		// 1) a token at the front of the transforms list
		// 2) setting the TRANSFORMSSECURE or TRANSFORMSATSOURCE property
		// 3) setting the relevent policy value (only if we're not creating an advertise script and
		//    the product is not already advertised. once the product is advertised then whatever
		//    is registered in the transforms list is what we go with)
		
		if ((*(const ICHAR*)istrTransform == SECURE_RELATIVE_TOKEN))
		{
			tsTransformsSecure = tsRelative;
		}
		else if ((*(const ICHAR*)istrTransform == SECURE_ABSOLUTE_TOKEN))
		{
			tsTransformsSecure = tsAbsolute;
		}
		else if (!fAdvertised)
		{
			if ((GetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSSECURE))   == 1) ||
				(GetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE)) == 1) ||
				(strTransformsSecure   == 1) ||
				(strTransformsAtSource == 1) ||
				(!fIgnoreMachineState && GetIntegerPolicyValue(szTransformsSecureValueName, fTrue)) ||
				(!fIgnoreMachineState && GetIntegerPolicyValue(szTransformsAtSourceValueName, fFalse)))
			{
				tsTransformsSecure = tsUnknown;
			}
		}

		const IMsiString* pistrRecacheTransform = &g_MsiStringNull;
		const IMsiString* pistrProcessedTransforms = &g_MsiStringNull;
		
		int cTransformsProcessed = 0;

		//
		// MULTIPLE INSTANCE SUPPORT:
		//   Apply multiple instance transform first to ensure that subsequent patches target the correct product.
		//   Customization transforms are always applied after patches.  If the instance transform were not applied
		//   prior to the patch transforms, then a multi-target patch may choose an incorrect target since the
		//   basis of transform selection is dependent upon the current product code.
		//

		if (strInstanceMst.TextSize() != 0)
		{
			DEBUGMSGV1(TEXT("Applying multiple instance transform '%s'..."), strInstanceMst);
			for (int c=0; c<2; c++)
			{
				ieiRet = InitializeTransforms(*pDatabase, 0, *strInstanceMst, fTrue, 0, false, true, true, &cTransformsProcessed, strSourceDir, strCurrentDirectory, &pistrRecacheTransform, &tsTransformsSecure, &pistrProcessedTransforms);
				
				if (ieiSuccess == ieiRet)
				{
					break;
				}
				else if (ieiResolveSourceAndRetry == ieiRet)
				{
					PMsiRecord pError = ResolveSource(istrProductKey, false, istrOriginalDbPath, iuiLevel, fRegistered, &strSourceDir, &strSourceDirProduct);
					if (pError)
					{
						pistrRecacheTransform->Release();
						pistrProcessedTransforms->Release();
						return ieiSourceAbsent;
					}
					continue;
				}
				else
				{
					pistrRecacheTransform->Release();
					pistrProcessedTransforms->Release();
					return ieiRet;
				}
				Assert(0);
			}
		}


		// look for local copy of patch so we don't download again (used for Url optimization for admins)
		ProcessCommandLine(szCommandLine,0,0,0,0,0,MsiString(IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY),&strPatchDownloadLocalCopy,fTrue,0,0);

		// initialize patch - process new patch if there is one, apply existing and new transforms
		ieiRet = InitializePatch(*pDatabase, *istrPatch, *strPatchDownloadLocalCopy, istrProductKey, fAdvertised, strCurrentDirectory, iuiLevel); // OK if istrProductKey not set
		if(ieiRet != ieiSuccess)
			return ieiRet;

		if ((GetLanguage() != LANG_NEUTRAL) &&     // <- package is language neutral
			 (iBaseLangId != GetLanguage()))        // <- we're using the package's base language
		{
			if ((ieiRet = ApplyLanguageTransform(int(GetLanguage()), *pDatabase)) != ieiSuccess) // OK is istrProductKey not set
				return ieiRet;
		}

		// need to set language as early as possible for possible UI dialogs
		if (!m_piParentEngine)
		{
			PMsiRecord pDialogInfo(&ENG::CreateRecord(3));
			pDialogInfo->SetInteger(1, icmtLangId);
			pDialogInfo->SetInteger(2, GetLanguage());
			pDialogInfo->SetInteger(3, pDatabase->GetANSICodePage());
			g_MessageContext.Invoke(imtEnum(imtCommonData | imtSuppressLog), pDialogInfo); // will call again later for log
		}


		for (int c=0; c<2; c++)
		{
			ieiRet = InitializeTransforms(*pDatabase, 0, *istrTransform, fTrue, 0, false, false, fRegistered ? true: false, &cTransformsProcessed, strSourceDir, strCurrentDirectory, &pistrRecacheTransform, &tsTransformsSecure, &pistrProcessedTransforms);
			
			if (ieiSuccess == ieiRet)
			{
				break;
			}
			else if (ieiResolveSourceAndRetry == ieiRet)
			{
				PMsiRecord pError = ResolveSource(istrProductKey, false, istrOriginalDbPath, iuiLevel, fRegistered, &strSourceDir, &strSourceDirProduct);
				if (pError)
				{
					pistrRecacheTransform->Release();
					pistrProcessedTransforms->Release();
					return ieiSourceAbsent;
				}
				continue;
			}
			else
			{
				pistrRecacheTransform->Release();
				pistrProcessedTransforms->Release();
				return ieiRet;
			}
			Assert(0);
		}

		// scope variables
		bool fProductCodeChanged = false;
		MsiString istrTransformedProductKey = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
		if (istrProductKey.Compare(iscExactI,istrTransformedProductKey) == 0)
			fProductCodeChanged = true;

		iacsAppCompatShimFlags iShimFlagsTemp = (iacsAppCompatShimFlags)0;
		ApplyAppCompatTransforms(*pDatabase, fProductCodeChanged ? *istrTransformedProductKey : *istrProductKey, *istrPackageKey, iacpAfterTransforms, iShimFlagsTemp,
										 fQuiet, fProductCodeChanged, fDontInstallPackage); // ignore failure
		m_iacsShimFlags = (iacsAppCompatShimFlags)(m_iacsShimFlags|iShimFlagsTemp);

		if(fDontInstallPackage)
		{
			MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME);
			if(!strProductName.TextSize())
				strProductName = istrOriginalDbPath;

			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_APPHELP_REJECTED_PACKAGE, strProductName);
			return PostInitializeError(0, *istrOriginalDbPath, ieiApphelpRejectedPackage);
		}

		Assert(tsTransformsSecure != tsUnknown);
		DEBUGMSG1(TEXT("Transforms are %s secure."), (tsTransformsSecure == tsNo) ? TEXT("not") : (tsTransformsSecure == tsAbsolute) ? TEXT("absolute") : (tsTransformsSecure == tsRelative) ? TEXT("relative") : TEXT("??"));

		if (!CreatePropertyTable(*pDatabase, sztblProperty, fFalse))  // load property table - lowest priority properties
			return ieiDatabaseInvalid;

		LogCommandLine(szCommandLine, *pDatabase);

		SetProperty(*MsiString(*IPROPNAME_PACKAGECODE),*istrPackageKey);
		SetProperty(*MsiString(*IPROPNAME_RECACHETRANSFORMS), *pistrRecacheTransform);
		SetProperty(*MsiString(*IPROPNAME_TRANSFORMS), *pistrProcessedTransforms);

		istrTransform = *pistrProcessedTransforms;
		pistrRecacheTransform->Release();

		// Now that we have a property table we can set the transforms properties

		if (tsTransformsSecure == tsAbsolute || tsTransformsSecure == tsRelative)
		{
			SetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSSECURE),   1);
			SetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE), 1);
		}
		else
		{
			SetProperty(*MsiString(*IPROPNAME_TRANSFORMSSECURE),      g_MsiStringNull);
			SetProperty(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE), g_MsiStringNull);
		}

		MsiString istrProductKeyProperty = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);

		DEBUGMSG1(TEXT("Product Code passed to Engine.Initialize:           '%s'"),szProductCode ? szProductCode : TEXT("(none)"));
		DEBUGMSG1(TEXT("Product Code from property table before transforms: '%s'"),istrProductKey);
		DEBUGMSG1(TEXT("Product Code from property table after transforms:  '%s'"),istrProductKeyProperty);

		MsiString istrPatchedProductCode;
		if(istrProductKey.Compare(iscExactI,istrProductKeyProperty) == 0)
		{
			if(istrPatch.TextSize())
			{
				// during a patch we are changing the product code - need to migrate source settings from old product
				istrPatchedProductCode = istrProductKey;
				SetProperty(*MsiString(*IPROPNAME_MIGRATE),*istrProductKey);
				SetProperty(*MsiString(*IPROPNAME_PATCHEDPRODUCTCODE),*istrProductKey);
			}
			
			istrProductKey = istrProductKeyProperty;
			iINSTALLSTATE = GetProductState(istrProductKey, fRegistered, fAdvertised);
		}

		if (!fAdvertised)
		{
			MsiString strRemove;
			ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_FEATUREREMOVE), &strRemove, fTrue, &m_piErrorInfo,0);
			if (strRemove.Compare(iscExact, IPROPVALUE_FEATURE_ALL))
				return ieiProductUnknown;
		}

		if(fRegistered)
			DEBUGMSG(TEXT("Product registered: entering maintenance mode"));
		else
			DEBUGMSG(TEXT("Product not registered: beginning first-time install"));

		SetMode(iefMaintenance, fRegistered);
		m_fRegistered = fRegistered;
		m_fAdvertised = fAdvertised;
		
		Assert(iINSTALLSTATE != INSTALLSTATE_INVALIDARG && iINSTALLSTATE != INSTALLSTATE_BADCONFIG);
		SetPropertyInt(*MsiString(IPROPNAME_PRODUCTSTATE),iINSTALLSTATE);
		
		// set PRODUCTTOBEREGISTERED property.  used by ForceReboot
		if(fRegistered)
			SetPropertyInt(*MsiString(*IPROPNAME_PRODUCTTOBEREGISTERED),1);

		if (istrProductKey.TextSize())
		{
			if (m_piProductKey)
				m_piProductKey->Release();
			m_piProductKey = istrProductKey, m_piProductKey->AddRef();
		}

		MsiString strProductCode = GetProductKey();

		// set m_strPackageDownloadLocalCopy to prevent unnecessary downloads for databases
		// at URL source; only accepted if user is admin or service provided it
		//	command line validation for this happens in CreateAndRunEngine
		m_strPackageDownloadLocalCopy = g_MsiStringNull;
		ProcessCommandLine(szCommandLine,0,0,0,0,0,MsiString(IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY),&strPackageDownloadLocalCopy,fTrue,0,0);
		if (strPackageDownloadLocalCopy.TextSize())
			m_strPackageDownloadLocalCopy = strPackageDownloadLocalCopy;


		// verify that the source passed in to us is valid - there are several cases where it may not be
		// special cases:
		// 1) we are a child install (and have a parent engine): assume the parent has already validated
		//    the source location.  NOTE: you can't invoke a child install without going through the	
		//    parent - see bug 8263
		// 2) we are a normal install but this product was previously installed as a child install:
		//    in this case, the existing install doesn't have a sourcelist so we can't easily verify the
		//    source.  FSourceIsAllowed will fail.  this case was knowingly broken by the fix to bug 8285
		if(!m_fChildInstall)
		{
			if(!fAdvertised || !IsCachedPackage(*this, *istrOriginalDbPath))
			{
				PMsiPath pOriginalDbPath(0);
				MsiString strOriginalDbName;
				if ((pError = m_riServices.CreateFilePath(istrOriginalDbPath, *&pOriginalDbPath, *&strOriginalDbName)) != 0)
					return PostInitializeError(pError, *istrOriginalDbPath, ieiDatabaseOpenFailed); //?? is this the correct iei to use here?

				if(!FSourceIsAllowed(m_riServices, !fAdvertised, strProductCode, MsiString(pOriginalDbPath->GetPath()), fFalse))
				{
					// assume new source is disallowed by policy
					return PostInitializeError(pError, *istrOriginalDbPath, ieiPackageRejected);
				}
			}
		}

		CTempBuffer<ICHAR, 39> rgchRegisteredPackageCode;
		rgchRegisteredPackageCode[0] = 0;
		MsiString strPackageCode = GetPropertyFromSz(IPROPNAME_PACKAGECODE);
		GetProductInfo(strProductCode, TEXT("PackageCode"), rgchRegisteredPackageCode);
		if (strPackageCode.Compare(iscExactI, rgchRegisteredPackageCode) == 0)
			AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_PACKAGECODE_CHANGING), 1));

		// changing the package code w/o recaching the package is not allowed
		if(!(iioOptions & iioReinstallModePackage) &&
			!(GetMode() & iefAdvertise) &&
			!(GetMode() & iefAdmin) &&
			m_fRegistered &&
			MsiString(GetPropertyFromSz(IPROPNAME_PACKAGECODE_CHANGING)).TextSize() != 0)
		{
			return PostInitializeError(0, *strProductCode, ieiProductAlreadyInstalled);
		}

		// set m_strPackageName
		m_strPackageName = g_MsiStringNull;

		// first, check for embedded nested package
		if (*(const ICHAR*)istrOriginalDbPath == ':') // SubStorage
		{																								
			// substorage for nested install
			m_strPackageName = istrOriginalDbPath;  // whatever string was passed in
		}
		else
		{
			// if not an admin install, and not creating an advertise script, and name is in the registry, use it
			if(!(GetMode() & iefAdmin) && !fIgnoreMachineState && strProductCode.TextSize())
			{
				MsiString strProductCodeForPackageName;
				if(istrPatchedProductCode.TextSize())
				{
					// if patching, package name is package name from old product
					strProductCodeForPackageName = istrPatchedProductCode;
				}
				else
				{
					strProductCodeForPackageName = strProductCode;
				}

				if(GetProductInfo(strProductCodeForPackageName, INSTALLPROPERTY_PACKAGENAME, szBuffer) &&
					szBuffer[0] != 0)
				{
					m_strPackageName = (const ICHAR*)szBuffer;
					DEBUGMSG1(TEXT("Package name retrieved from configuration data: '%s'"), (const ICHAR*)m_strPackageName);
				}
			}
			
			// if not in the registry, or an admin install, or creating an advertise script
			// use the name of the package we started with
			if(!m_strPackageName.TextSize())
			{
				PMsiPath pOriginalDbPath(0);
				if ((pError = m_riServices.CreateFilePath(istrOriginalDbPath, *&pOriginalDbPath, *&m_strPackageName)) != 0)
					return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseOpenFailed); //?? is this the correct iei to use here?

				DEBUGMSG1(TEXT("Package name extracted from package path: '%s'"), (const ICHAR*)m_strPackageName);

				if (pOriginalDbPath->SupportsLFN() && (MinimumPlatform(true, 4, 10) || MinimumPlatform(false, 4, 00)))
				{
					CTempBuffer<ICHAR, 20> rgchLFN;
					if (DetermineLongFileNameOnly(istrOriginalDbPath, rgchLFN))
					{
						m_strPackageName = static_cast<const ICHAR *>(rgchLFN);
						DEBUGMSG1(TEXT("Package to be registered: '%s'"), m_strPackageName);
					}
				}
			}
		}
		
		Assert(m_strPackageName.TextSize());
		                                                                                      
		if((GetMode() & iefAdmin) && istrPatch.TextSize())
		{
			// patching an admin install
			
			// 1) set TARGETDIR to package path
			MsiString strTargetDir;
			if ((pError = SplitPath(istrOriginalDbPath, &strTargetDir, 0)) != 0)
				return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseOpenFailed); //?? is this the correct iei to use here?

			AssertNonZero(SetProperty(*MsiString(IPROPNAME_TARGETDIR),*strTargetDir));

			// 2) if patching an admin image that uses short names, set SHORTFILENAMES
			if(GetMode() & iefNoSourceLFN)
			{
				AssertNonZero(SetPropertyInt(*MsiString(IPROPNAME_SHORTFILENAMES), 1));
			}
		}

		// if this product is already installed, set ALLUSERS to appropriate value
		// OR if performing a major upgrade patch over an installed product, set ALLUSERS to reflect the old product's state
		if(GetProductInfo(istrProductKey, INSTALLPROPERTY_ASSIGNMENTTYPE, szBuffer) ||
			(istrPatchedProductCode.TextSize() && GetProductInfo(istrPatchedProductCode, INSTALLPROPERTY_ASSIGNMENTTYPE, szBuffer)))
		{
			// the product is already known
			fAllUsers = (MsiString(*(ICHAR* )szBuffer) == 1) ? fTrue: fFalse;
			
			DEBUGMSG1(TEXT("Determined that existing product (either this product or the product being upgraded with a patch) is installed per-%s."),
						 fAllUsers ? TEXT("machine") : TEXT("user"));
		}

		// load message headers from error table
		if ((ieiRet = LoadMessageHeaders(pDatabase)) != ieiSuccess)
			return ieiRet;
	
	} // !fUIPreviewMode
	
	// process properties from the admin stream.  Overrides database and userinfo properties.
	if (pStorage)
	{
		PMsiStream pAdminDataUNICODE(0);
		pError = pStorage->OpenStream(IPROPNAME_ADMIN_PROPERTIES, fFalse, *&pAdminDataUNICODE);
		if ((!pError) && pAdminDataUNICODE)
		{
			int cbRemaining = pAdminDataUNICODE->Remaining();
			CTempBuffer<WCHAR, 1> rgchBufferUNICODE((cbRemaining + 1) / sizeof(WCHAR)); // Add 1 to cbRemaining in case it is odd
			pAdminDataUNICODE->GetData((void*) rgchBufferUNICODE, cbRemaining);
			// This shouldn't be wrong, short of a corrupted database.
			AssertNonZero(ProcessCommandLine(rgchBufferUNICODE, 0, 0, 0, 0, 0, 0, 0,fFalse, &m_piErrorInfo, this));
		}
	}

	const IMsiString* pistrAllUsers = 0;
	ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_ALLUSERS), &pistrAllUsers, fTrue, &m_piErrorInfo,0);
	if (pistrAllUsers)
	{
		SetProperty(*MsiString(IPROPNAME_ALLUSERS), *pistrAllUsers);
		pistrAllUsers->Release();
	}

	bool fWin9XProfilesEnabled = false;
	if(g_fWin9X)
	{
		static const ICHAR szProfilesKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation");
		static const ICHAR szProfilesVal[] = TEXT("ProfileDirectory");

		PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkCurrentUser, ibtCommon);
		PMsiRegKey pKey = &pRoot->CreateChild(szProfilesKey);
		MsiString strProfilesDir;
		PMsiRecord pErr = pKey->GetValue(szProfilesVal, *&strProfilesDir);
		if(!pErr && strProfilesDir.TextSize())
		{
			fWin9XProfilesEnabled = true;
			SetPropertyInt(*MsiString(*IPROPNAME_WIN9XPROFILESENABLED), 1);
		}
	}


	// set hardware and operating system properties, overrides existing properties
	if((int)fAllUsers == -1)
	{
		if(!g_fWin9X)
		{
			if (GetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS)) == 2)
			{
				if (IsAdmin())
				{
					fAllUsers = fTrue;
					SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
				}
				else
				{
					fAllUsers = fFalse;
					SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set
				}
			}
			else
			{
				fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
			}
		}
		else
		{
			// the assignment type is implicit on Win95 based on -
			// If Profiles are on and start menu is per-user - darwin goop to HKCU, transforms and icons to AppData
			// If Profiles are on and startmenu is shared - darwin goop to HKLM, transforms and icons to Windows folder
			// Profiles are not on (start menu is shared) - darwin goop to HKCU, transforms and icons to AppData

			bool fWin9XIndividualStartMenuEnabled = false;

			PMsiRecord pErr(0);
			static const ICHAR szStartMenuKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation\\Start Menu");

			PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkCurrentUser, ibtCommon);
			PMsiRegKey pKey = &pRoot->CreateChild(szStartMenuKey);
			Bool fKeyExists;
			pErr = pKey->Exists(fKeyExists);
			if(!pErr && fKeyExists)
				fWin9XIndividualStartMenuEnabled = true;

			if(fWin9XProfilesEnabled && !fWin9XIndividualStartMenuEnabled)
			{
				fAllUsers = fTrue;
				SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
			}
			else
			{
				fAllUsers = fFalse; // write darwin goop to HKCU
				SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set
			}
		}
	}
	else if(fAllUsers == fTrue)
		SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
	else
		SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set

	// for SourceList/Patch security, the elevation state is needed before this code is run
	// and/or without an engine. SafeForDangerousSourceAction (in msiutil.cpp) duplicates the
	// call to AcceptProduct using values obtained from the registry.
	apEnum ap = AcceptProduct(istrProductKey, fAdvertised?fTrue:fFalse, fAllUsers?true:false);
	switch (ap)
	{
	case apImpersonate:
		m_fRunScriptElevated = false;
		g_fRunScriptElevated = false;
		break;
	case apElevate:
		m_fRunScriptElevated = true;
		g_fRunScriptElevated = true;
		break;
	default:
		Assert(0);
	case apReject:
		return ieiPackageRejected;
	}

	// process properties from command line, overrides database, admin install and userinfo properties

	bool fRejectDisallowedProperties = false;
	if ( m_fRunScriptElevated &&
		 !g_fWin9X  &&
		 !IsAdmin() &&
		 !MsiString(GetPropertyFromSz(IPROPNAME_ENABLEUSERCONTROL)).TextSize() &&
		  GetIntegerPolicyValue(szAllowAllPublicProperties, fTrue) != 1)
	{
		SetPropertyInt(*MsiString(*IPROPNAME_RESTRICTEDUSERCONTROL), 1);
		fRejectDisallowedProperties = true;
	}

	if (!ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, 0, 0, fTrue, &m_piErrorInfo, this, fRejectDisallowedProperties))
		return ieiCommandLineOption;

	if (MsiString(GetPropertyFromSz(IPROPNAME_SECONDSEQUENCE)).TextSize())
	{
		DEBUGMSG("Engine has iefSecondSequence set to true.");
		SetMode(iefSecondSequence, fTrue);
	}

	// Override any command-line setting of ALLUSERS. We've already determine above
	// what we want ALLUSERS to be set to. This acommodates the command-line
	// if the product has not yet been advertised. Otherwise the command-line
	// is ignored.
	if (fAllUsers == fTrue)
		SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
	else
		SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set

	SetProperty(*MsiString(*IPROPNAME_TRANSFORMS), *istrTransform);
	DEBUGMSG1(TEXT("TRANSFORMS property is now: %s"), (const ICHAR*)MsiString(GetPropertyFromSz(IPROPNAME_TRANSFORMS)));
	SetProperty(*MsiString(*IPROPNAME_PRODUCTLANGUAGE), *istrLanguage);
	if (m_fChildInstall)
	{
		SetProperty(*MsiString(*IPROPNAME_PARENTPRODUCTCODE), *MsiString(m_piParentEngine->GetProductKey()));
		SetProperty(*MsiString(*IPROPNAME_PARENTORIGINALDATABASE), *MsiString(m_piParentEngine->GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE)));
	}

	SetProperty(*MsiString(*IPROPNAME_SOURCEDIR), *strSourceDir);
	SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSourceDir);

	SetProperty(*MsiString(*IPROPNAME_SOURCEDIRPRODUCT), *strSourceDirProduct);

	
	// set the database version property, if not already set (could be changed via transforms)
	if(GetPropertyInt(*MsiString(IPROPNAME_VERSIONDATABASE)) == iMsiStringBadInteger)
		AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_VERSIONDATABASE), m_iDatabaseVersion));


	isppEnum isppArchitecture = isppDefault;
	if (iioOptions & iioCreatingAdvertiseScript)
	{
		if ((iioOptions & iioSimulateX86) && (iioOptions & iioSimulateIA64) ||
		    ((iioOptions & iioSimulateX86) && (iioOptions & iioSimulateAMD64)) ||
		    ((iioOptions & iioSimulateAMD64) && (iioOptions & iioSimulateIA64)))
		{
			// should not happend
			AssertSz(0, TEXT("Simulation of more than one architecture specified"));
		}
		if (iioOptions & iioSimulateX86)
			isppArchitecture = isppX86;
		else if (iioOptions & iioSimulateAMD64)
			isppArchitecture = isppAMD64;
		else if (iioOptions & iioSimulateIA64)
			isppArchitecture = isppIA64;
		// else use isppDefault
	}

	// create FolderCache table
	AssertNonZero(CreateFolderCache(*pDatabase));

	if(!m_riServices.SetPlatformProperties(*PMsiTable(&m_piPropertyCursor->GetTable()),
	g_fWin9X ? fFalse : fAllUsers, isppArchitecture, m_pFolderCacheTable)) /* ALLUSERS for shell folders makes sense only on Win NT*/
			return ieiDatabaseInvalid;

	if ( g_fWinNT64 )
	{
		if ( g_Win64DualFolders.IsInitialized() )
			AssertNonZero(g_Win64DualFolders.AddRef());
		else
		{
			strFolderPairs rgstFolders[] =
				{strFolderPairs(IPROPNAME_SYSTEM64_FOLDER,       IPROPNAME_SYSTEM_FOLDER,       ieSwapForSharedDll),
				 strFolderPairs(IPROPNAME_PROGRAMFILES64_FOLDER, IPROPNAME_PROGRAMFILES_FOLDER),
				 strFolderPairs(IPROPNAME_COMMONFILES64_FOLDER,  IPROPNAME_COMMONFILES_FOLDER),
				 strFolderPairs(TEXT(""), TEXT(""))};
			for (int i=0; rgstFolders[i].str32bit.TextSize() && rgstFolders[i].str64bit.TextSize(); i++)
			{
				MsiString str64bit = GetProperty(*rgstFolders[i].str64bit);
				MsiString str32bit = GetProperty(*rgstFolders[i].str32bit);
				if ( !str64bit.TextSize() || !str32bit.TextSize() )
				{
					// something went wrong
					Assert(false);
				}
				else
				{
					rgstFolders[i].str64bit = str64bit;
					rgstFolders[i].str32bit = str32bit;
				}
			}
			CWin64DualFolders oTemp(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL, rgstFolders);
			g_Win64DualFolders = oTemp;
		}
	}

	bool fAdminUser = MsiString(GetPropertyFromSz(IPROPNAME_ADMINUSER)).TextSize() != 0;

	// Reject attempts to install on Terminal Server unless the user is either on the console
	// or is an admin with the EnableAdminRemote policy set.

	if (MsiString(GetPropertyFromSz(IPROPNAME_TERMSERVER)).TextSize())
	{
		if (fAdminUser && (fIgnoreMachineState || (m_fMode & iefAdmin)))
		{
			// If you're an admin and you're creating an advertise script or
			// doing an admin install then you aren't subject to any restriction.
			// The rationale is that the restriction of admins on client session
			// installs exists simply to protect the admin from unintended installs
			// triggered through faulting in of components; these installs could
			// reboot the server which might not make the admin happy. Advertise
			// script generation, and admin installs, however, are always safe for
			// the admin to do. Therefore, they don't need to set any policy to allow
			// themselves to do these.
		}
		else if (!TerminalServerInstallsAreAllowed(fAdminUser))
			return ieiTSRemoteInstallDisallowed;
	}
			
	if (m_fRunScriptElevated || fAdminUser)
		SetPropertyInt(*MsiString(*IPROPNAME_PRIVILEGED), 1);

	InitializeUserInfo(*istrProductKey);

	// set properties from summary stream
	if (m_fSummaryInfo)
	{
		m_pistrPlatform     = istrPlatform;    m_pistrPlatform->AddRef();
		if (m_fMode & iefMaintenance)
			SetProperty(*MsiString(*IPROPNAME_INSTALLED),
							*MsiString(DateTimeToString(m_idSummaryInstallDateTime)));
	}

	// update properties passed as arguments
	SetProperty(*MsiString(*IPROPNAME_DATABASE), *istrRunningDbPath);
	SetProperty(*MsiString(*IPROPNAME_ORIGINALDATABASE), *istrOriginalDbPath);

	m_piDatabase = pDatabase, m_piDatabase->AddRef(); // need to set before calling handler

	InitializeExtendedSystemFeatures(); // GPT support, extended shell, etc.

	// Initialize the UI after the properties and objects have been set
	m_iuiLevel = iuiLevel;
	if (m_piParentEngine)  // nested install
	{
		if (m_piParentEngine->InTransaction())  // can only check this at one point
		{
			m_fInParentTransaction = fTrue;
			m_fServerLocked = fTrue;

			if((iioOptions & iioUpgrade) == 0) // in all cases but upgrades, if in the parent transaction we will
														  // merge our install script with the parent's
			{
				m_fMergingScriptWithParent = fTrue;
			}
		}
		SetMode(iefLogEnabled, (m_piParentEngine->GetMode() & iefLogEnabled) ? fTrue : fFalse);  //!! always false now

		// if the child install is running in the same transaction as the parent, and the
		// elevation states differ, we can't run the nested install.
		if (!g_fWin9X && m_fMergingScriptWithParent && (m_piParentEngine->m_fRunScriptElevated != m_fRunScriptElevated))
		{
			DEBUGMSG("Child install has different elevation state than parent. Possible pre-existing install or machine/user conflict. Failing child install.");
			return ieiPackageRejected;
		}
	}
	else if (fUIPreviewMode)
	{
		if (LoadHandler() == imsError)
			return ieiHandlerInitFailed;
	}
	else
	{
		if ((ieiRet = InitializeUI(iuiLevel)) != ieiSuccess)
			return ieiRet;
		if ((ieiRet = InitializeLogging()) != ieiSuccess)
			return ieiRet;
	}

	// need to call after setting m_piDatabase
	AssertNonZero(SetPatchSourceProperties()); //!! error??

	// Set the Engine's LFN mode
	MsiString istrShortNameMode(GetPropertyFromSz(IPROPNAME_SHORTFILENAMES));
	SetMode(iefSuppressLFN,istrShortNameMode.TextSize() > 0 ? fTrue : fFalse);

	// set rollback flag - EnableRollback makes the proper checks against
	// the DisableRollback policy and the iioDisableRollback bit in m_iioOptions
	EnableRollback(fTrue);

	//!! what does child engine do here? should inherit from parent
	int iUILevel = GetPropertyInt(*MsiString(*IPROPNAME_CLIENTUILEVEL));
	if (iUILevel != iuiNone && MsiString(GetPropertyFromSz(IPROPNAME_LIMITUI)).TextSize())
		iUILevel = iuiBasic;             // doesn't always get set in InitializeUI
	else if (iUILevel == iMsiNullInteger)  // just incase we got here other than through CreateAndRunEngine
		iUILevel = m_iuiLevel;
	switch(iUILevel)  // map internal value to public value, same as in CMsiAPIMessage::SetInternalHandler
	{
	case iuiFull:    iUILevel = INSTALLUILEVEL_FULL;    break;
	case iuiReduced: iUILevel = INSTALLUILEVEL_REDUCED; break;
	case iuiBasic:   iUILevel = INSTALLUILEVEL_BASIC;   break;
	case iuiNone:    iUILevel = INSTALLUILEVEL_NONE;    break;
	default:         iUILevel = INSTALLUILEVEL_DEFAULT; break;  // should never hit this
	}
	AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_UILEVEL), iUILevel));// set UILevel property

	bool fOEMInstall = MsiString(GetPropertyFromSz(IPROPNAME_FASTOEMINSTALL)).TextSize() ? true : false;
	g_MessageContext.SetOEMInstall(fOEMInstall);
	if ( fOEMInstall )
	{
		ieiEnum iErrorReturn = ieiCommandLineOption;
		//  a couple of additional checks are required.

		if ( MsiString(GetPropertyFromSz(IPROPNAME_PATCH)).TextSize() )
		{
			DEBUGMSG(TEXT("OEM-mode installation does not support patching."));
			return iErrorReturn;
		}
		else if ( !g_fWin9X && !(fAdminUser && fAllUsers) )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only per machine installations."));
			return iErrorReturn;
		}
		else if ( MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTSTATE)) != -1 )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only first time installations."));
			return iErrorReturn;
		}
		else if ( fUIPreviewMode || iUILevel != INSTALLUILEVEL_NONE )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only UI-less installations."));
			return iErrorReturn;
		}
		MsiString strCurrentAction = GetPropertyFromSz(IPROPNAME_ACTION);
		if ( strCurrentAction.TextSize() && IStrComp(strCurrentAction, TEXT("INSTALL")) )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only INSTALL type of ACTION."));
			return iErrorReturn;
		}

		DEBUGMSG(TEXT("OEM-mode installation."));
	}

	// set QFEUpgrade property - indicates when this product is being upgraded
	// (an upgrade that doesn't change the product code)
	if(fAdvertised)
	{
		int iQFEUpgradeType = 0;
		// ideally we would only set QFEUpgrade when the package code is changing
		// but in Intellimirror upgrades, the package code is updated in the registry (via advertisement)
		// before the install happens, so we can't detect a qfe upgrade by a package code change
		if(iioOptions & iioReinstallModePackage)
		{
			iQFEUpgradeType = 1;
		}
		else if(MsiString(GetPropertyFromSz(IPROPNAME_PATCH)).TextSize())
		{
			iQFEUpgradeType = 2;
		}

		if(iQFEUpgradeType)
		{
			AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_QFEUPGRADE), iQFEUpgradeType));
		}
	}

	// Success, hold references to components within engine until terminate is called
	m_fInitialized = fTrue;

	// cache presence of particular tables in the current database
	if (m_piDatabase->GetTableState(sztblCustomAction, itsTableExists))
		m_fCustomActionTable = fTrue;

	// set caption and lang id for default UI handler
	// must call this after m_fInitialized is set since Message requires m_fInitialized is set
	if (!m_piParentEngine)
	{
		PMsiRecord pDialogInfo(&m_riServices.CreateRecord(3));
		// set lang id
		int iLangId = GetPropertyInt(*MsiString(IPROPNAME_INSTALLLANGUAGE)); // possibly changed by transform
		if (iLangId == iMsiNullInteger)   // product language not specified
			iLangId = m_iLangId;          // use language set by summaryinfo or transform
		pDialogInfo->SetInteger(1, icmtLangId);
		pDialogInfo->SetInteger(2, iLangId);
		pDialogInfo->SetInteger(3, pDatabase->GetANSICodePage());
		Message(imtCommonData, *pDialogInfo);
		pDialogInfo->SetNull(3);
		// set caption
		if (m_rgpiMessageHeader[imsgDialogCaption])
		{
			pDialogInfo->SetInteger(1, icmtCaption);
			pDialogInfo->SetMsiString(2, *m_rgpiMessageHeader[imsgDialogCaption]);
			Message(imtCommonData, *pDialogInfo);
		}
	}

	if ((ieiRet = ProcessPreselectedAndResumeInfo()) != ieiSuccess)
		return ieiRet;

	// go ahead and create the custom action manager with the appropriate re-mapped HKCU value
	// this is so that whether or not to remap HKCU (per bug 193684) is available at all times
	// for the elevated custom action servers.  On TS with per-machine installs, HKCU is not remapped
	// and remains .Default so that proper propogation occurs.  Note that while the CA Mgr is
	// created, no extra CA processes will be created until a CA server is needed

	if (g_scServerContext == scService)
	{
		m_fRemapHKCUInCAServers = true;
		if (MinimumPlatformWindows2000() && IsTerminalServerInstalled() && fAllUsers)
			m_fRemapHKCUInCAServers = false; // everything should go to .Default

		// if in service, create the custom action manager through the configuration manager
		CreateCustomActionManager(m_fRemapHKCUInCAServers);
	}

	MsiSuppressTimeout();
	

	return ieiSuccess;
}

ICHAR SkipWhiteSpace(const ICHAR*& rpch);

// parse property name, convert to upper case, advances pointer to next non-blank
const IMsiString& ParsePropertyName(const ICHAR*& rpch, Bool fUpperCase);

// parse property value, advance pointer past value, allows quotes, doubled to escape
const IMsiString& ParsePropertyValue(const ICHAR*& rpch);

// Name says it all, i.e. decides if szProperty is hidden or not.
//
// By definition, a property is hidden either if it is authored in the
// MsiHiddenProperties property or if it is associated with an Edit control
// that has the Password attribute set.
//
// If called w/ szHiddenProperties set to NULL,  it will get it from the
// database.

bool CMsiEngine::IsPropertyHidden(const ICHAR* szProperty,
											 const ICHAR* szHiddenProperties,
											 IMsiTable* piControlTable,
											 IMsiDatabase& riDatabase,
											 bool* pfError)
{
	if ( pfError )
		*pfError = false;

	if ( !szProperty || !*szProperty )
		// who wants to hide a non-named property?
		return false;

	MsiString strHiddenProperties;
	ICHAR* szPropertyList;
	if ( !szHiddenProperties )
	{
		strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		szPropertyList = const_cast<ICHAR*>(static_cast<const ICHAR*>(strHiddenProperties));
	}
	else
		szPropertyList = const_cast<ICHAR*>(szHiddenProperties);
	if ( *szPropertyList )
	{
		const ICHAR chDelimiter = TEXT(';');
		bool fForever = true;
		while ( fForever )
		{
			ICHAR* szWithin = IStrStr(szPropertyList, szProperty);
			if ( szWithin == NULL )
				// szProperty is not listed in the list of hidden properties.
				break;

			// I still need to check what surrounds szProperty in szPropertyList string.
			ICHAR chEnd = *(szWithin + IStrLen(szProperty));
			if ( chEnd && chEnd != chDelimiter )
				goto ContinueSearch;

			if ( szWithin != szPropertyList && *(szWithin - 1) != chDelimiter )
				goto ContinueSearch;
			else
				return true;

		ContinueSearch:
			szWithin += IStrLen(szProperty);
			szPropertyList = szWithin;
		}
	}

	// if we've got to this point, szProperty is not listed in the authored property.
	// we need to check the Control table.
	PMsiCursor pControlCursor(0);
	if ( piControlTable )
		pControlCursor = piControlTable->CreateCursor(fFalse);
	if ( pControlCursor )
	{
		//  hiding the properties of all Edit controls that have the Password attribute set
		int iTypeColumn = piControlTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblControl_colType));
		int iAttrColumn = piControlTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblControl_colAttributes));
		int iPropColumn = piControlTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblControl_colProperty));
		if ( iTypeColumn && iAttrColumn && iPropColumn )
		{
			pControlCursor->SetFilter(iColumnBit(iTypeColumn)+iColumnBit(iPropColumn));
			AssertNonZero(pControlCursor->PutString(iTypeColumn, *MsiString(szControlTypeEdit)));
			AssertNonZero(pControlCursor->PutString(iPropColumn, *MsiString(szProperty)));
			while ( pControlCursor->Next() )
			{
				int iAttrib = pControlCursor->GetInteger(iAttrColumn);
				if ( (iAttrib & msidbControlAttributesPasswordInput) == msidbControlAttributesPasswordInput )
					return true;
			}
			return false;
		}
		else
		{
			Assert(0);
			if ( pfError )
				*pfError = true;
			return true; // it's safer this way
		}
	}

	return false;
}

void CMsiEngine::LogCommandLine(const ICHAR* szCommandLine, IMsiDatabase& riDatabase)
{
	if ( FDiagnosticModeSet(dmDebugOutput|dmVerboseLogging) )
	{
		if ( !szCommandLine || !*szCommandLine )
		{
			DEBUGMSG(TEXT("No Command Line."));
			return;
		}
		const ICHAR rgchCmdLineTemplate[] = TEXT("Command Line: %s");
		MsiString strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		PMsiTable pTable(0);
		PMsiRecord pError = riDatabase.LoadTable(*MsiString(*sztblControl), 0, *&pTable);
		if ( pError )
			pTable = 0;
		MsiString strStars(IPROPVALUE_HIDDEN_PROPERTY);
		MsiString strOutput;
		ICHAR* pchCmdLine = const_cast<ICHAR*>(szCommandLine);

		for(;;)
		{
			MsiString istrPropName;
			MsiString istrPropValue;
			ICHAR ch = SkipWhiteSpace(pchCmdLine);
			if (ch == 0)
				break;

			// process property=value pair
			istrPropName = ParsePropertyName(pchCmdLine, fFalse);
			if (!istrPropName.TextSize() || *pchCmdLine++ != '=')
				// an error might have occured
				break;
			istrPropValue = ParsePropertyValue(pchCmdLine);
			if ( IsPropertyHidden(istrPropName, strHiddenProperties, pTable, riDatabase, NULL) )
				// this property should be hidden
				istrPropValue = strStars;
			strOutput += istrPropName;
			strOutput += TEXT("=");
			strOutput += istrPropValue;
			strOutput += TEXT(" ");
		}
		DEBUGMSG1(rgchCmdLineTemplate, (const ICHAR*)strOutput);
	}
}

INSTALLSTATE CMsiEngine::GetProductState(const ICHAR* szProductKey, Bool& rfRegistered, Bool& rfAdvertised)
{
	INSTALLSTATE is = INSTALLSTATE_UNKNOWN;
	rfRegistered = rfAdvertised = fFalse;
	if(!(GetMode() & iefAdmin) && szProductKey && *szProductKey)
	{
		is = MSI::MsiQueryProductState(szProductKey);
		if(is == INSTALLSTATE_DEFAULT)
		{
			rfRegistered = rfAdvertised = fTrue;
		}
		else if(is == INSTALLSTATE_ADVERTISED)
		{
			rfAdvertised = fTrue;
		}
	}
	return is;
}

bool CMsiEngine::IgnoreMachineState()
{
	// machine state is ignored if we are either
	//  1. creating an advertise script
	//  2. running in a restricted engine
	if ((m_iioOptions & iioCreatingAdvertiseScript) || (m_iioOptions & iioRestrictedEngine))
		return true;
	
	return false;
}

bool CMsiEngine::IgnoreReboot()
{
	// reboot is ignored if we are either (1) creating an advertise script or
	// (2) running in a restricted engine because we aren't making any changes
	// to the machine.
	if ((m_iioOptions & iioCreatingAdvertiseScript) || (m_iioOptions & iioRestrictedEngine))
		return true;
	
	return false;
}

ieiEnum CMsiEngine::ProcessPreselectedAndResumeInfo()
{
	ieiEnum ieiRet;

	// check whether another install is in progress and set properties as appropriate
	if ((ieiRet = ProcessInProgressInstall()) != ieiSuccess)
		return ieiRet;

	// set Preselected property
	Bool fPreselected = fFalse;
	// check if any feature properties are set
	for(int i = 0; i < g_cFeatureProperties; i++)
	{
		if(MsiString(GetPropertyFromSz(g_rgFeatures[i].szFeatureActionProperty)).TextSize())
		{
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_PRESELECTED), *MsiString(TEXT("1"))));
			break;
		}
	}

	return ieiSuccess;
}
	
void CMsiEngine::InitializeExtendedSystemFeatures()
{
	// Determine support for extended shell path
	if (g_fSmartShell == -1)  // not determined yet
	{
		g_fSmartShell = IsDarwinDescriptorSupported(iddShell);
	}

	// Set the Engine's GPTSupport mode
	SetMode(iefGPTSupport,MsiString(GetPropertyFromSz(IPROPNAME_GPT_SUPPORT)).TextSize() > 0 ? fTrue:fFalse);
}

ieiEnum CMsiEngine::ApplyLanguageTransform(int iLanguage, IMsiDatabase& riDatabase)
{
	PMsiStorage pLangStorage(0);
	
	PMsiStorage pDbStorage(riDatabase.GetStorage(1));
	if (pDbStorage == 0)
		return ieiDatabaseInvalid;

	MsiString strTransformList = MsiChar(STORAGE_TOKEN);
	strTransformList += MsiString(iLanguage);
	
	return InitializeTransforms(riDatabase, 0, *strTransformList, fTrue, 0, false, false, false, 0);
}

void CMsiEngine::GetSummaryInfoProperties(IMsiSummaryInfo& riSummary, const IMsiString*& rpiTemplate, int &iSourceType)
{
	m_fSummaryInfo = fTrue;
	rpiTemplate            = &riSummary.GetStringProperty(PID_TEMPLATE);
	m_pistrSummaryProduct  = &riSummary.GetStringProperty(PID_SUBJECT);
	m_pistrSummaryComments = &riSummary.GetStringProperty(PID_COMMENTS);
	m_pistrSummaryTitle    = &riSummary.GetStringProperty(PID_TITLE);
	m_pistrSummaryKeywords = &riSummary.GetStringProperty(PID_KEYWORDS);
	m_pistrSummaryPackageCode = &riSummary.GetStringProperty(PID_REVNUMBER);
									  riSummary.GetIntegerProperty(PID_MSISOURCE, iSourceType);
									  riSummary.GetIntegerProperty(PID_CODEPAGE,  m_iCodePage);
									  riSummary.GetIntegerProperty(PID_PAGECOUNT, m_iDatabaseVersion);
									  riSummary.GetTimeProperty(PID_CREATE_DTM,   m_idSummaryCreateDateTime);
									  riSummary.GetTimeProperty(PID_LASTPRINTED,  m_idSummaryInstallDateTime);

}

ieiEnum CMsiEngine::InitializeUI(iuiEnum /*iuiLevel*/)
{
	// if Full or Reduced UI and LIMITUI property set, downgrade to Basic
	if(!g_MessageContext.IsHandlerLoaded() && (m_iuiLevel == iuiFull || m_iuiLevel == iuiReduced))
	{
		if(MsiString(GetPropertyFromSz(IPROPNAME_LIMITUI)).TextSize() ||
			MsiString(GetPropertyFromSz(TEXT("NOUI"))).TextSize()) //!!?? temp?
			m_iuiLevel = iuiBasic;
		else
		{
			// Determine whether our source is media. During maintenance mode we simply use LastUsedSource to determine this.
			Bool fMediaSource = fFalse;
			if (GetMode() & iefMaintenance)
				fMediaSource = LastUsedSourceIsMedia(m_riServices, MsiString(GetProductKey()));
			else // first-run
			{
				AssertNonZero(ResolveFolderProperty(*MsiString(*IPROPNAME_SOURCEDIR)));
				MsiString strSource = GetPropertyFromSz(IPROPNAME_SOURCEDIR);
				SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSource);
				
				PMsiPath pPath(0);
				PMsiRecord pError(0);
				if ((pError = CreatePathObject(*strSource, *&pPath)) == 0)
				{
					idtEnum idt = PMsiVolume(&pPath->GetVolume())->DriveType();
					switch (idt)
					{
						//case idtFloppy    = 2, //!!
						case idtRemovable:
						case idtCDROM:
							fMediaSource = fTrue;
					}
				}
			}

			if (fMediaSource)
				AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_MEDIASOURCEDIR), 1));

			imsEnum imsLoad = LoadHandler();
			if (imsLoad == imsError)
				return ieiHandlerInitFailed;  //!! use default UI?
			else if (imsLoad != imsOk)
				m_iuiLevel = iuiBasic;
		}
	}
	return ieiSuccess;
}

void CMsiEngine::InitializeUserInfo(const IMsiString& ristrProductKey)
{
	// get registered user information, if present
	ICHAR szUserName[100];
	ICHAR szOrgName[100];
	ICHAR szPID[32];
	DWORD cchUserName = sizeof(szUserName)/sizeof(ICHAR);
	DWORD cchOrgName  = sizeof(szOrgName)/sizeof(ICHAR);
	DWORD cchPID      = sizeof(szPID)/sizeof(ICHAR);
	MsiString istrUser;
	MsiString istrOrg;
	if (MSI::MsiGetUserInfo(ristrProductKey.GetString(), szUserName, &cchUserName, szOrgName,
									&cchOrgName, szPID, &cchPID) == USERINFOSTATE_PRESENT)
	{
		if (cchUserName) istrUser = szUserName;
		if (cchOrgName) istrOrg = szOrgName;
		if (cchPID) SetProperty(*MsiString(*IPROPNAME_PRODUCTID), *MsiString(szPID));
	}
	PMsiRegKey pLocalMachine(&m_riServices.GetRootKey(rrkLocalMachine, ibtCommon)); // x86 and ia64 same location
	PMsiRegKey pCurrentUser (&m_riServices.GetRootKey(rrkCurrentUser, ibtCommon));  // x86 and ia64 same location

	PMsiRegKey pSysKey      (&pLocalMachine->CreateChild(szSysUserKey));
	PMsiRegKey pSysKeyNT      (&pLocalMachine->CreateChild(szSysUserKeyNT));
	PMsiRegKey pAcmeKey     (&pCurrentUser ->CreateChild(szUserInfoKey));
	PMsiRecord pRecord(0);

	if (MsiString(GetPropertyFromSz(IPROPNAME_NOUSERNAME)).TextSize() == 0)
	{
		if (!istrUser.TextSize()) istrUser = GetPropertyFromSz(IPROPNAME_USERNAME);
		if (!istrUser.TextSize()) pRecord = pAcmeKey->GetValue(szDefName, *&istrUser);
		if (!istrUser.TextSize()) pRecord = pSysKey->GetValue(szSysUserName, *&istrUser);
		if (!istrUser.TextSize()) pRecord = pSysKeyNT->GetValue(szSysUserName, *&istrUser);
		if (istrUser.TextSize()) SetProperty(*MsiString(*IPROPNAME_USERNAME), *istrUser);
	}

	if (MsiString(GetPropertyFromSz(IPROPNAME_NOCOMPANYNAME)).TextSize() == 0)
	{
		if (!istrOrg.TextSize()) istrOrg = GetPropertyFromSz(IPROPNAME_COMPANYNAME);
		if (!istrOrg.TextSize()) pRecord = pAcmeKey->GetValue(szDefOrg,  *&istrOrg);
		if (!istrOrg .TextSize()) pRecord = pSysKey->GetValue(szSysOrgName,  *&istrOrg);
		if (!istrOrg .TextSize()) pRecord = pSysKeyNT->GetValue(szSysOrgName,  *&istrOrg);
		if (istrOrg.TextSize())  SetProperty(*MsiString(*IPROPNAME_COMPANYNAME), *istrOrg);
	}
}

void CMsiEngine::AddFileToCleanupList(const ICHAR* szFileToCleanup)
{
	if (m_strTempFileCopyCleanupList.TextSize() != 0)
		m_strTempFileCopyCleanupList += MsiChar(';');
	m_strTempFileCopyCleanupList += MsiString(szFileToCleanup);
}

ieiEnum CMsiEngine::LoadMessageHeaders(IMsiDatabase* piDatabase)
{
	Assert(piDatabase);
	PMsiTable pErrorTable(0);
	PMsiRecord pError(0);

	int imsg;
	ieiEnum ieiReturn = ieiSuccess;
	pError = piDatabase->LoadTable(*MsiString(*sztblError), 0, *&pErrorTable);
	if ( !pError )
	{
		PMsiCursor pErrorCursor(pErrorTable->CreateCursor(fFalse));
		if (!pErrorCursor)
			ieiReturn = ieiDatabaseInvalid;
		else
		{
			while (pErrorCursor->Next() && ((imsg = pErrorCursor->GetInteger(1))) < cMessageHeaders)
			{
				if (imsg < cCachedHeaders)
					m_rgpiMessageHeader[imsg] = &pErrorCursor->GetString(2); // AddRef done by GetString
				else if (!m_piParentEngine)
				{
					MsiString strHeader = FormatText(*MsiString(pErrorCursor->GetString(2)));
					g_MessageContext.m_szAction = strHeader;
					g_MessageContext.Invoke(imtEnum(imsg << imtShiftCount), 0);
				}
			}
		}
	}
	//  attempting to get from the international resource DLL the cached errors
	//  not found in the error table.
	for ( imsg = 0; imsg < cCachedHeaders; imsg++ )
	{
		if ( !m_rgpiMessageHeader[imsg] )
			m_rgpiMessageHeader[imsg] = &GetErrorTableString(imsg);
	}
	return ieiReturn;
}

ieiEnum CMsiEngine::LoadUpgradeUninstallMessageHeaders(IMsiDatabase* /* piDatabase */, bool fUninstallHeaders)
{
	if(m_piParentEngine)
		return ieiSuccess;  // don't change headers from child install

	int iTimeRemainingIndex = fUninstallHeaders ? (imtUpgradeRemoveTimeRemaining >> imtShiftCount) : (imtTimeRemaining >> imtShiftCount);
	int iScriptInProgressIndex = fUninstallHeaders ? (imtUpgradeRemoveScriptInProgress >> imtShiftCount) : (imtScriptInProgress >> imtShiftCount);
	MsiString strHeader = GetErrorTableString(iTimeRemainingIndex);
	if ( strHeader.TextSize() )
	{
		g_MessageContext.m_szAction = strHeader;
		g_MessageContext.Invoke(imtTimeRemaining, 0);
	}

	strHeader = GetErrorTableString(iScriptInProgressIndex);
	if ( strHeader.TextSize() )
	{
		g_MessageContext.m_szAction = strHeader;
		g_MessageContext.Invoke(imtScriptInProgress, 0);
	}
	return ieiSuccess;
}

ieiEnum CMsiEngine::InitializeLogging()
{
	m_fLogAction = fTrue;   // default in case LOGACTION not set and running on server
//      if (!m_piParentEngine) //!! do we want to do this for each engine in the sessions?
	//!! we may want to query message handler to see if we're really logging
	const IMsiString* piLogHeader = m_rgpiMessageHeader[imsgLogHeader];
	if (!(GetMode() & iefSecondSequence) && piLogHeader)
	{
		PMsiRecord pRecord = &ENG::CreateRecord(0);
		pRecord->SetMsiString(0, *piLogHeader);
		Message(imtEnum(imtForceLogInfo), *pRecord);  // use engine to format properties
	}
	// get LOGACTION value - determines which Actions to log
	m_istrLogActions = GetPropertyFromSz(IPROPNAME_LOGACTION);
	if (m_istrLogActions.TextSize())
		m_fLogAction = fFalse;   //!! initialize to false - seems unnecessary, as its set each ActionStart
	SetMode(iefLogEnabled, /*ENG::LoggingEnabled() ? fTrue :*/ fFalse);  //!! query for this?
	return ieiSuccess;
}

const ICHAR sqlPatchSourceProperties[] =
TEXT("SELECT `Media`.`Source`,`Media`.`_MSIOldSource`, `#_PatchCache`.`SourcePath`, `#_PatchCache`.`TempCopy`, `#_PatchCache`.`Unregister`")
TEXT("FROM `PatchPackage`, `#_PatchCache`, `Media`")
TEXT("WHERE `PatchPackage`.`PatchId` = `#_PatchCache`.`PatchId` AND `PatchPackage`.`Media_` = `Media`.`DiskId`");

enum ipspEnum
{
	ipspProp = 1,
	ipspOldProp,
	ipspPath,
	ipspLocalPath,
	ipspUnregister,
};

// patch source properties are set to #_PatchCache.TempCopy so that no further downloads are required
Bool CMsiEngine::SetPatchSourceProperties()
{
	// must be called after Property table is initialized
	if(!m_pPatchCacheTable)
		// if not PatchCache table was created, there are no patch sources to register
		return fTrue;

	PMsiRecord pError(0);
	PMsiRecord pFetchRecord(0);
	PMsiView pView(0);
	if((pError = OpenView(sqlPatchSourceProperties, ivcFetch, *&pView)) == 0 &&
		(pError = pView->Execute(0)) == 0)
	{
		while(pFetchRecord = pView->Fetch())
		{
			if(pFetchRecord->GetInteger(ipspUnregister) != 1)
			{
				// point to local copy if available, otherwise original source
				// for customized media source property
				MsiString strPath(pFetchRecord->GetMsiString(ipspLocalPath));
				if (!strPath.TextSize())
					strPath = pFetchRecord->GetMsiString(ipspPath);

				if(SetProperty(*MsiString(pFetchRecord->GetMsiString(ipspProp)),
									*strPath) == fFalse)
					return fFalse;

				// for original source property provided in patch Media table,
				// always point to source location of patch and not temp copy location
				// this ensures that Office patches will work
				if(SetProperty(*MsiString(pFetchRecord->GetMsiString(ipspOldProp)),
									*MsiString(pFetchRecord->GetMsiString(ipspPath))) == fFalse)
					return fFalse;
			}
		}
	}
	else if(pError->GetInteger(1) != idbgDbQueryUnknownTable) // could have patchcache table without PatchPackage table
		return fFalse;
	
	return fTrue;
}

IMsiRecord* CMsiEngine::GetFolderCachePath(const int iFolderId, IMsiPath*& rpiPath)
{
	IMsiRecord* piError = 0;
	rpiPath = 0;

	if (!m_pFolderCacheTable)
		return PostError(Imsg(idbgTableDefinition), sztblFolderCache);

	m_pFolderCacheCursor->Reset();
	m_pFolderCacheCursor->SetFilter(iColumnBit(m_colFolderCacheFolderId));
	AssertNonZero(m_pFolderCacheCursor->PutInteger(m_colFolderCacheFolderId, iFolderId));
	if (m_pFolderCacheCursor->Next())
	{
		rpiPath = (IMsiPath*)m_pFolderCacheCursor->GetMsiData(m_colFolderCacheFolderPath);
		if (rpiPath == 0)
		{
			// create path object for the path and store in the table
			MsiString strFolder(m_pFolderCacheCursor->GetString(m_colFolderCacheFolder));
			if ((piError = CreatePathObject(*strFolder, rpiPath)) != 0)
				return piError;
			AssertNonZero(m_pFolderCacheCursor->PutMsiData(m_colFolderCacheFolderPath, rpiPath));
			AssertNonZero(m_pFolderCacheCursor->Update());
		}
	}
	else
	{
		// folderId wasn't found in the FolderCache table
		return PostError(Imsg(idbgCacheFolderPropertyNotDefined), iFolderId);
	}
	return 0;
}

bool CMsiEngine::CreateFolderCache(IMsiDatabase& riDatabase)
{
	PMsiRecord pError(0);
	if (!m_pFolderCacheTable)
	{
		if ((pError = riDatabase.CreateTable(*MsiString(*sztblFolderCache), 0, *&m_pFolderCacheTable)) != 0)
			return false;

		m_colFolderCacheFolderId   = m_pFolderCacheTable->CreateColumn(icdPrimaryKey + icdShort + icdTemporary,
																				*MsiString(*sztblFolderCache_colFolderId));
		m_colFolderCacheFolder     = m_pFolderCacheTable->CreateColumn(icdString + icdTemporary,
																				*MsiString(*sztblFolderCache_colFolderPath));
		m_colFolderCacheFolderPath = m_pFolderCacheTable->CreateColumn(icdObject + icdNullable + icdTemporary, g_MsiStringNull);

		if (!m_colFolderCacheFolderId || !m_colFolderCacheFolder || !m_colFolderCacheFolderPath)
			return false;

		m_pFolderCacheCursor = m_pFolderCacheTable->CreateCursor(fFalse);
		if (!m_pFolderCacheCursor)
			return false;
	}
	return true;
}

IMsiRecord* CMsiEngine::CachePatchInfo(IMsiDatabase& riDatabase, const IMsiString& ristrPatchCode,
													const IMsiString& ristrPackageName, const IMsiString& ristrSourceList,
													const IMsiString& ristrTransformList, const IMsiString& ristrLocalPackagePath,
													const IMsiString& ristrSourcePath, Bool fExisting, Bool fUnregister,
													int iSequence)
{
	// store information about patch in Patches table
	IMsiRecord* piError = 0;
	if(!m_pPatchCacheTable)
	{
		if ((piError = riDatabase.CreateTable(*MsiString(sztblPatchCache), 0, *&m_pPatchCacheTable)) != 0)
			return piError;
		m_colPatchCachePatchId     = m_pPatchCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary,
																								*MsiString(*sztblPatchCache_colPatchId));
		m_colPatchCachePackageName = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colPackageName));
		m_colPatchCacheSourceList  = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colSourceList));
		m_colPatchCacheTransformList = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colTransformList));
		m_colPatchCacheTempCopy = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colTempCopy));
		m_colPatchCacheSourcePath = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colSourcePath));
		m_colPatchCacheExisting = m_pPatchCacheTable->CreateColumn(icdShort + icdTemporary,
																								*MsiString(*sztblPatchCache_colExisting));
		m_colPatchCacheUnregister = m_pPatchCacheTable->CreateColumn(icdShort + icdTemporary,
																								*MsiString(*sztblPatchCache_colUnregister));
		m_colPatchCacheSequence = m_pPatchCacheTable->CreateColumn(icdLong + icdTemporary,
																								*MsiString(*sztblPatchCache_colSequence));
		if(!m_colPatchCachePatchId || !m_colPatchCachePackageName ||
			!m_colPatchCacheSourceList || !m_colPatchCacheTransformList || !m_colPatchCacheTempCopy ||
			!m_colPatchCacheSequence || !m_colPatchCacheUnregister || !m_colPatchCacheExisting ||
			!m_colPatchCacheSourcePath)
			return PostError(Imsg(idbgTableDefinition), sztblPatchCache);

		m_pPatchCacheCursor = m_pPatchCacheTable->CreateCursor(fFalse);
	}

	Bool fRecordExists = fTrue;
	m_pPatchCacheCursor->Reset();
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCachePatchId,ristrPatchCode));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCachePackageName,ristrPackageName));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheSourceList,ristrSourceList));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheTransformList,ristrTransformList));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheTempCopy,ristrLocalPackagePath));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheSourcePath,ristrSourcePath));
	AssertNonZero(m_pPatchCacheCursor->PutInteger(m_colPatchCacheExisting,fExisting?1:0));
	AssertNonZero(m_pPatchCacheCursor->PutInteger(m_colPatchCacheUnregister,fUnregister?1:0));
	AssertNonZero(m_pPatchCacheCursor->PutInteger(m_colPatchCacheSequence,iSequence));
	AssertNonZero(m_pPatchCacheCursor->InsertTemporary());

	return 0;
}

ieiEnum IsValidPatchStorage(IMsiStorage& riStorage, IMsiSummaryInfo& riSummaryInfo)
{
	// check storage id
	if (riStorage.ValidateStorageClass(ivscPatch1))  //!! temporary compatibility with old patch files
	{
		IMsiStorage* piDummy = 0;
		PMsiRecord pError = riStorage.OpenStorage(0, ismRawStreamNames, piDummy);
		if (piDummy)
		{
			piDummy->Release();
			piDummy = 0;
		}
	}
	else if (!riStorage.ValidateStorageClass(ivscPatch2))
		return ieiPatchPackageInvalid;

	// check if patch type supported
	// 1.0 - 1.1 supports only type 1 (or blank)
	// 1.2 supports type 2 as well
	// 2.0 supports type 3 as well
	int iType = 0;
	riSummaryInfo.GetIntegerProperty(PID_WORDCOUNT, iType);
	if(iType == 0 || iType == 1 || iType == 2 || iType == 3)
		return ieiSuccess;
	else
		return ieiPatchPackageUnsupported;
}

ieiEnum CMsiEngine::PostInitializeError(IMsiRecord* piError, const IMsiString& ristrErrorInfo, ieiEnum ieiError)
{
	if(piError)
		Message(imtInfo,*piError);
	if(m_piErrorInfo) m_piErrorInfo->Release();
	m_piErrorInfo = &ristrErrorInfo; m_piErrorInfo->AddRef();
	return ieiError;
}

const ICHAR sqlDropPatchTable[] = TEXT("DROP TABLE `Patch`");
const ICHAR sqlAddPatchTable[] = TEXT("CREATE TABLE `Patch` ( `File_` CHAR(72) NOT NULL, `Sequence` INTEGER NOT NULL, `PatchSize` LONG NOT NULL, `Attributes` INTEGER NOT NULL, `Header` OBJECT, `StreamRef_` CHAR(72)  PRIMARY KEY `File_`, `Sequence` )");
const ICHAR sqlHoldPatchTable[] = TEXT("ALTER TABLE `Patch` HOLD");

IMsiRecord* CMsiEngine::CreateNewPatchTableSchema(IMsiDatabase& riDatabase)
{
	PMsiView pViewPatch(0);
	IMsiRecord* piError = 0;

	if (riDatabase.FindTable(*MsiString(*sztblPatch)) != itsUnknown)
	{
		if ((piError = riDatabase.OpenView(sqlDropPatchTable, ivcModify, *&pViewPatch)) != 0
			|| (piError = pViewPatch->Execute(0)) != 0)
		{
			return piError;
		}
	}
	if ((piError = riDatabase.OpenView(sqlAddPatchTable, ivcModify, *&pViewPatch)) != 0
			|| (piError = pViewPatch->Execute(0)) != 0
			|| (piError = riDatabase.OpenView(sqlHoldPatchTable, ivcModify, *&pViewPatch)) != 0
			|| (piError = pViewPatch->Execute(0)) != 0
			|| (piError = pViewPatch->Close()) != 0)
	{
		return piError;
	}

	return 0;
}

ieiEnum CMsiEngine::InitializePatch(IMsiDatabase& riDatabase, const IMsiString& ristrPatchPackage, const IMsiString& ristrLocalCopy,
												const ICHAR* szProductKey, Bool fApplyExisting, const ICHAR* szCurrentDirectory, iuiEnum iuiLevel)
{
	PMsiRecord pError(0);
	Bool fAdmin = GetMode() & iefAdmin ? fTrue : fFalse;
	if(fAdmin)
		fApplyExisting = fFalse;

	// open patch package as storage
	PMsiStorage pNewPatchStorage(0);
	PMsiSummaryInfo pNewPatchSummary(0);
	MsiString strNewPatchId, strOldPatches, strPatchTempCopy;
	ieiEnum ieiStat = ieiSuccess;

	// per Whistler bug 381320, we need to handle conflicting Patch table schemas. To guarantee that the new one always wins, we drop the Patch table
	// from the database if it was there.  We also always create a new Patch table. This is done BEFORE any patch transforms are applied
	bool fCreatedNewPatchTableSchema = false;


	if(ristrPatchPackage.TextSize())
	{
		// attempting to apply new patch - only allowed if DisablePatch policy is not set and
		// either admin user, not elevated, AllowLockdownPatch machine policy set.
		// Ideally we would check m_fRunScriptElevated, but it has not been set yet.
		if (GetIntegerPolicyValue(szDisablePatchValueName, fTrue) == 1 ||
			!(GetIntegerPolicyValue(szAllowLockdownPatchValueName, fTrue) == 1 ||
			  SafeForDangerousSourceActions(szProductKey)))
		{
			// patching disabled
			return ieiPackageRejected;
		}

		bool fFileUrl = false;
		bool fUrl = IsURL(ristrPatchPackage.GetString(), fFileUrl);
		if (!fUrl || fFileUrl)
		{
			// patch is at source -- need to create a temp copy to run from
			MsiString strVolume;
			Bool fRemovable = fFalse;
			DWORD dwStat = ERROR_SUCCESS;

			if (fFileUrl)
			{
				// convert file:// url path to DOS path
				CTempBuffer<ICHAR, 1> rgchFilePath (cchExpectedMaxPath + 1);
				DWORD cchFilePath = rgchFilePath.GetSize();
				if (MsiConvertFileUrlToFilePath(ristrPatchPackage.GetString(), rgchFilePath, &cchFilePath, 0))
				{
	                dwStat = CopyTempDatabase(rgchFilePath, *&strPatchTempCopy, fRemovable, *&strVolume, m_riServices, stPatch);
				}
				else
				{
					// error, set status and we'll fail down below
					dwStat = ERROR_FILE_NOT_FOUND;
				}

				// turn off fUrl since we've converted it to the DOS path
				fUrl = false;
			}
			else // regular non-url path provided
			{
                dwStat = CopyTempDatabase(ristrPatchPackage.GetString(), *&strPatchTempCopy, fRemovable, *&strVolume, m_riServices, stPatch);
			}
			if (ERROR_SUCCESS == dwStat)
			{
				// patch was copied
				DEBUGMSGV1(TEXT("Original patch ==> %s"), ristrPatchPackage.GetString());
				DEBUGMSGV1(TEXT("Patch we're running from ==> %s"), strPatchTempCopy);

				AddFileToCleanupList(strPatchTempCopy);
			}
			else
			{
				strPatchTempCopy = ristrPatchPackage;
				ristrPatchPackage.AddRef();
				DEBUGMSGV1(TEXT("Unable to create a temp copy of patch '%s'."), ristrPatchPackage.GetString());
			}
		}
		else if (fUrl && ristrLocalCopy.TextSize())
		{
			strPatchTempCopy = ristrLocalCopy;
			ristrLocalCopy.AddRef();
			DEBUGMSGV2(TEXT("Using downloaded local copy %s for patch %s"), (const ICHAR*)strPatchTempCopy, ristrPatchPackage.GetString());
		}

		// must perform SAFER check on patch
		SAFER_LEVEL_HANDLE hSaferLevel = 0;
		pError = OpenAndValidateMsiStorageRec(strPatchTempCopy.TextSize() ? strPatchTempCopy : ristrPatchPackage.GetString(), stPatch, m_riServices, *&pNewPatchStorage, /* fCallSAFER = */ true, /* szFriendlyName = */ ristrPatchPackage.GetString(), /* phSaferLevel = */ &hSaferLevel);
		if (pError != 0)
		{
			ieiEnum ieiInitError = MapStorageErrorToInitializeReturn(pError);
			return PostInitializeError(pError,ristrPatchPackage,ieiInitError);
		}

		if (fUrl && !ristrLocalCopy.TextSize())
		{
			// retrieve the storage path used when downloading the URL file
			AssertRecord(pNewPatchStorage->GetName(*&strPatchTempCopy));

			if (MinimumPlatformWindowsDotNETServer())
			{
				AddFileToCleanupList(strPatchTempCopy);
				if (IsAdmin())
					m_strPatchDownloadLocalCopy = strPatchTempCopy;
			}
		}

		// get summary information of package
		if ((pError = pNewPatchStorage->CreateSummaryInfo(0, *&pNewPatchSummary)))
		{
			// could not open summary info
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageInvalid);
		}

		ieiStat = IsValidPatchStorage(*pNewPatchStorage, *pNewPatchSummary);
		if(ieiStat != ieiSuccess)
		{
			pError = PostError(Imsg(idbgNotPatchStorage),ristrPatchPackage);
			return PostInitializeError(pError,ristrPatchPackage,ieiStat);
		}

		if (!fCreatedNewPatchTableSchema)
		{
			// ensure new Patch table schema is used
			if ((pError = CreateNewPatchTableSchema(riDatabase)) != 0)
			{
				DEBUGMSG(TEXT("Unable to create new patch table schema"));
				return PostInitializeError(pError, ristrPatchPackage, ieiPatchPackageInvalid);
			}
			fCreatedNewPatchTableSchema = true;
		}
		
		strOldPatches = pNewPatchSummary->GetStringProperty(PID_REVNUMBER);
		strNewPatchId = strOldPatches.Extract(iseFirst,38);
		strOldPatches.Remove(iseFirst,38);
	}

	int iPatchSequence = 1;
	Bool fApplyNewPatch = fTrue;
	
	if(fApplyExisting)
	{
		Assert(szProductKey && *szProductKey);
		
		// apply all existing patches first
		int iIndex = 0;
		CTempBuffer<ICHAR,39> rgchPatchBuf;
		CTempBuffer<ICHAR,100> rgchTransformsBuf;
		DWORD cchTransformsBuf = 100;
		for(;;)
		{
			DWORD lResult = MsiEnumPatches(szProductKey,iIndex,rgchPatchBuf,rgchTransformsBuf,&cchTransformsBuf);
			if(lResult == ERROR_MORE_DATA)
			{
				// resize buffer to returned size + 1
				cchTransformsBuf++;
				rgchTransformsBuf.SetSize(cchTransformsBuf);
				lResult = MsiEnumPatches(szProductKey,iIndex,rgchPatchBuf,rgchTransformsBuf,&cchTransformsBuf);
			}
			iIndex++;

			if(lResult == ERROR_SUCCESS)
			{
				if(strOldPatches.Compare(iscWithinI,rgchPatchBuf))
				{
					// obsolete patch, need to unregister
					if((pError = CachePatchInfo(riDatabase,*MsiString((const ICHAR*)rgchPatchBuf),g_MsiStringNull,
														 g_MsiStringNull,g_MsiStringNull,
														 g_MsiStringNull, g_MsiStringNull,
														 fTrue, fTrue, iPatchSequence++)) != 0)
					{
						return PostInitializeError(pError,g_MsiStringNull,ieiPatchPackageInvalid);
					}
				}
				else
				{
					// get local path
					CTempBuffer<ICHAR,MAX_PATH> rgchLocalPackage;
					if (!GetPatchInfo(rgchPatchBuf, INSTALLPROPERTY_LOCALPACKAGE,rgchLocalPackage))
					{
						// couldn't get local path for whatever reason (could be corrupt config data, or a roaming user)
						// will try to recache patch from its original source
						rgchLocalPackage[0] = 0;
					}
					
					// open patch package as storage
					PMsiStorage pExistingPatchStorage(0);
					PMsiSummaryInfo pExistingPatchSummaryInfo(0);

					MsiString strPatchPackage = (const ICHAR*)rgchLocalPackage;

					MsiString strTempCopy;

					bool fPatchAtSource = false;

					for (int c = 0; c < 2 ; c++)
					{
						DEBUGMSG1(TEXT("Opening existing patch '%s'."), strPatchPackage);

						if(strPatchPackage.TextSize())
						{
							bool fFileUrl = false;
							bool fUrl = IsURL(strPatchPackage, fFileUrl);
							if (fPatchAtSource && (!fUrl || fFileUrl))
							{
								// patch is at source -- need to create a temp copy to run from
								MsiString strVolume;
								Bool fRemovable = fFalse;
								DWORD dwStat = ERROR_SUCCESS;

								if (fFileUrl)
								{
									// convert file:// url path to DOS path
									CTempBuffer<ICHAR, 1> rgchFilePath (cchExpectedMaxPath + 1);
									DWORD cchFilePath = rgchFilePath.GetSize();
									if (MsiConvertFileUrlToFilePath(strPatchPackage, rgchFilePath, &cchFilePath, 0))
									{
										dwStat = CopyTempDatabase(rgchFilePath, *&strTempCopy, fRemovable, *&strVolume, m_riServices, stPatch);
									}
									else
									{
										// error, set status and we'll fail down below
										dwStat = ERROR_FILE_NOT_FOUND;
									}

									// turn off fUrl since we've converted it to the DOS path
									fUrl = false;
								}
								else
								{
									dwStat = CopyTempDatabase(strPatchPackage, *&strTempCopy, fRemovable, *&strVolume, m_riServices, stPatch);
								}
								if (ERROR_SUCCESS == dwStat)
								{
									// patch was copied
									DEBUGMSGV1(TEXT("Original patch ==> %s"), strPatchPackage);
									DEBUGMSGV1(TEXT("Patch we're running from ==> %s"), strTempCopy);

									AddFileToCleanupList(strTempCopy);
								}
								else
								{
									strTempCopy = strPatchPackage;
									DEBUGMSGV1(TEXT("Unable to create a temp copy of patch '%s'."), strPatchPackage);
								}
							}
							// if fPatchAtSource && fUrl we are still okay as we set strTempCopy in the loop
							// to point to the actual patch package path.  For the fUrl case we'll just let
							// OpenAndValidateMsiStorageRec handle the download

							// a SAFER check on the patch is only required if we go back up to 							// the source to get the patch
							// a locally cached patch does not require a SAFER check
							SAFER_LEVEL_HANDLE hSaferLevel = 0;
							pError = OpenAndValidateMsiStorageRec(fPatchAtSource ? strTempCopy : strPatchPackage, stPatch, m_riServices, *&pExistingPatchStorage, /* fCallSAFER = */ fPatchAtSource, /* szFriendlyName = */ strPatchPackage, /* phSaferLevel = */ fPatchAtSource ? &hSaferLevel : NULL);

							if (fPatchAtSource && fUrl && pExistingPatchStorage)
							{
								// retrieve the storage path used when downloading the URL file
								AssertRecord(pExistingPatchStorage->GetName(*&strTempCopy));

								if (MinimumPlatformWindowsDotNETServer())
									AddFileToCleanupList(strTempCopy);
							}
						}
						
						if (strPatchPackage.TextSize() == 0 || pError != 0)
						{
							if (c == 0)
							{
								DEBUGMSG1(TEXT("Couldn't find local patch '%s'. Looking for it at its source."), strPatchPackage);

								MsiString strPatchSource;
								MsiString strDummy;
								pError = ResolveSource(rgchPatchBuf, true, 0, iuiLevel, fTrue, &strPatchSource, &strDummy);
								if (pError)
									return ieiSourceAbsent;

								fPatchAtSource = true;

								CTempBuffer<ICHAR, MAX_PATH> rgchPatchPackageName;
								AssertNonZero(GetPatchInfo(rgchPatchBuf, TEXT("PackageName"), rgchPatchPackageName));
												
								strPatchPackage = strPatchSource;
								strPatchPackage += rgchPatchPackageName;
								strTempCopy = strPatchPackage;
								continue;

							}
							else
							{
								// pError may be 0
								return PostInitializeError(pError, *strPatchPackage, ieiPatchPackageOpenFailed);
							}
						}
						break;
					}

					// get summary information of package
					if ((pError = pExistingPatchStorage->CreateSummaryInfo(0, *&pExistingPatchSummaryInfo)))
					{
						// could not open summary info
						return PostInitializeError(pError,*strPatchPackage,ieiPatchPackageInvalid);
					}

					ieiEnum ieiStat = IsValidPatchStorage(*pExistingPatchStorage, *pExistingPatchSummaryInfo);
					if(ieiStat != ieiSuccess)
					{
						pError = PostError(Imsg(idbgNotPatchStorage),*strPatchPackage);
						return PostInitializeError(pError,*strPatchPackage,ieiStat);
					}
				
					if (!fCreatedNewPatchTableSchema)
					{
						// ensure new Patch table schema is used
						if ((pError = CreateNewPatchTableSchema(riDatabase)) != 0)
						{
							DEBUGMSG(TEXT("Unable to create new patch table schema"));
							return PostInitializeError(pError, *strPatchPackage, ieiPatchPackageInvalid);
						}
						fCreatedNewPatchTableSchema = true;
					}

					MsiString strValidTransforms;
					// InitializeTransforms will perform a digital signature check on transforms if it determines
					// that the check is warranted.  We already check patches via OpenAndValidateMsiStorage so
					// we cancel the trust check for transforms stored in the patch
					if(ieiSuccess == InitializeTransforms(riDatabase,pExistingPatchStorage,
																	  *MsiString((const ICHAR*)rgchTransformsBuf),
																	  fTrue,&strValidTransforms, true, false, true, 0, szCurrentDirectory,0,0,0,0) &&
																	  strValidTransforms.TextSize())
					{
						// cache source path
						if((pError = CachePatchInfo(riDatabase,*MsiString((const ICHAR*)rgchPatchBuf),g_MsiStringNull,
															 g_MsiStringNull,*MsiString((const ICHAR*)rgchTransformsBuf),
															 *strTempCopy, *strPatchPackage,
															 fTrue, fFalse, iPatchSequence++)) != 0)
						{
							return PostInitializeError(pError,*strPatchPackage,ieiPatchPackageInvalid);
						}
					}
					else
					{
						// obsolete patch, need to unregister
						if((pError = CachePatchInfo(riDatabase,*MsiString((const ICHAR*)rgchPatchBuf),g_MsiStringNull,
															 g_MsiStringNull,g_MsiStringNull,
															 g_MsiStringNull, g_MsiStringNull,
															 fTrue, fTrue, iPatchSequence++)) != 0)
						{
							return PostInitializeError(pError,*strPatchPackage,ieiPatchPackageInvalid);
						}
					}

					if(strNewPatchId.Compare(iscExactI, (const ICHAR*)rgchPatchBuf))
						// new patch already applied, don't need to apply again
						fApplyNewPatch = fFalse;
				}
				
				//!! if we need to recache database, call CachePatchInfo with temp path
			}
			else if(lResult == ERROR_NO_MORE_ITEMS)
				break;
			else
				break; //!! ?? error
		}
	}
	
	if(fApplyNewPatch && ristrPatchPackage.TextSize())
	{
		Assert(pNewPatchStorage);
		Assert(pNewPatchSummary);

		MsiString strNewTransforms = pNewPatchSummary->GetStringProperty(PID_LASTAUTHOR);
		MsiString strValidTransforms;
		// InitializeTransforms will perform a digital signature check on transforms if it determines
		// that the check is warranted.  We already check patches via OpenAndValidateMsiStorage so
		// we cancel the trust check for transforms stored in the patch
		ieiStat = InitializeTransforms(riDatabase,pNewPatchStorage,*strNewTransforms, fFalse, &strValidTransforms,true,false,true,0,szCurrentDirectory,0,0,0,0);
		if(ieiStat != ieiSuccess)
		{
			pError = PostError(Imsg(idbgInvalidPatchTransform));
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageInvalid);
		}

		if(!strValidTransforms.TextSize())
		{
			return PostInitializeError(pError,ristrPatchPackage,ieiNotValidPatchTarget);
		}
		
		PMsiPath pPackagePath(0);
		MsiString strPackageName;
		if((pError = m_riServices.CreateFilePath(ristrPatchPackage.GetString(),*&pPackagePath,*&strPackageName)) != 0)
		{
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageOpenFailed);
		}

		// set up patch registration record - will be dispatched by PublishProduct
		MsiString strSourceList = pNewPatchSummary->GetStringProperty(PID_KEYWORDS);

		if((pError = CachePatchInfo(riDatabase,*strNewPatchId,*strPackageName,*strSourceList,*strValidTransforms,
											 *strPatchTempCopy, ristrPatchPackage, fFalse, fFalse, iPatchSequence++)) != 0)
		{
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageInvalid);
		}
	}
	
	return ieiSuccess;
}

ieiEnum CMsiEngine::ProcessLanguage(const IMsiString& riAvailableLanguages, const IMsiString& riLanguage, unsigned short& iBaseLangId, Bool fNoUI, bool fIgnoreCurrentMachineLanguage)
{
	UNREFERENCED_PARAMETER(fNoUI);

	const ICHAR* pchLangIds = riAvailableLanguages.GetString();
	unsigned cLangIds = 0;
	unsigned short iBestLangId = 0;
	isliEnum isliBestMatch = isliNotSupported;
	unsigned short iLangId = 0;
	iBaseLangId = 0;


	for(;;) // language processing loop
	{
		int ch = *pchLangIds++;
		if (ch == ILANGUAGE_DELIMITER || ch == 0)
		{
			if (iLangId == 0)  // empty lang field or LANG_NEUTRAL specified
			{
				SetLanguage(0);
				return ieiSuccess;
			}
			
			if (cLangIds == 0) //first one
			{
				iBaseLangId = iLangId;
			}
			cLangIds++;

			if(riLanguage.TextSize()) // langid specified on command-line
			{
				if(riLanguage.GetIntegerValue() == iLangId)
					break;
			}
			else // no langid specified
			{
				if (fIgnoreCurrentMachineLanguage) // use the first lang id supported by the package, regardless of the machine's support
				{
					iBestLangId = iLangId;
					isliBestMatch = isliExactMatch;
					break;
				}
				else
				{
					isliEnum isliNewMatch = m_riServices.SupportLanguageId(iLangId, fFalse);
					if (isliNewMatch > isliBestMatch)
					{
						iBestLangId = iLangId;
						isliBestMatch = isliNewMatch;
					}
					if (isliBestMatch == isliExactMatch) // stop at 1st exact match
						break;
				}
			}

			iLangId = 0;  // reset for next language
			if (ch == 0)
				break;
		}
		else if (iLangId >= 0)
		{
			if (ch == TEXT(' '))
				continue;
			ch -= TEXT('0');
			if ((unsigned)ch > 9)
				return ieiLanguageUnsupported;

			iLangId = (unsigned short) (iLangId * 10 + ch);
		}
	}

	if(riLanguage.TextSize())
	{
		if(iLangId == 0)// langid specified on command-line but not supported
			return ieiLanguageUnsupported;
		else
			SetLanguage(iLangId);
	}
	else
	{
		if (isliBestMatch >= isliDialectMismatch)
		{
			SetLanguage(iBestLangId);
		}
		else if (isliBestMatch == isliLanguageMismatch)
		{

			if (cLangIds == 1) // we only support 1 language; no choice
				SetLanguage(iBaseLangId);
			else
			{
				// formerly we used to try to have the user select languages, now we just go with the first one
				pchLangIds = riAvailableLanguages.GetString();
				unsigned short iLangId = 0;
				while ((*pchLangIds != ILANGUAGE_DELIMITER) && (*pchLangIds != 0))
				{
					iLangId = (unsigned short)((10*iLangId)+(*pchLangIds - TEXT('0')));
					pchLangIds++;
				}
				SetLanguage(iLangId);
			}
		}
		else // isliBestMatch == isliNotSupported
		{
			return ieiLanguageUnsupported;
		}
	}

	return ieiSuccess;
}


ieiEnum CMsiEngine::ProcessPlatform(const IMsiString& riAvailablePlatforms, WORD& wChosenPlatform)
{
	_SYSTEM_INFO sinf;
	WIN::GetSystemInfo(&sinf);

	MsiString strAvailablePlatforms (riAvailablePlatforms); 
	riAvailablePlatforms.AddRef();
	MsiString strPlatform;
	if (strAvailablePlatforms.TextSize() == 0) // empty list means platform-independent
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_INTEL;
		return ieiSuccess;
	}

	bool fIntel = false;
	bool fIntel64 = false;
	bool fAmd64 = false;
	for (;;)
	{
		strPlatform = strAvailablePlatforms.Extract(iseUpto, IPLATFORM_DELIMITER);
		if (strPlatform.Compare(iscExact, IPROPNAME_INTEL))
			fIntel = true;
		else if (strPlatform.Compare(iscExact, IPROPNAME_AMD64))
			fAmd64 = true;
		else if (strPlatform.Compare(iscExact, IPROPNAME_INTEL64))
			fIntel64 = true;

		if (!strAvailablePlatforms.Remove(iseIncluding, IPLATFORM_DELIMITER))
			break;
	}

	// mixed packages are not supported
	if ((fIntel64 && fIntel) ||
	    (fIntel64 && fAmd64) ||
	    (fAmd64 && fIntel) )
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_UNKNOWN; // use unknown to represent mixed
		return ieiPlatformUnsupported;
	}

	if ( fIntel64 )
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_IA64;
		if ( !g_fWinNT64 )
			// we do not allow 64-bit packages to run on a 32-bit OS
			return ieiPlatformUnsupported;
		else
			return ieiSuccess;
	}
	else if (fAmd64)
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_AMD64;
		if (!g_fWinNT64)
			// we do not allow 64-bit packages to run on 32-bit OS
			return ieiPlatformUnsupported;
		else
			return ieiSuccess;
	}
	else if ( fIntel )
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_INTEL;
		return ieiSuccess;
	}
	else
	{
		wChosenPlatform = sinf.wProcessorArchitecture;
		return ieiPlatformUnsupported;
	}
}

ipitEnum CMsiEngine::InProgressInstallType(IMsiRecord& riInProgressInfo)
{
	ipitEnum ipitRet = ipitSameConfig;
	
	MsiString strCurrentLogon = GetPropertyFromSz(IPROPNAME_LOGONUSER);
	if(!(strCurrentLogon.Compare(iscExactI,MsiString(riInProgressInfo.GetMsiString(ipiLogonUser)))))
	{
		DEBUGMSG(TEXT("Checking in-progress install: install performed by different user."));
		ipitRet = ipitEnum(ipitRet | ipitDiffUser);
	}

	if(!(m_piProductKey->Compare(iscExactI, MsiString(riInProgressInfo.GetMsiString(ipiProductKey)))))
	{
		DEBUGMSG(TEXT("Checking in-progress install: install for different product."));
		ipitRet = ipitEnum(ipitRet | ipitDiffProduct);
	}

	// determine if same configuration or not
	// compare in-progress property values with those on the command line - command line
	// may not override any in-progress properties
	
	// comparison is fairly weak here - currently we only check the action to make sure it is the same
	// other things to check in the future: selections, folders, random properties

	MsiString strCurrentAction, strInProgressAction;
	strCurrentAction = GetPropertyFromSz(IPROPNAME_ACTION);
	
	MsiString strProperties = riInProgressInfo.GetMsiString(ipiProperties);
	ProcessCommandLine(strProperties, 0, 0, 0, &strInProgressAction, 0, 0, 0, fTrue, 0, 0);

	Assert(strInProgressAction.TextSize());

	// same config if actions are identical, or current action not specified and inprogress using default action
	if(strCurrentAction.Compare(iscExactI,strInProgressAction) ||
		(strCurrentAction.TextSize() == 0 && strInProgressAction.Compare(iscExactI, szDefaultAction)))
	{
		MsiString strSelections = riInProgressInfo.GetMsiString(ipiSelections);
		MsiString strValue;
		AssertNonZero(ProcessCommandLine(strSelections, 0, 0, 0, 0, 0,
													MsiString(IPROPNAME_FEATUREREMOVE), &strValue,
													fTrue, 0, 0));
		if ( strValue.Compare(iscExactI, TEXT("ALL")) )
		{
				//  fix to bug # 8785: we do not attempt to resume an interrupted RemoveAll.
			DEBUGMSG(TEXT("Checking in-progress install: install for an uninstall."));
			ipitRet = ipitEnum(ipitRet | ipitDiffConfig);
		}
		else
			DEBUGMSG(TEXT("Checking in-progress install: install for same configuration."));
	}
	else
	{
		DEBUGMSG(TEXT("Checking in-progress install: install for different configuration."));
		ipitRet = ipitEnum(ipitRet | ipitDiffConfig);
	}

	return ipitRet;
}

ieiEnum CMsiEngine::ProcessInProgressInstall()
{
	if(!m_piProductKey)
		return ieiSuccess;
	
	iuiEnum iui = g_scServerContext == scClient ? m_iuiLevel :
					  (iuiEnum)GetPropertyInt(*MsiString(IPROPNAME_CLIENTUILEVEL));
					
	if((GetMode() & iefSecondSequence) ||             // in-progress install already processed on client side
		((iui == iuiFull || iui == iuiReduced) && (m_piServer && m_piServer->IsServiceInstalling())))
																	  // on client side and mutex already exists -
																	 //  assume currently running install is in-progress install
																	 //  or will handle in-progress install
																	 // NOTE: condition will cause in-progress install to be processed
																	 //  twice when LIMITUI set on NT
	{
		return ieiSuccess;
	}
	
	PMsiRecord pInProgressInfo(0);
	bool fRes = GetInProgressInfo(*&pInProgressInfo);
	Assert(fRes);
	if(fRes && pInProgressInfo && pInProgressInfo->GetFieldCount())
	{
		// we have an in-progress install
		ipitEnum ipit = InProgressInstallType(*pInProgressInfo);

		// if the RUNONCEENTRY property is set, it means that the current install was launched from the RunOnce key
		// and that in-progress install must be the install that is being resumed
		if((ipit & ipitDiffUser) && MsiString(GetPropertyFromSz(IPROPNAME_RUNONCEENTRY)).TextSize())
		{
			Assert((ipit & ipitDiffProduct) == 0);
			
			// need to know if install was per-machine or not - parse ALLUSERS prop from command line
			MsiString strProperties = pInProgressInfo->GetMsiString(ipiProperties);
			MsiString strAllUsers;
			AssertNonZero(ProcessCommandLine(strProperties,0,0,0,0,0,
														MsiString(IPROPNAME_ALLUSERS),&strAllUsers,
														fTrue, 0, 0));
			
			
			// different user starting install after reboot
			if(strAllUsers.TextSize())
			{
				// suspended install is per-machine - we let the current user continue the install
				Assert(strAllUsers.Compare(iscExact,TEXT("1")));
				ipit = ipitSameConfig;
			}
			else if(g_fWin9X)
			{
				// if profiles are not enabled a different user can continue the install
				// note that we must make sure we thought profiles were disabled for the suspended install
				// AND the current install.  there are some cases where it looks as if profiles are not
				// enabled when they really are (when you cancel the login prompt)
				MsiString strInProgressProfilesEnabled, strCurrentProfilesEnabled;
				AssertNonZero(ProcessCommandLine(strProperties,0,0,0,0,0,
															MsiString(IPROPNAME_WIN9XPROFILESENABLED),
															&strInProgressProfilesEnabled, fTrue, 0, 0));

				strCurrentProfilesEnabled = GetPropertyFromSz(IPROPNAME_WIN9XPROFILESENABLED);

				if(!strInProgressProfilesEnabled.TextSize() && !strCurrentProfilesEnabled.TextSize())
				{
					ipit = ipitSameConfig;
				}
			}

			if(ipit != ipitSameConfig)
			{
				// suspended install is per-user
				// user can't continue, so we warn the user and end the install
				PMsiRecord pError = PostError(Imsg(imsgDiffUserInstallInProgressAfterReboot),
														*MsiString(pInProgressInfo->GetMsiString(ipiLogonUser)),
														*MsiString(pInProgressInfo->GetMsiString(ipiProductName)));

				Message(imtUser,*pError);
				return ieiDiffUserAfterReboot;
			}
		}
		
		if(ipit == ipitSameConfig)
		{
			// resuming suspended install

			// if REBOOT=FORCE is in the InProgress info, and we are resuming a ForceReboot install, unset that property now
			MsiString strRebootPropBeforeInProgress = GetPropertyFromSz(IPROPNAME_REBOOT);

			DEBUGMSG(TEXT("Suspended install detected. Resuming."));
			MsiString strSelections = pInProgressInfo->GetMsiString(ipiSelections);
			MsiString strFolders    = pInProgressInfo->GetMsiString(ipiFolders);
			MsiString strProperties = pInProgressInfo->GetMsiString(ipiProperties);
			MsiString strAfterRebootProperties = pInProgressInfo->GetMsiString(ipiAfterReboot);
			AssertNonZero(ProcessCommandLine(strSelections,0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));
			AssertNonZero(ProcessCommandLine(strFolders,   0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));
			AssertNonZero(ProcessCommandLine(strProperties,0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));
			AssertNonZero(ProcessCommandLine(strAfterRebootProperties,0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));

			MsiString strRebootPropAfterInProgress = GetPropertyFromSz(IPROPNAME_REBOOT);

			if(((((const ICHAR*) strRebootPropBeforeInProgress)[0] & 0xDF) != TEXT('F')) && // REBOOT <> FORCE before processing InProgress info
			   ((((const ICHAR*) strRebootPropAfterInProgress )[0] & 0xDF) == TEXT('F')) && // REBOOT == FORCE in InProgress info
				MsiString(GetPropertyFromSz(IPROPNAME_AFTERREBOOT)).TextSize())              // we are after a ForceReboot
			{
				// unset REBOOT property because most likely the user doesn't want to reboot again
				DEBUGMSG1(TEXT("%s property set to 'F' after a ForceReboot.  Resetting property to NULL."), IPROPNAME_REBOOT);
				AssertNonZero(SetProperty(*MsiString(*IPROPNAME_REBOOT), g_MsiStringNull));
			}

			// set Resume and UpdateStarted properties
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUME), *MsiString(TEXT("1"))));
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUMEOLD), *MsiString(TEXT("1"))));
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_UPDATESTARTED), *MsiString(TEXT("1"))));
		}
	}

	return ieiSuccess;
}

// this function should go away once bug # 463473 gets fixed.

void FormatEventLogData(const ICHAR* szGuid, const IMsiString*& rpiGuid, UINT uError=0)
{
	CTempBuffer<ICHAR, 256> rgchBuffer;
	if ( uError )
	{
		ASSERT_IF_FAILED(StringCchPrintf(rgchBuffer, rgchBuffer.GetSize(),
													TEXT("%s, %u"), szGuid, uError));
	}
	else
		ASSERT_IF_FAILED(StringCchCopy(rgchBuffer, rgchBuffer.GetSize(), szGuid));
	
	MsiString((const ICHAR*)rgchBuffer).ReturnArg(rpiGuid);
}

iesEnum CMsiEngine::Terminate(iesEnum iesState)
// If we are a child install or we are the server side of a client side install then we return
// iesReboot or iesRebootNow if a reboot is required (but don't prompt the user to reboot)
// Otherwise, we return iesCallerReboot if we require a reboot and the user said to reboot (or there is no UI)
{
	MsiSuppressTimeout();
	
	if (!m_fInitialized)
		return iesFailure;
	ENG::WaitForCustomActionThreads(this, fTrue, *this);  // wait for icaContinue async custom actions, except if EXE

	// if in the client and the parent engine, we can kill the custom action server. In the service, the script
	// will kill the CA server when finished.
	if (g_scServerContext == scClient && !m_piParentEngine)
		ShutdownCustomActionServer();
	
	MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME);
	if(!strProductName.TextSize())
		strProductName = TEXT("Unknown Product");

	bool fPropagateReboot = false;
	bool fQuietReboot = false;
	bool fDependents = ((m_iioOptions & iioClientEngine) != 0) || m_piParentEngine || ((GetMode() & iefSecondSequence) && (g_scServerContext != scClient));
	bool fRebootNeeded = false;

	if(GetMode() & iefRebootNow)
		SetMode(iefReboot, fTrue); // make sure both are set
	
	if (!IgnoreReboot() && (iesState == iesSuccess || iesState == iesNoAction || (iesState == iesSuspend && (GetMode() & iefRebootNow))))
	{
		// successful completion - determine if reboot should happen
		MsiString strReboot = GetPropertyFromSz(IPROPNAME_REBOOT);
		MsiString strRebootPrompt = GetPropertyFromSz(IPROPNAME_REBOOTPROMPT);

		fQuietReboot = (((const ICHAR*) strRebootPrompt)[0] & 0xDF) == TEXT('S');

		switch(((const ICHAR*)strReboot)[0] & 0xDF)
		{
		case TEXT('S'):
			// REBOOT=SUPPRESS: suppress end-of-install reboots
			if(GetMode() & iefRebootNow)
				break;
			// fall through
		case TEXT('R'):
			// REBOOT=REALLYSUPPRESS: suppress end-of-install and ForceReboot reboots
			if(GetMode() & iefReboot)
				SetMode(iefRebootRejected, fTrue);

			SetMode(iefReboot, fFalse);
			SetMode(iefRebootNow, fFalse);
			break;
		case TEXT('F'):
			// REBOOT=FORCE: force reboot
			SetMode(iefReboot, fTrue);
			break;
		};

	
		if (fDependents) // parent or client-side engine will do the actual reboot if necessary
		{
			fPropagateReboot = true;
		}
		else
		{
			if (GetMode() & iefReboot)
			{
				PMsiRecord piRecord(0);
				imtEnum imtOutput = imtInfo;
				if (GetLoggedOnUserCount() > 1)
				{
					piRecord = PostError(Imsg(imsgRebootWithWarning), *strProductName);
					// Default button should be "No" in this case.
					if (!fQuietReboot)
						imtOutput = imtEnum(imtUser | imtYesNo | imtDefault2);
				}
				else
				{
					piRecord = PostError(GetMode() & iefRebootNow ? Imsg(imsgRebootNow) : Imsg(imsgRebootAtEnd), *strProductName);
					// In this case, the default button is "Yes".
					if (!fQuietReboot)
						imtOutput = imtEnum(imtUser | imtYesNo);
				}
				
				imsEnum imsReturn = Message(imtOutput, *piRecord);
				switch (imsReturn)
				{
				case imsYes:
				case imsNone:
				case imsOk:
					break;
				case imsNo:
					SetMode(iefRebootRejected, fTrue);
					SetMode(iefReboot, fFalse);
					SetMode(iefRebootNow, fFalse);
					fRebootNeeded = true;
					break;
				default:
					AssertSz(false, "Invalid return from message");
					break;
				}
			}
		}
	}
	else
	{
		// failure, user cancelled, restricted engine, or creating advertise script - clear reboot flags in case they'd been set previously
		if (IgnoreReboot() && ((GetMode() & iefReboot) || (GetMode() & iefRebootNow)))
		{
			DEBUGMSG(TEXT("Reboot has been ignored because we are in a restricted engine or we are creating an advertise script."));
		}
		SetMode(iefReboot, fFalse);
		SetMode(iefRebootNow, fFalse);
		SetMode(iefRebootRejected, fFalse);
	}

#ifdef DEBUG
	if(m_fServerLocked && !m_fInParentTransaction && iesState == iesSuccess)
		AssertSz(0,"Server still locked in Engine.Terminate.");
#endif //DEBUG

	if (g_MessageContext.ChildUIThreadExists())
	{
		// See if the thread is still running, if it isn't we want to terminate
		if (!g_MessageContext.ChildUIThreadRunning())
		{
			g_MessageContext.Terminate(fFalse);
		}
	}

	if (g_MessageContext.Invoke(imtEnum(imtDumpProperties), 0) == imsYes && m_piPropertyCursor)
	{
		PMsiTable pTable(0);
		PMsiRecord pError = m_piDatabase->LoadTable(*MsiString(*sztblControl), 0, *&pTable);
		if ( pError )
			pTable = 0;
		MsiString strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		MsiString strStars(IPROPVALUE_HIDDEN_PROPERTY);

		// use new cursor - m_piPropertyCursor used within FormatLog
		PMsiTable pPropertyTable = &m_piPropertyCursor->GetTable();
		PMsiCursor pPropertyCursor = pPropertyTable->CreateCursor(fFalse);
		PMsiRecord pRecord(&ENG::CreateRecord(2));
		ICHAR rgchBuf[sizeof(szPropertyDumpTemplate)/sizeof(ICHAR)]; // substitute a single character
		int chEngine = 'C';
		if (m_piParentEngine)
			chEngine = 'N';
		else if (g_scServerContext != scClient)
			chEngine = 'S';
		StringCchPrintf(rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR),  szPropertyDumpTemplate, chEngine);
		pRecord->SetString(0, rgchBuf);
		while (pPropertyCursor->Next())
		{
			MsiString strProperty(pPropertyCursor->GetString(1));
			pRecord->SetMsiString(1,*strProperty);
			if ( IsPropertyHidden(strProperty, strHiddenProperties, pTable, *m_piDatabase, NULL) )
				pRecord->SetMsiString(2,*strStars);
			else
				pRecord->SetMsiString(2,*MsiString(pPropertyCursor->GetString(2)));
			g_MessageContext.Invoke(imtEnum(imtForceLogInfo), pRecord);
		}
	}

	if (!fDependents)
	{
		ReleaseHandler();

		// terminate log

		const IMsiString* piLogTrailer = m_rgpiMessageHeader[imsgLogTrailer];
		if (piLogTrailer)
		{
			PMsiRecord pRecord = &ENG::CreateRecord(0);
			pRecord->SetMsiString(0, *piLogTrailer);
			Message(imtEnum(imtForceLogInfo), *pRecord);  // use engine to format properties
		}
	}

	FreeDirectoryTable();    // release path objects held by table
	FreeSelectionTables();
	
	int iefMode = GetMode(); // grab this before we clear the engine data

	// If not already logged by a call to FatalError, send install result to Event log
	if (!fDependents && !m_fResultEventLogged &&
		 (iesState == iesSuccess || iesState == iesFailure ||
		  iesState == iesUserExit ))
		//!! FUTURE eugend: new eventlog-type messages need to be added
		//                  for the iesState == UserExit case here,
		//                  for each of installation, configuration
		//                  and removal, stating that the operation got
		//                  interrupted.
		//                  bug # 463473 is tracking this.
	{
		UINT uFakeError = (iesState == iesUserExit) ? ERROR_INSTALL_USEREXIT : 0;  // this should go away once bug # 463473 gets fixed.
		int iErrorIndex = 0;
		IErrorCode iErrorCode = 0;

		switch(GetInstallType())
		{
		case iitFirstInstall:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogInstallSuccess;
				iErrorCode  = Imsg(imsgEventLogInstallSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogInstallFailed;
				iErrorCode  = Imsg(imsgEventLogInstallFailed);
			}
			break;

		case iitMaintenance:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogConfigurationSuccess;
				iErrorCode  = Imsg(imsgEventLogConfigurationSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogConfigurationFailed;
				iErrorCode  = Imsg(imsgEventLogConfigurationFailed);
			}
			break;

		case iitUninstall:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogUninstallSuccess;
				iErrorCode  = Imsg(imsgEventLogUninstallSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogUninstallFailed;
				iErrorCode  = Imsg(imsgEventLogUninstallFailed);
			}
			break;

		case iitAdvertise:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogAdvertiseSuccess;
				iErrorCode  = Imsg(imsgEventLogAdvertiseSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogAdvertiseFailed;
				iErrorCode  = Imsg(imsgEventLogAdvertiseFailed);
			}
			break;
		};

		if(iErrorIndex)
		{
			PMsiRecord pError = PostError(iErrorCode);
			AssertNonZero(pError->SetMsiString(0, *MsiString(GetErrorTableString(iErrorIndex))));
			ReportToEventLog(EVENTLOG_INFORMATION_TYPE,
								  EVENTLOG_ERROR_OFFSET + pError->GetInteger(1),
								  *pError, uFakeError);
		}
	}

	// reboot handling
	if (iefMode & iefRebootNow) // reboot triggered by ForceReboot
	{
		if(fPropagateReboot) // pass to client engine
		{
			DEBUGMSG("Propagated RebootNow to the client/parent install.");
			iesState = (iesEnum)iesRebootNow; // client will change return back to ERROR_INSTALL_SUSPEND
		}
		else
			iesState = (iesEnum)iesCallerReboot; // caller will reboot for us

		if (m_piConfigManager)
			m_piConfigManager->EnableReboot(m_fRunScriptElevated,
													  *strProductName,
													  *MsiString(GetProductKey()));
	}
	else if (iefMode & iefReboot) // normal end-of-install reboot
	{
		if(fPropagateReboot) // pass to client engine
		{
			DEBUGMSG("Propagated Reboot to the client/parent install.");
			iesState = (iesEnum)iesReboot;
		}
		else
			iesState = (iesEnum)iesCallerReboot; // caller will reboot for us
			
		if (m_piConfigManager)
			m_piConfigManager->EnableReboot(m_fRunScriptElevated,
													  *strProductName,
													  *MsiString(GetProductKey()));
	}
	else if (iefMode & iefRebootRejected && iesState != iesSuspend) // if ForceReboot reboot rejected, we still
																						 // want to return ERROR_INSTALL_SUSPEND
	{
		iesState = (iesEnum)iesRebootRejected; // reboot required but rejected by user or REBOOT=S/R
		fRebootNeeded = true;
	}

	if ( fRebootNeeded )
	{
		//!! FUTURE eugend: a new eventlog-type message needs to be added
		//                  here, stating that a reboot is needed for the
		//                  completion of the installation of this product.
		//
		//                  bug # 463473 tracks this.
		MsiString strTemp;
		FormatEventLogData(MsiString(GetProductKey()),
								 *&strTemp,
								 ERROR_SUCCESS_REBOOT_REQUIRED);  // this should go away once bug # 463473 gets fixed.
		CConvertString sTemp((const ICHAR*)strTemp);
		const char* pszTemp = sTemp;
		DEBUGMSGED(EVENTLOG_INFORMATION_TYPE,
					  EVENTLOG_TEMPLATE_REBOOT_TRIGGERED,
					  strProductName, IStrLen(sTemp), (LPVOID)pszTemp);
	}
	ClearEngineData();
	m_fInitialized = fFalse; // can't run again without initializing

	MsiSuppressTimeout();
	UnbindLibraries();
	g_Win64DualFolders.Release();
	return iesState;
}

const IMsiString& CMsiEngine::GetRootParentProductKey()  // recurses up nested install hierarchy
{
	if (!(m_fChildInstall && m_piParentEngine))
		return GetProductKey();
	return m_piParentEngine->GetRootParentProductKey();
}

Bool CMsiEngine::InTransaction()
{
	if (m_fServerLocked)
		return fTrue;
#ifdef DEBUG
	if(m_piParentEngine)
		Assert(m_piParentEngine->InTransaction() == fFalse);
#endif //DEBUG
	return fFalse;
}

HRESULT CMsiClientMessage::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiMessage))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiClientMessage::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiClientMessage::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	if (m_fMessageContextInitialized == true)
		g_MessageContext.Terminate(fFalse);
	delete this;
	g_cInstances--;
	return 0;
}

extern IMsiRecord* g_piNullRecord;

imsEnum CMsiClientMessage::MessageNoRecord(imtEnum imt)
{
	return Message(imt, *g_piNullRecord);
}

imsEnum CMsiClientMessage::Message(imtEnum imt, IMsiRecord& riRecord)
{
	int imsg = ((imt & ~iInternalFlags) & imtTypeMask);
	if (imsg > imtCommonData && imsg != imtCustomServiceToClient)  //!! move to action.cpp and use mask, or put limit in engine.h
	{
		g_MessageContext.m_szAction = riRecord.GetString(0);
		return g_MessageContext.Invoke(imt, 0);
	}
	imtEnum imtArg = imt;
	if (imsg == imtActionStart || imsg == imtActionData)
		// there's no engine, so there's no way to get the value of LOGACTION property
		imtArg = imtEnum(imt | imtSuppressLog);
	return g_MessageContext.Invoke(imtArg, &riRecord);
}

iesEnum CMsiEngine::RunExecutionPhase(const ICHAR* szActionOrSequence, bool fSequence)
{
	Assert(szActionOrSequence && *szActionOrSequence);

	// running on the server side is not permitted in a SAFE engine
	if (m_fRestrictedEngine)
	{
		DEBUGMSG2(TEXT("Running server side execution of %s %s is not permitted in a restricted engine"), fSequence ? TEXT("sequence") : TEXT("action"), szActionOrSequence);
		return iesNoAction;
	}

	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);
    	
	CMutex hExecuteMutex; // will release when out of scope
	bool fSetPowerdown = false;
	
	m_cExecutionPhaseSequenceLevel = m_cSequenceLevels;
	
	// if client-side or running an install from a custom action, grab the execution mutex as we are about to run the execution phase
	// in some cases, this thread already has the mutex but it won't hurt to grab it again.
	if((g_scServerContext == scClient || g_scServerContext == scCustomActionServer) && !m_piParentEngine)
	{
		// the convention is that with basic UI we don't prompt the user to retry when another install
		// is running. For example, when the server is registered and basic UI, we grab the mutex in
		// CreateAndRunEngine, before we have any UI to prompt the user with.  We need extra logic here
		// to achieve the same behaviour - thus we pass 0 for the message object when the UI level is
		// less than reduced
		while ( m_piServer && m_piServer->IsServiceInstalling() &&
				  !(m_iuiLevel == iuiBasic || m_iuiLevel == iuiNone) )
		{
			PMsiRecord pError = PostError(Imsg(imsgInstallInProgress));
			switch(Message(imtEnum(imtRetryCancel|imtError), *pError))
			{
			case imsCancel:
				pError = PostError(Imsg(imsgConfirmCancel));
				switch(Message(imtEnum(imtUser+imtYesNo+imtDefault2), *pError))
				{
				case imsNo:
					continue;
				default: // imsNone, imsYes
					return iesUserExit;
				}
				break;
			case imsRetry:
				continue;
			case imsNone:
				return iesInstallRunning;
			}
		}
		GrabExecuteMutex(hExecuteMutex);
		fSetPowerdown = true;
		m_riServices.SetNoOSInterruptions();
	}
	
	if (FIsUpdatingProcess())
	{
		iesEnum iesRet;
		DEBUGMSG1("Not switching to server: %s", (g_scServerContext != scClient) ? "we're in the server" : "we're not connected to the server" );
		if(fSequence)
			iesRet = Sequence(szActionOrSequence);
		else
			iesRet = DoAction(szActionOrSequence);

		if (fSetPowerdown)
			m_riServices.ClearNoOSInterruptions();
		return iesRet;
	}
	else if (!m_piServer)
	{
	    iesEnum iesRet;
	    PMsiRecord pError = PostError (Imsg(imsgServiceConnectionFailure));
	    Message(imtEnum(imtError + imtOk), *pError);
	    iesRet = FatalError (*pError);
	    
	    if (fSetPowerdown)
			m_riServices.ClearNoOSInterruptions();
	    return iesRet;
	}

	Assert(!fSequence);
	Assert(m_piServer);

	MsiString strPropertyList, strLoggedPropertyList;
	MsiString strSelections;
	AssertRecord(GetCurrentSelectState(*&strSelections, *&strPropertyList, &strLoggedPropertyList, 0, fTrue));
	strPropertyList += *TEXT(" ");
	strPropertyList += strSelections;
	strPropertyList += *TEXT(" ");
	strLoggedPropertyList += *TEXT(" ");
	strLoggedPropertyList += strSelections;
	strLoggedPropertyList += *TEXT(" ");

	MsiString strDatabase = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE); //?? there might be some optimization we can do to avoid having to cache the temp database twice, but there are security considerations...

	DEBUGMSG1(TEXT("Switching to server: %s"), strLoggedPropertyList);

	MsiString strHomeVars;
	GetHomeEnvironmentVariables(*&strHomeVars);

	strPropertyList += strHomeVars;

	int iError;
	iesEnum iesReturn = iesSuccess;

	iioEnum iioOptions = m_iioOptions;


	// now add MSIPATCHDOWNLOADLOCALCOPY if necessary, should only be set for admins
	if (m_strPatchDownloadLocalCopy.TextSize())
	{
		Assert(IsAdmin());
		strPropertyList += TEXT(" ") IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY TEXT("=\"");
		strPropertyList += m_strPatchDownloadLocalCopy;
		strPropertyList += TEXT("\" ");

		// indicate property should be trusted
		iioOptions = (iioEnum)(iioOptions | iioPatchApplication);
	}

	if((GetMode() & iefRollbackEnabled) == 0)
		iioOptions = (iioEnum)(iioOptions | iioDisableRollback);

	if (g_scServerContext == scClient)
		iioOptions = (iioEnum)(iioOptions | iioClientEngine);

	for (;;)
	{
		PMsiMessage pMessage = new CMsiClientMessage();
		
                iError = m_piServer->DoInstall(irePackagePath, strDatabase, szActionOrSequence, strPropertyList,g_szLogFile,g_dwLogMode, g_fFlushEachLine, *pMessage,iioOptions,0);

		switch(iError)
		{
		
		// for this group of returns we don't need to alert the user. either the user has
		// already seen the error dialog, or she doesn't need to see one, or the dialog
		// will be displayed in the near future

		case ERROR_SUCCESS:                              break;
		case ERROR_INSTALL_SUSPEND:      iesReturn = iesSuspend;  break;
		case ERROR_INSTALL_USEREXIT:     iesReturn = iesUserExit; break;
		case ERROR_INSTALL_ALREADY_RUNNING: iesReturn = iesInstallRunning; break;
		case ERROR_INSTALL_REBOOT_NOW: iesReturn = iesSuspend;  SetMode(iefRebootNow, fTrue); // fall through
		case ERROR_INSTALL_REBOOT:               SetMode(iefReboot, fTrue); break;
		case ERROR_SUCCESS_REBOOT_REQUIRED: SetMode(iefRebootRejected, fTrue); break;
		case ERROR_INSTALL_FAILURE:    iesReturn = iesFailure; break;

		// the most likely cause of this group of errors is a network failure. we'll give
		// the user a chance to retry if we see any of these

		case ERROR_FILE_NOT_FOUND:                                              // fall through
		case ERROR_INSTALL_PACKAGE_OPEN_FAILED:
		case ERROR_INSTALL_PACKAGE_INVALID:
		case ERROR_PATCH_PACKAGE_OPEN_FAILED:
		case ERROR_PATCH_PACKAGE_INVALID:
			{
				PMsiRecord pError = PostError(Imsg(imsgErrorReadingFromFile), *strDatabase, GetLastError());
				switch(Message(imtEnum(imtError+imtRetryCancel),*pError))
				{
				case imsRetry:
					continue;
				default:
					iesReturn = iesFailure;
				};
			}
			break;

		// any other error we get is unexpected, so we'll put up a debug error

		default:
#ifdef DEBUG
			ICHAR rgchMsg[1025];

			StringCchPrintf(rgchMsg, sizeof(rgchMsg)/sizeof(ICHAR),  TEXT("Unexpexcted return code %d.\n"), iError);
			AssertSz(fFalse, rgchMsg);
#endif //DEBUG
			iesReturn = iesFailure;    // fall through
			{
				PMsiRecord pError = PostError(Imsg(idbgUnexpectedServerReturn), iError, strDatabase);
				iesReturn = FatalError(*pError);
			}
		}

		break;
	}

	m_fJustGotBackFromServer = fTrue;
	DEBUGMSG1(TEXT("Back from server. Return value: %d"), (const ICHAR*)(INT_PTR)iError);

	if (fSetPowerdown)
		m_riServices.ClearNoOSInterruptions();
	return iesReturn;
}

Bool CMsiEngine::UnlockInstallServer(Bool fSuspend)
{
	DEBUGMSG(TEXT("Unlocking Server"));
	
	if(fSuspend == fFalse) // not suspending install - remove InProgressKey
	{
		return ClearInProgressInformation(m_riServices) ? fTrue : fFalse;
	}
	return fTrue;
}

bool CMsiEngine::GetInProgressInfo(IMsiRecord*& rpiCurrentInProgressInfo)
{
	//!! need to have a mutex around this so we aren't writing and reading key at same time?
	PMsiRecord pError = GetInProgressInstallInfo(m_riServices, rpiCurrentInProgressInfo);
	return pError == 0;
}

IMsiRecord* CMsiEngine::LockInstallServer(IMsiRecord* piSetInProgressInfo,       // InProgress info to set
													IMsiRecord*& rpiCurrentInProgressInfo) // current InProgress info if any
{
	Assert(m_fServerLocked == fFalse);

	IMsiRecord* piError = 0;

	PMsiRecord pInProgressInfo(0);
	if((piError = GetInProgressInstallInfo(m_riServices, *&pInProgressInfo)) != 0)
		return piError;

	if(pInProgressInfo && pInProgressInfo->GetFieldCount())
	{
		MsiString strInProgressProductKey = pInProgressInfo->GetMsiString(ipiProductKey);
		rpiCurrentInProgressInfo = pInProgressInfo;
		rpiCurrentInProgressInfo->AddRef();

		// not running - need to roll back or resume
		DEBUGMSG1(TEXT("Server Locked: Install is suspended for product %s"),(const ICHAR*)strInProgressProductKey);
		return 0;
	}
	else if(piSetInProgressInfo)
	{
		MsiString strProductKey = GetProductKey();

		DEBUGMSG1(TEXT("Server not locked: locking for product %s"),(const ICHAR*)strProductKey);

		return SetInProgressInstallInfo(m_riServices, *piSetInProgressInfo);
	}
	else
		return 0;
}

iesEnum CMsiEngine::RollbackSuspendedInstall(IMsiRecord& riInProgressParams, Bool fPrompt,
															Bool& fRollbackAttempted, Bool fUserChangedDuringInstall)
// prompt user and rollback in-progress install
// assumes a mutex is created for this install
{
	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);

	if (NULL == m_piServer)
	{
	    PMsiRecord pError = PostError (Imsg(imsgServiceConnectionFailure));
	    return FatalError(*pError);
	}
	
	MsiString strProductKey = riInProgressParams.GetMsiString(ipiProductKey);
	Bool fSameProduct = ToBool(strProductKey.Compare(iscExactI,MsiString(GetProductKey())));
	IErrorCode imsg = fSameProduct ? Imsg(imsgResumeWithDifferentOptions) : Imsg(imsgOtherInstallSuspended);
	MsiString strProductName = riInProgressParams.GetMsiString(ipiProductName);

	if(fPrompt)
	{
		PMsiRecord pError = PostError(imsg,*strProductName);
		if(Message(imtEnum(imtError|imtYesNo), *pError) == imsNo)
		{
			fRollbackAttempted = fFalse;
			return iesFailure;
		}
	}

	// need to use basic UI for rollback progress
	fRollbackAttempted = fTrue;
	iesEnum iesRet = m_piServer->InstallFinalize(iesFailure,*this, fUserChangedDuringInstall);
	if(iesRet == iesSuspend)
	{
		// rollback requires a reboot to complete
		// when rolling back a suspended install, we treat it like a "reboot before continuing" reboot
		SetMode(iefReboot, fTrue);
		SetMode(iefRebootNow, fTrue);
		// will return iesSuspend below, causing install to stop
	}

	CloseHydraRegistryWindow(/*Commit=*/false);
	EndSystemChange(/*fCommitChange=*/false, riInProgressParams.GetString(ipiSRSequence));
	AssertNonZero(UnlockInstallServer(fFalse));
	return iesRet;
}

//FN: writes msistring into stream as unicode text
void ConvertMsiStringToStream(const IMsiString& riString, IMsiStream& riStream)
{
	const WCHAR* pwch;
	unsigned long cbWrite;
#ifdef UNICODE
	pwch = riString.GetString();
	cbWrite = riString.TextSize()* sizeof(ICHAR);
#else
	CTempBuffer<WCHAR, 1024> rgchBuf;
	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, riString.GetString(), -1, 0, 0);
	rgchBuf.SetSize(cch);
	AssertNonZero(WIN::MultiByteToWideChar(CP_ACP, 0, riString.GetString(), -1, rgchBuf, cch));
	pwch = rgchBuf;
	cbWrite = (cch - 1)* sizeof(WCHAR);
#endif
	riStream.PutData(pwch, cbWrite);
}

//FN: reads stream as unicode text into msistring 
const IMsiString& ConvertStreamToMsiString(IMsiStream& riStream)
{
	const IMsiString* piString;
	unsigned long cbRead;
	unsigned long cbLength = riStream.Remaining();
	const WCHAR* pwch;
	if(!cbLength)
		return SRV::CreateString();
	pwch = SRV::AllocateString(cbLength/sizeof(ICHAR), fFalse, piString);
	if (!pwch)
		return SRV::CreateString();
	cbRead = riStream.GetData((void*)pwch, cbLength);
	if (cbRead != cbLength)
	{
		piString->Release();
		return SRV::CreateString();
	}
	return *piString;
}

// structure that defines the inprogress info
struct CInProgressInfo{
	ICHAR* szInProgressFieldName; int iOutputRecordField; bool fRequired;
};

const CInProgressInfo rgInProgressInfo[] =
{
	szMsiInProgressProductCodeValue, ipiProductKey,  true,
	szMsiInProgressProductNameValue, ipiProductName, true,
	szMsiInProgressLogonUserValue,	 ipiLogonUser,   false,
	szMsiInProgressSelectionsValue,  ipiSelections,  false,
	szMsiInProgressFoldersValue,     ipiFolders,     false,
	szMsiInProgressPropertiesValue,  ipiProperties,  false,
	szMsiInProgressTimeStampValue,   ipiTimeStamp,   true,
	szMsiInProgressDatabasePathValue,ipiDatabasePath,false,
	szMsiInProgressDiskPromptValue,  ipiDiskPrompt,  false,
	szMsiInProgressDiskSerialValue,  ipiDiskSerial,  false,
	szMsiInProgressSRSequence,       ipiSRSequence,  false,
	szMsiInProgressAfterRebootValue, ipiAfterReboot,  false,
};

const int cInProgressInfo = sizeof(rgInProgressInfo)/sizeof(CInProgressInfo);

IMsiRecord* GetInProgressInstallInfo(IMsiServices& riServices, IMsiRecord*& rpiRec)
{
	PMsiRecord pError(0); // used to catch errors - don't return
	PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
	PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
	Bool fExists = fFalse;

	MsiString strInProgressFileName;
	PMsiStorage pStorage(0);
	PMsiRecord pRec(0);

	int cIndex = 0;

	if(	((pError = pInProgressKey->Exists(fExists)) == 0) &&
		fExists == fTrue &&
		((pError = pInProgressKey->GetValue(0, *&strInProgressFileName)) == 0) && // filename containing inprogress info
		((pError = riServices.CreateStorage(strInProgressFileName, ismReadOnly, *&pStorage)) == 0)) // create storage
	{
		pRec = &riServices.CreateRecord(ipiEnumCount);

		// get the inprogress info from the storage file
		// each inprogress entity is stored as a stream
		do
		{
			PMsiStream pStream(0);
			if((pError = pStorage->OpenStream(rgInProgressInfo[cIndex].szInProgressFieldName, fFalse, *&pStream)) == 0)
			{
				// read the stream into the record field
				pRec->SetMsiString(rgInProgressInfo[cIndex].iOutputRecordField, *MsiString(ConvertStreamToMsiString(*pStream)));
			}
		}while( (!rgInProgressInfo[cIndex].fRequired || (!pError && MsiString(pRec->GetMsiString(rgInProgressInfo[cIndex].iOutputRecordField)).TextSize())) && // check if we are missing a mandatory field
				(++cIndex < cInProgressInfo));
	}

	if(cIndex != cInProgressInfo) // we do not have progress info
		pRec = &riServices.CreateRecord(0);

	pRec->AddRef();
	rpiRec = pRec;// return the record
	return 0;
}

IMsiRecord* SetInProgressInstallInfo(IMsiServices& riServices, IMsiRecord& riRec)
{
    PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
    Bool fExists = fFalse;
    PMsiRecord pError(0);
    if(((pError = pInProgressKey->Exists(fExists)) == 0) && fExists == fTrue)
    {
        // we've gotten this far without failing by checking the execute mutex - just nuke the key
        CElevate elevate;
        AssertRecord(pInProgressKey->Remove());
    }

    {
        IMsiRecord* piError = 0;
        CElevate elevate;

		// create the file for storing the inprogress info
		// Generate a unique name for inprogress file, create and secure the file.
		MsiString strMsiDir = ENG::GetMsiDirectory();

		// set dest path and file name
		MsiString strInProgressFileName;
		static const ICHAR szInprogressExtension[]  = TEXT("ipi");

		PMsiPath pDestPath(0);

		if (((piError = riServices.CreatePath(strMsiDir, *&pDestPath)) != 0) ||
			((piError = pDestPath->EnsureExists(0)) != 0) ||
			((piError = pDestPath->TempFileName(0, szInprogressExtension, fTrue, *&strInProgressFileName, &CSecurityDescription(true, false))) != 0))
			return piError;
		
		MsiString strInProgressFullFilePath = pDestPath->GetPath();
		strInProgressFullFilePath += strInProgressFileName;

		if ((piError = pDestPath->SetAllFileAttributes(0,FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)) != 0)
		{
			AssertNonZero(WIN::DeleteFile(strInProgressFullFilePath));
			return piError;
		}

		PMsiStorage pStorage(0);
		piError = riServices.CreateStorage(strInProgressFullFilePath, ismCreate, *&pStorage);

		if(piError)
		{
			AssertNonZero(WIN::DeleteFile(strInProgressFullFilePath));
			return piError;
		}

		// write the individual inprogress fields as streams
		int cIndex = 0;
		do
		{
			PMsiStream pStream(0);
			if((pError = pStorage->OpenStream(rgInProgressInfo[cIndex].szInProgressFieldName, fTrue, *&pStream)) == 0)
			{
				// write the stream from the record field
				ConvertMsiStringToStream(*MsiString(riRec.GetMsiString(rgInProgressInfo[cIndex].iOutputRecordField)), *pStream);
			}
		}while(++cIndex < cInProgressInfo);

		// now attempt to commit the Inprogress file
		pError = pStorage->Commit();

		if(pError)
		{
			AssertNonZero(WIN::DeleteFile(strInProgressFullFilePath));
			return pError;
		}


        piError = pInProgressKey->Create();
		if(!piError)
			piError = pInProgressKey->SetValue(0, *strInProgressFullFilePath);
        if(piError)
        {
            // cleanup in case key is half-written
			AssertNonZero(WIN::DeleteFile(strInProgressFullFilePath));
            AssertRecord(pInProgressKey->Remove());
            
            if(piError->GetInteger(2) == ERROR_ACCESS_DENIED) // assumes system error is in 2nd field
            {
                DEBUGMSG(MsiString(piError->FormatText(fTrue)));
                piError->Release();
                return PostError(Imsg(imsgErrorAccessingSecuredData));
            }
            else
                return piError;
        }
    }
    RegFlushKey(HKEY_LOCAL_MACHINE);
    return 0;
}

IMsiRecord* UpdateInProgressInstallInfo(IMsiServices& riServices, IMsiRecord& riRec)
{
	IMsiRecord* piError = 0;
	PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
	PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
	Bool fExists = fFalse;

	MsiString strInProgressFileName;
	PMsiStorage pStorage(0);
	PMsiRecord pRec(0);

	if((piError = pInProgressKey->Exists(fExists)) != 0)
		return piError;

	if(fExists == fFalse)
	{
		AssertSz(0, TEXT("No InProgress info to update"));
		return 0;
	}

	if((piError = pInProgressKey->GetValue(0, *&strInProgressFileName)) != 0 ||
		(piError = riServices.CreateStorage(strInProgressFileName, ismTransact, *&pStorage)) != 0)
	{
		return piError;
	}
	
	// write the individual inprogress fields as streams
	int cIndex = 0;
	do
	{
		PMsiStream pStream(0);
		if(!riRec.IsNull(rgInProgressInfo[cIndex].iOutputRecordField))
		{
			if((piError = pStorage->OpenStream(rgInProgressInfo[cIndex].szInProgressFieldName, fTrue, *&pStream)) != 0)
				return piError;
			
			// write the stream from the record field
			ConvertMsiStringToStream(*MsiString(riRec.GetMsiString(rgInProgressInfo[cIndex].iOutputRecordField)), *pStream);
		}
	}while(++cIndex < cInProgressInfo);

	// now attempt to commit the Inprogress file
	if((piError = pStorage->Commit()) != 0)
		return piError;

	return 0;
}

bool ClearInProgressInformation(IMsiServices& riServices)
{
	CElevate elevate;
	PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
	PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
	// read the default value which would point to the file 
	MsiString strInProgressFileName;
	PMsiRecord pError = pInProgressKey->GetValue(0, *&strInProgressFileName);
	AssertRecordNR(pError);
	if(!pError && strInProgressFileName.TextSize())
	{
		// delete the inprogress file
		AssertNonZero(WIN::DeleteFile((const ICHAR*)strInProgressFileName));
	}
	pError = pInProgressKey->Remove();
	AssertRecordNR(pError);
	return pError ? false : true;
}

IMsiRecord* CMsiEngine::GetCurrentSelectState(const IMsiString*& rpistrSelections,
															 const IMsiString*& rpistrProperties,
															 const IMsiString** ppistrLoggedProperties,
															 const IMsiString** ppistrFolders,
															 Bool /*fReturnPresetSelections*/)
{
	PMsiCursor pDirectoryCursor(0);
	PMsiCursor pFeatureCursor(0);

	if(m_piDirTable)
		pDirectoryCursor = m_piDirTable->CreateCursor(fFalse);

	if(m_piFeatureTable)
		pFeatureCursor = m_piFeatureTable->CreateCursor(fFalse);

	bool fGrabbedFeatureProps = false;
	
	if(pFeatureCursor)
	{
		MsiString strSelections;

		// in general if costing has been performed, we don't trust the existing values of the
		// feature properties.  it is possible that the feature properties don't contain the full
		// list of features and their requested states.  for example, ADDLOCAL=Child may actually
		// turn on the Child feature and its parent, if the parent hasn't yet been installed.

		// the exception to this rule is that we do respect REMOVE=ALL. InstallValidate explicitely
		// sets REMOVE=ALL when appropriate, and we don't want to overwrite that with the entire list
		// of properties.

		// NOTE: there is no chance of a preexisting property like ADDDEFAULT sneaking in among our
		// list of properties since we skip all feature properties below when compiling a list
		// of properties
		
		MsiString strRemoveValue = GetPropertyFromSz(IPROPNAME_FEATUREREMOVE);
		if (strRemoveValue.Compare(iscExact, IPROPVALUE_FEATURE_ALL))
		{
			strSelections = IPROPNAME_FEATUREREMOVE TEXT("=") IPROPVALUE_FEATURE_ALL;
		}
		else
		{
			MsiString strAddLocal, strAddSource, strRemove, strReinstall, strAdvertise, strFeature;
			while(pFeatureCursor->Next())
			{
				iisEnum iis = (iisEnum)pFeatureCursor->GetInteger(m_colFeatureActionRequested);
				strFeature = pFeatureCursor->GetString(m_colFeatureKey);
				strFeature += TEXT(",");
				switch(iis)
				{
					case iisAbsent:
						strRemove += strFeature;
						break;
					case iisLocal:
						strAddLocal += strFeature;
						break;
					case iisSource:
						strAddSource += strFeature;
						break;
					case iisReinstall:
						strReinstall += strFeature;
						break;
					case iisAdvertise:
						strAdvertise += strFeature;
						break;
				};
			}

			if(strAddLocal.Compare(iscEnd,TEXT(",")))
				strAddLocal.Remove(iseEnd,1);
			if(strAddSource.Compare(iscEnd,TEXT(",")))
				strAddSource.Remove(iseEnd,1);
			if(strRemove.Compare(iscEnd,TEXT(",")))
				strRemove.Remove(iseEnd,1);
			if(strReinstall.Compare(iscEnd,TEXT(",")))
				strReinstall.Remove(iseEnd,1);
			if(strAdvertise.Compare(iscEnd,TEXT(",")))
				strAdvertise.Remove(iseEnd,1);
			if(strAddLocal.TextSize())
			{
				strSelections += IPROPNAME_FEATUREADDLOCAL;
				strSelections += TEXT("=");
				strSelections += strAddLocal;
				strSelections += TEXT(" ");
			}
			if(strAddSource.TextSize())
			{
				strSelections += IPROPNAME_FEATUREADDSOURCE;
				strSelections += TEXT("=");
				strSelections += strAddSource;
				strSelections += TEXT(" ");
			}
			if(strRemove.TextSize())
			{
				strSelections += IPROPNAME_FEATUREREMOVE;
				strSelections += TEXT("=");
				strSelections += strRemove;
				strSelections += TEXT(" ");
			}
			if(strReinstall.TextSize())
			{
				strSelections += IPROPNAME_REINSTALL;
				strSelections += TEXT("=");
				strSelections += strReinstall;
				strSelections += TEXT(" ");
			}
			if(strAdvertise.TextSize())
			{
				strSelections += IPROPNAME_FEATUREADVERTISE;
				strSelections += TEXT("=");
				strSelections += strAdvertise;
			}
			if (!strSelections.TextSize())
			{
				// no properties were set, but we want to tell the server that to ensure it doesn't attempt to install anything
				// this is an undocumented property value used for communication between client and server
				strSelections += szFeatureSelection;
				strSelections += TEXT("=");
				strSelections += szFeatureDoNothingValue;
			}
		}

		strSelections.ReturnArg(rpistrSelections);
		fGrabbedFeatureProps = true;
	}

	if (ppistrFolders && pDirectoryCursor && pFeatureCursor)
	{
		MsiString strFolders, strFolder;
		pFeatureCursor->Reset();
		pFeatureCursor->SetFilter(iColumnBit(m_colFeatureConfigurableDir));
		// add locations of configurable folders - either ALL CAPS key names, or declared configurable
		// in Feature table
		while(pDirectoryCursor->Next())
		{
			MsiString strDirKey = pDirectoryCursor->GetString(m_colDirKey);
			Assert(strDirKey);
			Bool fConfigurableDir = fFalse;
			// check if a feature has marked this folder as configurable
			AssertNonZero(pFeatureCursor->PutString(m_colFeatureConfigurableDir,*strDirKey));
			if(pFeatureCursor->Next())
			{
				fConfigurableDir = fTrue;
			}
			pFeatureCursor->Reset();
			if(!fConfigurableDir)
			{
				// check if this directory key is all uppercase (can be set on command-line)
				MsiString strTemp = strDirKey;
				strTemp.UpperCase();
				if(strDirKey.Compare(iscExact,strTemp)) //!! is there a better way of doing this?
				{
					fConfigurableDir = fTrue;
				}
			}
			if(fConfigurableDir)
			{
				strFolders += strDirKey;
				strFolders += TEXT("=\"");
				strFolders += MsiString(GetProperty(*strDirKey));
				strFolders += TEXT("\" ");
			}
			// if root, add source property and value
			MsiString strSourceDir, strParentDir = pDirectoryCursor->GetString(m_colDirParent);
			if(strParentDir.TextSize() == 0 || strParentDir.Compare(iscExact,strDirKey))
			{
				strSourceDir = pDirectoryCursor->GetString(m_colDirSubPath);
				strFolders += strSourceDir;
				strFolders += TEXT("=\"");
				strFolders += MsiString(GetProperty(*strSourceDir));
				strFolders += TEXT("\" ");
			}
		}
		
		if(strFolders.Compare(iscEnd,TEXT(",")))
			strFolders.Remove(iseEnd,1);
		strFolders.ReturnArg(*ppistrFolders);
	}

	Assert(m_piPropertyCursor);
	
	// use new cursor - m_piPropertyCursor used within FormatLog
	PMsiTable  pPropertyTable  = &m_piPropertyCursor->GetTable();
	PMsiCursor pPropertyCursor = pPropertyTable->CreateCursor(fFalse);
	PMsiTable  pStaticPropertyTable(0);
	PMsiCursor pStaticPropertyCursor(0);

	PMsiDatabase pDatabase = GetDatabase();
	AssertRecord(pDatabase->LoadTable(*MsiString(*sztblProperty), 0, *&pStaticPropertyTable));
	if (pStaticPropertyTable)
	{
		pStaticPropertyCursor = pStaticPropertyTable->CreateCursor(fFalse);
		pStaticPropertyCursor->SetFilter(iColumnBit(1));
	}

	MsiStringId rgPropertiesToSkip[g_cFeatureProperties + 2]; // feature properties + 2 database properties
	unsigned int cPropertiesToSkip = 2;
	rgPropertiesToSkip[0] = pDatabase->EncodeStringSz(IPROPNAME_DATABASE);
	rgPropertiesToSkip[1] = pDatabase->EncodeStringSz(IPROPNAME_ORIGINALDATABASE);

	if(fGrabbedFeatureProps) // if we got the feature properties above, skip them here
	{
		for(int i = 0; i < g_cFeatureProperties; i++)
		{
			rgPropertiesToSkip[cPropertiesToSkip] = pDatabase->EncodeStringSz(g_rgFeatures[i].szFeatureActionProperty);
			if (rgPropertiesToSkip[cPropertiesToSkip])
				cPropertiesToSkip++;
		}
	}

	MsiString strPropertyList;
	MsiString strLoggedPropertyList;
	MsiString strHiddenProperties;
	MsiString strStars(IPROPVALUE_HIDDEN_PROPERTY);
	PMsiTable pControlTable(0);
	if ( ppistrLoggedProperties )
	{
		strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		PMsiRecord pError(pDatabase->LoadTable(*MsiString(*sztblControl), 0, *&pControlTable));
	}
	while (pPropertyCursor->Next())
	{
		MsiStringId iProperty = pPropertyCursor->GetInteger(1);

		for (int i = 0; (i < cPropertiesToSkip) && (iProperty != rgPropertiesToSkip[i]); i++)
			;

		if (i != cPropertiesToSkip)
			continue;

		MsiString strProperty = pDatabase->DecodeString(iProperty);
		if(strProperty.TextSize() == 0)
		{
			AssertSz(0, TEXT("NULL property name in GetCurrentSelectState."));
			continue;
		}
		
		const ICHAR* pch = strProperty;

		while (*pch && !WIN::IsCharLower(*pch))
			pch++;

		if (!*pch)
		{
			MsiString strPropertyValue = pPropertyCursor->GetString(2);
			if (pStaticPropertyCursor)
			{
				pStaticPropertyCursor->PutString(1, *strProperty);
				if (pStaticPropertyCursor->Next())
				{
					MsiString strStaticValue = pStaticPropertyCursor->GetString(2);
					pStaticPropertyCursor->Reset();

					if (strStaticValue.Compare(iscExact, strPropertyValue)) // don't bother passing values that haven't changed
						continue;
				}
			}
			
			MsiString strEscapedPropertyValue;
			while (strPropertyValue.TextSize()) // Escape quotes. Change all instances of " to ""
			{
				MsiString strSegment = strPropertyValue.Extract(iseIncluding, '\"');
				strEscapedPropertyValue += strSegment;
				if (!strPropertyValue.Remove(iseIncluding, '\"'))
					break;
				strEscapedPropertyValue += TEXT("\"");
			}

			//!! handle embedding quotes
			strPropertyList += strProperty;
			strPropertyList += *TEXT("=\"");
			strPropertyList += strEscapedPropertyValue;
			strPropertyList += *TEXT("\" ");
			if ( ppistrLoggedProperties )
			{
				strLoggedPropertyList += strProperty;
				if ( IsPropertyHidden(strProperty, strHiddenProperties,
											 pControlTable, *pDatabase, NULL) )
				{
					strLoggedPropertyList += *TEXT("=");
					strLoggedPropertyList += strStars;
					strLoggedPropertyList += *TEXT(" ");
				}
				else
				{
					strLoggedPropertyList += *TEXT("=\"");
					strLoggedPropertyList += strEscapedPropertyValue;
					strLoggedPropertyList += *TEXT("\" ");
				}
			}
		}
	}

	// Now look for public properties that exists in the static property table but
	// not in the dynamic table. We'll have to pass those across as
	// PROPERTY="".

	if (pStaticPropertyCursor)
	{
		pStaticPropertyCursor->Reset();
		pStaticPropertyCursor->SetFilter(0);

		pPropertyCursor->Reset();
		pPropertyCursor->SetFilter(iColumnBit(1));

		while (pStaticPropertyCursor->Next())
		{
			MsiString strStaticProperty = pStaticPropertyCursor->GetString(1);
			
			const ICHAR* pch = strStaticProperty;

			while (*pch && !WIN::IsCharLower(*pch))
				pch++;

			if (!*pch)
			{
				pPropertyCursor->PutString(1, *strStaticProperty);
				if (!pPropertyCursor->Next())
				{
					strPropertyList += strStaticProperty;
					strPropertyList += *TEXT("=\"\" ");
					if ( ppistrLoggedProperties )
					{
						strLoggedPropertyList += strStaticProperty;
						if ( IsPropertyHidden(strStaticProperty, strHiddenProperties,
													 pControlTable, *pDatabase, NULL) )
						{
							strLoggedPropertyList += *TEXT("=");
							strLoggedPropertyList += strStars;
							strLoggedPropertyList += *TEXT(" ");
						}
						else
							strLoggedPropertyList += *TEXT("=\"\" ");
					}
				}
			}
		}
	}

	strPropertyList.ReturnArg(rpistrProperties);
	if ( ppistrLoggedProperties )
		strLoggedPropertyList.ReturnArg(*ppistrLoggedProperties);

	return 0;
}

bool CMsiEngine::WriteExecuteScriptRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	return WriteScriptRecord(m_pExecuteScript, ixoOpCode, riParams, false, *this);
}

bool CMsiEngine::WriteSaveScriptRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	return WriteScriptRecord(m_pSaveScript, ixoOpCode, riParams, false, *this);
}


iesEnum CMsiEngine::ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	iesEnum iesRet = iesSuccess;
	PMsiRecord pError(0);

	if(!m_fServerLocked)
	{
		pError = PostError(Imsg(idbgErrorWritingScriptRecord));
		return FatalError(*pError);
	}

	g_MessageContext.SuppressTimeout();  // keep from timing out for lengthy actions (such as an obscene number of reg keys)

	Assert(m_issSegment == issScriptGeneration);

	if (m_fMergingScriptWithParent)
	{
		if (!(m_fMode & iefOperations))  // if first script record, output new product info
		{
			SetMode(iefOperations, fTrue);
			PMsiRecord pProductInfo(0);
			if((iesRet = CreateProductInfoRec(*&pProductInfo)) != iesSuccess)
				return iesRet;
			if((iesRet = m_piParentEngine->ExecuteRecord(ixoProductInfo, *pProductInfo)) != iesSuccess)
				return iesRet;
		}
		return m_piParentEngine->ExecuteRecord(ixoOpCode, riParams); // merge with main script
	}

	if(ixoOpCode == ixoActionStart && m_fInExecuteRecord == fFalse)
	{
		// should never do this in normal course of operation
		// but the ability to pass ixoActionStart to ExecuteRecord is needed for automation testing
		m_pCachedActionStart = &m_riServices.CreateRecord(3);
		AssertNonZero(m_pCachedActionStart->SetMsiString(1,*MsiString(riParams.GetMsiString(1))));
		AssertNonZero(m_pCachedActionStart->SetMsiString(2,*MsiString(riParams.GetMsiString(2))));
		AssertNonZero(m_pCachedActionStart->SetMsiString(3,*MsiString(riParams.GetMsiString(3))));
		return iesSuccess;
	}

	if(m_fExecutedActionStart == fFalse && m_fInExecuteRecord == fFalse && m_pCachedActionStart)
	{
		// need to dispatch cached ActionStart operation before this one
		Assert(ixoOpCode != ixoActionStart);
		m_fInExecuteRecord = fTrue;   // call recursively
		iesRet = ExecuteRecord(::ixoActionStart, *m_pCachedActionStart);
		m_fInExecuteRecord = fFalse;
		m_fExecutedActionStart = fTrue;
		if(iesRet != iesSuccess)
			return iesRet;
	}

	if(!(GetMode() & iefOperations))
	{
		// haven't start spooling or executing script operations yet
		// execute initialization ops and initialize script if applicable

		// determine execution mode - default is ixmScript
		MsiString strExecuteMode(GetPropertyFromSz(IPROPNAME_EXECUTEMODE));
		if(strExecuteMode.TextSize())
		{
			switch(((const ICHAR*)strExecuteMode)[0] & 0xDF)
			{
			case TEXT('S'): m_ixmExecuteMode = ixmScript; break;
			case TEXT('N'): m_ixmExecuteMode = ixmNone;   break;
			};
		}

		// set script file name - this script file isn't used for execution, only for saving all operations
		if(m_pistrSaveScript)
			m_pistrSaveScript->Release();
		m_pistrSaveScript = &GetPropertyFromSz(IPROPNAME_SCRIPTFILE);

		SetMode(iefOperations, fTrue);
		m_iProgressTotal = 0;

		// setup ixoProductInfo record
		PMsiRecord pProductInfo(0);
		if((iesRet = CreateProductInfoRec(*&pProductInfo)) != iesSuccess)
			return iesRet;

		// setup ixoDialogInfo records
		PMsiRecord pDialogLangIdInfo = &m_riServices.CreateRecord(IxoDialogInfo::Args + 1);
		AssertNonZero(pDialogLangIdInfo->SetInteger(IxoDialogInfo::Type, icmtLangId));
		AssertNonZero(pDialogLangIdInfo->SetInteger(IxoDialogInfo::Argument, m_iLangId));
		AssertNonZero(pDialogLangIdInfo->SetInteger(IxoDialogInfo::Argument + 1, m_piDatabase->GetANSICodePage()));
		
		PMsiRecord pDialogCaptionInfo(0);
		if (m_rgpiMessageHeader[imsgDialogCaption])
		{
			pDialogCaptionInfo = &m_riServices.CreateRecord(IxoDialogInfo::Args);
			AssertNonZero(pDialogCaptionInfo->SetInteger(IxoDialogInfo::Type, icmtCaption));
			AssertNonZero(pDialogCaptionInfo->SetMsiString(IxoDialogInfo::Argument,
																		  *MsiString(FormatText(*m_rgpiMessageHeader[imsgDialogCaption]))));
		}

		// setup ixoRollbackInfo record
		PMsiRecord pRollbackInfo = &m_riServices.CreateRecord(IxoRollbackInfo::Args);
		MsiString strDescription, strTemplate;
		AssertNonZero(pRollbackInfo->SetString(IxoRollbackInfo::RollbackAction,TEXT("Rollback")));
		if(GetActionText(TEXT("Rollback"), *&strDescription, *&strTemplate))
		{
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::RollbackDescription,*strDescription));
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::RollbackTemplate,*strTemplate));
		}
		AssertNonZero(pRollbackInfo->SetString(IxoRollbackInfo::CleanupAction,TEXT("RollbackCleanup")));
		if(GetActionText(TEXT("RollbackCleanup"), *&strDescription, *&strTemplate))
		{
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::CleanupDescription,*strDescription));
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::CleanupTemplate,*strTemplate));
		}
		
		MsiString strIsPostAdmin = GetPropertyFromSz(IPROPNAME_ISADMINPACKAGE);
		istEnum istScriptType;
		if (m_fMode & iefAdvertise)
			istScriptType = istAdvertise;
		else if (strIsPostAdmin.TextSize())
			istScriptType = istPostAdminInstall;
		else if (m_fMode & iefAdmin)
			istScriptType = istAdminInstall;
		else
			istScriptType = istInstall;

		PMsiStream pStream(0);
		if(m_ixmExecuteMode == ixmScript)
		{
			// need to open execute script and dispatch initialization ops
			Assert(m_scmScriptMode != scmWriteScript);

			// open execute script
			AssertSz(m_pExecuteScript == 0,"Script still open");
			AssertSz(m_pistrExecuteScript == 0,"Execute script name not released");
			if(m_pistrExecuteScript)
			{
				m_pistrExecuteScript->Release();
				m_pistrExecuteScript = 0;
			}
			// generate name for execute script
			{
				CElevate elevate;
				CTempBuffer <ICHAR,1> rgchPath(MAX_PATH);

				HANDLE hTempFile = OpenSecuredTempFile(false, rgchPath);
				if (INVALID_HANDLE_VALUE == hTempFile)
				{
					pError = PostError(Imsg(imsgErrorCreatingTempFileName),GetLastError(),rgchPath);
					return FatalError(*pError);
				}
				else
					WIN::CloseHandle(hTempFile);

				// file still exists, but it is now secured.
				MsiString strTemp(static_cast<ICHAR*>(rgchPath));
				m_pistrExecuteScript = strTemp;
				m_pistrExecuteScript->AddRef();

				// create execute script
				pError = m_riServices.CreateFileStream(m_pistrExecuteScript->GetString(),
																	fTrue, *&pStream);
				if (pError)
				{
					Message(imtError, *pError);  //!! check imsg code, allow retry?
					return iesFailure;
				}
			}

			DWORD dwScriptAttributes = m_fRunScriptElevated ? isaElevate : isaEnum(0);

			// if the TS registry is being used (per-machine TS install), mark this fact
			// in the script headers to ensure rollback after a suspended install
			// correctly remaps the keys.
			if (IsTerminalServerInstalled() && MinimumPlatformWindows2000() && !(GetMode() & (iefAdmin | iefAdvertise)) &&
				MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
			{
				dwScriptAttributes |= isaUseTSRegistry;
			}

			m_pExecuteScript = new CScriptGenerate(*pStream, m_iLangId, GetCurrentDateTime(),
				istScriptType, static_cast<isaEnum>(dwScriptAttributes), m_riServices);
			if (!m_pExecuteScript)
				return iesFailure; //!! need bad command line msg

			AssertSz(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL ||
				m_wPackagePlatform == PROCESSOR_ARCHITECTURE_IA64  ||
				m_wPackagePlatform == PROCESSOR_ARCHITECTURE_AMD64,
					TEXT("Invalid platform!"));
			while (m_pExecuteScript->InitializeScript(m_wPackagePlatform) == false)
			{
				if (PostScriptWriteError(*this) == fFalse)
					return iesFailure;
			}
			// write init ops
			Assert(pProductInfo && pRollbackInfo); // should always be set
			if(pProductInfo && !WriteExecuteScriptRecord(ixoProductInfo, *pProductInfo))
				return iesFailure;
			if(pDialogLangIdInfo && !WriteExecuteScriptRecord(ixoDialogInfo, *pDialogLangIdInfo))
				return iesFailure;
			if(pDialogCaptionInfo && !WriteExecuteScriptRecord(ixoDialogInfo, *pDialogCaptionInfo))
				return iesFailure;
			if(pRollbackInfo &&!WriteExecuteScriptRecord(ixoRollbackInfo, *pRollbackInfo))
				return iesFailure;
		}

		if(m_pistrSaveScript && m_pistrSaveScript->TextSize())
		{
			// create saved script if it hasn't been opened yet
			if(m_pSaveScript == 0)
			{
				// haven't opened saved script yet
				// ensure that m_pistrSaveScript is full path to file
				Assert(m_scmScriptMode != scmWriteScript);
				CAPITempBuffer<ICHAR,MAX_PATH> rgchScriptPath;
				AssertNonZero(ExpandPath(m_pistrSaveScript->GetString(),rgchScriptPath));
				m_pistrSaveScript->SetString(rgchScriptPath, m_pistrSaveScript);
				AssertNonZero(SetProperty(*MsiString(*IPROPNAME_SCRIPTFILE), *m_pistrSaveScript));
				pError = m_riServices.CreateFileStream(m_pistrSaveScript->GetString(),
																	fTrue, *&pStream);
				if (pError)
				{
					Message(imtError, *pError);  //!! check imsg code, allow retry?
					return iesFailure;
				}
				
				// don't set isaElevate flag in saved scripts - they can only be run in-proc anyway, so
				// this is just by convention
				m_pSaveScript = new CScriptGenerate(*pStream, m_iLangId, GetCurrentDateTime(),
																istScriptType, isaEnum(0), m_riServices);
				if (!m_pSaveScript)
					return iesFailure; //!! need bad command line msg

				AssertSz(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL ||
					m_wPackagePlatform == PROCESSOR_ARCHITECTURE_IA64  ||
					m_wPackagePlatform == PROCESSOR_ARCHITECTURE_AMD64,
						TEXT("Invalid platform!"));
				while (m_pSaveScript->InitializeScript(m_wPackagePlatform) == false)
				{
					if (PostScriptWriteError(*this) == fFalse)
						return iesFailure;
				}
				Assert(pProductInfo && pRollbackInfo); // should always be set
				if(pProductInfo && !WriteSaveScriptRecord(ixoProductInfo, *pProductInfo))
					return iesFailure;
				if(pDialogLangIdInfo && !WriteSaveScriptRecord(ixoDialogInfo, *pDialogLangIdInfo))
					return iesFailure;
				if(pDialogCaptionInfo && !WriteSaveScriptRecord(ixoDialogInfo, *pDialogCaptionInfo))
					return iesFailure;
				if(pRollbackInfo && !WriteSaveScriptRecord(ixoRollbackInfo, *pRollbackInfo))
					return iesFailure;
			}
		}
	}

	// execute or spool operation - may need to do both if direct mode and saving a script
	if(m_pExecuteScript || m_pSaveScript)
	{
		if(m_scmScriptMode != scmWriteScript)
		{
			// need to start up GenerateScript action
			m_scmScriptMode = scmWriteScript;
			PMsiRecord pGenerateScriptRec = &m_riServices.CreateRecord(3);
			MsiString strDescription, strTemplate;
			AssertNonZero(pGenerateScriptRec->SetString(1, TEXT("GenerateScript")));
			if(GetActionText(TEXT("GenerateScript"), *&strDescription, *&strTemplate))
			{
				AssertNonZero(pGenerateScriptRec->SetMsiString(2, *strDescription));
				AssertNonZero(pGenerateScriptRec->SetMsiString(3, *strTemplate));
			}
			m_fInExecuteRecord = fTrue;
			if(Message(imtActionStart, *pGenerateScriptRec) == imsCancel)
				return iesUserExit;
			m_fInExecuteRecord = fFalse;
			m_fDispatchedActionStart = fFalse; // action needs to re-send action start with a progress message
		}

		if (ixoOpCode == ixoProgressTotal)
		{
			int iTotalEvents = riParams.GetInteger(IxoProgressTotal::Total);
			int iByteEquivalent = riParams.GetInteger(IxoProgressTotal::ByteEquivalent);
			m_iProgressTotal += iTotalEvents * iByteEquivalent;
		}

		if(ixoOpCode == ixoActionStart)
		{
			// log ActionStart as ActionData for GenerateScript action
			PMsiRecord pActionData = &m_riServices.CreateRecord(1);
			MsiString strDescription = riParams.GetMsiString(2);
			if(strDescription.TextSize())
				AssertNonZero(pActionData->SetMsiString(1, *strDescription));
			else
				AssertNonZero(pActionData->SetMsiString(1, *MsiString(riParams.GetMsiString(1))));
			m_fInExecuteRecord = fTrue;
			if (Message(imtActionData, *pActionData) == imsCancel)
				return iesUserExit;
			m_fInExecuteRecord = fFalse;
		}

		if (m_pScriptProgressRec)
		{
			using namespace ProgressData;
			AssertNonZero(m_pScriptProgressRec->SetInteger(imdSubclass, iscProgressReport));
			AssertNonZero(m_pScriptProgressRec->SetInteger(imdIncrement, 1));
			if(Message(imtProgress, *m_pScriptProgressRec) == imsCancel)
				return iesUserExit;
		}

		if(m_pExecuteScript && !WriteExecuteScriptRecord(ixoOpCode, riParams))
			return iesFailure;
		if(m_pSaveScript && !WriteSaveScriptRecord(ixoOpCode, riParams))
			return iesFailure;
	}

	return iesSuccess;
}


void CMsiEngine::ReportToEventLog(WORD wEventType, int iEventLogTemplate, IMsiRecord& riRecord, UINT uFakeError)  // uFakeError should go away once bug # 463473 gets fixed.
{
	MsiString strMessage = riRecord.FormatText(fTrue);
	PMsiRecord pLogRecord = &CreateRecord(3);
	AssertNonZero(pLogRecord->SetMsiString(0, *MsiString(GetErrorTableString(imsgEventLogTemplate))));
	AssertNonZero(pLogRecord->SetMsiString(2, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME))));
	AssertNonZero(pLogRecord->SetMsiString(3, *strMessage));
	MsiString strLog = pLogRecord->FormatText(fFalse);
	MsiString strTemp;
	FormatEventLogData(MsiString(GetProductKey()), *&strTemp, uFakeError);  // this should go away once bug # 463473 gets fixed.
	CConvertString sTemp((const ICHAR*)strTemp);
	const char* pszTemp = sTemp;
	DEBUGMSGED(wEventType, iEventLogTemplate, strLog,
				  IStrLen(sTemp), (LPVOID)pszTemp);
}


iesEnum CMsiEngine::FatalError(IMsiRecord& riRecord)
{
	if (riRecord.GetInteger(1) == imsgUser)
	{
		return iesUserExit;
	}
	else
	{
		Message(imtEnum(imtError | imtSendToEventLog), riRecord); // should only be called with no user options
		m_fResultEventLogged = fTrue;
		return iesFailure;            // record released by caller
	}
}


void CMsiEngine::SetMode(int fMask, Bool fMode)
{
	if (fMode)
		m_fMode |= fMask;
	else
		m_fMode &= ~fMask;
}

int CMsiEngine::GetMode()
{
	return m_fMode;
}

const IMsiString& CMsiEngine::FormatText(const IMsiString& riTextString)
{
	return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallback,(IUnknown*)(IMsiEngine*)this);
}

// following fns are called with special callback that looks at the requested state for a component
// if the action state is null
const IMsiString& FormatTextEx(const IMsiString& riTextString, IMsiEngine& riEngine, bool fUseRequestedComponentState)
{
	if(fUseRequestedComponentState)
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallbackEx,(IUnknown*)&riEngine);
	else
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallback,(IUnknown*)&riEngine);
}

const IMsiString& FormatTextSFN(const IMsiString& riTextString, IMsiEngine& riEngine, int rgiSFNPos[][2], int& riSFNPos, bool fUseRequestedComponentState)
{
	riSFNPos = 0;
	if(fUseRequestedComponentState)
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallbackEx,(IUnknown*)&riEngine, rgiSFNPos, &riSFNPos);
	else
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallback,(IUnknown*)&riEngine, rgiSFNPos, &riSFNPos);

}


int CMsiEngine::FormatTextCallback(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&rgchOut,
																 Bool& fPropMissing,
																 Bool& fPropUnresolved,
																 Bool& fSFN,
																 IUnknown* piContext)
{
	return FormatTextCallbackCore(pch, cch, rgchOut, fPropMissing, fPropUnresolved, fSFN, piContext, false);
}

int CMsiEngine::FormatTextCallbackEx(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&rgchOut,
																 Bool& fPropMissing,
																 Bool& fPropUnresolved,
																 Bool& fSFN,
																 IUnknown* piContext)
{
	return FormatTextCallbackCore(pch, cch, rgchOut, fPropMissing, fPropUnresolved, fSFN, piContext, true);
}

// Queries used in FormatTextCallbackCore
static const ICHAR* szSqlDirectoryQuery =       TEXT("SELECT `Directory_`, `Action`, `ActionRequest` FROM ")
											TEXT("`Component` WHERE ")
											TEXT("`Component` = ?");

int CMsiEngine::FormatTextCallbackCore(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&rgchOut,
																 Bool& fPropMissing,
																 Bool& fPropUnresolved,
																 Bool& fSFN,
																 IUnknown* piContext,
																 bool fUseRequestedComponentState)
{
	CTempBuffer<ICHAR, 20> rgchString;
	// 1 for the null
	rgchString.SetSize(cch+1);
	if ( ! (ICHAR *) rgchString )
		return 0;
	memcpy(rgchString, pch, cch * sizeof(ICHAR));
	rgchString[cch] = 0;
	rgchOut[0] = 0;
	int iField = GetIntegerValue(rgchString, 0);  // check if integer value
	if (iField >= 0)  // positive integer, leave for record formatting
	{
		rgchOut.SetSize(cch + 3);
		if ( ! (ICHAR *) rgchOut )
			return 0;
		memcpy(&rgchOut[1], &rgchString[0], cch * sizeof(ICHAR));
		rgchOut[0] = TEXT('[');
		rgchOut[cch + 1] = TEXT(']');
		rgchOut[cch + 2] = 0;
		fPropUnresolved = fTrue;
		return cch + 2;
	}
	CMsiEngine* piEngine = (CMsiEngine*)(IMsiEngine*)piContext;

	MsiString istrOut((ICHAR *)rgchString);
	fPropUnresolved = fFalse;
	ICHAR chFirst = *(const ICHAR*)istrOut;
	if (chFirst == TEXT('\\')) // we have an escaped character
	{
		if (istrOut.TextSize() > 1)
		{
			istrOut.Remove(iseFirst, 1);
			istrOut.Remove(iseLast, istrOut.CharacterCount() - 1);
		}
		else
		{
			return 0;
		}
	}
	else if (chFirst == ichFileTablePrefix || chFirst == ichFileTablePrefixSFN) // we have File table key
	{
		MsiString strFile = istrOut.Extract(iseLast,istrOut.CharacterCount()-1);
		PMsiRecord pError(0);

		if ((!piEngine->m_fSourceResolved && piEngine->m_fSourceResolutionAttempted) ||
			(pError = piEngine->GetFileInstalledLocation(*strFile,*&istrOut, fUseRequestedComponentState, &(piEngine->m_fSourceResolutionAttempted))))
		{
			fPropMissing = fTrue;
			return 0;
		}

		if(chFirst == ichFileTablePrefixSFN)
			fSFN = fTrue;
	}
	else if (chFirst == ichComponentPath) // we have Component table key
	{
		PMsiServices pServices = piEngine->GetServices();
		PMsiDatabase pDatabase = piEngine->GetDatabase();
		
		PMsiDirectoryManager pDirectoryManager(*(IMsiEngine*)piEngine, IID_IMsiDirectoryManager);
		istrOut.Remove(iseFirst, 1);
		ICHAR* Buffer = 0; // avoid warning

		PMsiView piView(0);
		PMsiRecord pError(pDatabase->OpenView(szSqlDirectoryQuery, ivcFetch, *&piView));
		Assert(pError == 0);
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}
		PMsiRecord piRec (&pServices->CreateRecord(1));
		piRec->SetMsiString(1, *istrOut);
		pError = piView->Execute(piRec);
		Assert(pError == 0);
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}
		piRec = piView->Fetch();
		if(piRec == 0)
		{
			fPropMissing = fTrue;
			return 0;
		}
		enum iftFileInfo{
			iftDirectory=1,
			iftAction,
			iftActionRequest,
		};
		PMsiPath piPath(0);
		int iAction = piRec->GetInteger(iftAction);
		if(iAction == iMsiNullInteger && fUseRequestedComponentState)
			iAction = piRec->GetInteger(iftActionRequest);
		if((iAction == iisAbsent)||(iAction == iMsiNullInteger))
		{
			fPropMissing = fTrue;
			return 0;
		}
		else if(iAction == iisSource)
		{
			if (piEngine->m_fSourceResolved || !piEngine->m_fSourceResolutionAttempted)
			{
				pError = pDirectoryManager->GetSourcePath(*MsiString(piRec->GetMsiString(iftDirectory)),
										*&piPath);

				piEngine->m_fSourceResolutionAttempted = true;
			}
			else
			{
				fPropMissing = fTrue;
				return 0;
			}
		}
		else
		{
			pError = pDirectoryManager->GetTargetPath(*MsiString(piRec->GetMsiString(iftDirectory)),
									*&piPath);
		}
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}

		istrOut = piPath->GetPath();
		//?? do we drop the last "\"
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}
	}
	else if ((chFirst == ichNullChar) && (cch == 1))// we have null character
	{
		istrOut = MsiString(MsiChar(0));
	}
	else // we have to evaluate a property
	{
		istrOut = piEngine->GetProperty(*istrOut);
		if (istrOut.TextSize() == 0) // property is undefined
			fPropMissing = fTrue;
	}

	rgchOut.SetSize((cch = istrOut.TextSize()) + 1);
	if ( ! (ICHAR *) rgchOut )
		return 0;
	memcpy(rgchOut, (const ICHAR *)istrOut, (cch + 1) * sizeof(ICHAR));
	return cch;
}

IMsiRecord* CMsiEngine::OpenView(const ICHAR* szSql, ivcEnum ivcIntent,
												IMsiView*& rpiView)
{
	if(!m_piDatabase)
		return PostError(Imsg(idbgEngineNotInitialized));
	return m_piDatabase->OpenView(szSql, ivcIntent, rpiView);
}

//!! This function is only used in one place -- to determine the SOURCEDIR
//!! Resolving the SOURCEDIR relative to the database path is no longer
//!! the right thing to do. We'll be OK for now because the SOURCEDIR
//!! is fully specified by Engine::DoInitialize. In Beta 2, however,
//!! when the SourceList spec is implemented we should probably eliminate
//!! this function.
Bool CMsiEngine::ResolveFolderProperty(const IMsiString& riPropertyString)
{
	MsiString istrPropValue = GetProperty(riPropertyString);
	if(PathType(istrPropValue) == iptFull)
		return fTrue;
	MsiString istrPath = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	Assert(PathType(istrPath) == iptFull);
	
	PMsiPath pPath(0);
	MsiString strFileName;
	AssertRecord(m_riServices.CreateFilePath(istrPath, *&pPath, *&strFileName));

	istrPath.Remove(iseLast,strFileName.CharacterCount());
	istrPath += istrPropValue;

	SetProperty(riPropertyString, *istrPath);
	return (istrPath.TextSize() == 0) ? fFalse : fTrue;
}

//____________________________________________________________________________
//
// Condition evaluator implementation
//____________________________________________________________________________

// table for parsing identifiers

const int rgiIdentifierValidChar[8] =
{
	0x00000000,
	0x03ff4000, // digits, period
	0x87fffffe, // upper case letters, underscore
	0x07fffffe, // lower case letters
	0x00000000, 0x00000000, 0x00000000, 0x00000000  // extended chars
};

inline int IsValidIdentifierChar(ICHAR ch) // return non-zero if valid
{
  return (rgiIdentifierValidChar[(char)ch/32] & (1 << ch % 32));
}

const int ivchNumber     = 1;
const int ivchProperty   = 4;  // can't begin with a digit
const int ivchComponent  = 8;
const int ivchFeature    = 16;
const int ivchEnvir      = 32;
const int ivchOperator   = 0;
const int ivchAnyIdentifier = ivchProperty + ivchComponent + ivchFeature + ivchEnvir;

enum tokEnum  // token parsed by Lex, operators from low to high precedence
{
	tokEos,         // end of string
	tokRightPar, // right parenthesis
	tokImp,
	tokEqv,
	tokXor,
	tokOr,
	tokAnd,
	tokNot,  // unaray, between logical and comparison ops
	tokEQ, tokNE, tokGT, tokLT, tokGE, tokLE, tokLeft, tokMid, tokRight,
	tokValue,
	tokLeftPar,  // left parenthesis
	tokError,
};

struct CMsiParser   // non-recursive Lex state structure
{
	CMsiParser(IMsiEngine& riEngine, const ICHAR* szExpression);
  ~CMsiParser();
	tokEnum Lex();
	void UnLex();   // cache current token for next Lex call
	iecEnum Evaluate(tokEnum tokPrecedence);  // recursive evaluator
 private: // result of Lex()
	tokEnum   m_tok;       // current token type
	iscEnum   m_iscMode;   // string compare mode flags
	MsiString m_istrToken; // string value of token if tok==tokValue
	int       m_iToken;    // integer value if obtainable, else iMsiNullInteger
 private: // to Lex
	int           m_iParenthesisLevel;
	const ICHAR*  m_pchInput;
	IMsiEngine&   m_riEngine;
	Bool          m_fAhead;
 private: // eliminate warning
	void operator =(const CMsiParser&){}
};
inline CMsiParser::CMsiParser(IMsiEngine& riEngine, const ICHAR* szExpression)
	: m_pchInput(szExpression), m_iParenthesisLevel(0), m_fAhead(fFalse),
	  m_tok(tokError), m_riEngine(riEngine) {}
inline CMsiParser::~CMsiParser() {}
inline void CMsiParser::UnLex() { Assert(m_fAhead==fFalse); m_fAhead = fTrue; }

iecEnum CMsiEngine::EvaluateCondition(const ICHAR* szCondition)

{
	if (szCondition == 0 || *szCondition == 0)
		return iecNone;
	CMsiParser Parser(*this, szCondition);
	iecEnum iecStat = Parser.Evaluate(tokEos);
	return iecStat;
}

// Lex next token for input stream
// sets m_tok to token type, and returns that value

tokEnum CMsiParser::Lex()
{
	if (m_fAhead || m_tok == tokEos)
	{
		m_fAhead = fFalse;
		return m_tok;
	}
	ICHAR ch;   // skip white space
	while ((ch = *m_pchInput) == TEXT(' ') || ch == TEXT('\t'))
		m_pchInput++;
	if (ch == 0)  // end of expression
		return (m_tok = tokEos);

	if (ch == TEXT('('))   // start of parenthesized expression
	{
		++m_pchInput;
		m_iParenthesisLevel++;
		return (m_tok = tokLeftPar);
	}
	if (ch == TEXT(')'))   // end of parenthesized expression
	{
		++m_pchInput;
		m_tok = tokRightPar;
		if (m_iParenthesisLevel-- == 0)
			m_tok = tokError;
		return m_tok;
	}
	if (ch == TEXT('"'))  // text literal
	{
		const ICHAR* pch = ++m_pchInput;
		Bool fDBCS = fFalse;
		while ((ch = *m_pchInput) != TEXT('"'))
		{
			if (ch == 0)
				return (m_tok = tokError);
#ifdef UNICODE
			m_pchInput++;
#else // !UNICODE
			const ICHAR* pchTemp = m_pchInput;
			m_pchInput = INextChar(m_pchInput);
			if (m_pchInput == pchTemp + 2)
				fDBCS = fTrue;
#endif // UNICODE
		}
		int cch = m_pchInput++ - pch;
		memcpy(m_istrToken.AllocateString(cch, fDBCS), pch, cch * sizeof(ICHAR));
		m_iToken = iMsiNullInteger; // prevent compare as an integer
	}
	else if (ch == TEXT('-') || ch >= TEXT('0') && ch <= TEXT('9'))  // integer
	{
		m_iToken = ch - TEXT('0');
		int chFirst = ch;  // save 1st char in case minus sign
		if (ch == TEXT('-'))
			m_iToken = iMsiNullInteger; // check for lone minus sign

		while ((ch = *(++m_pchInput)) >= TEXT('0') && ch <= TEXT('9'))
			m_iToken = m_iToken * 10 + ch - TEXT('0');
		if (m_iToken < 0)  // integer overflow or '-' witn no digits
			return (m_tok = tokError);
		if (chFirst == TEXT('-'))
			m_iToken = -m_iToken;
		m_istrToken = (const ICHAR*)0;
	}
	else if (ENG::IsValidIdentifierChar(ch) || ch == ichEnvirPrefix)
	{
		const ICHAR* pch = m_pchInput;
		do
			m_pchInput++;
		while (ENG::IsValidIdentifierChar(*m_pchInput));
		int cch = m_pchInput - pch;
		if (cch <= 3)  // check for text operators
		{
			switch((pch[0] | pch[1]<<8 | (cch==3 ? pch[2]<<16 : 0)) & 0xDFDFDF)
			{
			case 'O' | 'R'<<8:           return (m_tok = tokOr);
			case 'A' | 'N'<<8 | 'D'<<16: return (m_tok = tokAnd);
			case 'N' | 'O'<<8 | 'T'<<16: return (m_tok = tokNot);
			case 'X' | 'O'<<8 | 'R'<<16: return (m_tok = tokXor);
			case 'E' | 'Q'<<8 | 'V'<<16: return (m_tok = tokEqv);
			case 'I' | 'M'<<8 | 'P'<<16: return (m_tok = tokImp);
			};
		}
		memcpy(m_istrToken.AllocateString(cch, fFalse), pch, cch * sizeof(ICHAR));
		m_istrToken = m_riEngine.GetProperty(*m_istrToken);
		m_iToken = m_istrToken;
	}
	else if (ch == ichComponentAction || ch == ichComponentState
			|| ch == ichFeatureAction || ch == ichFeatureState)
	{
		m_iToken = iMsiNullInteger;
		const ICHAR* pch = ++m_pchInput;
		while (ENG::IsValidIdentifierChar(*m_pchInput))
			m_pchInput++;
		int cch = m_pchInput - pch;
		PMsiSelectionManager piSelMgr(0);
		m_riEngine.QueryInterface(IID_IMsiSelectionManager, (void**)&piSelMgr);
		PMsiTable pTable = (ch == ichComponentState || ch == ichComponentAction)
								? piSelMgr->GetComponentTable()
								: piSelMgr->GetFeatureTable();
		if (pTable != 0)   // component/feature table open
		{
			PMsiCursor pCursor = pTable->CreateCursor(fFalse);
			memcpy(m_istrToken.AllocateString(cch, fFalse), pch, cch * sizeof(ICHAR));
			pCursor->SetFilter(1);
			pCursor->PutString(1, *m_istrToken);
			PMsiDatabase pDatabase = m_riEngine.GetDatabase();
			const ICHAR* szColumn = NULL;
			switch(ch)
			{
			case ichComponentState:  szColumn = sztblComponent_colInstalled;     break;
			case ichComponentAction: szColumn = sztblComponent_colAction;        break;
			case ichFeatureState:    szColumn = sztblFeature_colInstalled;       break;
			case ichFeatureAction:   szColumn = sztblFeature_colAction;          break;
			}
			int iCol = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szColumn));
			if (pCursor->Next() != 0)
			{
				//!! FIX IF/WHEN iisEnum fixed to track INSTALLSTATE -> m_iToken = pCursor->GetInteger(iCol);
				m_iToken = MapInternalInstallState(iisEnum(pCursor->GetInteger(iCol)));
			}
		}
		m_istrToken = (const ICHAR*)0;
	}
	else // check for operators
	{
		ICHAR ch1 = *m_pchInput++;
		if (ch1 == '~')  // prefix for string operators
		{
			m_iscMode = iscExactI;
			ch1 = *m_pchInput++;
		}
		else
			m_iscMode = iscExact;

		if (ch1 == '=')
			return (m_tok = tokEQ);

		ICHAR ch2 = *m_pchInput;
		if (ch1 == '<')
		{
			if (ch2 == '=')
			{
				m_tok = tokLE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_tok = tokNE;
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_tok = tokLeft;
				m_iscMode = (iscEnum)(m_iscMode | iscStart);
				m_pchInput++;
			}
			else
				m_tok = tokLT;
		}
		else if (ch1 == '>')
		{
			if (ch2 == '=')
			{
				m_tok = tokGE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_tok = tokRight;
				m_iscMode = (iscEnum)(m_iscMode | iscEnd);
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_tok = tokMid;
				m_iscMode = (iscEnum)(m_iscMode | iscWithin);
				m_pchInput++;
			}
			else
				m_tok = tokGT;
		}
		else
			m_tok = tokError;

		return m_tok;
	}
	return (m_tok = tokValue);
}

// evaluate expression up to operator of lower precedence

iecEnum CMsiParser::Evaluate(tokEnum tokPrecedence)
{
	iecEnum iecStat = iecTrue;
	if (Lex() == tokEos || m_tok == tokRightPar)
	{
		UnLex();  // put back ')' in case of "()"
		return iecNone;
	}
	if (m_tok == tokNot) // only unary op valid here
	{
		switch(Evaluate(m_tok))
		{
		case iecTrue:  iecStat = iecFalse; break;
		case iecFalse: break;
		default:       return iecError;
		};
	}
	else if (m_tok == tokLeftPar)
	{
		iecStat = Evaluate(tokRightPar);
		if (Lex() != tokRightPar) // parse off right parenthesis
			return iecError;
		if (iecStat == iecError || iecStat == iecNone)
			return iecStat;
	}
	else
	{
		if (m_tok != tokValue)
			return iecError;
		
		if (Lex() >= tokValue)  // get next operator (or end)
			return iecError;

		if (m_tok <= tokNot)  // logical op or end
		{
			UnLex();   // tokNot is not allowed, caught below
			if (m_istrToken.TextSize() == 0
			&& (m_iToken == iMsiNullInteger || m_iToken == 0))
				iecStat = iecFalse;
		}
		else // comparison op
		{
			MsiString istrLeft = m_istrToken;
			int iLeft = m_iToken;
			tokEnum tok = m_tok;
			iscEnum isc = m_iscMode;
			if (Lex() != tokValue)  // get right operand
				return iecError;
			int iRight = m_iToken;
			if (m_iToken == iMsiNullInteger || iLeft == iMsiNullInteger)
			{  // not an integer to integer compare
				if (iRight != iMsiNullInteger && m_istrToken.TextSize() == 0
				  || iLeft != iMsiNullInteger && istrLeft.TextSize() == 0)
				{   // integer to string, all tests false except <>
					if (tok != tokNE)
						iecStat = iecFalse;
				}
				else  // string to string compare
				{
					iRight = 0;
					if (isc == iscExact)
					{
						iLeft = IStrComp(istrLeft, m_istrToken);
					}
					else if (isc == iscExactI)
					{
						iLeft = IStrCompI(istrLeft, m_istrToken);
					}
					else
					{
						iLeft = istrLeft.Compare(isc, m_istrToken);
						tok = tokNE;
					}
				}
			}
			switch (tok)
			{
			case tokEQ:   if   (iLeft != iRight)  iecStat = iecFalse; break;
			case tokNE:   if   (iLeft == iRight)  iecStat = iecFalse; break;
			case tokGT:   if   (iLeft <= iRight)  iecStat = iecFalse; break;
			case tokLT:   if   (iLeft >= iRight)  iecStat = iecFalse; break;
			case tokGE:   if   (iLeft <  iRight)  iecStat = iecFalse; break;
			case tokLE:   if   (iLeft >  iRight)  iecStat = iecFalse; break;
			case tokMid:  if (!(iLeft &  iRight)) iecStat = iecFalse; break;
			case tokLeft: if  ((iLeft >> 16)    != iRight) iecStat = iecFalse; break;
			case tokRight:if  ((iLeft & 0xFFFF) != iRight) iecStat = iecFalse; break;
			default: Assert(0);
			};
		}
	}
	for(;;)
	{
		tokEnum tok = Lex();
		if (tok >= tokNot)  // disallow NOT without op, comparison of terms
			return iecError;

		if (tok <= tokPrecedence)  // stop at logical ops of <= precedence
		{
			UnLex();         // put back for next caller
			return iecStat;  // return what we have so far
		}
		iecEnum iecRight = Evaluate(tok);
		if (iecRight == iecNone || iecRight == iecError)
			return iecError;
		switch(tok)
		{
		case tokAnd: iecStat = iecEnum(iecStat & iecRight); break;
		case tokOr:  iecStat = iecEnum(iecStat | iecRight); break;
		case tokXor: iecStat = iecEnum(iecStat ^ iecRight); break;
		case tokEqv: iecStat = iecEnum(iecStat ^ 1 ^ iecRight); break;
		case tokImp: iecStat = iecEnum(iecStat ^ 1 | iecRight); break;
		default: Assert(0);
		};
	}
}

//____________________________________________________________________________
//
// Property handling implementation
//____________________________________________________________________________

Bool CMsiEngine::SetProperty(const IMsiString& riProperty, const IMsiString& riData)
{
	if (riProperty.GetString()[0] == ichEnvirPrefix) // environment variable
		return WIN::SetEnvironmentVariable(riProperty.GetString()+1, riData.GetString())
									? fTrue : fFalse;
	if (!m_piPropertyCursor)
		return fFalse;
	Bool fStat;
	m_piPropertyCursor->PutString(1, riProperty);
	if (riData.TextSize() == 0)
	{
		if (m_piPropertyCursor->Next())
			fStat = m_piPropertyCursor->Delete();
		else
			fStat = fTrue;
	}
	else
	{
		m_piPropertyCursor->PutString(2, riData);
		fStat = m_piPropertyCursor->Assign();  // either updates or inserts
	}
	m_piPropertyCursor->Reset();
	return fStat;
}

Bool CMsiEngine::SetPropertyInt(const IMsiString& riPropertyString, int iData)
{
	ICHAR buf[12];
	StringCchPrintf(buf, sizeof(buf)/sizeof(ICHAR), TEXT("%i"),iData);
	return SetProperty(riPropertyString, *MsiString(buf));
}

const IMsiString& CMsiEngine::GetEnvironmentVariable(const ICHAR* szEnvVar)
{
	const IMsiString* pistr = &g_MsiStringNull;
	CTempBuffer<ICHAR, MAX_PATH+1> rgchEnvirBuffer;
	rgchEnvirBuffer[0] = 0;  // in case variable doesn't exist, needed?
	int cch = WIN::GetEnvironmentVariable(szEnvVar, rgchEnvirBuffer, rgchEnvirBuffer.GetSize());

	// if the buffer was not large enough, resize and retry
	if (cch > rgchEnvirBuffer.GetSize())
	{
		rgchEnvirBuffer.SetSize(cch);
		cch = WIN::GetEnvironmentVariable(szEnvVar, rgchEnvirBuffer, rgchEnvirBuffer.GetSize());
	}
	if (!cch)
		return *pistr;

	rgchEnvirBuffer[rgchEnvirBuffer.GetSize()-1] = 0;  // terminate in case overflow
#ifdef _WIN64
	if ( g_Win64DualFolders.ShouldCheckFolders() )
	{
		// SwapFolder does not handle variables longer than MAX_PATH
		if (IStrLen(rgchEnvirBuffer) < MAX_PATH)
		{
			rgchEnvirBuffer.Resize(MAX_PATH+1);
			ieSwappedFolder iRes;
			CTempBuffer<ICHAR,1> rgchSubstitutePath(MAX_PATH+1);
			iRes = g_Win64DualFolders.SwapFolder(ie64to32,
															 rgchEnvirBuffer,
															 rgchSubstitutePath,
															 rgchSubstitutePath.GetSize());
			if ( iRes == iesrSwapped )
			{
				if ( IStrLen(rgchSubstitutePath)+1 <= rgchEnvirBuffer.GetSize() )
				{
					if (FAILED(StringCchCopy(rgchEnvirBuffer, rgchEnvirBuffer.GetSize(),
									  rgchSubstitutePath)))
					{
						Assert(0);
					}
				}
				else
				{
					Assert(0);
				}
			}
			else
				Assert(iRes != iesrError && iRes != iesrNotInitialized);
		}
	}
#endif // _WIN64

	pistr->SetString(rgchEnvirBuffer, pistr);
	return *pistr;
}

const IMsiString& CMsiEngine::GetProperty(const IMsiString& riProperty)
{
	if (riProperty.GetString()[0] == ichEnvirPrefix) // environment variable
	{
		return GetEnvironmentVariable(riProperty.GetString()+1);
	}
	if (!m_piPropertyCursor)   // should never happen
	{
		Assert(0);
		return g_MsiStringNull;
	}
	m_piPropertyCursor->PutString(1, riProperty);
	if(m_piPropertyCursor->Next())  // cursor reset if fails to find
	{
		const IMsiString& riStr = m_piPropertyCursor->GetString(2);
		m_piPropertyCursor->Reset();
		return riStr;
	}
	return g_MsiStringNull;
}

const IMsiString& CMsiEngine::GetPropertyFromSz(const ICHAR* szProperty)
{
	if (szProperty[0] == ichEnvirPrefix) // environment variable
	{
		return GetEnvironmentVariable(&szProperty[1]);
	}
	if (!m_piPropertyCursor)   // should never happen
	{
		Assert(0);
		return g_MsiStringNull;
	}
	MsiStringId idProp;
	
	if (m_piDatabase == 0)
	{
		PMsiTable piTable(&m_piPropertyCursor->GetTable());
		PMsiDatabase piDatabase(&piTable->GetDatabase());
		idProp = piDatabase->EncodeStringSz(szProperty);
	}
	else
		idProp = m_piDatabase->EncodeStringSz(szProperty);
	if (idProp == 0)
		return g_MsiStringNull;
	m_piPropertyCursor->PutInteger(1, idProp);
	if(m_piPropertyCursor->Next())  // cursor reset if fails to find
	{
		const IMsiString& riStr = m_piPropertyCursor->GetString(2);
		m_piPropertyCursor->Reset();
		return riStr;
	}
	return g_MsiStringNull;
	
}

int CMsiEngine::GetPropertyInt(const IMsiString& riProperty)
{
	const IMsiString& ristr = CMsiEngine::GetProperty(riProperty);
	int i = ristr.GetIntegerValue();
	ristr.Release();
	return i;
}

bool CMsiEngine::SafeSetProperty(const IMsiString& ristrProperty, const IMsiString& ristrData)
{
	if (ristrProperty.GetString()[0] == ichEnvirPrefix) // environment variable
		return CMsiEngine::SetProperty(ristrProperty, ristrData) ? true : false;
	Assert(m_piPropertyCursor);
	PMsiCursor pCursor = PMsiTable(&m_piPropertyCursor->GetTable())->CreateCursor(fFalse);
	pCursor->PutString(1, ristrProperty);
	if (ristrData.TextSize() == 0)
	{
		pCursor->SetFilter(1);
		return pCursor->Next() ? (pCursor->Delete() == fTrue) : true;
	}
	else
	{
		pCursor->PutString(2, ristrData);
		return pCursor->Assign() == fTrue;  // either updates or inserts
	}
}

const IMsiString& CMsiEngine::SafeGetProperty(const IMsiString& ristrProperty)
{
	if (ristrProperty.GetString()[0] == ichEnvirPrefix) // environment variable
		return CMsiEngine::GetProperty(ristrProperty);
	Assert(m_piPropertyCursor);
	PMsiCursor pCursor = PMsiTable(&m_piPropertyCursor->GetTable())->CreateCursor(fFalse);
	pCursor->SetFilter(1);
	pCursor->PutString(1, ristrProperty);
	if (pCursor->Next())
		return pCursor->GetString(2);
	else
		return g_MsiStringNull;
//!! This doesn't seem to work... malcolmh 2/5/98       return pCursor->Next() ? pCursor->GetString(2) : g_MsiStringNull;
}

//____________________________________________________________________________
//
// Internal engine utility functions
//____________________________________________________________________________

Bool CMsiEngine::GetFeatureInfo(const IMsiString& riFeature, const IMsiString*& rpiTitle,
										  const IMsiString*& rpiHelp, int& riAttributes)
{
	PMsiRecord pError(0);
	if (!m_piFeatureCursor)
	{
		if (pError = LoadFeatureTable())
			return fFalse;

		Assert(m_piFeatureCursor);
	}

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	m_piFeatureCursor->PutString(m_colFeatureKey, riFeature);
	if (m_piFeatureCursor->Next())
	{
		rpiTitle = &m_piFeatureCursor->GetString(m_colFeatureTitle);
		rpiHelp  = &m_piFeatureCursor->GetString(m_colFeatureDescription);

		// Try the runtime attributes column first.  If it hasn't been initialized,
		// try the authored attributes column.  If that fails as well, default to
		// FavorLocal.
		int iAttributesInternal = m_piFeatureCursor->GetInteger(m_colFeatureAttributes);
		if(iAttributesInternal == iMsiNullInteger)
		{
			iAttributesInternal = m_piFeatureCursor->GetInteger(m_colFeatureAuthoredAttributes);
			if (iAttributesInternal == iMsiNullInteger)
				iAttributesInternal = ifeaFavorLocal;
		}
		switch(iAttributesInternal & ifeaInstallMask)
		{
		case ifeaFavorLocal:
			riAttributes = INSTALLFEATUREATTRIBUTE_FAVORLOCAL;
			break;
		case ifeaFavorSource:
			riAttributes = INSTALLFEATUREATTRIBUTE_FAVORSOURCE;
			break;
		case ifeaFollowParent:
			riAttributes = INSTALLFEATUREATTRIBUTE_FOLLOWPARENT;
			break;
		default:
			AssertSz(0, "Unknown Attributes setting");
			riAttributes = 0;
			break;
		}

		if(iAttributesInternal & ifeaFavorAdvertise)
			riAttributes |= INSTALLFEATUREATTRIBUTE_FAVORADVERTISE;

		if(iAttributesInternal & ifeaDisallowAdvertise)
			riAttributes |= INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE;

		if (iAttributesInternal & ifeaNoUnsupportedAdvertise)
			riAttributes |= INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE;

		// Since ifeaUIDisallowAbsent state is UI status only, it's utility
		// to the caller is questionable, and is not returned.
		return fTrue;
	}
	else
	{
		return fFalse;
	}
}

ieiEnum MapStorageErrorToInitializeReturn(IMsiRecord* piError)
{
    if (!piError)
        return ieiSuccess;

    switch (piError->GetInteger(1))
    {
    case idbgInvalidMsiStorage:             return ieiPatchPackageInvalid;
    case imsgMsiFileRejected:               return ieiPatchPackageRejected;
    default:
        {
            switch (piError->GetInteger(3))
            {
            case STG_E_FILENOTFOUND:        // fall through
            case STG_E_PATHNOTFOUND:        // ...
            case STG_E_ACCESSDENIED:        // ...
            case STG_E_SHAREVIOLATION:      return ieiPatchPackageOpenFailed;
            case STG_E_INVALIDNAME:         // fall through
            default:                        return ieiPatchPackageInvalid;
            }
        }
    }
}

UINT MapInitializeReturnToUINT(ieiEnum iei)
{
	switch (iei)
	{
	case ieiSuccess            : return ERROR_SUCCESS; // initialization complete
	case ieiAlreadyInitialized : return ERROR_ALREADY_INITIALIZED; // this engine object is already initialized
	case ieiCommandLineOption  : return ERROR_INVALID_COMMAND_LINE; // invalid command line syntax %1
	case ieiDatabaseOpenFailed : return ERROR_INSTALL_PACKAGE_OPEN_FAILED; // database could not be opened
	case ieiDatabaseInvalid    : return ERROR_INSTALL_PACKAGE_INVALID; // incompatible database
	case ieiInstallerVersion   : return ERROR_INSTALL_PACKAGE_VERSION; // installer version does not support database format
	case ieiSourceAbsent       : return ERROR_INSTALL_SOURCE_ABSENT; // could not resolve a source
	case ieiHandlerInitFailed  : return ERROR_INSTALL_UI_FAILURE; // could not initialize handler interface
	case ieiLogOpenFailure     : return ERROR_INSTALL_LOG_FAILURE; // could not open logfile in requested mode
	case ieiLanguageUnsupported: return ERROR_INSTALL_LANGUAGE_UNSUPPORTED; // no acceptable language could be found
	case ieiPlatformUnsupported: return ERROR_INSTALL_PLATFORM_UNSUPPORTED; // no acceptable platform could be found
	case ieiTransformFailed    : return ERROR_INSTALL_TRANSFORM_FAILURE; // database transform failed to merge
	case ieiDatabaseCopyFailed : return ERROR_INSTALL_TEMP_UNWRITABLE; // could not copy db to temp dir
	case ieiPatchPackageOpenFailed : return ERROR_PATCH_PACKAGE_OPEN_FAILED; // could not open patch package
	case ieiPatchPackageInvalid : return ERROR_PATCH_PACKAGE_INVALID; // patch package invalid
	case ieiPatchPackageUnsupported: return ERROR_PATCH_PACKAGE_UNSUPPORTED; // patch package unsupported (wrong patching engine?)
	case ieiTransformNotFound  : return ERROR_INSTALL_TRANSFORM_FAILURE; // transform file not found
	case ieiPackageRejected    : return ERROR_INSTALL_PACKAGE_REJECTED;  // package cannot be run because of security reasons
	case ieiProductUnknown     : return ERROR_UNKNOWN_PRODUCT; // attempt to uninstall a product you haven't installed
	case ieiDiffUserAfterReboot: return ERROR_INSTALL_USEREXIT; // different user attempting to complete install after reboot
	case ieiProductAlreadyInstalled: return ERROR_PRODUCT_VERSION;
	case ieiTSRemoteInstallDisallowed : return ERROR_INSTALL_REMOTE_DISALLOWED;
	case ieiNotValidPatchTarget: return ERROR_PATCH_TARGET_NOT_FOUND;
	case ieiPatchPackageRejected: return ERROR_PATCH_PACKAGE_REJECTED; // patch rejected by policy
	case ieiTransformRejected: return ERROR_INSTALL_TRANSFORM_REJECTED; // transform rejected by policy
	case ieiPerUserInstallMode: return ERROR_INSTALL_FAILURE;
	case ieiApphelpRejectedPackage: return ERROR_APPHELP_BLOCK;
	default: AssertSz(0, "Unknown ieiEnum"); return ERROR_NOT_SUPPORTED;
	};
};

bool __stdcall FIsUpdatingProcess (void) 
{
	return (g_fWin9X || scService == g_scServerContext);
}

//____________________________________________________________________________
//
// Command line option translation table
// If value appears on command line, specify property name only: "Name"
// Else supply name and value as: "Name=PropertyValue"
// If value contains spaces, use: "Name=""Propery Value" (no ending extra quote)
//____________________________________________________________________________

//____________________________________________________________________________
//
// Command line parsing
//____________________________________________________________________________

ICHAR SkipWhiteSpace(const ICHAR*& rpch)
{
	if (rpch)
	{
		ICHAR ch;
		for (; (ch = *rpch) == ' ' || ch == '\t'; rpch++)
			;
		return ch;
	}
	else
		return 0;
}

// parse property name, convert to upper case, advances pointer to next non-blank

const IMsiString& ParsePropertyName(const ICHAR*& rpch, Bool fUpperCase)
{
	if (rpch)
	{
		MsiString istrName;
		ICHAR ch;
		const ICHAR* pchStart = rpch;
		while ((ch=*rpch) != 0 && ch != '=' && ch != ' ' && ch != '\t')
			rpch++;
		int cchName = rpch - pchStart;
		if (cchName)
		{
			// property names will not contain DBCS characters -- they are required to follow
			// our identifier rules
			memcpy(istrName.AllocateString(cchName, /*fDBCS=*/fFalse), pchStart, cchName * sizeof(ICHAR));
			if(fUpperCase)
				istrName.UpperCase();
		}
		SkipWhiteSpace(rpch);
		return istrName.Return();
	}
	else
	{
		return g_MsiStringNull;
	}
}

// parse property value, advance pointer past value, allows quotes, doubled to escape

const IMsiString& ParsePropertyValue(const ICHAR*& rpch)
{
	if (rpch)
	{
		MsiString istrValue;
		MsiString istrSection;
		Bool fDBCS = fFalse;
		if (SkipWhiteSpace(rpch) != 0)
		{
			ICHAR ch;
			do
			{
				const ICHAR* pchStart = rpch;
				int cchValue = 0;
				if (*rpch == '"')           // opening quote
				{
					pchStart++;
					rpch++;
					while ((ch=*rpch) != 0)
					{
	#ifdef UNICODE
						rpch++;
	#else // !UNICODE
						const ICHAR* pchTmp = rpch;
						rpch = ICharNext(rpch);
						if (rpch == pchTmp + 2)
						{
							fDBCS = fTrue;
							cchValue++; // add 1 for trail byte
						}
	#endif // UNICODE
						if (ch == '"')      // closing quote or escaped quote
						{
							ch = *rpch;     // check following char
							if (ch == '"')  // if doubled quote
								cchValue++; // include a quote in string
							break;
						}
						cchValue++;
					}
				}
				else
				{
					while ((ch=*rpch) != 0 && ch != ' ' && ch != '\t')
					{
	#ifdef UNICODE
						rpch++;
	#else // !UNICODE
						const ICHAR* pchTmp = rpch;
						rpch = ICharNext(rpch);
						if (rpch == pchTmp + 2)
						{
							fDBCS = fTrue;
							cchValue++; // add 1 for trail byte
						}
	#endif // UNICODE
						cchValue++;
					}
				}
				if (cchValue)
				{
					memcpy(istrSection.AllocateString(cchValue, fDBCS), pchStart, cchValue * sizeof(ICHAR));
					istrValue += istrSection;
				}
			} while (ch == '"'); // loop if escaped double quote
		}
		return istrValue.Return();
	}
	else
	{
		return g_MsiStringNull;
	}
}

const ICHAR* rgszAllowedProperties[] =
{
	IPROPNAME_FILEADDLOCAL,
	IPROPNAME_COMPONENTADDLOCAL,
	IPROPNAME_COMPONENTADDSOURCE,
	IPROPNAME_COMPONENTADDDEFAULT,
	IPROPNAME_ALLUSERS,
	IPROPNAME_SCRIPTFILE,
	IPROPNAME_EXECUTEMODE,
	IPROPNAME_PRODUCTLANGUAGE,
	IPROPNAME_TRANSFORMS,
	IPROPNAME_REINSTALLMODE,
	IPROPNAME_RUNONCEENTRY,
	IPROPNAME_CURRENTDIRECTORY,
	IPROPNAME_CLIENTUILEVEL,
	IPROPNAME_CLIENTPROCESSID,
	IPROPNAME_ACTION,
	IPROPNAME_CURRENTMEDIAVOLUMELABEL,
	IPROPNAME_INSTALLLEVEL,
	IPROPNAME_REINSTALL,
	IPROPNAME_FEATUREREMOVE,
	IPROPNAME_FEATUREADDLOCAL,
	IPROPNAME_FEATUREADDSOURCE,
	IPROPNAME_FEATUREADDDEFAULT,
	IPROPNAME_FEATUREADVERTISE,
	IPROPNAME_PATCH,
	IPROPNAME_SECONDSEQUENCE,
	IPROPNAME_TRANSFORMSATSOURCE,
	IPROPNAME_TRANSFORMSSECURE,
	IPROPNAME_CURRENTDIRECTORY,
	IPROPNAME_MIGRATE,
	IPROPNAME_LIMITUI,
	IPROPNAME_LOGACTION,
	IPROPNAME_UPGRADINGPRODUCTCODE,
	IPROPNAME_REBOOT,
	IPROPNAME_SEQUENCE,
	IPROPNAME_NOCOMPANYNAME,
	IPROPNAME_NOUSERNAME,
	IPROPNAME_RESUME,
	IPROPNAME_PRIMARYFOLDER,
	IPROPNAME_SHORTFILENAMES,
	IPROPNAME_INSTALLLEVEL,
	IPROPNAME_MEDIAPACKAGEPATH,
	IPROPNAME_PROMPTROLLBACKCOST,
	IPROPNAME_ODBCREINSTALL,
	IPROPNAME_FILEADDSOURCE,
	IPROPNAME_FILEADDDEFAULT,
	IPROPNAME_AFTERREBOOT,
	IPROPNAME_EXECUTEACTION,
	IPROPNAME_REBOOTPROMPT,
	IPROPNAME_MSINODISABLEMEDIA,
	IPROPNAME_CHECKCRCS,
	IPROPNAME_FASTOEMINSTALL,
	IPROPNAME_MSINEWINSTANCE,
	IPROPNAME_MSIINSTANCEGUID,
	IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY,
	IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY,
0
};

#ifdef UNICODE
bool PropertyIsAllowed(const ICHAR* szProperty, const ICHAR* szAllowedProperties)
#else
bool PropertyIsAllowed(const ICHAR*, const ICHAR*)
#endif
{
#ifdef UNICODE
	if (!szProperty)
		return false;

	MsiString strProperty = *szProperty;
	strProperty.UpperCase();

	// check whether this is one of our hardcoded allowed properties

	for (const ICHAR** pszAllowed = rgszAllowedProperties; *pszAllowed; pszAllowed++)
	{
		if (strProperty.Compare(iscExact, *pszAllowed))
			return true;
	}

	// check whether this is an author-defined allowed property

	if (szAllowedProperties && *szAllowedProperties)
	{
		const ICHAR* pchAllowedPropEnd = szAllowedProperties;

		for (;;)
		{
			if (*pchAllowedPropEnd == 0 || *pchAllowedPropEnd == ';')
			{
				unsigned int cchToCompare = pchAllowedPropEnd - szAllowedProperties;
				int cchProperty = lstrlen(szProperty);
				// property must have length >= 1
				// list containing ";;" or ending in ";" is valid, but ';' has no meaning w.r.t. a property name
				if (cchToCompare != 0 && cchProperty == cchToCompare && 0 == memcmp(szProperty, szAllowedProperties, cchToCompare*sizeof(ICHAR)))
					return true;
				
				if (*pchAllowedPropEnd == 0)
					break;

				szAllowedProperties = pchAllowedPropEnd + 1;
			}

			pchAllowedPropEnd++;
		}
	}

	if (szProperty)
		DEBUGMSGL1(TEXT("Ignoring disallowed property %s"), szProperty);

	return false;
#else
	return true;
#endif
}

// parse properties from command line, assumes module name stripped off

Bool ProcessCommandLine(const ICHAR* szCommandLine,
								const IMsiString** ppistrLanguage, const IMsiString** ppistrTransforms,
								const IMsiString** ppistrPatch, const IMsiString** ppistrAction,
								const IMsiString** ppistrDatabase,
								const IMsiString* pistrOtherProp, const IMsiString** ppistrOtherPropValue,
								Bool fUpperCasePropNames, const IMsiString** ppistrErrorInfo,
								IMsiEngine* piEngine,
								bool fRejectDisallowedProperties)
{
	if (!szCommandLine)
		return fTrue;

	MsiString strAuthoredAllowedProperties;
	if (fRejectDisallowedProperties && piEngine)
	{
		strAuthoredAllowedProperties = piEngine->GetPropertyFromSz(IPROPNAME_ALLOWEDPROPERTIES);
	}

	const ICHAR* pchCmdLine = szCommandLine;
	for(;;)
	{
		MsiString istrPropName;
		MsiString istrPropValue;
		ICHAR ch = SkipWhiteSpace(pchCmdLine);
		const ICHAR* szCmdOption = pchCmdLine;  // keep start for error message
		if (ch == 0)
			break;

		// process property=value pair
		istrPropName = ParsePropertyName(pchCmdLine, fUpperCasePropNames);
		if (!istrPropName.TextSize() || *pchCmdLine++ != '=')
		{
			if (ppistrErrorInfo)
			{
				(*ppistrErrorInfo)->Release();
				istrPropName.ReturnArg(*ppistrErrorInfo);
			}
			return fFalse;
		}
		istrPropValue = ParsePropertyValue(pchCmdLine);

		if ((ppistrLanguage) || (ppistrTransforms) || (ppistrPatch) || (ppistrAction) || (ppistrDatabase) ||
			 (pistrOtherProp && ppistrOtherPropValue))
		{
			if ((ppistrLanguage) && (istrPropName.Compare(iscExact, IPROPNAME_PRODUCTLANGUAGE) == 1))
			{
				if(*ppistrLanguage)
					(*ppistrLanguage)->Release();
				*ppistrLanguage= istrPropValue;
				(*ppistrLanguage)->AddRef();
			}
			else if ((ppistrTransforms) && (istrPropName.Compare(iscExact, IPROPNAME_TRANSFORMS) == 1))
			{
				while (istrPropValue.Compare(iscStart, TEXT(" "))) // remove leading spaces
					istrPropValue.Remove(iseFirst, 1);

				if(*ppistrTransforms)
					(*ppistrTransforms)->Release();
				*ppistrTransforms = istrPropValue;
				(*ppistrTransforms)->AddRef();
			}
			else if ((ppistrPatch) && (istrPropName.Compare(iscExact, IPROPNAME_PATCH) == 1))
			{
				if(*ppistrPatch)
					(*ppistrPatch)->Release();
				*ppistrPatch = istrPropValue;
				(*ppistrPatch)->AddRef();
			}
			else if ((ppistrAction) && (istrPropName.Compare(iscExact, IPROPNAME_ACTION) == 1))
			{
				if(*ppistrAction)
					(*ppistrAction)->Release();
				*ppistrAction = istrPropValue;
				(*ppistrAction)->AddRef();
			}
			else if ((ppistrDatabase) && (istrPropName.Compare(iscExact, IPROPNAME_DATABASE) == 1))
			{
				if(*ppistrDatabase)
					(*ppistrDatabase)->Release();
				*ppistrDatabase = istrPropValue;
				(*ppistrDatabase)->AddRef();
			}
			else if ((pistrOtherProp) && (ppistrOtherPropValue) &&
						(istrPropName.Compare(iscExact, pistrOtherProp->GetString()) == 1))
			{
				if(*ppistrOtherPropValue)
					(*ppistrOtherPropValue)->Release();
				*ppistrOtherPropValue = istrPropValue;
				(*ppistrOtherPropValue)->AddRef();
			}
		}
		else if (piEngine && (!fRejectDisallowedProperties || PropertyIsAllowed(istrPropName, strAuthoredAllowedProperties)))
		{
			piEngine->SetProperty(*istrPropName, *istrPropValue);
		}
	}
	return fTrue;
}

//____________________________________________________________________________
//
// Product registration methods
//____________________________________________________________________________

iesEnum CMsiEngine::CreateProductInfoRec(IMsiRecord*& rpiRec)
{
	using namespace IxoProductInfo;
	
	PMsiRecord pError(0);
	rpiRec = &m_riServices.CreateRecord(Args);
	MsiString strProductKey = GetProductKey();

	DWORD dwVersion = ProductVersion();

	//!! if properties not set in Property table, should we use the summary properties? or just fail?
	AssertNonZero(rpiRec->SetMsiString(ProductKey, *strProductKey));
	AssertNonZero(rpiRec->SetMsiString(ProductName, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME))));
	AssertNonZero(rpiRec->SetMsiString(PackageName, *m_strPackageName));
	AssertNonZero(rpiRec->SetInteger(Language, (int)GetLanguage()));
	AssertNonZero(rpiRec->SetInteger(Version, (int)dwVersion));
	AssertNonZero(rpiRec->SetInteger(Assignment, MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? 1 : 0));
	AssertNonZero(rpiRec->SetInteger(ObsoleteArg, 0)); // this used to be set on the execute side; we don't any longer,
																		// but old Darwins do, so we continue to reserve the spot
	AssertNonZero(rpiRec->SetMsiString(ProductIcon, *MsiString(GetPropertyFromSz(IPROPNAME_ARPPRODUCTICON))));
	AssertNonZero(rpiRec->SetMsiString(PackageCode, *MsiString(GetPropertyFromSz(IPROPNAME_PACKAGECODE))));
	AssertNonZero(rpiRec->SetInteger(InstanceType, m_fNewInstance ? 1 : 0));
	
	// save off AppCompat information for custom actions if enabled for this install
	if (m_fCAShimsEnabled)
	{
		PMsiStream piDBGuid(0);
		char* pbBuffer = m_riServices.AllocateMemoryStream(sizeof(m_guidAppCompatDB), *&piDBGuid);
		if (!pbBuffer)
			return iesFailure;
		memcpy(pbBuffer, &m_guidAppCompatDB, sizeof(m_guidAppCompatDB));
		AssertNonZero(rpiRec->SetMsiData(AppCompatDB, piDBGuid));
	
	
		PMsiStream piIDGuid(0);
		pbBuffer = m_riServices.AllocateMemoryStream(sizeof(m_guidAppCompatID), *&piIDGuid);
		if (!pbBuffer)
			return iesFailure;
		memcpy(pbBuffer, &m_guidAppCompatID, sizeof(m_guidAppCompatID));
		AssertNonZero(rpiRec->SetMsiData(AppCompatID, piIDGuid));
	}

	if (!m_fAdvertised)
	{
		// if not already advertised mode, we'll to deduce the media relative path if installing from media,
		// or grab it from the admin properties stream if possible
		iesEnum iesResult = iesSuccess;

		PMsiPath pPath(0);
		PMsiRecord pError(0);
		if ((pError = GetSourcedir(*this, *&pPath)) != 0)
			return FatalError(*pError);

		MsiString strMediaRelativePath;

		idtEnum idt = PMsiVolume(&pPath->GetVolume())->DriveType();
		if (idt == idtCDROM || idt == idtFloppy || idt == idtRemovable)
		{
			strMediaRelativePath = pPath->GetRelativePath();
		}
		else
		{
			strMediaRelativePath = GetPropertyFromSz(IPROPNAME_MEDIAPACKAGEPATH);
		}

		AssertNonZero(rpiRec->SetMsiString(PackageMediaPath, *strMediaRelativePath));
	}
	else
	{
		// if in maintenance mode, get the relative path from the registered source list
		CRegHandle hSourceListKey;
		if (ERROR_SUCCESS == OpenSourceListKey(strProductKey, /*fPatch=*/fFalse, hSourceListKey, /*fWrite=*/fFalse, false))
		{
			PMsiRegKey pSourceListKey = &m_riServices.GetRootKey((rrkEnum)(int)hSourceListKey, ibtCommon); // x86 and ia64 same
			PMsiRegKey pMediaKey = &pSourceListKey->CreateChild(szSourceListMediaSubKey, 0);

			MsiString strPackagePath;
			PMsiRecord pError(0);
			if ((pError = pMediaKey->GetValue(szMediaPackagePathValueName, *&strPackagePath)) == 0)
			{
				AssertNonZero(rpiRec->SetMsiString(PackageMediaPath, *strPackagePath));
			}
		}
	}

	return iesSuccess;
}

unsigned int CMsiEngine::ProductVersion()
{
	return ProductVersionStringToInt(MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTVERSION)));
}

unsigned int ProductVersionStringToInt(const ICHAR* szVersion)
{
	MsiString strVersion(szVersion);
	MsiString strField;
	DWORD dwVersion = 0;

	// Given a version A.B.C.D the integer representation is (A << 24) | (B << 16) | C
	// Assumes that A, B <= 0xFF and C <= 0xFFFF

	// FUTURE davidmck - No need to do the extraction
	for(int i = 0,iShift=24; i < 3; i++, iShift-= i*8)// first shift 24, then 16 then 0
	{
		strField = strVersion.Extract(iseUpto, '.');
		dwVersion |= (int)strField << iShift;
		if(!strVersion.Remove(iseIncluding, '.'))
			break; // insufficient fields
	}
	return dwVersion;
}

// stuff from fileactn.cpp
extern iesEnum ExecuteChangeMedia(IMsiEngine& riEngine, IMsiRecord& riMediaRec, IMsiRecord& riParamsRec,
								  const IMsiString& ristrTemplate, unsigned int cbPerTick, const IMsiString& ristrFirstVolLabel);
extern IMsiRecord* OpenMediaView(IMsiEngine& riEngine, IMsiView*& rpiView, const IMsiString*& rpistrFirstVolLabel);

IMsiRecord* GetSourcedir(IMsiDirectoryManager& riDirManager, IMsiPath*& rpiPath)
{
	IMsiRecord* piError;
	if ((piError = riDirManager.GetSourcePath(*MsiString(*IPROPNAME_SOURCEDIR), rpiPath)) != 0)
	{
		if (piError->GetInteger(1) == idbgSourcePathsNotCreated)
		{
			piError->Release();
			piError = riDirManager.GetSourcePath(*MsiString(*IPROPNAME_SOURCEDIROLD), rpiPath);
		}
	}
	return piError;
}

IMsiRecord* GetSourcedir(IMsiDirectoryManager& riDirManager, const IMsiString*& rpiValue)
{
	IMsiRecord* piError;
	PMsiPath pPath(0);
	if ((piError = GetSourcedir(riDirManager, *&pPath)) != 0)
		return piError;

	MsiString(pPath->GetPath()).ReturnArg(rpiValue);
	return 0;
}

iesEnum CMsiEngine::CacheDatabaseIfNecessary()
{
	using namespace IxoDatabaseCopy;

	MsiString strOriginalDatabasePath = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	MsiString strDatabasePath         = GetPropertyFromSz(IPROPNAME_DATABASE);

	// cached DB if first-run OR maintenance-mode & our package isn't the cached package
	if (*(const ICHAR*)strOriginalDatabasePath != ':'  // not a SubStorage
	  && (!(GetMode() & iefMaintenance) || (!IsCachedPackage(*this, *strDatabasePath))))
	{
		{
			using namespace IxoChangeMedia;
			
			// if we have a media table entry dispatch an IxoChangeMedia operation for the cache database copy
			PMsiView pView(0);
			iesEnum iesRet;
			PMsiRecord piError(0);
			MsiString strFirstVolumeLabel;
			if((piError = OpenMediaView(*this,*&pView,*&strFirstVolumeLabel)) != 0)
				return FatalError(*piError);
			
			if((piError = pView->Execute(0)) != 0)
				return FatalError(*piError);
			PMsiRecord pMediaFetch = pView->Fetch(); // only want first one
			if(pMediaFetch)
			{
				PMsiRecord pExecuteMedia = &m_riServices.CreateRecord(IxoChangeMedia::Args);
				iesRet = ExecuteChangeMedia(*this,*pMediaFetch,*pExecuteMedia,*MsiString(GetErrorTableString(imsgPromptForDisk)),0,*strFirstVolumeLabel);
				if(iesRet != iesSuccess && iesRet != iesNoAction)
					return iesRet;
			}
		}

		MsiString strStreams;
		CreateCabinetStreamList(*this, *&strStreams);

		PMsiRecord pCacheDatabaseInfo(&m_riServices.CreateRecord(IxoDatabaseCopy::Args));
		// for nested installs the currently running msi (strDatabasePath) may be gone when we
		// run the script for merged nested installs so we always copy the source package for nested
		// installed. for non-nested installs, however, the currently running msi will still be around
		// so we copy that.

		if (m_fChildInstall)
			pCacheDatabaseInfo->SetMsiString(DatabasePath, *strOriginalDatabasePath);
		else
			pCacheDatabaseInfo->SetMsiString(DatabasePath, *strDatabasePath);

		pCacheDatabaseInfo->SetMsiString(ProductCode, *MsiString(GetProductKey()));
		pCacheDatabaseInfo->SetMsiString(CabinetStreams, *strStreams);

		return ExecuteRecord(IxoDatabaseCopy::Op, *pCacheDatabaseInfo);
	}
	return iesSuccess;
}

iesEnum CMsiEngine::CleanupTempFilesViaOpcode()
{
	if (m_strTempFileCopyCleanupList.TextSize())
	{
		using namespace IxoCleanupTempFiles;
		PMsiRecord pRecTempFiles(&m_riServices.CreateRecord(Args));
		pRecTempFiles->SetMsiString(TempFiles, *m_strTempFileCopyCleanupList);

		return ExecuteRecord(Op, *pRecTempFiles);
	}

	return iesSuccess;
}

iesEnum CMsiEngine::RegisterProduct()
{
	PMsiRecord pError(0);

	if (!m_piProductKey)
	{
		pError = PostError(Imsg(idbgEngineNotInitialized),TEXT(""));
		return FatalError(*pError);
	}
	
	iesEnum iesRet = iesSuccess;
	if (FFeaturesInstalled(*this) == fFalse)
		return iesRet;  // nothing selected


	if ((iesRet = CacheDatabaseIfNecessary()) != iesSuccess)
		return iesRet;

	// register product if
	// a) haven't registered this product code before
	// b) are installing a new package with the same product code
	MsiString strQFEUpgrade = GetPropertyFromSz(IPROPNAME_QFEUPGRADE);
	int iQFEUpgradeType = 0;
	if(strQFEUpgrade.TextSize())
	{
		iQFEUpgradeType = strQFEUpgrade;
		if(iQFEUpgradeType == iMsiNullInteger)
		{
			Assert(0);
			iQFEUpgradeType = 0;
		}
	}

	if (!m_fRegistered || iQFEUpgradeType)
	{
		if(iQFEUpgradeType)
			DEBUGMSG(TEXT("Re-registering product - performing upgrade of existing installation."));
		
		using namespace IxoProductRegister;
		PMsiRecord pProductInfo(&m_riServices.CreateRecord(Args));
		pProductInfo->SetMsiString(AuthorizedCDFPrefix, *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPAUTHORIZEDCDFPREFIX))));
		pProductInfo->SetMsiString(Comments,        *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPCOMMENTS))));
		pProductInfo->SetMsiString(Contact,         *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPCONTACT))));
		// ARPPRODUCTICON is set during advertisement.

		// (DisplayName is in the ixoProductInfo op)
		// (DisplayVersion is in the ixoProductInfo op)

		pProductInfo->SetMsiString(HelpLink,        *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPHELPLINK))));
		pProductInfo->SetMsiString(HelpTelephone,   *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPHELPTELEPHONE))));

		// (InstallDate is determined on the execute side)
		
		pProductInfo->SetMsiString(InstallLocation, *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPINSTALLLOCATION))));

		// only register source during initial install
		// or QFE non-patch upgrade
		// if patching, use existing value
		if(!m_fRegistered || iQFEUpgradeType == 1)
		{
			MsiString strSourceDir;
			if ((pError = ENG::GetSourcedir(*this, *&strSourceDir)) != 0)
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return FatalError(*pError);
			}

			pProductInfo->SetMsiString(InstallSource,   *strSourceDir);
		}
		else if (iQFEUpgradeType == 2)
		{
			// QFEUpgrade via patch -- use existing InstallSource value from the initial install (don't blank it)
			CTempBuffer<ICHAR, MAX_PATH> rgchInstallSource;
			if (ENG::GetProductInfo(m_piProductKey->GetString(), INSTALLPROPERTY_INSTALLSOURCE, rgchInstallSource))
			{
				pProductInfo->SetString(InstallSource, rgchInstallSource);
			}
		}

		// (LocalPackage is written by ixoDatabaseCopy)
		// (ModifyPath is determined on the execute side)
		if (MsiString(GetProperty(*MsiString(*IPROPNAME_ARPNOMODIFY))).TextSize())
			pProductInfo->SetInteger(NoModify, 1);

		if (MsiString(GetProperty(*MsiString(*IPROPNAME_ARPNOREMOVE))).TextSize())
			pProductInfo->SetInteger(NoRemove, 1);

		if (MsiString(GetProperty(*MsiString(*IPROPNAME_ARPNOREPAIR))).TextSize())
			pProductInfo->SetInteger(NoRepair, 1);

		// (ProductId is in the ixoUserRegister op)

		pProductInfo->SetMsiString(Publisher,       *MsiString(GetProperty(*MsiString(*IPROPNAME_MANUFACTURER))));
		pProductInfo->SetMsiString(Readme,          *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPREADME))));

		// (RegCompany is in the ixoUserRegister op)
		// (RegOwner is in the ixoUserRegister op)

		pProductInfo->SetMsiString(Size,            *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPSIZE))));

		MsiString istrEstimatedSize = GetEstimatedInstallSize();
		pProductInfo->SetMsiString(EstimatedSize, *istrEstimatedSize);

		pProductInfo->SetMsiString(SystemComponent, *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPSYSTEMCOMPONENT))));
		
		// (UninstallString is determined on the execute side)
		
		pProductInfo->SetMsiString(UpgradeCode,     *MsiString(GetProperty(*MsiString(*IPROPNAME_UPGRADECODE))));
		pProductInfo->SetMsiString(URLInfoAbout,    *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPURLINFOABOUT))));
		pProductInfo->SetMsiString(URLUpdateInfo,   *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPURLUPDATEINFO))));
		pProductInfo->SetMsiString(VersionString,   *MsiString(GetProperty(*MsiString(*IPROPNAME_PRODUCTVERSION))));
		
		// (WindowsInstaller is determined on the execute side)
		
		iesRet = ExecuteRecord(Op, *pProductInfo);
		if(iesRet != iesSuccess)
			return iesRet;

		// will register the product, so set the PRODUCTTOBEREGISTERED property
		SetPropertyInt(*MsiString(*IPROPNAME_PRODUCTTOBEREGISTERED),1);
	}
	else
	{
		// Maintenance mode - just update the EstimatedSize

		using namespace IxoUpdateEstimatedSize;
		PMsiRecord pSizeInfo(&m_riServices.CreateRecord(Args));
		MsiString istrEstimatedSize = GetEstimatedInstallSize();
		pSizeInfo->SetMsiString(EstimatedSize, *istrEstimatedSize);
		iesRet = ExecuteRecord(Op, *pSizeInfo);
		if(iesRet != iesSuccess)
			return iesRet;
	}
	
	// do the product name registration, if being installed as a standalone ap
	if (!m_fChildInstall && FFeaturesInstalled(*this, fFalse))
	{
		using namespace IxoProductCPDisplayInfoRegister;
		PMsiRecord pParam(&m_riServices.CreateRecord(Args));
		iesRet = ExecuteRecord(Op, *pParam);
	}
	return iesRet;
}


const IMsiString& CMsiEngine::GetEstimatedInstallSize()
{
	// For EstimatedSize, get total cost across all volumes, and convert from units of 512 to KB
	// If in maintenance mode, always use non-rollback cost to inc/dec current value; otherwise
	// always use rollback cost.
	bool fMaint = GetMode() & iefMaintenance ? true : false;
	int iTotalCost = GetTotalCostAcrossVolumes(fMaint ? false : true, /* fARPCost = */ true) / 2;

	// Subtract off the fixed engine overhead costs
	int iEngineCost, iEngineNoRbCost;
	PMsiRecord pError = DetermineEngineCost(&iEngineCost, &iEngineNoRbCost);
	if (!pError)
		iTotalCost -= fMaint ? iEngineNoRbCost / 2 : iEngineCost / 2;
	MsiString istrTotalCost = iTotalCost;
	return istrTotalCost.Return();
}


iesEnum CMsiEngine::RegisterUser(bool fDirect)
{
	// two modes of operation:
	// fDirect = true:  call server directly to register user, used by MsiCollectUserInfo
	// fDirect = false: dispatch script operation to register user, used by RegisterUser action
	
	PMsiRecord piError(0);

	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);
	
	if (!m_piProductKey)
	{
		piError = PostError(Imsg(idbgEngineNotInitialized),TEXT(""));
		return FatalError(*piError);
	}

	MsiString strUserName  = GetPropertyFromSz(IPROPNAME_USERNAME);
	MsiString strCompany   = GetPropertyFromSz(IPROPNAME_COMPANYNAME);
	MsiString strProductID = GetPropertyFromSz(IPROPNAME_PRODUCTID);
		
	if(fDirect)
	{
		if (NULL == m_piServer)
		{
		    piError = PostError (Imsg(imsgServiceConnectionFailure));
		    return FatalError (*piError);
		}

		piError = m_piServer->RegisterUser(m_piProductKey->GetString(),strUserName,strCompany,strProductID);
		if(piError)
			return FatalError(*piError);
		else
			return iesSuccess;
	}
	else
	{
		using namespace IxoUserRegister;

		if ((m_fRegistered) || (FFeaturesInstalled(*this) == fFalse))
			return iesSuccess;  // already be registered, maintenance mode, nothing selected or we we called before

		if (!m_piProductKey)
		{
			piError = PostError(Imsg(idbgEngineNotInitialized),TEXT(""));
			return FatalError(*piError);
		}

		if(!strProductID.TextSize())
			return iesSuccess; // PID not valid, but allow install to continue anyway
		
		PMsiRecord pUserInfo(&m_riServices.CreateRecord(Args));
		pUserInfo->SetMsiString(Owner,     *strUserName);
		pUserInfo->SetMsiString(Company,   *strCompany);
		pUserInfo->SetMsiString(ProductId, *strProductID);
		
		return ExecuteRecord(ixoUserRegister, *pUserInfo);
	}
}

const IMsiString& CMsiEngine::GetProductKey()
{
	if (!m_piProductKey)
	{
		MsiString istrProductKey = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
		if (istrProductKey.TextSize())
			m_piProductKey = istrProductKey, m_piProductKey->AddRef();
		else
			return g_MsiStringNull;
	}
	m_piProductKey->AddRef();
	return *m_piProductKey;
}

//!! temp - remove when UnpublishAction is removed
iesEnum UnpublishProduct(IMsiEngine& riEngine);
//!! end temp

//!! currently calls the UnpublishProduct from coreactn
iesEnum CMsiEngine::UnregisterProduct()
{
	iesEnum iesRet = iesNoAction;
	if (!m_piProductKey)
		return iesRet;
	if(m_fRegistered)
	{
		if(!FFeaturesInstalled(*this))
		{
			using namespace IxoProductUnregister;
			PMsiRecord piRecord(&(m_riServices.CreateRecord(Args)));
			AssertNonZero(piRecord->SetMsiString(UpgradeCode,
															 *MsiString(GetPropertyFromSz(IPROPNAME_UPGRADECODE))));
			iesRet = ExecuteRecord(Op, *piRecord);
			if (iesRet != iesSuccess)
				return iesRet;

			// will register the product, so set the PRODUCTTOBEREGISTERED property
			SetProperty(*MsiString(*IPROPNAME_PRODUCTTOBEREGISTERED),g_MsiStringNull);
		}

		if(!m_fChildInstall && !FFeaturesInstalled(*this, fFalse))
		{
			using namespace IxoProductCPDisplayInfoUnregister;
			PMsiRecord piRecord(&(m_riServices.CreateRecord(Args)));
			iesRet = ExecuteRecord(Op, *piRecord);
			if (iesRet != iesSuccess)
				return iesRet;
		}
	}
	iesRet = ::UnpublishProduct(*this); //!! we shouldn't have an UnpublishProduct action - the code in that
											  //!! action should really be here.  This should be fixed in Beta 2
	return iesRet;
}

iesEnum CMsiEngine::BeginTransaction()
{
	PMsiRecord pError(0);
	
	if(!g_MessageContext.IsServiceInstalling())
	{
		pError = PostError(Imsg(idbgErrorBeginningTransaction));
		return FatalError(*pError);
	}

	if (!m_fServerLocked)
	{
		DEBUGMSG("BeginTransaction: Locking Server");
		MsiString strSelections, strFolders, strProperties;
		//!! some properties may be duplicated in these strings, should reduce as much of this as possible
		pError = GetCurrentSelectState(*&strSelections, *&strProperties, 0, &strFolders, fTrue);
		if(pError)
		{
			return FatalError(*pError); //!!
		}

		PMsiRecord pSetInProgressInfo = &m_riServices.CreateRecord(ipiEnumCount);
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiProductKey,
																  *MsiString(GetProductKey())));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiProductName,
																  *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiLogonUser,
																  *MsiString(GetPropertyFromSz(IPROPNAME_LOGONUSER))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiSelections, *strSelections));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiFolders, *strFolders));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiProperties, *strProperties));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiDatabasePath,
																  *MsiString(GetPropertyFromSz(IPROPNAME_DATABASE))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiDiskPrompt,
																  *MsiString(GetPropertyFromSz(IPROPNAME_DISKPROMPT))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiDiskSerial,
																  *MsiString(GetPropertyFromSz(IPROPNAME_DISKSERIAL))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiTimeStamp,
																  *MsiString(ENG::GetCurrentDateTime())));

		PMsiRecord pCurrentInProgressInfo(0);	
		for(;;)
		{
			pCurrentInProgressInfo = 0;

			if (MinimumPlatformMillennium() || MinimumPlatformWindowsNT51())
			{
				// Millennium/Whistler only
				if((pError = GetInProgressInstallInfo(m_riServices, *&pCurrentInProgressInfo)) != 0)
					return FatalError(*pError);
				if( !pCurrentInProgressInfo || !pCurrentInProgressInfo->GetFieldCount() )
					BeginSystemChange();
				pCurrentInProgressInfo = 0;
				
				ICHAR rgchBuffer[64];
				_i64tot(m_i64PCHEalthSequenceNo, rgchBuffer, 10);
				AssertNonZero(pSetInProgressInfo->SetMsiString(ipiSRSequence, *MsiString(rgchBuffer)));
			}

			pError = LockInstallServer(pSetInProgressInfo,*&pCurrentInProgressInfo);
			if(pError)
				return FatalError(*pError);
			else if(pCurrentInProgressInfo)
			{

				INT64 iSRSequence = pCurrentInProgressInfo->GetString(ipiSRSequence) ?
										  _ttoi64(pCurrentInProgressInfo->GetString(ipiSRSequence)) : 0;
				// suspended install detected
				if(MsiString(GetPropertyFromSz(IPROPNAME_RESUME)).TextSize())
				{
					// already checked in-progress install
					m_fServerLocked = fTrue;
					m_i64PCHEalthSequenceNo = iSRSequence;
					break;
				}
				
				ipitEnum ipitType = InProgressInstallType(*pCurrentInProgressInfo);
				if(ipitType == ipitSameConfig)
				{
					// resume this install
					m_fServerLocked = fTrue;
					m_i64PCHEalthSequenceNo = iSRSequence;

					// since there is a suspended install, we need to resume the terminal server
					// transaction by remapping the HKCU key as necessary. If the suspended install
					// is just a continuation, the transaction will be closed after the install 
					// finishes.
					OpenHydraRegistryWindow(/*fNewTransaction=*/false);
					break;
				}
				else
				{
					Bool fUserChangedDuringInstall = fFalse;
					if(ipitType & ipitDiffUser)
					{
						// communicate to this process, and the service that the user has changed.
						// don't rollback if different user started original install

						fUserChangedDuringInstall = fTrue;

						pError = PostError(Imsg(imsgDiffUserInstallInProgress),
											 *MsiString(pCurrentInProgressInfo->GetMsiString(ipiLogonUser)),
											 *MsiString(pCurrentInProgressInfo->GetMsiString(ipiProductName)));

						Message(imtUser,*pError); // no options, don't need to check return.
					}

					// each rollback script is responsible for ensuring its own registry/CA state
					// for per-machine TS installs. 
					Bool fRollbackAttempted = fFalse;
					iesEnum iesResult = RollbackSuspendedInstall(*pCurrentInProgressInfo,fTrue,
																				fRollbackAttempted, fUserChangedDuringInstall);
					if(iesResult == iesSuspend)
						// reboot required
						return iesResult;
					
					if(fRollbackAttempted == fFalse)
						return iesUserExit;
					
					//!! else ?? check return status
					continue;
				}
			}
			else
			{
				OpenHydraRegistryWindow(/*fNewTransaction=*/true);
				m_fServerLocked = fTrue;
				break;
			}
		}
	}
#ifdef DEBUG
	else
	{
		DEBUGMSG(TEXT("BeginTransaction: Server already locked"));
		Assert(m_fInParentTransaction);
	}
#endif //DEBUG

	m_issSegment = issScriptGeneration;

	if(!(GetMode() & (iefAdmin | iefAdvertise)))
	{
		iesEnum iesStatus = UnregisterProduct(); // unadvertises, unregisters the product if nothing installed
		if (iesStatus != iesSuccess && iesStatus != iesNoAction)
			return iesStatus;   //!! need to call FatalError?
	}
	return iesSuccess;
}

iesEnum CMsiEngine::EndTransaction(iesEnum iesState)
{
	iesEnum iesReturn = iesSuccess;

	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);
	
	MsiString strProductCode = GetProductKey();
	
	bool fUpdateStarted = MsiString(GetPropertyFromSz(IPROPNAME_UPDATESTARTED)).TextSize() != 0;

	if(m_fServerLocked && !m_fInParentTransaction)
	{
#ifdef DEBUG
		if(MsiString(GetPropertyFromSz(TEXT("ROLLBACKTEST"))).TextSize())
			iesState = iesFailure; // force rollback
#endif // DEBUG

		bool fAllowSuspend = MsiString(GetPropertyFromSz(IPROPNAME_ALLOWSUSPEND)).TextSize() != 0;

		if((GetMode() & iefRollbackEnabled) && fAllowSuspend && fUpdateStarted &&
			iesState != iesFinished && iesState != iesSuccess &&
			iesState != iesNoAction && iesState != iesSuspend)
		{
			//!! check if rollback always
			PMsiRecord pError = PostError(Imsg(imsgRestoreOrContinue));
			switch(Message(imtEnum(imtUser+imtYesNo+imtIconQuestion+imtDefault1),*pError))
			{
			case imsNo:
				iesState = iesSuspend;
				break;
			default:
				AssertSz(fTrue, "Invalid return from message");
			case imsYes:
			case imsNone:
				break;
			}
		}
		
		//!! check return for reboot
		if (m_piServer)
		{
		    iesReturn = m_piServer->InstallFinalize(iesState, *this, fFalse /*fUserChangedDuringInstall*/);
		}
		else
		{
		    PMsiRecord pError = PostError (Imsg(imsgServiceConnectionFailure));
		    iesReturn = FatalError (*pError);
		}
		
		if(iesReturn == iesFinished  || /*!!*/ iesReturn == iesSuspend)
			iesReturn = iesSuccess;

		// if we're on TS5, installing per machine, and aren't doing an admin image or
		// creating an advertise script, plus we aren't going to continue after a
		// reboot, we should notify TS that the install is complete
		switch (iesState)
		{
		case iesUserExit: // fall through
		case iesFailure:
			// for user cancel or failure, don't commit changes.
			CloseHydraRegistryWindow(/*Commit=*/false);
			EndSystemChange(/*fCommitChange=*/false, m_i64PCHEalthSequenceNo);
			break;
		case iesSuspend:
			// no action, leave window open, after reboot will close
			break;
		case iesSuccess:
		default:
			CloseHydraRegistryWindow(/*Commit=*/true);
			EndSystemChange(/*fCommitChange=*/true, m_i64PCHEalthSequenceNo);
			break;
		}

		Bool fRes = UnlockInstallServer((iesState == iesSuspend) ? fTrue : fFalse); //!! error
		m_fServerLocked = fFalse;

	}
	
	// reset Resume and UpdateStarted properties
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUME),g_MsiStringNull));
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUMEOLD),g_MsiStringNull));
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_UPDATESTARTED),g_MsiStringNull));

	m_issSegment = issPostExecution;
	return iesReturn;
}


urtEnum g_urtLoadFromURTTemp = urtSystem; // global, to remember where to load mscoree from

iesEnum CMsiEngine::RunScript(bool fForceIfMergedChild)
{
	// runs any spooled script operations
	if(m_fServerLocked == fFalse)
	{
		PMsiRecord pError = PostError(Imsg(idbgErrorRunningScript));
		return FatalError(*pError);
	}

	iesEnum iesState = iesSuccess;

	// drop fusion and mscoree, if loaded
	// this will allow us to reload these dlls from the temp folder, if present, the next time we need them (in the executor)
	FUSION::Unbind();
	MSCOREE::Unbind();

	MsiString strCarryingNDP = GetPropertyFromSz(IPROPNAME_CARRYINGNDP);
	if(strCarryingNDP.Compare(iscExactI, IPROPVALUE__CARRYINGNDP_URTREINSTALL))
		g_urtLoadFromURTTemp = urtPreferURTTemp;
	else if(strCarryingNDP.Compare(iscExactI, IPROPVALUE__CARRYINGNDP_URTUPGRADE))
		g_urtLoadFromURTTemp = urtRequireURTTemp;
	else g_urtLoadFromURTTemp = urtSystem;


	if(m_pExecuteScript)
	{
		Assert(m_ixmExecuteMode == ixmScript);
		Assert(m_pistrExecuteScript);
		Assert(!m_fMergingScriptWithParent);
		DEBUGMSG1(TEXT("Running Script: %s"),m_pistrExecuteScript->GetString());
		//!! do we really have to set iefOperations false here, or can be do it below?
		SetMode(iefOperations,fFalse); // not processing operations anymore
		SetProperty(*MsiString(*IPROPNAME_UPDATESTARTED), *MsiString(*TEXT("1")));
		m_pExecuteScript->SetProgressTotal(m_iProgressTotal);
		delete m_pExecuteScript, m_pExecuteScript = 0;
		m_scmScriptMode = scmRunScript;
		
		// Reset script progress record to prevent further progress ticks should
		// another script be generated later
		m_pScriptProgressRec = 0;

		AssertSz(m_piConfigManager, "Attempt to call RunScript from the client side of a client-server connection.");

		// if rollback was disabled in the middle of script generation iefRollbackEnabled is currently unset
		// but we still need to enable rollback for the start of script execution
		// ixoDisableRollback will then turn off rollback in the middle of the script
		Bool fRollbackEnabled = ToBool(m_fDisabledRollbackInScript || GetMode() & iefRollbackEnabled);
		m_fDisabledRollbackInScript = fFalse;
		
		iesState = m_piConfigManager->RunScript(m_pistrExecuteScript->GetString(), *this, this, fRollbackEnabled);
		if(iesState == iesFinished)
			iesState = iesSuccess;  // we may not really be finished yet
		if (iesState == iesSuspend)
		{
			AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_REPLACEDINUSEFILES),1));
			SetMode(iefReboot, fTrue);
			iesState = iesSuccess;
		}
		BOOL fRes = FALSE;
		{
			CElevate elevate;
			fRes = WIN::DeleteFile(m_pistrExecuteScript->GetString());
		}
#ifdef DEBUG
		if(!fRes)
		{
			ICHAR rgchDebug[1025];
			ASSERT_IF_FAILED(StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug),
					TEXT("Could not delete install script %s. Server probably crashed. Please save install script and .rbs files in \\config.msi for debugging."),
					m_pistrExecuteScript->GetString()));
			AssertSz(0,rgchDebug);
		}
#endif //DEBUG
		m_pistrExecuteScript->Release();
		m_pistrExecuteScript = 0;
		m_scmScriptMode = scmIdleScript;
	}
	else if (m_fMergingScriptWithParent && (GetMode() & iefOperations))
	{
		// send null productinfo record to switch back to parent info in the script
		PMsiRecord precNull = &m_riServices.CreateRecord(0); //!! use global null record
		iesState = ExecuteRecord(ixoProductInfo, *precNull);  // can't set iefOperations false until after this

		// script execution could be forced within a merged child install
		if((iesState == iesSuccess || iesState == iesNoAction) && fForceIfMergedChild && m_piParentEngine)
		{
			iesState = m_piParentEngine->RunScript(fForceIfMergedChild);
		}
	}
	SetMode(iefOperations,fFalse); // no more spooled operations
	
	g_urtLoadFromURTTemp = urtSystem; // must reset before returning from this function
	return iesState;
}

// ValidateProductID: should only be called through ValidateProductID action or Control Event
Bool CMsiEngine::ValidateProductID(bool fForce)
{
	if (MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTID)).TextSize())
	{
		if(fForce)
			// forcing validation - reset ProductID
			SetProperty(*MsiString(*IPROPNAME_PRODUCTID),g_MsiStringNull);
		else
			// not forcing validation, and pid already validated, so just return
			return fTrue;
	}

	MsiString strTemplate(GetPropertyFromSz(IPROPNAME_PIDTEMPLATE));
	MsiString strOut;
	MsiString strFirst;
	if (strTemplate.Compare(iscWithin, TEXT("<")))
	{
		strFirst = strTemplate.Extract(iseUpto, '<');
		if (strFirst.TextSize())
			strFirst += MsiString(*TEXT("-"));
		strTemplate.Remove(iseIncluding, '<');
	}
	MsiString strLast;
	if (strTemplate.Compare(iscWithin, TEXT(">")))
	{
		strLast = strTemplate.Extract(iseAfter, '>');
		if (strLast.TextSize())
			strLast = MsiString(*TEXT("-")) + strLast;
		strTemplate.Remove(iseFrom, '>');
	}
	MsiString strBack;
	if (strFirst.TextSize())
	{
		strBack = ValidatePIDSegment(*strFirst, fFalse);
		if (strBack.TextSize())
			strOut += strBack;
		else
			return fFalse;
	}
	strBack = ValidatePIDSegment(*strTemplate, fTrue);
	if (strBack.TextSize())
		strOut += strBack;
	else
		return fFalse;
	if (strLast.TextSize())
	{
		strBack = ValidatePIDSegment(*strLast, fFalse);
		if (strBack.TextSize())
			strOut += strBack;
		else
			return fFalse;
	}
	MsiString strNull;
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_PRODUCTID), *strOut));
	return fTrue;
}

const IMsiString& CMsiEngine::ValidatePIDSegment(const IMsiString& ristrSegment, Bool fUser)
{
	MsiString strNull;
	MsiString strOut;
	ristrSegment.AddRef();
	MsiString strIn;
	if (fUser)
		strIn = GetPropertyFromSz(IPROPNAME_PIDKEY);
	MsiString strTemplate(ristrSegment);
	MsiString strCurrentTemplate;
	MsiString strCurrentIn;
	MsiString strCheckSum;
	Bool fUpdateFound =  fFalse;
	int iRandomMask = 1;
	Bool fNeedUserEntry = ToBool(strTemplate.Compare(iscWithin, TEXT("#")) || strTemplate.Compare(iscWithin, TEXT("%")) ||
		strTemplate.Compare(iscWithin, TEXT("=")) || strTemplate.Compare(iscWithin, TEXT("^")) ||
		strTemplate.Compare(iscWithin, TEXT("&")) || strTemplate.Compare(iscWithin, TEXT("?")));
	if (fUser && fNeedUserEntry && strIn.TextSize() != strTemplate.TextSize())
		strTemplate = strNull;
	while (strTemplate.TextSize())
	{
		strCurrentTemplate = strTemplate.Extract(iseFirst, 1);
		strTemplate.Remove(iseFirst, 1);
		strCurrentIn = strIn.Extract(iseFirst, 1);
		strIn.Remove(iseFirst, 1);
		if (MsiString(*TEXT("#%")).Compare(iscWithin, strCurrentTemplate))
		{
			if (!fUser) // can occur only in the user visible part
			{
				strOut = strNull;
				break;
			}
			int iCurrent = strCurrentIn;
			if (iCurrent == iMsiNullInteger) // not an integer
			{
				strOut = strNull;
				break;
			}
			strOut += strCurrentIn;
			if (MsiString(*TEXT("%")).Compare(iscExact, strCurrentTemplate))
				strCheckSum += strCurrentIn;
		}
		else if (MsiString(*TEXT("@")).Compare(iscExact, strCurrentTemplate))
		{
			if (fUser && fNeedUserEntry)  // should not be in the user visible part
			{
				strOut = strNull;
				break;
			}
			unsigned int uiTick = WIN::GetTickCount();
			uiTick /= iRandomMask;
			iRandomMask *= 10;
			strOut += MsiString(int(uiTick) % 10);
		}
		else if (MsiString(*TEXT("=")).Compare(iscExact, strCurrentTemplate))
		{
			if (!fUser || fUpdateFound) // can occur only in the user visible part and only once
			{
				strOut = strNull;
				break;
			}
			fUpdateFound = fTrue;
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_CCPTRIGGER), *strCurrentIn));
			strOut += MsiString(*TEXT("-"));
		}
		else if (MsiString(*TEXT("^&")).Compare(iscWithin, strCurrentTemplate))
		{
			if (!fUser) // can appear only in the user visible part
			{
				strOut = strNull;
				break;
			}
			ICHAR ch = ((const ICHAR *)strCurrentIn)[0];
			if (!(('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')))
			{
				strOut = strNull;
				break;
			}
			if (MsiString(*TEXT("^")).Compare(iscExact, strCurrentTemplate))
				strCurrentIn.UpperCase();
			strOut += strCurrentIn;
		}
		else if (MsiString(*TEXT("?")).Compare(iscExact, strCurrentTemplate))
		{
			strOut += strCurrentIn;

		}
		else if (MsiString(*TEXT("<>")).Compare(iscWithin, strCurrentTemplate))
			// should not be any more of these left in the string
		{
			strOut = strNull;
			break;
		}
		else
		{
			if (!fUser || !fNeedUserEntry || strCurrentTemplate.Compare(iscExact, strCurrentIn)) // literal constant should match exactly
			{
				strOut += strCurrentTemplate;
			}
			else
			{
				strOut += strNull;
				break;
			}
		}
	}
	if (fUser && strCheckSum.TextSize() && !PIDCheckSum(*strCheckSum))
	{
		strOut = strNull;
	}
	const IMsiString* piStr = strOut;
	piStr->AddRef();
	return *piStr;
}

Bool CMsiEngine::PIDCheckSum(const IMsiString& ristrDigits)
{
	int iDigit = 0;
	int iSum = 0;
	const ICHAR* pch;
	pch = ristrDigits.GetString();
	while (*pch)
	{
		iDigit = *pch - '0';
		iSum += iDigit;
		pch++;
	}
	return ToBool(!(iSum % 7));
}

CMsiFile* CMsiEngine::GetSharedCMsiFile()
{
	if (TestAndSet(&m_fcmsiFileInUse))
	{
		AssertSz(fFalse, "Two users of the shared CMsiFile");
		return 0;
	}

	if (m_pcmsiFile == 0)
	{
		m_pcmsiFile = new CMsiFile(*this);
	}

	return m_pcmsiFile;


}

void CMsiEngine::ReleaseSharedCMsiFile()
{

	m_fcmsiFileInUse = 0;

}

//____________________________________________________________________________
//
// Internal engine methods
//____________________________________________________________________________

/*----------------------------------------------------------------------------
CMsiEngine::ValidateTransform - Returns ievtTransformValie if the given transform is a
storage, and the database meets all requirements that the transform specifies
(version, language, product, etc.)  iTransErrors will be set to conditions
specified by the transform to be treated as errors. (iteXXXX flags)

  if fCallSAFER is true, performs a SaferIdentifyLevel call on the transform;
   - tranform must pass SAFER check to return fTrue
------------------------------------------------------------------------------*/
ievtEnum CMsiEngine::ValidateTransform(IMsiStorage& riStorage, const ICHAR* szProductKey,
											  const ICHAR* szProductVersion, const ICHAR* szUpgradeCode,
											  int& iTransErrorConditions, bool fCallSAFER, const ICHAR* szFriendlyName, bool fSkipValidation,
											  int* piTransValidationConditions)
{
	PMsiRecord pError(0);
	int iTransRestrictions = 0;

	if (piTransValidationConditions)
		*piTransValidationConditions = 0;

	MsiString strTransform;
	AssertRecord(riStorage.GetName(*&strTransform));

	PMsiSummaryInfo pTransSummary(0);
	if ((pError = riStorage.CreateSummaryInfo(0, *&pTransSummary)))
	{
		pError = PostError(Imsg(idbgTransformCreateSumInfoFailed), *strTransform);
		Message(imtInfo,*pError);
		return ievtTransformFailed;
	}

	// check that the storage is actually an MSI transform
	if (!riStorage.ValidateStorageClass(ivscTransform))
		return ievtTransformFailed;
	

	// perform SAFER policy check
	if (fCallSAFER)
	{
		SAFER_LEVEL_HANDLE hSaferLevel = 0;
		if (!VerifyMsiObjectAgainstSAFER(m_riServices, &riStorage, strTransform, /* szFriendlyName = */ szFriendlyName, stTransform, /* phSaferLevel = */ &hSaferLevel))
			return ievtTransformRejected;
		AssertNonZero(UpdateSaferLevelInMessageContext(hSaferLevel));
	}


	int iTransMsiVersion = 0;
	
	MsiString istrTransTemplate(pTransSummary->GetStringProperty(PID_TEMPLATE));
	MsiString istrTransRevNumber(pTransSummary->GetStringProperty(PID_REVNUMBER));
	iTransRestrictions = 0;
	pTransSummary->GetIntegerProperty(PID_CHARCOUNT, iTransRestrictions);
	
	if (pTransSummary->GetIntegerProperty(PID_PAGECOUNT, iTransMsiVersion) == fFalse)
	{
		pError = PostError(Imsg(idbgTransformLacksMSIVersion), *strTransform);
		Message(imtInfo,*pError);
		return ievtTransformFailed;
	}
	
	// check the engine and services versions against that required by transform
	if (iTransMsiVersion < iVersionEngineMinimum || iTransMsiVersion > iVersionEngineMaximum)
	{
		pError = PostError(Imsg(idbgTransformIncompatibleVersion), *strTransform, *MsiString(iTransMsiVersion),
							iVersionEngineMinimum, iVersionEngineMaximum);
		Message(imtInfo,*pError);
		return ievtTransformFailed;
	}

	int iTransValidation = (0xFFFF0000 & iTransRestrictions) >> 16;
	if (piTransValidationConditions)
		*piTransValidationConditions = iTransValidation;

	iTransErrorConditions = iTransRestrictions & 0xFFFF;

	if(fSkipValidation)
	{
		DEBUGMSG1(TEXT("Skipping transform validation for '%s'"), strTransform);
		return ievtTransformValid;
	}

	ICHAR rgchBits[9];
	StringCchPrintf(rgchBits, sizeof(rgchBits)/sizeof(ICHAR), TEXT("%#x"),iTransValidation);
	DEBUGMSG2(TEXT("Validating transform '%s' with validation bits %s"),strTransform,rgchBits);

	if (iTransValidation & itvLanguage)
	{
		MsiString istrTransLanguage = istrTransTemplate.Extract(iseAfter, ISUMMARY_DELIMITER);
		if ((int)istrTransLanguage != GetLanguage())
		{
			pError = PostError(Imsg(idbgTransformInvalidLanguage),*strTransform,*m_strPackagePath,
									 (int)istrTransLanguage,GetLanguage());
			DEBUGMSG(MsiString(pError->FormatText(fTrue)));
			Message(imtInfo,*pError);
			return ievtTransformFailed;
		}
	}
	if (iTransValidation & itvProduct)
	{
		MsiString istrTransProductCode(istrTransRevNumber.Extract(iseFirst, 38));
		if (istrTransProductCode.Compare(iscExactI, szProductKey) == fFalse)
		{
			pError = PostError(Imsg(idbgTransformInvalidProduct),*strTransform,*m_strPackagePath,
									 *istrTransProductCode,*MsiString(szProductKey));
			DEBUGMSG(MsiString(pError->FormatText(fTrue)));
			Message(imtInfo,*pError);
			return ievtTransformFailed;
		}
	}

	if (iTransValidation & itvUpgradeCode)
	{
		MsiString istrUpgradeCode = istrTransRevNumber;
		istrUpgradeCode.Remove(iseIncluding, ';'); // remove old product code & version
		unsigned int cch = istrUpgradeCode.TextSize();
		istrUpgradeCode.Remove(iseIncluding, ';'); // remove new product code & version
		
		if (istrUpgradeCode.TextSize() != cch)
		{
			if (istrUpgradeCode.Compare(iscExactI, szUpgradeCode) == fFalse)
			{
				pError = PostError(Imsg(idbgTransformInvalidUpgradeCode),*strTransform,*m_strPackagePath,
										 *istrUpgradeCode,*MsiString(szUpgradeCode));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		// else there was no 2nd ';' and therefore no upgrade code
	}

	if ((iTransValidation & (itvMajVer|itvMinVer|itvUpdVer)) != 0)
	{
		MsiString istr  = istrTransRevNumber;
		istr.Remove(iseFirst, 38); // remove old product code
		MsiString istrTransAppVersion = istr.Extract(iseUpto, ';');

		unsigned int iAppVersion      = ProductVersionStringToInt(szProductVersion);
		unsigned int iTransAppVersion = ProductVersionStringToInt(istrTransAppVersion);

		if(iTransValidation & itvMajVer)
		{
			iAppVersion &= 0xFF000000;
			iTransAppVersion &= 0xFF000000;
		}
		else if(iTransValidation & itvMinVer)
		{
			iAppVersion &= 0xFFFF0000;
			iTransAppVersion &= 0xFFFF0000;
		}
		// else itvUpdVer: don't need to mask off bits

		if (iTransValidation & itvLess)
		{
			if (!(iAppVersion < iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidLTVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		else if (iTransValidation & itvLessOrEqual)
		{
			if (!(iAppVersion <= iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidLEVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		else if (iTransValidation & itvEqual)
		{
			if (!(iAppVersion == iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidEQVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		if (iTransValidation & itvGreaterOrEqual)
		{
			if (!(iAppVersion >= iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidGEVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		else if (iTransValidation & itvGreater)
		{
			if (!(iAppVersion > iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidGTVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
	}
	DEBUGMSG1(TEXT("Transform '%s' is valid."), strTransform);
	return ievtTransformValid;
}

#ifndef UNICODE
// from execute.cpp
extern IMsiRecord* GetSecureTransformCachePath(IMsiServices& riServices, 
										const IMsiString& riProductKey, 
										IMsiPath*& rpiPath);

IMsiRecord* GetSecureTransformPath(const IMsiString& riTransformName, 
								   const IMsiString& riProductKey, 
								   const IMsiString*& rpiSecurePath, IMsiServices& riServices)
{
	IMsiRecord* piError = 0; 
	
	PMsiPath pSecureTransformCachePath(0);
	if ((piError = GetSecureTransformCachePath(riServices, 
		riProductKey, 
		*&pSecureTransformCachePath)) != 0)
		return piError;

	MsiString strSecurePath = pSecureTransformCachePath->GetPath();
	strSecurePath += riTransformName;

	strSecurePath.ReturnArg(rpiSecurePath);
	return 0;
}
#endif

IMsiRecord* ExpandShellFolderTransformPath(const IMsiString& riOriginalPath, const IMsiString*& riExpandedPath, IMsiServices& riServices)
{
	IMsiRecord* piError = 0;
	MsiString strExpandedPath = riOriginalPath;
	riOriginalPath.AddRef();
	
	strExpandedPath.Remove(iseFirst, 1);
	MsiString strCSIDL = strExpandedPath.Extract(iseUpto, MsiChar(SHELLFOLDER_TOKEN));
	strExpandedPath.Remove(iseIncluding, MsiChar(SHELLFOLDER_TOKEN));

	Assert((int)strCSIDL != iMsiStringBadInteger);
	MsiString strShellFolderPath;
	if ((piError = riServices.GetShellFolderPath(strCSIDL, false, *&strShellFolderPath)) != 0)
		return piError;

	Assert(strShellFolderPath.TextSize());
	strShellFolderPath += strExpandedPath;
	strExpandedPath = strShellFolderPath;
	strExpandedPath.ReturnArg(riExpandedPath);
	return piError;
}

/*----------------------------------------------------------------------------
CMsiEngine::InitializeTransforms - Parses the TRANSFORMS property, setting
each transform.
------------------------------------------------------------------------------*/
ieiEnum CMsiEngine::InitializeTransforms(IMsiDatabase& riDatabase, IMsiStorage* piStorage,
												  const IMsiString& riTransforms,
												  Bool fValidateAll, const IMsiString** ppistrValidTransforms,
												  bool fTransformsFromPatch,
												  bool fProcessingInstanceMst,
#ifdef UNICODE
												  bool fUseLocalCacheForSecureTransforms,
#else
												  bool, // unused on Win9X
#endif
												  int *pcTransformsProcessed,
												  const ICHAR* szSourceDir,
												  const ICHAR* szCurrentDirectory,
												  const IMsiString** ppistrRecacheTransforms,
												  tsEnum *ptsTransformsSecure,
												  const IMsiString **ppistrProcessedTransformsList)


	// piStorage:
	//    if set, it contains transform substorages, otherwise transforms are in riDatabase
	// pcTransformsProcessed:
	//    the count of how many transforms in the list have been processed so far
	// ppistrProcessedTransformsList:
	//    We might munge the transform list as we're processing it. For example if we're
	//    given a full path but the TransformsAtSource policy is set then we'll chop off
	//    everything but the file name. If we're given just the file name but the
	//    transforms secure policy is set then we'll prepend the source directory.
	//    After we're done pistrProcessedTransformsList will contain the processed
	//    (or munged) version of the transform list. The list will reflect any chopping
	//    of paths or prepending of paths.
	//
{

	// whether or not a SAFER check is performed on transform (via ValidateTransform)
	// turned off if transform is cached or is a substorage
	bool fCallSAFER = true;


	MsiString strProcessedTransformsList;

	// In case this function was called for the second time we'll start our
	// list with whatever we had the last time this function was called.
	// IMPORTANT NOTE: because ppistrProcessedTransformsList is an output
	// argument, it also has an external refcount.  Using strProcessedTransformsList
	// inherits this refcount so a release on the outside would be a double-free.
	// Therefore, we need to always use:
	//			if (ppistrProcessedTransformsList)
	//				strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
	// wherever we have a return from this function so that we ensure that the refcount
	// is accurate
	if (ppistrProcessedTransformsList)
		strProcessedTransformsList = **ppistrProcessedTransformsList;

	MsiString istrTransformList(riTransforms); riTransforms.AddRef();
	if (istrTransformList.TextSize() != 0)
	{
		const ICHAR* pchTransformList = istrTransformList;
		MsiString istrTransform(*TEXT(""));
		CTempBuffer<ICHAR, 100> cBuffer;
		cBuffer.SetSize(istrTransformList.TextSize() + 1);
		if ( ! (ICHAR *) cBuffer )
		{
			if (ppistrProcessedTransformsList)
				strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
			return ieiTransformFailed;
		}
		ICHAR *pchTransform = cBuffer;
		PMsiRecord pError(0);
		
		MsiString strCurrentDirectory = szCurrentDirectory;

		bool fEmbeddedTransform = false;
		bool fCachedTransform = false;
		ievtEnum ievt = ievtTransformValid;
		int cTransforms = 0;
		bool fSmallUpdatePatch = false;
		bool fMissingVersionValidationMinorUpdatePatch = false;
		for (;;)
		{
			// Find the next transform to process. If pcTransformProcessed is set then
			// *pcTransformProcessed is the number of transforms we already processed
			// during the last call to this function. We'll skip those transforms
			// this time around.
			do {
				ICHAR *pch = pchTransform;
				*pch = 0;
				while (*pchTransformList == ' ') // eat spaces
					pchTransformList++;

				while ( (*pchTransformList != 0) && (*pchTransformList != ';') )
					*pch++ = *pchTransformList++;

				if (*pchTransformList == ';')
					pchTransformList++;

				*pch = 0; // null terminate
			} while (pcTransformsProcessed != 0 && cTransforms++ < *pcTransformsProcessed);

			MsiString strCurrentProcessTransform;
	
			if (*pchTransform != 0)
			{
				PMsiStorage pTransStorage(0);
				MsiString strTransform;

				// Skip the secure token, if present. We'll rely soly on
				// ptsTransformsSecure to determine whether or not we have
				// secure transforms.
				if (*pchTransform == SECURE_RELATIVE_TOKEN || *pchTransform == SECURE_ABSOLUTE_TOKEN)
				{
					// Skip the secure token
					pchTransform++;
				}

				// Next we need to actually open the transform storage. For
				// storage transforms this is easy -- we simply attempt
				// to open a child storage. For other types of transforms we
				// have to do a bit more work.

				bool fPatchTransform = false;

				if (*pchTransform == STORAGE_TOKEN) // child storage
				{
					// need to turn off digital signature check below
					fEmbeddedTransform = true;

					// Storage transforms are added to the processed list
					// with their STORAGE_TOKEN intact

					if (strProcessedTransformsList.TextSize() > 1)
						strProcessedTransformsList += MsiChar(';');
					strProcessedTransformsList += pchTransform;

					strTransform = pchTransform+1; // skip the storage token
					DEBUGMSG1(TEXT("Looking for storage transform: %s"), strTransform);

					if(*((const ICHAR*)strTransform) == PATCHONLY_TOKEN)
						fPatchTransform = true;

					PMsiStorage pDbStorage(0);
					if(piStorage)
					{
						pDbStorage = piStorage;
						piStorage->AddRef();
					}
					else
						pDbStorage = riDatabase.GetStorage(1);

					if (pDbStorage == 0)
						pError = PostError(Imsg(idbgNoTransformAsChild),*strTransform,*m_strPackagePath);
					else
						pError = pDbStorage->OpenStorage(strTransform, ismReadOnly, *&pTransStorage);

					if(pError)
					{
						if (ppistrProcessedTransformsList)
							strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
						return PostInitializeError(pError,*strTransform,ieiTransformFailed);
					}
					Assert(pTransStorage);
				}
				else // transform is in a file either locally or at the source
				{
					MsiString strFileTransform = pchTransform;

					// We potentially go through this loop twice to accomodate
					// missing transforms. This first time through we'll look
					// in the expected location for the transform, i.e. cached
					// somewhere on the user's machine. If we can't find the
					// transform on the user's machine then we'll go through
					// a second time and we'll look at the original location
					// of the transform.
					for (int cAttempt=0; cAttempt<2; cAttempt++)
					{
						if (*(const ICHAR*)strFileTransform == SHELLFOLDER_TOKEN) // transform is cached
						{
							// Shell-folder cached transfoms are easy. All we need to
							// do is expand the *26*... format into a full path.

							// transform is cached on machine, so no SAFER check is needed
							fCachedTransform = true;

							strCurrentProcessTransform = strFileTransform;

							if ((pError = ExpandShellFolderTransformPath(*strFileTransform, *&strTransform, m_riServices)))
							{
								if (ppistrProcessedTransformsList)
									strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
								return PostInitializeError(pError, *strFileTransform, ieiTransformNotFound);
							}

							DEBUGMSG1(TEXT("Looking for file transform in shell folder: %s"), (const ICHAR*)strTransform);
						}
						else if (ptsTransformsSecure && (*ptsTransformsSecure != tsNo)) // we have some type of secure transform
						{
							// First time around we look for the secure transform on the
							// user's machine in the secure transform cache.
							if (cAttempt == 0)
							{
								// We know that we have a secure transform of some form.
								// If the form is unknown we'll determine it now, based
								// on what type of path the transform has. Otherwise
								// we'll simply ensure that the path-type of our
								// transform matches the form of secure transforms
								// that we're using.
								iptEnum iptTransform = PathType(strFileTransform);
								switch (*ptsTransformsSecure)
								{
								case tsUnknown:
									if (iptTransform == iptFull)
										*ptsTransformsSecure = tsAbsolute;
									else
										*ptsTransformsSecure = tsRelative;
									break;
								case tsRelative:
									if (iptTransform != iptRelative)
									{
										if (ppistrProcessedTransformsList)
											strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
										return PostInitializeError(0, *strTransform, ieiTransformFailed);
									}
									break;
								case tsAbsolute:
									if (iptTransform != iptFull)
									{
										if (ppistrProcessedTransformsList)
											strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
										return PostInitializeError(0, *strTransform, ieiTransformFailed);
									}
									break;
								default:
									AssertSz(0, TEXT("Unknown secure transform type"));
								}
								
								// We register the transform as-is (with either a full
								// or relative path).
								strCurrentProcessTransform = strFileTransform;
#ifdef UNICODE
								if(fUseLocalCacheForSecureTransforms)
								{
									// check to see if the transform is cached locally
									// check for the transform registration and path
									MsiString strCurrentProductCode = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
									CRegHandle HKey;
									DWORD dwResult = OpenInstalledProductTransformsKey(strCurrentProductCode, HKey, false);
									if (ERROR_SUCCESS == dwResult)
									{
										// check for the appropriate registration
										CAPITempBuffer<ICHAR, MAX_PATH> szCachedTransform;
										if (ERROR_SUCCESS == MsiRegQueryValueEx(HKey, strFileTransform, 0, 0, szCachedTransform, 0))
										{
											// use the cached transform filename
											MsiString strCachePath = GetMsiDirectory();
											Assert(strCachePath.TextSize());
											PMsiPath pTransformPath(0);
											if((pError = m_riServices.CreatePath(strCachePath,*&pTransformPath)) != 0)
											{
												if (ppistrProcessedTransformsList)
													strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
												return PostInitializeError(pError, *strTransform, ieiTransformFailed);
											}
											if((pError = pTransformPath->GetFullFilePath(szCachedTransform,*&strTransform)))
											{
												if (ppistrProcessedTransformsList)
													strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
												return PostInitializeError(pError, *strTransform, ieiTransformFailed);
											}
	
											fCachedTransform = true;
										}
	
									}
								}
#else
								// While we register the full path if we have it, to
								// _find_ the transform this time around we only need
								// the file name. This is because the first time
								// around we're looking in the cache so the transforms
								// location is CACHEPATH\filename.mst
								MsiString strFileName = strFileTransform;
								if (iptTransform == iptFull)
								{
									// strip the full path off
									MsiString strDummy;
									MsiString strTemp = strFileName;
									if ((pError = SplitPath(strTemp, &strDummy, &strFileName)) != 0)
									{
										if (ppistrProcessedTransformsList)
											strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
										return PostInitializeError(pError, *strFileTransform, ieiTransformNotFound);
									}
								}

								// Now all that's left is to tack the file name onto
								// the path to the secure transforms directory for
								// this product. GetSecureTransformPath() will do this
								// for us.
								MsiString strCurrentProductCode  = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
								if ((pError = GetSecureTransformPath(*strFileName, *strCurrentProductCode, *&strTransform, m_riServices)) != 0)
								{
									if (ppistrProcessedTransformsList)
										strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
									return PostInitializeError(pError, *strTransform, ieiTransformNotFound);
								}

								fCachedTransform = true;                        

#endif
							}
							else // cAttempt == 1 (second time around)
							{
								// If we're going around for a second time then we
								// didn't find the transforms on the user's machine.
								// We need to now look to the original location of
								// the transform. strFileTransform should have
								// already been set to the correct location by
								// the code down below so we'll simply use it as-is.

								// because it wasn't found on the machine, the SAFER check will have to be performed on the transform
								fCachedTransform = false;
								strTransform = strFileTransform;
							}

							DEBUGMSG1(TEXT("Looking for secure file transform: %s"), strTransform);
						}
						else // transform is a file transform to be cached
						{
							// The only processing we need to do on standard
							// file transforms is to make sure that they're
							// fully pathed.

							// SAFER check is required as this transform isn't cached on the machine
							fCachedTransform = false;

							CAPITempBuffer<ICHAR,MAX_PATH> rgchTransform;
							AssertNonZero(ExpandPath(strFileTransform, rgchTransform, strCurrentDirectory));
							strTransform = (const ICHAR*)rgchTransform;
							strCurrentProcessTransform = strTransform;

							DEBUGMSG1(TEXT("Looking for file transform: %s"), strTransform);
						}
						
						// We've finally reached the point where we can actually open
						// the transform! -- SAFER check is false here because we explicitly validate
						// the transform against SAFER policy down below
						// szFriendlyName is NULL because it is only needed when performing SAFER check
						// phSaferLevel is NULL because it is only needed when performing a SAFER check

						// copy the transform locally for usage if it is not from our cache location,
						// so that we don't suffer from network outages. If the transform is at a URL,
						// then it is automatically downloaded to a temp location in OpenAndValidateMsiStorageRec

						MsiString strOpenTransform = strTransform;
						bool fFileUrl = false;
						bool fUrl = IsURL(strOpenTransform, fFileUrl);
						if (!fCachedTransform && (!fUrl || fFileUrl))
						{
							// copy transform to temp location
							MsiString strVolume;
							Bool fRemovable = fFalse;
							DWORD dwStat = ERROR_SUCCESS;
							if (fFileUrl)
							{
								// convert file:// url path to DOS path
								CTempBuffer<ICHAR, 1> rgchFilePath (cchExpectedMaxPath + 1);
								DWORD cchFilePath = rgchFilePath.GetSize();
								if (MsiConvertFileUrlToFilePath(strTransform, rgchFilePath, &cchFilePath, 0))
								{
									dwStat = CopyTempDatabase(rgchFilePath, *&strOpenTransform, fRemovable, *&strVolume, m_riServices, stTransform);
								}
								else
								{
									// error, set status and we'll fail down below
									dwStat = ERROR_FUNCTION_FAILED;
								}

								// turn off fUrl since we've converted it to the DOS path
								fUrl = false;
							}
							else
							{
								dwStat = CopyTempDatabase(strTransform, *&strOpenTransform, fRemovable, *&strVolume, m_riServices, stTransform);
							}
							if (ERROR_SUCCESS == dwStat)
							{
								// transform was copied
								DEBUGMSGV1(TEXT("Original transform ==> %s"), strTransform);
								DEBUGMSGV1(TEXT("Transform we're running from ==> %s"), strOpenTransform);

								AddFileToCleanupList(strOpenTransform);
							}
							else
							{
								strOpenTransform = strTransform;
								DEBUGMSGV1(TEXT("Unable to create a temp copy of transform '%s'."), strTransform);
							}
						}

						pError = OpenAndValidateMsiStorageRec(strOpenTransform, stTransform, m_riServices, *&pTransStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);

						if (!fCachedTransform && fUrl && MinimumPlatformWindowsDotNETServer() && pTransStorage)
						{
							MsiString strDownload;
							AssertRecord(pTransStorage->GetName(*&strDownload));
							AddFileToCleanupList(strDownload);
						}

						if (pError)
						{
							// Uh-oh. Something went wrong in opening the transform.
							if ((cAttempt == 0) &&
								  (pError->GetInteger(3) == STG_E_FILENOTFOUND ||
								   pError->GetInteger(3) == STG_E_PATHNOTFOUND))
							{
								// It's our first attempt at finding the transform and
								// the error was just that we couldn't find it. We'll
								// determine where the original location of the
								// transform is, set strFileTransform to that location,
								// and go around for a second attempt at opening
								// the transform.
								
								if (*(const ICHAR*)strFileTransform != STORAGE_TOKEN)
								{
									Assert(ptsTransformsSecure);
									if (ptsTransformsSecure)
									{
										DEBUGMSG2(TEXT("Couldn't find cached transform %s. Looking for it at the %s."), strTransform, (*ptsTransformsSecure == tsAbsolute) ? TEXT("original location") : TEXT("source"));

										// Absolutely pathed secure transforms are
										// already fully pathed. For relatively
										// pathed secure transforms, and for
										// non-secure transforms, we need to prepend
										// SOURCEDIR to the name of the transform.

										if (*ptsTransformsSecure == tsRelative ||
											 *ptsTransformsSecure == tsNo)
										{
											MsiString strSourceDir;
											if (szSourceDir && *szSourceDir)
											{
												strSourceDir = szSourceDir;
											}
											else
											{
												// Source-dir wasn't passed into this
												// function. We'll need to remedy that
												// by returning the special value
												// ieiResolveSourceAndRetry. This will
												// trigger to call us again, passing
												// in SOURCEDIR. Eventually we'll
												// end up just above here, with
												// szSourceDir set.
											
												if (ppistrProcessedTransformsList)
													strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);

												return (ieiEnum)ieiResolveSourceAndRetry;
											}
											
											PMsiPath pPath(0);
											MsiString strFileName;
											if (*ptsTransformsSecure == tsRelative)
											{
												// use the original filename NOT the temp path
												strFileName = strFileTransform;
											}
											else
											{
												if ((pError = m_riServices.CreateFilePath(strTransform, *&pPath, *&strFileName)))
												{
													if (ppistrProcessedTransformsList)
														strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
													return PostInitializeError(pError, *strTransform, ieiTransformNotFound);
												}
											}

											strFileTransform = strSourceDir;
											strFileTransform += strFileName;
										}
										else
										{
											Assert(*ptsTransformsSecure == tsAbsolute);
										}

										// let's try again
										continue;
									}
								}
								if (ppistrProcessedTransformsList)
									strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);

								return PostInitializeError(pError, *strTransform, ieiTransformNotFound);
							}
							else // (cAttempt == 1) || (some error other than not finding the transform occurred)
							{
								if (ppistrProcessedTransformsList)
									strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
								return PostInitializeError(pError, *strTransform, ieiTransformFailed);
							}
						}
						else  // pError == 0
						{
							// We've successfully opened the trasnform so we'll add
							// it to our "processed" list.
							if (strProcessedTransformsList.TextSize() > 1)
								strProcessedTransformsList += MsiChar(';');
							strProcessedTransformsList += strCurrentProcessTransform;
							strCurrentProcessTransform = *TEXT("");

							if (cAttempt==1 && ((m_iioOptions & iioCreatingAdvertiseScript) == 0))
							{
								// This was our second time around. This means that
								// we failed to find the transform on the user's machine
								// and we were forced to resort to looking to the
								// transform's original location. This implies that we
								// need to recache the trasnform, so we'll add it to
								// our re-cache list.

								Assert(ppistrRecacheTransforms);
								if (ppistrRecacheTransforms)
								{
									MsiString strRecache = **ppistrRecacheTransforms;
									
									if (strRecache.TextSize())
										strRecache += TEXT(";");

									strRecache += strTransform;
									strRecache.ReturnArg(*ppistrRecacheTransforms);

									DEBUGMSG1(TEXT("Found missing cached transform %s. Adding it to re-cache list."), strTransform);
								}
							}
						}
						break;
					}
				}
				
				// By this point we have opened the transform. We now need to
				// validate that this transform can be applied to this
				// database.

				MsiString strCurrentProductCode    = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
				MsiString strCurrentProductVersion = GetPropertyFromSz(IPROPNAME_PRODUCTVERSION);
				MsiString strUpgradeCode           = GetPropertyFromSz(IPROPNAME_UPGRADECODE);
				if(strCurrentProductCode.TextSize() == 0 || strCurrentProductVersion.TextSize() == 0)
				{
					//!! log error
					if (ppistrProcessedTransformsList)
						strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
					return ieiDatabaseInvalid;
				}
	
				if (pcTransformsProcessed)
					(*pcTransformsProcessed)++;

				int iTransErrorConditions = 0;
				int iTransValidationConditions = 0;

				// SAFER:
				//  -- if fCallSAFER has already been set to false, we won't perform SAFER check
				//  -- however, if fCallSAFER is true, we'll still evaluate whether or not trust check is warranted
				//  -- no trust check is warranted if at least one of the following conditions is true
				//        1. transform is an embedded transform (covered by package)
				//        2. transform is already cached securely on machine
				if (fCallSAFER)
				{
					// determine whether SAFER check still warranted
					if (fEmbeddedTransform)
						fCallSAFER = false; // turn off for transform as substorage
					if (fCachedTransform)
						fCallSAFER = false; // turn off for cached transform
				}

				if(fPatchTransform)
				{
					// don't validate patch transforms - they are accepted whenever the preceding transform is accepted
					if(ievt == ievtTransformValid)
					{
						//
						// SAFER -- no safer check is performed on patch transforms since the SAFER check is performed on the patch itself
						//          and patch transforms are embedded inside the patch (this should actually already be covered by
						//          fEmbeddedTransform, but just to drive this home...)
						//

						// only call to pull out error conditions
						ValidateTransform(*pTransStorage, strCurrentProductCode,
													 strCurrentProductVersion, strUpgradeCode,
													 iTransErrorConditions, /* fCallSAFER = */ false, /* szFriendlyName = */ strTransform, true, &iTransValidationConditions);

						DEBUGMSG1(TEXT("Skipping validation for patch transform %s.  Will apply because previous transform was valid"),
									 strTransform);
					}
					else
					{
						iTransErrorConditions = 0; // to appease the compiler - won't actually be used below

						DEBUGMSG1(TEXT("Skipping validation for patch transform %s.  Will not apply because previous transform was invalid"),
									 strTransform);
					}
				}
				else
				{
					//
					// SAFER -- regardless of whether we will call SAFER, go ahead and set the friendly name to strTransform
					//          This ensures that we get proper URL coverage since this may have been a transform at a URL location
					//

					ievt = ValidateTransform(*pTransStorage, strCurrentProductCode,
												 strCurrentProductVersion, strUpgradeCode,
												 iTransErrorConditions, fCallSAFER, /* szFriendlyName = */ strTransform, false, &iTransValidationConditions);
				}

				if(ievtTransformValid == ievt)
				{
					if ((pError = ApplyTransform(riDatabase, *pTransStorage, iTransErrorConditions, fPatchTransform, &m_ptsState)) != 0)
					{
						if (ppistrProcessedTransformsList)
							strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
						return PostInitializeError(pError,*strTransform,ieiTransformFailed);
					}
					if(ppistrValidTransforms)
					{
						if((*ppistrValidTransforms)->TextSize())
							(*ppistrValidTransforms)->AppendString(TEXT(";"), *ppistrValidTransforms);
						(*ppistrValidTransforms)->AppendString(pchTransform, *ppistrValidTransforms);
					}

					// detect when we are applying a small update patch
					// when we are, we want to only apply the first set of transforms and then stop
					// in other words, if we are applying a patch, and we detect that one of the non-patch transforms
					// didn't change the ProductCode or ProductVersion, then we will apply the second in the set of transforms
					// (the transform where fPatchTransform == true) and then quit.
					// see Whistler bug 339781 for more info

					// detect when the transform didn't specify a check for the ProductVersion in the transform validation conditions
					// if so, and the patch transform isn't changing the product code (small update or minor update), then skip the
					// remaining set of transforms.  see Whistler bug 363989 for more info

					if(fTransformsFromPatch)
					{
						if(false == fPatchTransform)
						{
							MsiString strNewProductCode    = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
							MsiString strNewProductVersion = GetPropertyFromSz(IPROPNAME_PRODUCTVERSION);
							
							if(strNewProductCode.Compare(iscExactI, strCurrentProductCode))
							{
								MsiString strNewProductVersion = GetPropertyFromSz(IPROPNAME_PRODUCTVERSION);
								unsigned int iOldVersion = ProductVersionStringToInt(strCurrentProductVersion);
								unsigned int iNewVersion = ProductVersionStringToInt(strNewProductVersion);

								if(iOldVersion == iNewVersion)
								{
									fSmallUpdatePatch = true;
								}
								else
								{
									// check transform validation conditions and see if this is bogus minor update patch
									// that does not include version check information
									if (!(iTransValidationConditions & (itvMajVer|itvMinVer|itvUpdVer))
										|| ((iTransValidationConditions & (itvMajVer|itvMinVer|itvUpdVer))
										&& !(iTransValidationConditions & (itvLess|itvLessOrEqual|itvEqual|itvGreaterOrEqual|itvGreater))))
									{
										fMissingVersionValidationMinorUpdatePatch = true;
									}
								}
							}
						}
						else if(fSmallUpdatePatch)
						{
							DEBUGMSG("Detected that this is a 'Small Update' patch.  Any remaining transforms in the patch will be skipped.");
							break; // done processing transforms
						}
						else if (fMissingVersionValidationMinorUpdatePatch)
						{
							DEBUGMSG("Detected that this patch is a 'Minor Update' patch without product version validation. Any remaining transforms in the patch will be skipped.");
							break; // done processing transforms
						}				
					}
				}
				else if(fValidateAll)
				{
					if (ppistrProcessedTransformsList)
						strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
					return PostInitializeError(0,*strTransform, (ievtTransformFailed == ievt) ? ieiTransformFailed : ieiTransformRejected);
				}
				// else just continue on

				fEmbeddedTransform = false; // reset
				fCachedTransform = false; // reset

			}

			if (*pchTransformList == 0)
				break;
		}
	}

	// if the secure transforms type is still tsUnknown then we don't
	// actually have any secure transforms in our list.
	// We only care about this if we have completed our processing of the transforms list
	// For the multi-instance transform, our processing isn't done yet, so we can't quite make
	// this determination
	if (!fProcessingInstanceMst && (ptsTransformsSecure && (*ptsTransformsSecure == tsUnknown)))
		*ptsTransformsSecure = tsNo;

	if (ppistrProcessedTransformsList)
	{
		// We need to mark the front of the processed transforms list with
		// the appropriate token if necessary.

		if (strProcessedTransformsList.TextSize())
		{
			if (ptsTransformsSecure && (*ptsTransformsSecure == tsRelative) &&
				(*(const ICHAR*)strProcessedTransformsList != SECURE_RELATIVE_TOKEN))
			{
				strProcessedTransformsList = MsiString(MsiChar(SECURE_RELATIVE_TOKEN)) + strProcessedTransformsList;
			}
			else if (ptsTransformsSecure && (*ptsTransformsSecure == tsAbsolute) &&
				(*(const ICHAR*)strProcessedTransformsList != SECURE_ABSOLUTE_TOKEN))
			{
				strProcessedTransformsList = MsiString(MsiChar(SECURE_ABSOLUTE_TOKEN)) + strProcessedTransformsList;
			}
		}

		strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
	}

	return ieiSuccess;
}

//____________________________________________________________________________
//
// IMsiDirectoryManager implementation
//____________________________________________________________________________

IMsiRecord* CMsiEngine::CreatePathObject(const IMsiString& riPathString,IMsiPath*& rpiPath)
// --------------------------------------
{
	IMsiRecord* piError = 0;
	IMsiRecord* piError2 = 0;
	for(;;)
	{
		// CreatePathObject: dispatches error message if CreatePath fails
		if((piError = m_riServices.CreatePath(riPathString.GetString(),rpiPath)) != 0)
		{
			int imsg = piError->GetInteger(1);
			switch(imsg)
			{
			case idbgErrorGettingVolInfo:
			case imsgPathNotAccessible:
				piError->Release();
				piError2 = PostError(Imsg(imsgErrorCreateNetPath), riPathString);
				switch(Message(imtEnum(imtError+imtRetryCancel),*piError2))
				{
				case imsRetry:
					piError2->Release();
					continue;
				default:
					piError2->Release(); //!! should return piError2
					return PostError(Imsg(imsgErrorCreateNetPath), riPathString); //!! Message prepends header every time // imsCancel, imsNone
				};
			default:
				return piError;
			};
		}
		else
			return 0;
	}
}

IMsiRecord* CMsiEngine::LoadDirectoryTable(const ICHAR* szTableName)
// ------------------------------------------------------------------
// szTableName may be left null to use default Directory table name
// ------------------------------------------------------------------
{
	m_fDirectoryManagerInitialized = fFalse;
	m_fSourceResolved = false;
	m_fSourcePathsCreated = false;
	m_fSourceSubPathsResolved = false;

	IMsiRecord* piError;
	if(szTableName == 0)
		szTableName = sztblDirectory;
	if ((piError = m_piDatabase->LoadTable(*MsiString(*szTableName), 4, m_piDirTable)))
	{
		if(piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			m_fDirectoryManagerInitialized = fTrue;
			return 0; // no directory table is OK
		}
		else
			return piError;
	}

	// authored columns
	m_colDirKey = m_piDirTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblDirectory_colDirectory));
	m_colDirParent = m_piDirTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblDirectory_colDirectoryParent));
	m_colDirSubPath = m_piDirTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblDirectory_colDefaultDir));
	if(!m_colDirKey || !m_colDirParent || !m_colDirSubPath)
		return PostError(Imsg(idbgTableDefinition), szTableName);

	// temporary columns
		
	// target path object
	m_colDirTarget = m_piDirTable->CreateColumn(icdObject + icdNullable, g_MsiStringNull);
	Assert(m_colDirTarget != 0);
	
	// source path object
	m_colDirSource = m_piDirTable->CreateColumn(icdObject + icdNullable, g_MsiStringNull);
	Assert(m_colDirSource != 0);
	
	// configurable flag
	m_colDirNonConfigurable = m_piDirTable->CreateColumn(icdShort + icdNullable, g_MsiStringNull);
	Assert(m_colDirNonConfigurable != 0);
	
	// preconfigured flag
	m_colDirPreconfigured = m_piDirTable->CreateColumn(icdLong + icdNullable, g_MsiStringNull);
	Assert(m_colDirPreconfigured != 0);

	// source sub-path (long names)
	m_colDirLongSourceSubPath = m_piDirTable->CreateColumn(icdString + icdNullable, g_MsiStringNull);
	Assert(m_colDirLongSourceSubPath != 0);
		
	// source sub-path (short names)
	m_colDirShortSourceSubPath = m_piDirTable->CreateColumn(icdString + icdNullable, g_MsiStringNull);
	Assert(m_colDirShortSourceSubPath != 0);
		
	// link tree for tree-walking cursors
	if(m_piDirTable->LinkTree(m_colDirParent) == -1)
		return PostError(Imsg(idbgLinkTable), szTableName);
	m_fDirectoryManagerInitialized = fTrue;
	return 0;
}

IMsiTable* CMsiEngine::GetDirectoryTable()
//--------------------------------------
{
	if (m_piDirTable)
		m_piDirTable->AddRef();
	return m_piDirTable;
}

void CMsiEngine::FreeDirectoryTable()
//---------------------------------
{
	if (m_piDirTable)
	{
		m_piDirTable->Release(); // releases all path objects
		m_piDirTable = 0;
	}
	m_fDirectoryManagerInitialized = fFalse;
	m_fSourceResolved = false;
	m_fSourcePathsCreated = false;
	m_fSourceSubPathsResolved = false;
}

const IMsiString& CMsiEngine::GetDefaultDir(const IMsiString& ristrValue, bool fSource)
{
	if(ristrValue.Compare(iscWithin,TEXT(":")))
	{
		return MsiString(ristrValue.Extract((fSource ? iseAfter : iseUpto),':')).Return();
	}
	else
	{
		ristrValue.AddRef();
		return ristrValue;
	}
}

void DebugDumpDirectoryTable(IMsiTable& riDirTable, bool fSource, int colKey, int colObject, int colLongSource, int colShortSource)
{
	if (!FDiagnosticModeSet(dmVerboseDebugOutput|dmVerboseLogging))
		return;

	DEBUGMSG1("%s path resolution complete. Dumping Directory table...",
				fSource ? "Source" : "Target");

	if(!fSource)
	{
		DEBUGMSG("Note: target paths subject to change (via custom actions or browsing)");
	}

	PMsiCursor pDumpCursor = riDirTable.CreateCursor(fTrue);

	while(pDumpCursor->Next())
	{
		PMsiPath pPath = (IMsiPath*)pDumpCursor->GetMsiData(colObject);
		MsiString strPath = TEXT("NULL");
		if(pPath)
			strPath = pPath->GetPath();

		if(fSource)
		{
			DEBUGMSG4(TEXT("Dir (source): Key: %s\t, Object: %s\t, LongSubPath: %s\t, ShortSubPath: %s"),
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colKey)),
					 (const ICHAR*)strPath,
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colLongSource)),
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colShortSource)));
		}
		else
		{
			DEBUGMSG2(TEXT("Dir (target): Key: %s\t, Object: %s"),
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colKey)),
					 (const ICHAR*)strPath);
		}
	}
}

IMsiRecord* CMsiEngine::CreateSourcePaths()
//---------------------------------------
{
	IMsiRecord* piError = 0;

	if (!m_fDirectoryManagerInitialized || !m_fSourceSubPathsResolved)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return 0; // no directory table, no paths to create

	PMsiPath pSourceRoot(0);
	int iSourceType = 0;
	if((piError = GetSourceRootAndType(*&pSourceRoot, iSourceType)) != 0)
		return piError;
	
	PMsiPath pPath(0);

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue); // tree-walking cursor - depth-first

	PMsiPath pRootPath(0);
	while(pDirCursor->Next())
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiString istrName(pDirCursor->GetString(m_colDirKey));
		MsiString istrParent(pDirCursor->GetString(m_colDirParent));
		MsiString istrSubPath(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fTrue));
		MsiString istrPath;

		PMsiPath pFullPath(0);
		
		Bool fRoot = (!istrParent.TextSize() || istrName.Compare(iscExact, istrParent)) ? fTrue : fFalse;
		if(fRoot) // source root - DefaultDir is property defining path
		{
			MsiString istrRootPath;
			
			// COMPAT FIX
			// when running against a pre-1.5 package that is marked compressed, use SourceDir instead of the 
			// authored root property

			if(FPerformAppcompatFix(iacsAcceptInvalidDirectoryRootProps))
			{
				istrRootPath = GetPropertyFromSz(IPROPNAME_SOURCEDIR);
			}
			else
			{
				if(!istrSubPath.TextSize())
					return PostError(Imsg(idbgNoRootSourcePropertyName), (const ICHAR *)istrName);
				istrRootPath = GetProperty(*istrSubPath);
			}
			if(!istrRootPath.TextSize())
			{
				return PostError(Imsg(idbgNoRootProperty), (const ICHAR *)istrSubPath);
			}

			if((piError = CreatePathObject(*istrRootPath, *&pRootPath)) != 0)
				return piError;  //!! use idbgDatabaseValueError

			if((piError = pRootPath->ClonePath(*&pFullPath)) != 0)
				return piError;
		}
		else // grab already-resolve sub-path, and tack onto root path
		{
			if(!pRootPath)
				return PostError(Imsg(idbgDatabaseTableError));

			if((piError = pRootPath->ClonePath(*&pFullPath)) != 0)
				return piError;

			// append sub-path if global source type is uncompressed (meaning look in the tree, not at the root)
			if((!(iSourceType & msidbSumInfoSourceTypeCompressed) ||
				  (iSourceType & msidbSumInfoSourceTypeAdminImage)))
			{
				Bool fLFN = ToBool(FSourceIsLFN(iSourceType, *pRootPath));
					
				// short path is in short column, or if short and long are the same, in the long column
				MsiString strSubPath;
				if(!fLFN)
				{
					strSubPath = pDirCursor->GetString(m_colDirShortSourceSubPath);
				}

				if(!strSubPath.TextSize())
				{
					strSubPath = pDirCursor->GetString(m_colDirLongSourceSubPath);
				}

				if((piError = pFullPath->AppendPiece(*strSubPath)) != 0)
					return piError;
			}
		}

	
		AssertNonZero(pDirCursor->PutMsiData(m_colDirSource, pFullPath));
		AssertNonZero(pDirCursor->Update());
		AssertNonZero(pDirCursor->PutNull(m_colDirSource)); // reset object field
	}

	m_fSourcePathsCreated = true;
	
	DebugDumpDirectoryTable(*m_piDirTable, true, m_colDirKey, m_colDirSource,
									m_colDirLongSourceSubPath, m_colDirShortSourceSubPath);

	return 0;
}

IMsiRecord* CMsiEngine::ResolveSourceSubPaths()
//---------------------------------------
{
	IMsiRecord* piError = 0;

	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return 0; // no directory table, no paths to create

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
	PMsiCursor pParentDirCursor = m_piDirTable->CreateCursor(fFalse);
	pParentDirCursor->SetFilter(iColumnBit(m_colDirKey));  // permanent setting

	// tree walk is depth first
	while(pDirCursor->Next())
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiString strName(pDirCursor->GetString(m_colDirKey));
		MsiString strParent(pDirCursor->GetString(m_colDirParent));
		MsiString strSubPath(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fTrue));

		// for root entries, reset path string, and skip entry itself
		if(!strParent.TextSize() || strName.Compare(iscExact, strParent))
		{
			continue;
		}

		// find parent entry
		pParentDirCursor->Reset();
		AssertNonZero(pParentDirCursor->PutString(m_colDirKey, *strParent));
		AssertNonZero(pParentDirCursor->Next());

		MsiString strLongSubPath =  pParentDirCursor->GetString(m_colDirLongSourceSubPath);
		MsiString strShortSubPath = pParentDirCursor->GetString(m_colDirShortSourceSubPath);

		if (strSubPath.Compare(iscExact, TEXT("?")) == 0 &&
			 strSubPath.Compare(iscExact,TEXT(".")) == 0)
		{
			// make sure default sub path doesn't contain chDirSep
			if(strSubPath.Compare(iscWithin, szDirSep) ||
				strSubPath.Compare(iscWithin, szURLSep))
			{
				return PostError(Imsg(idbgInvalidDefaultFolder), *strSubPath);
			}
			
			MsiString strLongName, strShortName;
			
			// should always be able to extract long name
			if((piError = m_riServices.ExtractFileName(strSubPath,fTrue,*&strLongName)) != 0)
				return piError;

			// poorly authored packages may only supply long name, but that worked in 1.0 so we have
			// to accept it (by ignoring any errors from ExtractFileName)
			PMsiRecord(m_riServices.ExtractFileName(strSubPath,fFalse,*&strShortName));
		
			if(!strLongName.TextSize())
				return PostError(Imsg(idbgDatabaseValueError), sztblDirectory,
											  strName, sztblDirectory_colDefaultDir);

			// if short and long names are different (and short is non-empty),
			// need to start storing subpaths separately
			if(strShortSubPath.TextSize() || // parent sub-path already different than long path
				strShortName.TextSize() &&	strLongName.Compare(iscExact, strShortName) == 0) // current short|long names are different
			{
				if(!strShortSubPath.TextSize())
				{
					strShortSubPath = strLongSubPath; // differences start here, so need to start with parent's long path
				}
				
				strShortSubPath += strShortName;
				strShortSubPath += szDirSep; //!! need to fix path object to fix up dir seps for URL paths
			}

			strLongSubPath += strLongName;
			strLongSubPath += szDirSep;
		}
		// else this directory is identical to its parent

		AssertNonZero(pDirCursor->PutString(m_colDirLongSourceSubPath, *strLongSubPath));
		if(strShortSubPath.TextSize())
		{
			AssertNonZero(pDirCursor->PutString(m_colDirShortSourceSubPath, *strShortSubPath));
		}

		AssertNonZero(pDirCursor->Update());
		
		// reset cursor fields
		AssertNonZero(pDirCursor->PutString(m_colDirLongSourceSubPath, g_MsiStringNull));
		AssertNonZero(pDirCursor->PutString(m_colDirShortSourceSubPath, g_MsiStringNull));
	}
	
	m_fSourceSubPathsResolved = true;
	return 0;
}

IMsiRecord* CMsiEngine::CreateTargetPaths()
//---------------------------------------
{
	IMsiRecord* piError = CreateTargetPathsCore(0);
	if(piError == 0 && m_piDirTable)
	{
		DebugDumpDirectoryTable(*m_piDirTable, false, m_colDirKey, m_colDirTarget,
										m_colDirLongSourceSubPath, m_colDirShortSourceSubPath);
	}
	return piError;
}

IMsiRecord* CMsiEngine::CreateTargetPathsCore(const IMsiString* piDirKey)
{
	IMsiRecord* piError = 0;

	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return 0; // no directory table, no paths to create

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
	PMsiCursor pTempCursor = m_piDirTable->CreateCursor(fFalse); // used to find parent
	Assert(pTempCursor);
	pTempCursor->SetFilter(iColumnBit(m_colDirKey));  // permanent setting
	Bool fShortNames = GetMode() & iefSuppressLFN ? fTrue : fFalse;
	bool fAdmin = GetMode() & iefAdmin ? true : false;
	MsiString istrRootDrive = GetPropertyFromSz(IPROPNAME_ROOTDRIVE);
	while(pDirCursor->Next())
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		PMsiPath pPath(0);
		MsiString istrName(pDirCursor->GetString(m_colDirKey));
		MsiString istrParent(pDirCursor->GetString(m_colDirParent));
		MsiString istrSubPath(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fAdmin));
		bool fPreconfigured = pDirCursor->GetInteger(m_colDirPreconfigured) == iMsiNullInteger ? false : true;
		MsiString istrPath;

		// The piDirKey parameter and the DirPreconfigured column of the Directory table are used to allow
		// the Directory table paths to be re-initialized, if necessary.  Calling CreateTargetPathsCore with piDirKey
		// set to a key in the Directory table tells CreateTargetPathsCore to reinitialize all paths to the default
		// authored values, ignoring the current Property value set for the path, EXCEPT for the piDirKey
		// path itself, and any directories that were preconfigured via property the first time the
		// Directory table paths were initialized.  To initialize the directory paths normally, call
		// CreateTargetPathsCore with NULL for piDirKey.
		if (!piDirKey || fPreconfigured || istrName.Compare(iscExact, piDirKey->GetString()))
			istrPath = GetProperty(*istrName);

		Bool fRoot = (!istrParent.TextSize() || istrName.Compare(iscExact, istrParent)) ? fTrue : fFalse;
		if(fRoot && istrPath.TextSize() == 0) // target root and no property defined
		{
			if(!istrRootDrive.TextSize()) // error - ROOTDRIVE not set
				return PostError(Imsg(idbgNoRootProperty), *istrRootDrive);
			else
			{
				if((piError = CreatePathObject(*istrRootDrive, *&pPath)) != 0)
					return piError;
			}
		}
		else if ((fAdmin && fRoot) || (!fAdmin && istrPath.TextSize())) // set path with property value
		{
			if((piError = CreatePathObject(*istrPath, *&pPath)) != 0)
				return piError;
			if (!fPreconfigured && !piDirKey)
			{
				AssertNonZero(pDirCursor->PutInteger(m_colDirPreconfigured, true));
				AssertNonZero(pDirCursor->Update());
			}
		}
		else // set path with default value
		{
			if (istrSubPath.Compare(iscExact, TEXT("?")) == 0)
			{
				// get parent path object and append default dir name to it
				pTempCursor->Reset();
				AssertNonZero(pTempCursor->PutString(m_colDirKey, *istrParent));
				AssertNonZero(pTempCursor->Next());
				PMsiPath pTempPath = (IMsiPath*)pTempCursor->GetMsiData(m_colDirTarget);
				Assert(pTempPath);
				if((piError = pTempPath->ClonePath(*&pPath)) != 0)
					return piError;

				Assert(pPath);

				if(istrSubPath.Compare(iscExact,TEXT(".")) == 0)
				{
					// extract appropriate name from short|long pair
					Bool fLFN = (fShortNames == fFalse && pTempPath->SupportsLFN()) ? fTrue : fFalse;
					MsiString strSubPathName;
					

						if((piError = m_riServices.ExtractFileName(istrSubPath,fLFN,*&strSubPathName)) != 0)
							return piError;
					
						if(!strSubPathName.TextSize())
							return PostError(Imsg(idbgDatabaseValueError), sztblDirectory,
														  istrName, sztblDirectory_colDefaultDir);

						// make sure default sub path doesn't contain chDirSep
						if(strSubPathName.Compare(iscWithin, szDirSep))
							return PostError(Imsg(idbgInvalidDefaultFolder), *strSubPathName);

						if((piError = pPath->AppendPiece(*strSubPathName)) != 0)
							return piError;

				}
				// else this directory is identical to its parent
			}
		}
		if ( pPath && g_fWinNT64 && g_Win64DualFolders.ShouldCheckFolders() )
		{
			ICHAR szSubstitutePath[MAX_PATH+1];
			ieSwappedFolder iRes;
			iRes = g_Win64DualFolders.SwapFolder(ie64to32,
															 MsiString(pPath->GetPath()),
															 szSubstitutePath,
															 ARRAY_ELEMENTS(szSubstitutePath));
			if ( iRes == iesrSwapped )
				piError = pPath->SetPath(szSubstitutePath);
			else
				Assert(iRes != iesrError && iRes != iesrNotInitialized);
		}
		AssertNonZero(pDirCursor->PutMsiData(m_colDirTarget, pPath));
		AssertNonZero(pDirCursor->Update());
		AssertNonZero(pDirCursor->PutMsiData(m_colDirTarget, 0)); // reset search field
		// set property - ensure that property values have trailing '\'
		if(pPath)
			AssertNonZero(SetProperty(*istrName, *MsiString(pPath->GetPath())));
	}
	return 0;
}


IMsiRecord* CMsiEngine::GetTargetPath(const IMsiString& riDirKey,IMsiPath*& rpiPath)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDirKey); // no Directory table, so this directory must not exist

	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));

	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDirKey);
	if (pDirCursor->Next())
	{
		rpiPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
		if(rpiPath == 0)
		{
			MsiString strSubPath = pDirCursor->GetString(m_colDirSubPath);

			// Question marks are inserted in the subPath column when the
			// RegisterComponentDirectory inserts a new entry into the
			// Directory table.  If a path for that directory was never
			// defined, we know we've got an error.
			if (strSubPath.Compare(iscExact,TEXT("?")))
			{
				return PostError(Imsg(idbgDirPropertyUndefined), riDirKey);
			}
			else
			{
				return PostError(Imsg(idbgTargetPathsNotCreated), riDirKey);
			}
		}
	}
	else
	{
		rpiPath = 0;
		return PostError(Imsg(idbgUnknownDirectory), riDirKey);
	}
	return 0;
}

IMsiRecord* CMsiEngine::IsPathWritable(IMsiPath& riPath, Bool& fWritable)
{
	// check for folder writability only if we will attempt to write to the folder with client privs
	// this is true when running as a client or if the folder is remote
	// otherwise, we assume the folder is writable by the server (if its not, the server must handle
	// the error)
	//!! we are making the assumption here that if g_fWin9X or m_piConfigManager are set that we
	//!! are running under client mode. However, this doesn't catch the case when we are running as an
	//!! OLE server on NT.  We don't do this currently but we could in the future. This will need to be
	//!! fixed to detect that case.
	IMsiRecord* piErr = 0;
	fWritable = fTrue;
	idtEnum idtDrivetype = PMsiVolume(&riPath.GetVolume())->DriveType();
	if((FIsUpdatingProcess() || idtDrivetype == idtRemote || idtDrivetype == idtCDROM))
		piErr = riPath.Writable(fWritable);
	return piErr;
}


IMsiRecord* CMsiEngine::SetTargetPath(const IMsiString& riDestString, const ICHAR* szPath, Bool fWriteCheck)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDestString); // no Directory table, so this directory must not exist

	IMsiRecord* piError = 0;
	PMsiPath pPath(0);
	Bool fSuppressLFN = GetMode() & iefSuppressLFN ? fTrue : fFalse;
	bool fAdmin = GetMode() & iefAdmin ? true : false;
	CTempBuffer<const IMsiString*,10> rgOldDirKeys; // holds keys of changed paths in case we need to revert to them
	CTempBuffer<IMsiPath*,10> rgOldPaths; // holds changed paths in case we need to revert to them
	int iOldPathsIndex = 0;

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDestString);

	// get current path object
	int iDirLevel = pDirCursor->Next();
	if(iDirLevel != 0)
	{
		pPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
		if (!pPath)
			return PostError(Imsg(idbgTargetPathsNotCreated), riDestString);
	}
	else
	{
		return PostError(Imsg(idbgUnknownDirectory), riDestString);
	}
	
#ifdef _WIN64
	// if we are asked to change the path to a 64-bit folder when the package is marked 32-bit,
	// we need to remap the path to the 32-bit folder
	ICHAR szSubstitutePath[MAX_PATH+1];
	if ( szPath && g_Win64DualFolders.ShouldCheckFolders() )
	{
		ieSwappedFolder iRes;
		iRes = g_Win64DualFolders.SwapFolder(ie64to32,
														 szPath,
														 szSubstitutePath,
														 ARRAY_ELEMENTS(szSubstitutePath));
		if ( iRes == iesrSwapped )
		{
			DEBUGMSG2(TEXT("In SetTargetPath, re-mapping '%s' to '%s' because this is a 32-bit package being installed on Win64."), szPath, szSubstitutePath);
			szPath = szSubstitutePath;
		}
		else
			Assert(iRes != iesrError && iRes != iesrNotInitialized);
	}
#endif // _WIN64

	// New path object
	PMsiPath pNewPathObj(0);

	if ((piError = CreatePathObject(*MsiString(szPath), *&pNewPathObj)) != 0)
		return piError;

	// hold old path
	PMsiPath pOldPath(0);
	if((piError = pPath->ClonePath(*&pOldPath)) != 0)
		return piError;

	ipcEnum ipc;

	// If the paths are identical, we have no work to do
	pOldPath->Compare(*pNewPathObj, ipc);
	if (ipc == ipcEqual)
		return 0;
		
	Assert(pOldPath);

	// scan all other directories for child paths and update them
	bool fShortNameError = false;
	pDirCursor->SetFilter(0);
	MsiString istrChild, strDefaultFolder, strCurrentFolder;
	do
	{
#ifdef DEBUG
		MsiString strDebug = pDirCursor->GetString(m_colDirKey);
#endif //DEBUG
		piError = 0;
		PMsiPath pOldChildPath(0); // path to pass to RecostDirectory
		PMsiPath pChildPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
		if(pChildPath && (((IMsiPath*)pChildPath == (IMsiPath*)pPath) ||
			((piError = pChildPath->Child(*pOldPath, *&istrChild)) == 0)))
		{
			if((piError = pChildPath->ClonePath(*&pOldChildPath)) != 0)
				break;
			if((piError = pChildPath->SetPathToPath(*pNewPathObj)) != 0)
				break;

			if(istrChild.TextSize())
			{
				// child of path being changed
				
				// if the last folder of istrChild is one of the default folder names in
				// the directory table, use the default value instead

				// strDefaultFolder caches the DefaultDir value for the current path or the closest parent
				// that doesn't have '.' as the DefaultDir
				// since we are tree-walking this happens automatically
				//!! doesn't work in some cases - strDefaultFolder may not always be value of parent
				MsiString strTemp(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fAdmin));
				if(strTemp.Compare(iscExact,TEXT(".")) == 0)
					strDefaultFolder = strTemp;

				strCurrentFolder = pOldChildPath->GetEndSubPath();

				// extract appropriate name from short|long pair
				Bool fLFN = (fSuppressLFN == fFalse && pChildPath->SupportsLFN()) ? fTrue : fFalse;
				MsiString strSubPathName;
				if((piError = m_riServices.ExtractFileName(strDefaultFolder,fLFN,*&strSubPathName)) != 0)
					return piError;
			
				// make sure default sub path doesn't contain chDirSep
				if(strDefaultFolder.Compare(iscWithin, szDirSep))
				{
					piError = PostError(Imsg(idbgInvalidDefaultFolder),
											  *strDefaultFolder);
					break;
				}
				if(strDefaultFolder.Compare(iscExactI, strCurrentFolder) || // exact match OR
					(strDefaultFolder.Compare(iscWithin, TEXT("|")) && // short|long combo AND
					(strDefaultFolder.Compare(iscStart, strCurrentFolder) || // matches short name OR
					strDefaultFolder.Compare(iscEnd, strCurrentFolder)))) // matches long name
				{
					istrChild.Remove(iseEnd, strCurrentFolder.CharacterCount()+1);
					istrChild += strSubPathName;
				}
			}

			if((piError = pChildPath->AppendPiece(*istrChild)) != 0)
			{
				// If a filename length error occured, we must be trying
				// to change from a LongFileName to ShortFileName volume.
				// We've got to bail out, and fix things up below...
				int iErr = piError->GetInteger(1);
				if (iErr == imsgErrorFileNameLength || iErr == imsgInvalidShortFileNameFormat)
				{
					fShortNameError = true;
					break;
				}

				// couldn't append child, set path back to old path
				// other paths will be fixed below
				AssertRecord(pChildPath->SetPathToPath(*pOldChildPath));
				break;
			}
			istrChild = TEXT("");

			if(fWriteCheck)
			{
				Bool fWritable;
				if ((piError = IsPathWritable(*pChildPath, fWritable)) != 0 || fWritable == fFalse)
				{
					// Can't write to this directory; throw an error, and set path back to old path.
					// Other paths will be fixed below.
					if (!piError && !fWritable)
						piError = PostError(Imsg(imsgDirectoryNotWritable), (const ICHAR*) MsiString(pChildPath->GetPath()));

					AssertRecord(pChildPath->SetPathToPath(*pOldChildPath));
					break;
				}
			}

			MsiString strDirKey = pDirCursor->GetString(m_colDirKey);
			if((piError = RecostDirectory(*strDirKey, *pOldChildPath)) != 0)
			{
				// couldn't RecostDirectory, set path back to old path
				// other paths will be fixed below
				AssertRecord(pChildPath->SetPathToPath(*pOldChildPath));
				break;
			}
			AssertNonZero(SetProperty(*strDirKey, *MsiString(pChildPath->GetPath())));

			// everything worked for this path
			// add path to list of old paths
			if(iOldPathsIndex >= rgOldPaths.GetSize())
			{
				rgOldPaths.Resize(iOldPathsIndex + 10);
				rgOldDirKeys.Resize(iOldPathsIndex + 10);
			}
			rgOldDirKeys[iOldPathsIndex] = (const IMsiString*)strDirKey;
			rgOldDirKeys[iOldPathsIndex]->AddRef();
			rgOldPaths[iOldPathsIndex] = (IMsiPath*)pOldChildPath;
			rgOldPaths[iOldPathsIndex]->AddRef();
			iOldPathsIndex++;
		}
		else if(piError)
		{
			piError->Release();
			piError = 0;
		}
	}
	while(pDirCursor->Next() > iDirLevel);

	for(int i=0; i<iOldPathsIndex; i++)
	{
		if(piError)
		{
			// need to revert changed paths to their old values
			pDirCursor->Reset();
			pDirCursor->SetFilter(iColumnBit(m_colDirKey));
			AssertNonZero(pDirCursor->PutString(m_colDirKey, *(rgOldDirKeys[i])));
			AssertNonZero(pDirCursor->Next());
			// set old path
			PMsiPath pNewPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
			AssertNonZero(pDirCursor->PutMsiData(m_colDirTarget, rgOldPaths[i]));
			AssertNonZero(pDirCursor->Update());
			// recost old directory
			AssertRecord(RecostDirectory(*(rgOldDirKeys[i]),*pNewPath));
			// set old property
			AssertNonZero(SetProperty(*(rgOldDirKeys[i]),*MsiString(rgOldPaths[i]->GetPath())));
		}
		if((const IMsiString*)rgOldDirKeys[i])
			rgOldDirKeys[i]->Release();
		if((const IMsiString*)rgOldPaths[i])
			rgOldPaths[i]->Release();
	}
	pDirCursor->Reset();
	pDirCursor->SetFilter(0);
	if (fShortNameError)
	{
		// Switched from a LFN to SFN volume; potentially all paths in the
		// directory table are wrong, so we've got to create them again,
		// this time with short names.  Then no choice but to reset and
		// recompute the disk cost for all components.
		Assert(piError);
		piError->Release();
		AssertNonZero(SetProperty(riDestString, *MsiString(szPath)));
		if ((piError = CreateTargetPathsCore(&riDestString)) != 0)
			return piError;
		return InitializeDynamicCost(/* fReinitialize = */ fTrue);
	}
	else
	{
		if(!piError)
			DetermineOutOfDiskSpace(NULL, NULL);
		return piError;
	}
}

IMsiRecord* CMsiEngine::SetDirectoryNonConfigurable(const IMsiString& ristrDirKey)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), ristrDirKey); // no Directory table, so this directory must not exist

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fFalse);
	pDirCursor->PutString(m_colDirKey, ristrDirKey);
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	if (pDirCursor->Next())
	{
		AssertNonZero(pDirCursor->PutInteger(m_colDirNonConfigurable, 1));
		AssertNonZero(pDirCursor->Update());
		return 0;
	}
	else
		return PostError(Imsg(idbgUnknownDirectory), ristrDirKey);
}

IMsiRecord* CMsiEngine::ResolveSource(const ICHAR* szProductKey, bool fPatch, const ICHAR* szOriginalDatabasePath, iuiEnum iuiLevel, Bool fMaintenanceMode, const IMsiString** ppiSourceDir, const IMsiString** ppiSourceDirProduct)
{
	Assert(!ppiSourceDirProduct == !ppiSourceDir); // either both 0 or both set

	// patches have their own source list so m_fSourceResolved doesn't apply here.  It is only used for
	// prevention of multiple source resolutions of the package
	if (!fPatch && m_fSourceResolved)
		return 0;

	DEBUGMSG("Resolving source.");


	// If we're not running from the cached database (always true for first-run)
	// then we must've been launched from a valid source (this needs to be determined up front,
	// before we even let the install begin). We'll use this source as
	// it's obviously available if we were launched from it. Otherwise
	// if we're running from the cached database then we attempt to resolve
	// a source.

	MsiString strPatchedProductKey = GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);
	
	MsiString strProductKey;
	if (szProductKey)
		strProductKey = szProductKey;
	else if(strPatchedProductKey.TextSize())
		strProductKey = strPatchedProductKey;
	else
		strProductKey = GetProductKey();

	MsiString strPackage;
	if (szOriginalDatabasePath)
		strPackage    = szOriginalDatabasePath;
	else
		strPackage    = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);

	if (fMaintenanceMode == -1)
		fMaintenanceMode = (GetMode() & iefMaintenance) != 0 ? fTrue : fFalse;

	IMsiRecord* piError = 0;
	MsiString strSource;
	MsiString strSourceProduct = GetRootParentProductKey();
	if (*(const ICHAR*)strPackage == ':') // SubStorage
	{
		Assert(m_piParentEngine);
		if ((piError = GetSourcedir(*m_piParentEngine, *&strSource)) != 0)
			return piError;
	}
	else
	{
		if (GetMode() & iefAdmin ||
			 (strPatchedProductKey.TextSize() == 0 &&
			  !fPatch &&
			 (!fMaintenanceMode || !IsCachedPackage(*this, *strPackage, fFalse, strProductKey))))
		{
			DEBUGMSG("Resolving source to launched-from source.");
			DEBUGMSG("Setting launched-from source as last-used.");

			strSource = strPackage;
			Assert(PathType(strSource) == iptFull);

			PMsiPath pPath(0);
			MsiString strFileName;
			// FUTURE: Perhaps could use split path here
			AssertRecord(m_riServices.CreateFilePath(strSource, *&pPath, *&strFileName));
			strSource.Remove(iseLast,strFileName.CharacterCount());
		}
		else // running from cached database; need to resolve the source
		{
			AssertSz(!m_fRestrictedEngine, TEXT("Full source resolution is not allowed in a restricted engine"));
			iuiEnum iuiSource = iuiLevel != -1 ? iuiLevel : m_iuiLevel;

			// when attempting to resolve the source from the engine, we're really asking for disk 1 (which has the package
			// patches, and transforms). Other disks are only requested via the script or a GetComponentPath call.
			if ((piError = ::ResolveSource(&m_riServices, strProductKey, /*uiDisk=*/ 1, *&strSource, *&strSourceProduct, fFalse, 0 /*not needed*/, fPatch)) == 0)
			{
				Assert(strSource.Compare(iscEnd, MsiString(MsiChar(chDirSep))) ||
						 strSource.Compare(iscEnd, MsiString(MsiChar(chURLSep))));
			}
			else
			{
				return piError;
			}
		}

#ifdef DEBUG
		MsiString strMsiDirectory(GetMsiDirectory());
		strMsiDirectory += chDirSep;

		// No assert if the path is actually a sub-directory.  Only concerned about things resolving
		// directly to the Msi Directory.
		AssertSz(strSource.Compare(iscExactI,strMsiDirectory) == 0, "Resolved source to cached msi folder");
#endif 

	}
	if (ppiSourceDir)
	{
		strSource.ReturnArg(*ppiSourceDir);
		strSourceProduct.ReturnArg(*ppiSourceDirProduct);
	}
	else
	{
		SetProperty(*MsiString(IPROPNAME_SOURCEDIR), *strSource);
		SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSource);
		SetProperty(*MsiString(IPROPNAME_SOURCEDIRPRODUCT), *strSourceProduct);
	}

	// only set m_fSourceResolved when dealing with packages
	if (!fPatch)
		m_fSourceResolved = true;

	DEBUGMSG1(TEXT("SOURCEDIR ==> %s"), strSource);
	DEBUGMSG1(TEXT("SOURCEDIR product ==> %s"), strSourceProduct);
	return 0;
}

IMsiRecord* CMsiEngine::GetSourcePath(const IMsiString& riDirKey,IMsiPath*& rpiPath)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDirKey); // no Directory table, so this directory must not exist

	
	IMsiRecord* piErrRec = NULL;

	if (!m_fSourceResolved)
	{
		if ((piErrRec = ResolveSource()) != 0)
		{
			if (piErrRec->GetInteger(1) == imsgSourceResolutionFailed || piErrRec->GetInteger(1) == imsgSourceResolutionFailedCSOS)
				piErrRec->SetMsiString(2, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME)));
			return piErrRec; //!! Reformat error?
		}
	}

	if(!m_fSourcePathsCreated)
	{
		if ((piErrRec = CreateSourcePaths()) != 0)
		{
			m_fSourceResolved = false;
			return piErrRec;
		}
	}

	rpiPath = 0;

	// COMPAT FIX
	// for packages older than 150, need to handle Directory tables that have no root rows with DefaultDir of
	// either SOURCEDIR or SourceDir
	if (FPerformAppcompatFix(iacsAcceptInvalidDirectoryRootProps) &&
		 (riDirKey.Compare(iscExact, IPROPNAME_SOURCEDIR) || riDirKey.Compare(iscExact, IPROPNAME_SOURCEDIROLD)))
	{
		return CreatePathObject(*MsiString(GetPropertyFromSz(IPROPNAME_SOURCEDIR)), rpiPath);
	}

	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDirKey);
	if (pDirCursor->Next())
	{
		rpiPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirSource);
		piErrRec = 0;
	}
	else
	{
		// look for source properties (e.g. SOURCEDIR, etc.)
		PMsiCursor pDirTreeCursor(m_piDirTable->CreateCursor(fTrue));
		pDirTreeCursor->SetFilter(iColumnBit(m_colDirSubPath));
		pDirTreeCursor->PutString(m_colDirSubPath, riDirKey);

		int iLevel;
		while ((iLevel = pDirTreeCursor->Next()) != 0)
		{
			if (iLevel == 1) // root
			{
				rpiPath = (IMsiPath*)pDirTreeCursor->GetMsiData(m_colDirSource);
				piErrRec = 0;
				break;
			}
		}
	}
	if (!rpiPath)
		piErrRec = PostError(Imsg(idbgSourcePathsNotCreated), riDirKey);
	return piErrRec;
}

// GetSourceSubPath: returns the already-resolved SubPath for this Directory key
//                   requires ResolveSourceSubPaths to have been called (CostInitialize calls that)
//                   unlike GetSourcePath, this fn doesn't accept "SOURCEDIR" or "SourceDir" as an arg
//                   if fPrependSourceDirToken is true, returned string starts with token for use in
//                   ixoSetSourceFolder op
IMsiRecord* CMsiEngine::GetSourceSubPath(const IMsiString& riDirKey, bool fPrependSourceDirToken,
													  const IMsiString*& rpistrSubPath)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized || !m_fSourceSubPathsResolved)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDirKey); // no Directory table, so this directory must not exist

	MsiString strSubPath;
	if(fPrependSourceDirToken)
	{
		strSubPath = szUnresolvedSourceRootTokenWithBS;
	}
	
	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDirKey);
	if (pDirCursor->Next())
	{
		// string is [short path|][long path] - the correct path will be used once the source type is known
		MsiString strShortSubPath = pDirCursor->GetString(m_colDirShortSourceSubPath);
		MsiString strLongSubPath  = pDirCursor->GetString(m_colDirLongSourceSubPath);

		if(strShortSubPath.TextSize())
		{
			strSubPath += strShortSubPath;
			strSubPath += MsiChar(chFileNameSeparator);
		}
		strSubPath += strLongSubPath;

		strSubPath.ReturnArg(rpistrSubPath);
		return 0;
	}
	else
	{
		// not a perfect error, because paths may have been created, but good enough
		return PostError(Imsg(idbgSourcePathsNotCreated), riDirKey);
	}
}

IMsiRecord* GetSourceTypeFromPackage(IMsiServices& riServices, IMsiPath& riSourceRoot,
												 const IMsiString& ristrPackageName,
												 const IMsiString& ristrLocalCopy,
												 const ICHAR* rgchProductCode, IMsiDatabase* piDatabase, int &iSourceType)
{
	DEBUGMSGV(TEXT("Determining source type"));

	IMsiRecord* piError = 0;

	PMsiStorage pStorage(0);
	PMsiSummaryInfo pSummary(0);

	CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // to be set later if needed

	bool fUrlSourceProvided = false;

	if (PMsiVolume(&riSourceRoot.GetVolume())->IsURLServer())
	{
		DEBUGMSGV(TEXT("URL source provided. . ."));
		fUrlSourceProvided = true;

		// try to determine if we already have a source type registered; otherwise we have to download the package
		CRegHandle HSourceListKey;
		HKEY hURLSourceKey = 0;
		int iURLSourceType;
		DWORD cbURLSourceType = sizeof(iURLSourceType);
		DWORD dwType;
		if (ERROR_SUCCESS == OpenSourceListKey(rgchProductCode, /* fPatch */ fFalse, HSourceListKey, /* fWrite */ fFalse, /* fSetKeyString */ false)
			&& ERROR_SUCCESS == MsiRegOpen64bitKey(HSourceListKey, szSourceListURLSubKey, 0, g_samRead, &hURLSourceKey)
			&& ERROR_SUCCESS == RegQueryValueEx(hURLSourceKey, szURLSourceTypeValueName, 0, &dwType, (LPBYTE)&iURLSourceType, &cbURLSourceType)
			&& dwType == REG_DWORD)
		{
			// found a source type registered for URLs for this product -- use it!
			iSourceType = iURLSourceType;
			DEBUGMSGV2(TEXT("Source type from package '%s': %d"),ristrPackageName.GetString(),(const ICHAR*)(INT_PTR)iSourceType);

			RegCloseKey(hURLSourceKey);

			return 0;
		}
		if (hURLSourceKey)
		{
			RegCloseKey(hURLSourceKey);
			hURLSourceKey = 0;
		}
	}

	MsiString strPackageFullPath;
	if((piError = riSourceRoot.GetFullFilePath(ristrPackageName.GetString(), *&strPackageFullPath)) != 0)
		return piError;

	bool fFileDownload = true;

	// SAFER check is not warranted here.  All we want to do is open up the package to read its source type.
	// we will have already opened the source package prior to this; therefore szFriendlyName and phSaferLevel is NULL
	if((piError = OpenAndValidateMsiStorageRec((fUrlSourceProvided && ristrLocalCopy.TextSize()) ? ristrLocalCopy.GetString() : strPackageFullPath, stDatabase, riServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL)) != 0)
	{
		piError->Release();
		piError = 0;

		// cannot open source storage file
		// if we have a database pointer to try, use it
		if(piDatabase)
		{
			pStorage = piDatabase->GetStorage(1);
			fFileDownload = false;
		}
		else
		{
			return PostError(Imsg(imsgNetErrorReadingFromFile), *strPackageFullPath);
		}
	}

	if (MinimumPlatformWindowsDotNETServer() && fUrlSourceProvided && 0 == ristrLocalCopy.TextSize() && pStorage && fFileDownload)
	{
		MsiString strDownload;
		AssertRecord(pStorage->GetName(*&strDownload));
		cDeleteUrlLocalFileOnClose.SetFileName(*strDownload, /* fDeleteFromIECache = */ false);
	}

	Assert(pStorage);
		
	if ((piError = pStorage->CreateSummaryInfo(0, *&pSummary)) != 0)
		return piError;

	if(!pSummary->GetIntegerProperty(PID_MSISOURCE, iSourceType))
		return PostError(Imsg(imsgNetErrorReadingFromFile), *strPackageFullPath);

	DEBUGMSGV2(TEXT("Source type from package '%s': %d"),ristrPackageName.GetString(),(const ICHAR*)(INT_PTR)iSourceType);

	pStorage = 0; // force release to allow deletion

	return 0;
}

int CMsiEngine::GetDeterminedPackageSourceType()
{
	return m_iSourceType;
}

// GetSourceRootAndType: 
// returns the source type from the SOURCE package, which may be different than
// the source type of the CACHED package
IMsiRecord* CMsiEngine::GetSourceRootAndType(IMsiPath*& rpiSourceRoot, int& iSourceType)
{
	IMsiRecord* piError = 0;
	
	// the source for an embedded nested install is its parent's source
	if(*(const ICHAR*)m_strPackageName == ':' && m_piParentEngine)
	{
		// for child installs, we'll use the sourcetype of the package we are running from to determine
		// LFN/SFN and compressed/uncompressed
		// we use the parent package to determine admin/non-admin
		// there is really no good reason for this inconsistency, but its the logic used in MSI 1.1
		// and it isn't worth changing this behaviour for nested installs
		
		int iSourceTypeTemp = 0;
		if((piError = m_piParentEngine->GetSourceRootAndType(rpiSourceRoot, iSourceTypeTemp)) != 0)
			return piError;

		iSourceType = m_iCachedPackageSourceType & (~msidbSumInfoSourceTypeAdminImage);
		if(iSourceTypeTemp & msidbSumInfoSourceTypeAdminImage)
			iSourceType |= msidbSumInfoSourceTypeAdminImage;
	}
	else
	{
		if (!m_fSourceResolved)
		{
			if ((piError = ResolveSource()) != 0)
			{
				if (piError->GetInteger(1) == imsgSourceResolutionFailed || piError->GetInteger(1) == imsgSourceResolutionFailedCSOS)
					piError->SetMsiString(2, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME)));
				return piError; //!! Reformat error?
			}
		}

		if((piError = CreatePathObject(*MsiString(GetPropertyFromSz(IPROPNAME_SOURCEDIR)), rpiSourceRoot)) != 0)
			return piError;

		if(m_iSourceType == -1)
		{
			MsiString strProductKey = GetProductKey();
			if((piError = GetSourceTypeFromPackage(m_riServices, *rpiSourceRoot,
																*m_strPackageName, *m_strPackageDownloadLocalCopy, (const ICHAR*)strProductKey, m_piExternalDatabase,
																m_iSourceType)) != 0)
				return piError;
		
		}

		iSourceType = m_iSourceType;
	}
	
	return 0;
}

#ifdef DEBUG
void CMsiEngine::SetAssertFlag(Bool fShowAsserts)
{
	g_fNoAsserts = fShowAsserts;
}

void CMsiEngine::SetDBCSSimulation(char /*chLeadByte*/)
{
}

Bool CMsiEngine::WriteLog(const ICHAR *)
{
	return fFalse;
}

void CMsiEngine::AssertNoObjects()
{
}

void  CMsiEngine::SetRefTracking(long iid, Bool fTrack)
{

	::SetFTrackFlag(iid, fTrack);

}



#endif //DEBUG

IMsiRecord* CMsiEngine::LoadSelectionTables()
//-----------------------------------------
{
	// AFTERREBOOT or Resume properties set indicate that we are installing over a partial install
	// set flag to force reinstall of components
	if(MsiString(GetPropertyFromSz(IPROPNAME_RESUME)).TextSize() ||
		MsiString(GetPropertyFromSz(IPROPNAME_RESUMEOLD)).TextSize() ||
		MsiString(GetPropertyFromSz(IPROPNAME_AFTERREBOOT)).TextSize())
		m_fForceRequestedState = fTrue;

	SetCostingComplete(fFalse);
	IMsiRecord* piError = LoadFeatureTable();
	if (piError)
		return piError;

	return LoadComponentTable();
}


//____________________________________________________________________________
//
// IMsiSelectionManager implementation
//____________________________________________________________________________

IMsiRecord* CMsiEngine::LoadFeatureTable()
//----------------------------------------
{
	Assert(m_piDatabase);
	IMsiRecord* piError;
	m_piFeatureCursor = 0;
	m_piFeatureTable = 0;
	if ((piError = m_piDatabase->LoadTable(*MsiString(*sztblFeature),3,m_piFeatureTable)))
		return piError;

	m_colFeatureKey    = GetFeatureColumnIndex(sztblFeature_colFeature);
	m_colFeatureParent = GetFeatureColumnIndex(sztblFeature_colFeatureParent);
	m_colFeatureAuthoredLevel  = GetFeatureColumnIndex(sztblFeature_colAuthoredLevel);

	m_colFeatureAuthoredAttributes = GetFeatureColumnIndex(sztblFeature_colAuthoredAttributes);

	m_colFeatureConfigurableDir = GetFeatureColumnIndex(sztblFeature_colDirectory);
	m_colFeatureTitle = GetFeatureColumnIndex(sztblFeature_colTitle);
	m_colFeatureDescription = GetFeatureColumnIndex(sztblFeature_colDescription);
	m_colFeatureDisplay = GetFeatureColumnIndex(sztblFeature_colDisplay);

	m_colFeatureLevel = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colLevel));
	m_colFeatureAttributes = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colAttributes));
	m_colFeatureSelect = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colSelect));
	m_colFeatureAction = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colAction));
	m_colFeatureActionRequested = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colActionRequested));
	m_colFeatureInstalled = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colInstalled));
	m_colFeatureHandle = m_piFeatureTable->CreateColumn(IcdObjectPool() + icdNullable, *MsiString(*sztblFeature_colHandle));
	m_colFeatureRuntimeFlags = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colRuntimeFlags));
	m_colFeatureDefaultSelect = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colDefaultSelect));
	if(!m_colFeatureKey || !m_colFeatureParent || !m_colFeatureConfigurableDir)
		return PostError(Imsg(idbgTableDefinition), sztblFeature);
	if (m_piFeatureTable->LinkTree(m_colFeatureParent) == -1)
		return PostError(Imsg(idbgLinkTable), sztblFeature);

	m_piFeatureCursor = m_piFeatureTable->CreateCursor(fTrue);
	if (!m_piFeatureCursor->Next())
	{
		m_piFeatureTable->Release();
		m_piFeatureTable = 0;

		m_piFeatureCursor->Release();
		m_piFeatureCursor = 0;
		return 0;
	}
	else
	{
		m_piFeatureCursor->Reset();
	}


	if ((piError = m_piDatabase->LoadTable(*MsiString(*sztblFeatureComponents),1,m_piFeatureComponentsTable)))
		return piError;

	m_colFeatureComponentsFeature = GetFeatureComponentsColumnIndex(sztblFeatureComponents_colFeature);
	m_colFeatureComponentsComponent = GetFeatureComponentsColumnIndex(sztblFeatureComponents_colComponent);
	m_colFeatureComponentsRuntimeFlags = m_piFeatureComponentsTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeatureComponents_colRuntimeFlags));
	if(!m_colFeatureComponentsFeature || !m_colFeatureComponentsComponent)
		return PostError(Imsg(idbgTableDefinition), sztblFeatureComponents);
		
	m_piFeatureComponentsCursor = m_piFeatureComponentsTable->CreateCursor(fFalse);
	
	SetProductAlienClientsFlag();
	return 0;
}

int CMsiEngine::GetFeatureColumnIndex(const ICHAR* szColumnName)
{
	return m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szColumnName));
}


int CMsiEngine::GetFeatureComponentsColumnIndex(const ICHAR* szColumnName)
{
	return m_piFeatureComponentsTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szColumnName));
}


IMsiRecord* CMsiEngine::LoadComponentTable()
//----------------------------------------
{
	Assert(m_piDatabase);
	m_piComponentCursor = 0;
	IMsiRecord* piError = m_piDatabase->LoadTable(*MsiString(*sztblComponent),
													14,
													 m_piComponentTable);
	if (piError)
		return piError;

	m_colComponentKey       = GetComponentColumnIndex(sztblComponent_colComponent);
	m_colComponentDir       = GetComponentColumnIndex(sztblComponent_colDirectory);

	m_colComponentAttributes = GetComponentColumnIndex(sztblComponent_colAttributes);

	m_colComponentCondition = GetComponentColumnIndex(sztblComponent_colCondition);
	m_colComponentID = GetComponentColumnIndex(sztblComponent_colComponentId);
	m_colComponentKeyPath = GetComponentColumnIndex(sztblComponent_colKeyPath);

	// ComponentParent column is created for internal cost use only
	m_colComponentParent = m_piComponentTable->CreateColumn(icdString + icdNullable,*MsiString(*sztblComponent_colComponentParent));
	if(!m_colComponentKey || !m_colComponentParent || !m_colComponentAttributes)
		return PostError(Imsg(idbgTableDefinition), sztblComponent);

	m_colComponentInstalled = m_piComponentTable->CreateColumn(icdLong + icdNullable,*MsiString(*sztblComponent_colInstalled));
	m_colComponentAction     = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colAction));
	m_colComponentActionRequest = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colActionRequest));
	m_colComponentLocalCost  = m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colLocalCost));
	m_colComponentNoRbLocalCost  = m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colNoRbLocalCost));
	m_colComponentSourceCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colSourceCost));
	m_colComponentRemoveCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colRemoveCost));
	m_colComponentNoRbRemoveCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colNoRbRemoveCost));
	m_colComponentNoRbSourceCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colNoRbSourceCost));
	m_colComponentARPLocalCost = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colARPLocalCost));
	m_colComponentNoRbARPLocalCost = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colNoRbARPLocalCost));
	m_colComponentRuntimeFlags = m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colRuntimeFlags));
	m_colComponentForceLocalFiles = m_piComponentTable->CreateColumn(icdLong + icdNullable,*MsiString(*sztblComponent_colForceLocalFiles));
	m_colComponentLegacyFileExisted = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colLegacyFileExisted));
	m_colComponentTrueInstallState = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colTrueInstallSt));
	
	if (m_piComponentTable->LinkTree(m_colComponentParent) == -1)
		return PostError(Imsg(idbgLinkTable), sztblComponent);

	m_piComponentCursor = m_piComponentTable->CreateCursor(fTrue);
	if (!m_piComponentCursor)
		return PostError(Imsg(imsgOutOfMemory));

	if (!m_piComponentCursor->Next())
	{
		m_piComponentTable->Release();
		m_piComponentTable = 0;
		
		m_piComponentCursor->Release();
		m_piComponentCursor = 0;
		return 0;
	}
	else
	{
		m_piComponentCursor->Reset();
	}

	return 0;
}


int CMsiEngine::GetComponentColumnIndex(const ICHAR* szTableName)
{
	return m_piComponentTable ? m_piComponentTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szTableName)) : 0;
}


IMsiTable* CMsiEngine::GetComponentTable()
//--------------------------------------
{
	if (m_piComponentTable)
		m_piComponentTable->AddRef();
	return m_piComponentTable;
}


IMsiTable* CMsiEngine::GetFeatureTable()
//--------------------------------------
{
	if (m_piFeatureTable)
		m_piFeatureTable->AddRef();
	return m_piFeatureTable;
}

IMsiTable* CMsiEngine::GetFeatureComponentsTable()
{
	if (m_piFeatureComponentsTable)
		m_piFeatureComponentsTable->AddRef();
	return m_piFeatureComponentsTable;
}

IMsiRecord* GetProductClients(IMsiServices& riServices, const ICHAR* szProduct, const IMsiString*& rpistrClients)
{
	CRegHandle HKey;
	DWORD dwResult = OpenAdvertisedProductKey(szProduct, HKey, false, 0);
	if (ERROR_SUCCESS != dwResult)
		return 0;

	PMsiRegKey pProductKey    = &riServices.GetRootKey((rrkEnum)(int)HKey, ibtCommon);
	
	AssertRecord(pProductKey->GetValue(szClientsValueName, *&rpistrClients));
	return 0;
}

Bool FFeaturesInstalled(IMsiEngine& riEngine, Bool fAllClients)
/*-------------------------------------------------------
Local function that returns fTrue if there is at least
one Feature in the Feature Table that is in the
installed (iisLocal or iisSource) state.
if fAllClients is set to false the "requested" features states
(for this particular invokation context of the product) is used
--------------------------------------------------------*/
{
	PMsiRecord pError(0);
	PMsiTable pFeatureTable(0);
	PMsiDatabase pDatabase = riEngine.GetDatabase();
	Assert(pDatabase);
	Bool fFeaturesInstalled = fFalse;

	pError = pDatabase->LoadTable(*MsiString(*sztblFeature), 1, *&pFeatureTable);
	if (pError)
	{
		if (pError->GetInteger(1) == idbgDbTableUndefined)
			pError = 0;
	}
	else
	{
		const ICHAR* szCol = (fAllClients) ? sztblFeature_colAction : sztblFeature_colActionRequested;

		int icolFeatureAction =    pFeatureTable->GetColumnIndex(pDatabase->EncodeString(*MsiString(*szCol)));
		int icolFeatureInstalled = pFeatureTable->GetColumnIndex(pDatabase->EncodeString(*MsiString(*sztblFeature_colInstalled)));
		if(icolFeatureAction && icolFeatureInstalled)
		{

			PMsiCursor pFeatureCursor(pFeatureTable->CreateCursor(fFalse));
			while ((fFeaturesInstalled == fFalse) && (pFeatureCursor->Next()))
			{
				iisEnum iisAction = (iisEnum) pFeatureCursor->GetInteger(icolFeatureAction);
				iisEnum iisInstalled = (iisEnum) pFeatureCursor->GetInteger(icolFeatureInstalled);
				if (iisAction != iMsiNullInteger)
					iisInstalled = iisAction;
				if (iisInstalled != iMsiNullInteger && iisInstalled != iisAbsent)
					fFeaturesInstalled = fTrue;
			}
		}
		else
		{
			// temp columns not added, assume this means costing wasn't performed
			// probably doing a simple task like MsiCollectUserInfo - return true so product is not unregistered
			fFeaturesInstalled = fTrue;
		}
	}
	AssertRecord(pError);//!!
	return fFeaturesInstalled;
}

Bool CMsiEngine::FreeSelectionTables()
//----------------------------------
{
	Bool fInstalledSelections = fFalse;
	if (m_piComponentTable && m_colComponentAction && m_colComponentInstalled)
	{
		PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
		while (pComponentCursor->Next())
		{
			iisEnum iisAction = (iisEnum) pComponentCursor->GetInteger(m_colComponentAction);
			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			if (iisAction != iMsiNullInteger)
			{
				iisInstalled = iisAction;
				AssertNonZero(pComponentCursor->PutInteger(m_colComponentInstalled,iisInstalled));
				AssertNonZero(pComponentCursor->Update());
			}
			if (iisInstalled != iMsiNullInteger && iisInstalled != iisAbsent)
				fInstalledSelections = fTrue;
		}
	}
	if (m_piFeatureCursor)
	{
		m_piFeatureCursor->Release();
		m_piFeatureCursor = 0;
	}
	if (m_piFeatureTable)
	{
		m_piFeatureTable->Release();
		m_piFeatureTable = 0;
	}

	if (m_piFeatureComponentsCursor)
	{
		m_piFeatureComponentsCursor->Release();
		m_piFeatureComponentsCursor = 0;
	}
	
	if (m_piFeatureComponentsTable)
	{
		m_piFeatureComponentsTable->Release();
		m_piFeatureComponentsTable = 0;
	}
	if (m_piComponentCursor)
	{
		m_piComponentCursor->Release();
		m_piComponentCursor = 0;
	}
	if (m_piComponentTable)
	{
		m_piComponentTable->Release();
		m_piComponentTable = 0;
	}
	if (m_piCostAdjusterTable)
	{
		m_piCostAdjusterTable->Release();
		m_piCostAdjusterTable = 0;
	}
	if (m_piVolumeCostTable)
	{
		m_piVolumeCostTable->Release();
		m_piVolumeCostTable = 0;
	}
	if (m_piCostLinkTable)
	{
		m_piCostLinkTable->Release();
		m_piCostLinkTable = 0;
	}
	if (m_piFeatureCostLinkTable)
	{
		m_piFeatureCostLinkTable->Release();
		m_piFeatureCostLinkTable = 0;
	}
	return fInstalledSelections;
}


IMsiRecord* CMsiEngine::ProcessPropertyFeatureRequests(int* iRequestCountParam, Bool fCountOnly)
/*---------------------------------------------------------------------------
Examines these properties:

ADDLOCAL,ADDSOURCE,ADDDEFAULT,REMOVE,REINSTALL, REINSTALLMODE
COMPADDLOCAL,COMPADDSOURCE,COMPADDDEFAULT
FILEADDLOCAL,FILEADDSOURCE,FILEADDDEFAULT

and appropriately configures the installation state of the specified features
(if any).  If iRequestCountParam, is nonzero, the count of feature
configuration requests (not the total count of features being configured)
will be returned.  If fCountOnly is fTrue, ONLY the request count will be
returned - no feature configuration states will actually be changed.
---------------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec;

	if (!fCountOnly)
	{
		MsiString strReinstallMode(GetPropertyFromSz(IPROPNAME_REINSTALLMODE));
		if (strReinstallMode.TextSize() != 0)
		{
			piErrRec = SetReinstallMode(*strReinstallMode);
			if (piErrRec)
				return piErrRec;
		}
	}

	// check to see if we have nothing to do
	bool fNoActionToPerform = false;
	MsiString strNoAction(GetPropertyFromSz(szFeatureSelection));
	if (strNoAction.TextSize())
	{
		Assert(0 != strNoAction.Compare(iscExact, szFeatureDoNothingValue));
		fNoActionToPerform = true;
		if (!fCountOnly)
		{
			// on 1st install, the only selections made were to to turn everything off -- in essence, do nothing
			// we want to ensure that we do not install anything since we've already turned them off on the client
			if ((piErrRec = ConfigureAllFeatures((iisEnum)iMsiNullInteger)) != 0)
				return piErrRec;
		}
	}

	int cCount = 0;
	int iRequestCount = 0;
	for(cCount = 0; cCount < g_cFeatureProperties; cCount++)
	{
		MsiString strFeatureInfo(GetPropertyFromSz(g_rgFeatures[cCount].szFeatureActionProperty));
		strFeatureInfo += TEXT(","); // helps our loop
		while(strFeatureInfo.TextSize())
		{
			MsiString strFeature = strFeatureInfo.Extract(iseUpto, ',');
			if(strFeature.TextSize())
			{
				iRequestCount++;
				if (!fCountOnly)
				{
					switch (g_rgFeatures[cCount].ircRequestClass)
					{
						case ircFeatureClass:
						{
							piErrRec = ConfigureThisFeature(*strFeature,g_rgFeatures[cCount].iisFeatureRequest, /* fThisOnly=*/ fTrue);
							if (piErrRec)
								return piErrRec;
							break;
						}
						case ircComponentClass:
						{
							MsiString strComponent;
							if ((piErrRec = ComponentIDToComponent(*strFeature, *&strComponent)) != 0)
								return piErrRec;
							if ((piErrRec = ConfigureComponent(*strComponent,g_rgFeatures[cCount].iisFeatureRequest)) != 0)
							if (piErrRec)
								return piErrRec;
							break;
						}
						case ircFileClass:
						{
							piErrRec = ConfigureFile(*strFeature,g_rgFeatures[cCount].iisFeatureRequest);
							if (piErrRec)
								return piErrRec;
							break;
						}
						default:
						{
							Assert(0);
							break;
						}
					}
				}
			}
			strFeatureInfo.Remove(iseIncluding, ',');
		}
	}
	if (fNoActionToPerform)
	{
		Assert(iRequestCount == 0);
	}

	if (iRequestCountParam)
		*iRequestCountParam = fNoActionToPerform ? 1 : iRequestCount;
	return 0;
}

IMsiRecord* CMsiEngine::ComponentIDToComponent(const IMsiString& riIDString,
											   const IMsiString*& rpiComponentString)
/*--------------------------------------------------------------------------
Local routine that accepts a ComponentID string, and returns the associated
Component's key name.  If the ComponentID is unknown, and error record will
be returned instead.
--------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	CreateSharedCursor(piComponentCursor, m_piComponentCursor);
	m_piComponentCursor->SetFilter(iColumnBit(m_colComponentID));
	m_piComponentCursor->PutString(m_colComponentID,riIDString);
	if (m_piComponentCursor->Next())
	{
		rpiComponentString = &m_piComponentCursor->GetString(m_colComponentKey);
	}
	else
		return PostError(Imsg(idbgBadComponent),riIDString);

	return 0;

}

IMsiRecord* CMsiEngine::SetReinstallMode(const IMsiString& riModeString)
//--------------------------------------
{
	const ICHAR* pchModeChars = szReinstallMode;
	const ICHAR* pchMode = riModeString.GetString();
	m_fMode &= 0x0000FFFF; // Clear all install overwrite bits
	ICHAR ch;
	while ((ch = *pchMode++) != 0)
	{
		if (ch == ' ')
			continue;
		if (ch >= 'A' && ch <= 'Z')
			ch += ('a' - 'A');
		for (const ICHAR* pch = pchModeChars; *pch != ch; pch++)
		{
			if (*pch == 0)
				return PostError(Imsg(idbgBadReinstallMode),pch);
		}
		m_fMode |= (1 << (16 + pch - pchModeChars));
	}
	AssertNonZero(SetProperty(*MsiString(IPROPNAME_REINSTALLMODE), riModeString));
	return 0;
}

IMsiRecord* CMsiEngine::ConfigureFile(const IMsiString& riFileString,iisEnum iisActionRequest)
/*-------------------------------------------------------------------
Examines every feature linked to the component that owns riFileString
(via the File table), and calls ConfigureFeature on the feature that
would incur the smallest disk cost to install.
---------------------------------------------------------------------*/
{
	const ICHAR szSqlFile[] =
	TEXT("SELECT `Component_` FROM `File` WHERE `File`=?");

	enum ifqEnum
	{
		ifqComponent = 1,
		ifqNextEnum
	};
	PMsiView pFileView(0);
	IMsiRecord* piErrRec;
	piErrRec = OpenView(szSqlFile, ivcFetch, *&pFileView);
	if (piErrRec)
		return piErrRec;

	PMsiServices pServices(GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(1));
	pExecRec->SetMsiString(1, riFileString);
	if ((piErrRec = pFileView->Execute(pExecRec)) != 0)
		return piErrRec;
	
	 PMsiRecord pFileRec(pFileView->Fetch());
	 if (pFileRec == 0)
		 return PostError(Imsg(idbgBadFile),riFileString);

	 if ((piErrRec = ConfigureComponent(*MsiString(pFileRec->GetMsiString(ifqComponent)),iisActionRequest)) != 0)
		 return piErrRec;

	 return 0;
}



IMsiRecord* CMsiEngine::ConfigureComponent(const IMsiString& riComponentString,iisEnum iisActionRequest)
/*-------------------------------------------------------------------
Examines every feature linked to riComponentString, and calls
ConfigureFeature on the feature that would incur the smallest disk
cost to install.
---------------------------------------------------------------------*/
{
	CreateSharedCursor(pFeatureComponentsCursor,m_piFeatureComponentsCursor);
	Assert(m_piFeatureComponentsCursor);
	m_piFeatureComponentsCursor->SetFilter(iColumnBit(m_colFeatureComponentsComponent));
	m_piFeatureComponentsCursor->PutString(m_colFeatureComponentsComponent,riComponentString);
	IMsiRecord* piErrRec;

	MsiString strCheapestFeature;
	int iCheapestCost = 2147483647; // Init to largest possible cost
	while (m_piFeatureComponentsCursor->Next())
	{
		int iFeatureCost;
		MsiString strFeature = m_piFeatureComponentsCursor->GetString(m_colFeatureComponentsFeature);
		if ((piErrRec = GetAncestryFeatureCost(*strFeature,iisActionRequest,iFeatureCost)) != 0)
			return piErrRec;

		if (iFeatureCost < iCheapestCost)
		{
			strCheapestFeature = strFeature;
			iCheapestCost = iFeatureCost;
		}
	}
	if (strCheapestFeature.TextSize() > 0)
		return ConfigureThisFeature(*strCheapestFeature,iisActionRequest, /* fThisOnly= */ fTrue);
	else
		return PostError(Imsg(idbgBadComponent),riComponentString);
}


IMsiRecord* CMsiEngine::ConfigureFeature(const IMsiString& riFeatureString,iisEnum iisActionRequest)
//--------------------------------------
{
	return ConfigureThisFeature(riFeatureString, iisActionRequest, /* fThisOnly= */ fFalse);
}


IMsiRecord* CMsiEngine::ConfigureThisFeature(const IMsiString& riFeatureString,iisEnum iisActionRequest, Bool fThisOnly)
//---------------------------------------------------------------------------------------
// If fThisOnly is true, only the specified feature will be configured, without affecting
// any child features.
//---------------------------------------------------------------------------------------
{
	IMsiRecord *piErrRec;
	
	Bool fArgAll = riFeatureString.Compare(iscExactI, IPROPVALUE_FEATURE_ALL) ? fTrue : fFalse;
	if (fArgAll)
	{
		// Before we used to call SetCostingComplete(false) -- but this was wrong.  This was
		// made under the assumption that specification of ALL would only occur on the command line.
		// However, this is not the case as a custom action can call MsiSetFeatureState("ALL") during
		// an install in order to force all features to go to one state. SetCostingComplete(false)
		// is expensive as it results in re-initialization of all dynamic costing.  This is already taken
		// care of when the install starts via SetInstallLevel which is called by the CostFinalize action.
		// All we really want here is to simply update the cost based upon the changing action states of
		// the components
		piErrRec = ConfigureAllFeatures(iisActionRequest);
		if (piErrRec)
			return piErrRec;

		if (!fThisOnly)
		{
			if ((piErrRec = UpdateFeatureActionState(0,/* fTrackParent = */ fFalse)) != 0)
				return piErrRec;
			if ((piErrRec = UpdateFeatureComponents(0)) != 0)
				return piErrRec;
		}
	}
	else if (fThisOnly)
	{
		piErrRec = SetThisFeature(riFeatureString,iisActionRequest, /* fSettingAll = */ fFalse);
		if (piErrRec)
			return piErrRec;
	}
	else
	{
		piErrRec = SetFeature(riFeatureString,iisActionRequest);
		if (piErrRec)
			return piErrRec;
	}


	return DetermineEngineCostOODS();

}


IMsiRecord* CMsiEngine::ConfigureAllFeatures(iisEnum iisActionRequest)
/*------------------------------------------------------------
Internal function that sets all non-disabled features to the
requested state.
--------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(0);
	IMsiRecord* piErrRec;
	while (pFeatureCursor->Next() > 0)
	{
		MsiString istrFeature = pFeatureCursor->GetString(m_colFeatureKey);
		piErrRec = SetThisFeature(*istrFeature, iisActionRequest, /* fSettingAll= */ fTrue);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}


IMsiRecord* CMsiEngine::ProcessConditionTable()
//-------------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	bool fAdmin = GetMode() & iefAdmin;
	
	PMsiTable pConditionTable(0);
	IMsiRecord* piError;
	if ((piError = m_piDatabase->LoadTable(*MsiString(*sztblCondition), 0, *&pConditionTable)))
	{       // Not a problem if Condition table not found
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}

	int colFeature = pConditionTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblCondition_colFeature));
	int colCondition = pConditionTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblCondition_colCondition));
	int colLevel     = pConditionTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblCondition_colLevel));
	PMsiCursor pCursor(pConditionTable->CreateCursor(fFalse));
	Assert(pCursor);
	if (!colFeature || !colCondition || !colLevel)
		return PostError(Imsg(idbgTableDefinition),sztblCondition);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(1);
	while (pCursor->Next())
	{
		pFeatureCursor->Reset();
		MsiString istrConditionFeature(pCursor->GetString(colFeature));
		pFeatureCursor->PutString(m_colFeatureKey, *istrConditionFeature);
		if (pFeatureCursor->Next())
		{
#ifdef DEBUG
			const ICHAR* szFeature = MsiString(pCursor->GetString(colFeature));
#endif
			if (fAdmin || EvaluateCondition(MsiString(pCursor->GetString(colCondition))) == iecTrue)
			{
				pFeatureCursor->PutInteger(m_colFeatureLevel, pCursor->GetInteger(colLevel));
				AssertNonZero(pFeatureCursor->Update());
			}
		}
		else
			return PostError(Imsg(idbgBadForeignKey),
				*MsiString(m_piDatabase->DecodeString(pCursor->GetInteger(colFeature))),
				*MsiString(*sztblCondition_colFeature),*MsiString(*sztblCondition));
	}
	return 0;
}

IMsiRecord* CMsiEngine::SetInstallLevel(int iInstallLevel)
//-------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// determine the client state for the product

	// If called with iInstallLevel == 0, indicates caller doesn't want to
	// change the current installLevel; just wants to update all features
	if (iInstallLevel > 0)
		AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_INSTALLLEVEL),iInstallLevel));
	else
		iInstallLevel = GetPropertyInt(*MsiString(*IPROPNAME_INSTALLLEVEL));

	// If the install level has never been set, default to 1
	if (iInstallLevel == iMsiNullInteger)
	{
		iInstallLevel = 1;
		AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_INSTALLLEVEL),iInstallLevel));
	}

	IMsiRecord* piErrRec = 0;
	int iPropertyFeatureRequestCount = 0;
	if(!(m_fMode & iefAdvertise))
	{
		// If any Feature selection requests are pending via a property such as ADDLOCAL, ADDSOURCE, etc,
		// then only those requests shall be honored.  We won't select ON any features here in SetInstallLevel.
		piErrRec = ProcessPropertyFeatureRequests(&iPropertyFeatureRequestCount,/* fCountOnly = */ fTrue);
		if (piErrRec)
			return piErrRec;
	}

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fTrue));
	pFeatureCursor->Reset();
	pFeatureCursor->SetFilter(0);
	int iTreeLevel;

	iisEnum iisParInstalled[MAX_COMPONENT_TREE_DEPTH + 1];

	PMsiCursor pFeatureComponentsCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
	pFeatureComponentsCursor->SetFilter(1);

	PMsiCursor pFeatureCursorTemp(m_piFeatureTable->CreateCursor(fTrue));
	
	while ((iTreeLevel = pFeatureCursor->Next()) > 0)
	{
		if (iTreeLevel > MAX_COMPONENT_TREE_DEPTH)
			return PostError(Imsg(idbgIllegalTreeDepth),MAX_COMPONENT_TREE_DEPTH);
		
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiStringId idFeature = pFeatureCursor->GetInteger(m_colFeatureKey);
#ifdef DEBUG
		ICHAR rgchFeature[256];
		MsiString stFeature(m_piDatabase->DecodeString(idFeature));
		stFeature.CopyToBuf(rgchFeature,255);
#endif

		iisParInstalled[iTreeLevel] = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
		Bool fMaint = GetMode() & iefMaintenance ? fTrue : fFalse;
		Bool fParInstalled = (iTreeLevel == 1 || (iisParInstalled[iTreeLevel  - 1] != iMsiNullInteger &&
					  iisParInstalled[iTreeLevel - 1] != iisAbsent &&
							  iisParInstalled[iTreeLevel - 1] != iisAdvertise)) ?
								fTrue : fFalse;

		// m_colFeatureLevel and m_colFeatureAttributes are temporary runtime versions
		// of the authored columns - temporary so that they can be altered at runtime.
		// If a value hasn't been set yet, copy over the authored values from the
		// permanent columns.
		int iFeatureLevel = pFeatureCursor->GetInteger(m_colFeatureLevel);
		if (iFeatureLevel == iMsiNullInteger)
		{
			iFeatureLevel = pFeatureCursor->GetInteger(m_colFeatureAuthoredLevel);
			AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureLevel,iFeatureLevel));
			AssertNonZero(pFeatureCursor->Update());
		}
		int ifeaAttributes = pFeatureCursor->GetInteger(m_colFeatureAttributes);
		if (ifeaAttributes == iMsiNullInteger)
		{
			ifeaAttributes = pFeatureCursor->GetInteger(m_colFeatureAuthoredAttributes);
			AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureAttributes,ifeaAttributes));
			AssertNonZero(pFeatureCursor->Update());
		}

#ifdef DEBUG
		if (iFeatureLevel == iMsiNullInteger)
			return PostError(Imsg(idbgNullInNonNullableColumn),stFeature,sztblFeature_colLevel,sztblFeature);
#endif

		// Determine the default Select state for the feature, and store it for
		// future use in the 'DefaultSelect' column.
		int iValidStates;
		piErrRec = GetFeatureValidStates(idFeature,iValidStates, pFeatureComponentsCursor, pFeatureCursorTemp);
		if (piErrRec)
			return piErrRec;
		
		iisEnum iisFeatureSelect = (iisEnum) iMsiNullInteger;
		if (((ifeaAttributes & ifeaInstallMask) == ifeaFavorSource) && (iValidStates & icaBitSource))
			iisFeatureSelect = iisSource;
		else if (iValidStates & icaBitLocal)
			iisFeatureSelect = iisLocal;
		else if (iValidStates & icaBitSource)
			iisFeatureSelect = iisSource;

		int iRuntimeFlags = iValidStates & icaBitPatchable ? bfFeaturePatchable : 0;
		iRuntimeFlags |= (iValidStates & icaBitCompressable ? bfFeatureCompressable : 0);
		AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureRuntimeFlags, iRuntimeFlags));
		AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureDefaultSelect,iisFeatureSelect));
		AssertNonZero(pFeatureCursor->Update());

		// No features will be selected ON if either in maintenance, or if property feature
		// requests are pending.
		Bool fFeatureSelectable =
			((m_fMode & iefAdvertise) || ((fMaint == fFalse || fParInstalled == fFalse) && iPropertyFeatureRequestCount == 0)) ? fTrue : fFalse;

		if (fFeatureSelectable && iFeatureLevel > 0 && iFeatureLevel <= iInstallLevel)
		{
			if(!(m_fMode & iefAdvertise))
			{
				AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect,
					  (ifeaAttributes & ifeaFavorAdvertise) && (iValidStates & icaBitAdvertise) ? iisAdvertise : iisFeatureSelect));
			}
			else
			{
				AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect,
							  (iValidStates & icaBitAdvertise) ? iisAdvertise : iisAbsent));
			}
		}
		else
		{
			AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect, iMsiNullInteger));
		}
		AssertNonZero(pFeatureCursor->Update());

	}
	if ((piErrRec = ProcessPropertyFeatureRequests(0,/* fCountOnly = */ fFalse)) != 0)
		return piErrRec;
	if ((piErrRec = UpdateFeatureActionState(0,/* fTrackParent = */ fFalse, pFeatureComponentsCursor, pFeatureCursorTemp)) != 0)
		return piErrRec;
	if ((piErrRec = UpdateFeatureComponents(0)) != 0)
		return piErrRec;
		
	if ((piErrRec = DetermineEngineCostOODS()) != 0)
		return piErrRec;

	if (m_fCostingComplete == fFalse && m_iuiLevel == iuiFull)
	{
		if ((piErrRec = InitializeDynamicCost(/* fReinitialize = */ fFalse)) != 0)
			return piErrRec;
	}
	m_fSelManInitComplete = true;
	return 0;
}

IMsiRecord* CMsiEngine::SetAllFeaturesLocal()
//-------------------------------------
{
	IMsiRecord* piErrRec = 0;
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	while (pFeatureCursor->Next())
	{
#ifdef DEBUG
		MsiString strFeature = pFeatureCursor->GetString(m_colFeatureKey);
		ICHAR rgchFeature[256];
		strFeature.CopyToBuf(rgchFeature,255);
#endif

		AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect,iisLocal));
		AssertNonZero(pFeatureCursor->Update());
	}
	if ((piErrRec = UpdateFeatureActionState(0,/* fTrackParent = */ fFalse)) != 0)
		return piErrRec;
	if ((piErrRec = UpdateFeatureComponents(0)) != 0)
		return piErrRec;
		
	if ((piErrRec = DetermineEngineCostOODS()) != 0)
		return piErrRec;

	if (m_fCostingComplete == fFalse)
	{
		if ((piErrRec = InitializeDynamicCost(/* fReinitialize = */ fFalse)) != 0)
			return piErrRec;
	}
	return 0;
}



IMsiRecord* CMsiEngine::SetThisFeature(const IMsiString& riFeatureString, iisEnum iisRequestedState, Bool fSettingAll)
//--------------------------------------------------------------------------------
/* Sets the specified feature to the specified select state, without affecting any
   child features.  As an optimization, pass fSettingAll as true if SetThisFeature
   will be called for every feature in the product.
---------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;
	MsiString strFeature(riFeatureString.GetString());
	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	pFeatureCursor->Reset();
	pFeatureCursor->PutString(m_colFeatureKey, *strFeature);
	if (!pFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeature);

	// if Level == 0, the feature is permanently disabled
	if (pFeatureCursor->GetInteger(m_colFeatureLevel) == 0)
		return 0;

	// A requested state of iisCurrent denotes a request for the 'default' authored install state
	if (iisRequestedState == iisCurrent)
		iisRequestedState = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureDefaultSelect);

	iisEnum iisInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);

	// bug 7468 - prevent ABSENT -> ABSENT always and !! in the future prevent <state X> -> <state X> in all cases except reinstall
	if((iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent) && (iisRequestedState == iisAbsent || iisRequestedState == iisReinstall)) // || (iisInstalled == iisRequestedState))
		iisRequestedState = (iisEnum)iMsiNullInteger;

	iisEnum iisSelect;
	piErrRec = ValidateFeatureSelectState(riFeatureString,iisRequestedState,iisSelect);
	if (piErrRec)
		return piErrRec;

	pFeatureCursor->PutInteger(m_colFeatureSelect,iisSelect);
	pFeatureCursor->Update();
	iisEnum iisFinalState = iisSelect == iMsiNullInteger ? iisInstalled : iisSelect;

	// If the request is to install the feature, we must also make sure that
	// all parent features get installed (if they are not already selected)
	// Also, if fSettingAll is true, we know we don't need to bother turning
	// on parent, because the caller has (or will) initialize every feature
	// in the product to the desired state.
	if (!fSettingAll && iisSelect != iisAbsent && iisSelect != iMsiNullInteger)
	{
		MsiString strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		while (strFeatureParent.TextSize() && !strFeatureParent.Compare(iscExact,strFeature))
		{
			pFeatureCursor->Reset();
			pFeatureCursor->PutString(m_colFeatureKey, *strFeatureParent);
			if (!pFeatureCursor->Next())
				return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeatureParent);

			iisEnum iParInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
			iisEnum iParSelect = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureSelect);
			iisEnum iParFinalState = iParSelect == iMsiNullInteger ? iParInstalled : iParSelect;
			
			// if the parent's final state is to be installed, we don't need to
			// change anything, and we can stop walking up the parent tree, since
			// we therefore know that all parents up to the root must also be "ON"
			if (iParFinalState != iisAbsent && iParFinalState != iMsiNullInteger && iParFinalState != iisAdvertise)
				break;

			// We'll try to set the parent to the install state that the child was set to, but if
			// that state isn't valid for the parent, ValidateFeatureSelectState will change it to
			// a valid state for us.
			iisEnum iisParSelect = iParInstalled == iisFinalState ? (iisEnum) iMsiNullInteger : iisFinalState;

			iisEnum iisValidState;
			piErrRec = ValidateFeatureSelectState(*strFeatureParent,iisParSelect,iisValidState);
			if (piErrRec)
				return piErrRec;
			if (iisValidState == iParInstalled)
				iisValidState = (iisEnum) iMsiNullInteger;

			pFeatureCursor->PutInteger(m_colFeatureSelect,iisValidState);
			pFeatureCursor->Update();
			strFeature = strFeatureParent;
			strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::SetFeatureAttributes(const IMsiString& ristrFeature, int iAttributes)
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// Must be called before SetInstallLevel has been called
	if (m_fSelManInitComplete)
		return PostError(Imsg(idbgBadActionData), 0);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	pFeatureCursor->Reset();
	pFeatureCursor->PutString(m_colFeatureKey, ristrFeature);
	if (!pFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature), ristrFeature.GetString());

	int iAttributesToSet = (iAttributes & INSTALLFEATUREATTRIBUTE_FAVORLOCAL) ? msidbFeatureAttributesFavorLocal : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_FAVORSOURCE) ? msidbFeatureAttributesFavorSource : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_FOLLOWPARENT) ? msidbFeatureAttributesFollowParent : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_FAVORADVERTISE) ? msidbFeatureAttributesFavorAdvertise : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE) ? msidbFeatureAttributesDisallowAdvertise : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE) ? msidbFeatureAttributesNoUnsupportedAdvertise : 0;

	pFeatureCursor->PutInteger(m_colFeatureAttributes,iAttributesToSet);
	pFeatureCursor->Update();
	return 0;
}


IMsiRecord* CMsiEngine::SetFeature(const IMsiString& riFeatureString, iisEnum iisRequestedState)
//--------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	bool fSetAll = false;
	IMsiRecord* piErrRec;
	if (iisRequestedState == iisLocalAll || iisRequestedState == iisSourceAll)
	{
		fSetAll = true;
		iisRequestedState = iisRequestedState == iisLocalAll ? iisLocal : iisSource;
		piErrRec = SetFeatureChildren(riFeatureString, iisRequestedState);
		if (piErrRec)
			return piErrRec;
	}

	MsiString strFeature(riFeatureString.GetString());
	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	pFeatureCursor->Reset();
	pFeatureCursor->PutString(m_colFeatureKey, *strFeature);
	if (!pFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeature);

	// if Level == 0, the feature is permanently disabled
	if (pFeatureCursor->GetInteger(m_colFeatureLevel) == 0)
		return 0;

	// A requested state of iisCurrent denotes a request for the 'default' authored install state
	if (iisRequestedState == iisCurrent)
		iisRequestedState = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureDefaultSelect);

	iisEnum iisSelect;
	piErrRec = ValidateFeatureSelectState(riFeatureString,iisRequestedState,iisSelect);
	if (piErrRec)
		return piErrRec;

	pFeatureCursor->PutInteger(m_colFeatureSelect,iisSelect);
	pFeatureCursor->Update();
	iisEnum iisInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
	iisEnum iisFinalState = iisSelect == iMsiNullInteger ? iisInstalled : iisSelect;

	// If the request is to install the feature, we must also make sure that
	// all parent features get installed (if they are not already selected)
	if (iisFinalState != iisAbsent && iisFinalState != iMsiNullInteger)
	{
		MsiString strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		while (strFeatureParent.TextSize() && !strFeatureParent.Compare(iscExact,strFeature))
		{
			pFeatureCursor->Reset();
			pFeatureCursor->PutString(m_colFeatureKey, *strFeatureParent);
			if (!pFeatureCursor->Next())
				return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeatureParent);

			iisEnum iParInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
			iisEnum iParAction = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureAction);
			iisEnum iParFinalState = iParAction == iMsiNullInteger ? iParInstalled : iParAction;
			
			// if the parent's final state is to be installed, we don't need to
			// change anything, and we can stop walking up the parent tree, since
			// we therefore know that all parents up to the root must also be "ON"
			if (iParFinalState != iisAbsent && iParFinalState != iMsiNullInteger && iParFinalState != iisAdvertise)
				break;

			// We'll try to set the parent to the install state that the child was set to, but if
			// that state isn't valid for the parent, ValidateFeatureSelectState will change it to
			// a valid state for us.
			iisEnum iisParSelect = iParInstalled == iisFinalState ? (iisEnum) iMsiNullInteger : iisFinalState;

			iisEnum iisValidState;
			piErrRec = ValidateFeatureSelectState(*strFeatureParent,iisParSelect,iisValidState);
			if (piErrRec)
				return piErrRec;
			if (iisValidState == iParInstalled)
				iisValidState = (iisEnum) iMsiNullInteger;

			pFeatureCursor->PutInteger(m_colFeatureSelect,iisValidState);
			pFeatureCursor->PutInteger(m_colFeatureRuntimeFlags,pFeatureCursor->GetInteger(m_colFeatureRuntimeFlags) | bfFeatureMark);
			pFeatureCursor->Update();
			strFeature = strFeatureParent;
			strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		}
	}

	// If we had to turn on one or more parent features above to get riFeatureString installed,
	// we've got some work to do.  In the above code, we 'marked' the parent features we
	// turned on, and below we'll 'mark' riFeatureString and all its children.  Then we can
	// turn off every feature below the topmost parent we had to turn on, specifically
	// excepting the 'marked' children (that's what the second call to MarkOrResetFeatureTree
	// does, you'll be happy to note).
	Bool fTrackParent = fTrue;

	if (!strFeature.Compare(iscExact,riFeatureString.GetString()))
	{
		fTrackParent = fFalse;
		piErrRec = MarkOrResetFeatureTree(riFeatureString, /* Mark */ fTrue);
		if (piErrRec)
			return piErrRec;
		piErrRec = MarkOrResetFeatureTree(*strFeature, /* Reset */ fFalse);
		if (piErrRec)
			return piErrRec;
	}


	// we do not want to track parent in case of reinstall or if we're setting all children
	if(iisFinalState == iisReinstall || fSetAll == true)
		fTrackParent = fFalse;

	// Also note that if we are updating the feature tree starting from some parent
	// of riFeatureString that we had to turn on, it would be bad to allow
	// UpdateFeatureActionState to do its usual work of flipping children
	// under strFeature to match strFeature's Attributes state.  We disable that
	// by setting fTrackParent to fFalse.
	piErrRec = UpdateFeatureActionState(strFeature,fTrackParent);
	if (piErrRec)
		return piErrRec;
	return UpdateFeatureComponents(strFeature);
}


IMsiRecord* CMsiEngine::ValidateFeatureSelectState(const IMsiString& riFeatureString,iisEnum iisRequestedState,
												   iisEnum& iisValidState)
/*----------------------------------------------------------------------------
Internal function that accepts a string specifying a feature, and a proposed
Select state.  In the iisValidState parameter, a valid state that is as 'close'
as possible to the proposed state is returned.
------------------------------------------------------------------------------*/
{
	int iValidStates;
	MsiStringId idFeatureString = m_piDatabase->EncodeString(riFeatureString);
	IMsiRecord* piErrRec = GetFeatureValidStates(idFeatureString,iValidStates);
	if (piErrRec)
		return piErrRec;
	
	if (iisRequestedState != iisSource && iisRequestedState != iisLocal && (iisRequestedState != iisAdvertise || (iValidStates & icaBitAdvertise)))
		iisValidState = iisRequestedState;
	else if(iisRequestedState == iisAdvertise && (iValidStates & icaBitAbsent))
		iisValidState = iisAbsent;
	else if (iisRequestedState == iisSource && (iValidStates & icaBitSource))
		iisValidState = iisSource;
	else if (iisRequestedState == iisLocal && (iValidStates & icaBitLocal))
		iisValidState = iisLocal;
	else if (iValidStates & icaBitSource)
		iisValidState = iisSource;
	else if (iValidStates & icaBitLocal)
		iisValidState = iisLocal;
	else
		iisValidState = (iisEnum) iMsiNullInteger;
	return 0;
}


IMsiRecord* CMsiEngine::SetFeatureChildren(const IMsiString& riFeatureString, iisEnum iisRequestedState)
/*----------------------------------------------------------------------------*/
{
	int iParentLevel = 0;
	int iTreeLevel = 0;
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all riFeatureString's children
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if ((iTreeLevel = pCursor->Next()) == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString.GetString());
	iParentLevel = iTreeLevel;
	pCursor->SetFilter(0);
	IMsiRecord* piErrRec;
	do
	{
		MsiString strChildFeature(pCursor->GetString(m_colFeatureKey));
#ifdef DEBUG
		ICHAR rgchFeature[256];
		strChildFeature.CopyToBuf(rgchFeature,255);
#endif
		iisEnum iisSelect;
		piErrRec = ValidateFeatureSelectState(*strChildFeature,iisRequestedState,iisSelect);
		if (piErrRec)
			return piErrRec;
		pCursor->PutInteger(m_colFeatureSelect,iisSelect);
		pCursor->Update();
	}while ((iTreeLevel = pCursor->Next()) > iParentLevel);
	return 0;
}


IMsiRecord* CMsiEngine::CheckFeatureTreeGrayState(const IMsiString& riFeatureString, bool& rfIsGray)
/*----------------------------------------------------------------------------*/
{
	rfIsGray = false;
	int iParentLevel = 0;
	int iTreeLevel = 0;
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all riFeatureString's children
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if ((iTreeLevel = pCursor->Next()) == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString.GetString());

	iisEnum iisParentState = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
	if (iisParentState == iMsiNullInteger)
		iisParentState = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
	iParentLevel = iTreeLevel;
	pCursor->SetFilter(0);

	while ((iTreeLevel = pCursor->Next()) > iParentLevel)
	{
		MsiString strChildFeature(pCursor->GetString(m_colFeatureKey));
#ifdef DEBUG
		ICHAR rgchFeature[256];
		strChildFeature.CopyToBuf(rgchFeature,255);
#endif
		// If level is zero, feature is disabled, and doesn't affect gray state
		if (pCursor->GetInteger(m_colFeatureLevel) == 0)
			continue;

		// If feature is hidden, doesn't affect gray state either
		int iDisplay = pCursor->GetInteger(m_colFeatureDisplay);
		if (iDisplay == 0 || iDisplay == iMsiNullInteger)
			continue;

		iisEnum iisChildState = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
		if (iisChildState == iMsiNullInteger)
			iisChildState = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);

		if (iisChildState != iisParentState)
		{
				rfIsGray = true;
				return 0;
		}
	}
	return 0;
}



IMsiRecord* CMsiEngine::MarkOrResetFeatureTree(const IMsiString& riFeatureString, Bool fMark)
/*----------------------------------------------------------------------------*/
{
	int iParentLevel = 0;
	int iTreeLevel = 0;
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all riFeatureString's children
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if ((iTreeLevel = pCursor->Next()) == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString.GetString());
	iParentLevel = iTreeLevel;
	pCursor->SetFilter(0);
	do
	{
#ifdef DEBUG
		MsiString pstrFeature(pCursor->GetString(m_colFeatureKey));
		ICHAR rgchFeature[256];
		pstrFeature.CopyToBuf(rgchFeature,255);
#endif
		int iRuntimeFlags = pCursor->GetInteger(m_colFeatureRuntimeFlags);
		if (fMark)
			pCursor->PutInteger(m_colFeatureRuntimeFlags, iRuntimeFlags | bfFeatureMark);
		else
		{
			if (iRuntimeFlags & bfFeatureMark)
				pCursor->PutInteger(m_colFeatureRuntimeFlags, iRuntimeFlags & !bfFeatureMark);
			else
			{
				iisEnum iisAction = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
				pCursor->PutInteger(m_colFeatureSelect,iisAction);
			}
		}
		pCursor->Update();
	}while ((iTreeLevel = pCursor->Next()) > iParentLevel);
	return 0;
}

IMsiRecord* CMsiEngine::UpdateFeatureActionState(const IMsiString* piFeatureString, Bool fTrackParent, IMsiCursor* piFeatureComponentCursor, IMsiCursor* piFeatureCursor)
/*----------------------------------------------------------------------------
Internal function which walks the Feature table tree that includes the
piFeatureString and all its children, updating the iisAction state of all the
components owned by each feature.  Unless fTrackParent is fFalse, all child
features of piFeatureString will be flipped (if selected for install) to match
the Attributes state of piFeatureString.  However, If Null is passed for
piFeatureString, the entire feature tree will be updated, and NO 'flipping'
will be performed.

Returns: An error record if an invalid condition was requested for the feature,
or if the feature is not found in the Feature Table.
------------------------------------------------------------------------------*/
{
	int iParentLevel = 0;
	int iTreeLevel = 0;
	iisEnum iParInstalled[MAX_COMPONENT_TREE_DEPTH + 1];
	iisEnum iParAction[MAX_COMPONENT_TREE_DEPTH + 1];
	iisEnum iParSelect[MAX_COMPONENT_TREE_DEPTH + 1];
	int     iParLevel[MAX_COMPONENT_TREE_DEPTH + 1];
	Bool fTrackParentAttributes = fFalse;

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	if (piFeatureString)
	{
		// Set up the tree-walking cursor for all piFeatureString's children
		pCursor->SetFilter(1);
		pCursor->PutString(m_colFeatureKey,*piFeatureString);
		if ((iTreeLevel = pCursor->Next()) == 0)
			return PostError(Imsg(idbgBadFeature),*piFeatureString);
		iParentLevel = iTreeLevel;
		pCursor->SetFilter(0);

		// Get piFeatureString's parent
		PMsiCursor pParCursor(m_piFeatureTable->CreateCursor(fFalse));
		pParCursor->SetFilter(1);
		pParCursor->PutString(m_colFeatureKey,*MsiString(pCursor->GetString(m_colFeatureParent)));
		int iParentParentLevel;
		if ((iParentParentLevel = pParCursor->Next()) != 0)
		{
			iParInstalled[iParentParentLevel] = (iisEnum) pParCursor->GetInteger(m_colFeatureInstalled);
			iParAction[iParentParentLevel] = (iisEnum) pParCursor->GetInteger(m_colFeatureAction);
			iParSelect[iParentParentLevel] = (iisEnum) pParCursor->GetInteger(m_colFeatureSelect);
			iParLevel[iParentParentLevel] = pParCursor->GetInteger(m_colFeatureLevel);
		}
	}
	else
	{
		pCursor->SetFilter(0);
		if ((iTreeLevel = pCursor->Next()) == 0)
			return PostError(Imsg(idbgBadFeature),TEXT(""));
	}

	do
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiStringId idFeature = pCursor->GetInteger(m_colFeatureKey);
		MsiString strFeature(m_piDatabase->DecodeString(idFeature));
#ifdef DEBUG
		ICHAR rgchFeature[256];
		strFeature.CopyToBuf(rgchFeature,255);
#endif
		if (fTrackParent && piFeatureString && !strFeature.Compare(iscExact,piFeatureString->GetString()))
			fTrackParentAttributes = fTrue;

		iisEnum iisSelect = (iisEnum) pCursor->GetInteger(m_colFeatureSelect);
		iisEnum iisInstalled = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
		Bool fInstalled = (iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent) ? fFalse : fTrue;

		// Action determination rules
		iisEnum iisOldAction = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
		iisEnum iisAction = (iisEnum) iMsiNullInteger;

		int iValidStates;
		IMsiRecord* piErrRec = GetFeatureValidStates(idFeature,iValidStates, piFeatureComponentCursor, piFeatureCursor);
		if (piErrRec)
			return piErrRec;

		// Determine whether the parent will be in an installed state after termination of setup
		if (iTreeLevel > 1)
		{
			iisEnum iisParentFinalStateInstalled = ((iParAction[iTreeLevel -1] != iMsiNullInteger) &&
				(iParAction[iTreeLevel -1] != iisReinstall)) ? iParAction[iTreeLevel -1] : iParInstalled[iTreeLevel - 1];
			// we have an active selection
			if((iisSelect != iMsiNullInteger) &&
				((iisSelect == iisAbsent ||
				  iisParentFinalStateInstalled == iisLocal ||
				  iisParentFinalStateInstalled == iisSource) ||
				 ((iisSelect == iisAdvertise || (iisSelect == iisReinstall && iisInstalled == iisAdvertise)) && iisParentFinalStateInstalled == iisAdvertise)))
			{
				iisAction = iisSelect; // the selection is okay
			}
			else if (iisParentFinalStateInstalled != iisLocal && iisParentFinalStateInstalled != iisSource &&
				(fInstalled  || iisSelect != iMsiNullInteger))
			{
				// parent is either absent or advertised, we may need to tweak the selection of the child
				if(iisParentFinalStateInstalled == iisAdvertise && (iValidStates & icaBitAdvertise))
					iisAction = (iisInstalled == iisAdvertise) ? (iisEnum) iMsiNullInteger : iisAdvertise;
				else
					iisAction = (fInstalled) ? iisAbsent : (iisEnum) iMsiNullInteger;
			}
		}
		else
		{
			// This selection has no parent
			iisAction = iisSelect;
		}


		// All ifeaFollowParent features must track the parent's UseSource status
		int iFeatureAttributes = pCursor->GetInteger(m_colFeatureAttributes);
		if (iFeatureAttributes == iMsiNullInteger)
			iFeatureAttributes = 0;

		if(iTreeLevel > 1)
		{
			// the iParFinalState should be used only if iTreeLevel > 1
			iisEnum iParFinalState = (iParAction[iTreeLevel - 1] == iMsiNullInteger || iParAction[iTreeLevel - 1] == iisReinstall) ? iParInstalled[iTreeLevel - 1] : iParAction[iTreeLevel - 1];
			iisEnum iFinalState = iisAction == iMsiNullInteger ? iisInstalled : iisAction;
			if((iFeatureAttributes & ifeaUIDisallowAbsent) && !(iFeatureAttributes & ifeaDisallowAdvertise) &&
				iParFinalState == iisAdvertise)
			{
				iisAction = (iisInstalled == iisAdvertise) ? (iisEnum) iMsiNullInteger : iisAdvertise;
			}
			else if ((iFeatureAttributes & ifeaUIDisallowAbsent) && (iParFinalState == iisLocal || iParFinalState == iisSource) &&
				iFinalState == iisAbsent)
			{
				if (iParFinalState == iisLocal)
				{
					if (iValidStates & icaBitLocal)
						iisAction = iisSelect = (iisInstalled == iisLocal) ? (iisEnum) iMsiNullInteger : iisLocal;
					else
						iisAction = iisSelect = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
				}
				else
				{
					if (iValidStates & icaBitSource)
						iisAction = iisSelect = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
					else
						iisAction = iisSelect = (iisInstalled == iisLocal) ? (iisEnum) iMsiNullInteger : iisLocal;
				}
			}
			else if (fTrackParentAttributes || ((iFeatureAttributes & ifeaInstallMask) == ifeaFollowParent))
			{
				if (iParFinalState == iisLocal && iFinalState == iisSource && (iValidStates & icaBitLocal))
					iisAction = iisSelect = (iisInstalled == iisLocal) ? (iisEnum) iMsiNullInteger : iisLocal;
				else if (iParFinalState == iisSource && iFinalState == iisLocal && (iValidStates & icaBitSource))
					iisAction = iisSelect = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
				else if (iParFinalState == iisSource && iFinalState == iisAdvertise && (iValidStates & icaBitSource))
					iisAction = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
			}
		}

		// Features that are currently installed RunFromSource might have components that subsequently need
		// to be patched.  We can't leave it RunFromSource so we set them local.  But, if we are uninstalling
		// the feature, there is no need to patch it.
		int iRuntimeFlags = pCursor->GetInteger(m_colFeatureRuntimeFlags);
		if (((iRuntimeFlags & bfFeaturePatchable) || (iRuntimeFlags & bfFeatureCompressable)) && iisInstalled == iisSource && iisAction != iisLocal && iisAction != iisAbsent)
			iisAction = iisSelect = iisLocal;

		// If this feature's parent is disabled (install level is 0), disable all
		// children as well.  Note that in Admin mode, we disable only those features that
		// have specifically been authored with a 0 in the Level column.
		Bool fAdmin = GetMode() & iefAdmin ? fTrue : fFalse;
		int iInstallLevel = pCursor->GetInteger(fAdmin ? m_colFeatureAuthoredLevel : m_colFeatureLevel);
		if (iTreeLevel > 1 && iParLevel[iTreeLevel - 1] == 0)
		{
			iInstallLevel = 0;
			AssertNonZero(pCursor->PutInteger(m_colFeatureLevel,0));
		}

		// And, of course, disabled features can't be selected or acted upon
		if (iInstallLevel == 0)
			iisAction = iisSelect = (iisEnum) iMsiNullInteger;

		iParLevel[iTreeLevel] = iInstallLevel;
		iParInstalled[iTreeLevel] = iisInstalled;
		iParAction[iTreeLevel] = iisAction;
		iParSelect[iTreeLevel] = iisSelect;


		AssertNonZero(pCursor->PutInteger(m_colFeatureActionRequested, iisAction));
		AssertNonZero(pCursor->PutInteger(m_colFeatureSelect, iisSelect));
		if(iisAction == iisAbsent && m_fAlienClients) // there are other clients to the product
			iisAction = (iisEnum)iMsiNullInteger;
		pCursor->PutInteger(m_colFeatureAction, iisAction);
		AssertNonZero(pCursor->Update());
		if (m_fCostingComplete && iisAction != iisOldAction)
		{
			IMsiRecord* piErrRec;
			if ((piErrRec = RecostFeatureLinkedComponents(*strFeature)) != 0)
				return piErrRec;
		}

	}while ((iTreeLevel = pCursor->Next()) > iParentLevel);
	return 0;
}


IMsiRecord* CMsiEngine::RecostFeatureLinkedComponents(const IMsiString& riFeatureString)
/*----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// No recosting needed during initialization
	if (m_fCostingComplete == fFalse)
		return 0;

	// Recost every component that is explicitly linked to riComponentString
	if (m_piFeatureCostLinkTable)
	{
		PMsiCursor pCursor(0);
		AssertNonZero(pCursor = m_piFeatureCostLinkTable->CreateCursor(fFalse));
		pCursor->Reset();
		pCursor->SetFilter(iColumnBit(m_colFeatureCostLinkFeature));
		pCursor->PutString(m_colFeatureCostLinkFeature,riFeatureString);
		while (pCursor->Next())
		{
			IMsiRecord* piErrRec;
			if ((piErrRec = RecostComponent(pCursor->GetInteger(m_colFeatureCostLinkComponent),/*fCostLinked = */true)) != 0)
				return piErrRec;
		}
	}
	return 0;
}



IMsiRecord* CMsiEngine::UpdateFeatureComponents(const IMsiString* piFeatureString)
/*-----------------------------------------------------------------------
Internal function that sets the installed state of all the components
associated with the given feature, such that the components match the
installed state of the feature.  If piFeatureString is passed as NULL,
then the components of ALL features will be updated.
------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (!m_piComponentTable)
		return 0; // no components to update

	IMsiRecord* piErrRec;
	
	if (piFeatureString == 0)
	{
		PMsiCursor pComponentCursor = m_piComponentTable->CreateCursor(fTrue);
		MsiStringId idTempId;

		// It's possible that this would be 0 if no temporary Id items
		// are in the table. That's ok, since we'll get back 0
		// and that won't compare with any of the real ids
		idTempId = m_piDatabase->EncodeStringSz(szTemporaryId);

		PMsiTable pCompFeatureTable(0);
		piErrRec = CreateComponentFeatureTable(*&pCompFeatureTable);

		if (piErrRec)
			return piErrRec;
			
		PMsiCursor pCursor(pCompFeatureTable->CreateCursor(fFalse));
		
		int colComponent = pCompFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colComponent));
		int colFeature = pCompFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colFeature));

		pCursor->SetFilter(iColumnBit(colComponent));
		iisEnum iisComponentInstalled;
		MsiStringId idComponent;

		while (pComponentCursor->Next())
		{
			if (idTempId && pComponentCursor->GetInteger(m_colComponentID) == idTempId)
				continue;

			iisComponentInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			idComponent = pComponentCursor->GetInteger(m_colComponentKey);
			pCursor->Reset();
			pCursor->PutInteger(colComponent,idComponent);
			piErrRec = SetComponentState(pCursor, colFeature, idComponent, iisComponentInstalled);
			if (piErrRec)
				return piErrRec;
		}

		return 0;
	
	}
	
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	int iParentLevel;
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,*piFeatureString);
	iParentLevel = pCursor->Next();
	pCursor->SetFilter(0);

	if (piFeatureString && iParentLevel == 0)
		return PostError(Imsg(idbgBadFeature),*piFeatureString);

	int iTreeLevel;
	do
	{
		MsiStringId idChildFeature = pCursor->GetInteger(m_colFeatureKey);
		piErrRec = SetFeatureComponents(idChildFeature);
		if (piErrRec)
			return piErrRec;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);

	return 0;
}


IMsiRecord* CMsiEngine::SetFeatureComponents(const MsiStringId idFeatureString)
/*-----------------------------------------------------------------------
Internal function that sets the installed state of all the components
associated with the given feature, such that the components match the
installed state of the feature.  This function actually walks through
the FeatureComponents table, and for each Component mapped to the
given feature, calls SetComponent on that component.
------------------------------------------------------------------------*/
{
	CreateSharedCursor(pFeatureComponentsCursor, m_piFeatureComponentsCursor);
	Assert(m_piFeatureComponentsCursor);

	m_piFeatureComponentsCursor->SetFilter(1);
	m_piFeatureComponentsCursor->PutInteger(m_colFeatureComponentsFeature,idFeatureString);
	
	IMsiRecord* piErrRec;
#ifdef DEBUG
	ICHAR rgchFeature[256];
	MsiString(m_piDatabase->DecodeString(idFeatureString)).CopyToBuf(rgchFeature,255);
#endif

	while (m_piFeatureComponentsCursor->Next())
	{
		MsiStringId idComponent = m_piFeatureComponentsCursor->GetInteger(m_colFeatureComponentsComponent);
#ifdef DEBUG
		ICHAR rgchComponent[256];
		MsiString(m_piDatabase->DecodeString(idComponent)).CopyToBuf(rgchComponent,255);
#endif
		
		PMsiCursor pCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
		pCursor->SetFilter(iColumnBit(m_colFeatureComponentsComponent));
		
		// is the component currently installed?
		if (!m_piComponentCursor)
			return PostError(Imsg(idbgSelMgrNotInitialized),0);

		iisEnum iisComponentInstalled;

		{
			CreateSharedCursor(piComponentCursor, m_piComponentCursor);
			m_piComponentCursor->SetFilter(1);
			m_piComponentCursor->PutInteger(m_colComponentKey,idComponent);

			int iParentLevel = m_piComponentCursor->Next();
			if (iParentLevel == 0)
				return PostError(Imsg(idbgBadComponent), (const ICHAR*)MsiString(m_piDatabase->DecodeString(idComponent)));

			iisComponentInstalled = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentInstalled);
		}

		pCursor->PutInteger(m_colFeatureComponentsComponent,idComponent);
		piErrRec = SetComponentState(pCursor, m_colFeatureComponentsFeature, idComponent, iisComponentInstalled);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}

//
// This routine will look at each feature for this component and see what are the valid
// states for it. Parameters
// piCursor - a cursor to a table which is filtered by component
// colFeature - the feature column in piCursor
// idComponent - The component id being looked at
// iisComponentInstalled - the current state of the component
IMsiRecord* CMsiEngine::SetComponentState(IMsiCursor *piCursor, int colFeature, const MsiStringId idComponent, iisEnum iisComponentInstalled)
{
	int iReinstallLocalCount = 0;
	int iReinstallSourceCount = 0;
	int iLocalCount = 0;
	int iSourceCount = 0;
	int iAbsentCount = 0;

	IMsiRecord* piErrRec;

	bool fFeatureSelected = false;
	
	while (piCursor->Next())
	{
		iisEnum iisFeatureAction, iisFeatureInstalled;
		MsiStringId idFeature = piCursor->GetInteger(colFeature);
		piErrRec = GetFeatureStates(idFeature,&iisFeatureInstalled,&iisFeatureAction);
		if (piErrRec)
			return piErrRec;

		int iFeatureRuntimeFlags=0;
		piErrRec = GetFeatureRuntimeFlags(idFeature,&iFeatureRuntimeFlags);
		if (piErrRec)
			return piErrRec;

		// to determine the final component action state we need to also take into consideration the current installed states of features
		// that use that component but are not currently actively selected.
		// however, if no feature that uses that component is currently selected, we want to set the component's action state to null (darwin bug 7300)
		// this is achieved by using the fFeatureSelected flag
		if(iisFeatureAction != iMsiNullInteger)
			fFeatureSelected = true;
		else if(iisFeatureInstalled != iisAbsent && iisFeatureInstalled != iisAdvertise)
			iisFeatureAction = iisComponentInstalled;       // we do not want to switch states if the component is currently
														// installed and the feature is not actively selected
		if (iisFeatureAction == iisReinstall)
		{
			if (iisFeatureInstalled == iisLocal)
				iReinstallLocalCount++;
			else if (iisFeatureInstalled == iisSource)
				iReinstallSourceCount++;
		}
		else if (iisFeatureAction == iisLocal)
		{
			// need to handle case where feature is transitioning from source to local because it has a patchable component
			// and this component was already installed locally
			if (iisFeatureInstalled == iisSource && iisComponentInstalled == iisLocal && ((iFeatureRuntimeFlags & bfFeaturePatchable) || (iFeatureRuntimeFlags & bfFeatureCompressable)))
			{
				// component must be reinstalled since its feature is being patched (and therefore reinstalled)
				iReinstallLocalCount++;
			}
			else
				iLocalCount++;
		}
		else if (iisFeatureAction == iisSource)
			iSourceCount++;
		else if (((iisFeatureAction == iisAbsent) || (iisFeatureAction == iisAdvertise)) && ((iisFeatureInstalled != iisAbsent) && (iisFeatureInstalled != iisAdvertise))) // bug 7207 - feature absent <-> advt transitions does not affect component state
			iAbsentCount++;
	}

	// need to handle case where we reinstall some features and addlocal other features (originally absent or source)
	// particularly if the features share a component originally installed source.  we don't want the component to
	// stay source if at least one feature wants it to go local
	iisEnum iisCompositeAction = (iisEnum) iMsiNullInteger;
	if (iReinstallLocalCount > 0)
		iisCompositeAction = iisReinstallLocal;
	else if (iReinstallSourceCount > 0)
	{
		// if someone has an ADDLOCAL on us, we should adhere to it and force us local, but must
		// ensure that the component is re-evaluated (for transitive components)
		if (iLocalCount > 0)
			iisCompositeAction = iisReinstallLocal;
		else
			iisCompositeAction = iisReinstallSource;
	}
	else if (iLocalCount > 0)
		iisCompositeAction = iisLocal;
	else if (iSourceCount > 0)
		iisCompositeAction = iisSource;
	else if (iAbsentCount > 0)
		iisCompositeAction = iisAbsent;

	return SetComponent(idComponent,fFeatureSelected?iisCompositeAction:(iisEnum)iMsiNullInteger);
}

IMsiRecord* CMsiEngine::SetFileComponentStates(IMsiCursor* piComponentCursor, IMsiCursor* piFileCursor, IMsiCursor* piPatchCursor)
/*-----------------------------------------------------------------------
Internal function to check if a component contains either compressed
files or patched files
We look at each file in the file table, and then check it's corresponding component
------------------------------------------------------------------------*/
{
	
	IMsiRecord* piError = 0;
	
	if(!piFileCursor && !piPatchCursor)
		return 0;

	bool fCompressed, fPatched;

	int colFileKey = m_mpeftCol[ieftKey];
	int colFileComponent = m_mpeftCol[ieftComponent];
	int colFileAttributes = m_mpeftCol[ieftAttributes];

	AssertSz(piFileCursor != 0, "CheckComponentState passed null file cursor");
	
	if (piPatchCursor != 0)
	{
		piPatchCursor->SetFilter(iColumnBit(m_colPatchKey));
	}

	piFileCursor->SetFilter(0);
	piComponentCursor->SetFilter(iColumnBit(m_colComponentKey));

	while(piFileCursor->Next())
	{
		fCompressed = false;
		fPatched = false;
#ifdef DEBUG
		MsiString strFileName = piFileCursor->GetString(3);
#endif //DEBUG

		// determine if file is compressed using file attributes and source type
		// NOTE: we are using the source type from the cached package here, because we
		// don't want to resolve the source yet, and the cached package is our best guess
		// at the source type
		fCompressed = FFileIsCompressed(m_iCachedPackageSourceType,
												  piFileCursor->GetInteger(colFileAttributes));
		
		if(piPatchCursor)
		{
			piPatchCursor->Reset();
			AssertNonZero(piPatchCursor->PutInteger(m_colPatchKey,piFileCursor->GetInteger(colFileKey)));
			if(piPatchCursor->Next() && !(piPatchCursor->GetInteger(m_colPatchAttributes) & msidbPatchAttributesNonVital))
			{
				fPatched = true;
			}
		}
		if (fPatched || fCompressed)
		{
			int iRuntimeFlags;
			MsiStringId idComponent = piFileCursor->GetInteger(colFileComponent);

			piComponentCursor->Reset();
			piComponentCursor->PutInteger(m_colComponentKey, idComponent);
			if (piComponentCursor->Next())
			{
				iRuntimeFlags = piComponentCursor->GetInteger(m_colComponentRuntimeFlags);
				if (fCompressed) iRuntimeFlags |= bfComponentCompressed;
				if (fPatched) iRuntimeFlags |= bfComponentPatchable;
				piComponentCursor->PutInteger(m_colComponentRuntimeFlags, iRuntimeFlags);
				AssertNonZero(piComponentCursor->Update());
			}
			else
				AssertSz(fFalse, "Missing Component from File Table");
		}
	}


	piFileCursor->Reset();
	piComponentCursor->Reset();

	if (piPatchCursor)
		piPatchCursor->Reset();
	return 0;
}

extern idtEnum MsiGetPathDriveType(const ICHAR *szPath, bool fReturnUnknownAsNetwork);

IMsiRecord* CMsiEngine::DetermineComponentInstalledStates()
/*-----------------------------------------------------------------------
Internal function called at initialize time to determine the installed
state of all components, based both on registration with the configuration
manager, and the actual presence of the "key file" associated with the
component.
------------------------------------------------------------------------*/
{
	if(m_fMode & iefAdvertise) // skip if in advertise mode
		return 0;

	// what type of an install are we attempting
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;

	if (!m_piComponentTable)
		return 0; // no components ~ no work

	PMsiCursor piCursor = m_piComponentTable->CreateCursor(fFalse);
	while(piCursor->Next())
	{
		if((piCursor->GetInteger(m_colComponentParent) == 0) || (piCursor->GetInteger(m_colComponentParent) == piCursor->GetInteger(m_colComponentKey)))
		{
			if(ActionProgress() == imsCancel)
				return PostError(Imsg(imsgUser));

			MsiString strComponent = piCursor->GetString(m_colComponentKey);
			MsiString istrComponentID = piCursor->GetString(m_colComponentID);
			if (istrComponentID.TextSize() == 0)  // unregistered component
			{
//                              iisInstalled = iisAbsent; //!! necessary if we're not registering component?
				continue;
			}
			MsiString strFile;
			INSTALLSTATE iClientState = INSTALLSTATE_UNKNOWN;
			INSTALLSTATE iClientStateStatic = INSTALLSTATE_UNKNOWN;
			iisEnum iisInstalled;
			// Use the registration on the machine only if we have installed before.
			// In the event this is a per user managed install and the user is an admin
			// we honour previous per user (non-managed) component installations as well.
			if(m_fRegistered) 
			{
				PMsiRecord pRec(0);

				IMsiRecord* piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *istrComponentID, *&pRec, &iaaAsgnType);
				if (piErrRec)
					return piErrRec;

				iClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
				iClientStateStatic = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE_Static);
				strFile = pRec->GetMsiString(icmlcrFile);

				if(iClientStateStatic == INSTALLSTATE_LOCAL)
				{
					// do we have a fusion component  
					iatAssemblyType iatAT;
					MsiString strAssemblyName;
					piErrRec = GetAssemblyInfo(*strComponent, iatAT, &strAssemblyName, 0);
					if (piErrRec)
						return piErrRec;

					// set the target for local installs to the currently installed location
					// dont attempt to use the path for assembly components
					if(iatAT != iatURTAssembly && iatAT != iatWin32Assembly && strFile.TextSize() && MsiString(strFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger)
					{
						// is the file installed in a location accessible to the current user?
						if((iClientState == INSTALLSTATE_ABSENT || iClientState == INSTALLSTATE_BROKEN) && pRec->GetInteger(icmlcrLastErrorOnFileDetect) == ERROR_ACCESS_DENIED)
							iClientState = INSTALLSTATE_UNKNOWN;
						else
						{
							const IMsiString* pistrPath = 0;

							piErrRec = SplitPath(strFile, &pistrPath);
							if (piErrRec)
								return piErrRec;
						
						
							if (MsiGetPathDriveType(pistrPath->GetString(),false) == idtUnknown)
							{
								iClientState = INSTALLSTATE_UNKNOWN;
								pistrPath->Release();
								pistrPath = 0;
							}
							else
							{
								// ugly, is directory manager initialised
								if((m_fDirectoryManagerInitialized) && (m_piComponentCursor))
								{
									// directory manager initialised
									AssertNonZero(SetProperty(*MsiString(piCursor->GetString(m_colComponentDir)), *pistrPath));
									piErrRec = SetDirectoryNonConfigurable(*MsiString(piCursor->GetString(m_colComponentDir)));
									pistrPath->Release();
									pistrPath = 0;
									if (piErrRec)
										return piErrRec;
								}
								else
								{
									SetProperty(*MsiString(piCursor->GetString(m_colComponentDir)), *pistrPath); //!! should we not do this?
									pistrPath->Release();
									pistrPath = 0;
								}
							}
						}
					}
				}
			}

			// set the component state to what the user desired when he/she selected the feature(s)
			switch(iClientStateStatic)
			{
			case INSTALLSTATE_LOCAL:
			case INSTALLSTATE_ABSENT:
			// we treat INSTALLSTATE_NOTUSED as local for the sake for register and unregister components
			// this sets the Installed column to local, however the Action column will always be null
			// since the component is disabled
			case INSTALLSTATE_NOTUSED:
			{
				iisInstalled = iisLocal;
				break;
			}
			case INSTALLSTATE_SOURCE:
			case INSTALLSTATE_SOURCEABSENT:
				iisInstalled = iisSource;
				break;
			default:
				iisInstalled = iisAbsent;
				break;
			}
			// update the installed state
			AssertNonZero(piCursor->PutInteger(m_colComponentInstalled, iisInstalled));
			AssertNonZero(piCursor->PutInteger(m_colComponentTrueInstallState, iClientState));
			AssertNonZero(piCursor->Update());
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::DetermineFeatureInstalledStates()
/*------------------------------------------------------------------------------------
Internal function that walks through all features, and sets the installed state for
each, based on the composite installed state of the feature's components. For features
that don't have components, the installed state is determined by the composite state
of that feature's children. The calculated iisEnum state is written into the
m_colFeatureInstalled column.
--------------------------------------------------------------------------------------*/
{
	// Feature conditions must be evaluated before determining installed states
	IMsiRecord* piErrRec = ProcessConditionTable();
	if (piErrRec)
		return piErrRec;

	// First calculate the installed state of each feature, based on the states
	// of each component linked to the feature.
	piErrRec = CalculateFeatureInstalledStates();
	if (piErrRec)
		return piErrRec;

	// Those features that end up with an installed state of iMsiNullInteger have
	// no linked components.  We'll determine the state of these features as a
	// composite of the feature children.
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	int iTreeLevel;
	while ((iTreeLevel = pCursor->Next()) > 0)
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		iisEnum iisInstalled = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
		if (iisInstalled == iMsiNullInteger)
		{
			MsiString strFeature = pCursor->GetString(m_colFeatureKey);
			piErrRec = GetFeatureCompositeInstalledState(*strFeature,iisInstalled);
			if (piErrRec)
				return piErrRec;

			pCursor->PutInteger(m_colFeatureInstalled,iisInstalled);
			pCursor->Update();
		}
	}
	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureCompositeInstalledState(const IMsiString& riFeatureString, iisEnum& riisInstalled)
/*------------------------------------------------------------------------------------
Internal function that returns the current 'Installed' state of the specified feature,
as a composite of the installed state of the specified feature and all its children.

This is intended to be called only for those features that are not linked to any
components.  The general rules are that if any of the child features have an installed
state of iisSource, the parent's installed state is set to iisSource.  Otherwise, if
any child is iisLocal, the parent is set to iisLocal.  One special rule is that if any
of the children are marked with the FollowParent attribute, and that child is installed
iisLocal or iisSource, the parent is set to that same state.
--------------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString);
	pCursor->SetFilter(0);
	int iTreeLevel;
	int iLocalCount = 0;
	int iSourceCount = 0;
	int iAbsentCount = 0;
	int iAdvertiseCount = 0;
	int iLocalFollowParentCount = 0;
	int iSourceFollowParentCount = 0;
	do
	{
#ifdef DEBUG
		const ICHAR* szFeature = MsiString(pCursor->GetString(m_colFeatureKey));
#endif
		iisEnum iisInstalled = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
		int ifeaAttributes = pCursor->GetInteger(m_colFeatureAttributes);
		if(ifeaAttributes == iMsiNullInteger)
			ifeaAttributes = 0;
		if ((ifeaAttributes & ifeaInstallMask) == ifeaFollowParent && (iisInstalled == iisLocal || iisInstalled == iisSource))
		{
			if (iisInstalled == iisLocal)
				iLocalFollowParentCount++;
			else if (iisInstalled == iisSource)
				iSourceFollowParentCount++;
		}
		else if (iisInstalled == iisLocal)
			iLocalCount++;
		else if (iisInstalled == iisSource)
			iSourceCount++;
		else if (iisInstalled == iisAbsent)
			iAbsentCount++;
		else if (iisInstalled == iisAdvertise)
			iAdvertiseCount++;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	if (iSourceFollowParentCount > 0)
	{
		Assert(iLocalFollowParentCount == 0);
		return (riisInstalled = iisSource, 0);
	}
	else if (iLocalFollowParentCount > 0)
	{
		Assert(iSourceFollowParentCount == 0);
		return (riisInstalled = iisLocal, 0);
	}
	else if (iSourceCount > 0)
		return (riisInstalled = iisSource, 0);
	else if (iLocalCount > 0)
		return (riisInstalled = iisLocal, 0);
	else if (iAdvertiseCount > 0)
		return (riisInstalled = iisAdvertise, 0);
	else if (iAbsentCount > 0)
		return (riisInstalled = iisAbsent, 0);
	else
		return (riisInstalled = (iisEnum) iMsiNullInteger, 0);
}


IMsiRecord* CMsiEngine::CalculateFeatureInstalledStates()
/*------------------------------------------------------------------------------------
Internal function that walks through all features, and sets the installed state for
each, based on the composite installed state of the feature's components.  The
calculated iisEnum state is written into the m_colFeatureInstalled column.  For
features that don't have components, the installed state will be iMsiNullInteger.
--------------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Bool fAdvertised = fFalse;
	Bool fRegistered = fFalse;

	MsiString strProduct = GetProperty(*MsiString(*IPROPNAME_PRODUCTCODE));
	INSTALLSTATE is = GetProductState(strProduct, fRegistered, fAdvertised);

	bool fQFEUpgrade = false;
	MsiString strQFEUpgrade = GetPropertyFromSz(IPROPNAME_QFEUPGRADE);
	if(strQFEUpgrade.TextSize())
		fQFEUpgrade = true;

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	int iTreeLevel = 0;
	iisEnum iParInstalled[MAX_COMPONENT_TREE_DEPTH + 1];
	while ((iTreeLevel = pCursor->Next()) > 0)
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiString strFeature(pCursor->GetString(m_colFeatureKey));
		int iLevel = pCursor->GetInteger(m_colFeatureLevel);
		iisEnum iisInstalled = iisAbsent;
		if (!(m_fMode & iefAdvertise) && iLevel && fAdvertised) // we are not in advertise mode and feature is not disabled and product is known
		{
			// Get Feature-Component mapping
			DWORD dwType;
			CAPITempBuffer<ICHAR, cchExpectedMaxFeatureComponentList> szComponentList;
			CRegHandle HProductKey;
			if((OpenAdvertisedSubKey(szGPTFeaturesKey, strProduct, HProductKey, false, -1, 0) == ERROR_SUCCESS) && 
				(ERROR_SUCCESS == MsiRegQueryValueEx(HProductKey, strFeature, 0, &dwType, szComponentList, 0)) && 
				(*szComponentList != chAbsentToken))
			{
				iisInstalled = iisAdvertise;
				// check if the feature is truly installed to the local machine
				if(	fRegistered && 
					(ERROR_SUCCESS == OpenInstalledFeatureKey(strProduct, HProductKey, false)) && 
					(ERROR_SUCCESS == WIN::RegQueryValueEx(HProductKey, strFeature, 0, 0, 0, 0)))
				{
					MsiStringId idFeature = pCursor->GetInteger(m_colFeatureKey);
					int cComponents = 0;
					iisInstalled = GetFeatureComponentsInstalledState(idFeature, /* fIgnoreAddedComponents = */ false, cComponents);

					// we are only concerned about cases where the install state changes from the original state to a new state
					// when adding components to an existing features, the only times an install state will change are
					//		iisSource ->> iisAdvertise (an absent component was added)
					//      iisLocal  ->> iisAdvertise (an absent component was added)
					//      iisLocal  ->> iisSource    (a source component was added)
					
					if (fQFEUpgrade && (iisInstalled == iisAdvertise || iisInstalled == iisSource) && cComponents > 0)
					{
						// need to determine if this was caused by new component(s)
						int cRegisteredComponents = GetFeatureRegisteredComponentTotal(*strProduct, *strFeature);
						if (cComponents == cRegisteredComponents)
						{
							// nothing required
						}
						else if (-1 == cRegisteredComponents)
						{
							// is there anything we can do to help this feature?
							DEBUGMSG2(TEXT("SELMGR: The feature-component mapping registration is broken for feature '%s' of product '%s'"), strFeature, strProduct);
						}
						else if (0 == cRegisteredComponents)
						{
							// a new component was added to a feature that originally had no components
							// it's install state is therefore iMsiNullInteger in order to preserve the feature's original install state
							DEBUGMSG1(TEXT("SELMGR: New components have been added to feature '%s'"), strFeature);
							iisInstalled = (iisEnum) iMsiNullInteger;
						}
						else if (cComponents > cRegisteredComponents)
						{
							// Feature has new components
							DEBUGMSG1(TEXT("SELMGR: New components have been added to feature '%s'"), strFeature);

							// (1) Recalculate feature installed state by ignoring the "new" components (unregistered)
							// (2) The "new" components (unregistered) need to be installed to match the feature installed state
							iisInstalled = GetFeatureComponentsInstalledState(idFeature, /* fIgnoreAddedComponents = */ true, cComponents);
						}
						else if (cComponents < cRegisteredComponents)
						{
							DEBUGMSG(TEXT("SELMGR: Removal of a component from a feature is not supported"));
							AssertSz(0, TEXT("Removal of a component from a feature is not permitted during minor updates"));
						}
					}

					//!! the following seems obselete since we are already weeding out the
					//!! parent absent/advertised scenarios by the time we are here
					if (iTreeLevel > 1 && iisInstalled != iMsiNullInteger)
					{
						for (int x = iTreeLevel - 1;x > 0;x--)
						{
							if (iParInstalled[x] == iisAbsent || iParInstalled[x] == iisAdvertise)
							{
								iisInstalled = iParInstalled[x];
								break;
							}
						}
					}
				}
			}
		}

		pCursor->PutInteger(m_colFeatureInstalled,iisInstalled);
		pCursor->Update();
		iParInstalled[iTreeLevel] = iisInstalled;
	}
	return 0;
}


iisEnum CMsiEngine::GetFeatureComponentsInstalledState(const MsiStringId idFeatureString, bool fIgnoreAddedComponents, int& cComponents)
/*-----------------------------------------------------------------------
Internal function that returns the current 'Installed' state of the
specified feature, based only on the composite state of the components
assigned to the feature.

  cComponents:
	stores the count of components in the feature idFeatureString

  fIgnoreAddedComponents:
	added components are not included in the feature install
	state determination
------------------------------------------------------------------------*/
{
	CreateSharedCursor(pFeatureComponentsCursor, m_piFeatureComponentsCursor);

	if (!m_piComponentTable)
		return (iisEnum) iMsiNullInteger; // no components

	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(m_piFeatureComponentsCursor);
	m_piFeatureComponentsCursor->SetFilter(1);
	m_piFeatureComponentsCursor->PutInteger(m_colFeatureComponentsFeature,idFeatureString);
	int iLocalCount = 0;
	int iSourceCount = 0;
	int iAbsentCount = 0;
	int iNullCount = 0;
	int iComponentCount = 0;
	while (m_piFeatureComponentsCursor->Next())
	{
		iComponentCount++;
		MsiString istrComponent = m_piFeatureComponentsCursor->GetString(m_colFeatureComponentsComponent);
		pComponentCursor->SetFilter(1);
		pComponentCursor->PutString(m_colComponentKey,*istrComponent);
		if (pComponentCursor->Next())
		{
			// (1) Ignore added components (not marked as registered) if fIgnoreAddedComponents is true
			// (2) Feature install state is therefore only determined by registered components
			// (3) Component is considered registered if present in the feature-component mapping registration
			
			int iComponentRegistrationState = m_piFeatureComponentsCursor->GetInteger(m_colFeatureComponentsRuntimeFlags);
			if (fIgnoreAddedComponents && (iComponentRegistrationState == iMsiNullInteger || !(iComponentRegistrationState & bfComponentRegistered)))
			{
				DEBUGMSGV2(TEXT("SELMGR: Component '%s' is a new component added to feature '%s'"), istrComponent, MsiString(m_piFeatureComponentsCursor->GetString(m_colFeatureComponentsFeature)));
				continue;
			}

			Assert(!fIgnoreAddedComponents || (iComponentRegistrationState & bfComponentRegistered));

			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			if (iisInstalled == iisLocal)
				iLocalCount++;
			else if (iisInstalled == iisSource)
				iSourceCount++;
			else if (iisInstalled == iisAbsent)
				iAbsentCount++;
			else if (iisInstalled == iMsiNullInteger)
				iNullCount++;
		}
	}

	cComponents = iComponentCount;

	if (iComponentCount == 0)
		return (iisEnum) iMsiNullInteger;
	if (iAbsentCount > 0)
		return iisAdvertise;
	else if (iSourceCount > 0)
		return iisSource;
	else if (iLocalCount > 0)
		return iisLocal;
	else
	{
		Assert(iNullCount > 0);
		return (iisEnum) iMsiNullInteger;
	}
}

int CMsiEngine::GetFeatureRegisteredComponentTotal(const IMsiString& riProductString, const IMsiString& riFeatureString)
/*----------------------------------------------------------------------------------------------------------------------
Internal function that calculates the number of components registered to feature riFeatureString of
 product riProductString.  Calculation is based upon the global feature-component mapping registration

  riProductString -- name of product
  riFeatureString -- name of feature

  Returns -1 if failure, otherwise the number of components registered in the feature-component mapping
------------------------------------------------------------------------------------------------------------------------*/
{
	CRegHandle HProductKey;
	if (ERROR_SUCCESS != OpenInstalledFeatureKey(riProductString.GetString(), HProductKey, false))
		return -1; // failure! -- bad configuration data

	DWORD dwType = 0;
	CAPITempBuffer<ICHAR, cchExpectedMaxFeatureComponentList> szComponentList;
	if (ERROR_SUCCESS != MsiRegQueryValueEx(HProductKey, riFeatureString.GetString(), 0, &dwType, szComponentList, 0))
		return -1; // failure! -- bad configuration data

	// at this point, we expect the feature to have a component, but we'll check anyway
	ICHAR *pchComponentList = szComponentList;
	if (/* root feature */*pchComponentList == 0
		|| lstrlen(pchComponentList) < cchComponentIdCompressed
		|| /* child feature, no components */ *pchComponentList == chFeatureIdTerminator)
		return 0; // no registered components for this feature

	ICHAR szComponent[cchComponentId + 1];
	if (!UnpackGUID(pchComponentList, szComponent, ipgCompressed))
		return -1; // failure! -- bad configuration data

	// loop for each component in the feature and mark as registered in the FeatureComponents table
	ICHAR *pchBeginComponentId = 0;
	int cRegisteredComponents = 0;

	pchBeginComponentId = pchComponentList;
	int cchCompId = cchComponentIdCompressed;
	int cchComponentListLen = lstrlen(pchBeginComponentId);

	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pComponentCursor);

	PMsiCursor pFeatureComponentsCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
	Assert(pFeatureComponentsCursor);

	while (*pchBeginComponentId != 0)
	{
		if (*pchBeginComponentId == chFeatureIdTerminator)
		{
			// no more components
			break;
		}
		else
		{
			if(cchComponentListLen < cchCompId)
				return -1; // failure! -- bad configuration data

			ICHAR szComponentIdSQUID[cchComponentIdPacked+1];
			if (cchCompId == cchComponentIdPacked)
			{
				memcpy((ICHAR*)szComponentIdSQUID, pchBeginComponentId, cchComponentIdPacked*sizeof(ICHAR));
				szComponentIdSQUID[cchCompId] = 0;
			}
			else if (!UnpackGUID(pchBeginComponentId, szComponentIdSQUID, ipgPartial))
				return -1; // failure! -- bad configuration data

			ICHAR szComponentId[cchGUID+1]	= {0};
			if (!UnpackGUID(szComponentIdSQUID, szComponentId, ipgPacked))
				return -1; // failure! -- unable to convert to normal GUID

			// look for component name matching this componentId
			pComponentCursor->Reset();
			pComponentCursor->SetFilter(iColumnBit(m_colComponentID));
			pComponentCursor->PutString(m_colComponentID,*MsiString(szComponentId));
			if (!pComponentCursor->Next())
			{
				// component is registered to feature, but is not present in the Component table
				// - component has been removed from the feature -- this is not supported!!
				DEBUGMSG2(TEXT("SELMGR: ComponentId '%s' is registered to feature '%s', but is not present in the Component table.  Removal of components from a feature is not supported!"), szComponentId, riFeatureString.GetString());
				return -1;
			}
			MsiString strComponent(pComponentCursor->GetString(m_colComponentKey));

			// SELMGR: Component '%s' is registered to feature '%s', strComponent, riFeatureString.GetString()

			// find feature-component mapping and update as registered
			pFeatureComponentsCursor->Reset();
			pFeatureComponentsCursor->SetFilter(iColumnBit(m_colFeatureComponentsFeature) | iColumnBit(m_colFeatureComponentsComponent));
			pFeatureComponentsCursor->PutString(m_colFeatureComponentsFeature, riFeatureString);
			pFeatureComponentsCursor->PutString(m_colFeatureComponentsComponent, *strComponent);
			if (!pFeatureComponentsCursor->Next())
			{
				// component is registered to feature, but is not present in the FeatureComponents table
				// - component has been removed from the feature -- this is not supported!!
				DEBUGMSG2(TEXT("SELMGR: Component '%s' is registered to feature '%s', but is not present in the FeatureComponents table.  Removal of components from a feature is not supported!"), strComponent, riFeatureString.GetString());
				return -1;
			}
			int iFeatureComponentRuntimeFlags = pFeatureComponentsCursor->GetInteger(m_colFeatureComponentsRuntimeFlags);
			if (iFeatureComponentRuntimeFlags == iMsiNullInteger)
				iFeatureComponentRuntimeFlags = 0;
			iFeatureComponentRuntimeFlags |= bfComponentRegistered;
			pFeatureComponentsCursor->PutInteger(m_colFeatureComponentsRuntimeFlags, iFeatureComponentRuntimeFlags);
			AssertNonZero(pFeatureComponentsCursor->Update());

			cRegisteredComponents++;

			pchBeginComponentId += cchCompId;
			cchComponentListLen -= cchCompId;
		}
	}

	return cRegisteredComponents;
}

IMsiRecord* CMsiEngine::GetFeatureValidStatesSz(const ICHAR *szFeatureName,int& iValidStates)
{
	MsiStringId idFeature;
	
	idFeature = m_piDatabase->EncodeStringSz(szFeatureName);
	if (idFeature == 0)
	{
		return PostError(Imsg(idbgBadFeature),szFeatureName);
	}

	return GetFeatureValidStates(idFeature, iValidStates);
}
IMsiRecord* CMsiEngine::GetFeatureValidStates(MsiStringId idFeatureName, int& iValidStates)
{
	return GetFeatureValidStates(idFeatureName, iValidStates, (IMsiCursor* )0, (IMsiCursor*) 0);
}

IMsiRecord* CMsiEngine::GetFeatureValidStates(MsiStringId idFeatureName,int& iValidStates, IMsiCursor* piFeatureComponentsCursor, IMsiCursor* piFeatureCursor)
//-------------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

#ifdef DEBUG
	ICHAR rgchFeature[256];
	{
	MsiString stFeatureString(m_piDatabase->DecodeString(idFeatureName));
	stFeatureString.CopyToBuf(rgchFeature,255);
	}
#endif
	int iStateBits = 0;

	int iLocalCount = 0;
	int iSourceCount = 0;
	int iComponentCount = 0;
	int iPatchableCount = 0;
	int iCompressableCount = 0;
	bool fAdvertiseAllowed = true;

	if (m_piComponentTable)
	{
		PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
		PMsiCursor pFeatureComponentsCursor(0);
		if (piFeatureComponentsCursor == 0)
		{
			pFeatureComponentsCursor = m_piFeatureComponentsTable->CreateCursor(fFalse);
			pFeatureComponentsCursor->SetFilter(1);
			piFeatureComponentsCursor = pFeatureComponentsCursor;
		}
		else
			piFeatureComponentsCursor->Reset();
		
		Assert(piFeatureComponentsCursor);
		piFeatureComponentsCursor->PutInteger(m_colFeatureComponentsFeature,idFeatureName);

		// The RunFromSource state is disallowed if any component tied to the feature
		// contains patchable or compressed files.  The Advertise state is disallowed
		// for a child feature that is FollowParent, if the parent is in the source state.
		while (piFeatureComponentsCursor->Next())
		{
			iComponentCount++;
			MsiStringId idComponent = piFeatureComponentsCursor->GetInteger(m_colFeatureComponentsComponent);
			pComponentCursor->SetFilter(1);
			pComponentCursor->PutInteger(m_colComponentKey,idComponent);
			if (pComponentCursor->Next())
			{
				iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
				icaEnum icaAttributes = (icaEnum) (pComponentCursor->GetInteger(m_colComponentAttributes) & icaInstallMask);
				int iRuntimeFlags = pComponentCursor->GetInteger(m_colComponentRuntimeFlags);
				if ((iRuntimeFlags & bfComponentPatchable) || (iRuntimeFlags & bfComponentCompressed))
					icaAttributes = icaLocalOnly;

				if (iRuntimeFlags & bfComponentPatchable)
					iPatchableCount++;

				if (iRuntimeFlags & bfComponentCompressed)
					iCompressableCount++;

				if (icaAttributes == icaOptional)
				{
					iLocalCount++;
					iSourceCount++;
				}
				else if (icaAttributes == icaLocalOnly)
					iLocalCount++;
				else if (icaAttributes == icaSourceOnly)
				{
					iSourceCount++;
				}
			}
		}
	}

	PMsiCursor pFeatureCursor(0);

	if (piFeatureCursor == 0)
	{
		pFeatureCursor = m_piFeatureTable->CreateCursor(fTrue);
		piFeatureCursor = pFeatureCursor;
	}
	else
		piFeatureCursor->Reset();
		
	piFeatureCursor->SetFilter(1);
	piFeatureCursor->PutInteger(m_colFeatureKey,idFeatureName);
	if (!piFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),*MsiString(m_piDatabase->DecodeString(idFeatureName)));
		
	if (iComponentCount == 0)
	{
		iStateBits = icaBitLocal | icaBitSource;
	}
	else
	{
		if (iLocalCount > 0)
			iStateBits |= icaBitLocal;
		if (iSourceCount > 0 && iPatchableCount == 0 && iCompressableCount == 0)
			iStateBits |= icaBitSource;
		if (iPatchableCount > 0)
			iStateBits |= icaBitPatchable;
		if (iCompressableCount > 0)
			iStateBits |= icaBitCompressable;

	}
	
	int ifeaAttributes = piFeatureCursor->GetInteger(m_colFeatureAttributes);
	if(ifeaAttributes == iMsiNullInteger)
		ifeaAttributes = 0;
	// Now check to see if this feature should follow its parent
	// (as far as possible).
	int iParentLevel;
	
	if ((iStateBits & icaBitLocal) && (iStateBits & icaBitSource))
	{
		if ((ifeaAttributes & ifeaInstallMask) ==  ifeaFollowParent)
		{
			iStateBits = 0;
			// Find our root parent (i.e. a parent that is not ifeaFollowParent)
			do
			{
				MsiStringId idParent = piFeatureCursor->GetInteger(m_colFeatureParent);
				piFeatureCursor->Reset();
				piFeatureCursor->SetFilter(1);
				piFeatureCursor->PutInteger(m_colFeatureKey,idParent);
				iParentLevel = piFeatureCursor->Next();
			}while ((piFeatureCursor->GetInteger(m_colFeatureAttributes) & ifeaInstallMask) == ifeaFollowParent);
			
			iisEnum iParAction = (iisEnum) piFeatureCursor->GetInteger(m_colFeatureAction);
			iisEnum iParInstalled = (iisEnum) piFeatureCursor->GetInteger(m_colFeatureInstalled);
			iisEnum iParFinalState = iParAction == iMsiNullInteger ? iParInstalled : iParAction;

			if (iParFinalState == iisLocal)
				iStateBits = icaBitLocal;
			else if (iParFinalState == iisSource)
			{
				iStateBits = icaBitSource;
				fAdvertiseAllowed = false;
			}
			else
			{
				MsiStringId idParent = piFeatureCursor->GetInteger(m_colFeatureKey);
				IMsiRecord* piErrRec = GetFeatureValidStates(idParent,iStateBits, 0, 0);
				if (piErrRec)
					return piErrRec;

				// Per bug 7307, we must clear the Advertise bit if the followParent
				// child doesn't allow advertising.
				if (ifeaAttributes & ifeaDisallowAdvertise)
					iStateBits &= (~icaBitAdvertise);
			}
		}
	}

	// do we allow the advertise and absent states
	if(fAdvertiseAllowed && !(ifeaAttributes & ifeaDisallowAdvertise)
		&& (g_fSmartShell || !(ifeaAttributes & ifeaNoUnsupportedAdvertise)))
		iStateBits |= icaBitAdvertise;

	if(!(ifeaAttributes & ifeaUIDisallowAbsent))
		iStateBits |= icaBitAbsent;

	iValidStates = iStateBits;
	return 0;
}


IMsiRecord* CMsiEngine::GetDescendentFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost)
//-----------------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString);
	pCursor->SetFilter(0);
	int iTreeLevel;
	iCost = 0;
	ResetComponentCostMarkers();
	m_fExclusiveComponentCost = fTrue;
	do
	{
		int iFeatureCost;
		MsiString istrChildFeature = pCursor->GetString(m_colFeatureKey);
		IMsiRecord* piErrRec = GetFeatureCost(*istrChildFeature,iisAction,iFeatureCost);
		if (piErrRec)
			return piErrRec;
		iCost += iFeatureCost;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	m_fExclusiveComponentCost = fFalse;
	return 0;

}

IMsiRecord* CMsiEngine::EnumEngineCostsPerVolume(const DWORD dwIndex,
																 IMsiVolume*& rpiVolume,
																 int& iCost, int& iTempCost)
{
	iCost = iTempCost = 0;
	rpiVolume = 0;

	if ( !IsCostingComplete() )
		return PostError(Imsg(idbgOpOutOfSequence),0);
	
	if ( !m_pTempCostsCursor )
	{
		PMsiRecord pError(0);
		PMsiTable pTable(0);
		pError = m_piDatabase->CreateTable(*MsiString(*sztblEngineTempCosts), 0, *&pTable);
		if ( pError )
			return pError;

		m_colTempCostsVolume = pTable->CreateColumn(icdObject + icdNullable + icdPrimaryKey + icdTemporary,
																*MsiString(*sztblEngineTempCosts_colVolume));
		m_colTempCostsTempCost = pTable->CreateColumn(icdLong + icdNoNulls + icdTemporary,
																*MsiString(*sztblEngineTempCosts_colTempCost));
		Assert(m_colTempCostsVolume && m_colTempCostsTempCost);

		m_pTempCostsCursor = pTable->CreateCursor(fFalse);
		Assert(m_pTempCostsCursor);

		m_pTempCostsCursor->SetFilter(iColumnBit(m_colTempCostsVolume));
		Bool fValidEnum = fTrue;
		for ( int iIndex = 0; fValidEnum; iIndex++ )
		{
			int iCost = 0;
			int iNoRbCost = 0;
			PMsiPath pPath(0);
			PMsiRecord pError(0);
			pError = EnumEngineCosts(iIndex, /* fRecalc= */ fTrue,
											 /* fExact = */ fTrue, fValidEnum, *&pPath,
											 iCost, iNoRbCost, NULL);
			if ( pError )
			{
				m_pTempCostsCursor = 0;
				return pError;
			}
			if ( !fValidEnum )
				break;

			PMsiVolume pVolume = &pPath->GetVolume();
			m_pTempCostsCursor->Reset();
			m_pTempCostsCursor->PutMsiData(m_colTempCostsVolume, pVolume);
			if (!m_pTempCostsCursor->Next())
			{
				AssertNonZero(m_pTempCostsCursor->PutMsiData(m_colTempCostsVolume, pVolume));
				AssertNonZero(m_pTempCostsCursor->PutInteger(m_colTempCostsTempCost, 0));
				AssertNonZero(m_pTempCostsCursor->Insert());
			}
			int iRecCost = m_pTempCostsCursor->GetInteger(m_colTempCostsTempCost) + iCost;
			AssertNonZero(m_pTempCostsCursor->PutInteger(m_colTempCostsTempCost, iRecCost));
			AssertNonZero(m_pTempCostsCursor->Update());
		}
		m_pTempCostsCursor->SetFilter(0);
	}

	m_pTempCostsCursor->Reset();
	int iRes = 0;
	// I look for the dwIndex-th entry in the temporary table.
	for ( int i=0; i <= dwIndex && (iRes = m_pTempCostsCursor->Next()) != 0; i++ )
		;

	if ( !iRes )
		return PostError(Imsg(idbgNoMoreData));

	rpiVolume = (IMsiVolume*)m_pTempCostsCursor->GetMsiData(m_colTempCostsVolume);
	iCost = 0;
	iTempCost = m_pTempCostsCursor->GetInteger(m_colTempCostsTempCost);
	return 0;
}

IMsiRecord* CMsiEngine::EnumComponentCosts(const IMsiString& riComponentName,
														 const iisEnum iisAction,
														 const DWORD dwIndex,
														 IMsiVolume*& rpiVolume,
														 int& iCost, int& iTempCost)
{
	iCost = iTempCost = 0;
	rpiVolume = 0;

	if ( !m_piComponentTable || !m_colComponentParent )
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if ( !IsCostingComplete() )
		return PostError(Imsg(idbgOpOutOfSequence),0);

	PMsiCursor pComponentsCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pComponentsCursor);
	pComponentsCursor->SetFilter(iColumnBit(m_colComponentKey));
	pComponentsCursor->PutString(m_colComponentKey, riComponentName);

	// temporary array that holds the serial numbers of the volumes
	// encountered.  We add elements into it as long as we haven't
	// encountered the dwIndex-th volume.
	CTempBuffer<int, 20> rgiVolumes;
	// the number of volumes in rgiVolumes
	int cVolumes = 0;
	// the serial number of the dwIndex-th volume
	int iTheVolume = 0;
	bool fDoingComponent = true;
	bool fComponentDisabled = false;

	// this loop cumulates the cost for the particular component (and any
	// subcomponents it might have) when the volume that the component's
	// directory belongs to is on the volume at the dwIndex-th position
	for ( int iRes; (iRes = pComponentsCursor->Next()) != 0 || fDoingComponent; )
	{
		if (iRes && fDoingComponent)
		{
			// we're right on the component
			if (pComponentsCursor->GetInteger(m_colComponentRuntimeFlags) & bfComponentDisabled)
				fComponentDisabled = true;
		}
		if ( !iRes )
		{
			// we check the component first and then its child components
			// (the component table is layed-out as having child components
			// created on the fly for components that write to more directories
			// than the authored one).
			fDoingComponent = false;
			pComponentsCursor->Reset();
			pComponentsCursor->SetFilter(iColumnBit(m_colComponentParent));
			pComponentsCursor->PutString(m_colComponentParent, riComponentName);
			continue;
		}
		// getting the current volume's serial number
		MsiString strComponentDir = pComponentsCursor->GetString(m_colComponentDir);
		PMsiPath pPath(0);
		PMsiRecord piError = GetTargetPath(*strComponentDir, *&pPath);
		if ( piError )
			return piError;
		PMsiVolume pVolume = &pPath->GetVolume();
		int iVolume = pVolume->SerialNum();
		if ( iTheVolume == 0 )
		{
			// we haven't encountered the dwIndex-th volume yet

			// we look up the current volume in the array
			for ( int i=0; i < cVolumes; i++ )
				if ( iVolume == rgiVolumes[i] )
					break;
			if ( i == cVolumes )
			{
				// we haven't encountered this volume yet
				if ( i == dwIndex )
				{
					// this is the dwIndex-th volume.
					iTheVolume = iVolume;
					rpiVolume = pVolume;
					pVolume->AddRef();
				}
				else
				{
					// we add the new volume into the array
					if ( cVolumes == rgiVolumes.GetSize() )
						rgiVolumes.Resize(cVolumes+10);
					rgiVolumes[cVolumes++] = iVolume;
				}
			}
		}
		if ( iTheVolume && iVolume == iTheVolume && !fComponentDisabled )
		{
			int iCompCost, iNoRbCost, iARPCost, iNoRbARPCost;
			piError = GetComponentActionCost(pComponentsCursor, iisAction, iCompCost, iNoRbCost, iARPCost, iNoRbARPCost);
			if ( piError )
				return piError;
			iCost += iNoRbCost;
			iTempCost += iCompCost - iNoRbCost;
		}
	}

	if ( iTheVolume )
		// the dwIndex-th volume was found; life is good
		return 0;
	else
		return PostError(cVolumes ? Imsg(idbgNoMoreData) : Imsg(idbgBadComponent),
							  riComponentName);
}

IMsiRecord* CMsiEngine::GetFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost)
/*-------------------------------------------------------------------------
Returns the cost attributable to all components linked directly to the given
feature.  The cost value based on the specified action state, not on the
current action state of each component.
---------------------------------------------------------------------------*/
{
	if (!m_piFeatureComponentsTable || !m_piComponentTable || !m_piFeatureTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pFeatureComponentsCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pFeatureComponentsCursor);
	pFeatureComponentsCursor->SetFilter(1);
	pFeatureComponentsCursor->PutString(m_colFeatureComponentsFeature,riFeatureString);
	iCost = 0;
	int iComponentCount = 0;
	while (pFeatureComponentsCursor->Next())
	{
		int iComponentCost, iNoRbComponentCost;
		MsiString strComponent = pFeatureComponentsCursor->GetString(m_colFeatureComponentsComponent);
		IMsiRecord* piErrRec = GetTotalSubComponentActionCost(*strComponent,
			iisAction == iisAdvertise ? (iisEnum) iMsiNullInteger : iisAction, iComponentCost, iNoRbComponentCost);
		if (piErrRec)
			return piErrRec;
		iCost += iNoRbComponentCost;
		iComponentCount++;
	}
	if (iComponentCount == 0)
	{
		PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
		pCursor->SetFilter(1);
		pCursor->PutString(m_colFeatureKey,riFeatureString);
		if (!pCursor->Next())
			return PostError(Imsg(idbgBadFeature),riFeatureString);
	}
	return 0;
}


IMsiRecord* CMsiEngine::GetAncestryFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost)
/*-------------------------------------------------------------------------
Returns the cost attributable to the specified feature (excluding cost of
any children), plus the cost of all the feature's ancestors.
---------------------------------------------------------------------------*/
{
	iCost = 0;
	MsiString strAncestor(riFeatureString.GetString());
	while (strAncestor.TextSize() > 0)
	{
		int iFeatureCost;
		IMsiRecord* piErrRec = GetFeatureCost(*strAncestor,iisAction,iFeatureCost);
		if (piErrRec)
			return piErrRec;

		iCost += iFeatureCost;
		MsiString strFeature = strAncestor;
		if ((piErrRec = GetFeatureParent(*strFeature, *&strAncestor)) != 0)
			return piErrRec;
	}
	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureParent(const IMsiString& riFeatureString,const IMsiString*& rpiParentString)
/*------------------------------------------------------------------------
Returns the name of the feature to which riFeatureString is parented.  If
riFeatureString has no parent, a NULL string will be returned in
rpiParentString.
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(1);
	m_piFeatureCursor->PutString(m_colFeatureKey,riFeatureString);
	if (m_piFeatureCursor->Next())
		rpiParentString = &m_piFeatureCursor->GetString(m_colFeatureParent);
	else
		return PostError(Imsg(idbgBadFeature),riFeatureString);

	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureStates(const IMsiString& riFeatureString,iisEnum* iisInstalled, iisEnum* iisAction)
{
	MsiStringId idFeatureString;

	idFeatureString = m_piDatabase->EncodeString(riFeatureString);
	if (idFeatureString == iTableNullString)
	{
		return PostError(Imsg(idbgBadFeature),riFeatureString);
	}

	return GetFeatureStates(idFeatureString, iisInstalled, iisAction);
}

IMsiRecord* CMsiEngine::GetFeatureStates(const MsiStringId idFeatureString,iisEnum* iisInstalled, iisEnum* iisAction)
/*------------------------------------------------------------------------
Returns the installed and current action state for the specified feature.
Null can be passed for either iisEnum argument if the caller doesn't need
that value.  Note: the returned states are not valid until after
InitializeComponents has been called.
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(1);
	m_piFeatureCursor->PutInteger(m_colFeatureKey,idFeatureString);
	if (m_piFeatureCursor->Next())
	{
		if (iisInstalled) *iisInstalled = (iisEnum) m_piFeatureCursor->GetInteger(m_colFeatureInstalled);
		if (iisAction) *iisAction = (iisEnum) m_piFeatureCursor->GetInteger(m_colFeatureAction);
	}
	else
		return PostError(Imsg(idbgBadFeature),*MsiString(m_piDatabase->DecodeString(idFeatureString)));

	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureRuntimeFlags(const MsiStringId idFeatureString, int* piRuntimeFlags)
/*------------------------------------------------------------------------
Returns the runtime flags for the specified feature.
Note: the returned states are not valid until after
InitializeComponents has been called.
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(1);
	m_piFeatureCursor->PutInteger(m_colFeatureKey,idFeatureString);
	if (m_piFeatureCursor->Next())
	{
		if (piRuntimeFlags) *piRuntimeFlags = m_piFeatureCursor->GetInteger(m_colFeatureRuntimeFlags);
	}
	else
		return PostError(Imsg(idbgBadFeature),*MsiString(m_piDatabase->DecodeString(idFeatureString)));

	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureConfigurableDirectory(const IMsiString& riFeatureString, const IMsiString*& rpiDirKey)
/*------------------------------------------------------------------------
Returns the key for the directory marked as configurable by this feature.
If the feature does designate a directory as configurable, the
Directory table is checked to see if the directory has been marked as
non-configurable (for instance, if it contains in installed component)
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(m_colFeatureKey);
	m_piFeatureCursor->PutString(m_colFeatureKey,riFeatureString);
	if (!m_piFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),riFeatureString);

	MsiString strConfigDirKey = m_piFeatureCursor->GetString(m_colFeatureConfigurableDir);

#ifdef DEBUG // make sure dir key is all UPPERCASE
	MsiString strTemp = strConfigDirKey;
	strTemp.UpperCase();
	if(strTemp.Compare(iscExact,strConfigDirKey) == 0)
	{
		ICHAR szDebug[256];
		ASSERT_IF_FAILED(StringCchPrintf(szDebug, ARRAY_ELEMENTS(szDebug),
				TEXT("Configurable directory '%s' not public property (not ALL CAPS)"),(const ICHAR*)strConfigDirKey));
		AssertSz(0,szDebug);
	}
#endif //DEBUG

	if(strConfigDirKey.TextSize())
	{
		// no Directory table so this directory key doesn't exist
		if (!m_piDirTable)
			return PostError(Imsg(idbgUnknownDirectory),*strConfigDirKey);

		PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
		pDirCursor->Reset();
		pDirCursor->SetFilter(m_colDirKey);
		pDirCursor->PutString(m_colDirKey,*strConfigDirKey);
		if (!pDirCursor->Next())
			return PostError(Imsg(idbgUnknownDirectory),*strConfigDirKey);

		int i = pDirCursor->GetInteger(m_colDirNonConfigurable);
		if(i != 0 && i != iMsiStringBadInteger)
			strConfigDirKey = TEXT(""); // not really configurable
	}

	strConfigDirKey.ReturnArg(rpiDirKey);
	return 0;
}

IMsiRecord* CMsiEngine::GetComponentStates(const IMsiString& riComponentString,iisEnum* iisInstalled, iisEnum* iisAction)
/*------------------------------------------------------------------------
Returns the installed and current action state for the specified component.
Null can be passed for either iisEnum argument if the caller doesn't need
that value.  Note: the returned states are not valid until after
InitializeComponents has been called.
--------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	CreateSharedCursor(piComponentCursor, m_piComponentCursor);
	m_piComponentCursor->SetFilter(1);
	m_piComponentCursor->PutString(m_colComponentKey,riComponentString);
	if (m_piComponentCursor->Next())
	{
		if (iisInstalled) *iisInstalled = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentInstalled);
		if (iisAction) *iisAction = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentAction);
	}
	else
		return PostError(Imsg(idbgBadFeature),riComponentString);

	return 0;
}


void CMsiEngine::SetProductAlienClientsFlag()
{
	// the m_fAlienClients flag is set to prevent any features from being uninstalled
	m_fAlienClients = fFalse;
	
	if(m_fBeingUpgraded)
		return; // when we are being upgraded, the new product will take our place - it is safe to remove ourselves

	MsiString strParent = GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);
	if(!strParent.TextSize())
		strParent = *szSelfClientToken;

	MsiString strClients;
	AssertRecord(GetProductClients(m_riServices, MsiString(GetProductKey()), *&strClients));
	while (strClients.TextSize())
	{
		if(*(const ICHAR*)strClients)
		{
			MsiString strProduct = strClients.Extract(iseUpto, ';');

			if(!strProduct.Compare(iscExactI, strParent))
			{
				m_fAlienClients = fTrue;
				return;
			}
		}
		if (!strClients.Remove(iseIncluding, '\0'))
			break;
	}
}

IMsiRecord* CMsiEngine::InitializeComponents()
//------------------------------------------
{
	Bool fCompressed = fFalse;
	Bool fPatchable = fFalse;
	Bool *pfPatchable = 0;

	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFDISKSPACE),fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFNORBDISKSPACE),fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE), 0);
	SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED), 0);
	SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREMAINING), 0);
	m_fForegroundCostingInProgress = false;
	IMsiRecord* piErrRec = 0;
	bool fAdmin = GetMode() & iefAdmin;

	if(!fAdmin)
	{
		piErrRec = DetermineComponentInstalledStates();
		if (piErrRec)
			return piErrRec;
	}


	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fTrue));
	pComponentCursor->Reset();
	pComponentCursor->SetFilter(0);
	int iTreeLevel;
	int iKillLevel = 0;  // highest level that is inactive

	//
	// Load the File table and Patch table
	PMsiTable pFileTable(0);
	PMsiCursor pFileCursor(0);
	PMsiTable pPatchTable(0);
	PMsiCursor pPatchCursor(0);
	if ((piErrRec = LoadFileTable(0,*&pFileTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
		}
		else
			return piErrRec;
	}
	else
	{
		pFileCursor = pFileTable->CreateCursor(fFalse);

		if((piErrRec = m_piDatabase->LoadTable(*MsiString(sztblPatch),0,*&pPatchTable)) != 0)
		{
			if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
			{
				piErrRec->Release();
			}
			else
				return piErrRec;
		}
		else
		{
			m_colPatchKey = pPatchTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblPatch_colFile));
			m_colPatchAttributes = pPatchTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblPatch_colAttributes));
			if (pPatchTable->GetRowCount() != 0)
			{
				pfPatchable = &fPatchable;
				pPatchCursor = pPatchTable->CreateCursor(fFalse);
			}
		}
	}
	
	while ((iTreeLevel = pComponentCursor->Next()) > 0)
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		if (iTreeLevel > MAX_COMPONENT_TREE_DEPTH)
			return PostError(Imsg(idbgIllegalTreeDepth),MAX_COMPONENT_TREE_DEPTH);
		
		MsiStringId idComponent = pComponentCursor->GetInteger(m_colComponentKey);
#ifdef DEBUG
		ICHAR rgchComponent[256];
		MsiString(m_piDatabase->DecodeString(idComponent)).CopyToBuf(rgchComponent,255);
#endif


		Bool fComponentDisabled = fFalse;
		if(!fAdmin)
		{
			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			INSTALLSTATE iClientState = (INSTALLSTATE) pComponentCursor->GetInteger(m_colComponentTrueInstallState);

			Assert(iisInstalled == iMsiNullInteger || (iisInstalled >= iisAbsent && iisInstalled < iisNextEnum));

			if (iKillLevel > 0 && iTreeLevel > iKillLevel)
			{
				fComponentDisabled = fTrue;
			}
			else
			{
				if(iClientState == INSTALLSTATE_NOTUSED)
				{
					// component, once installed disabled always remain disabled (unless marked transitive and we are reinstalling
					iKillLevel = iTreeLevel;
					fComponentDisabled = fTrue;
				}
				else if((iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent) && m_colComponentCondition > 0 &&
					EvaluateCondition(MsiString(pComponentCursor->GetString(m_colComponentCondition))) == iecFalse)
				{
					// component has not been installed, is disabled
					iKillLevel = iTreeLevel;
					fComponentDisabled = fTrue;
				}
				else
				{
					// component has been installed (enabled) or has not been installed and the condition on the component is enabled
					iKillLevel = 0;
				}
			}
		}

		int iRuntimeFlags = pComponentCursor->GetInteger(m_colComponentRuntimeFlags);
		if (iRuntimeFlags == iMsiNullInteger)
			iRuntimeFlags = 0;

		if (fComponentDisabled) iRuntimeFlags |= bfComponentDisabled;
		pComponentCursor->PutInteger(m_colComponentRuntimeFlags, iRuntimeFlags);

		AssertNonZero(pComponentCursor->Update());
	}

	if ((piErrRec = SetFileComponentStates(pComponentCursor, pFileCursor, pPatchCursor)) != 0)
		return piErrRec;
		
	return DetermineFeatureInstalledStates();
}


Bool CMsiEngine::SetFeatureHandle(const IMsiString& riFeatureString, INT_PTR iHandle)
//------------------------
{
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fFalse));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if (pCursor->Next())
	{
		if (!PutHandleData(pCursor, m_colFeatureHandle, iHandle))
			return fFalse;
		if (!pCursor->Update())
			return fFalse;

		return fTrue;
	}
	else
	{
		return fFalse;
	}
}

IMsiRecord* CMsiEngine::SetComponentSz(const ICHAR * szComponentString, iisEnum iRequestedSelectState)
{
	MsiStringId idComponent;

	idComponent = m_piDatabase->EncodeStringSz(szComponentString);

	if (idComponent == 0)
		return PostError(Imsg(idbgBadComponent),szComponentString);

	IMsiRecord *piErrRec;

	if ((piErrRec = SetComponent(idComponent, iRequestedSelectState)) != 0)
		return piErrRec;
		
	if (m_fCostingComplete)
	{
		if ((piErrRec = DetermineEngineCost(NULL, NULL)) != 0)
			return piErrRec;
	}

	return 0;
}

IMsiRecord* CMsiEngine::SetComponent(const MsiStringId idComponentString, iisEnum iRequestedSelectState)
//----------------------------------
{
	IMsiRecord* piErrRec = 0;
	iisEnum iisAction, iisOldAction, iisOldRequestedSelectState;
	bool fComponentEnabled;

	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	{  // Force Cursor to go out of scope before UpdateComponentActionStates
		CreateSharedCursor(piComponentCursor, m_piComponentCursor);
		m_piComponentCursor->SetFilter(1);
		m_piComponentCursor->PutInteger(m_colComponentKey,idComponentString);

		int iParentLevel = m_piComponentCursor->Next();
		if (iParentLevel == 0)
			return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponentString)));

#ifdef DEBUG
			ICHAR rgchComponent[256];
			MsiString istrComponent(m_piComponentCursor->GetString(m_colComponentKey));
			istrComponent.CopyToBuf(rgchComponent,255);
#endif

		bool fSkipSharedTransitionProcessing = false;
		iisEnum iisInstalled = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentInstalled);
		iisOldAction = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentAction);
		iisOldRequestedSelectState = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentActionRequest);
		INSTALLSTATE iClientState = (INSTALLSTATE) m_piComponentCursor->GetInteger(m_colComponentTrueInstallState);
		int iRuntimeFlags = m_piComponentCursor->GetInteger(m_colComponentRuntimeFlags);
		icaEnum icaAttributes = (icaEnum) (m_piComponentCursor->GetInteger(m_colComponentAttributes));
		MsiString strComponentId = m_piComponentCursor->GetString(m_colComponentID);
		fComponentEnabled = (iRuntimeFlags & bfComponentDisabled) ? false : true;
		bool fComponentTransitive = (icaAttributes & icaTransitive) ? true : false;
		bool fNullActionRequired = false;

		// what type of an install are we attempting
		Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
		iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;
		
		iisAction = (iisEnum) iMsiNullInteger;
		// handle reinstall
		if (iRequestedSelectState == iisReinstallLocal || iRequestedSelectState == iisReinstallSource)
		{
			// app compat fix 350947
			// fix for component TTSData.A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24, marked transitive
			// from the merge module Sp5TTInt.msm
			// this component has its key file Mary.sdf not SFP'd in Whistler
			// however a non-key file sam.sdf is SFP'd. Hence we would have ordinarily 
			// remove all registration for the component while leaving the SFP'd file
			// alone during a reinstall on Whistler (after upgrade from Win2k). However this busts the component.
			// hence we check the component id of the component and effectively treat it
			// as permanant and non-transitive on Whistler and above

			// app comat fix 368867
			// help files for SAPI product being removed on Whistler even though they are installed as part of the OS
			// similar issue as above

			if(fComponentTransitive == true && MinimumPlatformWindowsNT51() && 
			   (strComponentId.Compare(iscExact, TTSData_A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24) ||
				strComponentId.Compare(iscExact, SapiCplHelpEng_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
				strComponentId.Compare(iscExact, SapiCplHelpJpn_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
				strComponentId.Compare(iscExact, SapiCplHelpChs_0880F209_45FA_42C5_92AE_5E620033E8EC)))
			{
				DEBUGMSG1(TEXT("APPCOMPAT: treating component: %s as non-transitive"), strComponentId);
				fComponentTransitive = false; // work as if the component is not marked transitive
			}

			if (fComponentTransitive)
			{
				// find the "true" condition on the component
				fComponentEnabled = (EvaluateCondition(MsiString(m_piComponentCursor->GetString(m_colComponentCondition))) == iecFalse)?fFalse:fTrue;



				// If a previously disabled transitive component is now enabled, install it.
				if (iClientState == INSTALLSTATE_NOTUSED && fComponentEnabled == true)
					iRequestedSelectState = (iRequestedSelectState == iisReinstallLocal) ? iisLocal : iisSource;

				// If previously installed transitive component has gone disabled, remove it.
				else if (iClientState != INSTALLSTATE_NOTUSED && (iisInstalled == iisLocal || iisInstalled == iisSource))
				{
					// The requested state remains local or source, even if iisAction is going to iisAbsent,
					// so that ProcessComponents will know to register the component as INSTALLSTATE_NOTUSED.
					iRequestedSelectState  = iisInstalled;
					iisAction = fComponentEnabled ? iisInstalled : iisAbsent;

					// In this case, we want to forcibly remove this component without regard to client list
					// or 'permanent' bit considerations.
					if (iisAction == iisAbsent)
					{
						PMsiRecord pRec(0);
						if ((piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *strComponentId, *&pRec, &iaaAsgnType)) != 0)
							return piErrRec;
	
						//
						// If the key path is SFP protected, we don't want to delete any of the registrations for this component
						// since the keypath is never going to go away so it is best to leave the registrations around.
						// Note: The specific case that this affects is bug # 409400 where speech components in Office packages
						// are installed on Win2K and lower platforms where they are not part of the system but not on WinXP and higher
						// where they are part of the system and hence SFP'ed. If a Win2K system with O2K is upgraded
						// to WinXP and a reinstall of Office is performed, we don't want the speech registrations to go away.
						//
						MsiString strKeyFullPath = pRec->GetMsiString(icmlcrFile);
						BOOL fProtected = fFalse;
						if ( g_MessageContext.m_hSfcHandle )
							fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strKeyFullPath));
						if (fProtected)
						{
							DEBUGMSG2(TEXT("Disallowing uninstallation of component: %s since key file %s is under SFP"), strComponentId, strKeyFullPath);
							iisAction = (iisEnum)iMsiNullInteger;
							fNullActionRequired = true;
						}

						fSkipSharedTransitionProcessing = true;
					}
				}

				// If new component, install it
				else if (iClientState == INSTALLSTATE_UNKNOWN)
					iRequestedSelectState = (iRequestedSelectState == iisReinstallLocal) ? iisLocal : iisSource;
				else
					iRequestedSelectState = (iisEnum) iMsiNullInteger;
			}
			else
			{
				// Standard reinstall -- we can't just set to iisInstalled because our reinstall request might also include a request for the component to go local if it's shared
				if ((iClientState != INSTALLSTATE_NOTUSED && (iisInstalled == iisLocal || iisInstalled == iisSource)) // existing component
					|| (iClientState == INSTALLSTATE_UNKNOWN && (iisInstalled == iisAbsent || (iisInstalled == (iisEnum) iMsiNullInteger && strComponentId.TextSize() == 0 /* unregistered */)))) // new component
					iRequestedSelectState = (iRequestedSelectState == iisReinstallLocal) ? iisLocal : iisSource;
				else
					iRequestedSelectState = (iisEnum) iMsiNullInteger;
			}
		}
		else if (!m_fForceRequestedState && iRequestedSelectState == iisInstalled)
		{
			// the component is already in the requested state
			iRequestedSelectState = (iisEnum) iMsiNullInteger;
		}

		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		// if the component is disabled and is set to be isolated to another component then we need to remove the 
		// files that we added to the other component
		if(!fComponentEnabled)
		{
			if ((piErrRec = RemoveIsolateEntriesForDisabledComponent(*this, MsiString(m_piComponentCursor->GetString(m_colComponentKey)))) != 0)
				return piErrRec;
		}

		// Action determination rules
		icaEnum icaInstallMode = icaEnum(icaAttributes & icaInstallMask);

		// Components with patchable or compressed files can't be RunFromSource
		if ((iRuntimeFlags & bfComponentPatchable) || (iRuntimeFlags & bfComponentCompressed))
			icaInstallMode = icaLocalOnly;

		if(!(GetMode() & iefAdmin))
		{
			if (iRequestedSelectState == iisLocal && icaInstallMode == icaSourceOnly)
				iRequestedSelectState = iisSource;
			else if (iRequestedSelectState == iisSource && icaInstallMode == icaLocalOnly)
				iRequestedSelectState = iisLocal;
		}

		if (iisAction == iMsiNullInteger && !fNullActionRequired)
			iisAction = iRequestedSelectState;

		MsiString istrComponentID = m_piComponentCursor->GetString(m_colComponentID);
		PMsiRecord pRec(0);
		if (istrComponentID.TextSize() == 0)  // unregistered component
		{
			iisAction = (fComponentEnabled && (iRequestedSelectState != iisAbsent)) ? iRequestedSelectState : (iisEnum) iMsiNullInteger;
			// Normally the PMsiSharedCursor implementation will do this when the shared cursor
			// goes out of scope. Here, we are going out of scope, but it doesn't look
			// that way to the compiler, so we'll reset the cursor by hand. This does
			// mean that the cursor will get reset twice in the case where it's not registered.
			m_piComponentCursor->Reset();
			return  UpdateComponentActionStates(idComponentString,iisAction, iRequestedSelectState, fComponentEnabled);
		}

		if ((iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent || iClientState == INSTALLSTATE_NOTUSED)
			&& fComponentEnabled == false)
		{
			iisAction = (iisEnum) iMsiNullInteger;
		}
		else if (!fSkipSharedTransitionProcessing)
		{  // Force Cursor to go out of scope before UpdateComponentActionStates
			switch(iisAction)
			{

		//--------------------------------------------------------------------------
			case iMsiNullInteger:
				switch(iisInstalled)
				{
				case iisLocal:
				case iisSource:
				{
					// need to shift to local if
					// 1. The installation state is absent/ (broken)
					if(iClientState == INSTALLSTATE_ABSENT && (!fComponentTransitive || (EvaluateCondition(MsiString(m_piComponentCursor->GetString(m_colComponentCondition))) != iecFalse)))
						iisAction = iisInstalled;
					break;
				}
				default:
					break;
				}
				break;

		//--------------------------------------------------------------------------
			case iisAbsent:
				switch(iisInstalled)
				{
				case iisSource:
				case iisLocal:
				{
					if (pRec == 0)
					{
						if ((piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *istrComponentID, *&pRec, &iaaAsgnType)) != 0)
							return piErrRec;
					}
					if ((piErrRec = DoStateTransitionForSharedUninstalls(iisAction, *pRec)) != 0)
						return piErrRec;
					break;
				}
				default:
					break;
				}
				break;

		//--------------------------------------------------------------------------

			case iisSource:
				switch(iisInstalled)
				{
				case iisLocal:
				{
					if (pRec == 0)
					{
						if ((piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *istrComponentID, *&pRec, &iaaAsgnType)) != 0)
							return piErrRec;
					}
					if ((piErrRec = DoStateTransitionForSharedUninstalls(iisAction, *pRec)) != 0)
						return piErrRec;
					break;
				}
				case iMsiNullInteger:
				case iisAbsent:
				{
					// prevent installation of "dont stomp" components if key path is regkey
					if((m_piComponentCursor->GetInteger(m_colComponentAttributes) & (icaNeverOverwrite | icaRegistryKeyPath)) == (icaNeverOverwrite | icaRegistryKeyPath))
					{
						if ((piErrRec = CheckNeverOverwriteForRegKeypath(idComponentString, iisAction)) != 0)
							return piErrRec;
					}
					break;
				}
				default:
					break;
				}
				break;

		//--------------------------------------------------------------------------
			case iisLocal:
				// prevent installation of older components, check for legacy installs
				if ((piErrRec = DoStateTransitionForSharedInstalls(idComponentString, iisAction)) != 0)
					return piErrRec;
				break;

		//--------------------------------------------------------------------------
			default:
				// unknown requested state
				return PostError(Imsg(idbgIllegalSetComponentRequest),0);
			}
		}
	}  // Force Cursor to go out of scope before UpdateComponentActionStates

	if(iisAction == iisOldAction && iRequestedSelectState == iisOldRequestedSelectState)
		return 0; // nothing to do

	return UpdateComponentActionStates(idComponentString,iisAction, iRequestedSelectState, fComponentEnabled);
}


// fn that checks if a particular GUID represents that used to mark permanant components
bool IsSystemClient(const IMsiString& riProduct)
{
	ICHAR rgchSystemProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(szSystemProductKey,    rgchSystemProductKeyPacked));
	ICHAR rgchProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(riProduct.GetString(), rgchProductKeyPacked));
	return !IStrCompI(rgchSystemProductKeyPacked + 2, rgchProductKeyPacked + 2); // system guid will have all characters except first 2 as "0"
}

IMsiRecord* CMsiEngine::DoStateTransitionForSharedUninstalls(iisEnum& riisAction, const IMsiRecord& riComponentPathRec)
{
	// if we are going from local to source or local to absent
		// we may need to switch to fileabsent state if there are other installs
		// but none in the same location
	
		// or null state if there are other installs in the same location

	// if we are going from source to absent
		// we may need to switch to null state  if there are other installs

	//NOTE: the riisAction variable is selectively modified AND is expected to be set to the default by the callee
	//NOTE: we assume that the m_piComponentCursor is set to the required component key
	//NOTE: we assume that the riComponentPathRec is a valid record returned by GetComponentPath

	Assert(m_piComponentCursor);

	MsiString strComponentId = m_piComponentCursor->GetString(m_colComponentID);
	INSTALLSTATE iClientState = (INSTALLSTATE)riComponentPathRec.GetInteger(icmlcrINSTALLSTATE);
	MsiString strFile = riComponentPathRec.GetMsiString(icmlcrFile);

	// what type of an install are we attempting
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;

    CClientEnumToken ctokProductIndex;
    ICHAR szProductBuf[cchProductCode + 1];
    Bool fLocalNonFusionPath = fFalse;
	enum cetEnumType cetET = cetVisibleToUser; // enumerate those hives that are visible to this user
    IMsiRecord* piErrRec = 0;
	int iHive = MsiString(strFile.Extract(iseUpto, TEXT(':')));
    // all fusion installs go to the same location, hence we should treat them as if they are non file key paths (we dont want to check the install location)
    if(((iClientState == INSTALLSTATE_LOCAL) || (iClientState == INSTALLSTATE_ABSENT)) && (strFile.TextSize()) 
    && *(const ICHAR*)strFile != chTokenFusionComponent && *(const ICHAR*)strFile != chTokenWin32Component &&
    (iHive == iMsiStringBadInteger))
    {
		// we have a local install and the key path is a file/ folder
		fLocalNonFusionPath = fTrue;
    }

	MsiString strUserId;
	MsiString strProduct;
	MsiString strCurrentUser;

	// get current user sid based on the assignment type
	// we need this to skip our own registration when determining other clients of the installation
	if(!g_fWin9X)
	{
		switch(iaaAsgnType)
		{
			case iaaUserAssign:
			case iaaUserAssignNonManaged:
			{
				DWORD dwResult = GetCurrentUserStringSID(*&strCurrentUser);
				if (ERROR_SUCCESS != dwResult)
					return PostError(Imsg(idbgOpGetUserSID));
				break;
			}

			case iaaMachineAssign:
				strCurrentUser = szLocalSystemSID;
				break;
		}
	}


	CEnumUsers cUsers(cetET);

	// set inital state to absent (everything to be removed)
	bool fCanRemoveFiles = true; //files
	bool fCanRemoveHKCR  = true; //hkcr registry data
	bool fCanRemoveOther = true; //other installation entities

	while((cUsers.Next(*&strUserId) == ERROR_SUCCESS))
    {
		CEnumComponentClients cClients(*strUserId, *strComponentId);
		while(cClients.Next(*&strProduct) == ERROR_SUCCESS)
		{
			if(!MsiString(GetProductKey()).Compare(iscExactI, strProduct))// not us 
			{
				// is this client in the same location
				INSTALLSTATE iAlienClientState;
				MsiString strAlienFile;
				PMsiRecord pRec(0);

				if ((piErrRec = GetComponentPath(m_riServices, strUserId, *strProduct, *strComponentId, *&pRec, 0)) != 0)
					return piErrRec;

				if((INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE_Static) == INSTALLSTATE_NOTUSED)
					continue; // this client has installed this component as disabled, hence does not count

				iAlienClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
				strAlienFile = pRec->GetMsiString(icmlcrFile);



				if(!fLocalNonFusionPath ||
					(((iAlienClientState == INSTALLSTATE_LOCAL)  || (iAlienClientState == INSTALLSTATE_ABSENT)) && (strAlienFile.TextSize()) && (MsiString(strAlienFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger) && strAlienFile.Compare(iscExactI, strFile)))
				{
					// non-file path, OR path matches to same location
					DEBUGMSG1(TEXT("Disallowing uninstallation of component: %s since another client exists"), strComponentId);
					// does the other client have a different assignment type than this product
					// then, we might still need to clean up the app. HKCR hive if on Win2k or greater
					// unless the component is marked as permanent
					if(g_fWin9X || fFalse == IsDarwinDescriptorSupported(iddOLE) || IsSystemClient(*strProduct) || strUserId.Compare(iscExact, strCurrentUser))
					{
						// < Win9x or NT4 or permanent component or this client is of the same assignment type
						// nothing gets removed
						fCanRemoveFiles = false;
						fCanRemoveHKCR  = false;
						fCanRemoveOther = false;
					}
					else
					{
						// >= Win2k and assignment types dont match
						// could still remove the hkcr data, if not already decided not to
						fCanRemoveFiles = false;
						fCanRemoveOther = false;
					}
				}
				else
				{
					// local path, but locations don't match
					if(g_fWin9X || fFalse == IsDarwinDescriptorSupported(iddOLE) || strUserId.Compare(iscExact, strCurrentUser))
					{
						// < Win9x or NT4 or this client is of the same assignment type
						// could still remove the files, if not already decided not to
						fCanRemoveHKCR  = false;
						fCanRemoveOther = false;
					}
					else
					{
						// >= Win2k and assignment types dont match
						// could still remove the files and hkcr, if not already decided not to
						fCanRemoveOther = false;
					}
				}
			}
		}
    }

	// translate the decision regarding the files, hkcr data and other installation entities into action states
	if(riisAction == iisAbsent)
	{
		if(!fCanRemoveFiles && !fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = (iisEnum)iMsiNullInteger;
		else if(fCanRemoveFiles && !fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = iisFileAbsent;
		else if(fCanRemoveFiles && fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = iisHKCRFileAbsent;
		else if(!fCanRemoveFiles && fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = iisHKCRAbsent;
		else
			Assert(fCanRemoveFiles && fCanRemoveHKCR && fCanRemoveOther);
	}
	else
	{
		Assert(riisAction == iisSource);
		// we shouldn't allow the state to be source if the files need to stay around
		if(!fCanRemoveFiles)
			riisAction = (iisEnum)iMsiNullInteger;
	}



    if((riisAction != iMsiNullInteger) && fLocalNonFusionPath) // we are still planning to remove the component/files AND (client state local AND key path is file)
    {
		// check the Shared DLL refcount
		return CheckLegacyAppsForSharedUninstalls(*strComponentId, riisAction, riComponentPathRec);
    }
    return 0;
}

// FN: GetSharedDLLCountForMsiRegistrations
// iterates through the registrations for all users for the component riComponentId
// that is installed to the same location as riKeyFullPath and are marked as being refcounted
// in the Shared Dll registry and returns the count of the same
IMsiRecord* GetSharedDLLCountForMsiRegistrations(IMsiServices& riServices, const IMsiString& riComponentId, const IMsiString& riKeyFullPath, int& riMsiDllCount)
{
	CEnumUsers cUsers(cetAll);// enumerate though the component registration of all users
	MsiString strUserId;
	MsiString strProduct;


	riMsiDllCount = 0;

    while(cUsers.Next(*&strUserId) == ERROR_SUCCESS)
    {
		CEnumComponentClients cClients(*strUserId, riComponentId);
		while(cClients.Next(*&strProduct) == ERROR_SUCCESS)
		{
			INSTALLSTATE iAlienClientState;
			MsiString strAlienFile;
			PMsiRecord pRec(0);

			IMsiRecord* piErrRec = 0;
			if ((piErrRec = GetComponentPath(riServices, strUserId, *strProduct, riComponentId, *&pRec, 0)) != 0)
				return piErrRec;

			if((INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE_Static) == INSTALLSTATE_NOTUSED)
				continue; // this client has installed this component as disabled, hence does not count

			iAlienClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
			strAlienFile = pRec->GetMsiString(icmlcrFile);

			// is this client installed local
			if(((iAlienClientState == INSTALLSTATE_LOCAL)  || (iAlienClientState == INSTALLSTATE_ABSENT)) && (strAlienFile.TextSize()) && (MsiString(strAlienFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger))
			{
				// is it in the same location and is it refcounted
				if((strAlienFile.Compare(iscExactI, riKeyFullPath.GetString())) && (pRec->GetInteger(icmlcrSharedDllCount) == fTrue))
					riMsiDllCount++;
			}
		}
	}
	return 0;
}

IMsiRecord* CMsiEngine::CheckLegacyAppsForSharedUninstalls(const IMsiString& riComponentId, iisEnum& riisAction, const IMsiRecord& riComponentPathRec)
{
	// check the Shared Dll count for sharing with legacy apps
	// for components that are not installed in the system folder
	//    we simply check the  ref count of the key file
	// else
	//    we check the ref count of all the files in the component

	//NOTE: the riisAction variable is selectively modified AND is expected to be set to the default by the callee
	//NOTE: we assume that the m_piComponentCursor is set to the required component key
	//NOTE: we assume that the riComponentPathRec is a valid record returned by GetComponentPath

	MsiString strKeyFullPath = riComponentPathRec.GetMsiString(icmlcrFile);

	// check the registry for shared dll count
	MsiString strCount;

	Assert(m_piComponentCursor);

	const int iAttrib = m_piComponentCursor->GetInteger(m_colComponentAttributes);
	const ibtBinaryType iType = 
		(iAttrib & msidbComponentAttributes64bit) == msidbComponentAttributes64bit ? ibt64bit : ibt32bit;

	// check the key file for all components
	IMsiRecord* piErrRec = GetSharedDLLCount(m_riServices, strKeyFullPath, iType, *&strCount);
	if (piErrRec)
		return piErrRec;
	strCount.Remove(iseFirst, 1);
	// get the shared dll count that is attributable to msi registration
	int iMsiDllCount = 0;
	piErrRec = GetSharedDLLCountForMsiRegistrations(m_riServices, riComponentId, *strKeyFullPath, iMsiDllCount);
	if (piErrRec)
		return piErrRec;
	if((strCount != iMsiStringBadInteger) && (strCount > iMsiDllCount))
	{
		riisAction = (iisEnum)iMsiNullInteger; // externally shared dll
		return 0;
	}

	MsiString strOldKeyPath = riComponentPathRec.GetMsiString(icmlcrRawFile);

	bool fAssembly = FALSE;
    if(	*(const ICHAR* )strOldKeyPath == chTokenFusionComponent || 
		*(const ICHAR* )strOldKeyPath == chTokenWin32Component)
	{
		fAssembly = TRUE;
	}

	// If the keyfile is protected by SFP, always treat as permanent

	AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
				g_szNoSFCMessage);
	if(!fAssembly)	
	{
		BOOL fProtected = fFalse;
		if ( g_MessageContext.m_hSfcHandle )
			fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strKeyFullPath));
		if (fProtected)
		{
			DEBUGMSG2(TEXT("Disallowing uninstallation of component: %s since key file %s is under SFP"), riComponentId.GetString(), strKeyFullPath);
			riisAction = (iisEnum)iMsiNullInteger;
			return 0;
		}
	}

	// app compat fix 350947
	// fix for component TTSData.A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24 
	// from the merge module Sp5TTInt.msm
	// this component has its key file Mary.sdf not SFP'd in Whistler
	// however a non-key file sam.sdf is SFP'd. Hence we would have ordinarily 
	// remove all registration for the component while leaving the SFP'd file
	// alone. However this busts the component.
	// hence we check the component id of the component and effectively treat it
	// as permanant on Whistler and above

	// app comat fix 368867
	// help files for SAPI product being removed on Whistler even though they are installed as part of the OS

	if(MinimumPlatformWindowsNT51() && 
		(riComponentId.Compare(iscExact, TTSData_A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24) ||
		riComponentId.Compare(iscExact, SapiCplHelpEng_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
		riComponentId.Compare(iscExact, SapiCplHelpJpn_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
		riComponentId.Compare(iscExact, SapiCplHelpChs_0880F209_45FA_42C5_92AE_5E620033E8EC)))
	{
		DEBUGMSG1(TEXT("APPCOMPAT: Disallowing uninstallation of component: %s"), riComponentId.GetString());
		riisAction = (iisEnum)iMsiNullInteger;
		return 0;
	}

	// if we are installed in the systems folder we check the reg key count for all files

	// is this the system folder
	// First we do a quick check
	MsiString strSystemFolder = GetPropertyFromSz(IPROPNAME_SYSTEM_FOLDER);
	if(!strKeyFullPath.Compare(iscStartI, strSystemFolder))
		return 0;
	MsiString strSystem64Folder;
	if ( g_fWinNT64 )
	{
		strSystem64Folder = GetPropertyFromSz(IPROPNAME_SYSTEM64_FOLDER);
		if ( !strKeyFullPath.Compare(iscStartI, strSystem64Folder) )
			return 0;
	}

	PMsiPath pPath(0);
	MsiString strComponentDir = m_piComponentCursor->GetString(m_colComponentDir);
	if ((piErrRec = GetTargetPath(*strComponentDir, *&pPath)) != 0)
		return piErrRec;

	MsiString strPath = pPath->GetPath();
	if(!strPath.Compare(iscExactI, strSystemFolder)
		|| (g_fWinNT64 && !strPath.Compare(iscExactI, strSystem64Folder)) )
		return 0;

	PMsiTable pFileTable(0);
	if ((piErrRec = LoadFileTable(3,*&pFileTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
			return piErrRec;
	}


	PMsiCursor pFileCursor(pFileTable->CreateCursor(fFalse));
	Bool fLFN = ((GetMode() & iefSuppressLFN) == 0 && pPath->SupportsLFN()) ? fTrue : fFalse;

	int iColComponent = m_mpeftCol[ieftComponent];
	int iColFileName  = m_mpeftCol[ieftName];

	MsiStringId idComponent    = m_piComponentCursor->GetInteger(m_colComponentKey);

	pFileCursor->SetFilter(iColumnBit(iColComponent));
	pFileCursor->PutInteger(iColComponent, idComponent);
	while(pFileCursor->Next())
	{
		MsiString strFileName;
		MsiString strFullFilePath;

		if ((piErrRec = m_riServices.ExtractFileName(MsiString(pFileCursor->GetString(iColFileName)),fLFN,*&strFileName)) != 0)
			return piErrRec;
		if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strFullFilePath)) != 0)
			return piErrRec;
		if ((piErrRec = GetSharedDLLCount(m_riServices, strFullFilePath, iType, *&strCount)) != 0)
			return piErrRec;
		strCount.Remove(iseFirst, 1);
		if((strCount != iMsiStringBadInteger) && (strCount > iMsiDllCount))
		{
			riisAction = (iisEnum)iMsiNullInteger; // externally shared dll
			break;
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::CheckNeverOverwriteForRegKeypath(const MsiStringId idComponentString, iisEnum& riisAction)
{
	MsiString strComponent(m_piDatabase->DecodeString(idComponentString));
	IMsiRecord* piErrRec = 0;

	// check if the key path exists
	PMsiView pView(0);
	static const ICHAR* szKeyRegistrySQL    =   TEXT(" SELECT `Root`,`Key`,`Name`,`Value`,`Component`.`Attributes`")
												TEXT(" FROM `Registry`,`Component`")
												TEXT(" WHERE `Registry`.`Registry` = `Component`.`KeyPath` AND `Component`.`Component` = ?");

	PMsiRecord pRec = &m_riServices.CreateRecord(1);
	pRec->SetMsiString(1, *strComponent);
	if((piErrRec = OpenView(szKeyRegistrySQL, ivcFetch, *&pView)) != 0)
		return piErrRec;
	if((piErrRec = pView->Execute(pRec)) != 0)
		return piErrRec;
	pRec = pView->Fetch();
	if(!pRec)
	{
#if DEBUG
		ICHAR szError[256];
		ASSERT_IF_FAILED(StringCchPrintf(szError, ARRAY_ELEMENTS(szError),
				TEXT("Error registering component %s. Possible cause: Component.KeyPath may not be valid"),(const ICHAR*)strComponent));
		AssertSz(0, szError);
#endif
		return PostError(Imsg(idbgBadComponent),(const ICHAR*)strComponent);
	}

	enum {
		irrRoot=1,
		irrKey,
		irrName,
		irrValue,
		irrAttributes
	};

	rrkEnum rrkCurrentRootKey;
	MsiString strSubKey;
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	switch(pRec->GetInteger(irrRoot))
	{
	case 0:
		if(fAllUsers || IsDarwinDescriptorSupported(iddOLE) == fFalse)
		{
			rrkCurrentRootKey =  (rrkEnum)rrkLocalMachine;
			strSubKey = szClassInfoSubKey;
		}
		else
		{
			rrkCurrentRootKey =  (rrkEnum)rrkUsers;
			AssertNonZero(GetCurrentUserStringSID(*&strSubKey) == ERROR_SUCCESS);
			strSubKey += MsiString(TEXT("\\"));
			strSubKey += szClassInfoSubKey;
		}
		break;
	case 1:
		rrkCurrentRootKey =  (rrkEnum)rrkCurrentUser;
		break;
	case 2:
		rrkCurrentRootKey =  (rrkEnum)rrkLocalMachine;
		break;
	case 3:
		rrkCurrentRootKey =  (rrkEnum)rrkUsers;
		break;
	case -1:
		rrkCurrentRootKey =  (rrkEnum)rrkUserOrMachineRoot; // do HKLM or HKCU based on ALLUSERS
		break;
	default:
		rrkCurrentRootKey =  (rrkEnum)(pRec->GetInteger(irrRoot) + (int)rrkClassesRoot);
		break;
	}

	ibtBinaryType ibtType = 
		(pRec->GetInteger(irrAttributes) & msidbComponentAttributes64bit) == msidbComponentAttributes64bit ? ibt64bit : ibt32bit;
	MsiString strKey = FormatText(*MsiString(pRec->GetMsiString(irrKey)));
	PMsiRegKey pRegKeyRoot = &m_riServices.GetRootKey(rrkCurrentRootKey, ibtType);
	if(strSubKey)
		pRegKeyRoot = &(pRegKeyRoot->CreateChild(strSubKey));
	PMsiRegKey pRegKey = &(pRegKeyRoot->CreateChild(strKey));

	MsiString strName = FormatText(*MsiString(pRec->GetMsiString(irrName)));

	MsiString strValue = FormatText(*MsiString(pRec->GetMsiString(irrValue)));
	Bool fExists;

	extern const ICHAR* REGKEY_CREATE;
	extern const ICHAR* REGKEY_DELETE;
	extern const ICHAR* REGKEY_CREATEDELETE;

	if(strValue.TextSize() ||
		(!strName.Compare(iscExact, REGKEY_CREATE) && !strName.Compare(iscExact, REGKEY_CREATEDELETE) && !strName.Compare(iscExact, REGKEY_DELETE)))
	{
		// check that the key + name exists
		piErrRec = pRegKey->ValueExists(strName, fExists);
	}
	else
	{
		// check that the key exists
		piErrRec = pRegKey->Exists(fExists);
	}
	if(piErrRec)
		return piErrRec;
	if(fExists)
	{
		riisAction = (iisEnum)iMsiNullInteger; // disallow installation, "dont stomp" component
		DEBUGMSG1(TEXT("Disallowing installation of component: %s since the registry keypath exists and the component is marked to never overwrite existing installations"), strComponent);
	}
	return 0;

}

IMsiRecord* CMsiEngine::GetAssemblyInfo(const IMsiString& rstrComponent, iatAssemblyType& riatAssemblyType, const IMsiString** ppistrAssemblyName, const IMsiString** ppistrManifestFileKey)
{
	static const ICHAR* szFusionComponentSQL =  TEXT(" SELECT `MsiAssembly`.`Attributes`, `MsiAssembly`.`File_Application`, `MsiAssembly`.`File_Manifest`,  `Component`.`KeyPath` FROM `MsiAssembly`, `Component` WHERE  `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Component_` = ?");

	riatAssemblyType = iatNone; // initialize to none

	if((GetMode() & iefAdmin) || !m_fAssemblyTableExists)
		return 0;// doing admin install OR no assembly table, return

	IMsiRecord* piError = 0;
	if(!m_pViewFusion)
	{
		piError = OpenView(szFusionComponentSQL, ivcFetch, *&m_pViewFusion);
		if(piError)
		{
			if(piError->GetInteger(1) == idbgDbQueryUnknownTable) // okay to not have the Assembly table
			{
				piError->Release();
				m_fAssemblyTableExists = false;
				return 0;
			}
			// else error
			return piError;
		}
	}
	PMsiRecord pParam = &m_riServices.CreateRecord(1);
	pParam->SetMsiString(1, rstrComponent);
	piError = m_pViewFusion->Execute(pParam);
	if(piError)
		return piError;

	PMsiRecord pRec = m_pViewFusion->Fetch();
	if(pRec)
	{
		// the component is an assembly, check which type
		enum {
			atAttributes = 1,
			atAppCtx,
			atManifest,
			atKeyFile,
		};
		if((pRec->GetInteger(atAttributes) & msidbAssemblyAttributesWin32) == msidbAssemblyAttributesWin32)
		{
			// if system does not SXS, ignore Win32 assemblies
			if(!MsiString(GetPropertyFromSz(IPROPNAME_WIN32ASSEMBLYSUPPORT)).TextSize())
				return 0;

			if(pRec->IsNull(atAppCtx))
				riatAssemblyType = iatWin32Assembly;
			else
				riatAssemblyType = iatWin32AssemblyPvt;
		}
		else
		{
			if(pRec->IsNull(atAppCtx))
				riatAssemblyType = iatURTAssembly;
			else
				riatAssemblyType = iatURTAssemblyPvt;

		}
		// get the assembly name
		if(ppistrAssemblyName)
		{
			piError = GetAssemblyNameSz(rstrComponent, riatAssemblyType, false, *ppistrAssemblyName);
			if(piError)
				return piError;
		}
		// get the mainfest file key
		if(ppistrManifestFileKey)
		{
			MsiString strManifest = pRec->GetMsiString(atManifest);
			if(!strManifest.TextSize()) // use the key file as the manifest
				strManifest = pRec->GetMsiString(atKeyFile);
			strManifest.ReturnArg(*ppistrManifestFileKey);
		}

	}
	return 0;
}


IMsiRecord* CMsiEngine::GetAssemblyNameSz(const IMsiString& rstrComponent, iatAssemblyType /*iatAT*/, bool fOldPatchAssembly, const IMsiString*& rpistrAssemblyName)
{
	static const ICHAR* szAssemblyNameNameSQL         = TEXT(" SELECT `Value` FROM `MsiAssemblyName` WHERE `Component_` = ? AND (`Name` = 'Name' OR `Name` = 'NAME' OR `Name` = 'name')");
	static const ICHAR* szAssemblyNameSQL             = TEXT(" SELECT `Name`, `Value` FROM `MsiAssemblyName` WHERE `Component_` = ? AND (`Name` <> 'Name' AND `Name` <> 'NAME' AND `Name` <> 'name')");

	static const ICHAR* szPatchOldAssemblyNameNameSQL = TEXT(" SELECT `Value` FROM `MsiPatchOldAssemblyName` WHERE `Assembly` = ? AND (`Name` = 'Name' OR `Name` = 'NAME' OR `Name` = 'name')");
	static const ICHAR* szPatchOldAssemblyNameSQL     = TEXT(" SELECT `Name`, `Value` FROM `MsiPatchOldAssemblyName` WHERE `Assembly` = ? AND (`Name` <> 'Name' AND `Name` <> 'NAME' AND `Name` <> 'name')");

	MsiString strName;
	IMsiRecord* piError = 0;

	IMsiView* piViewAssemblyNameName = 0;
	IMsiView* piViewAssemblyName     = 0;

	if(false == fOldPatchAssembly)
	{
		if(!m_pViewFusionNameName)
		{
			piError = OpenView(szAssemblyNameNameSQL, ivcFetch, *&m_pViewFusionNameName);
			if(piError)
				return piError;
		}

		piViewAssemblyNameName = m_pViewFusionNameName;
	}
	else
	{
		if(!m_pViewOldPatchFusionNameName)
		{
			piError = OpenView(szPatchOldAssemblyNameNameSQL, ivcFetch, *&m_pViewOldPatchFusionNameName);
			if(piError)
				return piError;
		}

		piViewAssemblyNameName = m_pViewOldPatchFusionNameName;
	}

	PMsiRecord pParam = &m_riServices.CreateRecord(1);
	pParam->SetMsiString(1, rstrComponent);
	piError = piViewAssemblyNameName->Execute(pParam);
	if(piError)
		return piError;
	PMsiRecord pRec = piViewAssemblyNameName->Fetch();
	if(!pRec)
	{
		//authoring error
		return PostError(Imsg(idbgBadAssemblyName),rstrComponent); //!! change error for oldpatch case
	}
	strName = pRec->GetString(1);

	// now get the rest of the name
	// first get the name part of the assembly name

	if(false == fOldPatchAssembly)
	{
		if(!m_pViewFusionName)
		{
			piError = OpenView(szAssemblyNameSQL, ivcFetch, *&m_pViewFusionName);
			if(piError)
				return piError;
		}

		piViewAssemblyName = m_pViewFusionName;
	}
	else
	{
		if(!m_pViewOldPatchFusionName)
		{
			piError = OpenView(szPatchOldAssemblyNameSQL, ivcFetch, *&m_pViewOldPatchFusionName);
			if(piError)
				return piError;
		}

		piViewAssemblyName = m_pViewOldPatchFusionName;
	}

	piError = piViewAssemblyName->Execute(pParam);
	if(piError)
		return piError;

	while(pRec = piViewAssemblyName->Fetch())
	{
		// construct [,name="value"] pairs
		strName	+= MsiString(MsiChar(','));
		strName	+= MsiString(pRec->GetString(1));
		strName	+= MsiString(MsiChar('='));
		strName	+= MsiString(MsiChar('\"'));
		strName	+= MsiString(pRec->GetString(2));
		strName	+= MsiString(MsiChar('\"'));
	}
	strName.ReturnArg(rpistrAssemblyName);
	return 0;
}


IMsiRecord* CMsiEngine::DoStateTransitionForSharedInstalls(const MsiStringId idComponentString, iisEnum& riisAction)
{
	Assert(riisAction == iisLocal); // expected to be called for local installs only
#ifdef DEBUG
	{
		MsiString strComponentTemp(m_piDatabase->DecodeString(idComponentString));
		ICHAR rgchComponent[256];
		strComponentTemp.CopyToBuf(rgchComponent,255);
	}
#endif
	
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec = 0;
	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fFalse));
	pCursor->SetFilter(1);
	pCursor->PutInteger(m_colComponentKey,idComponentString);
	if(!pCursor->Next())
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponentString)));

	int icaAttributes = pCursor->GetInteger(m_colComponentAttributes);
	// first check if the key path is a file
	MsiStringId idFileKey = pCursor->GetInteger(m_colComponentKeyPath);
	if(idFileKey == iTableNullString || (icaAttributes & icaODBCDataSource)) // not file or Regkey
		return 0;

	if(icaAttributes & icaRegistryKeyPath)
	{
		// if the component is marked with the "dont stomp" attribute, we should disallow the installation
		if(icaAttributes & icaNeverOverwrite)
			return CheckNeverOverwriteForRegKeypath(idComponentString, riisAction);
		return 0;
	}

    // do we have a fusion component  
    iatAssemblyType iatAT;
    MsiString strComponent = m_piDatabase->DecodeString(idComponentString);
    MsiString strComponentId = pCursor->GetString(m_colComponentID);

	MsiString strAssemblyName;
	piErrRec = GetAssemblyInfo(*strComponent, iatAT, &strAssemblyName, 0);
	if (piErrRec)
		return piErrRec;

	if(iatAT == iatURTAssembly || iatAT == iatWin32Assembly)
	{
		// if we have been asked to force reinstall simply return
		if(GetMode() & iefOverwriteAllFiles)
			return 0; // allow the reinstall

		// check the health of the installation, if any on the machine
		HRESULT hr;
		PAssemblyCache pCache(0);
		if(iatAT == iatURTAssembly)
			hr = FUSION::CreateAssemblyCache(&pCache, 0);
		else
		{
			Assert(iatAT == iatWin32Assembly);
			hr = SXS::CreateAssemblyCache(&pCache, 0);
		}
		if(!SUCCEEDED(hr))
		{
			if(iatAT == iatURTAssembly) // if cannot find fusion, assume we are bootstrapping, hence assume no assembly installed
			{
				PMsiRecord(PostAssemblyError(strComponentId, hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT)); // log error
				DEBUGMSG(TEXT("ignoring fusion interface error, assuming we are bootstrapping"));
				return 0;
			}
			else
				return PostAssemblyError(strComponentId, hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT);
		}


		LPCOLESTR szAssemblyName;
		szAssemblyName = strAssemblyName;
		//pass the right flags in
		DWORD dwFlags = GetMode() & iefOverwriteCorruptedFiles ? QUERYASMINFO_FLAG_VALIDATE : 0;

	    hr = pCache->QueryAssemblyInfo(dwFlags, szAssemblyName, NULL);

		//if okay or simply not refcounted via darwin then dont reinstall
		if(SUCCEEDED(hr)) // the flags we pass match the state of the assembly
		{
			riisAction = (iisEnum)iMsiNullInteger; // already installed
			DEBUGMSG1(TEXT("skipping installation of assembly component: %s since the assembly already exists"), strComponentId);
		}
		return 0;
	}

    // we have a file as the key path

	if(pCursor->GetInteger(m_colComponentLegacyFileExisted) != iMsiNullInteger)
	{
		// reset the legacyfileexisted column
		pCursor->PutNull(m_colComponentLegacyFileExisted);
		pCursor->Update();
	}

	GetSharedEngineCMsiFile(pobjFile, *this);
	piErrRec = pobjFile->FetchFile(*MsiString(m_piDatabase->DecodeString(idFileKey)));
	if (piErrRec)
		return piErrRec;

	PMsiRecord pFileInfoRec(pobjFile->GetFileRecord());

	if(!pFileInfoRec)
		 return PostError(Imsg(idbgBadFile),(const ICHAR*)MsiString(m_piDatabase->DecodeString(idFileKey)));


	PMsiPath pPath(0);
	MsiString strFileName;
	piErrRec = GetTargetPath(*MsiString(pFileInfoRec->GetMsiString(CMsiFile::ifqDirectory)),*&pPath);
	if (piErrRec)
		return piErrRec;

	Bool fLFN = ((GetMode() & iefSuppressLFN) == 0 && pPath->SupportsLFN()) ? fTrue : fFalse;
	if ((piErrRec = m_riServices.ExtractFileName(MsiString(pFileInfoRec->GetString(CMsiFile::ifqFileName)),fLFN,*&strFileName)))
		return piErrRec;

	// put back in pFileRec
	AssertNonZero(pFileInfoRec->SetMsiString(CMsiFile::ifqFileName,*strFileName));

	// check if the file exists
	Bool fExists;
	if ((piErrRec = pPath->FileExists(strFileName, fExists)) != 0)
		return piErrRec;

	if(!fExists)
		return 0;

	// if the component is marked with the "dont stomp" attribute, we should disallow the installation
	int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags);
	if ((icaAttributes & icaNeverOverwrite) || (iRuntimeFlags & bfComponentNeverOverwrite))  // authored flag or internally generated flag
	{
		riisAction = (iisEnum)iMsiNullInteger; // disallow installation, "dont stomp" component
		DEBUGMSG1(TEXT("Disallowing installation of component: %s since the keyfile exists and the component is marked to never overwrite existing installations"), strComponentId);
	}
	else
	{
		// prevent installation of possibly older component

		// OR in iefOverwriteEqualVersions flag temporarily so that we allow for -
		// 1. Installing a component where the version of the key file
		//    has remained the same but an auxiliary file has been updated
		// 2. Turning on the component, if not file reinstall is selected
		//    but other reinstalls have been.

		MsiString strFullPath;
		if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strFullPath)) != 0)
			return piErrRec;
		
		// If keyfile is protected, the component should be disabled if existing protected
		// file is same version as the keyfile.
		AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
					g_szNoSFCMessage);
		BOOL fProtected = fFalse;
		if ( g_MessageContext.m_hSfcHandle )
			fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strFullPath));
		bool fExistingMode = (fProtected || (GetMode() & iefOverwriteEqualVersions)) ? true:false;
		if(!fExistingMode)
			SetMode(iefOverwriteEqualVersions, fTrue);
		ifsEnum ifsState;
		int fBitVersioning = 0;
		piErrRec = ENG::GetFileInstallState(*this,*pFileInfoRec,0,0,0,&ifsState,
														/* fIgnoreCompanionParentAction=*/ true,
														/* fIncludeHashCheck=*/ false, &fBitVersioning);
		if(!fExistingMode)
			SetMode(iefOverwriteEqualVersions, fFalse);
		if (piErrRec)
			return piErrRec;
		if(!pFileInfoRec->GetInteger(CMsiFile::ifqState))
		{
			iisEnum iisOrigAction = riisAction;
			riisAction = (iisEnum)iMsiNullInteger; // disallow installation, "lesser" component
			if (fProtected && ifsState == ifsExistingEqualVersion)
				DEBUGMSG1(TEXT("Disallowing installation of component: %s since an equal version of its keyfile exists, and is protected by Windows"), strComponentId);
			else if (!(fBitVersioning & ifBitExistingModified))
				DEBUGMSG1(TEXT("Disallowing installation of component: %s since the same component with higher versioned keyfile exists"), strComponentId);
			else
			{
				// per bug 146316 (10630), we do not disable a component if the keypath is an unversioned file and the version on the machine is modified
				DEBUGMSG1(TEXT("Allowing installation of component: %s even though a modified unversioned keyfile exists and file versioning rules would disable the component"), strComponentId);
				riisAction = iisOrigAction;
			}
		}
	}

	MsiString strFullFilePath;
	if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strFullFilePath)) != 0)
		return piErrRec;

	bool fDarwinInstalledComponentExists = false;

	// what type of an install are we attempting
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;

	CClientEnumToken ctokProductIndex;
	MsiString strProduct;
	MsiString strUserId;

	// enumerate through all the clients of the component
	CEnumUsers cUsers(cetAll);
	while(cUsers.Next(*&strUserId) == ERROR_SUCCESS)
	{
		CEnumComponentClients cClients(*strUserId, *strComponentId);
		while(cClients.Next(*&strProduct) == ERROR_SUCCESS)
		{
			INSTALLSTATE iAlienClientState;
			MsiString strAlienFile;
			PMsiRecord pRec(0);

			// get the client state for the product

			if ((piErrRec = GetComponentPath(m_riServices, strUserId, *strProduct, *strComponentId, *&pRec, 0)) != 0)
				return piErrRec;

			iAlienClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
			strAlienFile = pRec->GetMsiString(icmlcrFile);

			// making sure the client is local and not registry path
			if((iAlienClientState == INSTALLSTATE_LOCAL) && (strAlienFile.TextSize()) && (MsiString(strAlienFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger))
			{
				// is this client in the same location

				// is the file path the same
				//!! we can assume that because of the VolumePref, we can get away with
				// a string compare. However this will not work when the other product
				// installs with a LFN preference different from ours.
				if(strFullFilePath.Compare(iscExactI, strAlienFile))
				{
					fDarwinInstalledComponentExists = true;
					break;
				}
			}
		}
	}

	if(!fDarwinInstalledComponentExists)
	{
		// if the key file exists on the machine w/o having been installed via darwin - legacy apps
		pCursor->PutInteger(m_colComponentLegacyFileExisted, 1);
		pCursor->Update();
	}
	return 0;
}

IMsiRecord*     CMsiEngine::LoadFileTable(int cAddColumns, IMsiTable*& pFileTable)
{
	IMsiRecord* piRec = 0;

	// First try to load the table
	if ((piRec = m_piDatabase->LoadTable(*MsiString(*sztblFile),cAddColumns,pFileTable)) != 0)
		return piRec;

	// Next see if the column indexes are set
	if (m_mpeftCol[0] == 0)
	{
		int i;
		for (i = 0 ; i < ieftMax ; i++)
			m_mpeftCol[i] = pFileTable->GetColumnIndex(m_piDatabase->EncodeStringSz(mpeftSz[i]));
	}

	return 0;

}

IMsiRecord* CMsiEngine::UpdateComponentActionStates(const MsiStringId idComponent, iisEnum iisAction, iisEnum iActionRequestState, bool fComponentEnabled)
/*----------------------------------------------------------------------------
Internal Engine function which walks the Component table tree that includes the
specified component and all its children, updating the iisAction state of each
component record.  If Null is passed for pistrComponent, the entire component
tree will be updated.

Returns: False if an invalid condition was requested for the component, or if
the component is not found in the Component Table.
------------------------------------------------------------------------------*/
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all pistrComponent's children
	pCursor->SetFilter(1);
	pCursor->PutInteger(m_colComponentKey,idComponent);
	if (pCursor->Next() != 1)
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponent)));
	pCursor->SetFilter(0);

	do
	{
#ifdef DEBUG
		MsiString strComponentTemp(pCursor->GetString(m_colComponentKey));
		ICHAR rgchComponent[256];
		strComponentTemp.CopyToBuf(rgchComponent,255);
#endif
		// Keep track of old action state for use in dynamic cost updating below
		iisEnum iisOldAction = (iisEnum) pCursor->GetInteger(m_colComponentAction);

		// All components must track the parent's UseSource status
		AssertNonZero(pCursor->PutInteger(m_colComponentAction, iisAction));
		AssertNonZero(pCursor->PutInteger(m_colComponentActionRequest, iActionRequestState));

		// we may be switching the component enable bit for transitive components reinstall
		int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags);
		if (fComponentEnabled)
			iRuntimeFlags &= ~bfComponentDisabled;
		else
			iRuntimeFlags |= bfComponentDisabled;

		AssertNonZero(pCursor->PutInteger(m_colComponentRuntimeFlags, iRuntimeFlags));
		AssertNonZero(pCursor->Update());

		// If the action state has changed, the dynamic costs attributed to
		// volumes in the VolumeCost table may need to be updated.
		if (m_fCostingComplete && iisAction != iisOldAction)
		{
			IMsiRecord* piErrRec;
			if ((piErrRec = RecostComponentActionChange(pCursor,iisOldAction)) != 0)
				return piErrRec;
		}
	}while (pCursor->Next() > 1);
	return 0;
}

IMsiTable* CMsiEngine::GetVolumeCostTable()
//---------------------------------------
{
	if (m_piVolumeCostTable)
		m_piVolumeCostTable->AddRef();
	return m_piVolumeCostTable;
}


IMsiRecord* CMsiEngine::InitializeDynamicCost(bool fReinitialize)
//-------------------------------------------
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (m_piVolumeCostTable && m_fCostingComplete)
	{
		// initialize volume cost to 0 for each volume
		PMsiDatabase pDatabase(GetDatabase());
		PMsiCursor pVolCursor = m_piVolumeCostTable->CreateCursor(fFalse);
		Assert (pVolCursor);
		int iColSelVolumeCost = m_piVolumeCostTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colVolumeCost));
		int iColSelNoRbVolumeCost = m_piVolumeCostTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colNoRbVolumeCost));
		Assert(iColSelVolumeCost > 0);
		Assert(iColSelNoRbVolumeCost > 0);
		while (pVolCursor->Next())
		{
			AssertNonZero(pVolCursor->PutInteger(iColSelVolumeCost,0));
			AssertNonZero(pVolCursor->PutInteger(iColSelNoRbVolumeCost,0));
			AssertNonZero(pVolCursor->Update());
		}
	}
	
	IMsiRecord* piErrRec = 0;
	SetCostingComplete(fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFDISKSPACE),fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFNORBDISKSPACE),fFalse);
	m_pCostingCursor = m_piComponentTable->CreateCursor(fFalse);
	m_fReinitializeComponentCost = fReinitialize;

	// Reset all cost adjusters
	if (m_piCostAdjusterTable)
	{
		PMsiCursor pCostCursor(m_piCostAdjusterTable->CreateCursor(fFalse));
		pCostCursor->Reset();
		while (pCostCursor->Next())
		{
			PMsiCostAdjuster pCostAdjuster = (IMsiCostAdjuster*) pCostCursor->GetMsiData(m_colCostAdjuster);
			if (pCostAdjuster)
			{
				if ((piErrRec = pCostAdjuster->Reset()) != 0)
					return piErrRec;
			}
		}
	}

	return 0;
}


bool CMsiEngine::IsBackgroundCostingEnabled()
//--------------------------------
{
	return (m_fCostingComplete == false) && (m_fForegroundCostingInProgress == false);
}


bool CMsiEngine::IsCostingComplete()
//--------------------------------
{
	return m_fCostingComplete;
}



void CMsiEngine::SetCostingComplete(bool fCostingComplete)
//---------------------------------
{
	m_fCostingComplete = fCostingComplete;
	SetPropertyInt(*MsiString(*IPROPNAME_COSTINGCOMPLETE),m_fCostingComplete);
}



IMsiRecord* CMsiEngine::RecostAllComponents(Bool& fCancel)
/*--------------------------------------------------------
Reinitializes and re-calculates the cost of all components
in the Component table.
--------------------------------------------------------*/
{
	using namespace ProgressData;
	int iScriptEvents;
	fCancel = fFalse;
	IMsiRecord* piErrRec = GetScriptCost(0, &iScriptEvents, fFalse, &fCancel);
	if (piErrRec)
		return piErrRec;

	if (fCancel)
		return 0;

	if (!m_pScriptProgressRec)
		m_pScriptProgressRec = &m_riServices.CreateRecord(ProgressData::imdNextEnum);

	AssertNonZero(m_pScriptProgressRec->SetInteger(imdSubclass, iscMasterReset));
	AssertNonZero(m_pScriptProgressRec->SetInteger(imdProgressTotal, iScriptEvents));
	AssertNonZero(m_pScriptProgressRec->SetInteger(imdDirection, ipdForward));
	AssertNonZero(m_pScriptProgressRec->SetInteger(imdEventType, ietScriptInProgress));
	if(Message(imtProgress, *m_pScriptProgressRec) == imsCancel)
	{
		fCancel = fTrue;
		return 0;
	}


	m_fForegroundCostingInProgress = true;
	if ((piErrRec = InitializeDynamicCost(/* fReinitialize = */ fTrue)) != 0)
	{
		m_fForegroundCostingInProgress = false;
		// If Selection mgr not active, there's simply no costing to do
		if (piErrRec->GetInteger(1) != idbgSelMgrNotInitialized)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	MsiString strNull;
	while (!m_fCostingComplete)
	{
		if ((piErrRec = CostOneComponent(*strNull)) != 0)
		{
			m_fForegroundCostingInProgress = false;
			return piErrRec;
		}

		AssertNonZero(m_pScriptProgressRec->SetInteger(imdSubclass, iscProgressReport));
		AssertNonZero(m_pScriptProgressRec->SetInteger(imdIncrement, iComponentCostWeight));
		if(Message(imtProgress, *m_pScriptProgressRec) == imsCancel)
		{
			m_fForegroundCostingInProgress = false;
			fCancel = fTrue;
			return 0;
		}
	}
	m_fForegroundCostingInProgress = false;
	return 0;

}

IMsiRecord* CMsiEngine::CostOneComponent(const IMsiString& riComponentString)
/*-------------------------------------------------------------------------
If riComponentString is a null string, and CostOneComponent has not
been called since the last call to InitializeDynamicCost, a call to
CostOneComponent will calculate the disk cost for the first component
in the Component table.  On subsequent calls (with riComponentString still
a null string), the next component in the table will be costed, and so on.
If riComponentString names a specific component, that component will be
costed (if it hasn't already been initialized).  If all components have
been initialized, any subsequent call to CostOneComponent will return
immmediately with no error.

Returns: error record if InitializeDynamicCost has never been called, or
if the specified component is not found in the Component table.
---------------------------------------------------------------------------*/

{
	if (m_fCostingComplete == fTrue)
		return 0;

	if (!m_pCostingCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Bool fNamedComponent = fFalse;
	if (riComponentString.TextSize() > 0)
	{
		fNamedComponent = fTrue;
		m_pCostingCursor->Reset();
		m_pCostingCursor->SetFilter(1);
		m_pCostingCursor->PutString(m_colComponentKey,riComponentString);
	}

	Bool fFoundOne = fFalse;
	IMsiRecord* piErrRec = 0;
	while (fFoundOne == fFalse)
	{
		if (m_pCostingCursor->Next())
		{
			if (m_fReinitializeComponentCost || m_pCostingCursor->GetInteger(m_colComponentLocalCost) == iMsiNullInteger)
			{
				fFoundOne = fTrue;
				// Initialize dynamic cost to 0 for each component
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentLocalCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentSourceCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentRemoveCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentARPLocalCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbLocalCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbRemoveCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbSourceCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbARPLocalCost,0));
				AssertNonZero(m_pCostingCursor->Update());

				if ((piErrRec = RecostComponentDirectoryChange(m_pCostingCursor,0, /*fCostLinked = */false)) != 0)
					return piErrRec;
			}

			if (fNamedComponent)
			{
				m_pCostingCursor->Reset();
				m_pCostingCursor->SetFilter(0);
			}

		}
		else
		{
			if (fNamedComponent)
				return PostError(Imsg(idbgBadComponent), riComponentString.GetString());
			else
			{
				ResetEngineCosts();
				SetCostingComplete(fTrue);
				
				if ((piErrRec = DetermineEngineCostOODS()) != 0)
					return piErrRec;

				return 0;
			}
		}
	}
	return 0;
}



IMsiRecord* CMsiEngine::RegisterFeatureCostLinkedComponent(const IMsiString& riFeatureString,
													const IMsiString& riComponentString)
/*---------------------------------------------------------------------
Registers a component that must be recosted when a specified feature's
action state changes.
-----------------------------------------------------------------------*/
{
	if (m_piFeatureCostLinkTable == 0)
	{
		const int iInitialRows = 2;
		IMsiRecord* piErrRec = m_piDatabase->CreateTable(*MsiString(*sztblFeatureCostLink),iInitialRows,
			m_piFeatureCostLinkTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colFeatureCostLinkFeature = m_piFeatureCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblFeatureCostLink_colFeature)));
		AssertNonZero(m_colFeatureCostLinkComponent = m_piFeatureCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblFeatureCostLink_colComponent)));
	}

	PMsiCursor pCursor(0);
	AssertNonZero(pCursor = m_piFeatureCostLinkTable->CreateCursor(fFalse));
	pCursor->Reset();
	pCursor->SetFilter(iColumnBit(m_colFeatureCostLinkFeature) | iColumnBit(m_colFeatureCostLinkComponent));
	pCursor->PutString(m_colFeatureCostLinkFeature,riFeatureString);
	pCursor->PutString(m_colFeatureCostLinkComponent,riComponentString);
	if (!pCursor->Next())
	{
		pCursor->PutString(m_colFeatureCostLinkFeature,riFeatureString);
		pCursor->PutString(m_colFeatureCostLinkComponent,riComponentString);
		AssertNonZero(pCursor->Insert());
	}
	return 0;
}



IMsiRecord* CMsiEngine::RegisterCostLinkedComponent(const IMsiString& riComponentString,
													const IMsiString& riRecostComponentString)
/*-------------------------------------------------------------------------
Links the two specified components together, such that if riComponentString
needs to be dynamically recosted at any time, riRecostComponentString will
also be recosted.
--------------------------------------------------------------------------*/
{
	if (m_piCostLinkTable == 0)
	{
		const int iInitialRows = 2;
		IMsiRecord* piErrRec = m_piDatabase->CreateTable(*MsiString(*sztblCostLink),iInitialRows,m_piCostLinkTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colCostLinkComponent = m_piCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblCostLink_colComponent)));
		AssertNonZero(m_colCostLinkRecostComponent = m_piCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblCostLink_colRecostComponent)));
	}

	PMsiCursor pCursor(0);
	AssertNonZero(pCursor = m_piCostLinkTable->CreateCursor(fFalse));
	pCursor->Reset();
	pCursor->SetFilter(iColumnBit(m_colCostLinkComponent) | iColumnBit(m_colCostLinkRecostComponent));
	pCursor->PutString(m_colCostLinkComponent,riComponentString);
	pCursor->PutString(m_colCostLinkRecostComponent,riRecostComponentString);
	if (!pCursor->Next())
	{
		pCursor->PutString(m_colCostLinkComponent,riComponentString);
		pCursor->PutString(m_colCostLinkRecostComponent,riRecostComponentString);
		AssertNonZero(pCursor->Insert());
	}
	return 0;
}


IMsiRecord* CMsiEngine::RegisterComponentDirectory(const IMsiString& riComponentString,
												   const IMsiString& riDirectoryString)
{
	MsiStringId idComponentString, idDirectoryString;

	idComponentString = m_piDatabase->EncodeString(riComponentString);
	Assert(idComponentString);
	idDirectoryString = m_piDatabase->EncodeString(riDirectoryString);
	Assert(idDirectoryString);
	return RegisterComponentDirectoryId(idComponentString, idDirectoryString);

}

IMsiRecord* CMsiEngine::RegisterComponentDirectoryId(const MsiStringId idComponentString,
												   const MsiStringId idDirectoryString)
/*---------------------------------------------------------------------------
Registers a specified directory property with a specified component, ensuring
that if the path associated with the directory changes, the component will
be re-costed.  This is used for components that may write files, etc. to
locations other than the directory named in the Component table.
----------------------------------------------------------------------------*/
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (!m_piDirTable)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	int iParentLevel = 0;
	int iTreeLevel = 0;
	int iChildCount = 0;
	int iParentAttributes = 0;

	CreateSharedCursor(piComponentCursor, m_piComponentCursor);
	m_piComponentCursor->SetFilter(1);
	m_piComponentCursor->PutInteger(m_colComponentKey,idComponentString);
	while ((iTreeLevel = m_piComponentCursor->Next()) > iParentLevel)
	{
		if (iParentLevel == 0)
		{
			m_piComponentCursor->SetFilter(0);
			iParentLevel = iTreeLevel;
			iParentAttributes = m_piComponentCursor->GetInteger(m_colComponentAttributes);
		}
		else
			iChildCount++;

		if (idDirectoryString == m_piComponentCursor->GetInteger(m_colComponentDir))
			return 0; // Directory already registered, so we're done
	}

	MsiString strComponent(m_piDatabase->DecodeString(idComponentString));
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadComponent),*strComponent);

	// Create a child component tied to riComponentString - this child component
	// will maintain the linked directory cost. If the name we invent for the
	// child is already taken, keep trying until we find an unused name.
	int iMaxTries = 100;
	int iSuffix = iChildCount + 65;
	const int cchMaxComponentTemp=40;
	int cchT;
	do
	{
		// Max size is 2 chars for __, cchMaxComponentTemp and 11 chars for max
		// int and trailing null
		ICHAR rgch[2+cchMaxComponentTemp+11];

		StringCchCopy(rgch, ARRAY_ELEMENTS(rgch), TEXT("__"));
		memcpy(&rgch[2], (const ICHAR *)strComponent, (cchT = min(strComponent.TextSize(), cchMaxComponentTemp)) * sizeof(ICHAR));
		ltostr(&rgch[2 + cchT], iSuffix++);
		MsiString strSubcomponent(rgch);
		m_piComponentCursor->Reset();
		m_piComponentCursor->PutString(m_colComponentKey,*strSubcomponent);
		m_piComponentCursor->PutInteger(m_colComponentParent,idComponentString);
		m_piComponentCursor->PutInteger(m_colComponentDir,idDirectoryString);
		m_piComponentCursor->PutInteger(m_colComponentAttributes,iParentAttributes);
		m_piComponentCursor->PutInteger(m_colComponentLocalCost,  iMsiNullInteger);
		m_piComponentCursor->PutInteger(m_colComponentSourceCost, iMsiNullInteger);
		m_piComponentCursor->PutInteger(m_colComponentRemoveCost, iMsiNullInteger);
		m_piComponentCursor->PutInteger(m_colComponentARPLocalCost, iMsiNullInteger);
		// Temporary value in the component id, isn't used anywhere.
		// This would actually be an error to see this in a persistent database.
		m_piComponentCursor->PutString(m_colComponentID,*MsiString(*szTemporaryId));
		iMaxTries--;
	}while (m_piComponentCursor->InsertTemporary() == fFalse && iMaxTries > 0);
	if (iMaxTries == 0)
		return PostError(Imsg(idbgBadSubcomponentName),*strComponent);

	// Try to insert the given directory name into the directory table, if
	// it's not already there. If the Insert call fails, fine; it just means
	// we've already got this directory in the table.
	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));
	pDirCursor->PutInteger(m_colDirKey,idDirectoryString);
	pDirCursor->PutString(m_colDirParent,*MsiString(*IPROPNAME_TARGETDIR));
	pDirCursor->PutString(m_colDirSubPath,*MsiString(*TEXT("?"))); // We can check for the presence of this
																   // question mark later if a path for this
									   // directory never gets defined.
	pDirCursor->InsertTemporary();
	return 0;
}



IMsiRecord* CMsiEngine::RecostDirectory(const IMsiString& riDirectoryString, IMsiPath& riOldPath)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that updates the VolumeCost table based on a directory
that has changed from the path given in riOldPath.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;
	PMsiCursor pComponentCursor(0);
	AssertNonZero(pComponentCursor = m_piComponentTable->CreateCursor(fFalse));

	// Recost every component that references the given destination directory name
	pComponentCursor->SetFilter(iColumnBit(m_colComponentDir));
	pComponentCursor->PutString(m_colComponentDir,riDirectoryString);
	MsiStringId idTempId = m_piDatabase->EncodeStringSz(szTemporaryId);
	while (pComponentCursor->Next())
	{
		// Bug 7566: If costing is not yet complete, don't need to Recost, but we
		// still need to call SetComponent below
		if (m_fCostingComplete)
		{
#ifdef LOG_COSTING
			ICHAR rgch[300];
			MsiString strComponent(pComponentCursor->GetString(m_colComponentKey));
			ASSERT_IF_FAILED(StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch),
					TEXT("Recosting component: %s, due to change in directory: %s"),(const ICHAR*) strComponent,
					riDirectoryString.GetString()));
			DEBUGMSG(rgch);
#endif
			if ((piErrRec = RecostComponentDirectoryChange(pComponentCursor,&riOldPath, /*fCostLinked = */false)) != 0)
				return piErrRec;
		}

		// if selected to be installed locally, we need to reevaluate whether we should
		// be installing this component based on existing component version
		iisEnum iisRequestedAction = (iisEnum)pComponentCursor->GetInteger(m_colComponentActionRequest);
		if(iisRequestedAction == iisLocal)
		{
			// Bug 7200 - we don't want to re-evaluate our temporary costing subcomponents
			if (idTempId && pComponentCursor->GetInteger(m_colComponentID) != idTempId)
			{
				if ((piErrRec = SetComponent(pComponentCursor->GetInteger(m_colComponentKey), iisRequestedAction)) != 0)
					return piErrRec;
			}
		}

	}

	// No further recosting needed during initialization
	if (m_fCostingComplete == fFalse)
		return 0;

	// Finally, recost any components explicitly linked to the ones we just recosted.
	pComponentCursor->Reset();
	pComponentCursor->SetFilter(iColumnBit(m_colComponentDir));
	pComponentCursor->PutString(m_colComponentDir,riDirectoryString);
	while (pComponentCursor->Next())
	{
		if ((piErrRec = RecostLinkedComponents(*MsiString(pComponentCursor->GetString(m_colComponentKey)))) != 0)
			return piErrRec;
	}

	return 0;
}


IMsiRecord* CMsiEngine::RecostComponentDirectoryChange(IMsiCursor* piCursor, IMsiPath* piOldPath, bool fCostLinked)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that updates the dynamic cost of the component
referenced by the Component Table cursor given in piCursor.  This function should always
be called whenever the directory mapped to the component changes.  The path in piOldPath
represents the directory path as it existed BEFORE the change.  If the cost is being
initialized, pass piOldPath as NULL.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Assert(piCursor);
	IMsiRecord* piErrRec;

#ifdef DEBUG
	const ICHAR* szComponent = MsiString(piCursor->GetString(m_colComponentKey));
	const ICHAR* szDirectory = MsiString(piCursor->GetString(m_colComponentDir));
#endif
	// in the case of cost-linked components, we explicitly want to re-cost them
	// no matter what their current action state is.
	iisEnum iisAction = (iisEnum) piCursor->GetInteger(m_colComponentAction);
	if (iisAction == iMsiNullInteger && !fCostLinked)
		return 0;

	MsiString strDirectory(piCursor->GetString(m_colComponentDir));
	PMsiPath pDestPath(0);
	if ((piErrRec = GetTargetPath(*strDirectory,*&pDestPath)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
		{
			return piErrRec;
		}
	}


	// Get the current total cost...
	int iOldTotalCost, iOldNoRbTotalCost, iOldARPTotalCost, iOldNoRbARPTotalCost;
	if ((piErrRec = GetComponentCost(piCursor, iOldTotalCost, iOldNoRbTotalCost, iOldARPTotalCost, iOldNoRbARPTotalCost)) != 0)
		return piErrRec;

	// ...and if we've got a good oldPath pointer (i.e. this component has been
	// costed previously), remove old cost from the old destination's volume...
	if (piOldPath && (iOldTotalCost || iOldNoRbTotalCost || iOldARPTotalCost || iOldNoRbARPTotalCost))
	{
#ifdef LOG_COSTING
		ICHAR rgch[300];
		MsiString strDestPath(piOldPath->GetPath());
		MsiString strActualComponent(piCursor->GetString(m_colComponentKey));
		ASSERT_IF_FAILED(StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch),
				TEXT("Removing old cost: Component: %s, path: %s, Cost: %li"),(const ICHAR*) strActualComponent,
				(const ICHAR*) strDestPath,iOldTotalCost * 512));
		DEBUGMSG(rgch);
#endif
		if ((piErrRec = AddCostToVolumeTable(piOldPath, -iOldTotalCost, -iOldNoRbTotalCost, -iOldARPTotalCost, -iOldNoRbARPTotalCost)) != 0)
			return piErrRec;
	}


	// Subcomponents have dummy names derived from the parent - all files
	// and such are linked to parent components, so we must pass the
	// parent component name to GetDynamicCost.
	Bool fSubcomponent = fTrue;
	MsiString strComponent(piCursor->GetString(m_colComponentParent));
	if (strComponent.TextSize() == 0)
	{
		strComponent = piCursor->GetString(m_colComponentKey);
		fSubcomponent = fFalse;
	}

	// Calculate the new dynamic cost, and attribute to the component's volume.
	// But, if no one registered a CostAdjuster Object, then we've got nothing to do.
	int iLocalCost = 0;
	int iSourceCost = 0;
	int iRemoveCost = 0;
	int iARPLocalCost = 0;
	int iNoRbLocalCost = 0;
	int iNoRbRemoveCost = 0;
	int iNoRbSourceCost = 0;
	int iNoRbARPLocalCost = 0;
	if (m_piCostAdjusterTable)
	{
		// Otherwise, we'll send a GetDynamicCost message to each cost object
		PMsiCursor pCostCursor(m_piCostAdjusterTable->CreateCursor(fFalse));
		pCostCursor->Reset();
		while (pCostCursor->Next())
		{
			PMsiCostAdjuster pCostAdjuster = (IMsiCostAdjuster*) pCostCursor->GetMsiData(m_colCostAdjuster);
			if (pCostAdjuster)
			{
				MsiDisableTimeout();
				int iThisLocalCost,iThisNoRbLocalCost, iThisSourceCost,iThisRemoveCost,iThisNoRbRemoveCost,iThisNoRbSourceCost,iThisARPLocalCost,iThisNoRbARPLocalCost;
				piErrRec = pCostAdjuster->GetDynamicCost(*strComponent, *strDirectory,
																((GetMode() & iefCompileFilesInUse) ? fTrue : fFalse),
																iThisRemoveCost, iThisNoRbRemoveCost, iThisLocalCost,
																iThisNoRbLocalCost, iThisSourceCost, iThisNoRbSourceCost, iThisARPLocalCost, iThisNoRbARPLocalCost);
				MsiEnableTimeout();
				if (piErrRec)
					return piErrRec;

				iLocalCost += iThisLocalCost;
				iSourceCost += iThisSourceCost;
				iRemoveCost += iThisRemoveCost;
				iARPLocalCost += iThisARPLocalCost;
				iNoRbRemoveCost += iThisNoRbRemoveCost;
				iNoRbLocalCost += iThisNoRbLocalCost;
				iNoRbSourceCost += iThisNoRbSourceCost;
				iNoRbARPLocalCost += iThisNoRbARPLocalCost;
			}
		}
	}
	int iRuntimeFlags = piCursor->GetInteger(m_colComponentRuntimeFlags) | bfComponentCostInitialized;
	AssertNonZero(piCursor->PutInteger(m_colComponentRuntimeFlags,iRuntimeFlags));
	AssertNonZero(piCursor->PutInteger(m_colComponentLocalCost,iLocalCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentSourceCost,iSourceCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentRemoveCost,iRemoveCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentARPLocalCost,iARPLocalCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbLocalCost,iNoRbLocalCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbRemoveCost,iNoRbRemoveCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbSourceCost,iNoRbSourceCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbARPLocalCost,iNoRbARPLocalCost));
	AssertNonZero(piCursor->Update());

	// add to the new destination's volume
	int iNewTotalCost, iNewNoRbTotalCost, iNewARPTotalCost, iNewNoRbARPTotalCost;
	if ((piErrRec = GetComponentCost(piCursor,iNewTotalCost, iNewNoRbTotalCost, iNewARPTotalCost, iNewNoRbARPTotalCost)) != 0)
		return piErrRec;

	if (iNewTotalCost || iNewNoRbTotalCost || iNewARPTotalCost || iNewNoRbARPTotalCost)
	{
		if ((piErrRec = AddCostToVolumeTable(pDestPath, iNewTotalCost, iNewNoRbTotalCost, iNewARPTotalCost, iNewNoRbARPTotalCost)) != 0)
			return piErrRec;

#ifdef LOG_COSTING
		ICHAR rgch[300];
		MsiString strDestPath(pDestPath->GetPath());
		MsiString strActualComponent(piCursor->GetString(m_colComponentKey));
		ASSERT_IF_FAILED(StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch),
				TEXT("Adding cost: Component: %s, path: %s, Cost: %li, NoRbCost: %li"),(const ICHAR*) strActualComponent,
				(const ICHAR*) strDestPath,iNewTotalCost * 512, iNewNoRbTotalCost * 512);
		DEBUGMSG(rgch);
#endif
	}

	return 0;
}


IMsiRecord* CMsiEngine::RecostComponentActionChange(IMsiCursor* piCursor, iisEnum iisOldAction)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that updates the dynamic cost of the component
referenced by the Component Table cursor given in piCursor.  This function should always
be called whenever the directory mapped to the component changes, or when the component
state itself changes.  The path in piOldPath represents the directory path as it existed
BEFORE the change; if the component directory hasn't changed, piOldPath should contain
the current directory.
-----------------------------------------------------------------------------------------*/
{
	Assert(piCursor);
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;
	PMsiPath pDestPath(0);
	if ((piErrRec = GetTargetPath(*MsiString(piCursor->GetString(m_colComponentDir)),*&pDestPath)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
		{
			return piErrRec;
		}
	}

#ifdef DEBUG
	const ICHAR* szComponent = MsiString(piCursor->GetString(m_colComponentKey));
#endif

	// If the component has never been costed before, initialize its cost now, and we're done
	int iRuntimeFlags = piCursor->GetInteger(m_colComponentRuntimeFlags);
	if (!(iRuntimeFlags & bfComponentCostInitialized))
	{
		if ((piErrRec = RecostComponentDirectoryChange(piCursor,pDestPath,/*fCostLinked =*/false)) != 0)
			return piErrRec;
	}
	else
	{
		// Get the old cost, based on the old action state
		int iOldCost, iOldNoRbCost, iOldARPCost, iOldNoRbARPCost;
		if ((piErrRec = GetComponentActionCost(piCursor, iisOldAction, iOldCost, iOldNoRbCost, iOldARPCost, iOldNoRbARPCost)) != 0)
			return piErrRec;

		// ...Remove old cost from the our destination's volume...
		if (pDestPath && (iOldCost || iOldNoRbCost || iOldARPCost || iOldNoRbARPCost))
		{
			if ((piErrRec = AddCostToVolumeTable(pDestPath, -iOldCost, -iOldNoRbCost, -iOldARPCost, -iOldNoRbARPCost)) != 0)
				return piErrRec;
		}

		// ...and add the new cost, based on the new action state, back in.
		int iNewCost, iNewNoRbCost, iNewARPCost, iNewNoRbARPCost;
		if ((piErrRec = GetComponentCost(piCursor,iNewCost, iNewNoRbCost, iNewARPCost, iNewNoRbARPCost)) != 0)
			return piErrRec;

		if (pDestPath && (iNewCost || iNewNoRbCost || iNewARPCost || iNewNoRbARPCost))
		{
			if ((piErrRec = AddCostToVolumeTable(pDestPath, iNewCost, iNewNoRbCost, iNewARPCost, iNewNoRbARPCost)) != 0)
				return piErrRec;
		}
	}

	// Finally, recost any components explicitly linked to the one we just recosted.
	MsiString strComponent(piCursor->GetString(m_colComponentKey));
	if ((piErrRec = RecostLinkedComponents(*strComponent)) != 0)
		return piErrRec;

	return 0;
}


IMsiRecord* CMsiEngine::RecostLinkedComponents(const IMsiString& riComponentString)
/*----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// No recosting needed during initialization
	if (m_fCostingComplete == fFalse)
		return 0;

	// Recost every component that is explicitly linked to riComponentString
	if (m_piCostLinkTable)
	{
		PMsiCursor pCursor(0);
		AssertNonZero(pCursor = m_piCostLinkTable->CreateCursor(fFalse));
		pCursor->Reset();
		pCursor->SetFilter(iColumnBit(m_colCostLinkComponent));
		pCursor->PutString(m_colCostLinkComponent,riComponentString);
		while (pCursor->Next())
		{
#ifdef LOG_COSTING
			ICHAR rgch[300];
			MsiString strLinkedComponent(pCursor->GetString(m_colCostLinkRecostComponent));
			ASSERT_IF_FAILED(StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch),
					TEXT("Recosting component: %s, due to recosting of %s"),(const ICHAR*) strLinkedComponent,
					riComponentString.GetString()));
			DEBUGMSG(rgch);
#endif

			IMsiRecord* piErrRec;
			if ((piErrRec = RecostComponent(pCursor->GetInteger(m_colCostLinkRecostComponent),/*fCostLinked =*/true)) != 0)
				return piErrRec;
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::RecostComponent(const MsiStringId idComponentString, bool fCostLinked)
//---------------------------------------------
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;


	// Recost this component and all of it's subcomponents
	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutInteger(m_colComponentKey,idComponentString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponentString)));
	pCursor->SetFilter(0);
	int iTreeLevel;
	do
	{
		PMsiPath pDestPath(0);
		if ((piErrRec = GetTargetPath(*MsiString(pCursor->GetString(m_colComponentDir)),*&pDestPath)) != 0)
		{
			if ( piErrRec->GetInteger(1) == idbgDirPropertyUndefined )
				piErrRec->Release();
			else
				return piErrRec;
		}
		else if ((piErrRec = RecostComponentDirectoryChange(pCursor,pDestPath,fCostLinked)) != 0)
			return piErrRec;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	return 0;
}


IMsiRecord* CMsiEngine::RegisterCostAdjuster(IMsiCostAdjuster& riCostAdjuster)
//------------------------------------------
{
	IMsiRecord* piErrRec;
	if (m_piCostAdjusterTable == 0)
	{
		piErrRec = m_piDatabase->CreateTable(*MsiString(sztblCostAdjuster),5,m_piCostAdjusterTable);
		if (piErrRec)
			return piErrRec;

		m_colCostAdjuster = m_piCostAdjusterTable->CreateColumn(icdObject + icdPrimaryKey + icdNullable, g_MsiStringNull);
	}

	// !!We might want to see if riCostAdjuster is already in the CostAdjuster table, and throw
	// an error if so
	Assert(m_piCostAdjusterTable);
	PMsiCursor pCostCursor = m_piCostAdjusterTable->CreateCursor(fFalse);
	Assert(pCostCursor);
	pCostCursor->Reset();
	AssertNonZero(pCostCursor->PutMsiData(m_colCostAdjuster,&riCostAdjuster));
	AssertNonZero(pCostCursor->Insert());

	piErrRec = riCostAdjuster.Initialize();
	if (piErrRec)
		return piErrRec;
	return 0;
}


IMsiRecord* CMsiEngine::GetComponentCost(IMsiCursor* piCursor, int& iTotalCost, int& iNoRbTotalCost, int& iARPTotalCost, int& iNoRbARPTotalCost)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that returns the total cost attributable to the
specified component, based on the component's current action state.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Assert(piCursor);
	iisEnum iisAction = (iisEnum) piCursor->GetInteger(m_colComponentAction);
	return GetComponentActionCost(piCursor,iisAction,iTotalCost,iNoRbTotalCost,iARPTotalCost,iNoRbARPTotalCost);
}


IMsiRecord* CMsiEngine::GetComponentActionCost(IMsiCursor* piCursor, iisEnum iisAction, int& iActionCost, int& iNoRbActionCost, int& iARPActionCost, int& iNoRbARPActionCost)
/*--------------------------------------------------------------------------------
Internal SelectionManager function that returns the total cost attributable to the
specified component, based on the action specified in iisAction.  If iisAction
is specified as iisCurrent, the cost will be based on the component's current
action state.
----------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (iisAction == iisCurrent)
		iisAction = (iisEnum) piCursor->GetInteger(m_colComponentAction);

	Assert(piCursor);
	switch (iisAction)
	{
		case iisAbsent:
			iActionCost = piCursor->GetInteger(m_colComponentRemoveCost);
			iNoRbActionCost = piCursor->GetInteger(m_colComponentNoRbRemoveCost);
			iARPActionCost = iActionCost;
			iNoRbARPActionCost = iNoRbActionCost;
			break;
		case iisLocal:
			iActionCost = piCursor->GetInteger(m_colComponentLocalCost);
			iNoRbActionCost = piCursor->GetInteger(m_colComponentNoRbLocalCost);
			iARPActionCost = piCursor->GetInteger(m_colComponentARPLocalCost);
			iNoRbARPActionCost = piCursor->GetInteger(m_colComponentNoRbARPLocalCost);
			break;
		case iisSource:
			iActionCost = piCursor->GetInteger(m_colComponentSourceCost);
			iNoRbActionCost = piCursor->GetInteger(m_colComponentNoRbSourceCost);
			iARPActionCost = iActionCost;
			iNoRbARPActionCost = iNoRbActionCost;
			break;
		case iMsiNullInteger:
		default:
			iActionCost = 0;
			iNoRbActionCost = 0;
			iARPActionCost = 0;
			iNoRbARPActionCost = 0;
			break;
	}

	return 0;

}


IMsiRecord* CMsiEngine::GetTotalSubComponentActionCost(const IMsiString& riComponentString, iisEnum iisAction,
													   int& iTotalCost, int& iNoRbTotalCost)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that returns the total cost attributable to the
specified component, and all its children, based on the specified Action state.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colComponentKey,riComponentString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadComponent),riComponentString);
	pCursor->SetFilter(0);
	int iTreeLevel;
	iTotalCost = iNoRbTotalCost = 0;
	do
	{
		int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags);
		if (!m_fExclusiveComponentCost || !(iRuntimeFlags & bfComponentCostMarker))
		{
			int iCost, iNoRbCost, iARPCost, iNoRbARPCost;
			IMsiRecord* piErrRec = GetComponentActionCost(pCursor,iisAction,iCost, iNoRbCost, iARPCost, iNoRbARPCost);
			if (piErrRec)
				return piErrRec;
			iTotalCost += iCost;
			iNoRbTotalCost += iNoRbCost;
			iRuntimeFlags |= bfComponentCostMarker;
			AssertNonZero(pCursor->PutInteger(m_colComponentRuntimeFlags,iRuntimeFlags));
			AssertNonZero(pCursor->Update());
			
		}
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	
	return 0;

}


IMsiRecord* CMsiEngine::AddCostToVolumeTable(IMsiPath* piDestPath, int iCost, int iNoRbCost, int iARPCost, int iNoRbARPCost)
/*---------------------------------------------------------------------
Internal function that adds the cost specified in iCost to the volume
associated with the given path object.
-----------------------------------------------------------------------*/
{
	if (m_piVolumeCostTable == 0)
	{
		const int iInitialRows = 5;
		IMsiRecord* piErrRec = m_piDatabase->CreateTable(*MsiString(*sztblVolumeCost),iInitialRows,m_piVolumeCostTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colVolumeObject = m_piVolumeCostTable->CreateColumn(icdObject + icdNullable + icdPrimaryKey,*MsiString(*sztblVolumeCost_colVolumeObject)));
		AssertNonZero(m_colVolumeCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colVolumeCost)));
		AssertNonZero(m_colNoRbVolumeCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colNoRbVolumeCost)));
		AssertNonZero(m_colVolumeARPCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colVolumeARPCost)));
		AssertNonZero(m_colNoRbVolumeARPCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colNoRbVolumeARPCost)));
	}

	if (piDestPath)
	{
		PMsiVolume pVolume = &piDestPath->GetVolume();
		Assert(pVolume);
		PMsiCursor pVolCursor(m_piVolumeCostTable->CreateCursor(fFalse));
		Assert(pVolCursor);
		pVolCursor->Reset();
		pVolCursor->SetFilter(1);
		pVolCursor->PutMsiData(m_colVolumeObject, pVolume);
		if (!pVolCursor->Next())
		{
			AssertNonZero(pVolCursor->PutMsiData(m_colVolumeObject,pVolume));
			AssertNonZero(pVolCursor->PutInteger(m_colVolumeCost,0));
			AssertNonZero(pVolCursor->PutInteger(m_colNoRbVolumeCost, 0));
			AssertNonZero(pVolCursor->PutInteger(m_colVolumeARPCost,0));
			AssertNonZero(pVolCursor->PutInteger(m_colNoRbVolumeARPCost,0));
			AssertNonZero(pVolCursor->Insert());
		}
		int iAccumCost = pVolCursor->GetInteger(m_colVolumeCost) + iCost;
		pVolCursor->PutInteger(m_colVolumeCost,iAccumCost);
		int iAccumNoRbCost = pVolCursor->GetInteger(m_colNoRbVolumeCost) + iNoRbCost;
		pVolCursor->PutInteger(m_colNoRbVolumeCost,iAccumNoRbCost);
		int iAccumARPCost = pVolCursor->GetInteger(m_colVolumeARPCost) + iARPCost;
		pVolCursor->PutInteger(m_colVolumeARPCost,iAccumARPCost);
		int iAccumNoRbARPCost = pVolCursor->GetInteger(m_colNoRbVolumeARPCost) + iNoRbARPCost;
		pVolCursor->PutInteger(m_colNoRbVolumeARPCost,iAccumNoRbARPCost);
		AssertNonZero(pVolCursor->Update());
	}
	return 0;
}


int CMsiEngine::GetTotalCostAcrossVolumes(bool fRollbackCost, bool fARPCost)
/*---------------------------------------------------------------------
Internal function that returns the sum cost attributed to all volumes
in the VolumeCost table, in units of 512 bytes.  If fRollback cost is
TRUE, the cost assuming rollback is enabled will be returned.  If no
volumeCost table exists, or if the routine fails for any other reason,
zero is returned.
-----------------------------------------------------------------------*/
{
	int iTotalCost = 0;
	if (m_piVolumeCostTable)
	{
		PMsiCursor pVolCursor(m_piVolumeCostTable->CreateCursor(fFalse));
		Assert(pVolCursor);
		pVolCursor->Reset();
		int iColumn;
		if (fARPCost)
			iColumn = fRollbackCost ? m_colVolumeARPCost : m_colNoRbVolumeARPCost;
		else
			iColumn = fRollbackCost ? m_colVolumeCost : m_colNoRbVolumeCost;

		while (pVolCursor->Next())
		{
			iTotalCost += pVolCursor->GetInteger(iColumn);
		}
	}
	return iTotalCost;
}


void CMsiEngine::ResetEngineCosts()
{
	m_iDatabaseCost = 0;
	m_iScriptCost = 0;
	m_iScriptCostGuess = 0;
	m_iRollbackScriptCost = 0;
	m_iRollbackScriptCostGuess = 0;
	m_iPatchPackagesCost = 0;
}

static const ICHAR sqlFileScriptCost[] = TEXT("SELECT NULL FROM `File`,`Component` WHERE `Component`=`Component_` AND (`Action` = 0 OR `Action`= 1 OR `Action` = 2)");

static const ICHAR sqlRegScriptCost[] =
TEXT("SELECT NULL FROM `Registry`,`Component` WHERE `Component` = `Component_` AND (`Action` = 0 OR `Action`= 1 OR `Action` = 2)");

static const ICHAR sqlBindImageScriptCost[] =
TEXT("SELECT NULL FROM `BindImage`, `File`, `Component` WHERE `File` = `File_` AND `Component` = `Component_` AND (`Action`=0 OR `Action`= 1 OR `Action` = 2)");

static const ICHAR sqlRegisterProgIdScriptCost[] = TEXT("SELECT DISTINCT NULL FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlPublishComponentsScriptCost[]   = TEXT("SELECT NULL FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlPublishFeaturesScriptCost[] = TEXT("SELECT NULL FROM `Feature` WHERE ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlSelfRegScriptCost[] = TEXT("SELECT NULL FROM `SelfReg`, `File`, `Component`")
									TEXT(" WHERE `SelfReg`.`File_` = `File`.`File` And `File`.`Component_` = `Component`.`Component`")
									TEXT(" AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2 OR `Component`.`Action` = 0)");

static const ICHAR sqlRegisterComponentsScriptCost[] = TEXT("SELECT NULL FROM `Component` WHERE `Component_Parent` = NULL AND (`ActionRequest` = 0 OR `ActionRequest` = 1 OR `ActionRequest` = 2)");

static const ICHAR sqlRegisterExtensionInfoScriptCost[] = TEXT("SELECT NULL FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlRegisterFontsScriptCost[] = TEXT("SELECT NULL FROM `Font`, `File`, `Component` WHERE `Font`.`File_` = `File`.`File` And `File`.`Component_` = `Component`.`Component` AND (`Component`.`Action` = 0 OR `Component`.`Action` = 1 OR `Component`.`Action` = 2)");

static const ICHAR sqlCreateShortcutsScriptCost[] = TEXT("SELECT NULL FROM `Shortcut`, `Feature`, `Component`, `File`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND")
TEXT(" ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlRegisterClassInfo[] = TEXT("SELECT NULL FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlComponentCount[] = TEXT("SELECT NULL FROM `Component`");

struct ScriptCostQuery
{
	const ICHAR* szSQL;
	const ICHAR* szTable;
	int iCostPerRow;
	int iEventsPerRow;
};

const ICHAR szRegistryTable[]   = TEXT("Registry");
const ICHAR szBindImageTable[]  = TEXT("BindImage");
const ICHAR szProgIdTable[]    = TEXT("ProgId");
const ICHAR szPublishComponentTable[] = TEXT("PublishComponent");
const ICHAR szSelfRegTable[]    = TEXT("SelfReg");
const ICHAR szExtensionTable[]    = TEXT("Extension");
const ICHAR szFontTable[]    = TEXT("Font");
const ICHAR szShortcutTable[]    = TEXT("Shortcut");
const ICHAR szClassTable[]    = TEXT("Class");

const ScriptCostQuery g_rgScriptCostQuery[] =
{
	sqlFileScriptCost,                sztblFile,                                   75, 2,
	sqlRegScriptCost,                 sztblRegistry,                               64, 2,
	sqlBindImageScriptCost,           sztblBindImage,                      26, 1,
	sqlRegisterProgIdScriptCost,      sztblProgId,                        138, 1,
	sqlPublishComponentsScriptCost,   sztblPublishComponent,              200, 1,
	sqlPublishFeaturesScriptCost,     sztblFeature,                        82, 1,
	sqlSelfRegScriptCost,             sztblSelfReg,                                28, 1,
	sqlRegisterComponentsScriptCost,  sztblComponent,              85, 1,
	sqlRegisterExtensionInfoScriptCost, sztblExtension,           170, 1,
	sqlRegisterFontsScriptCost,       sztblFont,                           48, 1,
	sqlCreateShortcutsScriptCost,     sztblShortcut,                       75, 1,
	sqlRegisterClassInfo,             sztblClass,                                 208, 1,
	sqlComponentCount,                sztblComponent,                               0, iComponentCostWeight, // Counts only events for costing progress
};

const int g_cScriptCostQueries = sizeof(g_rgScriptCostQuery)/sizeof(ScriptCostQuery);

IMsiRecord* CMsiEngine::GetScriptCost(int* piScriptCost, int* piScriptEvents, Bool fExact, Bool* pfUserCancelled)
//-----------------------------------
{
	Assert(!pfUserCancelled || !*pfUserCancelled);
	if (piScriptCost)
		*piScriptCost = 0;
	else if (piScriptEvents && !fExact && m_iScriptEvents != 0 && piScriptCost == 0)
	{
		*piScriptEvents = m_iScriptEvents;
		return 0;
	}
	
	if (piScriptEvents) *piScriptEvents = 0;

	if (fExact)
	{
		m_iScriptEvents = 0;
		PMsiView pView(0);
		IMsiRecord* piErrRec;
		for (int x = 0; x < g_cScriptCostQueries;x++)
		{
			if(pfUserCancelled && ActionProgress() == imsCancel)
			{
				*pfUserCancelled = fTrue;
				return 0;
			}
			
			piErrRec= OpenView(g_rgScriptCostQuery[x].szSQL, ivcFetch, *&pView);
			if (piErrRec)
			{
				if(piErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
				{
					piErrRec->Release();
					continue;
				}
				else
					return piErrRec;
			}

			if ((piErrRec = pView->Execute(0)) != 0)
				return piErrRec;

			long iRowCount;
			piErrRec = pView->GetRowCount(iRowCount);
			if (piErrRec)
				return piErrRec;
			if (piScriptCost) *piScriptCost += iRowCount * g_rgScriptCostQuery[x].iCostPerRow;
			m_iScriptEvents += iRowCount * g_rgScriptCostQuery[x].iEventsPerRow;
		}
		if (piScriptEvents) *piScriptEvents = m_iScriptEvents;
	}
	else
	{
		PMsiTable pTable(0);
		IMsiRecord* piErrRec;
		for (int x = 0; x < g_cScriptCostQueries;x++)
		{
			if(pfUserCancelled && ActionProgress() == imsCancel)
			{
				*pfUserCancelled = fTrue;
				return 0;
			}
			
			piErrRec = m_piDatabase->LoadTable(*MsiString(g_rgScriptCostQuery[x].szTable), 0, *&pTable);
			if (piErrRec)
			{
				if(piErrRec->GetInteger(1) == idbgDbTableUndefined)
				{
					piErrRec->Release();
					continue;
				}
				else
					return piErrRec;
			}

			long iRowCount;
			iRowCount = pTable->GetRowCount();
			if (piScriptCost) *piScriptCost += iRowCount * g_rgScriptCostQuery[x].iCostPerRow;
			if (piScriptEvents) *piScriptEvents += iRowCount * g_rgScriptCostQuery[x].iEventsPerRow;
		}
		

	}
	return 0;
}

IMsiRecord* CMsiEngine::EnumEngineCosts(int iIndex, Bool fRecalc, Bool fExact, Bool& fValidEnum,
										IMsiPath*& rpiPath, int& iCost, int& iNoRbCost, Bool* pfUserCancelled)
/*----------------------------------------------------------------
Internal function that allows the caller to enumerate through and
retrieve the set of disk cost requirements that are intrinsic to
the operation of the Engine.

- iIndex: 0-based index; the caller should increment this value on
  each call to EnumEngineCosts.

- fRecalc: If fTrue, EnumEngineCosts will recalculate and store
  the engine costs for the current index, based on current
  conditions.

- fExact: Passed to GetScriptCost, tells us if we need to be exact
  with our costing or not for the script

- fValidEnum: If returned as fTrue, the cost values, based on the
  current index, are valid.  The caller should continue to call
  EnumEngineCosts (incrementing iIndex each time) until fValidEnum
  is returned as fFalse.

- rpiPath: if fValidEnum is fTrue, a path object, representing the
  volume on which the cost should be incurred, will be returned.

- iCost: the disk cost (expressed as a multiple of 512 bytes). A
  negative number indicates disk space will be freed up.
- iNoRbCost: the disk cost, IF rollback were to be turned off.
----------------------------------------------------------------- */
 {
	fValidEnum = fFalse;

	if (iIndex == 0)  // Cached Database costs
	{
		// If advertising or substorage child install, no database caching
		if ((GetMode() & iefAdvertise) ||
			 *(const ICHAR*)MsiString(GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE)) == ':') // SubStorage
		{
			fValidEnum = fTrue;
			return 0;
		}
		
		MsiString strMsiDirectory = GetMsiDirectory();
		PMsiPath pMsiPath(0);
		IMsiRecord* piErrRec = m_riServices.CreatePath(strMsiDirectory, *&pMsiPath);
		if (piErrRec)
			return piErrRec;

		if (fRecalc)
		{
			MsiString strDatabasePath = GetPropertyFromSz(IPROPNAME_DATABASE);
			MsiString strDatabaseName = strDatabasePath.Extract(iseAfter, chDirSep);
			PMsiPath pDatabaseSourcePath(0);
			piErrRec = m_riServices.CreatePath(strDatabasePath, *&pDatabaseSourcePath);
			if (piErrRec)
				return piErrRec;

			piErrRec = pDatabaseSourcePath->ChopPiece(); // chop off database name
			if (piErrRec)
				return piErrRec;

			unsigned int uiDatabaseSize;
			piErrRec = pDatabaseSourcePath->FileSize(strDatabaseName, uiDatabaseSize);
			if (piErrRec)
				return piErrRec;

			unsigned int uiClusteredSize;
			if ((piErrRec = pMsiPath->ClusteredFileSize(uiDatabaseSize, uiClusteredSize)) != 0)
				return piErrRec;

			Bool fFeaturesInstalled = FFeaturesInstalled(*this);
			m_iDatabaseCost = 0;
			if (m_fMode & iefMaintenance && !fFeaturesInstalled)
				m_iDatabaseCost -= uiClusteredSize;
			if (!(m_fMode & iefMaintenance) && fFeaturesInstalled)
			{
				m_iDatabaseCost = uiClusteredSize;

				// If connected to the server, then a second, temporary, copy
				// of the MSI will be made before beginning the InstallExecuteSequence,
				// so we've got to account for that when running the UI sequence on
				// the client side.  However, since this copy will already have been
				// made once we execute the InstallExecuteSequence, we don't want to
				// account for it then.
				if (!FIsUpdatingProcess() && g_scServerContext == scClient)
					m_iDatabaseCost += uiClusteredSize;
			}
		}

		rpiPath = pMsiPath;
		rpiPath->AddRef();

		iCost = m_iDatabaseCost;
		iNoRbCost = iCost;
		fValidEnum = fTrue;
	}

	else if (iIndex == 1) // Script file cost estimate
	{
		// If EXECUTEMODE property is empty or set to "SCRIPT", we know we are
		// going to create an execute script.
		int iScriptCount = 0;
		Bool fCreateRollbackScript = fFalse;
		MsiString strExecuteMode(GetPropertyFromSz(IPROPNAME_EXECUTEMODE));
		if(strExecuteMode.TextSize() == 0 || (((const ICHAR*)strExecuteMode)[0] & 0xDF) == 'S')
		{
				iScriptCount++;
				fCreateRollbackScript = fTrue;
		}

		// In addition, if the SCRIPTFILE property is set, we are going to
		// create a user script.
		PMsiPath pScriptPath(0);
		MsiString strScriptPath = GetPropertyFromSz(IPROPNAME_SCRIPTFILE);
		if (strScriptPath.TextSize() == 0)
		{
		    strScriptPath = GetTempDirectory();
		}
		else
		{
			iScriptCount++;
		}

		if (iScriptCount)
		{
			IMsiRecord* piErrRec = m_riServices.CreatePath(strScriptPath, *&pScriptPath);
			if (piErrRec)
				return piErrRec;

			if (fRecalc)
			{
				m_iScriptCost = 0;
				m_iRollbackScriptCost = 0;
				if (!fExact && m_iScriptCostGuess != 0)
				{
					// If we already have a guess, we don't need to recalc no matter what
					fRecalc = fFalse;
				}
			}
			else if (fExact && m_iScriptCost == 0)
			{
				// If we're being exact but we don't have an exact number, need to recalc it
				fRecalc = fTrue;
			}
				
			if (fRecalc)
			{
				int iScriptCost = 0;
				int iScriptCostFinal = 0;
				int iRollbackScriptCostFinal = 0;
				
				piErrRec = GetScriptCost(&iScriptCost, 0, fExact, pfUserCancelled);
				if (piErrRec)
					return piErrRec;
				if (pfUserCancelled && *pfUserCancelled)
					return 0;

				iScriptCost += 325;         // Standard Script overhead: ixoHead, ixoProductInfo, ixoRollbackInfo, ixoEnd
				iScriptCost += 40 * 45; // ixoActionStart, ixoProgressTotal per script action
				iScriptCost += 1700 + 60 + 285;    // PublishProduct, UserRegister, RegisterProduct
				iScriptCost += (iScriptCost * 15) / 100;    // Small-time actions
				unsigned int uiClusteredSize;
				if ((piErrRec = pScriptPath->ClusteredFileSize(iScriptCost, uiClusteredSize)) != 0)
					return piErrRec;
				iScriptCostFinal = uiClusteredSize * iScriptCount;

				if (fCreateRollbackScript)
				{
					iScriptCost += iScriptCost / 2;  // Rollback script about 50% larger than install script
					if ((piErrRec = pScriptPath->ClusteredFileSize(iScriptCost, uiClusteredSize)) != 0)
						return piErrRec;
					iRollbackScriptCostFinal = uiClusteredSize;
				}
				if (!fExact)
				{
					m_iScriptCostGuess = iScriptCostFinal;
					m_iRollbackScriptCostGuess = iRollbackScriptCostFinal;
				}
				else
				{
					m_iScriptCost = iScriptCostFinal;
					m_iRollbackScriptCost = iRollbackScriptCostFinal;
				}
			}
			rpiPath = pScriptPath;
			rpiPath->AddRef();
		}
		if (!fExact)
		{
			iCost = m_iScriptCostGuess + m_iRollbackScriptCostGuess;
			iNoRbCost = m_iScriptCostGuess;
		}
		else
		{
			iCost = m_iScriptCost + m_iRollbackScriptCost;
			iNoRbCost = m_iScriptCost;
		}
		fValidEnum = fTrue;
	}
	else if (iIndex == 2) // Cached patch package costs
	{
		// patch packages cached in "msi" directory

		// during install or any configuration:
		//    1) any patches with TempCopy set are to be copied (path is TempCopy)
		//    2) any patches with Unregister set (and no other clients) are to be removed (path retrieved with MsiGetPatchInfo)

		// during uninstall, all patches (with no other clients) are to be removed (path retrieved with MsiGetPatchInfo)
		
		// TODO: cost patch removal - currently only patch caching is costed
			
		MsiString strMsiDirectory = GetMsiDirectory();
		PMsiPath pMsiPath(0);
		IMsiRecord* piErrRec = m_riServices.CreatePath(strMsiDirectory, *&pMsiPath);
		if (piErrRec)
			return piErrRec;

		if(fRecalc)
		{
			m_iPatchPackagesCost = 0;

			bool fUninstall = (!FFeaturesInstalled(*this));


			if(fUninstall == false)
			{
				const ICHAR sqlRegisterPatchPackages[] = TEXT("SELECT `TempCopy` FROM `#_PatchCache` ORDER BY `Sequence`");
				enum icppEnum
				{
					icppTempCopy = 1,
				};

				PMsiView pView(0);
				PMsiRecord pFetchRecord(0);

				m_iPatchPackagesCost = 0;
				
				if((piErrRec = OpenView(sqlRegisterPatchPackages, ivcFetch, *&pView)) == 0 &&
					(piErrRec = pView->Execute(0)) == 0)
				{
					while((pFetchRecord = pView->Fetch()) != 0)
					{
						MsiString strPatchPackage = pFetchRecord->GetMsiString(icppTempCopy);

						// path is to patch package that will be copied into the cache
						if(strPatchPackage.TextSize())
						{
							PMsiPath pPatchSourcePath(0);
							MsiString strPatchName;
							piErrRec = m_riServices.CreateFilePath(strPatchPackage, *&pPatchSourcePath, *&strPatchName);
							if (piErrRec)
								return piErrRec;

							unsigned int uiPatchSize;
							piErrRec = pPatchSourcePath->FileSize(strPatchName, uiPatchSize);
							if (piErrRec)
								return piErrRec;

							unsigned int uiClusteredSize;
							if ((piErrRec = pMsiPath->ClusteredFileSize(uiPatchSize, uiClusteredSize)) != 0)
								return piErrRec;
							
							m_iPatchPackagesCost += uiClusteredSize;
						}
					}
				}
				else if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
					return piErrRec;
				else
				{
					piErrRec->Release();
					piErrRec = 0;
				}

			}
			// else uninstalling // TODO: cost for uninstall
		}

		rpiPath = pMsiPath;
		rpiPath->AddRef();

		iCost = m_iPatchPackagesCost;
		iNoRbCost = iCost;
		fValidEnum = fTrue;
	}

	return 0;
}


IMsiRecord* CMsiEngine::DetermineEngineCost(int* piNetCost, int* piNetNoRbCost)
/*----------------------------------------------------------------
Internal function that allows the Engine itself to add any extra
disk costs to the VolumeCostTable.  The total costs are returned
in the piNetCost and piNetNoRbCost parameters, either of which
can be passed as NULL if the caller doesn't need those numbers.
-----------------------------------------------------------------*/
{
	PMsiPath pCostPath(0);
	int iIndex = 0;
	Bool fValidEnum = fFalse;
	if (piNetCost) *piNetCost = 0;
	if (piNetNoRbCost) *piNetNoRbCost = 0;
	do
	{
		for (int x = 0;x < 2;x++)
		{
			// Two passes - one to remove the old costs, another to
			// add back the newly calculated cost.
			Bool fRecalc = x & 1 ? fTrue : fFalse;
			int iCostSign = fRecalc ? 1 : -1;
			int iCost = 0, iNoRbCost = 0;
			IMsiRecord* piErrRec = EnumEngineCosts(iIndex,fRecalc,fFalse,fValidEnum, *&pCostPath,iCost,iNoRbCost, NULL);
			if (piErrRec)
				return piErrRec;

			if (fValidEnum && (iCost != 0 || iNoRbCost != 0))
			{
				int iNetCost = iCostSign * iCost;
				int iNetNoRbCost = iCostSign * iNoRbCost;
				int iNetARPCost = iNetCost;
				int iNetARPNoRbCost = iNetNoRbCost;
				if (piNetCost && fRecalc) *piNetCost += iNetCost;
				if (piNetNoRbCost && fRecalc) *piNetNoRbCost += iNetNoRbCost;
				if ((piErrRec = AddCostToVolumeTable(pCostPath, iNetCost, iNetNoRbCost, iNetARPCost, iNetARPNoRbCost)) != 0)
					return piErrRec;
			}
		}
		iIndex++;
	}while (fValidEnum);
	return 0;
}


void CMsiEngine::EnableRollback(Bool fEnable)
{
	if(m_iioOptions & iioDisableRollback ||
		GetIntegerPolicyValue(szDisableRollbackValueName, fTrue) == 1 ||
		GetIntegerPolicyValue(szDisableRollbackValueName, fFalse) == 1 ||
		MsiString(GetPropertyFromSz(IPROPNAME_DISABLEROLLBACK)).TextSize())
	{
		fEnable = fFalse;
		Assert((GetMode() & iefRollbackEnabled) == 0);
	}


	// check if we are disabling rollback in the middle of script generation
	// (and it was enabled previously)
	if(fEnable == fFalse && (GetMode() & iefRollbackEnabled) && (GetMode() & iefOperations))
	{
		// probably called from DisableRollback action
		
		// if in the middle of script generation, we want rollback enabled for script execution
		// up to this point, but not after - so we need to put an opcode in the script to
		// mark when rollback is disabled
		PMsiRecord pNullRec = &CreateRecord(0);
		AssertNonZero(ExecuteRecord(ixoDisableRollback,*pNullRec) == iesSuccess);
		
		m_fDisabledRollbackInScript = fTrue; // set so RunScript knows to enable rollback for first part of script
	}

	
	// now actually set the flags
	SetMode(iefRollbackEnabled, fEnable);
	if (!fEnable)
		SetPropertyInt(*MsiString(*IPROPNAME_ROLLBACKDISABLED),1);
	else
		SetProperty(*MsiString(*IPROPNAME_ROLLBACKDISABLED), g_MsiStringNull);

}

//
// A version for those who want to determineEngineCost and don't care about the return value
//
IMsiRecord *CMsiEngine::DetermineEngineCostOODS()
{

	if (m_fCostingComplete)
	{
		IMsiRecord* piErrRec;
		
		if ((piErrRec = DetermineEngineCost(NULL, NULL)) != 0)
			return piErrRec;
	}

	DetermineOutOfDiskSpace(NULL, NULL);

	return 0;
}

Bool CMsiEngine::DetermineOutOfDiskSpace(Bool* pfOutOfNoRbDiskSpace, Bool* pfUserCancelled)
/*----------------------------------------------------------------------------
Walks through all the volumes in the VolumeCostTable, and returns fTrue (and
sets the "OutOfDiskSpace" and "OutOfNoRbDiskSpace" properties) if any volume
has insufficient space for the requirements placed on it.

Also, if all volumes have enough space assuming rollback were turned off,
fTrue will be returned in pfOutOfNoRbDiskSpace.  NULL can be passed for this
parameter.
------------------------------------------------------------------------------*/
{
	Bool fOutOfDiskSpace = fFalse;
	Bool fOutOfNoRbDiskSpace = fFalse;
	PMsiVolume pScriptVolume(0);

	Assert(!pfUserCancelled || !*pfUserCancelled);
	
	if (m_piVolumeCostTable && m_fCostingComplete)
	{
		// Make sure there's enough space currently available to
		// create the script file.  Note that we have to do this
		// up front, because even if we are uninstalling the entire
		// product, and thus eventually freeing up plenty of disk
		// space, we need room for to create the script before we
		// ever remove any files.
		PMsiPath pScriptPath(0);
		Bool fValidEnum;
		int iScriptCost, iNoRbScriptCost;

		// We'll possibly go through this loop twice. First time
		// we'll take a rough cut at the size of the script file.
		// the second time we'll get the exact number if the first time
		// showed we might be out of disk space
		int cCalc = 2;
		while (cCalc > 0)
		{
			// Reset these for second time through
			fOutOfDiskSpace = fFalse;
			fOutOfNoRbDiskSpace = fFalse;
			Bool fExact = ToBool(cCalc == 1);
			// And ask it to recalc if we're getting exact cost
			PMsiRecord pErrRec = EnumEngineCosts(1,fFalse,fExact,fValidEnum, *&pScriptPath,iScriptCost,iNoRbScriptCost, pfUserCancelled);
			if (pfUserCancelled && *pfUserCancelled)
				return fFalse;
			if (pScriptPath)
			{
				if (!(GetMode() & iefRollbackEnabled))
					iScriptCost = iNoRbScriptCost;

				pScriptVolume = &pScriptPath->GetVolume();
				UINT64 iFreeScriptSpace = pScriptVolume->FreeSpace();
				if (iScriptCost > iFreeScriptSpace)
				{
					fOutOfDiskSpace = fTrue;
				}

				if (iNoRbScriptCost >= iFreeScriptSpace)
				{
					fOutOfNoRbDiskSpace = fTrue;
				}
			}
			
			if (!fOutOfDiskSpace && !fOutOfNoRbDiskSpace)
				break;
			cCalc--;
		}
		
		PMsiVolume pPrimaryVolume(0);
		PMsiPath pPrimaryFolderPath(0);
		MsiString strPrimaryFolder = GetPropertyFromSz(IPROPNAME_PRIMARYFOLDER);
		PMsiRecord pErrRec = GetTargetPath(*strPrimaryFolder, *&pPrimaryFolderPath);
		if (!pErrRec)
		{
			pPrimaryVolume = &pPrimaryFolderPath->GetVolume();
		}

		if (!fOutOfDiskSpace || !fOutOfNoRbDiskSpace || pPrimaryVolume)
		{
			PMsiDatabase pDatabase(GetDatabase());
			PMsiCursor pVolCursor = m_piVolumeCostTable->CreateCursor(fFalse);
			Assert (pVolCursor);
			while (pVolCursor->Next())
			{
				PMsiVolume pVolume = (IMsiVolume*) pVolCursor->GetMsiData(m_colVolumeObject);
				Assert(pVolume);
				bool fAdjusted = false;
				int iVolCost = pVolCursor->GetInteger((GetMode() & iefRollbackEnabled) ? m_colVolumeCost : m_colNoRbVolumeCost);
				int iNoRbVolCost = pVolCursor->GetInteger(m_colNoRbVolumeCost);

				UINT64 iSpaceAvailable = 0;
				if (pVolume == pPrimaryVolume)
				{
					iSpaceAvailable = pVolume->FreeSpace();
					//!! FUTURE: SetPropertyInt64 and GetPropertyInt64 are needed
					ICHAR rgchBuffer[24]; // _UI64_MAX = 18,446,744,073,709,551,615
					SetProperty(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE),
									*MsiString(_ui64tot(iSpaceAvailable, rgchBuffer, 10)));
					SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED), iNoRbVolCost);
					SetProperty(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREMAINING),
									*MsiString(_ui64tot((iSpaceAvailable - iNoRbVolCost), rgchBuffer, 10)));
					SetProperty(*MsiString(*IPROPNAME_PRIMARYFOLDER_PATH),*MsiString(pVolume->GetPath()));
				}

				if (iVolCost > 0)
				{
					if (iSpaceAvailable == 0)
						iSpaceAvailable = pVolume->FreeSpace();
					if (iVolCost >= iSpaceAvailable)
					{
						if (!fOutOfDiskSpace && pVolume == pScriptVolume)
						{
							fAdjusted = AdjustForScriptGuess(iVolCost, iNoRbVolCost, iSpaceAvailable, pfUserCancelled);
							if (pfUserCancelled && *pfUserCancelled)
								return fFalse;
							if (iVolCost >= iSpaceAvailable)
								fOutOfDiskSpace = fTrue;
						}
						else
							fOutOfDiskSpace = fTrue;
					}
					if (iNoRbVolCost > 0 && iNoRbVolCost >= iSpaceAvailable)
					{
						if (!fOutOfNoRbDiskSpace && pVolume == pScriptVolume)
						{
							if (!fAdjusted)
							{
								AdjustForScriptGuess(iVolCost, iNoRbVolCost, iSpaceAvailable, pfUserCancelled);
								if (pfUserCancelled && *pfUserCancelled)
									return fFalse;
							}
							if (iNoRbVolCost >= iSpaceAvailable)
								fOutOfNoRbDiskSpace = fTrue;
						}
						else
							fOutOfNoRbDiskSpace = fTrue;
					}
				}
			}
		}
		SetPropertyInt(*MsiString(*IPROPNAME_OUTOFDISKSPACE),fOutOfDiskSpace);
		SetPropertyInt(*MsiString(*IPROPNAME_OUTOFNORBDISKSPACE),fOutOfNoRbDiskSpace);
	}

	if (pfOutOfNoRbDiskSpace)
		*pfOutOfNoRbDiskSpace = fOutOfNoRbDiskSpace;
	return fOutOfDiskSpace;
}


bool CMsiEngine::AdjustForScriptGuess(int& iVolCost, int &iNoRbVolCost, UINT64 iVolSpace, Bool* pfUserCancelled)
{
	PMsiPath pScriptPath(0);
	bool fRet = false;
	Assert(!pfUserCancelled || !*pfUserCancelled);
	// Not enough disk space on the Script Volume, and we didn't compute
	// exact number before, see if we can do better
	if (((iVolCost - m_iScriptCostGuess - m_iRollbackScriptCostGuess) <= iVolSpace) || (iNoRbVolCost - m_iScriptCostGuess <= iVolSpace))
	{
		Bool fValidEnum;
		int iScriptCost = 0, iNoRbScriptCost = 0;
		PMsiRecord pErrRec = EnumEngineCosts(1,fFalse,fTrue,fValidEnum, *&pScriptPath,iScriptCost,iNoRbScriptCost, pfUserCancelled);

		if (pfUserCancelled && *pfUserCancelled)
			return false;
		iVolCost = iVolCost + iScriptCost - m_iScriptCostGuess - m_iRollbackScriptCostGuess;
		iNoRbVolCost = iNoRbVolCost + iNoRbScriptCost - m_iScriptCostGuess;
		fRet = true;
	}
	
	return fRet;
}

void CMsiEngine::ResetComponentCostMarkers()
/*---------------------------------------------------------------------
Cost markers are used to mark components that have already been counted
during costing.  This is necessary because components can be shared
among Features, but the cost of a particular component needs to be
counted only once.
----------------------------------------------------------------------*/

{
	if (!m_piComponentTable)
		return;

	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fFalse));
	pCursor->SetFilter(0);
	while (pCursor->Next())
	{
		int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags) & ~bfComponentCostMarker;
		AssertNonZero(pCursor->PutInteger(m_colComponentRuntimeFlags,iRuntimeFlags));
		AssertNonZero(pCursor->Update());
	}
}

//
// Maximum number of columns from any one table
// used to set array sizes
//
#define ccolMax 6

const TTBD rgttbdRegistry[] =
{
	icdString + icdPrimaryKey, sztblRegistryAction_colRegistry,
	icdShort, sztblRegistryAction_colRoot,
	icdString, sztblRegistryAction_colKey,
	icdString + icdNullable, sztblRegistryAction_colName,
	icdString + icdNullable, sztblRegistryAction_colValue,
	icdString, sztblRegistryAction_colComponent,
	icdShort + icdNullable, sztblRegistryAction_colAction,
	icdShort + icdNullable, sztblRegistryAction_colActionRequest,
	icdShort, sztblComponent_colBinaryType,
	icdShort + icdNullable, sztblComponent_colAttributes,
};

const TTBD rgttbdFile[] =
{
	icdString + icdPrimaryKey, sztblFileAction_colFile,
	icdString, sztblFileAction_colFileName,
	icdLong + icdNullable, sztblFileAction_colState,
	icdLong + icdNullable, sztblFileAction_colFileSize,
	icdString, sztblFileAction_colComponent,
	icdString, sztblFileAction_colDirectory,
	icdLong + icdNullable, sztblFileAction_colInstalled,
	icdShort + icdNullable, sztblFileAction_colAction,
	icdLong + icdNullable, sztblComponent_colForceLocalFiles,
	icdString + icdNullable, sztblFileAction_colComponentId,
	icdShort, sztblComponent_colBinaryType,
};

IMsiRecord* CMsiEngine::CreateTempActionTable(ttblEnum ttblTable)
{
	IMsiRecord* piErr;
	IMsiTable** ppiTable;
	const ICHAR* pszTableName;
	const ICHAR* pszNewTableName;
	const TTBD* pttbd;
	int cttbd;
	int i;
	int colComponent, colComponentInComponent, colAction, colActionRequest, colRuntimeFlags;
	int rgcolTbl[ccolMax], rgcolComp[ccolMax];
	int cColTbl, cColComp;
	
	if (ttblTable == ttblRegistry)
	{
		// Temp table already created
		if (m_piRegistryActionTable != 0)
			return 0;

		ppiTable = &m_piRegistryActionTable;
		pszTableName = szRegistryTable;
		pszNewTableName = sztblRegistryAction;
		pttbd = rgttbdRegistry;
		cttbd = sizeof(rgttbdRegistry)/sizeof(TTBD);
	}
	else
	{
		Assert(ttblTable == ttblFile);
		if (m_piFileActionTable != 0)
			return 0;

		ppiTable = &m_piFileActionTable;
		pszTableName = sztblFile;
		pszNewTableName = sztblFileAction;
		
		pttbd = rgttbdFile;
		cttbd = sizeof(rgttbdFile)/sizeof(TTBD);
	}

	PMsiCursor pCursorNew(0);
	PMsiCursor pCursorOld(0);
	PMsiCursor pCursorComp(0);
	
	PMsiTable pTableOld(0);
	PMsiTable pTableComp(0);
	
	piErr = m_piDatabase->LoadTable(*MsiString(*pszTableName), 0, *&pTableOld);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			return 0; // missing table so no data to process
		}
		else
			return piErr;
	}
	
	//
	// Guess that half the rows will be in the new table
	//
	piErr = m_piDatabase->CreateTable(*MsiString(*pszNewTableName), pTableOld->GetRowCount()/2, *ppiTable);
	if (piErr)
		return piErr;

	for (i = 0 ; i < cttbd ; i++)
	{
		(*ppiTable)->CreateColumn(pttbd[i].icd, *MsiString(*(pttbd[i].szColName)));
	}
	
	pCursorNew = (*ppiTable)->CreateCursor(fFalse);
	pCursorOld = pTableOld->CreateCursor(fFalse);

	// Get the Component column in the old table
	colComponent = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFile_colComponent));
	piErr = m_piDatabase->LoadTable(*MsiString(*sztblComponent), 0, *&pTableComp);

	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			return 0; // missing table so no data to process
		}
		else
			return piErr;
	}
	
	pCursorComp = pTableComp->CreateCursor(fFalse);
	// Get the Component column in the component table
	colComponentInComponent = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colComponent));
	colAction = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAction));
	colActionRequest =      pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colActionRequest));
	colRuntimeFlags  = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colRuntimeFlags));
	// Now fill up the arrays with which columns we're interested in

	if (ttblTable == ttblRegistry)
	{
		// Get the Component column in the old table
		colComponent = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFile_colComponent));
		cColTbl = 6;
		rgcolTbl[0] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colRegistry));
		rgcolTbl[1] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colRoot));
		rgcolTbl[2] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colKey));
		rgcolTbl[3] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colName));
		rgcolTbl[4] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colValue));
		rgcolTbl[5] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colComponent));

		cColComp = 4;
		rgcolComp[0] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAction));
		rgcolComp[1] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colActionRequest));
		rgcolComp[2] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colBinaryType));
		rgcolComp[3] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAttributes));

	}
	else
	{
		cColTbl = 5;
		rgcolTbl[0] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colFile));
		rgcolTbl[1] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colFileName));
		rgcolTbl[2] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colState));
		rgcolTbl[3] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colFileSize));
		rgcolTbl[4] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colComponent));

		cColComp = 6;
		rgcolComp[0] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colDirectory));
		rgcolComp[1] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colInstalled));
		rgcolComp[2] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAction));
		rgcolComp[3] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colForceLocalFiles));
		rgcolComp[4] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colComponentId));
		rgcolComp[5] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colBinaryType));
	}

	int idComp;
	pCursorComp->SetFilter(iColumnBit(colComponentInComponent));
	
	while (pCursorOld->Next())
	{
		pCursorNew->Reset();
		idComp = pCursorOld->GetInteger(colComponent);
		pCursorComp->Reset();
		pCursorComp->PutInteger(colComponentInComponent, idComp);
		if (pCursorComp->Next())
		{
			// Skip all Null integer guys
			// NOTE: we are now also interested in the "guys" that were requested to be installed
			// but not actually selected for install, due to better component being around

			if (pCursorComp->GetInteger(colAction) == iMsiNullInteger &&
				(ttblTable != ttblRegistry || (pCursorComp->GetInteger(colRuntimeFlags) & bfComponentDisabled)|| pCursorComp->GetInteger(colActionRequest) == iMsiNullInteger))
				continue;
			int iColNew = 1;
			int id;
#ifdef DEBUG
			const ICHAR* pszTemp;
			pszTemp = (const ICHAR*)MsiString(pCursorOld->GetString(rgcolTbl[0]));
#endif
			// Move the items from the old table to the new table
			for (i = 0 ; i < cColTbl ; i++)
			{
				id = pCursorOld->GetInteger(rgcolTbl[i]);
				if (id != iMsiNullInteger)
					AssertNonZero(pCursorNew->PutInteger(iColNew, id));
				iColNew++;
			}
			// Move the items from the component table to the new table
			for (i = 0 ; i < cColComp ; i++)
			{
				id = pCursorComp->GetInteger(rgcolComp[i]);
				if (id != iMsiNullInteger)
					AssertNonZero(pCursorNew->PutInteger(iColNew, id));
				iColNew++;
			}
			
			AssertNonZero(pCursorNew->Insert());

		}
		else
			AssertSz(fFalse, "Component missing from component table.");
			
	}
	
	return 0;

}

IMsiRecord* CMsiEngine::GetFileHashInfo(const IMsiString& ristrFileKey, DWORD dwFileSize, MD5Hash& rhHash,
													 bool& fHashInfo)
// this function takes a record, with the file key in a designated field,
// and fills in the hash information for that file into the record in the indicated fields
{
	fHashInfo = false;
	
	if(m_fLookedForFileHashTable == false)
	{
		// haven't tried to open MsiFileHash table yet
		Assert(m_pFileHashCursor == 0);
		
		if(!m_piDatabase)
			return PostError(Imsg(idbgEngineNotInitialized));

		m_fLookedForFileHashTable = true;

		PMsiTable pFileHashTable(0);
		
		IMsiRecord* piError = m_piDatabase->LoadTable(*MsiString(sztblFileHash), 0, *&pFileHashTable);
		if (piError)
		{
			if(piError->GetInteger(1) == idbgDbTableUndefined)
			{
				// no table is fine
				piError->Release();
				return 0;
			}
			else
				return piError;
		}

		m_colFileHashKey     = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colFile));
		m_colFileHashOptions = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colOptions));
		m_colFileHashPart1   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart1));
		m_colFileHashPart2   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart2));
		m_colFileHashPart3   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart3));
		m_colFileHashPart4   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart4));

		if(!m_colFileHashKey || !m_colFileHashOptions || !m_colFileHashPart1 || !m_colFileHashPart2 || !m_colFileHashPart3 || !m_colFileHashPart4)
		{
			return PostError(Imsg(idbgTableDefinition), sztblFileHash);
		}

		m_pFileHashCursor = pFileHashTable->CreateCursor(fFalse);
		m_pFileHashCursor->SetFilter(iColumnBit(m_colFileHashKey));
	}
	
	if(!m_pFileHashCursor)
	{
		// no cursor means no table means nothing to do
		return 0;
	}

	m_pFileHashCursor->Reset();
	AssertNonZero(m_pFileHashCursor->PutString(m_colFileHashKey, ristrFileKey));

	if(m_pFileHashCursor->Next())
	{
		// first 4 bits of options defines the hash type.  currently only supported type is
		//    0: MD5 hash
		// ignore any other type
		
		DWORD dwOptions = m_pFileHashCursor->GetInteger(m_colFileHashOptions);
		if((dwOptions & 0xF) == 0)
		{
			rhHash.dwOptions  = dwOptions;
			rhHash.dwFileSize = dwFileSize;
			rhHash.dwPart1    = m_pFileHashCursor->GetInteger(m_colFileHashPart1);
			rhHash.dwPart2    = m_pFileHashCursor->GetInteger(m_colFileHashPart2);
			rhHash.dwPart3    = m_pFileHashCursor->GetInteger(m_colFileHashPart3);
			rhHash.dwPart4    = m_pFileHashCursor->GetInteger(m_colFileHashPart4);

			fHashInfo = true;
		}
	}
	// else, no record for this file

	return 0;
}

const IMsiString& CMsiEngine::GetErrorTableString(int iError)
{
	MsiString strRet;
	ICHAR szQuery[256];
	StringCchPrintf(szQuery, sizeof(szQuery)/sizeof(ICHAR),  TEXT("SELECT `Message` FROM `Error` WHERE `Error` = %i"), iError);
	PMsiView pView(0);
	PMsiRecord pRec(0);
	bool fLookupDLL = true;
	if ((pRec = OpenView(szQuery, ivcFetch, *&pView)) == 0 && (pRec = pView->Execute(0)) == 0)
	{
		if ((pRec = pView->Fetch()))
		{
			fLookupDLL = false;
			strRet = pRec->GetMsiString(1);
		}
	}

	if ( fLookupDLL )
	{
		//  the error hasn't been found in the table or it is an empty string.
		HMODULE hLib = WIN::LoadLibraryEx(MSI_MESSAGES_NAME, NULL,
													 LOAD_LIBRARY_AS_DATAFILE);
		if ( hLib )
		{
			WORD wLanguage = (WORD)GetPropertyInt(*MsiString(IPROPNAME_INSTALLLANGUAGE));
			bool fEndLoop = false;
			int iRetry = (wLanguage == 0) ? 1 : 0;
			LPCTSTR szError = (iError == 0) ? TEXT("0") : MAKEINTRESOURCE(iError);

			while ( !fEndLoop )
			{
				if ( !MsiSwitchLanguage(iRetry, wLanguage) )
				{
					fEndLoop = true;
					continue;
				}

				HRSRC   hRsrc;
				HGLOBAL hGlobal;
				CHAR* szText;

				if ( (hRsrc = FindResourceEx(hLib, RT_RCDATA, szError, wLanguage)) != 0
					  && (hGlobal = LoadResource(hLib, hRsrc)) != 0
					  && (szText = (CHAR*)LockResource(hGlobal)) != 0
					  && *szText != 0 )
				{
					CTempBuffer<ICHAR, MAX_PATH> szBuffer;
					int cch = 0;
#ifdef UNICODE
					unsigned int iCodePage = MsiGetCodepage(wLanguage);
					cch = WIN::MultiByteToWideChar(iCodePage, 0, szText, -1, 0, 0);
					if ( cch )
					{
						szBuffer.SetSize(cch);
						AssertNonZero(WIN::MultiByteToWideChar(iCodePage, 0, szText, -1,
																			szBuffer, cch));
					}
#else
					cch = lstrlen(szText);
					if ( cch )
					{
						szBuffer.SetSize(cch+1);
						ASSERT_IF_FAILED(StringCchCopy(szBuffer, szBuffer.GetSize(), szText));
					}
#endif // UNICODE
					if ( cch )
					{
						fEndLoop = true;
						strRet = (ICHAR*)szBuffer;
					}
				}       // if find & load resource

			}       // while ( !fEndLoop )
			AssertNonZero(WIN::FreeLibrary(hLib));

		}       // if ( hLib )
	}

	return strRet.Return();
}




const ICHAR szComponentFeatureTable[] = TEXT("CompFeatureTable");
//
// Creates a ComponentFeature table with the component as the first key
// to speed up searches
//
IMsiRecord* CMsiEngine::CreateComponentFeatureTable(IMsiTable*& rpiCompFeatureTable)
{
	IMsiRecord* piErr;
	PMsiTable pTable(0);

	piErr = m_piDatabase->LoadTable(*MsiString(*sztblFeatureComponents), 0, *&pTable);
	if (piErr)
		return piErr;

	piErr = m_piDatabase->CreateTable(*MsiString(*szComponentFeatureTable), pTable->GetRowCount(), rpiCompFeatureTable);
	if (piErr)
		return piErr;

	rpiCompFeatureTable->CreateColumn(icdString + icdPrimaryKey, *MsiString(*sztblFeatureComponents_colComponent));
	rpiCompFeatureTable->CreateColumn(icdString + icdPrimaryKey, *MsiString(*sztblFeatureComponents_colFeature));

	PMsiCursor pCursor = pTable->CreateCursor(fFalse);
	
	int colComponentInFC = pTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colComponent));
	int colFeatureInFC = pTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colFeature));

	PMsiCursor pCursorCF = rpiCompFeatureTable->CreateCursor(fFalse);
	
	while (pCursor->Next())
	{
		pCursorCF->Reset();
		AssertNonZero(pCursorCF->PutInteger(1, pCursor->GetInteger(colComponentInFC)));
		AssertNonZero(pCursorCF->PutInteger(2, pCursor->GetInteger(colFeatureInFC)));
		AssertNonZero(pCursorCF->Insert());
	}
	
	return 0;
	
}


////
// determines if it is safe for a managed install to be completely removed. If asking about a
// child install, this is the same as asking if this engine is managed. Otherwise, it has to
// be non-managed, an admin, not a full uninstall, or an upgrade by a managed install.
bool CMsiEngine::FSafeForFullUninstall(iremEnum iremUninstallType)
{
	switch (iremUninstallType)
	{
	case iremThis:
	{
		// figure out we have unlimited power (AlwaysInstallElevated policies are true)
		int iMachineElevate    = GetIntegerPolicyValue(szAlwaysElevateValueName, fTrue);
		int iUserElevate       = GetIntegerPolicyValue(szAlwaysElevateValueName, fFalse);
		// Admins can do anything they want, and creating an admin image or advertise script is not a problem
		if (!((iUserElevate == 1) && (iMachineElevate == 1)) && !IsAdmin() && (!(GetMode() & (iefAdmin | iefAdvertise))))
		{
			// if trying to completely remove a managed per-machine application
			if (m_fRunScriptElevated && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() && !FFeaturesInstalled(*this))
			{
				// upgrades can remove a managed app if the parent (new version) is also managed,
				// otherwise they cannot. Nested installs and upgrades can be completely 
				// removed as long as the parent is elevated. (Presumably the parent is capable 
				// of correctly managing the lifetime of the child.) 
				if (m_piParentEngine)
				{
					return m_piParentEngine->FSafeForFullUninstall((m_iioOptions & iioUpgrade) ? iremChildUpgrade : iremChildNested);
				}

				// no parent engine, fully removing managed app, non admin, so not safe
				return false;
			}
		}

		// admin, creating advertise script, not fully removing product, not managed, or per-user
		return true;
	}
	case iremChildUpgrade:
	case iremChildNested:
	{
		// upgrades of a managed install can be removed if the new install is managed and per-machine as well.
		return m_fRunScriptElevated && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize();
	}
	default:
		Assert(0);
		return false;
	}
}


IMsiRecord* GetServerPath(IMsiServices& riServices, bool fUNC, bool f64Bit, const IMsiString*& rpistrServerPath)
{
	IMsiRecord* piError = 0;
	ICHAR rgchPath[MAX_PATH + 50];
	Bool fFound = fFalse;
	PMsiPath pPath(0);
	MsiString strRegPath;
	MsiString strThisPath;
	MsiString strSystemPath;
	
	// 1st check our registry key if we're on Win64
	if (!g_fWin9X && g_fWinNT64)
	{
		CRegHandle riHandle;
		if (ERROR_SUCCESS == MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szSelfRefMsiExecRegKey, 0, KEY_READ | KEY_WOW64_64KEY, &riHandle))
		{
			DWORD dwSize = MAX_PATH;
			if (ERROR_SUCCESS == RegQueryValueEx(riHandle, f64Bit ? szMsiExec64ValueName : szMsiExec32ValueName, 0, NULL, (LPBYTE)rgchPath, &dwSize))
			{
				MsiString strFileName;
				if ((piError = riServices.CreateFilePath(rgchPath,*&pPath,*&strFileName)) != 0)
					return piError;

				if ((piError = pPath->FileExists(MSI_SERVER_NAME, fFound)) != 0)
					return piError;

				strRegPath = pPath->GetPath();
			}
		}
	}

	// next try our current location, but only if its the correct type
#ifdef _WIN64
	if (!fFound && f64Bit)
#else
	if (!fFound && !f64Bit)
#endif
	{
		DWORD cch = 0;
		if (0 != (cch = WIN::GetModuleFileName(g_hInstance, rgchPath, MAX_PATH)))
		{
			Assert(cch < MAX_PATH);
			MsiString strFileName;
			if ((piError = riServices.CreateFilePath(rgchPath,*&pPath,*&strFileName)) != 0)
				return piError;

			if ((piError = pPath->FileExists(MSI_SERVER_NAME, fFound)) != 0)
				return piError;

			strThisPath = pPath->GetPath();
		}
	}

	// last chance, check the system directory
	if(!fFound)
	{
		// look in system directory
		DWORD cch = 0;
        
        cch = MsiGetSystemDirectory(rgchPath, MAX_PATH, f64Bit ? FALSE : TRUE);
		Assert(cch && cch <= MAX_PATH);
		MsiString strFileName;
		if ((piError = riServices.CreatePath(rgchPath,*&pPath)) != 0)
			return piError;
		
		if ((piError = pPath->FileExists(MSI_SERVER_NAME, fFound)) != 0)
			return piError;
			
		strSystemPath = pPath->GetPath();
	}

	if(!fFound)
	{
		// error: can't find server
		piError = &riServices.CreateRecord(5);
		ISetErrorCode(piError, Imsg(idbgServerMissing));
		AssertNonZero(piError->SetString(2,MSI_SERVER_NAME));
		AssertNonZero(piError->SetMsiString(3,*strSystemPath)); // current directory
		AssertNonZero(piError->SetMsiString(4,*strThisPath));   // system directory
		AssertNonZero(piError->SetMsiString(5,*strRegPath));    // registered directory (Win64 only)
		return piError;
	}

	Assert(pPath);
	MsiString strServerPath;
	if(fUNC)
		piError = pPath->GetFullUNCFilePath(MSI_SERVER_NAME,*&strServerPath);
	else
		piError = pPath->GetFullFilePath(MSI_SERVER_NAME,*&strServerPath);

	if(piError)
		return piError;

	strServerPath.ReturnArg(rpistrServerPath);

	return 0;
}

// look for cabinets beginning with '#', cabinets are in streams in database
// op will remove those streams from file
void CreateCabinetStreamList(IMsiEngine& riEngine, const IMsiString*& rpistrStreamList)
{
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pMediaTable(0);
	PMsiRecord pRecErr(0);

	MsiString strStreams;
	int iColCabinet = 0;
	if((pRecErr = pDatabase->LoadTable(*MsiString(*TEXT("Media")),0,*&pMediaTable)) == 0 &&
		(iColCabinet = pMediaTable->GetColumnIndex(pDatabase->EncodeStringSz(TEXT("Cabinet")))) != 0)
	{
		PMsiCursor pCursor = pMediaTable->CreateCursor(fFalse);
		
		while(pCursor->Next())
		{
			MsiString strCabinet = pCursor->GetString(iColCabinet);
			if(strCabinet.Compare(iscStart,TEXT("#")))
			{
				strCabinet.Remove(iseFirst,1); // string '#'
				strStreams += strCabinet;
				strStreams += TEXT(";");
			}
		}
		strStreams.Remove(iseFrom, TEXT(';'));
	}

	strStreams.ReturnArg(rpistrStreamList);
}

void GetTempDirectory(CAPITempBufferRef<ICHAR>& rgchTempDir)
{
	Assert(g_scServerContext != scService); // if we want to make this callable from the service the GetMsiDirectory needs to stop using MsiStrings
	rgchTempDir[0] = 0;

	if (g_fWin9X)
	{
		// work around to Win9X behavior.  Bug #4036
		GetEnvironmentVariable(TEXT("TMP"),rgchTempDir);

		if(*rgchTempDir == 0)
			GetEnvironmentVariable(TEXT("TEMP"),rgchTempDir);
	}
	else
	{
		// on NT, GetTempPath is still the right thing to do.

// Apparently we're trying to hide GetTempPath behind
// a define in common.h to make sure that this function
// gets called instead.
#ifdef UNICODE
#define GetRealTempPath(X,Y) WIN::GetTempPathW(X,Y)
#else
#define GetRealTempPath(X,Y) WIN::GetTempPathA(X,Y)
#endif

		DWORD dwSize = rgchTempDir.GetSize();
		DWORD dwRet = GetRealTempPath(dwSize, (ICHAR*) rgchTempDir);
		
		if (dwRet > dwSize)
		{
			rgchTempDir.SetSize(dwRet);
			dwSize = dwRet;

			dwRet = GetRealTempPath(dwRet, (ICHAR*) rgchTempDir);
		}
		Assert(0 != dwRet);
	}
#undef GetRealTempPath

	bool fValidTemp = true;
	if (*rgchTempDir)
	{
		if (0xFFFFFFFF == MsiGetFileAttributes(rgchTempDir))
			fValidTemp = CreateDirectory(rgchTempDir, 0) ? true : false;
	}

	if(*rgchTempDir == 0 || !fValidTemp)
	{
		if(g_fWin9X)
		{
			MsiGetWindowsDirectory(rgchTempDir, rgchTempDir.GetSize());
		}
		else
		{
			GetEnvironmentVariable(TEXT("SystemDrive"),rgchTempDir);
		}

		Assert(*rgchTempDir);

		int cchLen = IStrLen(rgchTempDir);
		if(cchLen && rgchTempDir[cchLen-1] == '\\')
			rgchTempDir[cchLen-1] = 0;

		ASSERT_IF_FAILED(StringCchCat(rgchTempDir, rgchTempDir.GetSize(), TEXT("\\TEMP")));

		if (0xFFFFFFFF == MsiGetFileAttributes(rgchTempDir))
			AssertNonZero(CreateDirectory(rgchTempDir, 0));
	}
}

const IMsiString& GetTempDirectory()
{
	if (g_scServerContext == scService)
	{
		return GetMsiDirectory();
	}
	else
	{
		CAPITempBuffer<ICHAR, MAX_PATH> rgchTempDir;
		GetTempDirectory(rgchTempDir);

		MsiString strTempFolder = (const ICHAR*)rgchTempDir;
		return strTempFolder.Return();
	}
}

const IMsiString& GetMsiDirectory()
{
	ICHAR rgchPath[MAX_PATH] = {0};

#ifdef DEBUG
	if(GetTestFlag('C'))
	{
		GetEnvironmentVariable(TEXT("_MSICACHE"), rgchPath, MAX_PATH);
		return MsiString(rgchPath).Return();
	}
#endif //DEBUG

	if (!MsiGetWindowsDirectory(rgchPath, sizeof(rgchPath)/sizeof(ICHAR)))
	{
		AssertNonZero(StartImpersonating());
		AssertNonZero(MsiGetWindowsDirectory(rgchPath, sizeof(rgchPath)/sizeof(ICHAR)));
		StopImpersonating();
	}
	MsiString strMsiDir = rgchPath;
	if (!strMsiDir.Compare(iscEnd, TEXT("\\")))
		strMsiDir += TEXT("\\");

	strMsiDir += szMsiDirectory;
	return strMsiDir.Return();
}


iptEnum PathType(const ICHAR* szPath)
{
	if(!szPath || IStrLen(szPath) == 0)
		return iptInvalid;
	
	bool fFileUrl = false;
	if (IsURL(szPath, fFileUrl))
		return iptFull;

	if ((szPath[0] < 0x7f && szPath[1] == ':') || (szPath[0] == '\\' && szPath[1] == '\\'))
		return iptFull;

	return iptRelative;
}

#ifndef DEBUG
inline
#endif
static void EnsureSharedDllsKey(IMsiServices& riServices)
{

	if (0 == g_piSharedDllsRegKey)
	{
		PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibtCommon);
		g_piSharedDllsRegKey = &pLocalMachine->CreateChild(szSharedDlls);
	}
	if (g_fWinNT64 && 0 == g_piSharedDllsRegKey32)
	{
		PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibt32bit);
		g_piSharedDllsRegKey32 = &pLocalMachine->CreateChild(szSharedDlls);
	}
}

static IMsiRegKey* GetSharedDLLKey(IMsiServices& riServices,
											  ibtBinaryType iType)
{
	EnsureSharedDllsKey(riServices);
	IMsiRegKey* pSharedDllKey = 0;
	bool fAssigned = false;
	if ( g_fWinNT64 )
	{
		if ( iType == ibt64bit )
		{
			fAssigned = true;
			pSharedDllKey = g_piSharedDllsRegKey;
		}
		else if ( iType == ibt32bit )
		{
			fAssigned = true;
			pSharedDllKey = g_piSharedDllsRegKey32;
		}
	}
	else if ( iType == ibt32bit )
	{
		fAssigned = true;
		pSharedDllKey = g_piSharedDllsRegKey;
	}
	if ( fAssigned )
	{
		if ( pSharedDllKey )
			pSharedDllKey->AddRef();
		else
			AssertSz(0, TEXT("g_piSharedDllsRegKey hasn't been initialized!"));
	}
	else
		AssertSz(0, TEXT("GetSharedDLLKey called with invalid ibtBinaryType argument!"));

	return pSharedDllKey;
}

static const ICHAR* GetRightSharedDLLPath(ibtBinaryType iType,
														const ICHAR* szFullFilePath)
{
	static ICHAR rgchFullFilePath[MAX_PATH+1];
	// clear previously returned string
	*rgchFullFilePath = 0;
	if ( g_fWinNT64 && iType == ibt32bit )
	{
		ieSwappedFolder iRes = g_Win64DualFolders.SwapFolder(ie32to64,
																	szFullFilePath,
																	rgchFullFilePath,
																	ARRAY_ELEMENTS(rgchFullFilePath),
																	ieSwapForSharedDll);
		Assert(iRes != iesrError && iRes != iesrNotInitialized);
	}
	return *rgchFullFilePath ? rgchFullFilePath : szFullFilePath;
}

IMsiRecord* GetSharedDLLCount(IMsiServices& riServices,
										const ICHAR* szFullFilePath,
										ibtBinaryType iType,
										const IMsiString*& rpistrCount)
{
	PMsiRegKey pSharedDllKey = GetSharedDLLKey(riServices, iType);

	if ( pSharedDllKey )
	{
		const ICHAR* szPath = GetRightSharedDLLPath(iType, szFullFilePath);
		Assert(szPath);
		return pSharedDllKey->GetValue(szPath, *&rpistrCount);
	}

	return 0;
}

IMsiRecord* SetSharedDLLCount(IMsiServices& riServices,
										const ICHAR* szFullFilePath,
										ibtBinaryType iType,
										const IMsiString& ristrCount)
{
	PMsiRegKey pSharedDllKey = GetSharedDLLKey(riServices, iType);

	if ( pSharedDllKey )
	{
		const ICHAR* szPath = GetRightSharedDLLPath(iType, szFullFilePath);
		Assert(szPath);
		return pSharedDllKey->SetValue(szPath, ristrCount);
	}

	return 0;
}

//__________________________________________________________________________
//
// Global PostError routines
//
//   PostError:  create error record and report error to event log
//   PostRecord: create error record but don't report error to event log
//
//__________________________________________________________________________

IMsiRecord* PostError(IErrorCode iErr)
{
	IMsiRecord* piError = &CreateRecord(1);
	ISetErrorCode(piError, iErr);
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr, int i)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr));
	AssertNonZero(piError->SetInteger(3, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr, int i1, int i2)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr));
	AssertNonZero(piError->SetInteger(3, i1));
	AssertNonZero(piError->SetInteger(4, i2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i, const IMsiString& ristr1, const IMsiString& ristr2)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	AssertNonZero(piError->SetMsiString(3, ristr1));
	AssertNonZero(piError->SetMsiString(4, ristr2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz1));
	AssertNonZero(piError->SetString(3, sz2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2,
												 const ICHAR* sz3)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz1));
	AssertNonZero(piError->SetString(3, sz2));
	AssertNonZero(piError->SetString(4, sz3));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i, const ICHAR* sz)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	AssertNonZero(piError->SetString(3, sz));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz, int i)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz));
	AssertNonZero(piError->SetInteger(3, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, int i)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz1));
	AssertNonZero(piError->SetString(3, sz2));
	AssertNonZero(piError->SetInteger(4, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, int i, const ICHAR* sz3)
{
    IMsiRecord* piError = &CreateRecord(5);
    ISetErrorCode(piError, iErr);
    AssertNonZero(piError->SetString(2, sz1));
    AssertNonZero(piError->SetString(3, sz2));
    AssertNonZero(piError->SetInteger(4, i));
    AssertNonZero(piError->SetString(5, sz3));
    DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
    return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, int i, const ICHAR* sz2, const ICHAR* sz3, const ICHAR* sz4)
{
    IMsiRecord* piError = &CreateRecord(6);
    ISetErrorCode(piError, iErr);
    AssertNonZero(piError->SetString(2, sz1));
    AssertNonZero(piError->SetInteger(3, i));
    AssertNonZero(piError->SetString(4, sz2));
    AssertNonZero(piError->SetString(5, sz3));
    AssertNonZero(piError->SetString(6, sz4));
    DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
    return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, const ICHAR* sz3, const ICHAR* sz4, const ICHAR* sz5)
{
    IMsiRecord* piError = &CreateRecord(6);
    ISetErrorCode(piError, iErr);
    AssertNonZero(piError->SetString(2, sz1));
    AssertNonZero(piError->SetString(3, sz2));
    AssertNonZero(piError->SetString(4, sz3));
    AssertNonZero(piError->SetString(5, sz4));
    AssertNonZero(piError->SetString(6, sz5));
    DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
    return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 int i1)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetInteger(4, i1));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 int i1, int i2)
{
	IMsiRecord* piError = &CreateRecord(5);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetInteger(4, i1));
	AssertNonZero(piError->SetInteger(5, i2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 const IMsiString& ristr3, const IMsiString& ristr4)
{
	IMsiRecord* piError = &CreateRecord(5);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetMsiString(4, ristr3));
	AssertNonZero(piError->SetMsiString(5, ristr4));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 const IMsiString& ristr3)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetMsiString(4, ristr3));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i1, const ICHAR* sz1, int i2, const ICHAR* sz2,
							 const ICHAR* sz3)
{
	IMsiRecord* piError = &CreateRecord(6);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i1));
	AssertNonZero(piError->SetString(3, sz1));
	AssertNonZero(piError->SetInteger(4, i2));
	AssertNonZero(piError->SetString(5, sz2));
	AssertNonZero(piError->SetString(6, sz3));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

// PostRecord fns don't report to event log

IMsiRecord* PostRecord(IErrorCode iErr)
{
	IMsiRecord* piError = &CreateRecord(1);
	ISetErrorCode(piError, iErr);
	return piError;
}

IMsiRecord* PostRecord(IErrorCode iErr, int i)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	return piError;
}


// COMPAT CHECK FUNCTIONS

const int iInvalidDirectoryRootMaxSchema = 150; // only allow invalid Directory table root DefaultDir properties
                                                // for packages less then 150

bool CMsiEngine::FPerformAppcompatFix(iacsAppCompatShimFlags iacsFlag)
{
	if(iacsFlag == iacsAcceptInvalidDirectoryRootProps)
	{
		return ((m_iDatabaseVersion == iMsiStringBadInteger || m_iDatabaseVersion < iInvalidDirectoryRootMaxSchema) &&
			GetMode() & iefCabinet); // NOTE: this may be checking the sourcetype of the cached package, which is ok
	}
	else
	{
		return (m_iacsShimFlags & (int)iacsFlag) ? true : false;
	}
}


CMsiStringNullCopy MsiString::s_NullString;  // initialized by InitializeClass below


extern "C" int __stdcall ProxyDllMain(HINSTANCE hInst, DWORD fdwReason, void* pvreserved);
extern void GetVersionInfo(int* piMajorVersion, int* piMinorVersion, int* piWindowsBuild, bool* pfWin9X, bool* pfWinNT64);

REGSAM g_samRead;
void InitializeModule()
{
	ProxyDllMain(g_hInstance, DLL_PROCESS_ATTACH, 0);
	MsiString::InitializeClass(g_MsiStringNull);
	GetVersionInfo(&g_iMajorVersion, &g_iMinorVersion, &g_iWindowsBuild, &g_fWin9X, &g_fWinNT64);

	// initialize the global read sam for ability to read Win64 hive from win32 msi
	g_samRead = KEY_READ;
#ifndef _WIN64
	if(g_fWinNT64)
		g_samRead |= KEY_WOW64_64KEY;
#endif
}

extern CMsiAPIMessage       g_message;
extern EnumEntityList g_EnumProducts;
extern EnumEntityList g_EnumComponentQualifiers;
extern EnumEntityList g_EnumComponents;
extern EnumEntityList g_EnumComponentClients;
extern EnumEntityList g_EnumAssemblies;
extern EnumEntityList g_EnumComponentAllClients;
extern CRFSCachedSourceInfo g_RFSSourceCache;

void TerminateModule()
{
	AssertZero(CheckAllHandlesClosed(false, WIN::GetCurrentThreadId()));
	g_message.Destroy();

	g_EnumProducts.Destroy();
	g_EnumComponentQualifiers.Destroy();
	g_EnumComponents.Destroy();
	g_EnumComponentClients.Destroy();
	g_EnumAssemblies.Destroy();
	g_EnumComponentAllClients.Destroy();
	g_RFSSourceCache.Destroy();
	//
	// We allocate this TLS slot only once and then hold on to it as long
	// as we are loaded. So we need to free it here otherwise we end up
	// leaking TLS slots every time someone loads and unloads us. Over a 
	// period of time, it causes that process to run out of TLS slots and 
	// then we can end up in all sorts of trouble.
	//
	if (INVALID_TLS_SLOT != g_dwImpersonationSlot)
	{
		AssertNonZero(TlsFree(g_dwImpersonationSlot));
		g_dwImpersonationSlot = INVALID_TLS_SLOT;
	}
	ProxyDllMain(g_hInstance, DLL_PROCESS_DETACH, 0);
}

#if defined(TRACK_OBJECTS)
//____________________________________________________________________________
//
// Array of mappings for tracking objects
//____________________________________________________________________________

Bool CMsiRef<iidMsiConfigurationManager>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiServices>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiDatabase>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiCursor>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiTable>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiView>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiRecord>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiStream>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiStorage>::m_fTrackClass = fFalse;

#ifdef cmitObjects
extern const MIT rgmit[cmitObjects];

const MIT       rgmit[cmitObjects] =
{
	iidMsiConfigurationManager, &(CMsiRef<iidMsiConfigurationManager>::m_fTrackClass),
	iidMsiServices, &(CMsiRef<iidMsiServices>::m_fTrackClass),
	iidMsiDatabase, &(CMsiRef<iidMsiDatabase>::m_fTrackClass),
	iidMsiCursor,   &(CMsiRef<iidMsiCursor>::m_fTrackClass),
	iidMsiTable,    &(CMsiRef<iidMsiTable>::m_fTrackClass),
	iidMsiView,             &(CMsiRef<iidMsiView>::m_fTrackClass),
	iidMsiRecord,   &(CMsiRef<iidMsiRecord>::m_fTrackClass),
	iidMsiStream,           &(CMsiRef<iidMsiStream>::m_fTrackClass),
	iidMsiStorage,  &(CMsiRef<iidMsiStorage>::m_fTrackClass),
};
#endif // cmitObjects


#endif //TRACK_OBJECTS

void CWin64DualFolders::ClearArray()
{
	if ( m_prgFolderPairs )
	{
		delete [] m_prgFolderPairs;
		m_prgFolderPairs = NULL;
	}
}

bool CWin64DualFolders::CopyArray(const strFolderPairs* pArg)
{
	if ( pArg != m_prgFolderPairs )
	{
		ClearArray();
		if ( !pArg )
			return true;
		// counting the non-null elements in pArg
		for (int iCount = 0; 
			  pArg[iCount].str64bit.TextSize() && pArg[iCount].str32bit.TextSize();
			  iCount++)
			;
		Assert(iCount > 0);  // this is the way it was intended to work
		m_prgFolderPairs = new strFolderPairs[iCount+1];
		if ( !m_prgFolderPairs )
		{
			Assert(0);  // fairly impossible
			return false;
		}
		// copying the array
		for (int i = 0; i <= iCount; i++)
		{
			m_prgFolderPairs[i].str64bit = pArg[i].str64bit;
			m_prgFolderPairs[i].str32bit = pArg[i].str32bit;
			m_prgFolderPairs[i].iSwapAttrib = pArg[i].iSwapAttrib;
		}
	}
	return true;
}

CWin64DualFolders& CWin64DualFolders::operator = (const CWin64DualFolders& Arg)
{
	if ( this != &Arg )
	{
		CopyArray(Arg.m_prgFolderPairs);
		m_f32bitPackage = Arg.m_f32bitPackage;
		m_iRefCnt = Arg.m_iRefCnt;
	}
	return *this;
}

ieIsDualFolder CWin64DualFolders::IsWin64DualFolder(ieFolderSwapType iConvertFrom,
												const ICHAR* szCheckedFolder,
												int& iSwapAttrib,
												int* iCharsToSubstite,
												ICHAR* szToSubstituteWith,
												const size_t cchToSubstituteWith)
{
	if ( !m_prgFolderPairs )
		return ieisNotInitialized;
	else if ( !g_fWinNT64 )
		return ieisNotWin64DualFolder;

	const int iLen = IStrLen(szCheckedFolder);
	for (int iIndex = 0;
		  m_prgFolderPairs[iIndex].str64bit.TextSize() && m_prgFolderPairs[iIndex].str32bit.TextSize();
		  iIndex++ )
	{
		ICHAR* szToCheckAgainst;
		ICHAR* szToReplaceWith;
		int iToCheckLen;
		int iToReplaceLen;
		if ( iConvertFrom == ie32to64 )
		{
			szToCheckAgainst = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str32bit;
			iToCheckLen = m_prgFolderPairs[iIndex].str32bit.TextSize();
			szToReplaceWith = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str64bit;
			iToReplaceLen = m_prgFolderPairs[iIndex].str64bit.TextSize();
		}
		else
		{
			szToCheckAgainst = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str64bit;
			iToCheckLen = m_prgFolderPairs[iIndex].str64bit.TextSize();
			szToReplaceWith = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str32bit;
			iToReplaceLen = m_prgFolderPairs[iIndex].str32bit.TextSize();
		}
		int iLimit;
		bool fSkippedSep = false;
		if ( szToCheckAgainst[iToCheckLen-1] == chDirSep )
		{
			if ( iLen < iToCheckLen - 1 )
				// the folder passed in as an argument cannot be compared
				// with szToCheckAgainst since it's too short
				continue;
			else if ( iLen == iToCheckLen - 1 )
			{
				// szCheckedFolder doesn't extend up to szToCheckAgainst's
				// trailing chDirSep
				iLimit = iLen;
				fSkippedSep = true;
			}
			else
				iLimit = iToCheckLen;
		}
		else
		{
			// the array should be initialized from properties so
			// that we should never get here
			Assert(0);
			continue;
		}
		if ( !IStrNCompI(szToCheckAgainst, szCheckedFolder, iLimit) )
		{
			if ( szToSubstituteWith )
			{
				if ( FAILED(StringCchCopy(szToSubstituteWith, cchToSubstituteWith, szToReplaceWith)) )
					return ieisError;
				if ( fSkippedSep )
				{
					if ( szToSubstituteWith[iToReplaceLen-1] == chDirSep )
						szToSubstituteWith[iToReplaceLen-1] = 0;
				}
			}
			if ( iCharsToSubstite )
				*iCharsToSubstite = iLimit;
			iSwapAttrib = m_prgFolderPairs[iIndex].iSwapAttrib;
			return ieisWin64DualFolder;
		}
	}
	iSwapAttrib = ieSwapInvalid;
	return iIndex ? ieisNotWin64DualFolder : ieisNotInitialized;
}

ieSwappedFolder CWin64DualFolders::SwapFolder(ieFolderSwapType iConvertFrom,
												const ICHAR* szFolder,
												ICHAR* szSubstituted,
												const size_t cchSubstituted,
												int iSwapMask)
{
	CTempBuffer<ICHAR,1> rgchToSubstituteWith(MAX_PATH+1);
	rgchToSubstituteWith[0] = 0;
	int iToSubstituteLen = 0;
	int iSwapAttrib = ieSwapInvalid;
	ieIsDualFolder iRet = IsWin64DualFolder(iConvertFrom, szFolder, iSwapAttrib,
														 &iToSubstituteLen, rgchToSubstituteWith,
														 rgchToSubstituteWith.GetSize());
	if ( iRet == ieisNotWin64DualFolder )
		return iesrNotSwapped;
	else if ( iRet == ieisNotInitialized )
	{
		AssertSz(0, TEXT("Uninitialized CWin64DualFolders object!"));
		return iesrNotInitialized;
	}
	else if ( iRet == ieisError )
		return iesrError;
	else if ( iToSubstituteLen <= 0 )
	{
		Assert(0);
		return iesrError;
	}
	else if ( !*rgchToSubstituteWith )
	{
		Assert(0);
		return iesrError;
	}
	// OK, we've found what we want to substitute with, now we need
	// to figure out if the substitution is appropriate.
	bool fToSubstitute = false;
	if ( iSwapMask == ieSwapAlways )
		fToSubstitute = true;
	else
	{
		CTempBuffer<ICHAR,1> rgchBuffer(MAX_PATH+1);
		rgchBuffer[0]=0;
		bool fError = false;
		if ( !strFolderPairs::IsValidSwapAttrib(iSwapMask) )
		{
			StringCchPrintf(rgchBuffer, rgchBuffer.GetSize(), 
				TEXT("WIN64DUALFOLDERS: %d is an invalid mask argument!"),
				iSwapMask);
			AssertSz(0, rgchBuffer);
			DEBUGMSG(rgchBuffer);
			fError = true;
		}
		else if ( !strFolderPairs::IsValidSwapAttrib(iSwapAttrib) )
		{
			StringCchPrintf(rgchBuffer, rgchBuffer.GetSize(), 
				TEXT("WIN64DUALFOLDERS: %d is an invalid iSwapAttrib folder pair member!"),
				iSwapAttrib);
			AssertSz(0, rgchBuffer);
			DEBUGMSG(rgchBuffer);
			fError = true;
		}
		if ( fError )
			// there was some error setting the limitation, so that we do not set any.
			fToSubstitute = true;
		else
			fToSubstitute = (iSwapMask & iSwapAttrib) ? true : false;
	}
	if ( !fToSubstitute )
	{
		DEBUGMSG3(TEXT("WIN64DUALFOLDERS: Substitution in \'%s\' folder had ")
			TEXT("been blocked by the %d mask argument (the folder pair's iSwapAttrib ")
			TEXT("member = %d)."), szFolder, (const ICHAR*)(INT_PTR)iSwapMask,
			(const ICHAR*)(INT_PTR)iSwapAttrib);
		return iesrNotSwapped;
	}
	DEBUGMSG5(TEXT("WIN64DUALFOLDERS: \'%s\' will substitute %d characters ")
		TEXT("in \'%s\' folder path. (mask argument = %d, the folder pair's ")
		TEXT("iSwapAttrib member = %d)."), rgchToSubstituteWith,
		(const ICHAR*)(INT_PTR)iToSubstituteLen, szFolder,
		(const ICHAR*)(INT_PTR)iSwapMask, (const ICHAR*)(INT_PTR)iSwapAttrib);
	if ( FAILED(StringCchCopy(szSubstituted, cchSubstituted, rgchToSubstituteWith)) )
		return iesrError;
	if ( iToSubstituteLen < IStrLen(szFolder) &&
		  FAILED(StringCchCat(szSubstituted, cchSubstituted, szFolder+iToSubstituteLen)) )
		return iesrError;
	return iesrSwapped;
}

extern bool MakeFusionPath(const ICHAR* szFile, ICHAR* szFullPath, size_t cchFullPath);

// global fns to post assembly errors, in addition to posting error, this fn also logs the formatmessage string for the error

IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName)
{
	return PostAssemblyError(szComponentId, hResult, szInterface, szFunction, szAssemblyName, iatURTAssembly);
}

IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName, iatAssemblyType iatAT)
{
	HMODULE hLibmscorrc = 0;
	CTempBuffer<ICHAR,1> rgchFullPath(MAX_PATH+1);
	CTempBuffer<ICHAR,1> rgchMsgBuf(MAX_PATH);
	INT	  iMsgId = imsgAssemblyInstallationError;

	// first try the system, then, if not found and assembly is .net assembly, try mscorrc.dll
	if((WIN::FormatMessage(	FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_SYSTEM,
							0, 
							hResult, 
							0,
							rgchMsgBuf,
							rgchMsgBuf.GetSize(), 
							0)) ||
		(	iatAT == iatURTAssembly && 
			MakeFusionPath(TEXT("mscorrc.dll"), rgchFullPath, rgchFullPath.GetSize()) &&
			((hLibmscorrc = WIN::LoadLibraryEx(rgchFullPath, 0, LOAD_WITH_ALTERED_SEARCH_PATH | LOAD_LIBRARY_AS_DATAFILE)) != 0) &&
			WIN::LoadString(hLibmscorrc, HRESULT_CODE(hResult), rgchMsgBuf, rgchMsgBuf.GetSize())))

	{
		DEBUGMSG1(TEXT("Assembly Error:%s"), (const ICHAR*)rgchMsgBuf);
	}
	if(hLibmscorrc)
		WIN::FreeLibrary(hLibmscorrc);

	// Special cases: Windows Bug 502557
	// For certain Fusion error codes, MSI carries the error message, for better
	// language support, as MSI is WorldWide binary and Fusion is not.

	if(	(hResult == FUSION_E_PRIVATE_ASM_DISALLOWED) || 
		(hResult == HRESULT_FROM_WIN32(
						ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT)))
	{
		iMsgId = imsgAssemblyNotStronglyNamed;
	}
	else if((hResult == FUSION_E_SIGNATURE_CHECK_FAILED) || 
			(hResult == HRESULT_FROM_WIN32(
						ERROR_SXS_PROTECTION_CATALOG_NOT_VALID)))
	{
		iMsgId = imsgAssemblyNotSignedOrBadCatalog;
	}
	else if(hResult == FUSION_E_ASM_MODULE_MISSING)
	{
		iMsgId = imsgAssemblyMissingModule;
	}

	// Reusing szMsgBuf here
	StringCchPrintf(rgchMsgBuf, rgchMsgBuf.GetSize(), TEXT("0x%X"), hResult);
	return PostError(Imsg(iMsgId), szComponentId, rgchMsgBuf, szInterface, szFunction, szAssemblyName);
}

#ifdef _X86_
#if !defined(PROFILE)
// So we don't pull in some unnecessary floating point routines.
extern "C" int _fltused = 1;
#endif // !PROFILE

#endif

#include "clibs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\iconfig.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       iconfig.cpp
//
//--------------------------------------------------------------------------

/* iconfig.cpp - IMsiConfigurationManager implementaIon

Currently this is built into the MSIENG.DLL for the initial implementation.
However, this prevents multiple processes from accessing the config database.
Eventually this code should be implemented as a daemon application,
that can also process remote OLE commands.
____________________________________________________________________________*/


//!! FIX -- suppressLFN on path creations?

#include "precomp.h" 
#include "_assert.h"
#include "iconfig.h"
#include "vertrust.h"
//#include "msi.h"
#include "_msinst.h"
#include "_srcmgmt.h"
#include "_camgr.h"
#include <winnls.h> // GetLocaleInfo
#include "_engine.h"
#include "EventLog.h"
#include "aclapi.h"
#include "resource.h"

const GUID IID_IMsiConfigurationManager    = GUID_IID_IMsiConfigurationManager;
const GUID IID_IMsiConfigManagerAsServer   = GUID_IID_IMsiConfigManagerAsServer;
const GUID IID_IMsiServer                  = GUID_IID_IMsiServer;
#ifdef DEBUG
const GUID IID_IMsiConfigManagerDebug      = GUID_IID_IMsiConfigManagerDebug;
const GUID IID_IMsiConfigMgrAsServerDebug  = GUID_IID_IMsiConfigMgrAsServerDebug;
#endif

// standard guids defined in uuid.lib which we do not link to
const GUID IID_IGlobalInterfaceTable =     { 0x00000146, 0x0000, 0x0000, { 0xC0, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x46 } };
const GUID CLSID_StdGlobalInterfaceTable = { 0x00000323, 0x0000, 0x0000, { 0xC0, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x46 } };

// macro wrapper for IMsiRecord* errors
#define RETURN_ERROR_RECORD(function)\
                            {\
                                IMsiRecord* piError = function;    \
                                if(piError)                        \
                                    return piError;                 \
                            }


extern INSTALLSTATE GetComponentClientState(const ICHAR* szUserId, const ICHAR* szProductSQUID, const ICHAR* szComponentSQUID, CAPITempBufferRef<ICHAR>& rgchComponentRegValue, DWORD& dwValueType, iaaAppAssignment* piaaAsgnType);
extern INSTALLSTATE GetComponentPath(const ICHAR* szUserId, const ICHAR* szProductSQUID, const ICHAR* szComponentSQUID, ICHAR* lpPathBuf, DWORD *pcchBuf, bool fFromDescriptor, CRFSCachedSourceInfo& pCacheInfo, int iDetectMode, const ICHAR* rgchComponentRegValue, DWORD dwValueType, ICHAR* lpPathBuf2, DWORD* pcchBuf2, DWORD* pdwLastErrorOnFileDetect);
extern CRFSCachedSourceInfo g_RFSSourceCache;  
  
extern Bool ConstructNetSourceListEntry(IMsiPath& riPath, const IMsiString*& rpiDriveLetter, const IMsiString*& rpiUNC,
                                                     const IMsiString*& rpiRelativePath);

extern DWORD GetProductAssignmentType(const ICHAR* szProductSQUID, iaaAppAssignment& riType);

IMsiRecord* SetLastUsedSourceCore(IMsiServices& riServices,
                                             const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
                                             const IMsiString** ppiRawSource,
                                             const IMsiString** ppiIndex,
                                             const IMsiString** ppiType,
                                             const IMsiString** ppiSource,
                                             const IMsiString** ppiSourceListKey,
                                             const IMsiString** ppiSourceListSubKey,
                                             bool fVerificationOnly,
                                             bool fFirstInstall, 
                                             bool* pfSourceAllowed);

// this is the lifetime of the service after an install finishes, in 100ns increments.
// the initial timer value (on service start) is in module.h
const LONGLONG iServiceShutdownTime = ((LONGLONG)(10 * 60)  * (LONGLONG)(1000 * 1000 * 10));

//____________________________________________________________________________
//
// CMsiConfigurationManager definitions
//____________________________________________________________________________

class CMsiConfigurationManager : public IMsiConfigurationManager
{
 public:
    // IMsiConfigurationManager implemented virtual functions
    // order of function declarations is for clarity only, vtable order
    // is defined by IMsiConfigurationManager class.
    HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long   __stdcall AddRef();
    unsigned long   __stdcall Release();

    // -- Misc --
    IMsiServices&   __stdcall GetServices();
    iesEnum         __stdcall InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
    int             __stdcall DoInstall(ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
                                                    const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions, const DWORD dwPrivilegesMask);
    IMsiRecord*     __stdcall RegisterUser(const ICHAR* szProductCode, const ICHAR* szUserName,
                                                        const ICHAR* szCompany, const ICHAR* szProductID);
    boolean         __stdcall Reboot();
    void            __stdcall EnableReboot(boolean fRunScriptElevated, const IMsiString& ristrProductName, const IMsiString& ristrProductCode);
    IMsiRecord*     __stdcall RemoveRunOnceEntry(const ICHAR* szEntry);
    boolean         __stdcall CleanupTempPackages(IMsiMessage& riMessage, boolean fCheckServiceBusy);
    void            __stdcall SetShutdownTimer(HANDLE hTimer);
    boolean         __stdcall IsServiceInstalling() { return g_MessageContext.IsServiceInstalling(); }


    // -- CustomActionServer --
    CMsiCustomActionManager* __stdcall GetCustomActionManager();
    void            __stdcall CreateCustomActionManager(bool fRemapHKCU);
    UINT            __stdcall RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD* pdwPrivileges);
    UINT            __stdcall ShutdownCustomActionServer();
    IMsiCustomAction* __stdcall CreateCustomActionProxy(const icacCustomActionContext icacDesiredContext, const unsigned long dwProcessId, IMsiRemoteAPI *pRemoteApi, const WCHAR* pvEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *pcbCookie, HANDLE *hServerProcess, unsigned long *dwServerProcessId, bool fClientOwned, bool fRemapHKCU);
    UINT            __stdcall CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *dwServerProcessId);

    // -- SourceList API --
    UINT            __stdcall SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum istSource);
    UINT            __stdcall SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType, const ICHAR* szSource);
    UINT            __stdcall SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName);

	// -- Internal SourceList --
	IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch);
	IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
															  const IMsiString** ppiRawSource,
															  const IMsiString** ppiIndex,
															  const IMsiString** ppiType,
															  const IMsiString** ppiSource,
															  const IMsiString** ppiSourceListKey,
															  const IMsiString** ppiSourceListSubKey);
	// -- Scripts -- 
	iesEnum         __stdcall RunScript(const ICHAR* szScriptFile, IMsiMessage& riMessage,
													IMsiDirectoryManager* piDirectoryManager, boolean fRollbackEnabled);

    // -- Rollback --
    IMsiRecord*     __stdcall RegisterRollbackScript(const ICHAR* szScriptFile);
    IMsiRecord*     __stdcall UnregisterRollbackScript(const ICHAR* szScriptFile);
    IMsiRecord*     __stdcall GetRollbackScriptEnumerator(MsiDate date, Bool fAfter, IEnumMsiString*& rpiEnumScripts);
    IMsiRecord*     __stdcall DisableRollbackScripts(Bool fDisable);
    IMsiRecord*     __stdcall RollbackScriptsDisabled(Bool& rfDisabled);

    // -- Components --
    IMsiRecord*     __stdcall RegisterComponent(const IMsiString&, const IMsiString&, INSTALLSTATE, const IMsiString&, unsigned int, int)
	{
		//!! obselete
		Assert(0);
		return 0;
	}
    IMsiRecord*     __stdcall UnregisterComponent(  const IMsiString& , const IMsiString& )
	{
		//!! obselete
		Assert(0);
		return 0;
	}

    // -- Folders --
    IMsiRecord*     __stdcall RegisterFolder(IMsiPath& riPath, Bool fExplicitCreation);
    IMsiRecord*     __stdcall IsFolderRemovable(IMsiPath& riPath, Bool fExplicit, Bool& fRemovable);
    IMsiRecord*     __stdcall UnregisterFolder(IMsiPath& riPath);
#ifdef CONFIGDB

    // -- Files --
    icdrEnum       __stdcall RegisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId);
    icdrEnum       __stdcall UnregisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId);
#endif
    void           __stdcall ChangeServices(IMsiServices& riServices);

 public: // constructor/destructor
    void *operator new(size_t cb) { return AllocSpc(cb); }
    void operator delete(void * pv) { FreeSpc(pv); }
    CMsiConfigurationManager(IMsiServices& riServices);
 public: // helper functions for use by CEnumRemovableFolders and CMsiConfigurationManager
    static iesEnum InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
 protected: // IMsiConfigurationManager data
  ~CMsiConfigurationManager();  // protected to prevent creation on stack
    CMsiRef<iidMsiConfigurationManager>           m_Ref;
    IMsiServices* m_piServices;  // must release after destruction
#ifdef CONFIGDB
    IMsiConfigurationDatabase* m_piConfigurationDatabase;
#endif
    bool          m_fElevatedRebootAllowed;
	MsiString      m_strProductNeedingReboot;
    MsiString     m_strProductCodeNeedingReboot;
 private:

    // prevent warnings and copy
    void operator = (const CMsiConfigurationManager&){}
    boolean CleanupTempPackagesInternal(IMsiMessage& riMessage);

	// shutdown timer in service (owned by main service thread) to reactivate
	// on destruction.
	HANDLE                   m_hShutdownTimer;

    // manage the custom action manager for the service process
    CRITICAL_SECTION         m_csCAManager;
    IGlobalInterfaceTable*   m_piGIT;
    CMsiCustomActionManager* m_pCustomActionManager;

    // the service also acts as a registration system for all servers regardless
    // of client. Only one server can register at a time.
    HANDLE                   m_hCARegistered;
    CRITICAL_SECTION         m_csCreateProxy;

    // even within the restriction that only one action can be created at one time,
    // only one server can be trying to register at any one time. Otherwise our
    // security is weaker because two actions could register at once (last one
    // wins)
    CRITICAL_SECTION         m_csRegisterAction;

    // this information is what is needed to correctly recognize and register a
    // CA server
    struct {
        unsigned char            m_rgchWaitingCookie[iRemoteAPICookieSize];
        icacCustomActionContext  m_icacWaitingContext;
        IMsiCustomAction*        m_piCustomAction;
        DWORD                    m_dwProcessId;
        DWORD                    m_dwRemoteCookie;
        DWORD                    m_dwGITCookie;
		DWORD                    m_dwPrivileges;
		unsigned long            m_dwCAServerProcessId;
		bool                     m_fImpersonatedIsSystem;
    } m_CustomServerInfo;
        
};


//____________________________________________________________________________
//
// CEnumRollbackScripts definition
//____________________________________________________________________________

class CEnumRollbackScripts : public IEnumMsiString
{
 public:  // implemented virtuals
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    HRESULT __stdcall Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched);
    HRESULT __stdcall Skip(unsigned long cSkip);
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone(IEnumMsiString** ppiEnum);
 public:  // construct/destructor
    CEnumRollbackScripts(const MsiDate date,
                                const Bool fAfter,
                               IMsiServices& riServices);
    void* ConstructedOK() {return m_piEnum;}
 protected:
  ~CEnumRollbackScripts();  // protected to prevent creation on stack
    unsigned long   m_iRefCnt;
    Bool            m_fDone;
    Bool            m_fAfter;
    PMsiServices    m_pServices;
    PMsiRegKey      m_pRollbackKey;
    MsiDate         m_date;
    IEnumMsiString* m_piEnum;
};

//____________________________________________________________________________
//
// CMsiConfigurationManager implementation
//____________________________________________________________________________

// Global instance of configuration manager

CMsiConfigurationManager* g_piConfigManager = 0;

// External factory called from OLE class factories

IMsiConfigurationManager* CreateConfigurationManager()
{
        
    if (g_piConfigManager)
        return (IMsiConfigurationManager*)(g_piConfigManager->AddRef(), g_piConfigManager);

    IMsiServices* piServices = ENG::LoadServices();
    if (piServices == 0)
        return 0;
    g_piConfigManager = new CMsiConfigurationManager(*piServices);
    if (g_piConfigManager == 0)
        ENG::FreeServices();
    return (IMsiConfigurationManager*)g_piConfigManager;
}

IMsiConfigurationManager* CreateConfigManagerAsServer()
{
    IMsiConfigurationManager* piConfigMgr = CreateConfigurationManager();
    if (piConfigMgr)
    {
        if ((g_fWin9X == false) && RunningAsLocalSystem())
        {
            g_scServerContext = scService;
            DEBUGMSG("Running as a service.");
        }
        else
        {
            g_scServerContext = scServer;
            DEBUGMSG("Running as a server.");
        }
    }
    return piConfigMgr;
}

CMsiConfigurationManager::CMsiConfigurationManager(IMsiServices& riServices)
 : m_piServices(&riServices), m_fElevatedRebootAllowed(false), m_piGIT(NULL),
   m_pCustomActionManager(NULL), m_hShutdownTimer(INVALID_HANDLE_VALUE)
{
    // We don't hold a ref to services, we must call ENG::FreeServices() at end
//  SetAllocator(&riServices);
    InterlockedIncrement(&g_cInstances);
    InitializeCriticalSection(&m_csCreateProxy);
    InitializeCriticalSection(&m_csCAManager);
    InitializeCriticalSection(&m_csRegisterAction);
	ZeroMemory((void *)&m_CustomServerInfo, sizeof(m_CustomServerInfo));
    m_CustomServerInfo.m_rgchWaitingCookie[0] = 0;
    m_CustomServerInfo.m_icacWaitingContext = icacNext;
    Debug(m_Ref.m_pobj = this);  // factory does not do QueryInterface, no aggregation
}

CMsiConfigurationManager::~CMsiConfigurationManager()

{
	if(m_piGIT)
		m_piGIT->Release();
		
//  ReleaseAllocator();

	// custom action servers should have been shut down by the message context shutdown code.
	// but shut them down here as well in case an advertise script creates one without an engine.
	ShutdownCustomActionServer();

    DeleteCriticalSection(&m_csCreateProxy);
    DeleteCriticalSection(&m_csCAManager);
    DeleteCriticalSection(&m_csRegisterAction);
    g_piConfigManager = 0;
    InterlockedDecrement(&g_cInstances);

	// if in the service, reset the timer to enable shutdown. There can only be 
	// one config manager in the service, and when it is destroyed, the process
	// should allow shutdowns. The g_cInstances count will often be 1 at this
	// point because services are released by the config manager Release() call
	// after this destructor is called. 
	if (g_scServerContext == scService && m_hShutdownTimer != INVALID_HANDLE_VALUE)
	{
		LARGE_INTEGER liDueTime = {0,0};
		liDueTime.QuadPart = -iServiceShutdownTime;
		KERNEL32::SetWaitableTimer(m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE);
	}
}

HRESULT CMsiConfigurationManager::QueryInterface(const IID& riid, void** ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;
    if (MsGuidEqual(riid, IID_IUnknown))
        return (*ppvObj = (IUnknown*)this, AddRef(), NOERROR);
    else if (MsGuidEqual(riid, IID_IMsiServer))
        return (*ppvObj = (IMsiServer*)this, AddRef(), NOERROR);
    else if (MsGuidEqual(riid, IID_IMsiConfigurationManager)
#ifdef DEBUG
     || MsGuidEqual(riid, IID_IMsiConfigManagerDebug)
     || ((g_scServerContext == scService || g_scServerContext == scServer) && MsGuidEqual(riid, IID_IMsiConfigMgrAsServerDebug))
#endif //DEBUG
     || ((g_scServerContext == scService || g_scServerContext == scServer) && MsGuidEqual(riid, IID_IMsiConfigManagerAsServer)))
        return (*ppvObj = (IMsiConfigurationManager*)this, AddRef(), NOERROR);
    else
        return (*ppvObj = 0, E_NOINTERFACE);
}

unsigned long CMsiConfigurationManager::AddRef()
{
    AddRefTrack();
    return InterlockedIncrement(&m_Ref.m_iRefCnt);
}

unsigned long CMsiConfigurationManager::Release()
{
	ReleaseTrack();
	long lRef = InterlockedDecrement(&m_Ref.m_iRefCnt);
    if (lRef != 0)
        return lRef;
    delete this;
    ENG::FreeServices();
    if (g_scServerContext != scClient)
    {
        Assert(g_cInstances == 0);
        g_cInstances = 0; // in case engine thread crashed we still want our instance count to go to 0
        WIN::PostQuitMessage(0); // give the service a chance to die if it wants to
    }
    return 0;
}

IMsiServices& CMsiConfigurationManager::GetServices()
//----------------------------------------------
{
    return (m_piServices->AddRef(), *m_piServices);
}

int CMsiConfigurationManager::DoInstall(ireEnum ireProductType, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
                                                     const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions, const DWORD dwPrivilegesMask)
{
	HANDLE hMutex;
	if(!FMutexExists(szMsiExecuteMutex, hMutex))
		// since we've decided not to depend on the existence of the mutex
		// that gets generated on the client side, this check should be on
		// "!g_MessageContext.IsServiceInstalling()", but the flag returned
		// by this method gets set only later on, in g_MessageContext.Initialize,
		// while we've kept the mutex creation on the client side intact for
		// backward compatibility reasons.
		return ERROR_INSTALL_FAILURE;

	WIN::CloseHandle(hMutex);

	if (ireProductType == ireProductCode)
	{
		// validate the product code
		size_t cchProduct = 0;
		if (!szProduct || FAILED(StringCchLength(szProduct, cchGUID+1, &cchProduct)) || (cchProduct != cchGUID))
			return ERROR_INSTALL_FAILURE;
	}
	else if (ireProductType == irePackagePath)
	{		
		// validate the path
		if (!szProduct || FAILED(StringCchLength(szProduct, cchMaxPath+1, NULL)))
			return ERROR_INSTALL_FAILURE;
	}

    CEngineMainThreadData threadData(ireProductType, szProduct, szAction, szCommandLine, iioOptions);
    if(szLogFile && *szLogFile)
    {
        if (FAILED(StringCbCopy(g_szLogFile, sizeof(g_szLogFile), szLogFile)))
            return ERROR_INSTALL_FAILURE;

        g_dwLogMode = iLogMode;
        g_fFlushEachLine = fFlushEachLine ? true : false;
    }
    else
    {
        g_szLogFile[0] = 0;
        g_dwLogMode = 0;
        g_fFlushEachLine = false;
    }
    SetDiagnosticMode(); // make sure mode is set correctly in case mode set before g_dwClientLogMode set

    return g_MessageContext.RunInstall(threadData, (iuiEnum)iuiDefault, &riMessage, dwPrivilegesMask); //?? is iuiDefault correct?
}

iesEnum CMsiConfigurationManager::RunScript(const ICHAR* szScriptFile, IMsiMessage& riMessage,
														  IMsiDirectoryManager* piDirectoryManager, boolean fRollbackEnabled)
//----------------------------------------------
{
	// validate the path
	if (!szScriptFile || FAILED(StringCchLength(szScriptFile, cchMaxPath+1, NULL)))
		return iesFailure;
    
	iesEnum iesResult = iesNoAction;
    // check in progress key - if one doesn't exist, or this product isn't marked in-progress, error
    MsiString strInProgressProductId;
    CTempBuffer<ICHAR,39> rgchProductId;
	PMsiRecord pInProgressInfo(0);
    PMsiRecord pError = GetInProgressInstallInfo(*m_piServices, *&pInProgressInfo);
    if(pError || !pInProgressInfo || (strInProgressProductId = pInProgressInfo->GetMsiString(ipiProductKey), (strInProgressProductId.TextSize() == 0)))
    {
        // error: called RunScript when not in progress
        pError = PostError(Imsg(idbgRunScriptInstallNotInProgress));
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
    // check if the product for this script is marked in progress
/* //!! breaks for nested install that are not merged
//!! only called from CMsiEngine::InstallFinalize (via proxy), where we've already checked/set inprogress
//!! If we need another check here, we should pass in the outermost product code
//!! rather than pulling it out of the script (which is a slow operation anyway)
    else if((MsiGetProductInfoFromScript(szScriptFile,rgchProductId,0,0,0,0,0,0)) != ERROR_SUCCESS)
    {
        pError = PostError(Imsg(idbgNoProductIdInScript),szScriptFile);
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
    else if(strInProgressProductId.Compare(iscExactI,rgchProductId) == 0)
    {
        pError = PostError(Imsg(idbgDifferentProductInProgress),(const ICHAR*)rgchProductId,
                                 (const ICHAR*)strInProgressProductId);
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
*/
	else
	{
		if(!IsImpersonating()) // should be impersonating at this point
		{
			iesResult = iesFailure;
		}
		else 
		{
			PMsiExecute pExecute = ::CreateExecutor(*this, riMessage, piDirectoryManager, (Bool)fRollbackEnabled);
			// we will elevate if necessary within RunScript
			iesResult = pExecute->RunScript(szScriptFile, false);
			if(iesResult == iesUnsupportedScriptVersion)
				iesResult = iesFailure;
		}
    }

    return iesResult;
}

IMsiRecord* CMsiConfigurationManager::DisableRollbackScripts(Bool fDisable)
{
    // open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

    if(fDisable)
    {
        CElevate elevate;
        return pRollbackKey->SetValue(szMsiRollbackScriptsDisabled, *MsiString(TEXT("#1")));
    }
    else
    {
        CElevate elevate;
        return pRollbackKey->RemoveValue(szMsiRollbackScriptsDisabled, 0);
    }
}

IMsiRecord* CMsiConfigurationManager::RollbackScriptsDisabled(Bool& fDisabled)
{
    // open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

    // if Disabled value exists, scripts are disabled
    return pRollbackKey->ValueExists(szMsiRollbackScriptsDisabled, fDisabled);
}

IMsiRecord* CMsiConfigurationManager::RegisterRollbackScript(const ICHAR* szScriptFile)
//----------------------------------------------
{
	// validate the path
	if (!szScriptFile || FAILED(StringCchLength(szScriptFile, cchMaxPath+1, NULL)))
		return PostError(Imsg(idbgOpInvalidParam), (int)ERROR_INVALID_PARAMETER);
    
	// open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

    Bool fExists;

#ifdef DEBUG
    RETURN_ERROR_RECORD(pRollbackKey->ValueExists(szScriptFile, fExists));
    AssertSz(!fExists, "Registering a rollback script that is already registered.");
#endif

    RETURN_ERROR_RECORD(pRollbackKey->ValueExists(szMsiRollbackScriptsDisabled, fExists));
    AssertSz(!fExists, "Registering a rollback script when scripts are marked disabled.");
    if(fExists)
    {
        // remove "disabled" value
        CElevate elevate;
        RETURN_ERROR_RECORD(pRollbackKey->RemoveValue(szMsiRollbackScriptsDisabled, 0));
    }

    // register the script
    MsiString strDate = TEXT("#");
    strDate += ENG::GetCurrentDateTime();

    {
        CElevate elevate;
        RETURN_ERROR_RECORD(pRollbackKey->SetValue(szScriptFile, *strDate));
    }
    return 0;
}

IMsiRecord* CMsiConfigurationManager::UnregisterRollbackScript(const ICHAR* szScriptFile)
//----------------------------------------------
{
	// validate the path
	if (!szScriptFile || FAILED(StringCchLength(szScriptFile, cchMaxPath+1, NULL)))
		return PostError(Imsg(idbgOpInvalidParam), (int)ERROR_INVALID_PARAMETER);

    // open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

#ifdef DEBUG
    Bool fExists;
    RETURN_ERROR_RECORD(pRollbackKey->ValueExists(szScriptFile, fExists));
    AssertSz(fExists, "Unregistering a rollback script that isn't registered.");
#endif

    {
        CElevate elevate;
        // unregister the script
        RETURN_ERROR_RECORD(pRollbackKey->RemoveValue(szScriptFile, 0));
    }
    return 0;
}

IMsiRecord* CMsiConfigurationManager::GetRollbackScriptEnumerator(MsiDate date, Bool fAfter, IEnumMsiString*& rpiEnumScripts)
//----------------------------------------------
{
    CEnumRollbackScripts* piEnum = new CEnumRollbackScripts(date,
        fAfter, *m_piServices);

    if (piEnum && !piEnum->ConstructedOK())
        piEnum->Release(), piEnum = 0;
    rpiEnumScripts = piEnum;
    return piEnum ? 0 : PostError(Imsg(idbgEnumRollback));
}

iesEnum InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
    return riConman.InstallFinalize(iesState, riConman, riMessage, fUserChangedDuringInstall);
}

iesEnum CMsiConfigurationManager::InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
    iesEnum iesResult = iesNoAction;
    PMsiRecord pError(0);
	PMsiRecord pInProgressInfo(0);
	pError = GetInProgressInstallInfo(*riConman.m_piServices, *&pInProgressInfo);

    if(pError != 0 || !pInProgressInfo || !MsiString(pInProgressInfo->GetMsiString(ipiProductKey)).TextSize())
    {
        // error: called installfinalize when not in progress
        pError = PostError(Imsg(idbgInstallNotInProgress));
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
    else
    {
#ifdef CONFIGDB
        if (riConman.m_piConfigurationDatabase)
        {
            if (iesState == iesSuccess)
            {
                PMsiRecord pError = riConman.m_piConfigurationDatabase->Commit();
                if (pError)
                    riMessage.Message(imtWarning, *pError);  //!! remap error? fatal?
            }
            riConman.m_piConfigurationDatabase->Release();
            riConman.m_piConfigurationDatabase = 0;
        }
#endif
		MsiString strTimeStamp = pInProgressInfo->GetMsiString(ipiTimeStamp);
		MsiDate date = (MsiDate)(int)strTimeStamp;

    //!! must set m_irlRollbackLevel before calling RollbackFinalize(),
    //!! but can't call DoMachineVsUserInitialization() as the product info record is not set yet
    //!! it will be set when processing the rollback script, but that doesn't help to determine the mode now
    //!! seems best to pass in the mode that was used to generate the script, but that will requires some changes

		// elevation state for rollback stored in script header
		{
			PMsiExecute pExecute = ::CreateExecutor(riConman, riMessage,
																 0, /* DirectoryManager not required during rollback */
																 fTrue); // rollback enabled
			iesResult = pExecute->RollbackFinalize(iesState, date, (fUserChangedDuringInstall) ? true : false); //!! what if this fails????
		}
	
	}
	return iesResult;
}

iesEnum CMsiConfigurationManager::InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
//----------------------------------------------
{
	return InstallFinalize(iesState, *this, riMessage, fUserChangedDuringInstall);
}

void FormatEventLogData(const ICHAR*, const IMsiString*&, UINT);  // this should go away once bug # 463473 gets fixed.

boolean CMsiConfigurationManager::Reboot()
{
	// the stub for the config manager impersonates via COM impersonation to correctly 
	// authenticate the user when called from the client. 
    BOOL fRet = TRUE;

    bool fReboot = false;
    
    if (g_fWin9X)
    {
        fReboot = true; // always allowed to reboot on Win9X
    }
    else
    {
        if (m_fElevatedRebootAllowed)
        {
            fReboot = true; // we've already been told that we're allowed to reboot
        }
        else
        {
            // Check to see whether the client has the reboot privilege enabled.
            fReboot = IsClientPrivileged(SE_SHUTDOWN_NAME);
        }
    }
        
    if(fReboot)
    {
        CElevate elevate;
        g_MessageContext.DisableTimeout();
        fRet = g_fWin9X || AcquireTokenPrivilege(SE_SHUTDOWN_NAME);
        if (fRet)
        {
            CConvertString sTemp((const ICHAR*)m_strProductCodeNeedingReboot);
            const char* pszTemp = sTemp;
            DEBUGMSGED(EVENTLOG_INFORMATION_TYPE,
                       EVENTLOG_TEMPLATE_REBOOT_TRIGGERED,
                       (const ICHAR*)m_strProductNeedingReboot,
                       IStrLen(sTemp), (LPVOID)pszTemp);

            if(MinimumPlatformWindowsNT51())
            {
                CTempBuffer<ICHAR,1> rgchErrorString(1024);
                unsigned int iCodepage = MsiLoadString(g_hInstance, IDS_INITIATED_SYSTEM_RESTART, rgchErrorString, rgchErrorString.GetSize(), 0);
                if (!iCodepage)
                {
                    AssertSz(0, TEXT("Missing IDS_INITIATED_SYSTEM_RESTART error string"));
                    StringCchCopy(rgchErrorString, rgchErrorString.GetSize(), TEXT("The Windows Installer initiated a system restart to complete or continue the configuration of '%s'..")); // should never happen - two periods in intentional
                }

                // assume the expanded string will be less than 1024 - so we use wsprintf
                CTempBuffer<ICHAR, 1> rgchExpandedErrorString(IStrLen(rgchErrorString)+m_strProductNeedingReboot.TextSize()+1);
                if (SUCCEEDED(StringCchPrintf((ICHAR *)rgchExpandedErrorString, rgchExpandedErrorString.GetSize(), rgchErrorString, (const ICHAR*)m_strProductNeedingReboot)))
				{
					SHUTDOWN_REASON sr = {sizeof(SHUTDOWN_REASON),
										  EWX_REBOOT,
										  REASON_SWINSTALL | REASON_PLANNED_FLAG,
										  SR_EVENT_INITIATE_CLEAN,
										  FALSE,
										  (ICHAR *)rgchExpandedErrorString};
	
					USER32::RecordShutdownReason(&sr);
				}
            }
            
			//
			// NOTE : DO NOT CALL ExitWindowsEX here for XP and higher systems. This is the service and it should not 
			// put up *ANY* UI. On WinXP and higher systems, ExitWindowsEx can put up a message box if multiple users 
			// are logged on to the machine whereas InitiateSystemShutdown does not. If ExitWindowsEx is used and the 
			// client and the service are running in different sessions, then the user will *never* see the message 
			// box put up by ExitWindowsEx since it is in a different session. See bug # 500177.
			//
			// Also note that the client already warns the user of potential loss of data for other logged on users
			// because it counts the number of users on the machine and puts up the appropriate reboot prompt based
			// on the number of users on the machine.
			//
			// Also, using ExitWindowsEx can result in UI even in silent installs on WinXP and higher systems. That is 
			// bad and can potentially cause hangs in deployment scenarios.
			//
			// However, we cannot call InitiateSystemShutdown on Win9X machines because that API is not supported on
			// Win9X
			//
				if (g_fWin9X || GetLoggedOnUserCount() <= 1)
				{
					// if there's only one user, ExitWindowsEx does not put up UI
					fRet = ExitWindowsEx (EWX_REBOOT, 0);
				}
				else
				{
					fRet = ADVAPI32::InitiateSystemShutdown(NULL, NULL, 0, FALSE, TRUE);
					if ( !fRet && WIN::GetLastError() == ERROR_NOT_READY )
						// this happens when the installation is called by Winlogon when a user
						// logs on in session 0 (console).  This behavior had been introduced in XP.
						fRet = ExitWindowsEx (EWX_REBOOT | EWX_FORCE, 0);
				}
        }
        g_MessageContext.EnableTimeout();
        return fRet == TRUE;
    }
    else
    {
        //!! FUTURE eugend: a new eventlog-type message needs to be added
        //                  here, stating that a reboot is needed for the
        //                  completion of the installation of this product.
        //
        //                  bug # 463473 tracks this.
        MsiString strTemp;
        FormatEventLogData(m_strProductCodeNeedingReboot, *&strTemp, ERROR_SUCCESS_REBOOT_REQUIRED);  // this should go away once bug # 463473 gets fixed.
        CConvertString sTemp((const ICHAR*)strTemp);
        const char* pszTemp = sTemp;
        DEBUGMSGED(EVENTLOG_INFORMATION_TYPE,
                   EVENTLOG_TEMPLATE_REBOOT_TRIGGERED,
                   (const ICHAR*)m_strProductNeedingReboot,
                   IStrLen(sTemp), (LPVOID)pszTemp);
        return FALSE;
    }
}

void CMsiConfigurationManager::EnableReboot(boolean fRunScriptElevated,
                                            const IMsiString& ristrProductName,
                                            const IMsiString& ristrProductCode)
{
    if (fRunScriptElevated)
        m_fElevatedRebootAllowed = true;

	 m_strProductNeedingReboot = ristrProductName;
	 ristrProductName.AddRef();
    m_strProductCodeNeedingReboot = ristrProductCode;
    ristrProductCode.AddRef();
}

IMsiRecord* CMsiConfigurationManager::SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch)
{
	// validate the product code
	size_t cchProductCode = 0;
	if (!szProductCode || FAILED(StringCchLength(szProductCode, cchGUID+1, &cchProductCode)) || (cchProductCode != cchGUID))
		return PostError(Imsg(idbgOpInvalidParam), (int)ERROR_INVALID_PARAMETER);
	
	// validate the path
	if (!szPath || FAILED(StringCchLength(szPath, cchMaxPath+1, NULL)))
		return PostError(Imsg(idbgOpInvalidParam), (int)ERROR_INVALID_PARAMETER);

	CCoImpersonate impersonate;
	return SetLastUsedSource(szProductCode, szPath, fAddToList ? fTrue : fFalse, fPatch ? fTrue : fFalse, 0, 0, 0, 0, 0, 0);
}

IMsiRecord* CMsiConfigurationManager::SetLastUsedSource(const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
                                                                          const IMsiString** ppiRawSource,
                                                                          const IMsiString** ppiIndex,
                                                                          const IMsiString** ppiType,
                                                                          const IMsiString** ppiSource,
                                                                          const IMsiString** ppiSourceListKey,
                                                                          const IMsiString** ppiSourceListSubKey)
{
    return SetLastUsedSourceCore(*m_piServices, szProductCodeGUID, szPath, fAddToList, fPatch, ppiRawSource, ppiIndex, ppiType, ppiSource, ppiSourceListKey, ppiSourceListSubKey, false, false, 0);
}

bool FSourceIsAllowed(IMsiServices& riServices, bool fFirstInstall, const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fPatch)
{
	bool fSourceAllowed;

	PMsiRecord pError = SetLastUsedSourceCore(riServices, szProductCodeGUID, szPath, fFalse, fPatch,
															0, 0, 0, 0, 0, 0, true, fFirstInstall, &fSourceAllowed);

    if(pError || fSourceAllowed == false)
        return false;
    else
        return true;
}

IMsiRecord* SetLastUsedSourceCore(IMsiServices& riServices,
                                             const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
                                             const IMsiString** ppiRawSource,
                                             const IMsiString** ppiIndex,
                                             const IMsiString** ppiType,
                                             const IMsiString** ppiSource,
                                             const IMsiString** ppiSourceListKey,
                                             const IMsiString** ppiSourceListSubKey,
                                             bool fVerificationOnly,
                                             bool fFirstInstall,
                                             bool* pfSourceAllowed)
{
	if(pfSourceAllowed)
		*pfSourceAllowed = false;
	
	// pack the GUID
	ICHAR szProductCodeSQUID[cchProductCodePacked + 1] = TEXT("");

	if (szProductCodeGUID && *szProductCodeGUID)
	{
		//!! should be error
		if(!PackGUID(szProductCodeGUID, szProductCodeSQUID))
			return PostError(Imsg(imsgInstallFailed), 0);
	}

	Assert((ppiRawSource && ppiIndex && ppiType && ppiSource && ppiSourceListSubKey) ||
			 (!ppiRawSource && !ppiIndex && !ppiType && !ppiSource && !ppiSourceListSubKey));

    DEBUGMSG("Entering CMsiConfigurationManager::SetLastUsedSource.");

    PMsiPath pPath(0);
    RETURN_ERROR_RECORD(riServices.CreatePath(szPath, *&pPath));

    IMsiRecord* piError = 0;
    const ICHAR* szSubKey;
    isfEnum isf;
    
    MsiString strLastUsedType;
    PMsiVolume pVolume = &pPath->GetVolume();
    idtEnum idt = pVolume->DriveType();

    if (pVolume->IsURLServer())
        idt = idtNextEnum; // use idtNext enum to represent URL

    switch (idt)
    {
    case idtCDROM:   // fall through
    case idtFloppy:  // fall through
//!!    case idtRemovable:
        szSubKey = szSourceListMediaSubKey;
        isf = isfMedia;
        strLastUsedType = MsiString(MsiChar(chMediaSource));
        break;
    default:
    case idtUnknown: // fall through
    case idtRAMDisk: //??
        Assert(0);
    case idtFixed:   // fall through
    case idtRemote:  // fall through
        szSubKey = szSourceListNetSubKey;
        isf = isfNet;
        strLastUsedType = MsiString(MsiChar(chNetSource));
        break;
    case idtNextEnum:
        szSubKey = szSourceListURLSubKey;
        isf = isfURL;
        strLastUsedType = MsiString(MsiChar(chURLSource));
        break;
    }
    
    MsiString strSourceListSubKey;

    MsiString strSourceListKey = _szGPTProductsKey;
    strSourceListKey += MsiString(MsiChar(chRegSep));
    strSourceListKey += MsiString(szProductCodeSQUID);  
    strSourceListKey += MsiString(MsiChar(chRegSep));
    strSourceListKey += szSourceListSubKey;

    strSourceListSubKey = strSourceListKey + MsiString(MsiChar(chRegSep));
    strSourceListSubKey += szSubKey;

    CRegHandle HKey;
    LONG lResult;

    // if a media source, check policies before bothering to check labels, etc. Media are allowed if
    // DisableMedia is not set, and its a first install or AllowLockdownBrowse is set or
    // the product is safe for source actions
    if (isf == isfMedia)
    {
        bool fMediaAllowed = (GetIntegerPolicyValue(szDisableMediaValueName, fFalse) != 1) &&
            (fFirstInstall || GetIntegerPolicyValue(szAllowLockdownMediaValueName, fTrue) == 1 ||
             SafeForDangerousSourceActions(szProductCodeGUID));
        if (!fMediaAllowed)
        {
            DEBUGMSG(TEXT("Warning: rejected media source due to system policy."));
            return 0;
        }
    }


    // if this is a first-time install, there's no sourcelist to check against
    Bool fSourceIsInList = fFalse;
    unsigned int uiMaxIndex = 0;
    MsiString strSetIndex;
    MsiString strNewSource;
    PMsiRegKey pSourceListSubKey(0);
    PMsiRegKey pSourceListKey(0);
    if (!fFirstInstall)
    {
        if (fVerificationOnly == false)
        {
            CElevate elevate;
            if ((lResult = OpenSourceListKeyPacked(szProductCodeSQUID, fPatch, HKey, fTrue, false)) != ERROR_SUCCESS)
                return PostError(Imsg(idbgSrcOpenSourceListKey), lResult);
        }
        else
        {
            if ((lResult = OpenSourceListKeyPacked(szProductCodeSQUID, fPatch, HKey, fFalse, false)) != ERROR_SUCCESS)
                return PostError(Imsg(idbgSrcOpenSourceListKey), lResult);
        }
    
        pSourceListKey = &riServices.GetRootKey((rrkEnum)(int)HKey, ibtCommon); // x86 and ia64 same
        pSourceListSubKey = &pSourceListKey->CreateChild(szSubKey);
        
    //  MsiString strNewURL;
        MsiString strLabel, strNewLabel;
    
        if (isf == isfNet || isf == isfURL)
        {
            strNewSource = szPath; // Note: we assume that the caller has passed us a source with the correct volume pref
        }
        else if (isf == isfMedia)
        {
            // SetLastUsedSource should always refresh the volume properties for media in case the disk in the
            // drive has been changed since the volume object was created.
            PMsiVolume pVolume(&pPath->GetVolume());
            pVolume->DiskNotInDrive();
            strNewLabel = pVolume->VolumeLabel();
        }
    
        PEnumMsiString pEnumString(0);
    
        if (pSourceListKey && (piError = pSourceListSubKey->GetValueEnumerator(*&pEnumString)) != 0)
            return piError;
    
        MsiString strSource;
        if (pSourceListKey)
        {
            for (;;)
            {
                MsiString strIndex;
                HRESULT hRes = pEnumString->Next(1, &strIndex, 0);
                if (S_FALSE == hRes)
                {
                    break;
                }
                else if (S_OK == hRes)
                {
                    MsiString strUnexpandedSource;
                    if ((piError = pSourceListSubKey->GetValue(strIndex, *&strUnexpandedSource)) != 0)
                        return piError;
    
                    if (strUnexpandedSource.Compare(iscStart, TEXT("#%")))
                    {
                        strUnexpandedSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token
                        ENG::ExpandEnvironmentStrings(strUnexpandedSource, *&strSource);
                    }
                    else
                        strSource = strUnexpandedSource;
    
                    int iIndex = strIndex;
                    if (iIndex > uiMaxIndex)
                        uiMaxIndex = iIndex;
    
                    if (isf == isfNet)
                    {
                        MsiString strPath = pPath->GetPath();
                        if (!strSource.Compare(iscEnd, szRegSep))
                            strPath.Remove(iseLast, 1);
    
                        if (strPath.Compare(iscExactI, strSource))
                        {
                            strSetIndex     = strIndex;
                            fSourceIsInList = fTrue;
                            break;
                        }
                    }
                    else if (isf == isfMedia)
                    {
                        strLabel = strSource.Extract(iseUpto, ';');
                        if (strLabel.Compare(iscExactI, strNewLabel))
                        {
                            strSetIndex     = strIndex;
                            fSourceIsInList = fTrue;
                            break;
                        }
                    }
                    else // isf == isfURL
                    {
                        if (strSource.Compare(iscExact, strNewSource))
                        {
                            strSetIndex     = strIndex;
                            fSourceIsInList = fTrue;
                            break;
                        }
                    }
                }
                else
                {
                    break;
                }
            }
        }
        DEBUGMSG1(TEXT("Specifed source is%s already in a list."), !fSourceIsInList ? TEXT(" not") : TEXT(""));
    
        if (ppiRawSource)
        {
            *ppiRawSource = &CreateString();
            *ppiIndex     = &CreateString();
            *ppiType      = &CreateString();
            *ppiSource    = &CreateString();
    
            strSourceListSubKey.ReturnArg(*ppiSourceListSubKey);
            strSourceListKey.ReturnArg(*ppiSourceListKey);
        }
    }

    // Check that this source type is allowed.
    CAPITempBuffer<ICHAR, 4> rgchValidSourceTypes;
	*rgchValidSourceTypes = 0;
    GetStringPolicyValue(szSearchOrderValueName, fFalse, rgchValidSourceTypes);

    const ICHAR* pchSourceType = rgchValidSourceTypes;
    Bool fValidSourceType = fFalse;
    while (*pchSourceType)
    {
        isfEnum isfValid;
        AssertNonZero(MapSourceCharToIsf(*pchSourceType, isfValid));
        if (isf == isfValid)
        {
            fValidSourceType = fTrue;
            break;
        }
        pchSourceType++;
    }

    if (!fValidSourceType)
    {
        DEBUGMSG2(TEXT("Warning: rejected invalid source type for source '%s' (product: %s)"), szPath, szProductCodeGUID);
        return 0;
    }

    // Check whether the user is allowed to add new sources
    // never if DisableBrowse is set. Otherwise, only if admin or non-elevated install. or
    // AllowLockdownBrowse is set.
    bool fAllowAdditionOfNewSources = true;
     
    // first-time installs do not respect the DisableBrowse policy (because by definition its
    // a new source)
    if (!fFirstInstall)
    {
        fAllowAdditionOfNewSources = (GetIntegerPolicyValue(szDisableBrowseValueName, fTrue) != 1) &&
            ((GetIntegerPolicyValue(szAllowLockdownBrowseValueName, fTrue) == 1) ||
             SafeForDangerousSourceActions(szProductCodeGUID));
    }

#ifdef DEBUG
    if (GetEnvironmentVariable(TEXT("MSI_ALWAYS_RESPECT_DISABLE_BROWSE"), 0, 0))
    {
        fAllowAdditionOfNewSources= (GetIntegerPolicyValue(szDisableBrowseValueName, fTrue) != 1);
    }
#endif

    DEBUGMSG1(TEXT("Adding new sources is%s allowed."), fAllowAdditionOfNewSources ? TEXT("") : TEXT(" not"));

    if ((!fAllowAdditionOfNewSources && fSourceIsInList) || fAllowAdditionOfNewSources)
    {

        if(pfSourceAllowed)
            *pfSourceAllowed = true;
    
        if(fVerificationOnly == false)
        {
            if (fAddToList && !fSourceIsInList)
            {
                if (isf == isfNet || isf == isfURL)
                {
                    // strNewSource is already set correctly
                }
                else if (isf == isfMedia)
                {
                    // nothing to add for media sources
                }

                strSetIndex = (int)(uiMaxIndex + 1);
                if (ppiSource)
                {
                    strNewSource.ReturnArg(*ppiSource);
                }
                else
                {
                    MsiString strValue = TEXT("#%"); // REG_EXPAND_SZ
                    strValue += strNewSource;
                    CElevate elevate;
                    AssertRecord(pSourceListSubKey->SetValue(strSetIndex, *strValue));
                }
                DEBUGMSG2(TEXT("Added new source '%s' with index '%s'"), (const ICHAR*)strNewSource, (const ICHAR*)strSetIndex);
            }

            // Set source as LastUsedSource
            if (ppiRawSource)
            {
                MsiString(pPath->GetPath()).ReturnArg(*ppiRawSource);
                strSetIndex.ReturnArg(*ppiIndex);
                strLastUsedType.ReturnArg(*ppiType);
            }
            else
            {
                // elevate so we can open the key for write if necessary
                {
                    CElevate elevate;

                    MsiString strLastUsedSource = strLastUsedType;
                    strLastUsedSource += MsiChar(';');
                    strLastUsedSource += strSetIndex;
                    strLastUsedSource += MsiChar(';');
                    strLastUsedSource += MsiString(pPath->GetPath());

                    AssertRecord(pSourceListKey->SetValue(szLastUsedSourceValueName, *strLastUsedSource));
                }
            }
            DEBUGMSG1(TEXT("Set LastUsedSource to: %s."), (const ICHAR*)MsiString(pPath->GetPath()));
            DEBUGMSG1(TEXT("Set LastUsedType to: %s."),   (const ICHAR*)strLastUsedType);
            DEBUGMSG1(TEXT("Set LastUsedIndex to: %s."),  (const ICHAR*)strSetIndex);
        }
    }
#ifdef DEBUG
    else
    {
        DEBUGMSG2(TEXT("Warning: rejected attempt to add new source '%s' (product: %s)"), szPath, szProductCodeGUID);
    }
#endif

    return 0;
}

IMsiRecord* CMsiConfigurationManager::RegisterUser(const ICHAR* szProductKey, const ICHAR* szUserName,
                                                                    const ICHAR* szCompany, const ICHAR* szProductID)
{
	// validate the product code
	size_t cchProductKey = 0;
	if (!szProductKey || FAILED(StringCchLength(szProductKey, cchGUID+1, &cchProductKey)) || (cchProductKey != cchGUID))
		return PostError(Imsg(idbgOpInvalidParam), (int)ERROR_INVALID_PARAMETER);
    
	CElevate elevate; // elevate to write to our key - should already be elevated, but just in case

	PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon);
#ifdef UNICODE

	MsiString			strKey = szMsiUserDataKey;
	ICHAR				szSID[cchMaxSID];
	ICHAR				szSQUID[cchGUIDPacked + 1];
	iaaAppAssignment	iType;
	DWORD				dwError;
	

	// Get sid. Depending on the product assignment type, this is either
	// user sid or machine sid.

	if(!PackGUID(szProductKey, szSQUID))
	{
		return PostError(Imsg(idbgOpInvalidParam), (int)ERROR_INVALID_PARAMETER);;
	}
	
	dwError = GetProductAssignmentType(szSQUID, iType);
	if(ERROR_SUCCESS != dwError)
	{
		return PostError(Imsg(idbgGetProductAssignmentTypeFailed), (int)dwError);
	}
	if(iType == iaaMachineAssign)
	{
		// Product is installed for machine. Use machine sid.
		StringCbCopy(szSID, sizeof(szSID), szLocalSystemSID);
	}
	else
	{
		dwError = GetCurrentUserStringSID(szSID);
	
		if(ERROR_SUCCESS != dwError)
		{
			return PostError(Imsg(idbgOpGetUserSID), (int)dwError);
		}
	}

	strKey += szRegSep;
	strKey += szSID;
	strKey += szRegSep;
	strKey += szMsiProductsSubKey;
	strKey += szRegSep;
	strKey += MsiString(GetPackedGUID(szProductKey));
	strKey += szRegSep;
	strKey += szMsiInstallPropertiesSubKey;
	
    PMsiRecord pError(0);
    
    PMsiStream pSecurityDescriptor(0);
    if ((pError = GetSecureSecurityDescriptor(*m_piServices, *&pSecurityDescriptor)) != 0)
        return pError;
    
    PMsiRegKey pUninstallKey = &pLocalMachine->CreateChild(strKey, pSecurityDescriptor);
#else
    // there is no multi-user on Win9X - use the global uninstall key location
    PMsiRecord pError(0);
	MsiString strKey = szMsiUninstallProductsKey_legacy;
	strKey += szRegSep;
	strKey += szProductKey;
    PMsiRegKey pUninstallKey = &pLocalMachine->CreateChild(strKey, 0);
#endif
    if(szUserName && *szUserName)
    {
        pError = pUninstallKey->SetValue(szUserNameValueName,*MsiString(szUserName));
        if(pError)
            return pError;
    }

    if(szCompany && *szCompany)
    {
        pError = pUninstallKey->SetValue(szOrgNameValueName, *MsiString(szCompany));
        if(pError)
            return pError;
    }

    if(szProductID && *szProductID)
    {
        pError = pUninstallKey->SetValue(szPIDValueName,     *MsiString(szProductID));
        if(pError)
            return pError;
    }
    
    return 0;
}

IMsiRecord* CMsiConfigurationManager::RemoveRunOnceEntry(const ICHAR* szEntry)
{
    if(!szEntry || !*szEntry)
    {
        Assert(0);
        return 0;
    }
    
    CElevate elevate; // elevate to delete value from RunOnceEntries key

    IMsiRecord* piError = 0;

    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pRunOnceKey = &pLocalMachine->CreateChild(szMsiRunOnceEntriesKey);

    return pRunOnceKey->RemoveValue(szEntry, 0);
}

extern iesEnum RemoveFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation,
                                     IMsiConfigurationManager& riConfigManager, IMsiMessage& riMessage);

boolean CMsiConfigurationManager::CleanupTempPackages(IMsiMessage& riMessage, boolean fCheckServiceBusy)
{
	boolean fReturn = false;
	if ( !fCheckServiceBusy )
		fReturn = CleanupTempPackagesInternal(riMessage);
	else
	{
		// We don't want to clean up temp packages used by another installation
		// and we don't want either the service to start another installation
		// while we're cleaning up.

		if ( g_MessageContext.SetServiceInstalling(true) == ERROR_SUCCESS )
		{
			// we know now that the service was free and we've made it look busy
			fReturn = CleanupTempPackagesInternal(riMessage);
			// make the service be free again.
			AssertNonZero(g_MessageContext.SetServiceInstalling(false) == ERROR_SUCCESS);
		}
		else
			DEBUGMSG(TEXT("Server locked. Will skip uninstalled package cleanup, and allow locking install to perform cleanup."));
	}
	return fReturn;
}

boolean CMsiConfigurationManager::CleanupTempPackagesInternal(IMsiMessage& riMessage)
{
    CElevate elevate; // elevate entire routine

    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pTempPackagesKey = &pLocalMachine->CreateChild(szMsiTempPackages);

    PMsiRecord pError(0);
    

    Bool fKeyExists = fFalse;
    if((pError = pTempPackagesKey->Exists(fKeyExists)) != 0)
    {
        AssertRecordNR(pError);
        return false;
    }

    if(!fKeyExists)
    {
        // no key, nothing to do
        return true;
    }
        
    PEnumMsiString pEnum(0);
    if((pError = pTempPackagesKey->GetValueEnumerator(*&pEnum)) != 0)
    {
        AssertRecordNR(pError);
        return false;
    }
    
    MsiString strFilePath;
    while((pEnum->Next(1, &strFilePath, 0)) == S_OK)
    {
        MsiString strValue;
        if((pError = pTempPackagesKey->GetValue(strFilePath,*&strValue)) != 0)
        {
            AssertRecordNR(pError);
            continue;
        }

        int iOptions = 0;
        if(strValue.TextSize() > 1)
        {
            // skip past '#' for integer values
            strValue.Remove(iseIncluding, '#');
            iOptions = strValue;
            if(iOptions == iMsiNullInteger)
                iOptions = 0;
        }

        PMsiPath pPath(0);
        MsiString strFileName;
        if((pError = m_piServices->CreateFilePath(strFilePath, *&pPath, *&strFileName)) != 0)
        {
            AssertRecordNR(pError);
            continue;
        }

        // first, remove file - ignore error
        DEBUGMSG1(TEXT("Post-install cleanup: removing installer file '%s'"), strFilePath);
        if((pError = pPath->RemoveFile(strFileName)) != 0)
        {
            AssertRecordNR(pError);
            continue;
        }
        
        // next, if options say so, try to remove the folder
        if(iOptions & TEMPPACKAGE_DELETEFOLDER)
        {
            DEBUGMSG1(TEXT("Post-install cleanup: removing installer folder '%s' (if empty)"), MsiString(pPath->GetPath()));

            // ignore error
            RemoveFolder(*pPath, fFalse, fFalse, *this, riMessage);
        }

    }

    // finally, remove key
    if((pError = pTempPackagesKey->Remove()) != 0)
    {
        AssertRecordNR(pError);
        return false;
    }
    
    return true;
}

///////////////////////////////////////////////////////////////////////
// save the specified timer off for reset on shutdown.
void CMsiConfigurationManager::SetShutdownTimer(HANDLE hTimer)
{
	m_hShutdownTimer = hTimer;
}


#ifdef CONFIGDB
icdrEnum CMsiConfigurationManager::RegisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId)
{
    return m_piConfigurationDatabase ? m_piConfigurationDatabase->InsertFile(szFolder, szFile, szComponentId) : icdrNotOpen;
}

icdrEnum CMsiConfigurationManager::UnregisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId)
{
    return m_piConfigurationDatabase ? m_piConfigurationDatabase->RemoveFile(szFolder, szFile, szComponentId) : icdrNotOpen;
}
#endif

IMsiRecord* GetComponentPath(IMsiServices& riServices, const ICHAR* szUserId, const IMsiString& riProductKey, 
								     const IMsiString& riComponentCode, 
									  IMsiRecord *& rpiRec,
									  iaaAppAssignment* piaaAsgnType)
												   
//----------------------------------------------
{
    INSTALLSTATE isStaticState  = INSTALLSTATE_UNKNOWN;
    INSTALLSTATE isDynamicState = INSTALLSTATE_UNKNOWN;
    INSTALLSTATE isReturnState  = INSTALLSTATE_UNKNOWN;

    ICHAR szProductKeyPacked[cchProductCode  + 1];
    ICHAR szComponentIdPacked[cchComponentId + 1];

    AssertNonZero(PackGUID(riProductKey.GetString(),    szProductKeyPacked));
    AssertNonZero(PackGUID(riComponentCode.GetString(), szComponentIdPacked));

    rpiRec = &riServices.CreateRecord(icmlcrEnumCount);
	// Get static state 
	CAPITempBuffer<ICHAR, MAX_PATH> rgchComponentRegValue;
	DWORD dwValueType;		
	isStaticState = GetComponentClientState(szUserId, szProductKeyPacked, szComponentIdPacked, rgchComponentRegValue, dwValueType, piaaAsgnType);
	rpiRec->SetInteger(icmlcrINSTALLSTATE_Static, (int)isStaticState);
	
	if (isStaticState == INSTALLSTATE_UNKNOWN)
	{
		rpiRec->SetString(icmlcrFile, TEXT(""));
		rpiRec->SetInteger(icmlcrINSTALLSTATE, (int)INSTALLSTATE_UNKNOWN);
		return 0;
	}
	rpiRec->SetString(icmlcrRawFile, (const ICHAR*)rgchComponentRegValue);
    if (REG_MULTI_SZ == dwValueType)
    {
        const ICHAR* pch = rgchComponentRegValue;
        while (*pch++)
            ;

        rpiRec->SetString(icmlcrRawAuxPath, pch);
    }
	
	// Get dynamic state
	CTempBuffer<ICHAR, 1> rgchFile(MAX_PATH);  // same initial buffer size as that in ::GetComponentPath
	DWORD cchFile = rgchFile.GetSize();     // actual buffer size in chars passed in, including room for null
    CTempBuffer<ICHAR, 1> rgchRegPath(MAX_PATH);  // same initial buffer size as that in ::GetComponentPath
    DWORD cchRegPath = rgchRegPath.GetSize();     // actual buffer size in chars passed in, including room for null
	MsiString strKeyPath;
    MsiString strRegKeyPath;
	DWORD dwLastError = ERROR_FUNCTION_FAILED;

	for (int c=1; c <= 3; c++)  // retry if buffer too small, ::GetComponentPath may process reg data before copying
	{
		// Always use the process-level RFS cache for engine/services based calls.
		isDynamicState = ::GetComponentPath(szUserId, szProductKeyPacked, szComponentIdPacked, rgchFile, &cchFile, false, g_RFSSourceCache, DETECTMODE_VALIDATEPATH, rgchComponentRegValue, dwValueType, rgchRegPath, &cchRegPath, &dwLastError);

		if (INSTALLSTATE_MOREDATA == isDynamicState)
		{
			rgchFile.SetSize(++cchFile);  // adjust buffer size for char count + 1 for null terminator
            rgchRegPath.SetSize(++cchRegPath);  // adjust buffer size for char count + 1 for null terminator
		}
		else 
		{
			strKeyPath = (const ICHAR*)rgchFile;
            strRegKeyPath = (const ICHAR*)rgchRegPath;
			if ((INSTALLSTATE_DEFAULT == isDynamicState) || (INSTALLSTATE_LOCAL == isDynamicState) || (INSTALLSTATE_ABSENT == isDynamicState))
			{

                // have we refcounted in the SharedDll registry

                if(rgchComponentRegValue[1] == chSharedDllCountToken) // we have refcounted in the registry
                    rpiRec->SetInteger(icmlcrSharedDllCount, fTrue);
            }
            break;
        }
    }

    if ((isDynamicState == INSTALLSTATE_ABSENT) || (isDynamicState == INSTALLSTATE_UNKNOWN))
    {
        isReturnState = INSTALLSTATE_ABSENT;
    }
    else if (isDynamicState == INSTALLSTATE_SOURCE || isDynamicState == INSTALLSTATE_LOCAL || isDynamicState == INSTALLSTATE_NOTUSED)
    {
        isReturnState = isDynamicState;
    }
    else if (isDynamicState == INSTALLSTATE_DEFAULT)
    {
        isReturnState = isStaticState;
    }
    else
    {
        AssertSz(0, "Unexpected dynamic component state");
        isReturnState = INSTALLSTATE_UNKNOWN;
    }

	rpiRec->SetMsiString(icmlcrFile, *strKeyPath);
    if(strRegKeyPath.TextSize())
        rpiRec->SetMsiString(icmlcrAuxPath, *strRegKeyPath);
	rpiRec->SetInteger(icmlcrINSTALLSTATE, isReturnState);
	rpiRec->SetInteger(icmlcrLastErrorOnFileDetect, dwLastError);
	return 0;	
}

IMsiRecord* CMsiConfigurationManager::RegisterFolder(IMsiPath& riPath, Bool fExplicitCreation)
//----------------------------------------------
{
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pFoldersKey = &pLocalMachine->CreateChild(szMsiFoldersKey);
    
    MsiString strFolderPath;
    RETURN_ERROR_RECORD(riPath.GetFullUNCFilePath(TEXT(""),*&strFolderPath));
    MsiString strValue;
    if (fExplicitCreation)
        strValue = *TEXT("1");

    {
        CElevate elevate;
        RETURN_ERROR_RECORD(pFoldersKey->SetValue(strFolderPath, *strValue));
    }
    return 0;
}

IMsiRecord* CMsiConfigurationManager::IsFolderRemovable(IMsiPath& riPath, Bool fExplicit, Bool& fRemovable)
//----------------------------------------------
{
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pFoldersKey = &pLocalMachine->CreateChild(szMsiFoldersKey);
    
    MsiString strFolder;
    RETURN_ERROR_RECORD(riPath.GetFullUNCFilePath(TEXT(""),*&strFolder));

    Bool fExists;
    RETURN_ERROR_RECORD(pFoldersKey->ValueExists(strFolder, fExists));
    
    fRemovable = fFalse;

    if (fExists)
    {
        if (fExplicit)
        {
            fRemovable = fTrue;
        }
        else
        {
            MsiString strData;
            RETURN_ERROR_RECORD(pFoldersKey->GetValue(strFolder, *&strData));
            fRemovable = (strData.TextSize() == 0) ? fTrue : fFalse;
        }
    }
    
    return 0;
}

IMsiRecord* CMsiConfigurationManager::UnregisterFolder(IMsiPath& riPath)
//----------------------------------------------
{
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    PMsiRegKey pFoldersKey = &pLocalMachine->CreateChild(szMsiFoldersKey);

    MsiString strFolder;
    RETURN_ERROR_RECORD(riPath.GetFullUNCFilePath(TEXT(""),*&strFolder));
    {
        CElevate elevate;
        RETURN_ERROR_RECORD(pFoldersKey->RemoveValue(strFolder, 0));
    }
    return 0;
}

void CMsiConfigurationManager::ChangeServices(IMsiServices& riServices)
{

    m_piServices = &riServices;

}

//____________________________________________________________________________
//
// CEnumRollbackScripts implementation
//____________________________________________________________________________

CEnumRollbackScripts::CEnumRollbackScripts(const MsiDate date,
                                                         const Bool fAfter,
                                                            IMsiServices& riServices)
    : m_iRefCnt(1), m_fDone(fFalse),
      m_pServices(&riServices),
      m_piEnum(0), m_pRollbackKey(0),
      m_date(date), m_fAfter(fAfter)
{
    PMsiRecord pError(0);

    riServices.AddRef();

    PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
    m_pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));
    
    if (pError = m_pRollbackKey->GetValueEnumerator(m_piEnum))
    {
        m_piEnum = 0;
        return;
    }
}

CEnumRollbackScripts::~CEnumRollbackScripts()
{
    if (m_piEnum)
        m_piEnum->Release();
}

HRESULT CEnumRollbackScripts::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IEnumMsiString)
        return (*ppvObj = this, AddRef(), NOERROR);
    else
        return (*ppvObj = 0, E_NOINTERFACE);
}

unsigned long CEnumRollbackScripts::AddRef()
{
    return ++m_iRefCnt;
}

unsigned long CEnumRollbackScripts::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;
    delete this;
    return 0;
}

HRESULT CEnumRollbackScripts::Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched)
{
    PMsiRecord pError(0);
    PMsiRecord pFetched(0);
    int cFetched = 0;
    unsigned long cRequested = cFetch;

    while(cFetch)
    {
        MsiString strScriptFile = 0;
        HRESULT hRes = m_piEnum->Next(1, &strScriptFile, 0);
        if (S_FALSE == hRes)
            break;
        else if (S_OK != hRes)
            return E_FAIL;

        MsiString strDate;
        pError = m_pRollbackKey->GetValue(strScriptFile, *&strDate);
        if (pError != 0)
            return E_FAIL;

        strDate.Remove(iseFirst, 1);
        if (m_fAfter && ((MsiDate)(int)strDate < m_date))
            continue;
        else if (!m_fAfter && ((MsiDate)((int)strDate > m_date)))
            continue;

        strDate += TEXT("#");
        strDate += strScriptFile;
        strDate.ReturnArg(*rgpi);

        rgpi++;
        cFetch--;
        cFetched++;
    }
    
    if (pcFetched)
        *pcFetched = cFetched;  
    return (cFetched == cRequested  ? S_OK : S_FALSE);
}

HRESULT CEnumRollbackScripts::Skip(unsigned long cSkip)
{
    PMsiRecord pFetched(0);
    PMsiRecord pError(0);
    while (cSkip)
    {
        MsiString strScriptFile;
        HRESULT hRes = m_piEnum->Next(1, &strScriptFile, 0);
        if (hRes == S_FALSE)
            break;
        else if (hRes == E_FAIL)
            return E_FAIL;

        MsiString strDate;
        pError = m_pRollbackKey->GetValue(strScriptFile, *&strDate);
        if (pError != 0)
            return E_FAIL;

        strDate.Remove(iseFirst, 1);
        if (m_fAfter && ((MsiDate)(int)strDate < m_date))
            continue;
        else if (!m_fAfter && ((MsiDate)((int)strDate > m_date)))
            continue;

        cSkip--;
    }
    return cSkip ? S_FALSE : NOERROR;
}

HRESULT CEnumRollbackScripts::Reset()
{
    PMsiRecord pError(0);
    m_fDone = fFalse;

    m_piEnum->Release();
    
    if (pError = m_pRollbackKey->GetValueEnumerator(m_piEnum))
    {
        m_piEnum = 0;
        return E_FAIL;
    }

    return NOERROR;
}

HRESULT CEnumRollbackScripts::Clone(IEnumMsiString** ppiEnum)
{
    CEnumRollbackScripts* piEnum = new CEnumRollbackScripts(m_date,
        m_fAfter, *m_pServices);
    if (piEnum && !piEnum->ConstructedOK())
        delete piEnum, piEnum = 0;
    return ((*ppiEnum = piEnum) != 0) ? NOERROR: E_OUTOFMEMORY;
}

UINT CMsiConfigurationManager::SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType)
{
    CCoImpersonate impersonate;
    DISPLAYACCOUNTNAME(TEXT("After impersonating in service for SourceList API: "));
    
    //!! future support more than just isrcNet
    if (isrcType != isrcNet)
    {
        return ERROR_INVALID_PARAMETER;
    }

	// validate the product code
	size_t cchProductCode = 0;
	if (!szProductCode || FAILED(StringCchLength(szProductCode, cchGUID+1, &cchProductCode)) || (cchProductCode != cchGUID))
		return ERROR_INVALID_PARAMETER;

    DWORD dwResult;
    CMsiSourceList SourceList;
    bool fMachine = (!szUserName || !*szUserName);
    if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/false, fMachine, szProductCode, szUserName)))
        return dwResult;
    return SourceList.ClearListByType(isrcType);
}

UINT CMsiConfigurationManager::SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType,
                                         const ICHAR* szSource)
{
    CCoImpersonate impersonate;
    DISPLAYACCOUNTNAME(TEXT("After impersonating in service for SourceList API: "));
    
    //!! future support more than just isrcNet
    if (isrcType != isrcNet)
    {
        return ERROR_INVALID_PARAMETER;
    }

	// validate the product code
	size_t cchProductCode = 0;
	if (!szProductCode || FAILED(StringCchLength(szProductCode, cchGUID+1, &cchProductCode)) || (cchProductCode != cchGUID))
		return ERROR_INVALID_PARAMETER;

	// validate the path
	if (!szSource || FAILED(StringCchLength(szSource, cchMaxPath+1, NULL)))
		return ERROR_INVALID_PARAMETER;

    DWORD dwResult;
    CMsiSourceList SourceList;
    bool fMachine = (!szUserName || !*szUserName);
    if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/false, fMachine, szProductCode, szUserName)))
        return dwResult;

    dwResult = SourceList.AddSource(isrcType, szSource);
    return dwResult;
}

UINT CMsiConfigurationManager::SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName)
{
    CCoImpersonate impersonate;
    DISPLAYACCOUNTNAME(TEXT("After impersonating in service for SourceListAPI:"));

	// validate the product code
	size_t cchProductCode = 0;
	if (!szProductCode || FAILED(StringCchLength(szProductCode, cchGUID+1, &cchProductCode)) || (cchProductCode != cchGUID))
		return ERROR_INVALID_PARAMETER;

    DWORD dwResult;
    CMsiSourceList SourceList;
    bool fMachine = (!szUserName || !*szUserName);
    if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/false, fMachine, szProductCode, szUserName)))
        return dwResult;

    dwResult = SourceList.ClearLastUsed();
    return dwResult;
}

// CreateCustomActionProxy spawns the custom action server process, waits for it to register, then returns
// a proxy interface to the caller. This function is responsible for creating the appropriate process token
// in the requested security context, generating the cookie, storing the outgoing RemoteAPI and process
// information for the registration function to pass to the client, and passing the resulting cookie and
// process information to the caller. Must be impersonating when making this call.
IMsiCustomAction* CMsiConfigurationManager::CreateCustomActionProxy(const icacCustomActionContext icacDesiredContext, const unsigned long dwProcessId, 
	IMsiRemoteAPI *pRemoteAPI, const WCHAR* pvEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *pcbCookie, 
	HANDLE *phServerProcess, unsigned long *pdwServerProcessId, bool fClientOwned, bool fRemapHKCU)
{
	Assert(IsImpersonating(true));
	
	// only one thread can be creating a custom action proxy at a time. Calls by additional threads
	// must block. This prevents additional CA threads from creating extra processes because the
	// first one is still starting up and hasn't gotten back to us yet. 
	EnterCriticalSection(&m_csCreateProxy);

    // ensure that we have a GIT pointer
    if (!m_piGIT)
    {
        if (S_OK != OLE32::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&m_piGIT))
        {
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }
    }

    // we cannot rely on OLE to create the custom action server interface for us, becuase it will create
    // the process as the owner of the desktop, which is not necessarily the user who is running the install.
    // Therefore, we explicitly call CreateProcessAsUser providing a cookie, and wait for the custom action
    // server to connect back to the service identifying itself as the correct process and providing the
    // IMsiCustomAction interface for itself.
    HANDLE hTokenPrimary = 0;
	
	// prepare the appropriate token by duplicating either our impersonation token or the process token. It
	// is the responsibility of the callER to ensure that elevated contexts are appropriate with respect
	// to the install session and security policies, as this function does not do any safety checks beyond
	// "are we the service"

	bool fElevateCustomActionServer = (g_scServerContext == scService && ((icacDesiredContext == icac64Elevated) || (icacDesiredContext == icac32Elevated)));

	if (fElevateCustomActionServer)
	{
		//
		// SAFER: elevated custom action server does not need to be marked inert since process
		//        running as local_system is not subject to SAFER policy
		//

		// elevate this block to ensure rights to the system process token
		{
			CElevate elevate;

            HANDLE	hTokenService = 0;

            // work with a duplicate of our process token so we don't make any permanent changes            
            if (OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hTokenService) && hTokenService)
            {           
                // if this call fails, set hTokenPrimary to 0, which causes us to drop out later
                if (!ADVAPI32::DuplicateTokenEx(hTokenService, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary))
                {
                    hTokenPrimary = 0;
                }
                CloseHandle(hTokenService);
            }
        }
                
        // on NT5 systems, the token used to create the process must have the appropriate session information
        // inside or UI thrown by the CA will pop up on the console. On NT4 we don't support remote installs,
        // and the TokenSessionId information is inaccessible anyway.
        if (g_iMajorVersion >= 5)
        {
            // open the thread token. This may be called via COM while an install is in progress, so
            // we can't assume that the token from GetUserToken() is the right token
            HANDLE hTokenUser = 0;

            // TRUE for OpenAsSelf argument makes call as system to ensure that we have access.
            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hTokenUser))
            {
                // failed to get user information. Its better to fail completely than to continue and allow
                // the custom action to open a security hole by throwing UI from an elevated process to a
                // different session. Setting hTokenPrimary to 0 causes a failure later
                CloseHandle(hTokenPrimary);
                hTokenPrimary = 0;
            }
            else
            {
                DWORD dwSessionId = 0;
                DWORD cbResult = 0;

				// elevate this block to provide write access to the primary token.
				CElevate elevate;
				
				// grab the session ID from the users token and place it in the duplicate service token
				if (!GetTokenInformation(hTokenUser, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD), &cbResult) ||
					!SetTokenInformation(hTokenPrimary, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD)))
				{
					// failed to set session information. Its better to fail completely than to continue and allow
					// the custom action to open a security hole by throwing UI from an elevated process to a 
					// different session.
					CloseHandle(hTokenPrimary);
					hTokenPrimary = 0;
				}
				
				CloseHandle(hTokenUser);
			}
		}
	}
	else
	{
		//
		// SAFER: must mark token inert so that executing custom actions are not subject to SAFER
		//        policy check.  We already indicated we trusted the package
		//

		// open the thread token. This may be called via COM while an install is in progress, so 
		// we can't assume that the token from GetUserToken() is the right token
		HANDLE hTokenUser = 0;


        // TRUE for OpenAsSelf argument makes call as process token (system) to ensure that we have access
        if(OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, TRUE, &hTokenUser))
        {       
			if (MinimumPlatformWindowsNT51())
			{
				// we must first duplicate the token so that we have a proper primary token for CreateProcessAsUser
				// upon success, we'll mark the token INERT

				HANDLE hTokenDup = 0;
				if (0 == ADVAPI32::DuplicateTokenEx(hTokenUser, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenDup))
				{
					hTokenDup = 0;
				}

				// normally we would try to create this using ADVAPI32::ComputeAccessTokenFromCodeAuthzLevel, but there's
				// no guarantee that the global message context is available.  Therefore we use CreateRestrictedToken
				// to explicitly mark the token inert, but we don't disable any privileges
				if (hTokenDup && 0 == ADVAPI32::CreateRestrictedToken(hTokenDup, SANDBOX_INERT, 0, NULL, 0, NULL, 0, NULL, &hTokenPrimary))
				{
					hTokenPrimary = 0;
				}
				if (hTokenDup)
					CloseHandle(hTokenDup);
			}
			else
			{
				if (0 == ADVAPI32::DuplicateTokenEx(hTokenUser, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary))
				{
					hTokenPrimary = 0;
				}
			}
			CloseHandle(hTokenUser);
        }
    }

    // if for any reason we were unable to create the primary token or assign it the appropriate session
    // id, we won't be able to run the action securely.
    if (!hTokenPrimary)
    {
        DEBUGMSGV("Failed to create primary token while spawning Custom Action Server.");
        LeaveCriticalSection(&m_csCreateProxy);
        return NULL;
    }

    // generate a cookie to use in authenticating the the custom action server.
    m_CustomServerInfo.m_rgchWaitingCookie[0] = 0;

    // if crypto failed, generate a pseudo-random cookie. note that using srand/rand/time
    // requires linking in a non-trivial part of the standard c library, so instead, we
    // use RtlRandom, which is a pseudo-random number generator implemented by NT.
    DEBUGMSGV("Generating random cookie.");
    ULONG ulSeed = GetTickCount();
    for (int iCookieByte = 0; iCookieByte < iRemoteAPICookieSize; iCookieByte++)
        m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte] = static_cast<unsigned char>(NTDLL::RtlRandom(&ulSeed) % 255);

    // generate a command line and working dir
    MsiString strWorkingDir = 0;
    CTempBuffer<ICHAR, MAX_PATH> szWorkingDir;

    MsiString strCommandLine;
	MsiString strExecutable;
    
    // Get the appropriate working directory based on the bitness.

    // get the full path to the appropriate copy of msiexec.exe (32 or 64)
    // and the appropriate working directory based on the bitness.
    PMsiRecord piError = 0;
    if (icacDesiredContext == icac64Elevated || icacDesiredContext == icac64Impersonated)
    {
        piError = GetServerPath(*m_piServices, /*fUNC=*/false, /*f64Bit=*/true, *&strExecutable);
        MsiGetSystemDirectory(szWorkingDir, MAX_PATH, /*bAlwaysReturnWOW64Dir=*/ FALSE);
    }
    else
    {
        piError = GetServerPath(*m_piServices, /*fUNC=*/false, /*f64Bit=*/false, *&strExecutable);
        MsiGetSystemDirectory(szWorkingDir, MAX_PATH, /*bAlwaysReturnWOW64Dir=*/ TRUE);
    }
        
    // msiexec.exe command line parsing expects the executable to be first on the command line
    // so even though we explicitly provide the executable path, we need to provide it as part
    // of the command line as well.
	strCommandLine = strExecutable;

    //!!future should change this to something that isn't OLE-overloaded
    strCommandLine += TEXT(" -Embedding ");

    // convert the cookie to a set of chars (hex encoding, in 4-bit chunks, high4 then low4)
    CTempBuffer<ICHAR, 2*iRemoteAPICookieSize+1> rgchCookieString;
    const ICHAR rgchHex[]=TEXT("0123456789ABCDEF");
    for (int iCookieByte=0; iCookieByte < iRemoteAPICookieSize; iCookieByte++)
    {
        rgchCookieString[2*iCookieByte] = rgchHex[m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte] / 0x10];
        rgchCookieString[2*iCookieByte+1] = rgchHex[m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte] % 0x10];
    }
    rgchCookieString[2*iRemoteAPICookieSize] = 0;

    strCommandLine += rgchCookieString;

	// pass the client-owned state to the server so it can correctly pass foreground rights
	// back to the client.
	HANDLE hServerResumeEvent = INVALID_HANDLE_VALUE;
	if (fClientOwned)
	{
		strCommandLine += TEXT(" C");
	}
	else if (fElevateCustomActionServer)
	{
		if (fRemapHKCU)
			strCommandLine += TEXT(" M ");
		else
			strCommandLine += TEXT(" E ");
	
		// if attempting to elevate the custom action server we'll need to create
		// a named global event to get the CA server to wait for its thread token
		// before loading the registry hive.
		SECURITY_ATTRIBUTES EventAttributes;
		EventAttributes.nLength = sizeof(EventAttributes);
		EventAttributes.bInheritHandle = FALSE;
		if (ERROR_SUCCESS == GetSecureSecurityDescriptor(reinterpret_cast<char**>(&EventAttributes.lpSecurityDescriptor), fFalse, fFalse))
		{
			ICHAR rgchName[20] = TEXT("");
			int chFirstChar = 0;
			if (MinimumPlatformWindows2000())
			{
				StringCbCopy(rgchName, sizeof(rgchName), TEXT("Global\\"));
				chFirstChar = 7;
			}
			StringCchCopy(&rgchName[chFirstChar], sizeof(rgchName)/sizeof(rgchName[0]) - chFirstChar, TEXT("MSI"));
			chFirstChar+=3;
			for (int iEventID=0; iEventID < 0xFFFF; iEventID++)
			{
				rgchName[chFirstChar]   = rgchHex[(iEventID & 0xF000) >> 12];
				rgchName[chFirstChar+1] = rgchHex[(iEventID & 0x0F00) >> 8];
				rgchName[chFirstChar+2] = rgchHex[(iEventID & 0x00F0) >> 4];
				rgchName[chFirstChar+3] = rgchHex[(iEventID & 0x000F)];
				rgchName[chFirstChar+4] = 0;

				// elevate to set system as owner of event
				DWORD dwLastError = 0;
				{
					CElevate elevate;
					hServerResumeEvent = CreateEvent(&EventAttributes, TRUE, FALSE, rgchName);

					// must grab last error before elevate destructor
					dwLastError = GetLastError();
				}

				// event handle returned, ensure that the event didn't already exist
				if (hServerResumeEvent != 0 && hServerResumeEvent != INVALID_HANDLE_VALUE)
				{
					if (dwLastError == ERROR_ALREADY_EXISTS)
					{
						WIN::CloseHandle(hServerResumeEvent);
						hServerResumeEvent = 0;
					}
					else 
						break;
				}
			}
			strCommandLine += rgchName;
		}
		if (!hServerResumeEvent || hServerResumeEvent == INVALID_HANDLE_VALUE)
		{
			DEBUGMSGV("Failed to create Custom Action Server wake event.");
			WIN::CloseHandle(hTokenPrimary);
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}
	}

    // create an unnamed event to wait on. (non-inheritable, auto-reset, initially unsignaled)
    // the registration thread signals this event when registration is completed
    m_hCARegistered = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hCARegistered)
    {
        DEBUGMSGV("Failed to create Custom Action Server event.");
        WIN::CloseHandle(hTokenPrimary);
		if (hServerResumeEvent != INVALID_HANDLE_VALUE)
			WIN::CloseHandle(hServerResumeEvent);
        LeaveCriticalSection(&m_csCreateProxy);
        return NULL;
    }
    
    // create the process as the desired user
    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    // init the structures to all 0
    memset(&pi, 0, sizeof(pi));
    
    memset(&si, 0, sizeof(si));
    si.cb        = sizeof(si);

    // set STARTUPINFO.lpDesktop to WinSta0\Default. When combined with the TS sessionID from the
    // token, this places any UI on the visible desktop of the appropriate session.
    si.lpDesktop=TEXT("WinSta0\\Default");
    {       
        CSIDAccess SIDAccess[3];

        SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;

        // LocalSystem and Admins always have full access to the process
        if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[0].pSID))) ||
            (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[1].pSID))))
        {
            WIN::CloseHandle(hTokenPrimary);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
			LeaveCriticalSection(&m_csCreateProxy);
            return 0;
        }
        SIDAccess[0].dwAccessMask = PROCESS_ALL_ACCESS;
        SIDAccess[1].dwAccessMask = PROCESS_ALL_ACCESS;

        // if an elevated context, don't give the user any access to the process at all, otherwise, give
        // the user all access except WRITE on the DACL, memory reads, memory writes, and procinfo change
        int cSD = 2;
        char rgchSID[cbMaxSID];             
        if (g_scServerContext != scService || (icacDesiredContext == icac64Impersonated) || (icacDesiredContext == icac32Impersonated))
        {
            // open the thread token. This may be called via COM while an install is in progress, so
            // we can't assume that the token from GetUserToken() is the right token
            HANDLE hTokenUser = 0;

            // TRUE for OpenAsSelf argument makes call with process token (system) to ensure that we have access.
            if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hTokenUser))
            {       
                if (ERROR_SUCCESS == GetUserSID(hTokenUser, rgchSID))
                {
                    // add the user token to the end of the array and increment the count of SIDs so the ACL
                    // functions pick up the new SID.
                    SIDAccess[2].pSID = (SID*)rgchSID;
                    cSD++;
                    
                    // tell the CSIDAccess class not to free the user's SID, as its a static array managed by
                    // the vertrust functions
                    SIDAccess[2].pSID.FreeSIDOkay(false);
					SIDAccess[2].dwAccessMask = PROCESS_ALL_ACCESS & ~(WRITE_DAC | WRITE_OWNER | PROCESS_SET_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE);
                }
                CloseHandle(hTokenUser);
            }
        }

        // set the "waiting context" to the desired context. RegisterCustomAction only accepts
        // incoming connections for one context at a time (internally this is enforced
        // via the critical section in this method) and must reject registrations for the wrong
        // context, even if the cookie matches.
        m_CustomServerInfo.m_icacWaitingContext = icacDesiredContext;

        // store the RemoteAPI interface. This interface is passed back to the client. Don't forget to marshal
        // to the registration thread via the GIT
        if (S_OK != m_piGIT->RegisterInterfaceInGlobal(pRemoteAPI, IID_IMsiRemoteAPI, &m_CustomServerInfo.m_dwRemoteCookie))
        {
            DEBUGMSGV("Unable to register RemoteAPI in GIT for registration.");
            WIN::CloseHandle(hTokenPrimary);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }

		// process id to pass to CA server. This is the process id of the eventual interface client
		// and is used by the CA server in its main thread to watch for client death and clean up
		// when the requesting process dies
		m_CustomServerInfo.m_dwProcessId = dwProcessId;

		// privilige bitmap to pass to CA server. For client-owned servers, this tells the server
		// what privileges need to be disabled before actions can run
		m_CustomServerInfo.m_dwPrivileges = dwPrivileges;

		// per bug 196384, we will create the process suspended for elevated custom actions so that we may
		// add the user token as the thread token.  we'll then resume the process thread.  this will allow
		// us to properly map HKCU
		BOOL fProcessCreated = false;

		// must elevate this block or CSecurityDescription won't be able to set the owner of the process to LOCALSYSTEM
		// and CreateProcess will fail
		{
			HANDLE	hTokenUser = INVALID_HANDLE_VALUE;
			// TRUE for OpenAsSelf argument makes call as process token (system) to ensure that we have access
			// error case checked below.
			if (!OpenThreadToken(GetCurrentThread(), MSI_TOKEN_ALL_ACCESS, TRUE, &hTokenUser))
			{
				DEBUGMSGV("Unable to grab user token for impersonation.");
				WIN::CloseHandle(hTokenPrimary);
				if (hServerResumeEvent != INVALID_HANDLE_VALUE)
					WIN::CloseHandle(hServerResumeEvent);
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
				m_CustomServerInfo.m_dwRemoteCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}

			// Check if the "user" is actually system. In that case, the registration code must
			// be ready to accept elevated servers when requesting impersonated servers.
			m_CustomServerInfo.m_fImpersonatedIsSystem = IsLocalSystemToken(hTokenUser);

			CElevate elevate;
			CSecurityDescription secdesc((PSID) SIDAccess[0].pSID, (PSID) NULL, SIDAccess, cSD);
			if (secdesc.isValid())
			{
				DWORD dwCreationFlags = NORMAL_PRIORITY_CLASS;
				void* pvCreationEnvironment = NULL;
				if (fClientOwned)
				{
					Assert(!g_fWin9X);
					dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
					pvCreationEnvironment = const_cast<void*>(reinterpret_cast<const void*>(pvEnvironment));
				}
				else if (MinimumPlatformWindows2000())
				{
					// on Win2K and greater, always grab a copy of the environment block to explicitly pass to
					// the Custom Action Server. This is to work around an OS bug where creating the CA server
					// in a different TS session does not correctly inherit the environment block of the service.
					dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
					if (STATUS_SUCCESS != NTDLL::RtlCreateEnvironment(TRUE, &pvCreationEnvironment))
					{
						DEBUGMSGV("Unable to duplicate environment block for child process.");
						WIN::CloseHandle(hTokenPrimary);
						if (hServerResumeEvent != INVALID_HANDLE_VALUE)
							WIN::CloseHandle(hServerResumeEvent);
						m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
						m_CustomServerInfo.m_dwRemoteCookie = 0;
						LeaveCriticalSection(&m_csCreateProxy);
						return NULL;
					}
				}

				// convert the command line from MsiString to char array to satisfy CreateProcess
				CTempBuffer<ICHAR, MAX_PATH> szCommandLine;
				szCommandLine.SetSize(strCommandLine.TextSize()+1);
				strCommandLine.CopyToBuf(szCommandLine, szCommandLine.GetSize());

				// this critical section prevents multiple processes from trying to register at once by blocking
				// in the registration call. It is used here to prevent ANY process from registering until the 
				// newly created process information is stored off correctly for use in validating the incoming 
				// registration call. This prevents a race condition between the new process registering and this
				// one being able to validate it.
				EnterCriticalSection(&m_csRegisterAction);

				fProcessCreated = ADVAPI32::CreateProcessAsUser(hTokenPrimary, strExecutable, szCommandLine, (LPSECURITY_ATTRIBUTES) secdesc, (LPSECURITY_ATTRIBUTES)0, FALSE,
					dwCreationFlags, pvCreationEnvironment, szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				
				if (!fProcessCreated)
				{
					DWORD dwLastError = GetLastError();
					DEBUGMSGV1(TEXT("Failed to create Custom Action Server. Error %d."), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(dwLastError)));
				}
				else
				{
					DEBUGMSGV2(TEXT("Created Custom Action Server with PID %d (0x%X)."), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(pi.dwProcessId)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(pi.dwProcessId)));
					m_CustomServerInfo.m_dwCAServerProcessId = pi.dwProcessId;
				}

				// once the process ID is stored off registration can proceed.
				LeaveCriticalSection(&m_csRegisterAction);

				// if the environment was cloned (not provided by the client), release it.
				if (!fClientOwned && pvCreationEnvironment)
				{
					NTDLL::RtlDestroyEnvironment(pvCreationEnvironment);
					pvCreationEnvironment=NULL;
				}
				
				if (fElevateCustomActionServer && fProcessCreated)
				{
					if (hTokenUser != INVALID_HANDLE_VALUE)
					{
						if (!SetThreadToken(&pi.hThread, hTokenUser))
						{
							DEBUGMSGV("Unable to set thread token in child process.");
							TerminateProcess(pi.hProcess, 0);
							WIN::CloseHandle(pi.hProcess);
							WIN::CloseHandle(hTokenPrimary);
							WIN::CloseHandle(hTokenUser);
							if (hServerResumeEvent != INVALID_HANDLE_VALUE)
								WIN::CloseHandle(hServerResumeEvent);
							m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
							m_CustomServerInfo.m_dwRemoteCookie = 0;
							LeaveCriticalSection(&m_csCreateProxy);
							return NULL;
						}
						WIN::CloseHandle(hTokenUser);
						hTokenUser = INVALID_HANDLE_VALUE;
					}
					
					// resume the suspended process
					if (!SetEvent(hServerResumeEvent))
					{
						// something bad happened...
						// we'll clean up the zombie process and return NULL
						AssertSz(0, "Unable to resume the suspended thread in CreateCustomActionProxy!");
						TerminateProcess(pi.hProcess, 0);
						WIN::CloseHandle(pi.hProcess);
						WIN::CloseHandle(hTokenPrimary);
						if (hServerResumeEvent != INVALID_HANDLE_VALUE)
							WIN::CloseHandle(hServerResumeEvent);
						m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
						m_CustomServerInfo.m_dwRemoteCookie = 0;
						LeaveCriticalSection(&m_csCreateProxy);
						return NULL;
					}
				}
				if (fProcessCreated)
				{
					WIN::CloseHandle(pi.hThread);
				}
			}
			else
			{
				AssertSz(0, "Created an invalid security descriptor in CreateCustomActionProxy!");
				if (hTokenUser != INVALID_HANDLE_VALUE)
					WIN::CloseHandle(hTokenUser);
				WIN::CloseHandle(hTokenPrimary);
				if (hServerResumeEvent != INVALID_HANDLE_VALUE)
					WIN::CloseHandle(hServerResumeEvent);
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
				m_CustomServerInfo.m_dwRemoteCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
			if (hTokenUser != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hTokenUser);
		}
		
		WIN::CloseHandle(hTokenPrimary);
		if (!fProcessCreated)
		{
			DEBUGMSGV("Failed to create Custom Action Server.");
			m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
			m_CustomServerInfo.m_dwRemoteCookie = 0;
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}
	}

    // wait until the custom action server checks back with us and is authenticated, or until it the child
    // process dies. Must pump messages here or we won't be able to handle incoming requests
    HANDLE rghWaitArray[2] = {pi.hProcess, m_hCARegistered};
    for(;;)
    {
        DWORD iWait = WIN::MsgWaitForMultipleObjects(2, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
        if (iWait == WAIT_OBJECT_0 + 2)
        {       
            // window message, need to pump until the queue is clear
            MSG msg;
            while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
            {
                WIN::TranslateMessage(&msg);
                WIN::DispatchMessage(&msg);
            }
            continue;
        }
        else if (iWait == WAIT_OBJECT_0 + 1)
        {
            // m_hCARegistered was signaled, registration was successful
            break;
        }
        else if (iWait == WAIT_OBJECT_0)
        {
            // because the process is first in the wait array, WAIT_OBJECT_0 means the
            // process died before it was authenticated. Close m_hCARegistered so
            // the registration function isn't left in a state where it will accept
            // an incoming server registration.
			DEBUGMSG("CA Server Process has terminated.");
            WIN::CloseHandle(m_hCARegistered);
            WIN::CloseHandle(pi.hProcess);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            m_hCARegistered = 0;
            m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
            m_CustomServerInfo.m_dwRemoteCookie = 0;
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }
        else if (iWait == 0xFFFFFFFF) // should be the same on 64bit;
        {
            // error
            AssertSz(0, "Error in MsgWait");
            WIN::CloseHandle(m_hCARegistered);
            WIN::CloseHandle(pi.hProcess);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            m_hCARegistered = 0;
            m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
            m_CustomServerInfo.m_dwRemoteCookie = 0;
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }
        else if (iWait == WAIT_TIMEOUT)
        {
            // our current wait period is forever, but if that changes, this could happen.
            DEBUGMSGV("Custom Action Server never connected to service.");
            WIN::CloseHandle(m_hCARegistered);
            WIN::CloseHandle(pi.hProcess);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            m_hCARegistered = 0;
            m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
            m_CustomServerInfo.m_dwRemoteCookie = 0;
            LeaveCriticalSection(&m_csCreateProxy);
            return 0;
        }
    }
    WIN::CloseHandle(m_hCARegistered);
	if (hServerResumeEvent != INVALID_HANDLE_VALUE)
		WIN::CloseHandle(hServerResumeEvent);
    m_hCARegistered = 0;

    // store the process handle. DO NOT close the handle. This ensures that the handle remains
    // valid even if the process dies, because a process id isn't reused until all process handles
    // have been released.
    if (phServerProcess)
        *phServerProcess = pi.hProcess;

    // and ProcessId
    if (pdwServerProcessId)
        *pdwServerProcessId = pi.dwProcessId;

    // RemoteAPI can be released from the GIT, the client process now has a refcount to keep it alive
    m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
    m_CustomServerInfo.m_dwRemoteCookie = 0;
    
    // if the caller wants the cookie, copy it to their provided buffer
    if (pcbCookie && rgchCookie && *pcbCookie >= iRemoteAPICookieSize)
    {
        *pcbCookie = iRemoteAPICookieSize;
        memcpy(rgchCookie, m_CustomServerInfo.m_rgchWaitingCookie, iRemoteAPICookieSize);
    }

    // grab the custom action interface, and then dispose of the entry in the GIT
    IMsiCustomAction* piCustomAction = NULL;
    m_piGIT->GetInterfaceFromGlobal(m_CustomServerInfo.m_dwGITCookie, IID_IMsiCustomAction, reinterpret_cast<void **>(&piCustomAction));
    m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwGITCookie);

    // don't need this GIT anymore
    m_piGIT->Release();
    m_piGIT = 0;
    m_CustomServerInfo.m_dwGITCookie = 0;
    
    LeaveCriticalSection(&m_csCreateProxy);
    return piCustomAction;
}

// destroys the custom action server in the ConfigManager, releasing any servers if necessary.
UINT CMsiConfigurationManager::ShutdownCustomActionServer()
{
    EnterCriticalSection(&m_csCreateProxy);
    if (m_pCustomActionManager)
    {
        m_pCustomActionManager->ShutdownCustomActionServer();
        delete m_pCustomActionManager;
        m_pCustomActionManager = 0;
    }
    LeaveCriticalSection(&m_csCreateProxy);
    return ERROR_SUCCESS;
};

// public interface call used to broker a request for a server between the client and the server.
// for security reasons, this call only accepts impersonated context requests.
UINT CMsiConfigurationManager::CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId,
    IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, 
	int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *dwServerProcessId)
{
    // fail immediately if any arguments are bad
    if (!piCustomAction || !piRemoteAPI || !rgchCookie || !cbCookie || !dwServerProcessId || !pvEnvironment)
        return ERROR_INVALID_PARAMETER;

    // if there won't be enough space for the cookie, fail immediately
    if (*cbCookie < iRemoteAPICookieSize)
        return ERROR_MORE_DATA;

    // clients are only allowed to create impersonated contexts
    if (icacContext != icac64Impersonated && icacContext != icac32Impersonated)
        return ERROR_ACCESS_DENIED;

	// verify that the environment block is doubly-null terminated
	if ((cchEnvironment < 2) ||
		(pvEnvironment[cchEnvironment-1] != L'\0') ||
		(pvEnvironment[cchEnvironment-2] != L'\0'))
		return ERROR_INVALID_PARAMETER;

	{
		// must impersonate the client to create the appropriate custom action server
		CCoImpersonate impersonate;	

		// because we are only creating an impersonated server, no remapping of HKCU is needed
		// since it will always be the right one
		
		// need to pass back processId of CA server for tracking by the client. Because the ProcessId could be 
		// reissued if the process dies, the client must ensure that the ProcessId is valid by verifying that
		// the custom action COM interface is still connected AFTER openining a process handle to the provided
		// process id. 
		if (piCustomAction)
			*piCustomAction = CreateCustomActionProxy(icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, dwPrivileges, rgchCookie, cbCookie, NULL, dwServerProcessId, true, /* fRemapHKCU = */ false);
	}

	return ERROR_SUCCESS;
}

// public interface call used by the server to register itself with the service (and thus indirectly the
// client if it is a brokered request). Only one context is active at a time, so incorming registration
// for a different context is immediately rejected. Context is verified by impersonating the client and
// checking the token, so the client must be making the call at Identify level or greater.
UINT CMsiConfigurationManager::RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction *piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD *pdwPrivileges)
{
    CCoImpersonate impersonate;

	if (!picacContext || !rgchCookie || !piCustomAction || !pdwProcessId || !piRemoteAPI || !pdwPrivileges)
		return ERROR_INVALID_PARAMETER;
    
    EnterCriticalSection(&m_csRegisterAction);

    // if we aren't expecting a server or already have the required registration, don't accept any more calls.
    if (!m_hCARegistered || m_CustomServerInfo.m_dwGITCookie)
    {
        DEBUGMSGV("Custom Action Server rejected - Invalid Context.");
        LeaveCriticalSection(&m_csRegisterAction);
        return ERROR_ACCESS_DENIED;
    }
	
	// check client PID if RPCRT4 exports the correct function OR if on WinXP
	// where function should exist.
	unsigned long ulPid = 0;
	HRESULT hRPCResult = RPCRT4::I_RpcBindingInqLocalClientPID(NULL, &ulPid);
	if ((hRPCResult != ERROR_CALL_NOT_IMPLEMENTED) || MinimumPlatformWindowsNT51())
	{
		if ((RPC_S_OK != hRPCResult) ||
			(ulPid != m_CustomServerInfo.m_dwCAServerProcessId))
		{
			DEBUGMSGV("Custom Action Server rejected - Unknown Process.");
			LeaveCriticalSection(&m_csRegisterAction);
			return ERROR_ACCESS_DENIED;
		}
	}
    
    // we must ensure that the process calling us is in the appropriate context. If we mix up 32 and 64 bit, nothing
    // bad will happen except that the install will fail. However we must ensure that we aren't registering a user
    // process as the elevated server. We do this by impersonating the client and then checking the token identity
    icacCustomActionContext icacTrueContext = icac32Impersonated;
    HANDLE hToken;
    if (WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
    {
        icacTrueContext = IsLocalSystemToken(hToken) ? icac32Elevated : icac32Impersonated;
        WIN::CloseHandle(hToken);
    }
	
	// if the client is localsystem, the CA server could be reporting itself as elevated when it is actually
	// filling the role of the impersonated server. In that scenario, these security checks are not applicable.
	// For non-client owned processes, we simply consolidate the impersonated server into the elevated server.
	if (!m_CustomServerInfo.m_fImpersonatedIsSystem)
	{
		if ((icacTrueContext == icac32Elevated     && (m_CustomServerInfo.m_icacWaitingContext == icac32Impersonated || m_CustomServerInfo.m_icacWaitingContext == icac64Impersonated)) ||
			(icacTrueContext == icac32Impersonated && (m_CustomServerInfo.m_icacWaitingContext == icac32Elevated     || m_CustomServerInfo.m_icacWaitingContext == icac64Elevated)))
		{
			DEBUGMSGV("Custom Action Server rejected - Mismatched Context.");
			LeaveCriticalSection(&m_csRegisterAction);
			return ERROR_ACCESS_DENIED;
		}
	
		// reconcile the desired context with what the process tells us it is
		if (*picacContext != m_CustomServerInfo.m_icacWaitingContext)
		{
			DEBUGMSGV("Custom Action Server rejected - Wrong Context.");
			LeaveCriticalSection(&m_csRegisterAction);
			return ERROR_ACCESS_DENIED;
		}
	}
    
    // the client process thinks that its our CustomActionServer. We need to validate the cookie to check
    // and then store this ICustomAction pointer for use in requesting objects off of it.
    if (cbCookie != iRemoteAPICookieSize)
    {
        DEBUGMSGV("Custom Action Server rejected - Invalid Cookie.");
        LeaveCriticalSection(&m_csRegisterAction);
        return ERROR_ACCESS_DENIED;
    }

    for (int iCookieByte = 0; iCookieByte < iRemoteAPICookieSize; iCookieByte++)
    {
        if (rgchCookie[iCookieByte] != m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte])
        {
            DEBUGMSGV("Custom Action Server rejected - Invalid Cookie.");
            LeaveCriticalSection(&m_csRegisterAction);
            return ERROR_ACCESS_DENIED;
        }
    }

    // another thread is waiting on the interface pointer to run the custom action,
    // but marshaled interface pointers are only valid inside the apartment that
    // the initial proxy is created in. The thread that spawned the CA process is blocked
    // waiting for the result, and is running in a different apartment. In order for
    // the proxy to be available to the blocked thread, it must be marshaled
    // by registering it in the COM GIT
    if ((m_piGIT == NULL) || (S_OK != m_piGIT->RegisterInterfaceInGlobal(piCustomAction, IID_IMsiCustomAction, &m_CustomServerInfo.m_dwGITCookie)))
    {
        LeaveCriticalSection(&m_csRegisterAction);
        return ERROR_FUNCTION_FAILED;
    }

    LPCSTR pszType = NULL;
    switch (m_CustomServerInfo.m_icacWaitingContext)
    {
        case icac32Impersonated:
            pszType = "32bit Impersonated";
            break;
        case icac32Elevated:
            pszType = "32bit Elevated";
            break;
        case icac64Impersonated:
            pszType = "64bit Impersonated";
            break;
        default:
            pszType = "64bit Elevated";
            break;
    }   
    DEBUGMSG1("Hello, I'm your %s custom action server.", pszType);

    // need to return the RemoteAPI, Privileges and the ProcessId to the client at this point
	*pdwProcessId = m_CustomServerInfo.m_dwProcessId;
	*pdwPrivileges = m_CustomServerInfo.m_dwPrivileges;
	if (S_OK != m_piGIT->GetInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie, IID_IMsiRemoteAPI, reinterpret_cast<void **>(piRemoteAPI)))
	{
		m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwGITCookie);
		m_CustomServerInfo.m_dwGITCookie = 0;
		LeaveCriticalSection(&m_csRegisterAction);
		return ERROR_FUNCTION_FAILED;
	}

	// if the client is localsystem, the CA server could be reporting itself as elevated when it is actually
	// filling the role of the impersonated server for the client. In that scenario, inform the CA server of its true job.
	if (m_CustomServerInfo.m_fImpersonatedIsSystem)
	{
		if (m_CustomServerInfo.m_icacWaitingContext == icac32Impersonated && *picacContext == icac32Elevated)
		{
			*picacContext = icac32Impersonated;
		}
		else if (m_CustomServerInfo.m_icacWaitingContext == icac64Impersonated && *picacContext == icac64Elevated)
			*picacContext = icac64Impersonated;
	}

    // wake up the main thread that is trying to run the custom action
    AssertNonZero(SetEvent(m_hCARegistered));
    LeaveCriticalSection(&m_csRegisterAction);

    return ERROR_SUCCESS;
}

// create a custom action manager if needed
// this function might be called by more than one thread, so it has to ensure that
// we never end up with more than one manager
void CMsiConfigurationManager::CreateCustomActionManager(bool fRemapHKCU)
{
	// script execution could occur more than once (install script, then rollback script), etc
	// so the custom action manager might have already been created.  there's nothing wrong with that
	EnterCriticalSection(&m_csCreateProxy);
	if (!m_pCustomActionManager)
		m_pCustomActionManager = new CMsiCustomActionManager(fRemapHKCU);
	LeaveCriticalSection(&m_csCreateProxy);
}

// returns the existing custom action manager object
CMsiCustomActionManager* CMsiConfigurationManager::GetCustomActionManager()
{
	AssertSz(m_pCustomActionManager, TEXT("Custom action manager has not yet been created!!"));
	return m_pCustomActionManager;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\imemory.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       imemory.cpp
//
//--------------------------------------------------------------------------

//
// File: imemory.cpp
// Purpose: CMsiMalloc implementation
// Owner: davidmck
// Notes:
//
//CMsiMalloc: Memory handling object


#include "precomp.h"
#include "services.h"
#include "imemory.h"
#include <typeinfo.h>
#include <stdlib.h>
#include "_service.h"

#ifdef DEBUG
#include "imagehlp.h"
#endif 

CRITICAL_SECTION vcsHeap;

//____________________________________________________________________________
//
// CMsiMalloc definition - here so this can be a member of services
//____________________________________________________________________________

#ifdef DEBUG

#define cBlockBuckets		512
#define cSkipBits			7		// Bits to skip for hashing
#define cHashBits			9		// Bits to use for hashing
#define maskHashBits		0x1ff

#define cDeadSpace	4

#define cFuncTrace	5

typedef struct _MBH	{			// Memory block header
	unsigned long	rgaddr[cFuncTrace];	// Address from which the allocation occurred
	struct _MBH *pmbhNext;		// Linked list of memory blocks
	const type_info *pti;		// Pointer to the type_info block that
					// this object is the type of. 0 if not object
	long cbAlloc;		// Size of the allocation
	long lRequest;		// Which memory allocation was this
	BOOL fObject;		// Is this an object with a vtable to be faked
					// at free time
	BOOL fRTTI;			// Can we look at the RTTI info for this object
	BOOL fLeakReported;	// Has an error already been reported
	BOOL fCorruptionReported;	// Has a corruption error been reported
	unsigned long lDeadSpace[cDeadSpace];// Longs to buffer the header from the memory
					// Used by darwin
	} MBH;
#endif //DEBUG

class CMsiMalloc : 
				public IMsiMalloc
#ifdef DEBUG
				, public IMsiDebugMalloc
#endif //DEBUG
				
{
 public:   // implemented virtual functions
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	void*         	__stdcall Alloc(unsigned long cb);
	void*         	__stdcall AllocObject(unsigned long cb);
	void          	__stdcall Free(void* pv);
	void			__stdcall FreeObject(void *pv);
	void*         	__stdcall AllocEx(unsigned long cb, unsigned long *plAddr);
	void*         	__stdcall AllocObjectEx(unsigned long cb, unsigned long *plAddr, bool fRTTI);
	void			__stdcall FreeAllocator();
	void            __stdcall HandleOutOfMemory();
#ifdef DEBUG
	BOOL			__stdcall FAllBlocksFreed(void);
 public:	// implemented in IMsiDebugMalloc
	void		    __stdcall SetDebugFlags(int gpfMemDebug);
	void		  	__stdcall ReturnBlockInfoPv(void *pv, TCHAR *pszInfo, int cchSzInfo);
	BOOL			__stdcall FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, size_t cchFnName, unsigned long *pdwDisp);
	BOOL			__stdcall FCheckBlock(void *pv);
	int		   	 	__stdcall GetDebugFlags();
	BOOL			__stdcall FCheckAllBlocks();
	unsigned long	__stdcall GetSizeOfBlock(void *pv);
#endif //DEBUG
	
 public:  // constructor/destructor
	CMsiMalloc();
#ifdef DEBUG
	~CMsiMalloc();
#endif //DEBUG
  	void *operator new(size_t cb) { return AllocSpc(cb); }
 	void operator delete(void *pv) {FreeSpc(pv); }
	BOOL	m_fInitHeap;
#ifdef DEBUG
 	BOOL	m_fKeepMemory;		// Do we keep the freed memory around
 	BOOL	m_fLogAllocs;		// Do we log allocations
 	BOOL	m_fCheckOnAlloc;	// Do we check all current blocks when allocating a new one
 	BOOL	m_fCheckOnFree;		// Do we check all current blocks when freeing a block
 	bool	m_fNoPreflightInit;	// True when we don't want to initialize before we need it.
#endif //DEBUG
protected:	// State data
	int     m_iRefCnt;
#ifdef DEBUG
 	MBH*	m_pmbhFreed;		// Pointer to the free list
 	long	m_lcbTotal;			// Total memory allocated
 	long	m_cBlocksCur;		// How many blocks are currently allocated
 	long	m_cBlocksTotal;		// How many blocks have we allocated since start
#endif //DEBUG 	
private:
#ifdef DEBUG
					// Removes the block of memory from the linked list. 
					// Returns true if it found it
	BOOL			FRemoveBlock(MBH* pmbh);	 
	BOOL			FWasFreed(MBH *pmbh);
	void			__stdcall FreeProc(void *pv, unsigned long *lAddr, bool fObject);
	void*			__stdcall AllocProc(unsigned long cb, unsigned long *plAddr);
	void			__stdcall ReturnBlockInfo(MBH *pmbh, TCHAR *szInfo, int cch);
	void			__stdcall SzFromFunctionAddress(TCHAR *szAddress, size_t cchAddress, long lAddress);
	BOOL			__stdcall FCheckMbh(MBH *pmbh);
	BOOL			__stdcall FIsAllocatedBlock(MBH *pmbh);
	void			__stdcall DisplayBlockInfo(MBH *pmbh, const TCHAR *szTitle);
	void 			InitSymbolInfo(bool fLoadModules);
	short			IHashValue(void *);
	void			InsertInMemList(MBH* pmbh);
	CRITICAL_SECTION m_crsMemAccess;
	MBH*	m_rgpmbhBlocks[cBlockBuckets];		// Array of hash buckets
#else
	void			__stdcall FreeProc(void *pv);
	void*			__stdcall AllocProc(unsigned long cb);
#endif //DEBUG
};	

#ifdef DEBUG
static BOOL (__stdcall *pfnMemAlloc)(void** ppMem, int cb);
#else
static BOOL (__stdcall *pfnMemAlloc)(void** ppMem, int cb);
#endif // DEBUG
static void (__stdcall *pfnMemFree)(void* pMem);

BOOL __stdcall HeapMemAlloc(void** ppMem, int cb)
{
	*ppMem = AllocSpc(cb);
	return *ppMem != NULL ? TRUE : FALSE;
}

void __stdcall HeapMemFree(void* pMem)
{
	FreeSpc(pMem);
}

const int cchTempBuffer = 256;  

#ifdef DEBUG

BOOL FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, size_t cchFnName, unsigned long *pdwDisp);
void FreedClassWarning( void *pThis );
int IClassFromPmbh(MBH *pmbh);

#define lFreeSpaceCnst	0xdeadf00dUL
#define lDeadSpaceCnst	0xdedededeUL
#define lNewSpaceCnst	0xa5

#define cbMBH	(sizeof(MBH))

#define cpfnMax		100
LONG_PTR rgpfnFake[cpfnMax];		//--merced: changed long to LONG_PTR

//
// A list of object classes in order from outer-most to inner-most
// in general, if class A appears before class B, class A adds a reference
// to class B.
//
char *rgszClasses[] = {
		"CMsiCursor",
		"CMsiView",
		"CMsiTable",
		"CCatalogTable",
		"CMsiDatabase",
		"CMsiStorage",
		"CMsiRecord",
		"CMsiRegKey",
		"CMsiString",
		"CMsiStringRef"
};

#define cClasses	(sizeof(rgszClasses)/sizeof(char *))

#else
#define cbMBH	0
// Free proc has only 1 parameter in ship
#define FreeProc(x, y, f)	FreeProc(x)
#define AllocProc(x, y)	AllocProc(x)
#endif //DEBUG

Debug(CMsiDebug vDebug;)
CMsiMalloc	vMalloc;
#ifdef TRACK_OBJECTS
CMsiRefHead g_refHead;
#endif //TRACK_OBJECTS

extern IMsiMalloc *piMalloc;

#ifdef DEBUG
BOOL FCheckAllBlocks()
{
	return vMalloc.FAllBlocksFreed();
}
#endif //DEBUG

void InitializeMsiMalloc()
{
	vMalloc.AddRef();
	piMalloc = &vMalloc;

#ifdef DEBUG

	vMalloc.m_fKeepMemory = GetTestFlag('K');
	vMalloc.m_fLogAllocs = GetTestFlag('M');
	vMalloc.m_fCheckOnAlloc = GetTestFlag('A');
	vMalloc.m_fCheckOnFree = GetTestFlag('F');
	g_fNoPreflightInits = vMalloc.m_fNoPreflightInit = true;

#endif //DEBUG
	if (!vMalloc.m_fInitHeap)
	{
		InitializeCriticalSection(&vcsHeap);
		vMalloc.m_fInitHeap = true;
		pfnMemAlloc = HeapMemAlloc;
		pfnMemFree = HeapMemFree;
	}

}

void FreeMsiMalloc(bool fFatalExit)
{

	if (!fFatalExit)
		vMalloc.Release();
	else
	{
		vMalloc.FreeAllocator();
	}

}

//
// This is an emergency situation
//
void CMsiMalloc::FreeAllocator()
{
	KillRecordCache(fTrue);
#ifdef DEBUG
	int i;
	for ( i = 0 ; i < cBlockBuckets ; i++)
		m_rgpmbhBlocks[i] = 0;
#endif //DEBUG
	m_iRefCnt = 0;
	if (m_fInitHeap)
	{
		DeleteCriticalSection(&vcsHeap);
		m_fInitHeap = false;
	}
	piMalloc = 0;
	
}

CMsiMalloc::CMsiMalloc()
#ifdef DEBUG
: m_lcbTotal(0), m_cBlocksCur(0), 
	m_cBlocksTotal(0), m_fKeepMemory(0),
	m_pmbhFreed(0)
#endif //DEBUG
{
#ifdef DEBUG
	for (int i = 0 ; i < cpfnMax ; i++)
		rgpfnFake[i] = (LONG_PTR)FreedClassWarning;	//--merced: changed long to LONG_PTR
	InitializeCriticalSection(&m_crsMemAccess);

	for ( i = 0 ; i < cBlockBuckets ; i++)
		m_rgpmbhBlocks[i] = 0;

#endif //DEBUG

	m_fInitHeap = false;
	m_iRefCnt = 0;
}

#ifdef DEBUG
CMsiMalloc::~CMsiMalloc()
{

	// Need to do this because services has gone away
	g_AssertServices = 0;

	if (m_iRefCnt > 0)
	{
		if ( g_scServerContext == scService )  //!! eugend: temporary hack till I figure out how to fix 138538
			FAllBlocksFreed();
	}
	else if (m_iRefCnt < 0)
		AssertSz(false, "CMsiMalloc released too many times");

	g_fFlushDebugLog = false;
	extern int g_rcRows;
	Assert(g_rcRows == 0);
	DeleteCriticalSection(&m_crsMemAccess);
	
}
#endif //DEBUG


HRESULT CMsiMalloc::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiMalloc)
		*ppvObj = (IMsiMalloc *)this;
#ifdef DEBUG
	else if (riid == IID_IMsiDebugMalloc)
		*ppvObj = (IMsiDebugMalloc*)this;
#endif //DEBUG
	else
		return (*ppvObj = 0, E_NOINTERFACE);
	AddRef();
	return NOERROR;
}

unsigned long CMsiMalloc::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiMalloc::Release()
{
#ifdef DEBUG
	if (!m_fNoPreflightInit)
		InitSymbolInfo(false);
#endif //DEBUG
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	Debug(FAllBlocksFreed();)
	if (m_fInitHeap)
	{
		DeleteCriticalSection(&vcsHeap);
		m_fInitHeap = false;
	}
	piMalloc = 0;
	return 0;
}

/*********************************************************
*
* Alloc allocates the memory and sets it to 0
*
**********************************************************/
void * CMsiMalloc::Alloc(unsigned long cb)
{
	Debug(GetCallingAddrMember(lCallAddr, cb));

	return AllocProc(cb, lCallAddr);
}

#pragma warning(disable : 4100) // unreferenced formal parameter
void * CMsiMalloc::AllocEx(unsigned long cb, unsigned long *plCallAddr)
{

	return AllocProc(cb, plCallAddr);
}
#pragma warning(3 : 4100)

void * CMsiMalloc::AllocProc(unsigned long cb, unsigned long *plCallAddr)
{
	void *pbNew;

	AssertSz(m_fInitHeap, "Allocator not initialized");

#ifdef DEBUG
	int cbOrig = cb;

	EnterCriticalSection(&m_crsMemAccess);
	cb += sizeof(MBH) + cDeadSpace * sizeof(long);

	if (m_fCheckOnAlloc)
		FCheckAllBlocks();
#endif //DEBUG

	void* pv;

	while (!pfnMemAlloc(&pv, cb))
	{
		::HandleOutOfMemory();
	}

	pbNew = pv;

#ifdef DEBUG
	MBH *pmbh;

	if (pbNew != 0)
	{
		unsigned long UNALIGNED *plFill, *plFillMax;
				
		// Keep up the linked list in the allocator
		pmbh = (MBH *)pbNew;
		pmbh->pti = 0;
		pmbh->cbAlloc = cbOrig;
		pmbh->lRequest = m_cBlocksTotal;
		FillCallStackFromAddr(pmbh->rgaddr, cFuncTrace, 0, plCallAddr);
		pmbh->fObject = false;
		pmbh->fLeakReported = false;
		pmbh->fCorruptionReported = false;
		pmbh->fRTTI = false;
		
		// Fill the space at the front of the block
		for (plFill = &(pmbh->lDeadSpace[0]), 
				plFillMax = plFill + 4;
				plFill < plFillMax ; plFill++)
		{
			*plFill = lDeadSpaceCnst;
		}
		memset((char *)pbNew + cbMBH, lNewSpaceCnst, cbOrig);
			
		for (plFill = (unsigned long *)((char *)pmbh + sizeof(MBH) + cbOrig),
				plFillMax = plFill + cDeadSpace ;
				plFill < plFillMax ;
				plFill++)
		{
			*plFill = lDeadSpaceCnst;
		}

		InsertInMemList(pmbh);

		pbNew = (char *)pbNew + sizeof(MBH);
		m_lcbTotal += cbOrig;
		m_cBlocksCur++;
		m_cBlocksTotal++;

	}

	if (m_fLogAllocs)
	{
		TCHAR szMessage[1024];
#define cCallStackLog	5
		unsigned long rgCallAddr[cCallStackLog];
		
		FillCallStackFromAddr(rgCallAddr, cCallStackLog, 0, plCallAddr);
		
		StringCchPrintf(szMessage, sizeof(szMessage)/sizeof(TCHAR), TEXT("Allocation -\t%d\tbytes. Memory Address - \t0x%x\t"),
				cbOrig, pbNew);		
				
		ListSzFromRgpaddr(szMessage, sizeof(szMessage)/sizeof(TCHAR) - lstrlen(szMessage), rgCallAddr, cCallStackLog, false);

		extern IMsiDebug* g_piDebugServices;
		if (g_AssertServices && g_AssertServices->LoggingEnabled())
			g_AssertServices->WriteLog(szMessage);
		else if(g_piDebugServices)
			g_piDebugServices->WriteLog(szMessage);

	}
	LeaveCriticalSection(&m_crsMemAccess);
#endif //DEBUG

	return pbNew;
}

void *CMsiMalloc::AllocObject(unsigned long cb)
{
	Debug(GetCallingAddrMember(lAddr, cb));
	
	void *pvNew = AllocProc(cb, lAddr);

#ifdef DEBUG
	if (pvNew != 0)
	{
		MBH *pmbhNew = (MBH *)((char *)pvNew - cbMBH);

		pmbhNew->fObject = true;
		pmbhNew->fRTTI = false;
	}
#endif //DEBUG
	return pvNew;

}

#pragma warning(disable : 4100) // unreferenced formal parameter
void *CMsiMalloc::AllocObjectEx(unsigned long cb, unsigned long *plAddr, bool fRTTI)
{
	
	void *pvNew = AllocProc(cb, plAddr);

#ifdef DEBUG
	if (pvNew != 0)
	{
		MBH *pmbhNew = (MBH *)((char *)pvNew - cbMBH);

		pmbhNew->fObject = true;
		pmbhNew->fRTTI = fRTTI;
	}
#endif //DEBUG
	return pvNew;

}
#pragma warning(3 : 4100)

void CMsiMalloc::Free(void* pv)
{
#ifdef DEBUG
	GetCallingAddrMember(lCallAddr, pv);
#endif //DEBUG
	FreeProc(pv, lCallAddr, false);
}

//
// FreeObject
//
void CMsiMalloc::FreeObject(void* pv)
{
	
#ifdef DEBUG
	GetCallingAddrMember(lCallAddr, pv);
#endif //DEBUG
	FreeProc(pv, lCallAddr, true);
}

//
// FreeProc -
// Routine to do the freeing, allows Free and Free Object to
// do their thing
//
void CMsiMalloc::FreeProc(void *pv, unsigned long * lAddr, bool fObject)
{
#ifdef DEBUG
	MBH *pmbh;
	unsigned long *plFill, *plFillMax;

	if ((ULONG_PTR)pv < sizeof(MBH))		//--merced: changed unsigned long to ULONG_PTR
	{
		AssertSz(false, "Invalid Pointer");
		return;
	}
			
	pmbh = (MBH *)(((char *)pv) - sizeof(MBH));

	if (m_fLogAllocs)
	{
		TCHAR szMessage[2048];
		TCHAR szInfo[1024];
		unsigned long rgCallAddr[cCallStackLog];
		
		FillCallStackFromAddr(rgCallAddr, cCallStackLog, 0, lAddr);

		szInfo[0] = 0;
		StringCchPrintf(szMessage, sizeof(szMessage)/sizeof(TCHAR), TEXT("Freeing memory \t%s\t Address\t0x%x\t"), szInfo, pv);		
				
		ListSzFromRgpaddr(szMessage, sizeof(szMessage)/sizeof(TCHAR) - lstrlen(szMessage), rgCallAddr, cCallStackLog, false);

		extern IMsiDebug* g_piDebugServices;
		if (g_AssertServices && g_AssertServices->LoggingEnabled())
			g_AssertServices->WriteLog(szMessage);
		else if(g_piDebugServices)
			g_piDebugServices->WriteLog(szMessage);

	}

	EnterCriticalSection(&m_crsMemAccess);
	
	if (!FRemoveBlock(pmbh))
		{
		if (FWasFreed(pmbh))
			{
			TCHAR szMessage[1024];
			StringCchPrintf(szMessage, sizeof(szMessage)/sizeof(TCHAR),TEXT("Memory doubly freed from 0x%08x"), pmbh->lDeadSpace[0]);
			AssertSz(false, szMessage);
			}
		else
			AssertSz(false, "Invalid block to Free");
		LeaveCriticalSection(&m_crsMemAccess);
		return;
		}

	if (fObject)
		AssertSz(pmbh->fObject, "Non-object freed by Object call");
	else
		AssertSz(!pmbh->fObject, "Object freed by non-object free");

	Assert(FCheckMbh(pmbh));
			
	if (m_fCheckOnFree)
		FCheckAllBlocks();
		
	// Reduce the totals for count of bytes allocated and count of
	// allocated blocks
	m_lcbTotal -= pmbh->cbAlloc;
	m_cBlocksCur--;

	if (fObject && pmbh->fRTTI)
		pmbh->pti = &(typeid(*(IUnknown *)pv));
	
	// Fill up memory with garbage
	for (plFill = (unsigned long *)((char *)pmbh + sizeof(MBH)),
			plFillMax = plFill + (pmbh->cbAlloc/sizeof(unsigned long));
			plFill < plFillMax;
			plFill++)
	{
		*plFill = lFreeSpaceCnst;
	}

	pmbh->pmbhNext = 0;	

	LeaveCriticalSection(&m_crsMemAccess);

	void *pvtbl = pv;

	if (fObject)
		*(LONG_PTR *)pvtbl = (LONG_PTR)&rgpfnFake;		//--merced: changed from long to LONG_PTR (twice)
	
	if (m_fKeepMemory)
	{
		// In this case we don't want to actually free the memory
		pmbh->pmbhNext = m_pmbhFreed;
		m_pmbhFreed = pmbh;
		pmbh->lDeadSpace[0] = *lAddr;
		return;
	}		

	pv = pmbh;
#endif //DEBUG
	
	pfnMemFree(pv);
}

void CMsiMalloc::HandleOutOfMemory()
{
	::HandleOutOfMemory();
}

#ifdef DEBUG
/**************************************************
*
* CMsiMalloc::FRemoveBlock
* Scans the linked list to find the block of memory
*
**************************************************/
BOOL CMsiMalloc::FRemoveBlock(MBH* pmbh)
{
	MBH *pmbhCur;
	MBH **ppmbhOld;

	int iHash = IHashValue(pmbh);
	pmbhCur = m_rgpmbhBlocks[iHash];
	ppmbhOld = &(m_rgpmbhBlocks[iHash]);

	while (pmbhCur != 0)
	{
		if (pmbhCur == pmbh)
		{
			*ppmbhOld = pmbhCur->pmbhNext;
			return true;
		}
		ppmbhOld = &(pmbhCur->pmbhNext);
		pmbhCur = pmbhCur->pmbhNext;
	}

	return false;

}

//
// Returns true if the memory is in the free pool
//
BOOL CMsiMalloc::FWasFreed(MBH* pmbh)
{
	MBH *pmbhCur;

	pmbhCur = m_pmbhFreed;

	while (pmbhCur != 0)
	{
		if (pmbhCur == pmbh)
		{
			return true;
		}
		pmbhCur = pmbhCur->pmbhNext;
	}

	return false;

}


void CMsiMalloc::SetDebugFlags(int grpfMemDebug)
{

	m_fKeepMemory = (grpfMemDebug & bfKeepMem);
	m_fLogAllocs = (grpfMemDebug & bfLogAllocs);
	m_fCheckOnAlloc = (grpfMemDebug & bfCheckOnAlloc);
	m_fCheckOnFree = (grpfMemDebug & bfCheckOnFree);
	g_fNoPreflightInits = m_fNoPreflightInit = ((grpfMemDebug & bfNoPreflightInit) ? true : false);


}

int CMsiMalloc::GetDebugFlags(void)
{
	int t = 0;

	if (m_fKeepMemory)
		t |= bfKeepMem;

	if (m_fLogAllocs)
		t |= bfLogAllocs;

	if (m_fCheckOnAlloc)
		t |= bfCheckOnAlloc;

	if (m_fCheckOnFree)
		t |= bfCheckOnFree;

	return t;
	
}

void CMsiMalloc::InitSymbolInfo(bool fLoadModules)
{
	::InitSymbolInfo(fLoadModules);
}

BOOL CMsiMalloc::FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, size_t cchFnName, unsigned long *pdwDisp)
{
	::FGetFunctionNameFromAddr(lAddr, pszFnName, cchFnName, pdwDisp);

	return false;

}

//
// Searches the rgszClasses array for the class that pmbh is a member of
//
int IClassFromPmbh(MBH *pmbh)
{
	int i;
	const char *pstName;
	
	if (pmbh->fObject && pmbh->fRTTI)
		{
		const type_info& rtyp = typeid(*(IUnknown *)((char *)pmbh + cbMBH));
		pstName = rtyp.name();
		}
	else
		{
		pstName = "class Unknown";
		if (pmbh->pti != 0)
			pstName = pmbh->pti->name();
		}


	for (i = 0 ; i < cClasses ; i++)
	{
		// Skip over the "class " part of the string
		if (!lstrcmpA(pstName+6, rgszClasses[i]))
			break;
	}

	return i;
}

BOOL CMsiMalloc::FAllBlocksFreed()
{
	MBH *pmbh;
	int rgcLeft[cClasses + 1];
	int iClass;
	TCHAR rgchMsg[(cClasses + 2) * 50];	
	TCHAR *pchMsg;
	size_t ich = 0;
	bool fHaveLeak = false;
	
	//
	// First give a general list of all the blocks left over
	//
	memset(rgcLeft, 0, sizeof(rgcLeft));

	int i;
	
	for (i = 0 ; i < cBlockBuckets ; i++)
	{
		pmbh = m_rgpmbhBlocks[i];

		if (pmbh != 0)
			fHaveLeak = true;
			
		while (pmbh != 0)
		{
			iClass = IClassFromPmbh(pmbh);					
			rgcLeft[iClass]++;
			pmbh = pmbh->pmbhNext;
		}
	}

	if (fHaveLeak)
	{
		
		StringCchPrintf(rgchMsg, sizeof(rgchMsg)/sizeof(TCHAR), TEXT("Leaked Objects:"));
		StringCchLength(rgchMsg, sizeof(rgchMsg)/sizeof(TCHAR), &ich);
		pchMsg = rgchMsg + ich;
		for (iClass = 0 ; iClass < cClasses ; iClass++)
		{
			if (rgcLeft[iClass] == 0)
				continue;
			StringCchPrintf(pchMsg, (sizeof(rgchMsg)/sizeof(TCHAR)-ich), TEXT("\r\n%30hs \t-%3d"), rgszClasses[iClass], rgcLeft[iClass]);
			StringCchLength(rgchMsg, sizeof(rgchMsg)/sizeof(TCHAR), &ich);
			pchMsg = rgchMsg + ich;
		}
		StringCchPrintf(pchMsg, (sizeof(rgchMsg)/sizeof(TCHAR) - ich), TEXT("\r\n%30s \t-%3d"), TEXT("Unknown"), rgcLeft[iClass]);
//		FailAssertMsg(rgchMsg);
		OutputDebugString(rgchMsg);
		OutputDebugString(TEXT("\r\n"));
	}

	
	// Need to check that all blocks were freed
	fHaveLeak = false;
	for (i = 0 ; i < cBlockBuckets ; i++)
	{
		pmbh = m_rgpmbhBlocks[i];

		while (pmbh != 0)
		{
			fHaveLeak = true;
			if (!pmbh->fLeakReported)
			{
				DisplayBlockInfo(pmbh, (const TCHAR *)TEXT("Memory leak"));
				pmbh->fLeakReported = true;
			}
			pmbh = pmbh->pmbhNext;
		}

	}

	return !fHaveLeak;
}

//
// Routine to display information about the passed in block
//
void CMsiMalloc::DisplayBlockInfo(MBH *pmbh, const TCHAR *szTitle)
{
	TCHAR szMsg[cchTempBuffer * 5];
	TCHAR szInfo[cchTempBuffer * 5];
	TCHAR *pch;
	
	ReturnBlockInfo(pmbh, szInfo, sizeof(szInfo)/sizeof(TCHAR));

	if (lstrlen(szTitle) + lstrlen(szInfo) + 3 > sizeof(szMsg)/sizeof(TCHAR))
		pch = szInfo;
	else
	{
		StringCchPrintf(szMsg, sizeof(szMsg)/sizeof(TCHAR), TEXT("%s\r\n%s"), szTitle, szInfo);
		pch = szMsg;
	}  
//	FailAssertMsg(pch);
	OutputDebugString(pch);
	OutputDebugString(TEXT("\r\n"));
}

void CMsiMalloc::ReturnBlockInfoPv(void *pv, TCHAR *pszInfo, int cchSzInfo)
{
	MBH *pmbh;

	pmbh = (MBH *)(((char *)pv) - cbMBH);
	
	ReturnBlockInfo(pmbh, pszInfo, cchSzInfo);

}

void CMsiMalloc::ReturnBlockInfo(MBH *pmbh, TCHAR *szInfo, int cchSzInfo)
{
	const IMsiString *piString;
	const char *pstName;
	const TCHAR *pchString;
	MEMORY_BASIC_INFORMATION memInfo;

	BOOL fSaveLog = m_fLogAllocs;
	m_fLogAllocs = false;
	
	if (pmbh->fObject && pmbh->fRTTI)
		{
		IMsiData *pData = 0;
		IMsiRecord *pRec = 0;
		
		pRec = dynamic_cast<IMsiRecord *>((IUnknown *)((char *)pmbh + cbMBH));
		if (pRec != 0 && g_AssertServices != 0)
		{
			const IMsiString& riString = pRec->FormatText(fTrue);
			piString = &riString;
		}
		else
		{
			pData = dynamic_cast<IMsiData *>((IUnknown *)((char *)pmbh + cbMBH));
			if (pData != 0)
			{
				piString = &pData->GetMsiStringValue();
				VirtualQuery((void *)piString, &memInfo, sizeof(memInfo));
				if (memInfo.State == MEM_FREE)
					piString = MsiString(*TEXT(""));	
			}
			else
				piString = MsiString(*TEXT(""));	
		}
		const type_info& rtyp = typeid(*(IUnknown *)((char *)pmbh + cbMBH));
		pstName = rtyp.name();
		}
	else
		{
		piString = MsiString(*TEXT(""));
		pstName = "Unknown";
		if (pmbh->pti != 0)
			pstName = pmbh->pti->name();
		}

	TCHAR szAddress[cchTempBuffer * cFuncTrace];

	szAddress[0] = 0;
	ListSzFromRgpaddr(szAddress, sizeof(szAddress)/sizeof(TCHAR), pmbh->rgaddr, cFuncTrace, true);
	pchString = piString->GetString();

	// For some odd reason we are getting freed memory pages in here
	VirtualQuery(pchString, &memInfo, sizeof(memInfo));
	if (memInfo.State == MEM_FREE)
		pchString = TEXT("");

	static const TCHAR pvFormat[] = TEXT("%d bytes at 0x%x allocated from:\r\n%sObject type:%hs\r\nObject string: [%s]\r\nAllocation Request: %d");

	// See if we are small enough to fit in the string, assume that the address is 8 characters,
	// the size is 6 characters, the request number is 6 characters
	if ((sizeof(pvFormat)/sizeof(TCHAR) + 6 + 8 + lstrlen(szAddress) + lstrlenA(pstName) + lstrlen(pchString) + 6)
			> cchSzInfo)
	{
		// If not large enough, assume that we have enough space without the list of addresses
		szAddress[0] = 0;
	}
	
	StringCchPrintf(szInfo, cchSzInfo, pvFormat, 
					pmbh->cbAlloc, ((char *)pmbh) + cbMBH, szAddress, 
					pstName, pchString, pmbh->lRequest);

	piString->Release();
	m_fLogAllocs = fSaveLog;
}

void CMsiMalloc::SzFromFunctionAddress(TCHAR *szAddress, size_t cchAddress, long lAddress)
{
	::SzFromFunctionAddress(szAddress, cchAddress, lAddress);
}

BOOL CMsiMalloc::FCheckMbh(MBH *pmbh)
{
	unsigned long UNALIGNED *plFill, *plFillMax;

	// Ensure that the dead space has not been trashed in front
	for (plFill = &(pmbh->lDeadSpace[0]), 
			plFillMax = plFill + 4;
			plFill < plFillMax ; plFill++)
	{
		if (*plFill != lDeadSpaceCnst)
			return false;
	}

	// ... in back
	for (plFill = (unsigned long *)((char *)pmbh + sizeof(MBH) + pmbh->cbAlloc),
			plFillMax = plFill + cDeadSpace ;
			plFill < plFillMax ;
			plFill++)
	{
		if (*plFill != lDeadSpaceCnst)
			return false;
	}

	return true;
}


BOOL CMsiMalloc::FCheckBlock(void *pv)
{
	MBH *pmbh;

	if ((ULONG_PTR)pv < sizeof(MBH))		//--merced: changed unsigned long to ULONG_PTR
	{
		return false;
	}
			
	pv = ((char *)pv) - sizeof(MBH);
	pmbh = (MBH *)pv;

	if (!FIsAllocatedBlock(pmbh))
		return false;

	return FCheckMbh(pmbh);
	
}

unsigned long CMsiMalloc::GetSizeOfBlock(void *pv)
{
	MBH *pmbh;

	if ((ULONG_PTR)pv < sizeof(MBH))	//--merced: changed unsigned long to ULONG_PTR
	{
		return 0;
	}
			
	pv = ((char *)pv) - sizeof(MBH);
	pmbh = (MBH *)pv;

	if (!FIsAllocatedBlock(pmbh))
		return 0;

	return pmbh->cbAlloc;
	
}

//
// Returns true if this is actually an allocated block from
// our memory allocation
//
BOOL CMsiMalloc::FIsAllocatedBlock(MBH *pmbh)
{
	MBH *pmbhCur;

	int iHash = IHashValue(pmbh);
	pmbhCur = m_rgpmbhBlocks[iHash];

	while (pmbhCur != 0)
	{
		if (pmbhCur == pmbh)
		{
			return true;
		}
		pmbhCur = pmbhCur->pmbhNext;
	}

	return false;

}

BOOL CMsiMalloc::FCheckAllBlocks(void)
{
	MBH *pmbhCur;
	BOOL fAllOk = true;
	
	int i;

	for (i = 0 ; i < cBlockBuckets ; i++)
	{
		pmbhCur = m_rgpmbhBlocks[i];

		while (pmbhCur != 0)
		{
			if (!pmbhCur->fCorruptionReported && !FCheckMbh(pmbhCur))
			{
				fAllOk = false;
				DisplayBlockInfo(pmbhCur, TEXT("Memory Corrupt"));
				pmbhCur->fCorruptionReported = true;
			}
			pmbhCur = pmbhCur->pmbhNext;
		}
	}
	
	return fAllOk;

}

//
// Calculates the hash value for a given pointer value
//
short CMsiMalloc::IHashValue(void *pv)
{
	short ival;
	long	bits;

	bits = ((LONG_PTR)pv) >> cSkipBits;			//!!merced: changed long to LONG_PTR. This'll probably affect the shift bits.
	
	ival = bits & maskHashBits;

	bits = bits >> cHashBits;

	ival = ival ^ (bits & maskHashBits);

	return ival;


}

//
// Inserts the memory block into the hash table of values
//
void CMsiMalloc::InsertInMemList(MBH* pmbh)
{
	short iHash;

	iHash = IHashValue(pmbh);

	pmbh->pmbhNext = m_rgpmbhBlocks[iHash];
	m_rgpmbhBlocks[iHash] = pmbh;

}


//
// Routine to assert when a freed class pointer is reused
//
void FreedClassWarning(void *pThis)
{
	MBH *pmbh;
	TCHAR szMsg[cchTempBuffer * 6];
	TCHAR szInfo[cchTempBuffer * 5];


	pmbh = (MBH *)(((char *)pThis) - sizeof(MBH));

	// Otherwise we'll try to do a dynamic cast, bad idea on freed object
	pmbh->fObject = false;
	
	vMalloc.ReturnBlockInfoPv(pThis, szInfo, sizeof(szInfo)/sizeof(TCHAR));
	// We know the additional text is smaller than cchTempBuffer, so no need to check szMsg size
	StringCchPrintf(szMsg, sizeof(szMsg)/sizeof(TCHAR), TEXT("%s\r\n%s"), TEXT("Calling through freed vtable."), szInfo);
	FailAssertMsg(szMsg);
}

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\icust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       icust.cpp
//
//--------------------------------------------------------------------------

/* icust.cpp - IMsiCustomAction implementation
____________________________________________________________________________*/

#include "precomp.h"
#include "_engine.h"
#include "_msiutil.h"
#include "icust.h"
#include "remapi.h"
#include <wow64t.h>

const GUID IID_IMsiCustomAction            = GUID_IID_IMsiCustomAction;
const GUID IID_IMsiCustomActionProxy       = GUID_IID_IMsiCustomActionProxy;
const GUID IID_IMsiRemoteAPI                  = GUID_IID_IMsiRemoteAPI;
const GUID IID_IMsiRemoteAPIProxy             = GUID_IID_IMsiRemoteAPIProxy;
const GUID IID_IMsiCustomActionLocalConfig = GUID_IID_IMsiCustomActionLocalConfig;

extern bool IsDebuggerRunning();


//____________________________________________________________________________
//
// CMsiCustomAction - Stub that supports running a remote custom action
//____________________________________________________________________________


CMsiCustomAction *g_pCustomActionContext = 0;
extern Bool g_fCustomActionServer;

// External factory called from DllGetClassObject class factories. Only one custom action
// context should ever be created, and it should be registered as the global CA context
// for this process. This officially turns this instance of the DLL to a remote API client.
IMsiCustomAction* CreateCustomAction()
{		
	if (g_pCustomActionContext)
	{
		AssertSz(0, "Tried to create multiple CA Contexts in server!");
		return 0;
	}
	g_fCustomActionServer = fTrue;
	g_pCustomActionContext = new CMsiCustomAction();
	if (!g_pCustomActionContext || !g_pCustomActionContext->m_fValid)
	{
		// release and destroy the invalid object
		if (g_pCustomActionContext)
			g_pCustomActionContext->Release();
		g_pCustomActionContext = NULL;
		return NULL;
	}
	g_scServerContext = scCustomActionServer;
	return (IMsiCustomAction*)g_pCustomActionContext;
}

CMsiCustomAction::CMsiCustomAction() :
	m_iRefCnt(1), m_fPostQuitMessage(false), m_piGIT(NULL), m_dwGITCookie(0),
	m_dwClientProcess(0), m_fClientOwned(false), m_hShutdownEvent(0), 
	m_hImpersonationToken(INVALID_HANDLE_VALUE), m_hEvtReady(0),
	m_fValid(false)
{
	m_hEvtReady = CreateEvent(NULL, TRUE, FALSE, NULL);
	InitializeMsiMalloc();
	m_dwMainThreadId = MsiGetCurrentThreadId();
	InitializeCriticalSection(&m_csGetInterface);
	InitializeCriticalSection(&m_csActionList);

	m_rgchRemoteCookie[0]=0;

	// the custom action server is responsible for determining its own context based on
	// the process token
	#ifdef _WIN64
	m_icacContext = icac64Impersonated;
	#else
	m_icacContext = icac32Impersonated;
	#endif

	HANDLE hToken = 0;
	if (WIN::OpenProcessToken(WIN::GetCurrentProcess(), TOKEN_QUERY, &hToken))
	{
		#ifdef _WIN64
		m_icacContext = IsLocalSystemToken(hToken) ? icac64Elevated : icac64Impersonated;
		#else
		m_icacContext = IsLocalSystemToken(hToken) ? icac32Elevated : icac32Impersonated;
		#endif
		WIN::CloseHandle(hToken);
	}

	// initialize the action list to have no actions
	for (unsigned int iIndex = 0; iIndex < m_rgActionList.GetSize(); iIndex++)
	{
		m_rgActionList[iIndex].dwThread = 0;
		m_rgActionList[iIndex].hThread = INVALID_HANDLE_VALUE;
	}

	// check for successful creation and mark the context as valid
	if (m_hEvtReady)
		m_fValid = true;
};

CMsiCustomAction::~CMsiCustomAction() 
{
	if (m_piGIT)
	{
		if (m_dwGITCookie)
		{
			m_piGIT->RevokeInterfaceFromGlobal(m_dwGITCookie);
			m_dwGITCookie = 0;
		}
		m_piGIT->Release();
		m_piGIT=0;
	}
	if (m_rgchRemoteCookie)
	{
		m_rgchRemoteCookie[0] = 0;
	}
	if (m_hEvtReady)
		::CloseHandle(m_hEvtReady);
	if (m_hImpersonationToken != INVALID_HANDLE_VALUE)
		::CloseHandle(m_hImpersonationToken);
	DeleteCriticalSection(&m_csGetInterface);
	DeleteCriticalSection(&m_csActionList);
	FreeMsiMalloc(false);
};

HRESULT CMsiCustomAction::QueryInterface(const IID& riid, void** ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;
	if (riid == IID_IUnknown || riid == IID_IMsiCustomActionProxy || riid == IID_IMsiCustomAction || riid == IID_IMsiCustomActionLocalConfig)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CMsiCustomAction::AddRef()
{
	return InterlockedIncrement(&m_iRefCnt);
}

unsigned long CMsiCustomAction::Release()
{
	if (InterlockedDecrement(&m_iRefCnt) != 0)
		return m_iRefCnt;

	// shut down the server, the client has no more actions to run
	HANDLE hEvent = InterlockedExchangePointer(&m_hShutdownEvent, 0);
	if (hEvent)
	{
		DEBUGMSG("Custom Action Server shutting down.");
		SetEvent(hEvent);
	}

	delete this;
	return 0;
}

class CustomActionData
{
public:
	CustomActionData(const ICHAR* szPath, const ICHAR* szActionName, const ICHAR* szEntryPoint,
		MSIHANDLE hInstall, bool fAppCompatEnabled, const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID);
	~CustomActionData();

	bool m_fValid;

	ICHAR* m_szPath;
	ICHAR* m_szActionName;
	ICHAR* m_szEntryPoint;
	MSIHANDLE m_hInstall;
	bool m_fDebugBreak;
	bool m_fAppCompat;
	GUID m_guidAppCompatDB;
	GUID m_guidAppCompatID;
};

CustomActionData::CustomActionData(const ICHAR* szPath, const ICHAR* szActionName, 
	const ICHAR* szEntryPoint, MSIHANDLE hInstall, bool fAppCompatEnabled, const GUID* pguidAppCompatDB, 
	const GUID* pguidAppCompatID) : m_fAppCompat(fAppCompatEnabled), m_fDebugBreak(false)
{
	int cchStr;

	m_szPath = NULL;
	m_szActionName = NULL;
	m_szEntryPoint = NULL;
	m_fValid = false;
	m_hInstall = hInstall;

	if (szPath)
	{
		cchStr = IStrLen(szPath) + 1;
		m_szPath = new ICHAR[cchStr];
		if (!m_szPath)
			return;
		StringCchCopy(m_szPath, cchStr, szPath);
	}

	if (szEntryPoint)
	{	
		cchStr = IStrLen(szEntryPoint) + 1;
		m_szEntryPoint = new ICHAR[cchStr];
		if (!m_szEntryPoint)
			return;
		StringCchCopy(m_szEntryPoint, cchStr, szEntryPoint);
	}

	if (szActionName)
	{	
		cchStr = IStrLen(szActionName) + 1;
		m_szActionName = new ICHAR[cchStr];
		if (!m_szActionName)
			return;
		StringCchCopy(m_szActionName, cchStr, szActionName);
	}

	if (fAppCompatEnabled && pguidAppCompatDB)
		memcpy(&m_guidAppCompatDB, pguidAppCompatDB, sizeof(m_guidAppCompatDB));
	else
		memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));

	if (fAppCompatEnabled && pguidAppCompatID)
		memcpy(&m_guidAppCompatID, pguidAppCompatID, sizeof(m_guidAppCompatID));
	else
		memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));

	m_fValid = true;
}

CustomActionData::~CustomActionData()
{
	if (m_szEntryPoint)
		delete[] m_szEntryPoint;
	if (m_szPath)
		delete[] m_szPath;
	if (m_szActionName)
		delete[] m_szActionName;
}


typedef DWORD   (__stdcall *PThreadEntry)(void*);

extern HRESULT RunScriptAction(int icaType, IDispatch* piDispatch, MsiString istrSource, MsiString istrTarget, LANGID iLangId, HWND hWnd, int& iScriptResult, IMsiRecord** piMSIResult);
extern char *SerializeRecord(IMsiRecord *piRecord, IMsiServices* piServices, int* pcb);

HRESULT CMsiCustomAction::RunScriptAction(int icaType, IDispatch* piDispatch, const ICHAR* szSource, const ICHAR *szTarget, LANGID iLangId, int* iScriptResult, int *pcb, char **pchRecord)
{
	// wait for the RemoteAPI to signal that it is ready in case the script needs to 
	// create a remote Installer object. We MUST pump messages here
	HANDLE rghWaitArray[1] = {m_hEvtReady};
	for(;;)
	{
		DWORD iWait = WIN::MsgWaitForMultipleObjects(1, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
		if (iWait == WAIT_OBJECT_0 + 1)  // window Msg
		{		
			MSG msg;
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				WIN::TranslateMessage(&msg);
				WIN::DispatchMessage(&msg);
			}
			continue;
		}
		else
			// either thread signaled or error
			break;
	}
	
	// check client PID if RPCRT4 exports the correct function OR if on WinXP
	// where function should exist.
	unsigned long ulPid = 0;
	HRESULT hRPCResult = RPCRT4::I_RpcBindingInqLocalClientPID(NULL, &ulPid);
	if ((hRPCResult != ERROR_CALL_NOT_IMPLEMENTED) || MinimumPlatformWindowsNT51())
	{
		if ((RPC_S_OK != hRPCResult) || (ulPid != m_dwClientProcess))
		{
			DEBUGMSGV("Action request rejected - Unknown PID.");
			return ERROR_ACCESS_DENIED;
		}
	}

	IMsiServices *piServices = LoadServices();
	// there's a very good chance that this is the only copy of services that exists in the custom action server, 
	// because there is no engine in this process. Thus the record must be serialized and released before we can 
	// destroy services (record cache issues).
	{
		PMsiRecord piError(0);
		::RunScriptAction(icaType, piDispatch, szSource, szTarget, iLangId, WIN::GetActiveWindow(), *iScriptResult, &piError);
		*pchRecord = SerializeRecord(piError, piServices, pcb);

		// if in the client, pass rights to the foreground to the CA server. 
		if (m_fClientOwned)
			USER32::AllowSetForegroundWindow(m_dwClientProcess);
	}
	FreeServices();

	return S_OK;
}

////
// initializes a DLL custom action. Does not actually run the action because the calling process must have the 
// thread Id before the action actually starts in order to property filter MsiProcessMessage calls for client
// owned, synchronous DLL actions launched via control events.
HRESULT CMsiCustomAction::PrepareDLLCustomAction(const ICHAR* szActionName, const ICHAR* szPath, const ICHAR* szEntryPoint, 
	MSIHANDLE hInstall, boolean fDebugBreak, boolean fAppCompat, const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID, DWORD* pdwThreadId)
{	
	// wait for the RemoteAPI to signal that it is ready. We MUST pump messages here
	HANDLE rghWaitArray[1] = {m_hEvtReady};
	for(;;)
	{
		DWORD iWait = WIN::MsgWaitForMultipleObjects(1, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
		if (iWait == WAIT_OBJECT_0 + 1)  // window Msg
		{		
			MSG msg;
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				WIN::TranslateMessage(&msg);
				WIN::DispatchMessage(&msg);
			}
			continue;
		}
		else
			// either thread signaled or error
			break;
	}

	// check client PID if RPCRT4 exports the correct function OR if on WinXP
	// where function should exist.
	unsigned long ulPid = 0;
	HRESULT hRPCResult = RPCRT4::I_RpcBindingInqLocalClientPID(NULL, &ulPid);
	if ((hRPCResult != ERROR_CALL_NOT_IMPLEMENTED) || MinimumPlatformWindowsNT51())
	{
		if ((RPC_S_OK != hRPCResult) || (ulPid != m_dwClientProcess))
		{
			DEBUGMSGV("Action request rejected - Unknown PID.");
			return ERROR_ACCESS_DENIED;
		}
	}

	if (!szPath)
	{
		m_fPostQuitMessage = true;
		if (m_dwGITCookie && m_piGIT)
		{
			// if successful, this calls AddRef() on the interface
			m_piGIT->RevokeInterfaceFromGlobal(m_dwGITCookie);
			m_dwGITCookie=0;
		}

		// prevent future calls on this object
		OLE32::CoDisconnectObject(this, 0);

		// shut down the server, the client has no more actions to run
		DEBUGMSG("Received CA shutdown signal.");
		HANDLE hEvent = InterlockedExchangePointer(&m_hShutdownEvent, 0);
		if (hEvent)
			SetEvent(hEvent);

		return ERROR_SUCCESS;
	}

	// initialize thread data, copy DLL path and entry point to heap storage
	CustomActionData* CAData = new CustomActionData(szPath, szActionName, szEntryPoint, hInstall, fAppCompat ? true : false, pguidAppCompatDB, pguidAppCompatID);
	if (!CAData)
		return ERROR_FUNCTION_FAILED;
	if (!CAData->m_fValid)
	{
		delete CAData;
		return ERROR_FUNCTION_FAILED;
	}

	// Must check if its OK to use DebugBreak again in this process, since the calling engine for impersonated 
	// servers could be the insecure client. If the user is not an admin we cannot break. 
	// Elevated servers are only generated via the service, so their decision making process is secure already.
	CAData->m_fDebugBreak = false;
#ifdef _WIN64
	if (m_icacContext == icac64Impersonated)
#else
	if (m_icacContext == icac32Impersonated)
#endif
	{
		if (IsAdmin())
			CAData->m_fDebugBreak = (fDebugBreak ? true : false);
	}
	else
		CAData->m_fDebugBreak = (fDebugBreak ? true : false);


	// create the custom action thread in a suspended state, then return thread ID to calling process.
	HANDLE hThread = CreateThread(NULL, 0, reinterpret_cast<PThreadEntry>(CMsiCustomAction::CustomActionThread), 
		reinterpret_cast<void *>(CAData), CREATE_SUSPENDED, pdwThreadId);

	if (!hThread)
	{
		DEBUGMSG1(TEXT("Unable to create CA thread. (%d)"), reinterpret_cast<ICHAR*>(ULongToPtr(GetLastError())));
		delete CAData;
		return ERROR_FUNCTION_FAILED;
	}

	// atomically add this action to the list of active actions
	EnterCriticalSection(&m_csActionList);

	// search the action list for this thread Id
	int iIndex = 0; 
	for (iIndex = 0; iIndex < m_rgActionList.GetSize(); iIndex++)
	{
		if (m_rgActionList[iIndex].dwThread == 0)
			break;
	}

	// if the array isn't big enough, double its size
	if (iIndex == m_rgActionList.GetSize())
	{
		m_rgActionList.Resize(iIndex*2);
	}

	// add the thrad data to the list
	m_rgActionList[iIndex].dwThread = *pdwThreadId;
	m_rgActionList[iIndex].hThread = hThread;

	// release synchronization lock
	LeaveCriticalSection(&m_csActionList);

	return S_OK;
}

////
// given a custom action identifier (really just a thread id), resume the custom action thread
// and wait for it to finish.
HRESULT CMsiCustomAction::RunDLLCustomAction(DWORD dwThreadId, unsigned long* pulRet)
{
	// check client PID if RPCRT4 exports the correct function OR if on WinXP
	// where function should exist.
	unsigned long ulPid = 0;
	HRESULT hRPCResult = RPCRT4::I_RpcBindingInqLocalClientPID(NULL, &ulPid);
	if ((hRPCResult != ERROR_CALL_NOT_IMPLEMENTED) || MinimumPlatformWindowsNT51())
	{
		if ((RPC_S_OK != hRPCResult) || (ulPid != m_dwClientProcess))
		{
			DEBUGMSGV("Action request rejected - Unknown PID.");
			return ERROR_ACCESS_DENIED;
		}
	}
	
	HANDLE hThread = 0;

	// atomically search the list of active actions for this action
	EnterCriticalSection(&m_csActionList);

	// search the action list for this thread Id
	int iIndex = 0; 
	for (iIndex = 0; iIndex < m_rgActionList.GetSize(); iIndex++)
	{
		if (m_rgActionList[iIndex].dwThread == dwThreadId)
		{
			hThread = m_rgActionList[iIndex].hThread;
			break;
		}
	}

	// release synchronization lock
	LeaveCriticalSection(&m_csActionList);
	
	if (!hThread)
	{
		DEBUGMSG1(TEXT("Unable to execute custom action. Service referred to unknown action %d."), reinterpret_cast<ICHAR*>(ULongToPtr(dwThreadId)));
		return ERROR_FUNCTION_FAILED;
	}

	// remove the suspend count on the waiting custom action thread
	DWORD dwResult = ResumeThread(hThread);
	if (dwResult == -1)
	{
		DEBUGMSG1(TEXT("Unable to execute custom action. Unable to resume action %d."), reinterpret_cast<ICHAR*>(ULongToPtr(dwThreadId)));
		return ERROR_FUNCTION_FAILED;
	}

	// the thread should always be suspended, but never be suspended twice
	AssertSz(dwResult == 1, TEXT("Invalid Suspend Count for CA Thread in CA Server."));

	WaitForSingleObject(hThread, INFINITE);

	// if the exit code is desired, grab it from the thread
	if (pulRet)
		GetExitCodeThread(hThread, pulRet);

	// if in the client, pass rights to the foreground to the CA server. 
	if (m_fClientOwned)
		USER32::AllowSetForegroundWindow(m_dwClientProcess);

	return S_OK;
}


////
// given a custom action identifier (really just a thread id), resume the custom action thread
// and wait for it to finish.
HRESULT CMsiCustomAction::FinishDLLCustomAction(DWORD dwThreadId)
{
	// check client PID if RPCRT4 exports the correct function OR if on WinXP
	// where function should exist.
	unsigned long ulPid = 0;
	HRESULT hRPCResult = RPCRT4::I_RpcBindingInqLocalClientPID(NULL, &ulPid);
	if ((hRPCResult != ERROR_CALL_NOT_IMPLEMENTED) || MinimumPlatformWindowsNT51())
	{
		if ((RPC_S_OK != hRPCResult) || (ulPid != m_dwClientProcess))
		{
			DEBUGMSGV("Action request rejected - Unknown PID.");
			return ERROR_ACCESS_DENIED;
		}
	}

	// atomically search the list of active actions for this action
	EnterCriticalSection(&m_csActionList);

	// search the action list for this thread Id
	int iIndex = 0; 
	for (iIndex = 0; iIndex < m_rgActionList.GetSize(); iIndex++)
	{
		if (m_rgActionList[iIndex].dwThread == dwThreadId)
		{
			::CloseHandle(m_rgActionList[iIndex].hThread);
			m_rgActionList[iIndex].hThread = 0;
			m_rgActionList[iIndex].dwThread = 0;
			break;
		}
	}

	// release synchronization lock
	LeaveCriticalSection(&m_csActionList);
	
	return S_OK;
}



////
// main thread for a DLL custom action in the custom action server. Loads DLL,
// calls GetProcAddress, calls entry point. Wraps the actual DLL call in 
// an exception handler to catch possible problems. Also throws debug UI if
// debugbreak is set.
DWORD WINAPI CMsiCustomAction::CustomActionThread(CustomActionData *pData)
{
   	DWORD dwRet = ERROR_FUNCTION_FAILED;
	DEBUGMSG2(TEXT("Custom action server running custom action: DLL: %s, Entrypoint: %s"), pData->m_szPath, pData->m_szEntryPoint);

	// call apphelp if needed BEFORE loading the DLL.
	if (MinimumPlatformWindowsNT51() && pData->m_fAppCompat)
	{
		APPHELP::ApphelpFixMsiPackage(&pData->m_guidAppCompatDB, &pData->m_guidAppCompatID, pData->m_szPath, pData->m_szActionName, 0);
	}

	UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS);
	HINSTANCE hLib = WIN::LoadLibrary(pData->m_szPath);
	WIN::SetErrorMode(uiErrorMode);

	PCustomActionEntry pfEntry = NULL;
	if (hLib != 0)
	{
#ifdef UNICODE
		char rgchEntry[100];
		if ( WIN::WideCharToMultiByte(CP_ACP, 0, pData->m_szEntryPoint, -1, rgchEntry, sizeof(rgchEntry), 0, 0) != 0 )
		    pfEntry = (PCustomActionEntry)WIN::GetProcAddress(hLib, rgchEntry);
#else
		pfEntry = (PCustomActionEntry)WIN::GetProcAddress(hLib, pData->m_szEntryPoint);
#endif
	}

	if (hLib)
	{
		if (pfEntry)
		{
			if (pData->m_fDebugBreak && !IsDebuggerRunning())
			{
				ICHAR rgchMessage[256];
				StringCchPrintf(rgchMessage, sizeof(rgchMessage)/sizeof(ICHAR), 
						TEXT("To debug your custom action, attach your debugger to process %d (0x%X) and press OK"), 
						WIN::GetCurrentProcessId(), WIN::GetCurrentProcessId());
				MessageBox(0, rgchMessage, TEXT("Windows Installer"), MB_OK | MB_TOPMOST);
			}
			
			LPEXCEPTION_POINTERS lpExceptionInfo = 0;
			__try
			{
				dwRet = CallCustomDllEntrypoint(pfEntry, pData->m_fDebugBreak ? TRUE : FALSE, pData->m_hInstall, pData->m_szEntryPoint);
			}
			__except(lpExceptionInfo=GetExceptionInformation(), 1) 
			{
				// this exception handler catches every exception thrown within the custom action call sequence.
				// breakpoint exceptions are immediately passed to the debugger (or the system to display a
				// debugger activation dialog if JIT is enabled). All other exceptions are trapped to protect 
				// the process. Allowing breakpoint actions to pass through this handler unmolested will NOT
				// always activate the debugger, as the COM RPC threads do not appear to have have the necessary
				// exception handlers.
				if (lpExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
				{
					UnhandledExceptionFilter(lpExceptionInfo); 
				}
				else
				{
					DEBUGMSG2(TEXT("Custom action server's custom action threw an exception! (%u), returning %u"), 
						reinterpret_cast<const ICHAR*>(static_cast<ULONG_PTR>(lpExceptionInfo->ExceptionRecord->ExceptionCode)), 
						reinterpret_cast<const ICHAR*>(static_cast<UINT_PTR>(ERROR_INSTALL_FAILURE)));
						dwRet = ERROR_INSTALL_FAILURE;
				}
			}
			DEBUGMSG3(TEXT("Custom action server's custom action is returning %u. (%s, %s)"), reinterpret_cast<ICHAR*>(ULongToPtr(dwRet)), pData->m_szPath, pData->m_szEntryPoint);
		}
		else
			dwRet = ERROR_INVALID_DLL;
		WIN::FreeLibrary(hLib);
	}
	else
		dwRet = ERROR_DLL_NOT_FOUND;
	
	if (pData)
		delete pData;

	return dwRet;
}

////
// creates an initial marshaling stream for the IMsiRemoteAPI interface. 
// Since several threads could be making API calls at the same time, the interface
// pointer needs to be thread safe. We don't know what apartment the threads
// are in, so we need to marshal into each thread.
HRESULT CMsiCustomAction::SetRemoteAPI(IMsiRemoteAPI *piRemoteAPI)
{
	BOOL fSuccess = TRUE;
	if (!piRemoteAPI)
		return ERROR_FUNCTION_FAILED;
		
	EnterCriticalSection(&m_csGetInterface);
	if (!m_piGIT)
	{
		if (S_OK != OLE32::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&m_piGIT))
		{
			LeaveCriticalSection(&m_csGetInterface);
			return ERROR_FUNCTION_FAILED;
		}
	}

	fSuccess = (S_OK == m_piGIT->RegisterInterfaceInGlobal(piRemoteAPI, IID_IMsiRemoteAPI, &m_dwGITCookie));

	SetEvent(m_hEvtReady);
	LeaveCriticalSection(&m_csGetInterface);
	return fSuccess ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

////
// retrieves the Remote API inteface from the GIT. The returned interface is valid is this apartment only
// and has been AddRef-ed
IMsiRemoteAPI* CMsiCustomAction::GetAPI()
{
	EnterCriticalSection(&m_csGetInterface);

	// ensure that we have a GIT pointer. Only one exists per process.
	if (!m_piGIT)
	{
		if (S_OK != OLE32::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&m_piGIT))
		{
			LeaveCriticalSection(&m_csGetInterface);
			return NULL;
		}
	}

	IMsiRemoteAPI *piRemoteAPI = NULL;
 
	// We can lose connection with the CA server in 3 ways: We could lose our GIT cookie, lose the data at that cookie,
	// or the object in our client could be destroyed, if any of that has happened, we are lost and need to kill ourselves
	if (m_dwGITCookie)
	{
		// if successful, this calls AddRef() on the interface
		m_piGIT->GetInterfaceFromGlobal(m_dwGITCookie, IID_IMsiRemoteAPI, reinterpret_cast<void **>(&piRemoteAPI));
		
		if (piRemoteAPI && !OLE32::CoIsHandlerConnected(piRemoteAPI))
		{
			piRemoteAPI->Release();
			piRemoteAPI=NULL;
		}
	}

	if (!piRemoteAPI)
	{
		// we could not verify the connection, so this process is now totally 
		// useless as far as API calls are concerned. 
		DEBUGMSGV(TEXT("Lost connection to service. Could not remote API call."));

		if (m_dwGITCookie)
		{
			m_piGIT->RevokeInterfaceFromGlobal(m_dwGITCookie);
			m_dwGITCookie = 0;
		}

		WIN::PostThreadMessage(m_dwMainThreadId, WM_QUIT, 0, 0);
		LeaveCriticalSection(&m_csGetInterface);
		return 0;
	}
	LeaveCriticalSection(&m_csGetInterface);
	return piRemoteAPI;
}		

////
// set security information used to communicate with the client
HRESULT CMsiCustomAction::SetCookie(icacCustomActionContext* icacContext, const unsigned char *rgchCookie) 
{
	#ifdef _WIN64
	if (m_icacContext == icac64Elevated)
	#else
	if (m_icacContext == icac32Elevated)	
	#endif
	{
		if (icacContext)
			m_icacContext = *icacContext;
	}

	memcpy(m_rgchRemoteCookie, rgchCookie, iRemoteAPICookieSize);
	return S_OK;
}

////
// set client information used to pass foreground rights to the client after
// an action runs and enable privileges/impersonation. hToken will be 
// duplicated, so must be open with at least TOKEN_DUPLICATE
HRESULT CMsiCustomAction::SetClientInfo(DWORD dwClientProcess, bool fClientOwned, DWORD dwPrivileges, HANDLE hToken)
{
	m_fClientOwned = fClientOwned;
	m_dwClientProcess = dwClientProcess;

	if (MinimumPlatformWindows2000())
	{
		HANDLE hToken = INVALID_HANDLE_VALUE;
		if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
		{
			DisablePrivilegesFromMap(hToken, dwPrivileges);
			::CloseHandle(hToken);
		}
	}
	if (hToken != INVALID_HANDLE_VALUE)
	{
		if (!ADVAPI32::DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, 0, SecurityImpersonation, TokenImpersonation, &m_hImpersonationToken))
		{
			m_hImpersonationToken = INVALID_HANDLE_VALUE;
			return E_FAIL;
		}
	}

	return S_OK;
}

////
// tells the custom action object what event to signal to indicate a 
// shutdown request from the client
HRESULT CMsiCustomAction::SetShutdownEvent(HANDLE hEvent)
{
	m_hShutdownEvent = hEvent;
	return S_OK;
}

HRESULT CMsiCustomAction::QueryPathOfRegTypeLib(REFGUID guid, unsigned short wVerMajor,
											unsigned short wVerMinor, LCID lcid,
											OLECHAR* lpszPathName, int cchPath)
{
	BSTR bstrPathName = OLEAUT32::SysAllocStringLen(NULL, cchPath);
	HRESULT hRes = OLEAUT32::QueryPathOfRegTypeLib(guid, wVerMajor, wVerMinor, lcid, &bstrPathName);
	if ( hRes == S_OK )
		StringCchCopyW(lpszPathName, cchPath, bstrPathName);
	OLEAUT32::SysFreeString(bstrPathName);
	return hRes;
}

HRESULT ProcessTypeLibraryCore(const OLECHAR* szLibID, LCID lcidLocale, 
										 const OLECHAR* szTypeLib, const OLECHAR* szHelpPath, 
										 const bool fRemove, int *fInfoMismatch);

HRESULT CMsiCustomAction::ProcessTypeLibrary(const OLECHAR* szLibID, LCID lcidLocale, 
											const OLECHAR* szTypeLib, const OLECHAR* szHelpPath, 
											int fRemove, int *fInfoMismatch)
{
	CResetImpersonationInfo impReset;
	return ProcessTypeLibraryCore(szLibID, lcidLocale, szTypeLib, szHelpPath, 
											Tobool(fRemove), fInfoMismatch);
}

#ifndef _WIN64

static struct 
{
	ICHAR szBuffer[MAX_PATH+1];
	int   iLen;
} g_stSystem32Folder = { TEXT(""), 0 }, g_stSyswow64Folder  = { TEXT(""), 0 };

static bool InitializeSystemFolders(void)
{
	if ( !*g_stSystem32Folder.szBuffer )
	{
		// getting %systemroot%system32 folder
		g_stSystem32Folder.iLen = WIN::GetSystemDirectory(g_stSystem32Folder.szBuffer, ARRAY_ELEMENTS(g_stSystem32Folder.szBuffer));
		if (!g_stSystem32Folder.iLen || (g_stSystem32Folder.iLen > ARRAY_ELEMENTS(g_stSystem32Folder.szBuffer)))
		{
			g_stSyswow64Folder.szBuffer[0] = '\0';
			g_stSystem32Folder.szBuffer[0] = '\0';
			g_stSyswow64Folder.iLen = 0;
			g_stSystem32Folder.iLen = 0;
			return false;
		}
		
		g_stSyswow64Folder.iLen = KERNEL32::GetSystemWow64Directory(g_stSyswow64Folder.szBuffer, ARRAY_ELEMENTS(g_stSyswow64Folder.szBuffer));
		if (!g_stSyswow64Folder.iLen || (g_stSyswow64Folder.iLen > ARRAY_ELEMENTS(g_stSyswow64Folder.szBuffer)))
		{
			g_stSyswow64Folder.szBuffer[0] = '\0';
			g_stSystem32Folder.szBuffer[0] = '\0';
			g_stSyswow64Folder.iLen = 0;
			g_stSystem32Folder.iLen = 0;
			return false;
		}
	}
	return true;
}
#endif

bool SwapSystem32(ICHAR* szPath, WORD cchPathOutMax)
{
	if ( !g_fWinNT64 )
		// doesn't run on  32-bit machines
		return true;
#ifdef _WIN64
	// doesn't run on 64-bit builds
	szPath;
	cchPathOutMax;
	return true;
#else
	if (!InitializeSystemFolders())
		return false;

	if ( !IStrNCompI(szPath, g_stSystem32Folder.szBuffer, g_stSystem32Folder.iLen) &&
		  (szPath[g_stSystem32Folder.iLen] == chDirSep || !szPath[g_stSystem32Folder.iLen]) )
	{
		CAPITempBuffer<ICHAR, MAX_PATH> rgchTemp;
		StringCchCopy(rgchTemp, rgchTemp.GetSize(), g_stSyswow64Folder.szBuffer);
		StringCchCat(rgchTemp, rgchTemp.GetSize(), szPath+g_stSystem32Folder.iLen);
		return SUCCEEDED(StringCchCopy(szPath, cchPathOutMax, rgchTemp)) ? true : false;
	}
	return true;
#endif
}

#define ODBC_INSTALL_INQUIRY     1

HRESULT CMsiCustomAction::SQLInstallDriverEx(int, const ICHAR *szDriver,
											const ICHAR *szPathIn, ICHAR *szPathOut,
											WORD cbPathOutMax, WORD* pcbPathOut,
											WORD fRequest, DWORD* pdwUsageCount)
{
	BOOL iRet = ODBCCP32::SQLInstallDriverEx(szDriver, szPathIn, szPathOut, cbPathOutMax,
											pcbPathOut, fRequest, pdwUsageCount);
	if ( iRet == TRUE && fRequest == ODBC_INSTALL_INQUIRY )
		if (!SwapSystem32(szPathOut,cbPathOutMax))
			return ERROR_FUNCTION_FAILED;

	return iRet;
}

HRESULT CMsiCustomAction::SQLConfigDriver(WORD fRequest,
											const ICHAR* szDriver, const ICHAR* szArgs,
											ICHAR* szMsg, WORD cbMsgMax, WORD* pcbMsgOut)
{
	return ODBCCP32::SQLConfigDriver(0, fRequest, szDriver, szArgs,
											szMsg, cbMsgMax, pcbMsgOut);
}

HRESULT CMsiCustomAction::SQLRemoveDriver(const ICHAR* szDriver, int fRemoveDSN,
											DWORD* pdwUsageCount)
{
	return ODBCCP32::SQLRemoveDriver(szDriver, fRemoveDSN, pdwUsageCount);
}

HRESULT CMsiCustomAction::SQLInstallTranslatorEx(int, const ICHAR *szTranslator,
											const ICHAR *szPathIn, ICHAR *szPathOut,
											WORD cbPathOutMax, WORD* pcbPathOut,
											WORD fRequest, DWORD* pdwUsageCount)
{
	BOOL iRet = ODBCCP32::SQLInstallTranslatorEx(szTranslator, szPathIn, szPathOut, cbPathOutMax,
											pcbPathOut, fRequest, pdwUsageCount);
	if ( iRet == TRUE && fRequest == ODBC_INSTALL_INQUIRY )
		if (!SwapSystem32(szPathOut,cbPathOutMax))
			return ERROR_FUNCTION_FAILED;

	return iRet;
}

HRESULT CMsiCustomAction::SQLRemoveTranslator(const ICHAR* szTranslator,
											DWORD* pdwUsageCount)
{
	return ODBCCP32::SQLRemoveTranslator(szTranslator, pdwUsageCount);
}

HRESULT CMsiCustomAction::SQLConfigDataSource(WORD fRequest,
											const ICHAR* szDriver,
											const ICHAR* szAttributes,
											DWORD /*cbAttrSize*/)
{
	return ODBCCP32::SQLConfigDataSource(0, fRequest, szDriver,
											szAttributes);
}

HRESULT CMsiCustomAction::SQLInstallDriverManager(ICHAR* szPath, WORD cbPathMax,
											WORD* pcbPathOut)
{
	return ODBCCP32::SQLInstallDriverManager(szPath, cbPathMax, pcbPathOut);
}

HRESULT CMsiCustomAction::SQLRemoveDriverManager(DWORD* pdwUsageCount)
{
	return ODBCCP32::SQLRemoveDriverManager(pdwUsageCount);
}

HRESULT CMsiCustomAction::SQLInstallerError(WORD iError, DWORD* pfErrorCode,
											ICHAR *szErrorMsg, WORD cbErrorMsgMax, WORD* pcbErrorMsg)
{
	return ODBCCP32::SQLInstallerError(iError, pfErrorCode, szErrorMsg, cbErrorMsgMax, pcbErrorMsg);
}

//____________________________________________________________________________
//
// CClientThreadImpersonate - stack based management of thread impersonation
//____________________________________________________________________________
DWORD g_dwThreadImpersonationSlot = INVALID_TLS_SLOT;
int   g_fThreadImpersonationLock = 0;
bool  g_fThreadImpersonationArray = false;
CAPITempBuffer<ThreadIdImpersonate, 5>  g_rgThreadIdImpersonate;
const int cExpandImpersonate=5;

CClientThreadImpersonate::CClientThreadImpersonate(const DWORD dwThreadID)
{
	// only need to impersonate if dwThreadID is non-zero
	if (dwThreadID)
	{
		m_fImpersonated = true;

		while (TestAndSet(&g_fThreadImpersonationLock))
		{
			Sleep(10);		
		}

		if (g_dwThreadImpersonationSlot != INVALID_TLS_SLOT)
		{
			::TlsSetValue(g_dwThreadImpersonationSlot, reinterpret_cast<VOID*>((DWORD_PTR)(dwThreadID)));
		}
		else
		{	
			DWORD dwCurrentThreadId = GetCurrentThreadId();
			unsigned int c = 0;
			unsigned int cThreadImpersonate = g_rgThreadIdImpersonate.GetSize();

			// search for an empty slot in the array, or a slot with the same threadId
			for (c=0; c < cThreadImpersonate && g_rgThreadIdImpersonate[c].m_dwThreadId; c++)
			{
				if (g_rgThreadIdImpersonate[c].m_dwThreadId == dwCurrentThreadId)
					break;
			}

			// the current thread doesn't have an entry in the array and there are no open slots
			// so we'll have to expand the array a bit to make room
			if (c == cThreadImpersonate)
			{
				g_rgThreadIdImpersonate.Resize(cThreadImpersonate+cExpandImpersonate);
				// init new entries to 0.
				for (int i=cThreadImpersonate; i < g_rgThreadIdImpersonate.GetSize(); i++)
				{
					g_rgThreadIdImpersonate[i].m_dwThreadId = 0;
					g_rgThreadIdImpersonate[i].m_dwClientThreadId = 0;
				}	
			}

			// whatever slot we found, store the actual ThreadId and effective ThreadId
			if (c < g_rgThreadIdImpersonate.GetSize())
			{
				g_rgThreadIdImpersonate[c].m_dwThreadId = dwCurrentThreadId;
				g_rgThreadIdImpersonate[c].m_dwClientThreadId = dwThreadID;
			}
		}	
		g_fThreadImpersonationLock = 0;	
	}
	else // dwThreadId == 0
	{
		m_fImpersonated = false;
	}
}

CClientThreadImpersonate::~CClientThreadImpersonate()
{
	// nothing to do if we never impersonated
	if (!m_fImpersonated)
		return;

	while (TestAndSet(&g_fThreadImpersonationLock))
	{
		Sleep(10);		
	}

	if (g_dwThreadImpersonationSlot != INVALID_TLS_SLOT)
	{
		// service or TLS avialable
		::TlsSetValue(g_dwThreadImpersonationSlot, 0);
	}
	else
	{
		// client side when no TLS slots are available
		unsigned int cThreadImpersonate = g_rgThreadIdImpersonate.GetSize();

		// search for this ThreadId.
		DWORD dwCurrentThreadId = GetCurrentThreadId();
		for (unsigned int c=0; c < cThreadImpersonate; c++)
		{
			if (g_rgThreadIdImpersonate[c].m_dwThreadId == dwCurrentThreadId)
			{
				// found. Clear out the slot for reuse.
				g_rgThreadIdImpersonate[c].m_dwThreadId = 0;
				g_rgThreadIdImpersonate[c].m_dwClientThreadId = 0;
				break;
			}	
		}
	}
	g_fThreadImpersonationLock = 0;
}

//____________________________________________________________________________
//
// CMsiRemoteAPI - object that handles incoming API requests from another
// process, including thread impersonation and cookie verification
//____________________________________________________________________________

IMsiRemoteAPI* CreateMsiRemoteAPI()
{
	return (IMsiRemoteAPI*)new CMsiRemoteAPI();
}

CMsiRemoteAPI::CMsiRemoteAPI() : m_iRefCnt(1), m_fPerformSystemUserTranslation(false)
{
	for (int i=0; i < icacNext; i++)
	{
		memset(m_rgContextData[i].m_rgchCookie, 0, sizeof(m_rgContextData[i].m_rgchCookie));
		m_rgContextData[i].m_iActionCount = 0;
		m_rgContextData[i].m_lPid = 0;
	}

	// establish a thread-local storage slot for thread impersonation. 
	while (TestAndSet(&g_fThreadImpersonationLock))
	{
		Sleep(10);		
	}
	Assert(g_dwThreadImpersonationSlot == INVALID_TLS_SLOT);
	g_dwThreadImpersonationSlot = TlsAlloc();

	// since this code runs in the client, its possible that we're loaded into
	// a process with no more TLS slots.
	if (g_dwThreadImpersonationSlot == INVALID_TLS_SLOT)
	{
		AssertSz(g_scServerContext != scService, "No TLS Slots in Service");

		// initialize thread impersonation array
		for (int iIndex = 0; iIndex < g_rgThreadIdImpersonate.GetSize(); iIndex++)
		{
			g_rgThreadIdImpersonate[iIndex].m_dwClientThreadId = 0;
			g_rgThreadIdImpersonate[iIndex].m_dwThreadId = 0;
		}
		g_fThreadImpersonationArray = true;
	}
	g_fThreadImpersonationLock = 0;
	m_dwRemoteAPIThread = GetCurrentThreadId();

	// if in the service and the client token is actually system, then a request for an impersonated context maps
	// to a request for the elevated context. Since impersonated and elevated servers are the same, we consolidate
	// the 4 servers into 2. This requires an adjustment in the action count array, but all of the cookie validation
	// works with the actual context provided.
	if (g_scServerContext == scService)
	{
		// don't close this handle, it belongs to the message context
		HANDLE hUserToken = GetUserToken();
	
		m_fPerformSystemUserTranslation = hUserToken && IsLocalSystemToken(hUserToken) && !TokenIsUniqueSystemToken(hUserToken);
	}
}

CMsiRemoteAPI::~CMsiRemoteAPI() 
{
	// release the thread-local storage slot for thread impersonation. 
	while (TestAndSet(&g_fThreadImpersonationLock))
	{
		Sleep(10);		
	}
	
	if (g_dwThreadImpersonationSlot != INVALID_TLS_SLOT)
	{
		TlsFree(g_dwThreadImpersonationSlot);
		g_dwThreadImpersonationSlot = INVALID_TLS_SLOT;
	}
	else
	{
		g_fThreadImpersonationArray = false;
		g_rgThreadIdImpersonate.Resize(5);
	}
	g_fThreadImpersonationLock =0;

	Assert(!m_iRefCnt);
	for (int i=0; i < icacNext; i++)
	{
		m_rgContextData[i].m_rgchCookie[0] = 0;
		m_rgContextData[i].m_iActionCount = 0;
		m_rgContextData[i].m_lPid = 0;
	}
};

bool CMsiRemoteAPI::SetCookieAndPid(const int icacContext, const unsigned char *rgchCookie, const unsigned long lPid)
{
	if (rgchCookie)
	{
		memcpy(m_rgContextData[icacContext].m_rgchCookie, rgchCookie, iRemoteAPICookieSize);
		m_rgContextData[icacContext].m_iActionCount = 0;
		m_rgContextData[icacContext].m_lPid = lPid;

	}
	else
	{
		m_rgContextData[icacContext].m_iActionCount = 0;
		m_rgContextData[icacContext].m_lPid = 0;
		return false;
	}

	return true;
};

// Begin and EndAction maintain an "active action" count for each context. If an API request
// comes in from an action context with a 0 action count, it is rejected
HRESULT CMsiRemoteAPI::BeginAction(const int icacContext)
{
	int iTrueContext = icacContext;
	if (m_fPerformSystemUserTranslation)
	{
		if (icacContext == icac32Impersonated)
		{
			iTrueContext = icac32Elevated;
		}
		else if (icacContext == icac64Impersonated)
		{
			iTrueContext = icac64Elevated;
		}
	}

	InterlockedIncrement(&m_rgContextData[iTrueContext].m_iActionCount);
	return 0;
};

HRESULT CMsiRemoteAPI::EndAction(const int icacContext)
{
	int iTrueContext = icacContext;
	if (m_fPerformSystemUserTranslation)
	{
		if (icacContext == icac32Impersonated)
		{
			iTrueContext = icac32Elevated;
		}
		else if (icacContext == icac64Impersonated)
		{
			iTrueContext = icac64Elevated;
		}
	}
	
	// ensure that our action count doesn't drop to -1.
	AssertNonZero(InterlockedDecrement(&m_rgContextData[iTrueContext].m_iActionCount) >= 0);
	return 0;
};

HRESULT CMsiRemoteAPI::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiRemoteAPIProxy || riid == IID_IMsiRemoteAPI)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CMsiRemoteAPI::AddRef()
{
	return InterlockedIncrement(&m_iRefCnt);
}

unsigned long CMsiRemoteAPI::Release()
{
	if (InterlockedDecrement(&m_iRefCnt) != 0)
		return m_iRefCnt;
	DEBUGMSG("Destroying RemoteAPI object.");
	PostThreadMessage(m_dwRemoteAPIThread, WM_QUIT, 0, 0);
	delete this;
	return 0;
}

bool CMsiRemoteAPI::ValidateCookie(const int icacContext, 
	const unsigned char *rgchCookie, const int cbCookie) const
{
	if (m_rgContextData[icacContext].m_iActionCount == 0)
	{
		DEBUGMSGV("API call rejected - No actions in Context");
		return false;
	}

	// check client PID if RPCRT4 exports the correct function OR if on WinXP
	// where function should exist.
	unsigned long ulPid = 0;
	HRESULT hRPCResult = RPCRT4::I_RpcBindingInqLocalClientPID(NULL, &ulPid);
	if ((hRPCResult != ERROR_CALL_NOT_IMPLEMENTED) || MinimumPlatformWindowsNT51())
	{
		if ((RPC_S_OK != hRPCResult) ||
			(ulPid != m_rgContextData[icacContext].m_lPid))
		{
			DEBUGMSGV("API call rejected - Unknown PID.");
			return false;
		}
	}
	
	if (!rgchCookie || (cbCookie != iRemoteAPICookieSize))
	{
		DEBUGMSGV("API call rejected - Invalid Cookie.");
		return false;
	}

	for (int iCookieByte = 0; iCookieByte < iRemoteAPICookieSize; iCookieByte++)
	{
		if (rgchCookie[iCookieByte] != m_rgContextData[icacContext].m_rgchCookie[iCookieByte])
		{
			DEBUGMSGV("API call rejected - Invalid Cookie.");
			return false;
		}
	}
	return true;
}

HRESULT CMsiRemoteAPI::GetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall, const ICHAR* szName, ICHAR* szValue, unsigned long cchValue, unsigned long* pcchValueRes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!szValue)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
	{
		// marshalling fix
		*szValue = 0;
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	}
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
    if (pcchValueRes) 
    {
        *pcchValueRes = cchValue;
    }
	UINT dwRes = MsiGetProperty(hInstall, szName, szValue, pcchValueRes);
	if (dwRes != ERROR_SUCCESS && dwRes != ERROR_MORE_DATA)
	{
		// marshalling fails with NULL or no size, so in error cases
		// we need to be sure to have an empty string to pass across
		Assert(szValue && cchValue);
		*szValue = 0;
	}
	return MSI_WIN32_TO_HRESULT(dwRes);
}

HRESULT CMsiRemoteAPI::CreateRecord(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned int cParams, unsigned long* pHandle)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);
	
	// Validate output pointers set here. Other args validated by actual API call. 
	if (!pHandle)
		return ERROR_INVALID_PARAMETER;
	
	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*pHandle = MsiCreateRecord(cParams);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::CloseAllHandles(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	MsiCloseAllHandles();
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::CloseHandle(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hAny)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiCloseHandle(hAny));
}

HRESULT CMsiRemoteAPI::DatabaseOpenView(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hDatabase, const ichar* szQuery, unsigned long* phView)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiDatabaseOpenView(hDatabase, szQuery, phView));
}

HRESULT CMsiRemoteAPI::ViewGetError(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hView, ichar* szColumnNameBuffer, unsigned long cchBuf, unsigned long* pcchBufRes, int *pMsidbError)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
    if (pcchBufRes) 
    {
        *pcchBufRes = cchBuf;
    }
	*pMsidbError = MsiViewGetError(hView, szColumnNameBuffer, pcchBufRes);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::ViewExecute(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hView, unsigned long hRecord)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiViewExecute(hView, hRecord));
}

HRESULT CMsiRemoteAPI::ViewFetch(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hView, unsigned long*  phRecord)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiViewFetch(hView, phRecord));
}

HRESULT CMsiRemoteAPI::ViewModify(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hView,  long eUpdateMode,  unsigned long hRecord)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiViewModify(hView, (MSIMODIFY)eUpdateMode, hRecord));
}

HRESULT CMsiRemoteAPI::ViewClose(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hView)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiViewClose(hView));
}

HRESULT CMsiRemoteAPI::OpenDatabase(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, const ichar* szDatabasePath, const ichar* szPersist, unsigned long *phDatabase)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiOpenDatabase(szDatabasePath, szPersist, phDatabase));
}

HRESULT CMsiRemoteAPI::DatabaseCommit(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hDatabase)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiDatabaseCommit(hDatabase));
}

HRESULT CMsiRemoteAPI::DatabaseGetPrimaryKeys(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hDatabase, const ichar * szTableName, unsigned long *phRecord)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiDatabaseGetPrimaryKeys(hDatabase, szTableName, phRecord));
}

HRESULT CMsiRemoteAPI::RecordIsNull(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord,  unsigned int iField, boolean *pfIsNull)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!pfIsNull)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*pfIsNull = (boolean)MsiRecordIsNull(hRecord, iField);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::RecordDataSize(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord,  unsigned int iField, unsigned int* puiSize)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!puiSize)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*puiSize = MsiRecordDataSize(hRecord, iField);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::RecordSetInteger(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord,  unsigned int iField, int iValue)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiRecordSetInteger(hRecord, iField, iValue));
}

HRESULT CMsiRemoteAPI::RecordSetString(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord,	 unsigned int iField, const ichar* szValue)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiRecordSetString(hRecord, iField, szValue));
}

HRESULT CMsiRemoteAPI::RecordGetInteger(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord,  unsigned int iField, int *piValue)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	// Validate output pointers set here. Other args validated by actual API call. 
	if (!piValue)
		return ERROR_INVALID_PARAMETER;

	*piValue = MsiRecordGetInteger(hRecord, iField);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::RecordGetString(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hRecord,  unsigned int iField, ichar* szValueBuf, unsigned long cchValueBuf, unsigned long *pcchValueRes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!szValueBuf)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);

	if (pcchValueRes)
		*pcchValueRes = cchValueBuf;
	UINT dwRes = MsiRecordGetString(hRecord, iField, szValueBuf, pcchValueRes);
	if (dwRes != ERROR_SUCCESS && dwRes != ERROR_MORE_DATA)
	{
		// marshalling fails with NULL or no size
		Assert(szValueBuf && cchValueBuf);
		*szValueBuf = 0;
	}
	return MSI_WIN32_TO_HRESULT(dwRes);
}

HRESULT CMsiRemoteAPI::RecordGetFieldCount(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord, unsigned int* piCount)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!piCount)
		return ERROR_INVALID_PARAMETER;
		
	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
	
	*piCount = MsiRecordGetFieldCount(hRecord);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::RecordSetStream(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord,  unsigned int iField, const ichar* szFilePath)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiRecordSetStream(hRecord, iField, szFilePath));
}

HRESULT CMsiRemoteAPI::RecordReadStream(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord,  unsigned int iField, boolean fBufferIsNull, char *szDataBuf, unsigned long *pcbDataBuf)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiRecordReadStream(hRecord, iField, fBufferIsNull ? NULL : szDataBuf, pcbDataBuf));
}

HRESULT CMsiRemoteAPI::RecordClearData(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hRecord)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiRecordClearData(hRecord));
}

HRESULT CMsiRemoteAPI::GetSummaryInformation(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hDatabase,  const ichar*  szDatabasePath,  unsigned int     uiUpdateCount,    unsigned long *phSummaryInfo)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiGetSummaryInformation(hDatabase, szDatabasePath, uiUpdateCount, phSummaryInfo));
}

HRESULT CMsiRemoteAPI::SummaryInfoGetPropertyCount(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hSummaryInfo,	 unsigned int *puiPropertyCount)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSummaryInfoGetPropertyCount(hSummaryInfo, puiPropertyCount));
}

HRESULT CMsiRemoteAPI::SummaryInfoSetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hSummaryInfo, unsigned int uiProperty,  unsigned int uiDataType, int iValue, FILETIME *pftValue,  const ichar* szValue)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSummaryInfoSetProperty(hSummaryInfo, uiProperty, uiDataType, iValue, pftValue, szValue));
}

HRESULT CMsiRemoteAPI::SummaryInfoGetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hSummaryInfo, unsigned int uiProperty, unsigned int *puiDataType, int *piValue, FILETIME *pftValue, ichar* szValueBuf, unsigned long cchValueBuf, unsigned long *pcchValueBufRes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!szValueBuf || !puiDataType)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
	{
		*szValueBuf = 0;
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	}
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	// we MUST have a puiDataType because its possible to get success yet still have random memory 
	// in the output buffer (because its a FILETIME type, etc). Thus, the type determines if we
	// need set the buffer to empty string. If NULL is passed to MsiSummaryInfoGetProperty from the
	// CA server, its the remote setup routines in msiquery.cpp that are responsible for creating
	// a dummy value (because they need the result as well).
	Assert(puiDataType);
    if (pcchValueBufRes) 
    {
        *pcchValueBufRes = cchValueBuf;
    }
	UINT dwRes = MsiSummaryInfoGetProperty(hSummaryInfo, uiProperty, puiDataType, piValue, pftValue, szValueBuf, pcchValueBufRes);
	if ((dwRes != ERROR_SUCCESS && dwRes != ERROR_MORE_DATA) || (dwRes == ERROR_SUCCESS && *puiDataType != VT_LPSTR))
	{
		// marshalling fails with NULL or no size, so in error cases
		// we need to be sure to have an empty string to pass across
		Assert(szValueBuf && cchValueBuf);
		*szValueBuf = 0;
	}
	return MSI_WIN32_TO_HRESULT(dwRes);
}

HRESULT CMsiRemoteAPI::SummaryInfoPersist(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hSummaryInfo)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSummaryInfoPersist(hSummaryInfo));
}

HRESULT CMsiRemoteAPI::GetActiveDatabase(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall, unsigned long* phDatabase)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!phDatabase)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*phDatabase = MsiGetActiveDatabase(hInstall);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::SetProperty(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szName,  const ichar* szValue)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSetProperty(hInstall, szName, szValue));
}

HRESULT CMsiRemoteAPI::GetLanguage(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall, unsigned short* pLangId)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!pLangId)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*pLangId = MsiGetLanguage(hInstall);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::GetMode(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall, long eRunMode, boolean* pfSet)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!pfSet)
		return ERROR_INVALID_PARAMETER;

	
	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*pfSet = (boolean)MsiGetMode(hInstall, (MSIRUNMODE)eRunMode);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::SetMode(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  long eRunMode,  boolean fState)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSetMode(hInstall, (MSIRUNMODE)eRunMode, fState));
}

HRESULT CMsiRemoteAPI::FormatRecord(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  unsigned long hRecord, ichar* szResultBuf, unsigned long cchResultBuf, unsigned long *pcchResultBufRes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!szResultBuf)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
	{
		*szResultBuf = 0;
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	}
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
    if (pcchResultBufRes)
    {
        *pcchResultBufRes = cchResultBuf;
    }
	UINT dwRes = MsiFormatRecord(hInstall, hRecord, szResultBuf, pcchResultBufRes);
	if (dwRes != ERROR_SUCCESS && dwRes != ERROR_MORE_DATA)
	{
		// marshalling fails with NULL or no size, so in error cases
		// we need to be sure to have an empty string to pass across
		Assert(szResultBuf && cchResultBuf);
		*szResultBuf = 0;
	}
	return MSI_WIN32_TO_HRESULT(dwRes);

}

HRESULT CMsiRemoteAPI::DoAction(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szAction)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiDoAction(hInstall, szAction));
}

HRESULT CMsiRemoteAPI::Sequence(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szTable, int iSequenceMode)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSequence(hInstall, szTable, iSequenceMode));
}

HRESULT CMsiRemoteAPI::ProcessMessage(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  long eMessageType,  unsigned long hRecord, int* piRes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!piRes)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*piRes = MsiProcessMessage(hInstall, (INSTALLMESSAGE)eMessageType, hRecord);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::EvaluateCondition(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szCondition, int *piCondition)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!piCondition)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*piCondition = MsiEvaluateCondition(hInstall, szCondition);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::GetFeatureState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFeature, long *piInstalled, long *piAction)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiGetFeatureState(hInstall, szFeature, (INSTALLSTATE*)piInstalled, (INSTALLSTATE*)piAction));
}

HRESULT CMsiRemoteAPI::SetFeatureState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFeature,  long iState)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSetFeatureState(hInstall, szFeature, (INSTALLSTATE)iState));
}

HRESULT CMsiRemoteAPI::SetFeatureAttributes(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFeature,  long iAttributes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSetFeatureAttributes(hInstall, szFeature, iAttributes));
}

HRESULT CMsiRemoteAPI::GetComponentState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall, const ichar* szComponent, long *piInstalled, long *piAction)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiGetComponentState(hInstall, szComponent, (INSTALLSTATE*)piInstalled, (INSTALLSTATE*)piAction));
}

HRESULT CMsiRemoteAPI::SetComponentState(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar*     szComponent,  long iState)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSetComponentState(hInstall, szComponent, (INSTALLSTATE)iState));
}

HRESULT CMsiRemoteAPI::GetFeatureCost(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFeature,  int iCostTree,  long iState, int *piCost)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiGetFeatureCost(hInstall, szFeature, (MSICOSTTREE)iCostTree, (INSTALLSTATE)iState, piCost));
}

HRESULT CMsiRemoteAPI::EnumComponentCosts(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall, const ichar* szComponent, unsigned long iIndex, long iState, ichar* szDrive,  unsigned long cchDrive, unsigned long* pcchDriveSize, int *piCost, int *piTempCost)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!pcchDriveSize || !szDrive)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);

	if (cchDrive) 
		*pcchDriveSize = cchDrive;

	UINT dwRes = MsiEnumComponentCosts(hInstall, szComponent, iIndex, (INSTALLSTATE)iState, szDrive, pcchDriveSize, piCost, piTempCost);
	if (dwRes != ERROR_SUCCESS && dwRes != ERROR_MORE_DATA)
	{
		// marshalling fails with NULL or no size, so in error cases
		// we need to be sure to have an empty string to pass across
		Assert(szDrive && cchDrive);
		*szDrive = 0;
	}
	return MSI_WIN32_TO_HRESULT(dwRes);
}

HRESULT CMsiRemoteAPI::SetInstallLevel(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall, int iInstallLevel)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiSetInstallLevel(hInstall, iInstallLevel));
}

HRESULT CMsiRemoteAPI::GetFeatureValidStates(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFeature, unsigned long *dwInstallStates)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiGetFeatureValidStates(hInstall, szFeature, dwInstallStates));
}

HRESULT CMsiRemoteAPI::DatabaseIsTablePersistent(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hDatabase,  const ichar* szTableName, int *piCondition)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!piCondition)
		return ERROR_INVALID_PARAMETER;
	
	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*piCondition = MsiDatabaseIsTablePersistent(hDatabase, szTableName);
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::ViewGetColumnInfo(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hView,  long eColumnInfo, unsigned long *phRecord)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);

	return MSI_WIN32_TO_HRESULT(MsiViewGetColumnInfo(hView, (MSICOLINFO)eColumnInfo, phRecord));
}

HRESULT CMsiRemoteAPI::GetLastErrorRecord(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long *phRecord)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!phRecord)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	*phRecord = MsiGetLastErrorRecord();
	return ERROR_SUCCESS;
}

HRESULT CMsiRemoteAPI::GetSourcePath(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall,  const ichar* szFolder, ichar* szPathBuf, unsigned long cchPathBuf, unsigned long *pcchPathBufRes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!szPathBuf)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
	{
		*szPathBuf = 0;
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	}
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);

    if (pcchPathBufRes)
    {
         *pcchPathBufRes = cchPathBuf;
    }
	UINT dwRes = MsiGetSourcePath(hInstall, szFolder, szPathBuf, pcchPathBufRes);
	if (dwRes != ERROR_SUCCESS && dwRes != ERROR_MORE_DATA)
	{
		// marshalling fails with NULL or no size, so in error cases
		// we need to be sure to have an empty string to pass across
		Assert(szPathBuf && cchPathBuf);
		*szPathBuf = 0;
	}
	return MSI_WIN32_TO_HRESULT(dwRes);
}

HRESULT CMsiRemoteAPI::GetTargetPath(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFolder, ichar* szPathBuf,  unsigned long cchPathBuf, unsigned long *pcchPathBufRes)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	// Validate output pointers set here. Other args validated by actual API call. 
	if (!szPathBuf)
		return ERROR_INVALID_PARAMETER;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
	{
		*szPathBuf = 0;
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	}
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);

    if (pcchPathBufRes)
    {
        *pcchPathBufRes = cchPathBuf;
    }
	UINT dwRes = MsiGetTargetPath(hInstall, szFolder, szPathBuf, pcchPathBufRes);
	if (dwRes != ERROR_SUCCESS && dwRes != ERROR_MORE_DATA)
	{
		// marshalling fails with NULL or no size, so in error cases
		// we need to be sure to have an empty string to pass across
		Assert(szPathBuf && cchPathBuf);
		*szPathBuf = 0;
	}
	return MSI_WIN32_TO_HRESULT(dwRes);
}

HRESULT CMsiRemoteAPI::SetTargetPath(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie,  unsigned long hInstall,  const ichar* szFolder,  const ichar* szFolderPath)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
		
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
	
	return MSI_WIN32_TO_HRESULT(MsiSetTargetPath(hInstall, szFolder, szFolderPath));
}

HRESULT CMsiRemoteAPI::VerifyDiskSpace(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, unsigned long hInstall)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
		return MSI_WIN32_TO_HRESULT(ERROR_ACCESS_DENIED);
	
	// impersonate client if running from impersonated action
	CImpersonate impersonate(icacContext == icac32Impersonated || icacContext == icac64Impersonated);
		
	return MSI_WIN32_TO_HRESULT(MsiVerifyDiskSpace(hInstall));
}

extern IDispatch* CreateAutoInstallDispatch();
HRESULT CMsiRemoteAPI::GetInstallerObject(const int icacContext, const unsigned long dwThreadId, const unsigned char* rgchCookie, const int cbCookie, IDispatch** piDispatch)
{
	CResetImpersonationInfo impReset;
	CClientThreadImpersonate ThreadImpersonate(dwThreadId);

	if (piDispatch)
		*piDispatch = NULL;
	else
		return E_INVALIDARG;

	if (!ValidateCookie(icacContext, rgchCookie, cbCookie))
	{
		return E_FAIL;
	}
		
	*piDispatch = CreateAutoInstallDispatch();
	return S_OK;
}

bool CMsiRemoteAPI::FindAndValidateContextFromCallerPID(icacCustomActionContext *picacContext) const
{
	// validate arguments
	if (!picacContext)
		return false;

	// check client PID if RPCRT4 exports the correct function OR if on WinXP
	// where function should exist.
	unsigned long ulPid = 0;
	HRESULT hRPCResult = RPCRT4::I_RpcBindingInqLocalClientPID(NULL, &ulPid);
	if ((hRPCResult == ERROR_CALL_NOT_IMPLEMENTED) && !MinimumPlatformWindowsNT51())
	{
		// not on WinXP and RPCRT4 does not export the PID check. Assume OK
		return true;
	}

	// on WinXP or function exported. PID check must succeed or call is rejected.
	if (RPC_S_OK != hRPCResult)
	{
		return false;
	}

	// enumerate every active context and check for a matching PID with the calling PID
	for (int iContext = icacFirst; iContext < icacNext; iContext++)
	{
		if (ulPid == m_rgContextData[iContext].m_lPid)
		{
			// found context, set in output context argument
			*picacContext = static_cast<icacCustomActionContext>(iContext);

			// call is only valid if the context has an action
			if (m_rgContextData[iContext].m_iActionCount > 0)
				return true;

			// otherwise the call is rejected
			return false;
		}
	}

	// PID does not match any known context
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\fileactn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileactn.cpp
//
//--------------------------------------------------------------------------

/*__________________________________________________________________________

  fileactn.cpp - Implementation of core engine File actions
____________________________________________________________________________*/

#include "precomp.h"
#include "engine.h"
#include "_engine.h"
#include "_assert.h"
#include "_srcmgmt.h"
#include "_dgtlsig.h"
#include "tables.h" // table and column name definitions

// #define LOG_COSTING // Testing only

const GUID IID_IMsiCostAdjuster = GUID_IID_IMsiCostAdjuster;



static Bool IsFileActivityEnabled(IMsiEngine& riEngine)
{
	int iInstallMode = riEngine.GetMode();
	if (!(iInstallMode & iefOverwriteNone) &&
		!(iInstallMode & iefOverwriteOlderVersions) &&
		!(iInstallMode & iefOverwriteEqualVersions) &&
		!(iInstallMode & iefOverwriteDifferingVersions) &&
		!(iInstallMode & iefOverwriteCorruptedFiles) &&
		!(iInstallMode & iefOverwriteAllFiles))
	{
		return fFalse;
	}
	return fTrue;
}

static Bool IsRegistryActivityEnabled(IMsiEngine& riEngine)
{
	int iInstallMode = riEngine.GetMode();
	if (!(iInstallMode & iefInstallMachineData) &&
		!(iInstallMode & iefInstallUserData))
	{
		return fFalse;
	}
	return fTrue;
}

static Bool IsShortcutActivityEnabled(IMsiEngine& riEngine)
{
	int iInstallMode = riEngine.GetMode();
	if (!(iInstallMode & iefInstallShortcuts))
	{
		return fFalse;
	}
	return fTrue;
}

const int iBytesPerTick = 32768;
const int iReservedFileAttributeBits = msidbFileAttributesReserved1 |
													msidbFileAttributesReserved2 |
													msidbFileAttributesReserved3 |
													msidbFileAttributesReserved4;

static Bool FShouldDeleteFile(iisEnum iisInstalled, iisEnum iisAction);

CMsiFileBase::CMsiFileBase(IMsiEngine& riEngine) :
	m_riEngine(riEngine),m_riServices(*(riEngine.GetServices())),m_pFileRec(0)
{
	m_riEngine.AddRef();
}

CMsiFileBase::~CMsiFileBase()
{
	m_riServices.Release();
	m_riEngine.Release();
}

IMsiRecord* CMsiFileBase::GetTargetPath(IMsiPath*& rpiDestPath)
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	if (!m_pFileRec)
		return PostError(Imsg(idbgFileTableEmpty));

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	return pDirectoryMgr->GetTargetPath(*MsiString(m_pFileRec->GetMsiString(ifqDirectory)),rpiDestPath);
}


IMsiRecord* CMsiFileBase::GetFileRecord( void )
/*----------------------------------------------
------------------------------------------------*/
{
	if (m_pFileRec)
		m_pFileRec->AddRef();
	return m_pFileRec;
}

IMsiRecord* CMsiFileBase::GetExtractedTargetFileName(IMsiPath& riPath, const IMsiString*& rpistrFileName)
{
	Assert(m_pFileRec);
	Bool fLFN = ((m_riEngine.GetMode() & (iefSuppressLFN)) == 0 && riPath.SupportsLFN()) ? fTrue : fFalse;
	return m_riServices.ExtractFileName(m_pFileRec->GetString(ifqFileName), fLFN, rpistrFileName);
}


CMsiFile::CMsiFile(IMsiEngine& riEngine) : 
	CMsiFileBase(riEngine),
	m_pFileView(0)
{
}

CMsiFile::~CMsiFile()
{
}

static const ICHAR szSqlFile[] =
	TEXT("SELECT `FileName`,`Version`,`State`,`File`.`Attributes`,`TempAttributes`,`File`,`FileSize`,`Language`,`Sequence`,`Directory_`, ")
	TEXT("`Installed`,`Action`,`Component`, `ForceLocalFiles`, `ComponentId` FROM `File`,`Component` WHERE `Component`=`Component_`")
	TEXT(" AND `File`=?");

IMsiRecord* CMsiFile::ExecuteView(const IMsiString& riFileKeyString)
/*-------------------------------------------------------------------
-------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec;

	if (m_pFileView)
	{
		// A non-view all query is already active
		PMsiRecord pExecRec(&m_riServices.CreateRecord(1));
		pExecRec->SetMsiString(1, riFileKeyString);
		if ((piErrRec = m_pFileView->Execute(pExecRec)) != 0)
			return piErrRec;
		return 0;		
	}
	
	piErrRec = m_riEngine.OpenView(szSqlFile, ivcFetch, *&m_pFileView);
	if (piErrRec)
		return piErrRec;

	PMsiRecord pExecRec(&m_riServices.CreateRecord(1));
	pExecRec->SetMsiString(1, riFileKeyString);
	if ((piErrRec = m_pFileView->Execute(pExecRec)) != 0)
		return piErrRec;

	return 0;
}


IMsiRecord* CMsiFile::FetchFile(const IMsiString& riFileKeyString)
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec = ExecuteView(riFileKeyString);
	if (piErrRec)
		return piErrRec;

	m_pFileRec = m_pFileView->Fetch();
#ifdef DEBUG
	if (m_pFileRec)
		Assert(m_pFileRec->GetFieldCount() >= ifqNextEnum - 1);
#endif
	return 0;
}


CMsiFileInstall::CMsiFileInstall(IMsiEngine& riEngine) : 
	CMsiFileBase(riEngine)
{
	m_piView = 0;
	m_fInitialized = false;
}

CMsiFileInstall::~CMsiFileInstall()
{
		
	if (m_piView)
	{
		m_piView->Release();
		m_piView = 0;
	}

}

IMsiRecord* CMsiFileInstall::Initialize()
{
	IMsiRecord* piErr;
	
	if (m_fInitialized)
		return 0;
		
	piErr = m_riEngine.CreateTempActionTable(ttblFile);

	if (piErr)
		return piErr;

	m_fInitialized = true;

	return 0;

}

IMsiRecord* CMsiFileInstall::TotalBytesToCopy(unsigned int& uiTotalBytesToCopy)
/*-------------------------------------------------------------------
Returns a count of bytes of all files that are expected to be copied
when the current file query is acted upon.
-------------------------------------------------------------------*/
{
	uiTotalBytesToCopy = 0;
	
	IMsiRecord* piErr;
	
	if (!m_fInitialized)
	{
		piErr = Initialize();

		if (piErr)
			return piErr;
	}

	PMsiTable pTable(0);
	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
		
	piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			AssertSz(fFalse, "FileAction table not created");
			return 0;
		}
		else
			return piErr;
	}
	int colState, colFileSize, colAction;
#ifdef DEBUG
	int colFileKey;

	AssertNonZero(colFileKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));
#endif //DEBUG
	AssertNonZero(colState = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colState)));
	AssertNonZero(colFileSize = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colFileSize)));
	AssertNonZero(colAction = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colAction)));	

	PMsiCursor pCursor = pTable->CreateCursor(fFalse);
	
	while (pCursor->Next())
	{
#ifdef DEBUG
		const ICHAR* szDebug = (const ICHAR *)MsiString(pCursor->GetString(colFileKey));
#endif //DEBUG
		// Only those files whose "shouldInstall" state is true will
		// actually be copied during script execution.
		if (pCursor->GetInteger(colState) == fTrue && pCursor->GetInteger(colAction) == iisLocal)
		{
			int iFileSize = pCursor->GetInteger(colFileSize);
			uiTotalBytesToCopy += iFileSize;
		}
	}
	return 0;
}

static const ICHAR* szFetchInstall = 
	TEXT("SELECT `File`.`FileName`,`Version`,`File`.`State`,`File`.`Attributes`,`TempAttributes`,`File`.`File`,`File`.`FileSize`,`Language`,`Sequence`, `Directory_`, ")
	TEXT("`Installed`,`FileAction`.`Action`,`File`.`Component_`,`FileAction`.`ForceLocalFiles`, `ComponentId` FROM `File`,`FileAction` WHERE `File`.`File`=`FileAction`.`File`")
	TEXT(" ORDER BY `Sequence`, `Directory_`");

IMsiRecord* CMsiFileInstall::FetchFile()
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec;
	
	if (m_piView == 0)
	{
		if (!m_fInitialized)
		{
			piErrRec = Initialize();

			if (piErrRec)
				return piErrRec;
		}

		piErrRec = m_riEngine.OpenView(szFetchInstall, ivcFetch, *&m_piView);
		if (piErrRec)
			return piErrRec;

		piErrRec = m_piView->Execute(0);
		if (piErrRec)
			return piErrRec;
	}

	m_pFileRec = m_piView->Fetch();
#ifdef DEBUG
	if (m_pFileRec)
		Assert(m_pFileRec->GetFieldCount() >= ifqNextEnum - 1);
#endif

	return 0;
}

CMsiFileRemove::CMsiFileRemove(IMsiEngine& riEngine) :
	m_riEngine(riEngine),m_riServices(*(riEngine.GetServices())), m_pFileRec(0)
{
	m_riEngine.AddRef();
	m_fInitialized = false;
	m_fEmpty = false;
	m_piCursor = 0;
	m_piCursorFile = 0;
}

CMsiFileRemove::~CMsiFileRemove()
{
	m_riEngine.Release();
	m_riServices.Release();
	if (m_piCursor)
	{
		m_piCursor->Release();
		m_piCursor = 0;
	}
	
		
	if (m_piCursorFile)
	{
		m_piCursorFile->Release();
		m_piCursorFile = 0;
	}

}


IMsiRecord* CMsiFileRemove::Initialize()
{
	IMsiRecord* piErr;

	if (m_fInitialized)
		return 0;
		
	piErr = m_riEngine.CreateTempActionTable(ttblFile);

	if (piErr)
		return piErr;

	// Initialize the column arrays
	PMsiTable pTable(0);
	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
	
	piErr = pDatabase->LoadTable(*MsiString(*sztblFile), 0, *&pTable);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			m_fEmpty = true;
			return 0;
		}
		else
			return piErr;
	}
	
	AssertNonZero(m_colFileName = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFileName)));
	
	AssertNonZero(m_colFileKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));

	piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
	if (piErr)
	{
		return piErr;
	}
	
	AssertNonZero(m_colFileActionDir = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colDirectory)));
	AssertNonZero(m_colFileActKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));
	AssertNonZero(m_colFileActAction = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colAction)));
	AssertNonZero(m_colFileActInstalled = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colInstalled)));
	AssertNonZero(m_colFileActComponentId = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colComponentId)));

	m_fInitialized = true;
	
	return 0;
}

IMsiRecord* CMsiFileRemove::TotalFilesToDelete(unsigned int& uiTotalFileCount)
/*-------------------------------------------------------------------
Returns a count of all files that are expected to be deleted when the
current file query is acted upon.
-------------------------------------------------------------------*/
{
	IMsiRecord* piErr;
	uiTotalFileCount = 0;

	if (!m_fInitialized)
	{
		piErr = Initialize();
		if (piErr)
			return piErr;
	}
		
	PMsiTable pTable(0);
	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
		
	piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			m_fEmpty = true;
			return 0;
		}
		else
			return piErr;
	}
	
	int colInstalled, colAction;
#ifdef DEBUG
	int colFileKey;

	AssertNonZero(colFileKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));
#endif //DEBUG
	AssertNonZero(colInstalled = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colInstalled)));
	AssertNonZero(colAction = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colAction)));

	PMsiCursor pCursor = pTable->CreateCursor(fFalse);
	
	// Determine the number of files to delete
	// set up the progress bar accordingly.
	while (pCursor->Next())
	{
#ifdef DEBUG
		const ICHAR* szDebug = (const ICHAR *)MsiString(pCursor->GetString(colFileKey));
#endif //DEBUG
		if (FShouldDeleteFile((iisEnum)pCursor->GetInteger(colInstalled), (iisEnum)pCursor->GetInteger(colAction)))
			uiTotalFileCount++;
	}
	return 0;
}


IMsiRecord* CMsiFileRemove::FetchFile(IMsiRecord*& rpiRecord)
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	IMsiRecord* piErr;

	rpiRecord = 0;
	//
	// If it's not already created, we need a cursor on the 
	// file action table
	if (m_piCursor == 0)
	{
		if (!m_fInitialized)
		{
			piErr = Initialize();
			if (piErr)
				return piErr;
		}
		
		if (m_fEmpty)
		{
			return 0;
		}
		
		PMsiTable pTable(0);
		PMsiDatabase pDatabase = m_riEngine.GetDatabase();

		// Since we've already initialized, m_fEmpty should be set or 
		// we actually have a file action table and file table
		piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
		if (piErr)
		{
			return piErr;
		}

		m_piCursor = pTable->CreateCursor(fFalse);

		piErr = pDatabase->LoadTable(*MsiString(*sztblFile), 0, *&pTable);
		if (piErr)
		{
			return piErr;
		}

		m_piCursorFile = pTable->CreateCursor(fFalse);
		m_piCursorFile->SetFilter(iColumnBit(m_colFileKey));
	}

	while (m_piCursor->Next())
	{
		//
		// See if this is a file that meets our criteria or not
		if (!FShouldDeleteFile((iisEnum)m_piCursor->GetInteger(m_colFileActInstalled), (iisEnum)m_piCursor->GetInteger(m_colFileActAction)))
			continue;			

		m_piCursorFile->Reset();
		m_piCursorFile->PutInteger(m_colFileKey, m_piCursor->GetInteger(m_colFileActKey));
		if (m_piCursorFile->Next())
		{
			rpiRecord = &CreateRecord(ifqrNextEnum - 1);
			rpiRecord->SetMsiString(ifqrFileName,    *MsiString(m_piCursorFile->GetString(m_colFileName)));
			rpiRecord->SetMsiString(ifqrDirectory,   *MsiString(m_piCursor->GetString(m_colFileActionDir)));
			rpiRecord->SetMsiString(ifqrComponentId, *MsiString(m_piCursor->GetString(m_colFileActComponentId)));
			break;
		}
		else
		{
			AssertSz(fFalse, "Missing file from the file table");
		}

	}

	m_pFileRec = rpiRecord;
	if (rpiRecord != 0)
		rpiRecord->AddRef();

	return 0;
}

IMsiRecord* CMsiFileRemove::GetExtractedTargetFileName(IMsiPath& riPath, const IMsiString*& rpistrFileName)
{
	Assert(m_pFileRec);
	Bool fLFN = ((m_riEngine.GetMode() & (iefSuppressLFN)) == 0 && riPath.SupportsLFN()) ? fTrue : fFalse;
	return m_riServices.ExtractFileName(m_pFileRec->GetString(ifqrFileName), fLFN, rpistrFileName);
}



// End of CMsiFileAll //


/*---------------------------------------------------------------------------
	Local functions for use by File Actions
---------------------------------------------------------------------------*/

static IMsiRecord* PlaceFileOnInUseList(IMsiEngine& riEngine, const IMsiString& riFileNameString, const IMsiString& riFilePathString)
/*---------------------------------------------------------------------------
Throws the given file/path in a table of "files in use".
-----------------------------------------------------------------------------*/
{
	PMsiTable pFileInUseTable(0);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	int iColFileName,iColFilePath;
	if (pDatabase->FindTable(*MsiString(sztblFilesInUse)) == itsUnknown)
	{
		IMsiRecord* piErrRec = pDatabase->CreateTable(*MsiString(*sztblFilesInUse),5,*&pFileInUseTable);
		if (piErrRec)
			return piErrRec;

		Assert(pFileInUseTable);
		iColFileName = pFileInUseTable->CreateColumn(icdPrimaryKey + icdString,*MsiString(*sztblFilesInUse_colFileName));
		iColFilePath = pFileInUseTable->CreateColumn(icdPrimaryKey + icdString,*MsiString(*sztblFilesInUse_colFilePath));
		pDatabase->LockTable(*MsiString(*sztblFilesInUse),fTrue);
	}
	else
	{
		pDatabase->LoadTable(*MsiString(*sztblFilesInUse),0,*&pFileInUseTable);
		Assert(pFileInUseTable);
		iColFileName = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFileName));
		iColFilePath = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFilePath));
	}

	Assert(pFileInUseTable);
	PMsiCursor pCursor = pFileInUseTable->CreateCursor(fFalse);
	Assert(pCursor);
	Assert(iColFileName > 0 && iColFilePath > 0);
	AssertNonZero(pCursor->PutString(iColFileName,riFileNameString));
	AssertNonZero(pCursor->PutString(iColFilePath,riFilePathString));
	AssertNonZero(pCursor->Assign());
	return 0;
}

static int GetInstallModeFlags(IMsiEngine& riEngine,int iFileAttributes)
/*----------------------------------------------------------------
Local function that returns the install mode bit flags currently
associated with the given IMsiEngine object.  These flags are
defined by the icm* bit constants in engine.h.

The bit flags returned can be associated with a specific file
by passing that file's attributes (defined by iff* bit constants
in engine.h) in the iFileAttributes parameter.  Currently, the
only file attribute bit that makes any difference is iffChecksum:
if this bit is not set, then the iefOverwriteCorrupted will not
be set in the returned installmode flags, regardless of the 
current Reinstall mode(s).
-----------------------------------------------------------------*/
{
	// InstallMode flags are in the upper 16 bits of the engine mode
	int fInstallModeFlags = riEngine.GetMode() & 0xFFFF0000;
	if (!(iFileAttributes & msidbFileAttributesChecksum))
		fInstallModeFlags &= ~icmOverwriteCorruptedFiles;
	return fInstallModeFlags;
}


static IMsiRecord* GetFinalFileSize(IMsiEngine& riEngine,IMsiRecord& riFileRec,unsigned int& ruiFinalFileSize)
/*----------------------------------------------------------------------------
Returns the final,unclustered,file size for the file specified by riFileRec.

- The required fields in this record are specified by the ifq* enum in CMsiFile.
- The value returned in ruiFinalFileSize is valid only if GetFileInstallState
	was called previously with the same record, and no fields have modified
	since the call.
- If the ifqState field of riFileRec indicates that this file will overwrite
	the existing file (if any), then the new file's unclustered size will be
	returned; otherwise, the unclustered size of the existing file will be
	returned.
------------------------------------------------------------------------------*/
{
	PMsiPath pDestPath(0);
	IMsiRecord* piErrRec;
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqDirectory)),*&pDestPath);
	if (piErrRec)
		return piErrRec;

	ruiFinalFileSize = 0;
	if (riFileRec.GetInteger(CMsiFile::ifqState) == fTrue)
		ruiFinalFileSize = riFileRec.GetInteger(CMsiFile::ifqFileSize);
	else
	{
		MsiString strFileName(riFileRec.GetMsiString(CMsiFile::ifqFileName));
		Bool fExists;
		piErrRec = pDestPath->FileExists(strFileName,fExists);
		if (piErrRec)
			return piErrRec;

		Assert(fExists);
		piErrRec = pDestPath->FileSize(strFileName,ruiFinalFileSize);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}

static Bool FShouldDeleteFile(iisEnum iisInstalled, iisEnum iisAction)
/*-------------------------------------------------------------------------
Determines whether the file whose iisInstalled and iisAction states
will be deleted
--------------------------------------------------------------------------*/
{
	if (((iisAction == iisAbsent) || (iisAction == iisFileAbsent) || (iisAction == iisHKCRFileAbsent) || (iisAction == iisSource)) && (iisInstalled == iisLocal))
		return fTrue;
	else
		return fFalse;
}


IMsiRecord* GetFileInstallState(IMsiEngine& riEngine,IMsiRecord& riFileRec,
										  IMsiRecord* piCompanionFileRec, /* if set, riFileRec is for parent */
										  unsigned int* puiExistingClusteredSize, Bool* pfInUse,
										  ifsEnum* pifsState, bool fIgnoreCompanionParentAction, bool fIncludeHashCheck, int *pfVersioning)
/*-------------------------------------------------------------------------
Determines whether the file whose information is specified in riFileRec
should be installed.  The required fields in this record are specified
by the ifq* enum in CMsiFile.  An ideal record to pass to
GetFileInstallState is that returned by CMsiFile::GetFileRecord(), but
a record returned by any query whose SELECT fields match ifq* is fine and
dandy.

- The intended destination path for the file is determined by the directory
property name given in the ifqDirectory field.

- If the file should be installed, fTrue will be returned in the ifqState
field of riFileRec.

- If the file is determined to be a companion file, the itfaCompanion bit
will be set in the ifqTempAttributes field of riFileRec.

- if piCompanionFileRec is set, the file information given in riFileRec
is assumed to refer to the parent of a companion file, which the information
given in piCompanionFileRec is the information for the companion file.
In this case, the version checking will be altered such that ifqState will be returned as 
fTrue if the existing file (if any) is of an equal or lesser version.  Plus the file
hash check may be made against the companion file.

- if fIgnoreCompanionParentAction is true, the ifqState field of riFileRec
will NOT be dependent upon whether the companion parent's component is
installed/is being installed - only the version check will count.

- If there is an existing file with the specified name in the file's
directory, the existing clustered size of that file will be returned in
uiExistingClusteredSize, and if that existing file is in use, fTrue will
be returned in fInUse.  Either of these parameters can be passed as NULL
if the caller doesn't care about these values.
--------------------------------------------------------------------------*/
{
	PMsiPath pDestPath(0);
	IMsiRecord* piErrRec;
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiServices pServices(riEngine.GetServices());
	piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqDirectory)),*&pDestPath);
	if (piErrRec)
		return piErrRec;

	PMsiPath pCompanionDestPath(0);
	if(piCompanionFileRec)
	{
		piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(piCompanionFileRec->GetMsiString(CMsiFile::ifqDirectory)),*&pCompanionDestPath);
		if (piErrRec)
			return piErrRec;
	}
	
	int fInstallModeFlags = GetInstallModeFlags(riEngine,riFileRec.GetInteger(CMsiFile::ifqAttributes));
	if (piCompanionFileRec)
		fInstallModeFlags |= icmCompanionParent;

	MD5Hash hHash;
	MD5Hash* pHash = 0;
	if(fIncludeHashCheck)
	{
		bool fHashInfo = false;
		IMsiRecord* piHashFileRec = piCompanionFileRec ? piCompanionFileRec : &riFileRec;
		
		piErrRec = riEngine.GetFileHashInfo(*MsiString(piHashFileRec->GetMsiString(CMsiFile::ifqFileKey)),
														piHashFileRec->GetInteger(CMsiFile::ifqFileSize), hHash, fHashInfo);
		if(piErrRec)
			return piErrRec;
		
		if(fHashInfo)
			pHash = &hHash;
	}

	ifsEnum ifsState;
	Bool fShouldInstall = fFalse;

	if(piCompanionFileRec)
	{
		piErrRec = pDestPath->GetCompanionFileInstallState(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqFileName)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqVersion)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqLanguage)),
																*pCompanionDestPath,
																*MsiString(piCompanionFileRec->GetMsiString(CMsiFile::ifqFileName)),
																pHash, ifsState, fShouldInstall, puiExistingClusteredSize,
																pfInUse, fInstallModeFlags, pfVersioning);
	}
	else
	{
		piErrRec = pDestPath->GetFileInstallState(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqFileName)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqVersion)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqLanguage)),
																pHash, ifsState, fShouldInstall, puiExistingClusteredSize,
																pfInUse, fInstallModeFlags, pfVersioning);
	}

	if (piErrRec)
		return piErrRec;

	if (pifsState) *pifsState = ifsState;
	if (ifsState ==	ifsCompanionSyntax || ifsState == ifsCompanionExistsSyntax)
	{
		AssertSz(!piCompanionFileRec, "Chained companion files detected");
		
		CMsiFile objFile(riEngine);
		MsiString strParentFileKey(riFileRec.GetMsiString(CMsiFile::ifqVersion));
		piErrRec = objFile.FetchFile(*strParentFileKey);
		if (piErrRec)
			return piErrRec;

		fShouldInstall = fFalse;
		PMsiRecord pParentRec(objFile.GetFileRecord());
		if (pParentRec == 0)
			// Bad companion file reference
			return PostError(Imsg(idbgDatabaseTableError));

		// get parent path
		PMsiPath pParentPath(0);
		if((piErrRec = objFile.GetTargetPath(*&pParentPath)) != 0)
			return piErrRec;

		// extract appropriate file name from short|long pair and put back in pParentRec
		MsiString strParentFileName;
		if((piErrRec = objFile.GetExtractedTargetFileName(*pParentPath,*&strParentFileName)) != 0)
			return piErrRec;
		AssertNonZero(pParentRec->SetMsiString(CMsiFile::ifqFileName,*strParentFileName));
		
		if (pParentRec->GetInteger(CMsiFile::ifqAction) == iisLocal ||
			pParentRec->GetInteger(CMsiFile::ifqInstalled) == iisLocal ||
			fIgnoreCompanionParentAction)
		{
			// no hash check on companion parent; hash check on companion is dependent upon whether
			// we should be using a hash check (for component mgmt -- NO, for installation of file -- YES; ...
			// fIncludeHashCheck should already be set appropriately for us)
			piErrRec = GetFileInstallState(riEngine,*pParentRec,&riFileRec,0,0,0,
													 /* fIgnoreCompanionParentAction=*/ false,
													 /* fIncludeHashCheck=*/ fIncludeHashCheck, pfVersioning);
			if (piErrRec)
				return piErrRec;
			fShouldInstall = (Bool) pParentRec->GetInteger(CMsiFile::ifqState);
		}

		// Mark as a companion for future reference, if not already marked
		int iTempAttributes = riFileRec.GetInteger(CMsiFile::ifqTempAttributes);
		if (!(iTempAttributes & itfaCompanion))
		{
			iTempAttributes |= itfaCompanion;
			riFileRec.SetInteger(CMsiFile::ifqTempAttributes,iTempAttributes);

			MsiString strComponent(riFileRec.GetMsiString(CMsiFile::ifqComponent));
			MsiString strParentComponent(pParentRec->GetMsiString(CMsiFile::ifqComponent));
			if (strComponent.Compare(iscExact,strParentComponent) == 0)
			{
				// cost-link the companion's component to the companion parent's component
				// so the companion component will get recosted whenever the directory or select
				// state of the parent component changes.
				PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
				piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strParentComponent,*strComponent);
				if (piErrRec)
					return piErrRec;
			} 
		}
	}
	riFileRec.SetInteger(CMsiFile::ifqState,fShouldInstall);
	return 0;
}

/*---------------------------------------------------------------------------
	InstallFiles costing/action
---------------------------------------------------------------------------*/

class CMsiFileCost : public IMsiCostAdjuster
{
public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString& __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall Reset();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiFileCost(IMsiEngine& riEngine);
protected:
	virtual ~CMsiFileCost();  // protected to prevent creation on stack
	IMsiEngine& m_riEngine;
	PMsiView m_pCostView;

	IMsiTable*  m_piRemoveFilePathTable;
	IMsiCursor* m_piRemoveFilePathCursor;
	int         m_colRemoveFilePath;
	int         m_colRemoveFilePathComponent;
	int			m_colRemoveFilePathMode;
private:

	IMsiRecord* CheckRemoveFileList(const IMsiString& riFullPathString, const IMsiString& riComponentString, Bool& fOnList);
	int     m_iRefCnt;
	Bool	m_fRemoveFilePathTableMissing;
#ifdef USE_OBJECT_POOL
	unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
};

CMsiFileCost::CMsiFileCost(IMsiEngine& riEngine) : m_riEngine(riEngine), m_pCostView(0)
{
	m_iRefCnt = 1;
	m_riEngine.AddRef();
	m_piRemoveFilePathTable = 0;
	m_piRemoveFilePathCursor = 0;
	m_fRemoveFilePathTableMissing = fFalse;
#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}


CMsiFileCost::~CMsiFileCost()
{
	if (m_piRemoveFilePathCursor)
		m_piRemoveFilePathCursor->Release();

	if (m_piRemoveFilePathTable)
		m_piRemoveFilePathTable->Release();

	m_riEngine.Release();

	RemoveObjectData(m_iCacheId);
}

HRESULT CMsiFileCost::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiCostAdjuster)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiFileCost::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiFileCost::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	delete this;
	return 0;
}

const IMsiString& CMsiFileCost::GetMsiStringValue() const
{
	return g_MsiStringNull;
}

int CMsiFileCost::GetIntegerValue() const
{
	return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiFileCost::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiFileCost::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

IMsiRecord*   CMsiFileCost::Initialize()
//------------------------------------
{
	// cost-link any global assembly components to the windows folder
	PMsiTable pAssemblyTable(0);
	IMsiRecord* piError = 0;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());

	if ((piError = pDatabase->LoadTable(*MsiString(sztblMsiAssembly),0,*&pAssemblyTable)) != 0)
	{
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}

	MsiStringId idWindowsFolder = pDatabase->EncodeStringSz(IPROPNAME_WINDOWS_FOLDER);
	AssertSz(idWindowsFolder != 0, "WindowsFolder property not set in database");
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);

	PMsiTable pComponentTable(0);
	PMsiCursor pComponentCursor(0);
	int colComponent = 0;
	int colDirectory = 0;

	if ((piError = pDatabase->LoadTable(*MsiString(sztblComponent),0,*&pComponentTable)) != 0)
	{
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}

	pComponentCursor = pComponentTable->CreateCursor(fFalse);
	colComponent = pComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colComponent));
	colDirectory = pComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colDirectory));

	iatAssemblyType iatAT = iatNone;
	while (pComponentCursor->Next())
	{
		if (idWindowsFolder == pComponentCursor->GetInteger(colDirectory))
			continue; // no need to cost link since this component is already going to the Windows Folder

		if ((piError = m_riEngine.GetAssemblyInfo(*MsiString(pComponentCursor->GetString(colComponent)), iatAT, 0, 0)) != 0)
			return piError;

		// iatNone, iatURTAssemblyPvt or iatWin32AssemblyPvt do not require cost linking
		if (iatWin32Assembly == iatAT || iatURTAssembly == iatAT)
		{
			// cost link component to the WindowsFolder
			if ((piError = pSelectionMgr->RegisterComponentDirectoryId(pComponentCursor->GetInteger(colComponent),idWindowsFolder)) != 0)
				return piError;
		}
	}

	return 0;
}

IMsiRecord* CMsiFileCost::Reset()
//------------------------------------------
{
	return 0;
}

static const ICHAR sqlFileCost[] =
	TEXT("SELECT `FileName`,`Version`,`State`,`File`.`Attributes`,`TempAttributes`,`File`,`FileSize`,`Language`,`Sequence`,`Directory_`,")
	TEXT("`Installed`,`Action`,`Component` FROM `File`,`Component` WHERE `Component`=`Component_` AND `Component_`=? AND `Directory_`=?");

static const ICHAR sqlFileCostGlobalAssembly[] =
	TEXT("SELECT `FileName`,`Version`,`State`,`File`.`Attributes`,`TempAttributes`,`File`,`FileSize`,`Language`,`Sequence`,`Directory_`,")
	TEXT("`Installed`,`Action`,`Component` FROM `File`,`Component` WHERE `Component`=`Component_` AND `Component_`=?");

IMsiRecord* CMsiFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost, 
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//--------------------------------------
{
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	IMsiRecord* piErrRec;

	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	
	iatAssemblyType iatAT = iatNone;
	MsiString strAssemblyName;
	if ((piErrRec = m_riEngine.GetAssemblyInfo(riComponentString, iatAT, &strAssemblyName, 0)) != 0)
		return piErrRec;

	bool fGlobalAssembly = false;
	if (iatWin32Assembly == iatAT || iatURTAssembly == iatAT)
		fGlobalAssembly = true;

	if (m_pCostView == 0)
	{
		if ((piErrRec = m_riEngine.OpenView(fGlobalAssembly ? sqlFileCostGlobalAssembly : sqlFileCost, ivcEnum(ivcFetch|ivcUpdate), *&m_pCostView)) != 0)
		{
				// If either file or component table missing, nothing to do
			if (piErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
			{
				piErrRec->Release();
				return 0;
			}
			else
				return piErrRec;
		}
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRecord(&pServices->CreateRecord(2));
	pExecRecord->SetMsiString(1, riComponentString);
	pExecRecord->SetMsiString(2,riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRecord)) != 0)
		return piErrRec;

	PMsiPath pDestPath(0);
	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(riDirectoryString,*&pDestPath);
	if (piErrRec)
			return piErrRec;

	PMsiRecord pFileRec(0);

	// cost normally if component is private or without assemblies
	if (!fGlobalAssembly)
	{
		while (pFileRec = m_pCostView->Fetch())
		{

	#ifdef DEBUG
			ICHAR rgchFileName[256];
			MsiString strDebug(pFileRec->GetMsiString(CMsiFile::ifqFileName));
			strDebug.CopyToBuf(rgchFileName,255);
	#endif

			// extract appropriate name from short|long pair and put back in pFileRec
			MsiString strFileNamePair(pFileRec->GetMsiString(CMsiFile::ifqFileName));

			Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
			MsiString strFileName;
			if((piErrRec = pServices->ExtractFileName(strFileNamePair,fLFN,*&strFileName)) != 0)
				return piErrRec;
			AssertNonZero(pFileRec->SetMsiString(CMsiFile::ifqFileName,*strFileName));
			
			unsigned int uiExistingClusteredSize;
			Bool fInUse;

			// Check existing file versioning only if file is not already marked
			// to be deleted by RemoveFile table.
			MsiString strFullFilePath;
			piErrRec = pDestPath->GetFullFilePath(strFileName,*&strFullFilePath);
			if (piErrRec)
				return piErrRec;
			Bool fOnList;
			piErrRec = CheckRemoveFileList(*strFullFilePath, riComponentString, fOnList);
			if (piErrRec)
				return piErrRec;
			if (fOnList)
			{
				fInUse = fFalse;
				uiExistingClusteredSize = 0;
				pFileRec->SetInteger(CMsiFile::ifqState,fTrue);
			}
			else
			{
				piErrRec = GetFileInstallState(m_riEngine, *pFileRec, /* piCompanionFileRec=*/ 0,
														 &uiExistingClusteredSize, &fInUse, 0,
														 /* fIgnoreCompanionParentAction=*/ false,
														 /* fIncludeHashCheck=*/ true, NULL);
				if (piErrRec)
					return piErrRec;
			}

			// put combined name back - can't update persistent data
			AssertNonZero(pFileRec->SetMsiString(CMsiFile::ifqFileName,*strFileNamePair));
			if ((piErrRec = m_pCostView->Modify(*pFileRec, irmUpdate)) != 0)
				return piErrRec;

			// iisAbsent costs
			iNoRbRemoveCost -= uiExistingClusteredSize;

			// iisSource costs
			if (pFileRec->GetInteger(CMsiFile::ifqInstalled) == iisLocal)
				iNoRbSourceCost -= uiExistingClusteredSize;

			// iisLocal costs
			if (pFileRec->GetInteger(CMsiFile::ifqState) == fTrue)
			{
				unsigned int uiNewClusteredSize;
				if ((piErrRec = pDestPath->ClusteredFileSize(pFileRec->GetInteger(CMsiFile::ifqFileSize),
					uiNewClusteredSize)) != 0)
					return piErrRec;
				iLocalCost += uiNewClusteredSize;
				iNoRbLocalCost += uiNewClusteredSize;
				iARPLocalCost += uiNewClusteredSize;
				iNoRbARPLocalCost += uiNewClusteredSize;
				if (!fInUse)
				{
					iNoRbLocalCost -= uiExistingClusteredSize;
					iNoRbARPLocalCost -= uiExistingClusteredSize;
				}

	#ifdef LOG_COSTING
				ICHAR rgch[300];
				StringCbPrintf(rgch, sizeof(rgch),TEXT("File: %s; Local cost: %i"),(const ICHAR*) strFullFilePath, iLocalCost * 512);
				DEBUGMSG(rgch);
	#endif
			}

			iisEnum iisAction = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqAction);
			iisEnum iisInstalled = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqInstalled);
			Bool fShouldInstall = (Bool)pFileRec->GetInteger(CMsiFile::ifqState);

			if (!fShouldInstall && iisAction == iisLocal && iisInstalled == iisAbsent)
			{
				// per bug 182012, even though we aren't installing the file, we still need to include the cost
				// of the file for the estimated install size.

				// we add in the cost of the existing file for the ARP cost (since this file isn't installed,
				// the rollback and no rollback costs are the same)
				iARPLocalCost += uiExistingClusteredSize;
				iNoRbARPLocalCost += uiExistingClusteredSize;
			}

			// file in use
			if(fAddFileInUse && fInUse &&                               // file in use, and we should add to list
				((iisAction == iisLocal && fShouldInstall) ||            // will install file local OR
				 FShouldDeleteFile(iisInstalled, iisAction)))  // will remove file
			{
				piErrRec = PlaceFileOnInUseList(m_riEngine, *strFileName,
														  *MsiString(pDestPath->GetPath()));
				if(piErrRec)
					return piErrRec;
			}
		}
	}
	else // component is installing assembly to GAC
	{
		// global assembly cost is attributed to the WindowsFolder
		if (riDirectoryString.Compare(iscExact,IPROPNAME_WINDOWS_FOLDER) == 0)
			return 0;

		// create the assembly name object
		LPCOLESTR szAssemblyName;
#ifndef UNICODE
		CTempBuffer<WCHAR, 1024>  rgchAssemblyNameUNICODE;
		ConvertMultiSzToWideChar(*strAssemblyName, rgchAssemblyNameUNICODE);
		szAssemblyName = rgchAssemblyNameUNICODE;
#else
		szAssemblyName = strAssemblyName;
#endif

		HRESULT hr;
		PAssemblyCache pCache(0);
		if(iatAT == iatURTAssembly)
			hr = FUSION::CreateAssemblyCache(&pCache, 0);
		else
		{
			Assert(iatAT == iatWin32Assembly);
			hr = SXS::CreateAssemblyCache(&pCache, 0);
		}
		bool fAssemblyInstalled = false;
		if(SUCCEEDED(hr))
		{
			// NOTE: At some point, QueryAssemblyInfo is supposed to also provide the disk cost of the installed assembly
			// For now, we just determine whether or not it is installed
			hr = pCache->QueryAssemblyInfo(0, szAssemblyName, NULL);

			if(SUCCEEDED(hr)) 
			{
				// assembly is installed
				fAssemblyInstalled = true;
			}
		} 
		else
		{
			if(iatAT == iatURTAssembly) // if cannot find fusion, assume we are bootstrapping, hence assume no assembly installed
			{
				PMsiRecord(PostAssemblyError(riComponentString.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT));
				DEBUGMSG(TEXT("ignoring fusion interface error, assuming we are bootstrapping"));
			}
			else
				return PostAssemblyError(riComponentString.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT);
		}

		// for all files that are part of this assembly
		// note that assembly files have atomic operations and are managed as a unit
		// therefore, all files will be installed or all files will not be installed
		unsigned int uiTotalClusteredSize = 0;
		iisEnum iisAction = (iisEnum)iMsiNullInteger;
		iisEnum iisInstalled = (iisEnum)iMsiNullInteger;

		while (pFileRec = m_pCostView->Fetch())
		{
			unsigned int uiClusteredSize = 0;
			if ((piErrRec = pDestPath->ClusteredFileSize(pFileRec->GetInteger(CMsiFile::ifqFileSize), uiClusteredSize)) != 0)
				return piErrRec;

			uiTotalClusteredSize += uiClusteredSize;

			if (iMsiNullInteger == iisAction)
				iisAction = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqAction);
			if (iMsiNullInteger == iisInstalled)
				iisInstalled = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqInstalled);
		}

		// determine the costs
		if (fAssemblyInstalled)
		{
			iLocalCost += uiTotalClusteredSize;
			iNoRbSourceCost -= uiTotalClusteredSize;
			iNoRbRemoveCost -= uiTotalClusteredSize;

			// determine ARP costs, special case
			if (iisAction == iisLocal && iisInstalled == iisAbsent)
			{
				iARPLocalCost += uiTotalClusteredSize;
				iNoRbARPLocalCost += uiTotalClusteredSize;
			}
		}
		else // !fAssemblyInstalled
		{
			iLocalCost += uiTotalClusteredSize;
			iNoRbLocalCost += uiTotalClusteredSize;
			iARPLocalCost += uiTotalClusteredSize;
			iNoRbARPLocalCost += uiTotalClusteredSize;
		}
	}// end global assembly cost calculation

	return 0;
}



IMsiRecord* CMsiFileCost::CheckRemoveFileList(const IMsiString& riFullPathString, const IMsiString& riComponentString, Bool& fOnList)
{
	fOnList = fFalse;
	if (m_fRemoveFilePathTableMissing)
		return 0;

	IMsiRecord* piErrRec;
	if (m_piRemoveFilePathTable == 0)
	{
		PMsiDatabase pDatabase(m_riEngine.GetDatabase());
		piErrRec = pDatabase->LoadTable(*MsiString(*sztblRemoveFilePath),0, m_piRemoveFilePathTable);
		if (piErrRec)
		{
			if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
			{
				piErrRec->Release();
				m_fRemoveFilePathTableMissing = fTrue;
				return 0;
			}
			else
				return piErrRec;
		}

		m_piRemoveFilePathCursor = m_piRemoveFilePathTable->CreateCursor(fFalse);
		Assert(m_piRemoveFilePathCursor);

		m_colRemoveFilePath = m_piRemoveFilePathTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFilePath_colPath));
		m_colRemoveFilePathComponent = m_piRemoveFilePathTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFilePath_colComponent));
		m_colRemoveFilePathMode = m_piRemoveFilePathTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFilePath_colRemoveMode));
	}

	MsiString strUpperFullPath;
	riFullPathString.UpperCase(*&strUpperFullPath);
	m_piRemoveFilePathCursor->Reset();
	m_piRemoveFilePathCursor->SetFilter(iColumnBit(m_colRemoveFilePath));
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePath,*strUpperFullPath);
	if (m_piRemoveFilePathCursor->Next())
	{
		iisEnum iisAction;
		PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
		MsiString strRemoveComponent = m_piRemoveFilePathCursor->GetString(m_colRemoveFilePathComponent);
		piErrRec = pSelectionMgr->GetComponentStates(*strRemoveComponent,NULL, &iisAction);
		if (piErrRec)
			return piErrRec;

		if (iisAction == iisLocal || iisAction == iisAbsent)
		{
			int iMode = m_piRemoveFilePathCursor->GetInteger(m_colRemoveFilePathMode);
			if (iisAction == iisLocal && (iMode & msidbRemoveFileInstallModeOnInstall) ||
				iisAction == iisAbsent && (iMode & msidbRemoveFileInstallModeOnRemove))
			{
				fOnList = fTrue;
			}
		}

		if (strRemoveComponent.Compare(iscExact,riComponentString.GetString()) == 0)
		{
			piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strRemoveComponent,riComponentString);
			if (piErrRec)
				return piErrRec;
		}
	}

	return 0;
}

// InstallFiles Media Table query enums
enum mfnEnum
{
	mfnLastSequence = 1,
	mfnDiskPrompt,
	mfnVolumeLabel,
	mfnCabinet,
	mfnSource,
	mfnDiskId,
	mfnNextEnum
};

Bool IsCachedPackage(IMsiEngine& riEngine, const IMsiString& riPackage, Bool fPatch, const ICHAR* szCode)
{
	PMsiRecord pErrRec = 0;
	PMsiServices pServices(riEngine.GetServices());

	Bool fCached = fFalse;
	
	// get local package path
	CTempBuffer<ICHAR, MAX_PATH> rgchLocalPackage;
	if (fPatch)
	{
		if (!GetPatchInfo(szCode, INSTALLPROPERTY_LOCALPACKAGE, 
							rgchLocalPackage))
		{
			return fFalse;
		}
	}
	else
	{
		MsiString strProductKey;
		if (szCode)
			strProductKey = szCode;
		else
			strProductKey = riEngine.GetProductKey();

		if (!GetProductInfo(strProductKey, INSTALLPROPERTY_LOCALPACKAGE, 
							rgchLocalPackage))
		{
			return fFalse;
		}
	}

	PMsiPath pDatabasePath(0);
	PMsiPath pLocalPackagePath(0);
	MsiString strDatabaseName;
	MsiString strLocalPackageName;
	ipcEnum ipc;

	if (((pErrRec = pServices->CreateFilePath(riPackage.GetString(), *&pDatabasePath, *&strDatabaseName)) == 0) &&
		 ((pErrRec = pServices->CreateFilePath(rgchLocalPackage, *&pLocalPackagePath, *&strLocalPackageName)) == 0) &&
		((pErrRec = pDatabasePath->Compare(*pLocalPackagePath, ipc)) == 0))
	{
		fCached = (ipc == ipcEqual && strDatabaseName.Compare(iscExactI,strLocalPackageName)) ? fTrue : fFalse;
	}

	return fCached;
}


iesEnum ExecuteChangeMedia(IMsiEngine& riEngine, IMsiRecord& riMediaRec, IMsiRecord& riParamsRec, const IMsiString& ristrTemplate, 
						   unsigned int cbPerTick, const IMsiString& ristrFirstVolLabel)
{
	iesEnum iesExecute;
	PMsiServices pServices(riEngine.GetServices());
	
	// Disk prompt string is created by formatting disk name from media table
	// into the DiskPrompt property template.
	PMsiRecord pPromptRec(&pServices->CreateRecord(2));
	pPromptRec->SetMsiString(0, ristrTemplate);
	pPromptRec->SetMsiString(2, *MsiString(riEngine.GetPropertyFromSz(IPROPNAME_DISKPROMPT)));
	pPromptRec->SetMsiString(0,*MsiString(pPromptRec->FormatText(fFalse)));
	pPromptRec->SetMsiString(1, *MsiString(riMediaRec.GetMsiString(mfnDiskPrompt)));

	riParamsRec.ClearData();

	MsiString strMediaLabel = riMediaRec.GetString(mfnVolumeLabel);
	bool fIsFirstPhysicalDisk = false;
	if(strMediaLabel.Compare(iscExact,ristrFirstVolLabel.GetString()))
	{
		// we are looking at the first Media table record
		// we allow the first disk's volume label to not match the real volume label
		// this is for authoring simplicity with single-volume installs

		// in first-run we use the IPROPNAME_CURRENTMEDIAVOLUMELABEL property, which will
		// be set if we're running from media

		// in maintenance-mode we need to use the label that was stored in the registry source
		// list for this product (if there is one)

		fIsFirstPhysicalDisk = true;
		if (riEngine.GetMode() & iefMaintenance)
		{
			// Media label from sourcelist is always what we want - even if its blank
			strMediaLabel = GetDiskLabel(*pServices, riMediaRec.GetInteger(mfnDiskId), MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PRODUCTCODE)));
		}
		else // first-run
		{
			// if CURRENTMEDIAVOLUMELABEL is an empty string, it means we aren't running from Media - just use label from Media table
			// if CURRENTMEDIAVOLUMELABEL is szBlankVolumeLabelToken, the Media has a blank label
			MsiString strReplacementLabel = riEngine.GetPropertyFromSz(IPROPNAME_CURRENTMEDIAVOLUMELABEL);
			if (strReplacementLabel.TextSize() && !strReplacementLabel.Compare(iscExact, strMediaLabel))
			{
				if (strReplacementLabel.Compare(iscExact, szBlankVolumeLabelToken))
					strMediaLabel = g_MsiStringNull;
				else
					strMediaLabel = strReplacementLabel;
			}
		}
	}
	
	riParamsRec.SetMsiString(IxoChangeMedia::MediaVolumeLabel,*strMediaLabel);
	riParamsRec.SetMsiString(IxoChangeMedia::MediaPrompt,*MsiString(pPromptRec->FormatText(fFalse)));
	riParamsRec.SetInteger(IxoChangeMedia::BytesPerTick,cbPerTick);
	riParamsRec.SetInteger(IxoChangeMedia::IsFirstPhysicalMedia,fIsFirstPhysicalDisk ? 1 : 0);
	
	MsiString strMediaCabinet(riMediaRec.GetMsiString(mfnCabinet));
	if (strMediaCabinet.TextSize() == 0)
	{
		riParamsRec.SetInteger(IxoChangeMedia::CopierType,ictFileCopier);
	}
	else 
	{	
		PMsiRecord pErrRec(0);
	
		// cabinet copy
		if (strMediaCabinet.Compare(iscStart,TEXT("#")))
		{
			// cabinet is in stream of storage object

			MsiString strModuleName, strSubStorageList;
			strMediaCabinet = strMediaCabinet.Extract(iseLast, strMediaCabinet.TextSize() - 1);
			
			// is storage our database or an external storage?
			MsiString strSourceProp = riMediaRec.GetMsiString(mfnSource); // could be null
			
			// is storage top-level or a substorage?
			if(!strSourceProp.TextSize() &&  // storage not defined by an arbitrary property - if it were
														// it would be a top-level storage
				*(const ICHAR*)MsiString(riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE)) == ':') // sub-storage
			{
				// sub-storage: cabinets will be in the sub-storage even if we are using the cached msi
				// since we only drop cabinets from the top-level storage when caching

				PMsiDatabase pDatabase(riEngine.GetDatabase());
				PMsiStorage pStorage(0);
				if(pDatabase)
					pStorage = pDatabase->GetStorage(1);
				
				if(!pStorage)
				{
					pErrRec = PostError(Imsg(idbgMissingStorage));
					return riEngine.FatalError(*pErrRec);
				}

				pErrRec = pStorage->GetSubStorageNameList(*&strModuleName, *&strSubStorageList);
				if(pErrRec)
					return riEngine.FatalError(*pErrRec);

				Assert(strModuleName.TextSize() && strSubStorageList.TextSize());
			}
			else
			{
				// storage is top-level

				if(!strSourceProp.TextSize())
				{
					if(riEngine.FChildInstall())
					{
						// if child is merged, DATABASE may not exist during file copy (since its temporary)
						strSourceProp = *IPROPNAME_ORIGINALDATABASE; 
					}
					else
					{
						strSourceProp = *IPROPNAME_DATABASE;
					}
				}

				MsiString strDatabasePath = riEngine.GetProperty(*strSourceProp);
				
				// by default, module name is path to database we are running
				strModuleName = strDatabasePath;

				// If we're in maintenance mode (or applying a patch that changes the product code)
				// then it's possible we are running from a cached database
				// If the source of our cabinets is a cached database then the cabinets won't be there.
				MsiString strPatchedProductKey = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);
				if (strPatchedProductKey.TextSize() || riEngine.GetMode() & iefMaintenance)
				{
					// if we are in maintenance mode, the current product has a cached msi and that's the one
					// we'd be using.  if not in maintenance mode, we must be patching a product to a new product
					// code and we may be using the cached msi belonging to the old product
					MsiString strProductKeyForCachedPackage;
					if(riEngine.GetMode() & iefMaintenance)
						strProductKeyForCachedPackage = riEngine.GetProductKey();
					else
						strProductKeyForCachedPackage = strPatchedProductKey;
						
					// Check whether our cabinets are in the cached database
					if (IsCachedPackage(riEngine, *strDatabasePath, fFalse, strProductKeyForCachedPackage))
					{
						// running from source package
						// if a child install, we'll resolve the source here
						// if not a child install, postpone source resolution to script execution
						if(riEngine.FChildInstall())
						{
							if ((pErrRec = ENG::GetSourcedir(*PMsiDirectoryManager(riEngine, IID_IMsiDirectoryManager), *&strModuleName)) != 0)
							{
								if (pErrRec->GetInteger(1) == imsgUser)
									return iesUserExit;
								else
									return riEngine.FatalError(*pErrRec);
							}
						}
						else
						{
							// not a child install - include path with "unresolved source" token
							strModuleName = szUnresolvedSourceRootTokenWithBS;
						}
						
						strModuleName += MsiString(riEngine.GetPackageName());
					}
				}
			}
			AssertNonZero(riParamsRec.SetMsiString(IxoChangeMedia::ModuleFileName,*strModuleName));
			AssertNonZero(riParamsRec.SetMsiString(IxoChangeMedia::ModuleSubStorageList,*strSubStorageList));
			AssertNonZero(riParamsRec.SetInteger(IxoChangeMedia::CopierType,ictStreamCabinetCopier));
		}
		else
		{
			// cabinet is in file
			riParamsRec.SetInteger(IxoChangeMedia::CopierType,ictFileCabinetCopier);

			// external cabs always live at IPROPNAME_SOURCEDIR
			// the Media.Source column can contain a different property, but that's only
			// supported for patches, which currently only use embedded cabs

			// if a child install, get full path to cabinet
			if(riEngine.FChildInstall())
			{
				PMsiPath pCabinetSourcePath(0);
				PMsiDirectoryManager pDirectoryManager(riEngine, IID_IMsiDirectoryManager);

				if ((pErrRec = GetSourcedir(*pDirectoryManager, *&pCabinetSourcePath)) != 0)
				{
					if (pErrRec->GetInteger(1) == imsgUser)
						return iesUserExit;
					else
						return riEngine.FatalError(*pErrRec); //?? Is this error return OK?
				}

				MsiString strCabinetPath;
				if((pErrRec = pCabinetSourcePath->GetFullFilePath(strMediaCabinet,*&strCabinetPath)) != 0)
					return riEngine.FatalError(*pErrRec);

				strMediaCabinet = strCabinetPath;
			}
			else
			{
				// just pass cabinet name in script - will resolve source during script execution
				MsiString strTemp = szUnresolvedSourceRootTokenWithBS;
				strTemp += strMediaCabinet;
				strMediaCabinet = strTemp;
			}

			// check the DigitalSignature table for signature information on this CAB. 
			PMsiStream pHash(0);
			PMsiStream pCertificate(0);
			MsiString strObject(riMediaRec.GetInteger(mfnDiskId));
			MsiString strMedia(sztblMedia);
			switch (GetObjectSignatureInformation(riEngine, *strMedia, *strObject, *&pCertificate, *&pHash))
			{
			case iesNoAction:
				// this cab does not require a signature
				riParamsRec.SetInteger(IxoChangeMedia::SignatureRequired, 0);
				break;
			case iesFailure:
				// problem with the authored signature information. Must fail for security reasons.
				return iesFailure;
			case iesSuccess:
			{
				// a signature is required on this cab. 
				riParamsRec.SetInteger(IxoChangeMedia::SignatureRequired, 1);
				riParamsRec.SetMsiData(IxoChangeMedia::SignatureCert, pCertificate);
				riParamsRec.SetMsiData(IxoChangeMedia::SignatureHash, pHash);
				break;
			}
			default:
				AssertSz(0, "Unknown return type from GetObjectSignatureInformation");
				break;
			}			
		}
	}
	
	riParamsRec.SetMsiString(IxoChangeMedia::MediaCabinet,*strMediaCabinet);
	if ((iesExecute = riEngine.ExecuteRecord(ixoChangeMedia,riParamsRec)) != iesSuccess)
		return iesExecute;

	return iesSuccess;
}


const ICHAR sqlMediaSequence[] = 
TEXT("SELECT `LastSequence`, `DiskPrompt`,%s,`Cabinet`, `DiskId` FROM `Media` ORDER BY `DiskId`");

const ICHAR sqlMediaSequenceWithSource[] = 
TEXT("SELECT `LastSequence`, `DiskPrompt`,%s,`Cabinet`,`Source`, `DiskId` FROM `Media` ORDER BY `DiskId`");

// local fn used by OpenMediaView
// returns fTrue is the Media table has a column called "Source"
Bool FMediaSourceColumn(IMsiEngine& riEngine)
{
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pColumnCatalogTable = pDatabase->GetCatalogTable(1);
	PMsiCursor pColumnCatalogCursor = pColumnCatalogTable->CreateCursor(fFalse);
	pColumnCatalogCursor->SetFilter(iColumnBit(1 /*cccTable*/) | iColumnBit(3 /*cccName*/));
	AssertNonZero(pColumnCatalogCursor->PutString(1 /*cccTable*/,*MsiString(*TEXT("Media"))));
	AssertNonZero(pColumnCatalogCursor->PutString(3 /*cccName*/,*MsiString(*TEXT("Source"))));
	if(pColumnCatalogCursor->Next())
		return fTrue;
	else
		return fFalse;
}

// open a view on the media table - use mfnEnum with fetched records
IMsiRecord* OpenMediaView(IMsiEngine& riEngine, IMsiView*& rpiView, const IMsiString*& rpistrFirstVolLabel)
{
	Bool fMediaSourceColumn = FMediaSourceColumn(riEngine);
	
	ICHAR szQuery[256];
	if(fMediaSourceColumn)
		StringCbPrintf(szQuery, sizeof(szQuery), sqlMediaSequenceWithSource, TEXT("`VolumeLabel`"));
	else
		StringCbPrintf(szQuery, sizeof(szQuery), sqlMediaSequence, TEXT("`VolumeLabel`"));

	PMsiView pView(0);
	IMsiRecord* piError = riEngine.OpenView(szQuery,ivcFetch,rpiView);
	if(piError)
		return piError;

	piError = rpiView->Execute(0);
	if(piError)
		return piError;

	// need to return the first diskID in the out param - fetch first rec, read diskID, re-execute
	PMsiRecord pRec = rpiView->Fetch();
	if(pRec)
	{
		MsiString(pRec->GetMsiString(mfnVolumeLabel)).ReturnArg(rpistrFirstVolLabel);
	}

	piError = rpiView->Execute(0);
	if(piError)
		return piError;

	// NOTE: ExecuteChangeMedia now special cases records with the first disks VolumeLabel to
	// possibly override the authored media label

	return 0;
}




// Internal action - called only from InstallFiles
iesEnum InstallProtectedFiles(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiRecord pRec = &pServices->CreateRecord(1);
	iuiEnum iui;
	if (g_scServerContext == scClient)
		iui = g_MessageContext.GetUILevel();
	else
		iui = (iuiEnum)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_CLIENTUILEVEL)); 
	bool fAllowUI = (iui == iuiNone) ? false : true;
	pRec->SetInteger(IxoInstallProtectedFiles::AllowUI, fAllowUI);
	return riEngine.ExecuteRecord(ixoInstallProtectedFiles, *pRec);
}

static bool ShouldCheckCRC(const bool fPropertySet,
									const iisEnum iisAction,
									const int iFileAttributes)
{
	if ( fPropertySet && iisAction == iisLocal && 
		  (iFileAttributes & msidbFileAttributesChecksum) == msidbFileAttributesChecksum )
		return true;
	else
		return false;
}

const ICHAR sqlPatchesOld[] =
TEXT("SELECT `Patch`.`File_`, `Patch`.`Header`, `Patch`.`Attributes`, NULL FROM `Patch` WHERE `Patch`.`File_` = ? AND `Patch`.`Sequence` > ?")
TEXT("ORDER BY `Patch`.`Sequence`");

const ICHAR sqlPatchesNew[] =
TEXT("SELECT `Patch`.`File_`, `Patch`.`Header`, `Patch`.`Attributes`, `Patch`.`StreamRef_` FROM `Patch` WHERE `Patch`.`File_` = ? AND `Patch`.`Sequence` > ?")
TEXT("ORDER BY `Patch`.`Sequence`");

enum pteEnum // Patch table query enum
{
	pteFile = 1,
	pteHeader,
	pteAttributes,
	pteStreamRef
};

const ICHAR sqlMsiPatchHeaders[] =
TEXT("SELECT `Header` FROM `MsiPatchHeaders` WHERE `StreamRef` = ?");

const ICHAR sqlBypassSFC[] =
TEXT("SELECT `File_` FROM `MsiSFCBypass` WHERE `File_` = ?");

const ICHAR sqlPatchOldAssemblies[] =
TEXT("SELECT `MsiPatchOldAssemblyFile`.`Assembly_` FROM `MsiPatchOldAssemblyFile` WHERE  `MsiPatchOldAssemblyFile`.`File_` = ?");

iesEnum InstallFiles(IMsiEngine& riEngine)
{
	if (!IsFileActivityEnabled(riEngine))
		return InstallProtectedFiles(riEngine);

	PMsiServices pServices(riEngine.GetServices());
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(pDirectoryMgr);
	int fMode = riEngine.GetMode();

	PMsiRecord pErrRec(0);
	PMsiRecord pRecParams = &pServices->CreateRecord(IxoChangeMedia::Args);
	iesEnum iesExecute;

	Bool fAdmin = (riEngine.GetMode() & iefAdmin) ? fTrue : fFalse;

	// Create our file manager, and order by directory if we're not installing
	// from compression cabinets.
	CMsiFileInstall objFile(riEngine);

	unsigned int cbTotalCost;
	pErrRec = objFile.TotalBytesToCopy(cbTotalCost);
	if (pErrRec)
	{
		// If File table is missing, not an error;
		// simply nothing to do
		if (pErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
		{
			iesExecute = InstallProtectedFiles(riEngine); 
			return iesExecute == iesSuccess ? iesNoAction : iesExecute;
		}
		else
			return riEngine.FatalError(*pErrRec);
	}

	if(cbTotalCost)
	{
		pRecParams->ClearData();
		pRecParams->SetInteger(IxoProgressTotal::Total, cbTotalCost);
		pRecParams->SetInteger(IxoProgressTotal::Type, 0); // 0: separate progress and action data messages
		pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
		if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
			return iesExecute;
	}

	// Open media table
	PMsiView pMediaView(0);
	MsiString strFirstVolumeLabel;
	pErrRec = OpenMediaView(riEngine,*&pMediaView,*&strFirstVolumeLabel);
	if (pErrRec)
	{
		if (pErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
			pErrRec = PostError(Imsg(idbgMediaTableRequired));

		return riEngine.FatalError(*pErrRec);
	}

	pErrRec = pMediaView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	PMsiPath pDestPath(0);
	PMsiVolume pSourceVol(0); // used only for oem installs
	PMsiVolume pDestVol(0);
	MsiString strSourceDirKey;
	MsiString strDestName;
	MsiString strDestPath;
	MsiString strSourcePath; // may be a relative sub-path

	// LockPermissions table is optional, so politely degrade the functionality
	BOOL fUseACLs = fFalse;
	BOOL fDestSupportsACLs = fFalse;

	int iFileCopyCount = 0;
	int iMediaEnd = 0;  // set to 0 to force media table fetch
	ictEnum ictCurrentMediaType = ictNextEnum;

	PMsiView pviewLockObjects(0);

	if	(	g_fWin9X || fAdmin ||
				(itsUnknown == PMsiDatabase(riEngine.GetDatabase())->FindTable(*MsiString(*TEXT("LockPermissions")))) ||
				(pErrRec = riEngine.OpenView(sqlLockPermissions, ivcFetch, *&pviewLockObjects))
			)
	{
		if (pErrRec)
		{
			int iError = pErrRec->GetInteger(1);
			riEngine.FatalError(*pErrRec);
		}
	}
	else
	{
		fUseACLs = fTrue;
	}
	
	PMsiRecord precLockExecute(&pServices->CreateRecord(2));
	AssertNonZero(precLockExecute->SetMsiString(1, *MsiString(*sztblFile)));

	// open Patch table view - used to grab patch headers for ixoFileCopy ops
	PMsiRecord pPatchViewExecute = &pServices->CreateRecord(2);
	PMsiView pPatchView(0);
	pErrRec = riEngine.OpenView(sqlPatchesNew, ivcFetch, *&pPatchView);
	if (pErrRec)
	{
		if (idbgDbQueryUnknownColumn == pErrRec->GetInteger(1))
		{
			// try old schema patch
			pErrRec = riEngine.OpenView(sqlPatchesOld, ivcFetch, *&pPatchView);
		}

		if (pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable
			//!! next line temp
			&& pErrRec->GetInteger(1) != idbgDbQueryUnknownColumn)
			return riEngine.FatalError(*pErrRec);
	}
	// if pPatchView set, we have a patch table, otherwise we don't

	// open MsiPatchOldAssemblyFile table view
	PMsiRecord pPatchOldAssemblyFileViewExecute(0);
	PMsiView   pPatchOldAssemblyFileView(0);
	
	if(pPatchView)
	{
		pPatchOldAssemblyFileViewExecute = &::CreateRecord(1);
		pErrRec = riEngine.OpenView(sqlPatchOldAssemblies, ivcFetch, *&pPatchOldAssemblyFileView);
		if(pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pErrRec);
	}


	MsiString strDiskPromptTemplate = riEngine.GetErrorTableString(imsgPromptForDisk);

	
	bool fMoveFileForOEMs = false;
	// for oem installs, resolve source now (it is already available during an OEM install)
	// and save off the volume so we can tell when the source and target volumes are the same
	if ( g_MessageContext.IsOEMInstall() )
	{
		PMsiPath pSourcePath(0); 
		
		if ((pErrRec = GetSourcedir(*pDirectoryMgr, *&pSourcePath)) != 0)
		{
			if (pErrRec->GetInteger(1) == imsgUser)
				return iesUserExit;
			else
				return riEngine.FatalError(*pErrRec);
		}

		pSourceVol = &(pSourcePath->GetVolume());
	}
	
	int iSourceTypeForChildInstalls = -1; // we resolve the source now for child installs
													  // (as opposed to during script generation for normal installs)
	PMsiPath pSourceRootForChildInstall(0);
	bool fCheckCRC = 
		MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CHECKCRCS)).TextSize() ? true : false;

	PMsiRecord pBypassSFCExecute = &pServices->CreateRecord(1);
	PMsiView pBypassSFCView(0);
	if (!g_fWin9X)
	{
		pErrRec = riEngine.OpenView(sqlBypassSFC, ivcFetch, *&pBypassSFCView);
		if (pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pErrRec);
	}

	// attempt to open view on MsiPatchHeaders table
	PMsiView pMsiPatchHeadersView(0);
	pErrRec = riEngine.OpenView(sqlMsiPatchHeaders, ivcFetch, *&pMsiPatchHeadersView);
	if (pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
		return riEngine.FatalError(*pErrRec);


	for(;;)
	{
		pErrRec = objFile.FetchFile();
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);

		PMsiRecord pFileRec(objFile.GetFileRecord());
		if (!pFileRec)
		{
			if (iFileCopyCount > 0)
			{
				// Ok, we're done processing all files in the File table.
				// If there are any Media table entries left unprocessed,
				// flush out ChangeMedia operations for each, in case the
				// last file copied was split across disk(s). Otherwise,
				// we'll never change disks to finish copying the last
				// part(s) of the split file.
				PMsiRecord pMediaRec(0);
				while ((pMediaRec = pMediaView->Fetch()) != 0)
				{
					iesExecute = ExecuteChangeMedia(riEngine, *pMediaRec, *pRecParams, *strDiskPromptTemplate, iBytesPerTick, *strFirstVolumeLabel);
					if (iesExecute != iesSuccess)
						return iesExecute;
				}
			}
			break;
		}

#ifdef DEBUG
		const ICHAR* szFileName = pFileRec->GetString(CMsiFile::ifqFileName);
		const ICHAR* szComponent = pFileRec->GetString(CMsiFile::ifqComponent);
#endif //DEBUG

		iisEnum iisAction = (iisEnum) pFileRec->GetInteger(CMsiFile::ifqAction);
		if (iisAction != iisLocal && iisAction != iisSource)
			continue;
		
		int iAttributes = pFileRec->GetInteger(CMsiFile::ifqAttributes) & (~iReservedFileAttributeBits);

		bool fFileIsCompressedInChildInstall = false;
		bool fSourceIsLFNInChildInstall = false;
		if(riEngine.FChildInstall())
		{
			if(iSourceTypeForChildInstalls == -1)
			{	
				pErrRec = pDirectoryMgr->GetSourceRootAndType(*&pSourceRootForChildInstall,
																			 iSourceTypeForChildInstalls);
				if(pErrRec)
				{
					if (pErrRec->GetInteger(1) == imsgUser)
						return iesUserExit;
					else
						return riEngine.FatalError(*pErrRec);
				}

				fSourceIsLFNInChildInstall = FSourceIsLFN(iSourceTypeForChildInstalls,
																		*pSourceRootForChildInstall);
			}

			fFileIsCompressedInChildInstall = FFileIsCompressed(iSourceTypeForChildInstalls,
																				 iAttributes);
		}

		MsiString strFileDir(pFileRec->GetString(CMsiFile::ifqDirectory));

		// set destination folder, but only if necessary
		if (strDestName.Compare(iscExact, strFileDir) == 0 || !pDestPath)
		{
			strDestName = strFileDir;
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestName,*&pDestPath);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if (pDestPath == 0)
			{
				pErrRec = PostError(Imsg(idbgNoProperty), *strDestName);
				return riEngine.FatalError(*pErrRec);
			}
			fDestSupportsACLs = PMsiVolume(&pDestPath->GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS;

			strDestPath = pDestPath->GetPath();
			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*strDestPath);
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			if ( g_MessageContext.IsOEMInstall() )
			{
				pDestVol = &(pDestPath->GetVolume());
				AssertSz(pDestVol, TEXT("Couldn't get pDestVol in InstallFiles"));
				if ( pDestVol && pSourceVol && pDestVol->DriveType() == idtFixed &&
					  pDestVol->VolumeID() && pDestVol->VolumeID() == pSourceVol->VolumeID() )
					fMoveFileForOEMs = true;
				else
					fMoveFileForOEMs = false;
			}
		}
		
		// check for redirected file - compound file key
		MsiString strFileKey(pFileRec->GetMsiString(CMsiFile::ifqFileKey));
		MsiString strSourceFileKey(strFileKey);  // with any compound key suffix removed
		if (((const ICHAR*)strSourceFileKey)[strSourceFileKey.TextSize() - 1] == ')')
		{
			CMsiFile objSourceFile(riEngine);
			AssertNonZero(strSourceFileKey.Remove(iseFrom, '('));
			pErrRec = objSourceFile.FetchFile(*strSourceFileKey);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			PMsiRecord pSourceFileRec = objSourceFile.GetFileRecord();
			strFileDir = pSourceFileRec->GetMsiString(CMsiFile::ifqDirectory);
		}
		
		// set source folder, but only if necessary
		if(strSourceDirKey.Compare(iscExact, strFileDir) == 0)
		{
			strSourceDirKey = strFileDir;

			pErrRec = 0;
			// for nested installs, use full source path (may mean source is resolve prematurely)
			// for non-nested installs, postpone source resolution to script execution
			if(riEngine.FChildInstall())
			{
				Assert(iSourceTypeForChildInstalls >= 0);
				Assert(pSourceRootForChildInstall);
				
				if((iSourceTypeForChildInstalls & msidbSumInfoSourceTypeCompressed) &&
					pSourceRootForChildInstall)
				{
					strSourcePath = pSourceRootForChildInstall->GetPath();
				}
				else
				{
					PMsiPath pSourcePath(0);
					pErrRec = pDirectoryMgr->GetSourcePath(*strSourceDirKey, *&pSourcePath);
					if (pErrRec)
					{
						return riEngine.FatalError(*pErrRec);
					}
					strSourcePath = pSourcePath->GetPath();
				}				
			}
			else
			{
				pErrRec = pDirectoryMgr->GetSourceSubPath(*strSourceDirKey, true, *&strSourcePath);
				if (pErrRec)
				{
					return riEngine.FatalError(*pErrRec);
				}
			}
			
			pRecParams->ClearData();
			AssertNonZero(pRecParams->SetMsiString(IxoSetSourceFolder::Folder,*strSourcePath));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetSourceFolder, *pRecParams)) != iesSuccess)
				return iesExecute;
		}

		int iTempAttributes = pFileRec->GetInteger(CMsiFile::ifqTempAttributes);
		// If this file was identified as having a companion parent (during costing),
		// we've got to execute an ixoSetCompanionParent operation before file copy.
		bool fSetCompanionParent = false;
		DWORD dwDummy;
		if ( g_MessageContext.IsOEMInstall() && 
			  !ParseVersionString(pFileRec->GetString(CMsiFile::ifqVersion), dwDummy, dwDummy) )
			fSetCompanionParent = true;
		else if (iTempAttributes & itfaCompanion)
			fSetCompanionParent = true;
		if ( fSetCompanionParent )
		{
			using namespace IxoSetCompanionParent;
			MsiString strParent(pFileRec->GetMsiString(CMsiFile::ifqVersion));
			CMsiFile objParentFile(riEngine);
			pErrRec = objParentFile.FetchFile(*strParent);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);

			PMsiPath pParentPath(0);
			pErrRec = objParentFile.GetTargetPath(*&pParentPath);
			if (pErrRec)
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}

			PMsiRecord pParentRec(objParentFile.GetFileRecord());

			MsiString strParentFileName;
			if((pErrRec = objParentFile.GetExtractedTargetFileName(*pParentPath, *&strParentFileName)) != 0)
				return riEngine.FatalError(*pErrRec);
			
			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentPath,*MsiString(pParentPath->GetPath()));
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentName,*strParentFileName);
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentVersion,
											 *MsiString(pParentRec->GetString(CMsiFile::ifqVersion)));
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentLanguage,
											 *MsiString(pParentRec->GetString(CMsiFile::ifqLanguage)));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetCompanionParent, *pRecParams)) != iesSuccess)
				return iesExecute;
		}

		pFileRec->SetMsiString(CMsiFile::ifqDirectory, *strDestPath);

		// If iFileSequence is past the end of the current media, switch to
		// the next disk.  Use a loop in case the file we want isn't on the
		// next consecutive disk.
		int iFileSequence = pFileRec->GetInteger(CMsiFile::ifqSequence);
		Assert(iFileSequence > 0);
		while (iFileSequence > iMediaEnd)
		{
			PMsiRecord pMediaRec(pMediaView->Fetch());
			if (pMediaRec == 0)
			{
				pErrRec = PostError(Imsg(idbgMissingMediaTable), *MsiString(sztblFile), *strFileKey);
				return riEngine.FatalError(*pErrRec);
			}
			iMediaEnd = pMediaRec->GetInteger(mfnLastSequence);

			// Always execute the ChangeMedia operation for each Media table entry, even
			// if the next file we want is not on the very next disk - we don't want
			// to miss a ChangeMedia for a split file that needs the next disk (even if
			// we don't have any other files to copy on that next disk).  If it turns out
			// that we don't need to copy any files at all from a particular disk, no
			// problem - the execute operations won't prompt for a disk that isn't needed.
			
			iesExecute = ExecuteChangeMedia(riEngine, *pMediaRec, *pRecParams, *strDiskPromptTemplate, iBytesPerTick, *strFirstVolumeLabel);
			if (iesExecute != iesSuccess)
				return iesExecute;

			ictCurrentMediaType = (ictEnum) pRecParams->GetInteger(IxoChangeMedia::CopierType);
		}

#ifdef DEBUG
		ICHAR rgchFileKey[256];
		strFileKey.CopyToBuf(rgchFileKey,255);
#endif

		// extract appropriate name from short|long pair for target file
		MsiString strDestFileName;
		if((pErrRec = objFile.GetExtractedTargetFileName(*pDestPath,*&strDestFileName)) != 0)
			return riEngine.FatalError(*pErrRec);

		// is this file part of a fusion assembly?
		MsiString strComponentKey = pFileRec->GetMsiString(CMsiFile::ifqComponent);
		iatAssemblyType iatType = iatNone;
		MsiString strManifest;
		if((pErrRec = riEngine.GetAssemblyInfo(*strComponentKey, iatType, 0, &strManifest)) != 0)
			return riEngine.FatalError(*pErrRec);

		bool fAssemblyFile = false;
		if(iatType == iatURTAssembly || iatType == iatWin32Assembly)
		{
			fAssemblyFile = true;
		}

		long cPatchHeaders = 0;
		long cOldAssemblies = 0;

		if(pPatchView)
		{
			AssertNonZero(pPatchViewExecute->SetMsiString(1,*strSourceFileKey));
			AssertNonZero(pPatchViewExecute->SetInteger(2,iFileSequence));
			if((pErrRec = pPatchView->Execute(pPatchViewExecute)) != 0 ||
				(pErrRec = pPatchView->GetRowCount(cPatchHeaders)) != 0)
				return riEngine.FatalError(*pErrRec);

			if(fAssemblyFile && pPatchOldAssemblyFileView)
			{
				AssertNonZero(pPatchOldAssemblyFileViewExecute->SetMsiString(1,*strSourceFileKey));
				if((pErrRec = pPatchOldAssemblyFileView->Execute(pPatchOldAssemblyFileViewExecute)) != 0 ||
					(pErrRec = pPatchOldAssemblyFileView->GetRowCount(cOldAssemblies)) != 0)
					return riEngine.FatalError(*pErrRec);
			}

		}

		PMsiRecord pRecCopy(0);
		int iPatchHeadersStart = 0;
		
		if(false == fAssemblyFile)
		{
			// create record and set args specific to IxoFileCopy
			
			using namespace IxoFileCopy;
			pRecCopy = &pServices->CreateRecord(Args-1+cPatchHeaders);

			iPatchHeadersStart = VariableStart;

			int fInstallModeFlags = GetInstallModeFlags(riEngine,iAttributes);
			if (iisAction == iisSource)
				fInstallModeFlags |= icmRunFromSource;
			else if(iisAction == iisLocal && !pFileRec->IsNull(CMsiFile::ifqForceLocalFiles))
				fInstallModeFlags |= icmOverwriteAllFiles;
			if ( g_MessageContext.IsOEMInstall() && iisAction == iisLocal && fMoveFileForOEMs )
				fInstallModeFlags |= icmRemoveSource;
			pRecCopy->SetInteger(InstallMode,fInstallModeFlags);
			pRecCopy->SetMsiString(Version,*MsiString(pFileRec->GetMsiString(CMsiFile::ifqVersion)));
			pRecCopy->SetMsiString(Language,*MsiString(pFileRec->GetMsiString(CMsiFile::ifqLanguage)));
			pRecCopy->SetInteger(CheckCRC, ShouldCheckCRC(fCheckCRC, iisAction, iAttributes));

			MD5Hash hHash;
			bool fHashInfo = false;
			pErrRec = riEngine.GetFileHashInfo(*strFileKey, /* dwFileSize=*/ 0, hHash, fHashInfo);
			if(pErrRec)
				return riEngine.FatalError(*pErrRec);
			
			if(fHashInfo)
			{
				AssertNonZero(pRecCopy->SetInteger(HashOptions, hHash.dwOptions));
				AssertNonZero(pRecCopy->SetInteger(HashPart1,   hHash.dwPart1));
				AssertNonZero(pRecCopy->SetInteger(HashPart2,   hHash.dwPart2));
				AssertNonZero(pRecCopy->SetInteger(HashPart3,   hHash.dwPart3));
				AssertNonZero(pRecCopy->SetInteger(HashPart4,   hHash.dwPart4));
			}
		}
		else
		{
			// create record and set args specific to IxoAssemblyCopy

			using namespace IxoAssemblyCopy;
			pRecCopy = &pServices->CreateRecord(Args-1+cPatchHeaders+cOldAssemblies);

			// is this file the manifest file?
			if(strManifest.Compare(iscExact, strFileKey))
			{
				pRecCopy->SetInteger(IsManifest, fTrue); // need to know the manifest file during assembly installation
			}

			iPatchHeadersStart = VariableStart;
			int iOldAssembliesStart = iPatchHeadersStart + cPatchHeaders;
			
			if(cOldAssemblies)
			{
				int iIndex = iOldAssembliesStart;
				PMsiRecord pOldAssemblyFetch(0);
				while((pOldAssemblyFetch = pPatchOldAssemblyFileView->Fetch()) != 0)
				{
					MsiString strOldAssembly = pOldAssemblyFetch->GetMsiString(1);

					// get the assembly name
					MsiString strOldAssemblyName;
					pErrRec = riEngine.GetAssemblyNameSz(*strOldAssembly, iatType, true, *&strOldAssemblyName);
					if(pErrRec)
						return riEngine.FatalError(*pErrRec);

					AssertNonZero(pRecCopy->SetMsiString(iIndex++, *strOldAssemblyName));

#ifdef DEBUG				
					DEBUGMSG2(TEXT("OldAssembly fetch: Assembly = '%s', Name = '%s'"),
								 (const ICHAR*)strOldAssembly, (const ICHAR*)strOldAssemblyName);
#endif //DEBUG
				}

				if(pPatchOldAssemblyFileView)
					pPatchOldAssemblyFileView->Close();

				AssertNonZero(pRecCopy->SetInteger(OldAssembliesCount, cOldAssemblies));
				AssertNonZero(pRecCopy->SetInteger(OldAssembliesStart, iOldAssembliesStart));
			}
		
			AssertNonZero(pRecCopy->SetMsiString(ComponentId,*MsiString(pFileRec->GetMsiString(CMsiFile::ifqComponentId))));
		}
			
		{
			// now set the args in the record that are shared between
			// IxoFileCopy and IxoAssemblyCopy

			Assert(IxoFileCopyCore::SourceName         == IxoFileCopy::SourceName         && IxoFileCopyCore::SourceName         == IxoAssemblyCopy::SourceName);
			Assert(IxoFileCopyCore::SourceCabKey       == IxoFileCopy::SourceCabKey       && IxoFileCopyCore::SourceCabKey       == IxoAssemblyCopy::SourceCabKey);
			Assert(IxoFileCopyCore::DestName           == IxoFileCopy::DestName           && IxoFileCopyCore::DestName           == IxoAssemblyCopy::DestName);
			Assert(IxoFileCopyCore::Attributes         == IxoFileCopy::Attributes         && IxoFileCopyCore::Attributes         == IxoAssemblyCopy::Attributes);
			Assert(IxoFileCopyCore::FileSize           == IxoFileCopy::FileSize           && IxoFileCopyCore::FileSize           == IxoAssemblyCopy::FileSize);
			Assert(IxoFileCopyCore::PerTick            == IxoFileCopy::PerTick            && IxoFileCopyCore::PerTick            == IxoAssemblyCopy::PerTick);
			Assert(IxoFileCopyCore::IsCompressed       == IxoFileCopy::IsCompressed       && IxoFileCopyCore::IsCompressed       == IxoAssemblyCopy::IsCompressed);
			Assert(IxoFileCopyCore::VerifyMedia        == IxoFileCopy::VerifyMedia        && IxoFileCopyCore::VerifyMedia        == IxoAssemblyCopy::VerifyMedia);
			Assert(IxoFileCopyCore::ElevateFlags       == IxoFileCopy::ElevateFlags       && IxoFileCopyCore::ElevateFlags       == IxoAssemblyCopy::ElevateFlags);
			Assert(IxoFileCopyCore::TotalPatches       == IxoFileCopy::TotalPatches       && IxoFileCopyCore::TotalPatches       == IxoAssemblyCopy::TotalPatches);
			Assert(IxoFileCopyCore::PatchHeadersStart  == IxoFileCopy::PatchHeadersStart  && IxoFileCopyCore::PatchHeadersStart  == IxoAssemblyCopy::PatchHeadersStart);
			Assert(IxoFileCopyCore::SecurityDescriptor == IxoFileCopy::SecurityDescriptor && IxoFileCopyCore::SecurityDescriptor == IxoAssemblyCopy::Empty);

			Assert(pRecCopy);

			using namespace IxoFileCopyCore;

			if(cPatchHeaders)
			{
				int iIndex = iPatchHeadersStart;
				PMsiRecord pPatchFetch(0);

				PMsiRecord pMsiPatchHeadersExecute = &pServices->CreateRecord(1);
				PMsiRecord pMsiPatchHeadersFetch(0);

				while((pPatchFetch = pPatchView->Fetch()) != 0)
				{
	#ifdef DEBUG
					const ICHAR* szFile = pPatchFetch->GetString(pteFile);
	#endif //DEBUG
					if (fFalse == pPatchFetch->IsNull(pteHeader))
					{
						AssertNonZero(pRecCopy->SetMsiData(iIndex++, PMsiData(pPatchFetch->GetMsiData(pteHeader))));
					}
					else // patch row hit OLE stream name limit, header is in the MsiPatchHeaders table
					{
						if (pPatchFetch->IsNull(pteStreamRef) == fTrue)
						{
							pErrRec = PostError(Imsg(idbgTableDefinition), *MsiString(sztblPatch));
							return riEngine.FatalError(*pErrRec);
						}

						if (!pMsiPatchHeadersView)
						{
							// Patch table row is set up to reference MsiPatchHeaders table, but the MsiPatchHeaders table is missing
							pErrRec = PostError(Imsg(idbgBadForeignKey), *MsiString(pPatchFetch->GetMsiString(pteStreamRef)), *MsiString(*sztblPatch_colStreamRef),*MsiString(*sztblPatch));
							return riEngine.FatalError(*pErrRec);
						}

						pMsiPatchHeadersView->Close();
						AssertNonZero(pMsiPatchHeadersExecute->SetMsiString(1, *MsiString(pPatchFetch->GetMsiString(pteStreamRef))));
						if ((pErrRec = pMsiPatchHeadersView->Execute(pMsiPatchHeadersExecute)) != 0)
							return riEngine.FatalError(*pErrRec);
						if (!(pMsiPatchHeadersFetch = pMsiPatchHeadersView->Fetch()))
						{
							// bad foreign key, can't find row in MsiPatchHeaders table
							pErrRec = PostError(Imsg(idbgBadForeignKey), *MsiString(pPatchFetch->GetMsiString(pteStreamRef)), *MsiString(*sztblPatch_colStreamRef),*MsiString(*sztblPatch));
							return riEngine.FatalError(*pErrRec);
						}
#ifdef DEBUG
						Assert(pMsiPatchHeadersFetch->IsNull(1) == fFalse);
#endif//DEBUG
						AssertNonZero(pRecCopy->SetMsiData(iIndex++, PMsiData(pMsiPatchHeadersFetch->GetMsiData(1))));
					}
				}
			
				AssertNonZero(pRecCopy->SetInteger(TotalPatches, cPatchHeaders));
				AssertNonZero(pRecCopy->SetInteger(PatchHeadersStart, iPatchHeadersStart));
			}

			if(pPatchView)
				pPatchView->Close();

			if(riEngine.FChildInstall())
			{
				MsiString strSourceNameForChildInstall;
				pErrRec = pServices->ExtractFileName(pFileRec->GetString(CMsiFile::ifqFileName),
																 ToBool(fSourceIsLFNInChildInstall),
																 *&strSourceNameForChildInstall);
				if(pErrRec)
					return riEngine.FatalError(*pErrRec);

				AssertNonZero(pRecCopy->SetMsiString(SourceName,*strSourceNameForChildInstall));
			}
			else
			{
				AssertNonZero(pRecCopy->SetMsiString(SourceName,
																 *MsiString(pFileRec->GetMsiString(CMsiFile::ifqFileName))));
			}

			AssertNonZero(pRecCopy->SetMsiString(SourceCabKey,*strSourceFileKey));

			PMsiStream pSD(0);
			if (fUseACLs && fDestSupportsACLs)
			{
				// generate security descriptor
				AssertNonZero(precLockExecute->SetMsiString(2, *strFileKey));
				pErrRec = pviewLockObjects->Execute(precLockExecute);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);

				pErrRec = GenerateSD(riEngine, *pviewLockObjects, precLockExecute, *&pSD);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);

				if ((pErrRec = pviewLockObjects->Close()))
					return riEngine.FatalError(*pErrRec);
				
				
				AssertNonZero(pRecCopy->SetMsiData(SecurityDescriptor, pSD));
			}
			else
				AssertNonZero(pRecCopy->SetNull(SecurityDescriptor));

			// Set up the rest of the CopyTo file parameter record
			pRecCopy->SetMsiString(DestName,*strDestFileName);
			pRecCopy->SetInteger(Attributes,iAttributes);
			pRecCopy->SetInteger(FileSize,pFileRec->GetInteger(CMsiFile::ifqFileSize));
			if(riEngine.FChildInstall())
			{
				pRecCopy->SetInteger(IsCompressed, fFileIsCompressedInChildInstall ? 1 : 0);
			}
			pRecCopy->SetInteger(PerTick,iBytesPerTick);
			pRecCopy->SetInteger(VerifyMedia, fTrue);

			if (pBypassSFCView)
			{
				AssertNonZero(pBypassSFCExecute->SetMsiString(1, *strFileKey));
				pErrRec = pBypassSFCView->Execute(pBypassSFCExecute);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);
				PMsiRecord pFetch = pBypassSFCView->Fetch();
			
				if (pFetch)
				{
					AssertNonZero(pRecCopy->SetInteger(ElevateFlags, ielfBypassSFC));
				}
			}
		}

		if ((iesExecute = riEngine.ExecuteRecord(fAssemblyFile ? ixoAssemblyCopy : ixoFileCopy, *pRecCopy)) != iesSuccess)
			return iesExecute;
		iFileCopyCount++;
	}

	// Always top off InstallFiles by emitting the InstallProtectedFiles Opcode (even if no
	// ixoFileCopy Opcodes were generated, since other previous actions, such as MoveFiles,
	// may have generated ixoFileCopy operations)
	return InstallProtectedFiles(riEngine);
}

bool FFileIsCompressed(int iSourceType, int iFileAttributes)
{
	bool fZeroLengthFileInstall = (iFileAttributes & (msidbFileAttributesNoncompressed | msidbFileAttributesCompressed))
												== (msidbFileAttributesNoncompressed | msidbFileAttributesCompressed);

	bool fAdminImage = (iSourceType & msidbSumInfoSourceTypeAdminImage) ? true : false;
	
	bool fCompressedSource = (iSourceType & msidbSumInfoSourceTypeCompressed) ? true : false;
		
	return ((fCompressedSource && (iFileAttributes & msidbFileAttributesNoncompressed) == 0) ||
			  (!fAdminImage && !fCompressedSource && !fZeroLengthFileInstall && (iFileAttributes & msidbFileAttributesCompressed)) ||
			  (iFileAttributes & msidbFileAttributesPatchAdded)) ? true : false;
}

bool FSourceIsLFN(int iSourceType, IMsiPath& riPath)
{
	if(((iSourceType & msidbSumInfoSourceTypeSFN) == 0) && riPath.SupportsLFN())
		return true;
	else
		return false;
}


/*---------------------------------------------------------------------------
	RemoveFiles costing/action
---------------------------------------------------------------------------*/
class CMsiRemoveFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall Reset();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost, 
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);

public:  // constructor
	CMsiRemoveFileCost(IMsiEngine& riEngine);
protected:
	~CMsiRemoveFileCost();
private:
	enum icrlEnum
	{
		icrlCompileInit,
		icrlCompileDisable,
		icrlCompileDynamic,
		icrlNextEnum
	};
	IMsiRecord* Initialize(Bool fInit);
	IMsiRecord* AddToRemoveFilePathTable(const IMsiString& riPathString, const IMsiString& riComponentString, int iRemoveMode);
	IMsiRecord* RemoveComponentFromRemoveFilePathTable(const IMsiString& riComponentString);
	IMsiRecord* CompileRemoveList(const IMsiString& riComponentString, const IMsiString& riDirectoryString);
	IMsiRecord* GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost, icrlEnum icrlCompileMode);
};
CMsiRemoveFileCost::CMsiRemoveFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiRemoveFileCost::~CMsiRemoveFileCost(){}


IMsiRecord* CMsiRemoveFileCost::Reset()
//------------------------------------------
{
	if (m_piRemoveFilePathCursor)
	{
		m_piRemoveFilePathCursor->Reset();
		while (m_piRemoveFilePathCursor->Next())
		{
			m_piRemoveFilePathCursor->Delete();
		}
	}

	return Initialize(/*fInit=*/ fFalse);
}

IMsiRecord* CMsiRemoveFileCost::Initialize()
//------------------------------------------
{
	return Initialize(/*fInit=*/ fTrue);
}


static const ICHAR sqlInitRemoveFiles[] = TEXT("SELECT `Component_`,`DirProperty` FROM `RemoveFile`");

IMsiRecord* CMsiRemoveFileCost::Initialize(Bool fInit)
//------------------------------------------
{

	enum initmfEnum
	{
		initrfComponent = 1,
		initrfDirProperty,
		initrfNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitRemoveFiles, ivcFetch, *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pViewRec(pView->Fetch());
		if (!pViewRec)
			break;

		MsiString strComponent(pViewRec->GetMsiString(initrfComponent));
		MsiString strDirProperty(pViewRec->GetMsiString(initrfDirProperty));
		if (fInit)
		{
			piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent, *strDirProperty);
			if (piErrRec)
				return piErrRec;
		}
		else
		{
			MsiString strPath(m_riEngine.GetProperty(*strDirProperty));
			if (strPath.TextSize())
			{
				piErrRec = CompileRemoveList(*strComponent, *strDirProperty);
				if (piErrRec)
					return piErrRec;
			}
		}

	}
	return 0;
}

IMsiRecord* CMsiRemoveFileCost::CompileRemoveList(const IMsiString& riComponentString, const IMsiString& riDirectoryString)
{

	Bool fAddFileInUse = fFalse;
	int iRemoveCost, iNoRbRemoveCost, iLocalCost, iLocalNoRbCost, iSourceCost, iNoRbSourceCost, iARPLocalCost, iNoRbARPLocalCost;

	return GetDynamicCost(riComponentString, riDirectoryString, fAddFileInUse, iRemoveCost, iNoRbRemoveCost, iLocalCost,
							iLocalNoRbCost, iSourceCost, iNoRbSourceCost, iARPLocalCost, iNoRbARPLocalCost, icrlCompileInit);
}


IMsiRecord* CMsiRemoveFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
{
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	icrlEnum icrlCompileMode = pSelectionMgr->IsCostingComplete() ? icrlCompileDynamic : icrlCompileDisable;
	return GetDynamicCost(riComponentString, riDirectoryString, fAddFileInUse, iRemoveCost, iNoRbRemoveCost, 
		                  iLocalCost, iNoRbLocalCost, iSourceCost, iNoRbSourceCost, iARPLocalCost, iNoRbARPLocalCost, icrlCompileMode);
}
										

IMsiRecord* ExtractUnvalidatedFileName(const ICHAR *szFileName, Bool fLFN, const IMsiString*& rpistrExtractedFileName)
/*----------------------------------------------------------------------------
Extracts a short or long file name, based on fLFN, from szFileName. szFileName 
is of the form-> shortFileName OR longFileName OR shortFileName|longFileName. 
Unlike the ExtractFileName services function, this one does not validate
the syntax of the filename.
----------------------------------------------------------------------------*/
{
	MsiString strCombinedFileName(szFileName);
	MsiString strFileName = strCombinedFileName.Extract(fLFN ? iseAfter : iseUpto, chFileNameSeparator);
	strFileName.ReturnArg(rpistrExtractedFileName);
	return NOERROR;
}


static const ICHAR sqlRemoveFileCost[] = 
	TEXT("SELECT `FileName`,`InstallMode` FROM `RemoveFile` WHERE `Component_`=? AND `DirProperty`=?");

static const ICHAR sqlShortRemoveFileCost[] =
	TEXT("SELECT `FileName`,NULL FROM `RemoveFile` WHERE `Component_`=? AND `DirProperty`=?");

IMsiRecord* CMsiRemoveFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost, icrlEnum icrlCompileMode)
//--------------------------------------------
{

	enum irfcEnum
	{
		irfcFileName = 1,
		irfcInstallMode = 2,
		irfcNextEnum
	};

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iSourceCost = iNoRbLocalCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	
	// Walk through every file in the RemoveFile table that is tied to riComponentString.
	PMsiServices pServices(m_riEngine.GetServices());
	IMsiRecord* piErrRec;

	if (!m_pCostView)
	{
		if ((piErrRec = m_riEngine.OpenView(sqlRemoveFileCost, ivcFetch, *&m_pCostView)) != 0)
		{
			if (piErrRec->GetInteger(1) == idbgDbQueryUnknownColumn)
			{
				piErrRec->Release();
				piErrRec = m_riEngine.OpenView(sqlShortRemoveFileCost, ivcFetch, *&m_pCostView);
			}
			if (piErrRec)
				return piErrRec;
		}
	}
	else
		m_pCostView->Close();


#ifdef DEBUG
	const ICHAR* szComponent = riComponentString.GetString();
	const ICHAR* szDirectory = riDirectoryString.GetString();
#endif
	PMsiRecord pExecRecord(&pServices->CreateRecord(2));
	pExecRecord->SetMsiString(1, riComponentString);
	pExecRecord->SetMsiString(2,riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRecord)) != 0)
		return piErrRec;

	PMsiPath pDestPath(0);
	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(riDirectoryString,*&pDestPath);
	if (piErrRec)
	{
		if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
			return piErrRec;
	}

	Assert(pDestPath);
	if (icrlCompileMode == icrlCompileDynamic)
	{
		piErrRec = RemoveComponentFromRemoveFilePathTable(riComponentString);
		if (piErrRec)
			return piErrRec;
	}

	PMsiRecord pFileRec(0);
	while (pFileRec = m_pCostView->Fetch())
	{
		Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == fFalse && pDestPath->SupportsLFN()) ? fTrue : fFalse;
		MsiString strWildcardName;
		MsiString strWildcardNamePair = pFileRec->GetMsiString(irfcFileName);
		piErrRec = ExtractUnvalidatedFileName(strWildcardNamePair,fLFN, *&strWildcardName);
		if (piErrRec)
			return piErrRec;

		MsiString strFullFilePath(pDestPath->GetPath());
		strFullFilePath += strWildcardName;
		WIN32_FIND_DATA fdFileData;
		Bool fNextFile = fFalse;
		HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
		if (hFindFile == INVALID_HANDLE_VALUE)
			continue;

		int iMode = pFileRec->GetInteger(irfcInstallMode);
		if (iMode == iMsiNullInteger)
			iMode = msidbRemoveFileInstallModeOnInstall;
		do
		{
			// Make sure we haven't located a directory
			if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				unsigned int uiFileSize,uiClusteredSize;

				if (icrlCompileMode != icrlCompileInit)
				{
					piErrRec = pDestPath->FileSize(fdFileData.cFileName,uiFileSize);
					if (piErrRec)
						return piErrRec;
					piErrRec = pDestPath->ClusteredFileSize(uiFileSize,uiClusteredSize);
					if (piErrRec)
						return piErrRec;

					if (iMode & msidbRemoveFileInstallModeOnInstall)
					{
						iNoRbLocalCost -= uiClusteredSize;
						iNoRbSourceCost -= uiClusteredSize;
						iNoRbARPLocalCost -= uiClusteredSize;
					}
					if (iMode & msidbRemoveFileInstallModeOnRemove)
					{
						iNoRbRemoveCost -= uiClusteredSize;
					}

					Bool fInUse;
					piErrRec = pDestPath->FileInUse(fdFileData.cFileName,fInUse);
					if(piErrRec)
						return piErrRec;
					if(fAddFileInUse && fInUse)
					{
						piErrRec = PlaceFileOnInUseList(m_riEngine, *MsiString(fdFileData.cFileName),
																  *MsiString(pDestPath->GetPath()));
						if(piErrRec)
							return piErrRec;
					}

				}

				if (icrlCompileMode != icrlCompileDisable)
				{	// Add files to be removed to list for reference by CMsiFileCost
					MsiString strFullPath;
					piErrRec = pDestPath->GetFullFilePath(fdFileData.cFileName,*&strFullPath);
					if (piErrRec)
						return piErrRec;
	
					piErrRec = AddToRemoveFilePathTable(*strFullPath, riComponentString, iMode);
					if (piErrRec)
						return piErrRec;
				}

			}
			fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
			if (!fNextFile)
				AssertNonZero(FindClose(hFindFile));
		}while (fNextFile);
	}
	return 0;
}



IMsiRecord* CMsiRemoveFileCost::AddToRemoveFilePathTable(const IMsiString& riPathString, const IMsiString& riComponentString, int iRemoveMode)
{
	if (m_piRemoveFilePathTable == 0)
	{
		PMsiDatabase pDatabase(m_riEngine.GetDatabase());
		const int iInitialRows = 5;
		IMsiRecord* piErrRec = pDatabase->CreateTable(*MsiString(*sztblRemoveFilePath),iInitialRows,
			m_piRemoveFilePathTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colRemoveFilePath = m_piRemoveFilePathTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblRemoveFilePath_colPath)));
		AssertNonZero(m_colRemoveFilePathComponent = m_piRemoveFilePathTable->CreateColumn(icdString,
			*MsiString(*sztblRemoveFilePath_colComponent)));

		AssertNonZero(m_colRemoveFilePathMode = m_piRemoveFilePathTable->CreateColumn(icdLong,
			*MsiString(*sztblRemoveFilePath_colRemoveMode)));

		m_piRemoveFilePathCursor = m_piRemoveFilePathTable->CreateCursor(fFalse);
		Assert(m_piRemoveFilePathCursor);
	}

	MsiString strUpperFullPath;
	riPathString.UpperCase(*&strUpperFullPath);
	m_piRemoveFilePathCursor->SetFilter(0);
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePath,*strUpperFullPath);
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePathComponent,riComponentString);
	m_piRemoveFilePathCursor->PutInteger(m_colRemoveFilePathMode, iRemoveMode);
	AssertNonZero(m_piRemoveFilePathCursor->Assign());
	return 0;
}


IMsiRecord* CMsiRemoveFileCost::RemoveComponentFromRemoveFilePathTable(const IMsiString& riComponentString)
{
	if (!m_piRemoveFilePathTable)
		return 0;

	Assert(m_piRemoveFilePathCursor);
	m_piRemoveFilePathCursor->Reset();
	m_piRemoveFilePathCursor->SetFilter(iColumnBit(m_colRemoveFilePathComponent));
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePathComponent,riComponentString);
	while (m_piRemoveFilePathCursor->Next())
	{
		m_piRemoveFilePathCursor->Delete();
	}
	return 0;
}


iesEnum RemoveForeignFoldersCore(IMsiEngine& riEngine, IMsiTable& riRemoveFileTable, IMsiPath* piFolderToRemove)
// This function will spit out ixoFolderRemove opcodes for files in the RemoveFile table that have a non-null
// _Path field, which should be those that are to be removed. This function should be called with piFolderToRemove
// set to 0. It will then recursively call itself, ensuring that it spits out
// the op for a child folder before it spits out the op for the child's parent.
{
	static int iPathColumn = 0;
	static int iFileNameColumn = 0;
	if (iPathColumn == 0)
	{
		PMsiDatabase pDatabase = riEngine.GetDatabase();
		iPathColumn     = riRemoveFileTable.GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFile_colPath));
		iFileNameColumn = riRemoveFileTable.GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFile_colFileName));
		Assert(iPathColumn);
		Assert(iFileNameColumn);
	}

	PMsiCursor pCursor = riRemoveFileTable.CreateCursor(fFalse);
	pCursor->SetFilter(iColumnBit(iFileNameColumn));
	pCursor->PutNull(iFileNameColumn);


	// Iterate through the RemoveFiles table. If this is the top-level call then we call ourself again 
	// with every folder we encounter. If this is not the top-level call then we only call ourself
	// again if the folder we encounter is a child of the folder to remove. After we've removed all
	// the children we remove the folder.
	while (pCursor->Next())
	{
		PMsiPath pFetchedPath = (IMsiPath*)pCursor->GetMsiData(iPathColumn);
		if (!pFetchedPath)
			continue;

		Bool fCallRemoveForeignFoldersCore = fFalse;

		if (piFolderToRemove == 0) // top level call
			fCallRemoveForeignFoldersCore = fTrue;
		else
		{
			PMsiRecord pErrRec(0);
			ipcEnum ipc;
			if ((pErrRec = piFolderToRemove->Compare(*pFetchedPath, ipc)) != 0)
				return riEngine.FatalError(*pErrRec);

			if (ipc == ipcChild)
			{
				DEBUGMSG2(TEXT("Removing child folder of %s (child: %s)"), MsiString(piFolderToRemove->GetPath()), MsiString(pFetchedPath->GetPath()));
				fCallRemoveForeignFoldersCore = fTrue;
			}
		}

		if (fCallRemoveForeignFoldersCore)
		{
			AssertNonZero(pCursor->PutNull(iPathColumn));
			AssertNonZero(pCursor->Update()); // remove path so we don't process this folder again

			iesEnum iesRet = RemoveForeignFoldersCore(riEngine, riRemoveFileTable, pFetchedPath); // remove the child first
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}

	if (piFolderToRemove != 0) // the top-level call doesn't remove anything; it just recursively calls this function w/ every folder
	{
		// Remove ourself
		DEBUGMSG1(TEXT("Removing foreign folder: %s"), (const ICHAR*)MsiString(piFolderToRemove->GetPath()));
		PMsiRecord pRecParams = &CreateRecord(IxoFolderRemove::Args);
		pRecParams->ClearData();
		pRecParams->SetMsiString(IxoFolderRemove::Folder,*MsiString(piFolderToRemove->GetPath()));
		pRecParams->SetInteger(IxoFolderRemove::Foreign, 1);
		iesEnum iesRet;
		if ((iesRet = riEngine.ExecuteRecord(ixoFolderRemove, *pRecParams)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

static const ICHAR sqlRemoveForeignFiles[] =
	TEXT("SELECT `FileName`,`DirProperty`,`InstallMode`,`Action` FROM `RemoveFile`,`Component` WHERE `Component`=`Component_` AND `FileName` IS NOT NULL")
	TEXT(" ORDER BY `DirProperty`");

static const ICHAR sqlShortRemoveForeignFiles[] =
	TEXT("SELECT `FileName`,`DirProperty`,NULL,`Action` FROM `RemoveFile`,`Component` WHERE `Component`=`Component_` AND `FileName` IS NOT NULL")
	TEXT(" ORDER BY `DirProperty`");

static const ICHAR sqlRemoveForeignFolders[] =
	TEXT("SELECT `_Path`, `DirProperty`,`InstallMode`,`Action` FROM `RemoveFile`,`Component` WHERE `FileName` IS NULL AND `Component`=`Component_` ");

static const ICHAR sqlShortRemoveForeignFolders[] =
	TEXT("SELECT `_Path`, `DirProperty`,NULL,`Action` FROM `RemoveFile`,`Component` WHERE `FileName` IS NULL AND `Component`=`Component_` ");

iesEnum RemoveForeignFilesOrFolders(IMsiEngine& riEngine, Bool fFolders)
{


	// RemoveForeignFiles query
	enum irffEnum
	{
		irffFileNameOrPath = 1,
		irffDirProperty,
		irffInstallMode,
		irffAction,
		irffNextEnum
	};

	using namespace IxoFileRemove;

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());

	// Open the RemoveFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pRemoveView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pRemoveFileTable(0);

	pErrRec = pDatabase->LoadTable(*MsiString(sztblRemoveFile), 1, *&pRemoveFileTable);

	if (pErrRec == 0)
	{
		if (fFolders)
			AssertNonZero(pRemoveFileTable->CreateColumn(icdTemporary|icdNullable|icdObject, *MsiString(*sztblRemoveFile_colPath))); // to hold our path objects

		pErrRec = riEngine.OpenView(fFolders ? sqlRemoveForeignFolders : sqlRemoveForeignFiles, ivcEnum(ivcFetch|ivcUpdate), *&pRemoveView);
		if (pErrRec)
		{
			if (pErrRec->GetInteger(1) == idbgDbQueryUnknownColumn)
			{
				pErrRec = riEngine.OpenView(fFolders ? sqlShortRemoveForeignFolders : sqlShortRemoveForeignFiles, ivcEnum(ivcFetch|ivcUpdate), *&pRemoveView);
			}
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
		}
	}
	else if (pErrRec->GetInteger(1) != idbgDbTableUndefined)
	{
		return riEngine.FatalError(*pErrRec);
	}
	if (!pRemoveView)
		return iesNoAction;

	pErrRec = pRemoveView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
	PMsiRecord pRecParams = &pServices->CreateRecord(6);

	// If we're removing files we will pass through the RemoveFile table twice - first to compile the
	// total cost, then to execute the remove actions

	// If we're removing folders we'll pass through the RemoveFile table once, setting the
	// _Path column of each folder we're to remove. We'll then call RemoveForeignFoldersCore to
	// do the work of removing the folders.

	unsigned int iFileOrFolderCount = 0;
	Bool fCompile = fTrue;
	MsiString strDestPath;
	MsiString strDestProperty;
	int iTotalPasses = fFolders ? 1 : 2;
	for (;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pFileOrFolderRec(pRemoveView->Fetch());
			if (!pFileOrFolderRec)
				break;

			iisEnum iisAction = (iisEnum) pFileOrFolderRec->GetInteger(irffAction);
			int iMode = pFileOrFolderRec->GetInteger(irffInstallMode);
			if (iMode == iMsiNullInteger)
				iMode = msidbRemoveFileInstallModeOnInstall;
			if (iMode & msidbRemoveFileInstallModeOnInstall && (iisAction == iisLocal || iisAction == iisSource) ||
				(iMode & msidbRemoveFileInstallModeOnRemove && iisAction == iisAbsent))
			{
				if (fFolders)
				{
					PMsiPath pPath(0);
					strDestProperty = pFileOrFolderRec->GetMsiString(irffDirProperty);

					if ((pErrRec = pDirectoryMgr->GetTargetPath(*strDestProperty, *&pPath)) != 0)
					{
						strDestPath = riEngine.GetProperty(*strDestProperty);

						if (strDestPath.TextSize())
						{
							if ((pErrRec = pServices->CreatePath(strDestPath, *&pPath)) != 0)
								return riEngine.FatalError(*pErrRec);
						}
					}
					
					if (pPath != 0)
					{
						iFileOrFolderCount++;
					
						AssertNonZero(pFileOrFolderRec->SetMsiData(irffFileNameOrPath, (const IMsiData*)(IMsiPath*)pPath));

						if ((pErrRec = pRemoveView->Modify(*pFileOrFolderRec, irmUpdate)) != 0)
							return riEngine.FatalError(*pErrRec);
					}
				}
				else // !fFolders
				{
					// Get target path object
					if (!strDestProperty.Compare(iscExact, pFileOrFolderRec->GetString(irffDirProperty)))
					{
						strDestProperty = pFileOrFolderRec->GetMsiString(irffDirProperty);
						strDestPath = riEngine.GetProperty(*strDestProperty);
						if (!fCompile && strDestPath.TextSize())
						{
							pRecParams->ClearData();
							pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*strDestPath);
							if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
								return iesExecute;
						}
					}

					// We'll find and delete every file that matches the wildcard filename
					// (which can include * and ? wildcards).
					if (!strDestPath.TextSize())
						continue;

					PMsiPath pDestPath(0);
 					pErrRec = pServices->CreatePath(strDestPath, *&pDestPath);
					if (pErrRec)
						return riEngine.FatalError(*pErrRec);

					Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == fFalse && pDestPath->SupportsLFN()) ? fTrue : fFalse;
					MsiString strWildcardName;
					MsiString strWildcardNamePair = pFileOrFolderRec->GetMsiString(irffFileNameOrPath);
					pErrRec = ExtractUnvalidatedFileName(strWildcardNamePair,fLFN,*&strWildcardName);
					if (pErrRec)
						return riEngine.FatalError(*pErrRec);

					MsiString strFullFilePath(pDestPath->GetPath());
					strFullFilePath += strWildcardName;
					Bool fNextFile = fFalse;
					WIN32_FIND_DATA fdFileData;
					HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
					if (hFindFile == INVALID_HANDLE_VALUE)
						continue;

					do
					{
						// Make sure we haven't located a directory
						if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
						{
							if (fCompile)
							{
								iFileOrFolderCount++;
							}
							else
							{
								pRecParams->ClearData();
								pRecParams->SetString(FileName,fdFileData.cFileName);
								if ((iesExecute = riEngine.ExecuteRecord(ixoFileRemove, *pRecParams)) != iesSuccess)
									return iesExecute;
							}
						}
						fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
						if (!fNextFile)
							AssertNonZero(FindClose(hFindFile));
					}while (fNextFile);
				}
			}
		} 
		
		if (iFileOrFolderCount == 0)
		{
			// we have no files/folders ... abort
			iTotalPasses = 0;
			break;
		}

		if (fFolders || fCompile)
		{
			pRecParams->ClearData();
			pRecParams->SetInteger(IxoProgressTotal::Total, iFileOrFolderCount);
			pRecParams->SetInteger(IxoProgressTotal::Type, 1);
			pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, ibeRemoveFiles);
			if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
				return iesExecute;
		}

		if (fFolders)
		{
			DEBUGMSG1(TEXT("Counted %d foreign folders to be removed."), (const ICHAR*)(INT_PTR)iFileOrFolderCount);
			return RemoveForeignFoldersCore(riEngine, *pRemoveFileTable, 0);
		}
		else if (fCompile)
		{
			// Re-execute the query for the execution phase
			strDestProperty = TEXT("");
			fCompile = fFalse;
			pRemoveView->Close();
			pErrRec = pRemoveView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
		}// Next pass
	}

	return iesSuccess;
}


iesEnum RemoveFiles(IMsiEngine& riEngine)
{
	// If none of the install bits involving files are set,
	// this action doesn't need to do anything.
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	iesEnum iesForeignResult = RemoveForeignFilesOrFolders(riEngine, /*fFolders = */ fFalse);
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	iesEnum iesExecute = iesSuccess;
	PMsiRecord pErrRec(0);
	PMsiView pRemoveView(0);
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	
	// Determine the total count of all files to delete, and
	// set up the progress bar accordingly.
	unsigned int uiFileCount = 0;
	CMsiFileRemove objFile(riEngine);
	
	pErrRec = objFile.TotalFilesToDelete(uiFileCount);
	if (pErrRec)
	{
		// If file table is missing, not an error - just no
		// installed files to remove
		if (pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pErrRec);
	}

	if (iesForeignResult != iesSuccess && iesForeignResult != iesNoAction) // !! this wasn't the previous behavior; previously we'd ignore the foreign result if there were implicit removals to be done
		return iesForeignResult; 

	if (uiFileCount != 0)
	{
		PMsiRecord pRecParams = &pServices->CreateRecord(6);
		pRecParams->ClearData();
		pRecParams->SetInteger(IxoProgressTotal::Total, uiFileCount);
		pRecParams->SetInteger(IxoProgressTotal::Type, 1); // 1: use ActionData as progress
		pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, ibeRemoveFiles);
		if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
			return iesExecute;

		MsiString strDestProperty;
		PMsiPath pDestPath(0);

		// Remove installed files
		using namespace IxoFileRemove;
		for(;;)
		{
			PMsiRecord pDeleteRec(0);
			pErrRec = objFile.FetchFile(*&pDeleteRec);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
				
			if (!pDeleteRec)
				break;


			// cache current destination for performance
			if (!strDestProperty.Compare(iscExact, pDeleteRec->GetString(CMsiFileRemove::ifqrDirectory)))
			{
				strDestProperty = pDeleteRec->GetMsiString(CMsiFileRemove::ifqrDirectory);
				pErrRec = pDirectoryMgr->GetTargetPath(*strDestProperty,*&pDestPath);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);
				if (pDestPath == 0)
				{
					pErrRec = PostError(Imsg(idbgNoProperty),*strDestProperty);
					return riEngine.FatalError(*pErrRec);
				}
				MsiString strDestPath = pDestPath->GetPath();
				pRecParams->ClearData();
				pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*strDestPath);
				if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
					return iesExecute;
			}

			MsiString strFileName;
			if((pErrRec = objFile.GetExtractedTargetFileName(*pDestPath,*&strFileName)) != 0)
				return riEngine.FatalError(*pErrRec);
			AssertNonZero(pDeleteRec->SetMsiString(CMsiFileRemove::ifqrFileName,*strFileName));
			
			pRecParams->ClearData();
			pRecParams->SetString(FileName,strFileName);
			pRecParams->SetMsiString(ComponentId,*MsiString(pDeleteRec->GetMsiString(CMsiFileRemove::ifqrComponentId)));
			if ((iesExecute = riEngine.ExecuteRecord(ixoFileRemove, *pRecParams)) != iesSuccess)
				return iesExecute;
		}
	}

	if (iesExecute != iesSuccess && iesExecute != iesNoAction)
		return iesExecute; 

	return RemoveForeignFilesOrFolders(riEngine, /*fFolders = */ fTrue);
}



/*---------------------------------------------------------------------------
	MoveFiles costing/action
---------------------------------------------------------------------------*/
class CMsiMoveFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiMoveFileCost(IMsiEngine& riEngine);
protected:
	~CMsiMoveFileCost();
private:
	enum imfEnum
	{
		imfSourceName = 1,
		imfDestName,
		imfSourceProperty,
		imfDestProperty,
		imfOptions,
		imfNextEnum
	};
};
CMsiMoveFileCost::CMsiMoveFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiMoveFileCost::~CMsiMoveFileCost(){}

static const ICHAR sqlInitMoveFiles[] =
	TEXT("SELECT `Component_`,`SourceFolder`,`DestFolder` FROM `MoveFile`");


IMsiRecord* CMsiMoveFileCost::Initialize()
//----------------------------------------
{
	enum imfInitEnum
	{
		imfInitComponent = 1,
		imfInitSourceFolder,
		imfInitDestFolder,
		imfInitNextEnum
	};
	PMsiView pMoveView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitMoveFiles, ivcFetch, *&pMoveView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pMoveView->Execute(0)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pMoveRec(pMoveView->Fetch());
		if (!pMoveRec)
			break;

		MsiString strComponent(pMoveRec->GetMsiString(imfInitComponent));
		MsiString strSourceFolder(pMoveRec->GetMsiString(imfInitSourceFolder));
		MsiString strDestFolder(pMoveRec->GetMsiString(imfInitDestFolder));
		PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strSourceFolder);
		if (piErrRec)
			return piErrRec;
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strDestFolder);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}


static const ICHAR sqlMoveFileCost[] =
	TEXT("SELECT `SourceName`,`DestName`,`SourceFolder`,`DestFolder`,`Options` FROM `MoveFile` WHERE `Component_`=?");

IMsiRecord* CMsiMoveFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	enum imfcEnum
	{
		imfcSourceName = 1,
		imfcDestName,
		imfcSourceFolder,
		imfcDestFolder,
		imfcOptions,
		imfcNextEnum
	};
	
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	

	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlMoveFileCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRecord(&pServices->CreateRecord(1));
	pExecRecord->SetMsiString(1, riComponentString);
	if ((piErrRec = m_pCostView->Execute(pExecRecord)) != 0)
		return piErrRec;

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);

	for(;;)
	{
		PMsiRecord pFileRec(m_pCostView->Fetch());
		if (!pFileRec)
			break;

		Bool fCostSource = fFalse;
		Bool fCostDest = fFalse;
		MsiString strSourceFolder(pFileRec->GetMsiString(imfcSourceFolder));
		if (riDirectoryString.Compare(iscExact,strSourceFolder))
			fCostSource = fTrue;

		MsiString strDestFolder(pFileRec->GetMsiString(imfcDestFolder));
		if (riDirectoryString.Compare(iscExact,strDestFolder))
			fCostDest = fTrue;

		if (fCostSource == fFalse && fCostDest == fFalse)
			continue;

		// Get source and target path objects - if either are undefined, there's
		// no work to do, so go on to the next record.
		Bool fSuppressLFN = m_riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
		PMsiPath pSourcePath(0);
		MsiString strSourcePath(m_riEngine.GetProperty(*strSourceFolder));
		if (strSourcePath.TextSize() == 0)
			continue;

		piErrRec = pServices->CreatePath(strSourcePath,*&pSourcePath);
		if (piErrRec)
			return piErrRec;

		PMsiPath pDestPath(0);
		piErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
		if (piErrRec)
		{
			if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
			{
				piErrRec->Release();
				continue;
			}
			else
				return piErrRec;
		}

		// Get source filename
		MsiString strSourceName(pFileRec->GetMsiString(imfcSourceName));
		if (strSourceName.TextSize() == 0)
		{
			strSourceName = pSourcePath->GetEndSubPath();
			pSourcePath->ChopPiece();
		}

		// We'll find and cost every file that matches the source name
		// (which can include * and ? wildcards).
		Bool fNextFile = fFalse;
		Bool fFindFirst = fTrue;
		MsiString strFullFilePath(pSourcePath->GetPath());
		strFullFilePath += strSourceName;
		WIN32_FIND_DATA fdFileData;
		HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
		if (hFindFile == INVALID_HANDLE_VALUE)
			continue;

		do
		{
			// Make sure we haven't located a directory
			if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				strSourceName = fdFileData.cFileName;
				MsiString strDestName(pFileRec->GetMsiString(imfcDestName));
				if (!fFindFirst || strDestName.TextSize() == 0)
					strDestName = strSourceName;
				else
				{
					MsiString strDestNamePair = strDestName;
					Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
					piErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName);
					if (piErrRec)
						return piErrRec;
				}

				MsiString strVersion;
				MsiString strLanguage;
				piErrRec = pSourcePath->GetFileVersionString(strSourceName, *&strVersion);
				if (piErrRec)
				{
					if (piErrRec->GetInteger(1) == imsgSharingViolation)
					{
						// Couldn't get the version of the source file.  We'll have to 
						// assume the file is unversioned.
						piErrRec->Release();
						piErrRec = 0;
					}
					else
						return piErrRec;
				}
				else
				{
					piErrRec = pSourcePath->GetLangIDStringFromFile(strSourceName,*&strLanguage);
					if (piErrRec)
						return piErrRec;
				}

				int fInstallModeFlags = GetInstallModeFlags(m_riEngine,0);
				unsigned int uiExistingClusteredSize;
				Bool fInUse;
				ifsEnum ifsState;
				Bool fShouldInstall = fFalse;
				if ((piErrRec = pDestPath->GetFileInstallState(*strDestName,*strVersion,*strLanguage,
																			  /* pHash=*/ 0, ifsState,fShouldInstall,
																			  &uiExistingClusteredSize,&fInUse,fInstallModeFlags,
																			  NULL)) != 0)
					return piErrRec;

				int iMoveOptions = pFileRec->GetInteger(imfOptions);
				if (fCostDest && fShouldInstall)
				{
					Assert(fdFileData.nFileSizeHigh == 0);
					unsigned int uiNewClusteredSize;
					if ((piErrRec = pDestPath->ClusteredFileSize(fdFileData.nFileSizeLow, uiNewClusteredSize)) != 0)
						return piErrRec;
					iLocalCost += uiNewClusteredSize;
					iSourceCost += uiNewClusteredSize;
					iARPLocalCost += uiNewClusteredSize;
					iNoRbLocalCost += uiNewClusteredSize;
					iNoRbSourceCost += uiNewClusteredSize;
					iNoRbARPLocalCost += uiNewClusteredSize;
					if (!fInUse)
					{
						iNoRbLocalCost -= uiExistingClusteredSize;
						iNoRbSourceCost -= uiExistingClusteredSize;
						iNoRbARPLocalCost -= uiExistingClusteredSize;
					}
				
					if(iMoveOptions & msidbMoveFileOptionsMove)
					{
						Assert(fdFileData.nFileSizeHigh == 0);
						unsigned int uiSourceClusteredSize;
						if ((piErrRec = pSourcePath->ClusteredFileSize(fdFileData.nFileSizeLow, uiSourceClusteredSize)) != 0)
							return piErrRec;
						iLocalCost -= uiSourceClusteredSize;
						iNoRbLocalCost -= uiSourceClusteredSize;
						iSourceCost -= uiSourceClusteredSize;
						iNoRbSourceCost -= uiSourceClusteredSize;
						iARPLocalCost -= uiSourceClusteredSize;
						iNoRbARPLocalCost -= uiSourceClusteredSize;
					}

					// file in use
					if(fAddFileInUse && fInUse)
					{
						piErrRec = PlaceFileOnInUseList(m_riEngine, *strDestName,
																  *MsiString(pDestPath->GetPath()));
						if(piErrRec)
							return piErrRec;
					}
				}
			}
			fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
			if (!fNextFile)
				AssertNonZero(FindClose(hFindFile));
			fFindFirst = fFalse;
		}while (fNextFile);
	} 

	return 0;
}



const ICHAR sqlMoveFiles[] =
TEXT("SELECT `SourceName`,`DestName`,`SourceFolder`,`DestFolder`,`Options`,`Action` FROM `MoveFile`,`Component` WHERE `Component`=`Component_`");

enum imfEnum
{
	imfSourceName = 1,
	imfDestName,
	imfSourceFolder,
	imfDestFolder,
	imfOptions,
	imfAction,
	imfNextEnum
};

iesEnum MoveFiles(IMsiEngine& riEngine)
{
	
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());

	// Open the MoveFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pMoveView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	if (pDatabase->FindTable(*MsiString(sztblMoveFile)) != itsUnknown)
	{
		pErrRec = riEngine.OpenView(sqlMoveFiles, ivcFetch, *&pMoveView);
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);
	}
	if (!pMoveView)
		return iesSuccess;

	pErrRec = pMoveView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	// We found the MoveFile table. Prepare for the move!
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
	PMsiRecord pRecParams = &pServices->CreateRecord(IxoFileCopy::Args);

	// We will pass through the MoveFile table twice - first to compile the
	// total cost, then to execute the move actions
	unsigned int cbTotalCost = 0;
	unsigned int cbPerTick = 0;
	Bool fCompile = fTrue;
	for (int iTotalPasses = 2;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pFileRec(pMoveView->Fetch());
			if (!pFileRec)
				break;

			iisEnum iisAction = (iisEnum) pFileRec->GetInteger(imfAction);
			if (iisAction != iisLocal && iisAction != iisSource)
				continue;

			// Get source and target path objects - if either are undefined,
			// do nothing, just go on to the next record.
			PMsiPath pSourcePath(0);
			MsiString strSourceFolder(pFileRec->GetMsiString(imfSourceFolder));
			MsiString strSourcePath(riEngine.GetProperty(*strSourceFolder));
			if (strSourcePath.TextSize() == 0)
				continue;

			pErrRec = pServices->CreatePath(strSourcePath,*&pSourcePath);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);

			PMsiPath pDestPath(0);
			MsiString strDestFolder(pFileRec->GetMsiString(imfDestFolder));
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (pErrRec)
			{
				// If destination dir property was never defined, just go on.
				if (pErrRec->GetInteger(1) == idbgDirPropertyUndefined)
				{
					pErrRec = 0;
					continue;
				}
				else
				{
					return riEngine.FatalError(*pErrRec);
				}
			}

			// Source source filename
			MsiString strSourceName(pFileRec->GetString(imfSourceName));
			if (strSourceName.TextSize() == 0)
			{
				strSourceName = pSourcePath->GetEndSubPath();
				pSourcePath->ChopPiece();
			}

			Bool fMoveAcrossVolumes = (PMsiVolume(&pSourcePath->GetVolume()) == 
				                       PMsiVolume(&pDestPath->GetVolume())) ? fFalse : fTrue;

			// We'll find and move/copy every file that matches the source name
			// (which can include * and ? wildcards).
			Bool fNextFile = fFalse;
			Bool fFindFirst = fTrue;
			MsiString strFullFilePath(pSourcePath->GetPath());
			strFullFilePath += strSourceName;
			WIN32_FIND_DATA fdFileData;
			HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
			if (hFindFile == INVALID_HANDLE_VALUE)
				continue;

			do
			{
				// Make sure we haven't located a directory
				if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
				{
					Assert(fdFileData.nFileSizeHigh == 0);
					unsigned int uiFileSize = fdFileData.nFileSizeLow;
					if (fCompile)
					{
						cbTotalCost += uiFileSize;
					}
					else
					{
						int iMoveOptions = pFileRec->GetInteger(imfOptions);

						// Set up the source name
						strSourceName = fdFileData.cFileName;

						// Set up the destination name
						MsiString strDestName(pFileRec->GetString(imfDestName));
						if (!fFindFirst || strDestName.TextSize() == 0)
							strDestName = strSourceName;
						else
						{
							MsiString strDestNamePair = strDestName;
							Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
							pErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName);
							if (pErrRec)
								return riEngine.FatalError(*pErrRec);
						}

						// Set up the ixoFileCopy source folder
						pRecParams->ClearData();
						pRecParams->SetMsiString(IxoSetSourceFolder::Folder,*MsiString(pSourcePath->GetPath()));
						if ((iesExecute = riEngine.ExecuteRecord(ixoSetSourceFolder, *pRecParams)) != iesSuccess)
							return iesExecute;

						pRecParams->ClearData();
						pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*MsiString(pDestPath->GetPath()));
						if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
							return iesExecute;

						// Set up the ixoFileCopy record
						using namespace IxoFileCopy;
						int iAttributes = fdFileData.dwFileAttributes;

						if(iAttributes == FILE_ATTRIBUTE_NORMAL)
							// set to 0, this value is interpreted as something else by CMsiFileCopy::CopyTo
							iAttributes = 0;
						
						MsiString strVersion;
						MsiString strLanguage;
						pErrRec = pSourcePath->GetFileVersionString(strSourceName, *&strVersion);
						if (pErrRec)
						{
							// If the source file is in-use, we'll have to assume it's unversioned
							// and move on (if it's still in-use at file copy time, we'll put up an
							// error/retry message then).
							if (pErrRec->GetInteger(1) != imsgSharingViolation)
								return riEngine.FatalError(*pErrRec);
						}
						else
						{
							pErrRec = pSourcePath->GetLangIDStringFromFile(strSourceName, *&strLanguage);
							if (pErrRec)
								return riEngine.FatalError(*pErrRec);
						}

						pRecParams->ClearData();
						pRecParams->SetString(SourceName,strSourceName);
						pRecParams->SetString(DestName,strDestName);
						pRecParams->SetInteger(Attributes,iAttributes &~ msidbFileAttributesPatchAdded); // remove PatchAdded bit for MoveFiles
						pRecParams->SetInteger(FileSize,uiFileSize);
						pRecParams->SetString(Version,strVersion);
						pRecParams->SetString(Language,strLanguage);
						pRecParams->SetInteger(InstallMode, icmOverwriteOlderVersions | ((iMoveOptions & msidbMoveFileOptionsMove) ? icmRemoveSource : 0));
						pRecParams->SetInteger(PerTick,cbPerTick); 
						pRecParams->SetInteger(IsCompressed, 0); // always uncompressed
						pRecParams->SetInteger(VerifyMedia, fFalse);

						if ((iesExecute = riEngine.ExecuteRecord(ixoFileCopy, *pRecParams)) != iesSuccess)
							return iesExecute;
					}
				}
				fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
				if (!fNextFile)
					AssertNonZero(FindClose(hFindFile));
				fFindFirst = fFalse;
			}while (fNextFile);
		} 
		// Re-execute the query for the execution phase
		if (fCompile)
		{
			fCompile = fFalse;
			pMoveView->Close();
			pErrRec = pMoveView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if(cbTotalCost)
			{
				cbPerTick = iBytesPerTick;
				pRecParams->ClearData();
				pRecParams->SetInteger(IxoProgressTotal::Total, cbTotalCost);
				pRecParams->SetInteger(IxoProgressTotal::Type, 0); // 0: separate progress and action data messages
				pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
				if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
					return iesExecute;
			}
		}// Next pass
	}

	return iesSuccess;
}


/*---------------------------------------------------------------------------
	DuplicateFiles costing/action
---------------------------------------------------------------------------*/
class CMsiDuplicateFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiDuplicateFileCost(IMsiEngine& riEngine);
protected:
	~CMsiDuplicateFileCost();
private:
};
CMsiDuplicateFileCost::CMsiDuplicateFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiDuplicateFileCost::~CMsiDuplicateFileCost(){}

static const ICHAR sqlInitDupFiles[] =
	TEXT("SELECT `DuplicateFile`.`Component_`,`File`.`Component_`,`DestFolder` FROM `DuplicateFile`,`File` WHERE `File_`=`File`");

static const ICHAR sqlInitDupNullDest[] =
	TEXT("SELECT `Directory_` FROM `Component` WHERE `Component`=?");

IMsiRecord* CMsiDuplicateFileCost::Initialize()
//-------------------------------------------
{

	enum idfInitEnum
	{
		idfInitComponent = 1,
		idfInitFileComponent,
		idfInitDestFolder,
		idfInitNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitDupFiles, ivcFetch, *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiView pCompView(0);
	piErrRec = m_riEngine.OpenView(sqlInitDupNullDest, ivcFetch, *&pCompView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	PMsiRecord pCompRec(0);

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pRec(pView->Fetch());
		if (!pRec)
			break;
		
		// close component view so we can re-execute to find directory of this duplicate file's component
		pCompView->Close();
		if ((piErrRec = pCompView->Execute(pRec)) != 0)
			return piErrRec;
		pCompRec = pCompView->Fetch();
		if (!pCompRec)
			break;

		MsiString strComponent(pRec->GetMsiString(idfInitComponent));
		MsiString strFileComponent(pRec->GetMsiString(idfInitFileComponent));
		MsiString strDestFolder(pRec->GetMsiString(idfInitDestFolder));
		// NULL destFolder is allowed -- in this case goes as dir of component
		//  specified in DuplicateFile table Component column
		if (strDestFolder.TextSize() == 0)
		{
			strDestFolder = pCompRec->GetMsiString(1);
		}
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strDestFolder);
		if (piErrRec)
			return piErrRec;

		if (strComponent.Compare(iscExact,strFileComponent) == 0)
		{
			piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strFileComponent,*strComponent);
			if (piErrRec)
				return piErrRec;
		}

	}
	return 0;
}

static const ICHAR sqlCostDupFiles[] =
	TEXT("SELECT `File_`,`DestName`,`DestFolder`,`Directory_`,`Action`,`Installed` FROM `DuplicateFile`,`Component` WHERE `Component`=`Component_` ")
	TEXT("AND `Component_`=?");

IMsiRecord* CMsiDuplicateFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//-----------------------------------------------
{
	enum idfEnum
	{
		idfFileKey = 1,
		idfDestName,
		idfDestFolder,
		idfComponentDestFolder,
		idfAction,
		idfInstalled,
		idfNextEnum
	};

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	
	// DuplicateFile cost adjuster will never get registered
	// and called unless the DuplicateFile table is present.
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlCostDupFiles, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(2));
	pExecRec->SetMsiString(1, riComponentString);
	pExecRec->SetMsiString(2, riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pDupRec(m_pCostView->Fetch());
		if (!pDupRec)
			break;

		// Our source file is a File Table entry
		MsiString strFileKey(pDupRec->GetMsiString(idfFileKey));
		CMsiFile objSourceFile(m_riEngine);
		piErrRec = objSourceFile.FetchFile(*strFileKey);
		if (piErrRec)
			return piErrRec;

		// If our source file is not installed, and isn't going to
		// be installed, then we can't duplicate it.
		PMsiRecord pSourceRec(objSourceFile.GetFileRecord());
		if (!pSourceRec)
			return PostError(Imsg(idbgFileTableEmpty));

		iisEnum iisSourceAction = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqAction);
		iisEnum iisSourceInstalled = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqInstalled);
		if (iisSourceAction == iisLocal || (iisSourceAction == iMsiNullInteger && iisSourceInstalled == iisLocal))
		{
			// Determine our source path
			PMsiPath pSourcePath(0);
			piErrRec = objSourceFile.GetTargetPath(*&pSourcePath);
			if (piErrRec)
				return piErrRec;
			
			// Determine our destination path
			MsiString strDestFolder(pDupRec->GetMsiString(idfDestFolder));
			if (strDestFolder.TextSize() == 0)
				strDestFolder = pDupRec->GetMsiString(idfComponentDestFolder);
			if (0 == riDirectoryString.Compare(iscExact,strDestFolder))
				continue;
			PMsiPath pDestPath(0);
			piErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (piErrRec)
					return piErrRec;

			// get source file name and put back in pSourceRec
			MsiString strSourceName;
			if((piErrRec = objSourceFile.GetExtractedTargetFileName(*pSourcePath,*&strSourceName)) != 0)
				return piErrRec;
			AssertNonZero(pSourceRec->SetMsiString(CMsiFile::ifqFileName,*strSourceName));

			// If our source file is not going to overwrite the existing file (if any), then the
			// existing file's size becomes the size of our source file.
			ifsEnum ifsState;
			piErrRec = GetFileInstallState(m_riEngine, *pSourceRec, /* piCompanionFileRec=*/ 0,0,0,
				&ifsState, /* fIgnoreCompanionParentAction=*/ false, /* fIncludeHashCheck=*/ false, NULL);
			if (piErrRec)
				return piErrRec;

			// Ok, if our source file isn't already present, AND it isn't going to be installed
			// (according to GetFileInstallState), we can't duplicate it.
			if (ifsState == ifsAbsent && pSourceRec->GetInteger(CMsiFile::ifqState) == fFalse)
				continue;

			unsigned int uiSourceFileSize;
			piErrRec = GetFinalFileSize(m_riEngine, *pSourceRec, uiSourceFileSize);
			if (piErrRec)
				return piErrRec;
			
			// Now we must check the install state of our potentially duplicated file;
			// we can do this by modifying the appropriate fields in pSourceRec and
			// then calling GetFileInstallState again.
			MsiString strDestNamePair = pDupRec->GetString(idfDestName);
			MsiString strDestName;
			if (strDestNamePair.TextSize())
			{
				Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
				if((piErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName)) != 0)
					return piErrRec;
				AssertNonZero(pSourceRec->SetMsiString(CMsiFile::ifqFileName,*strDestName));
			}
			else
				strDestName = strSourceName;

			// check to see if we are a noop -- duplicating same file to same directory
			MsiString strFileDir = pSourceRec->GetString(CMsiFile::ifqDirectory);
			if (strSourceName.Compare(iscExact, strDestName) && strFileDir.Compare(iscExact, strDestFolder))
			{
				// duplicateFile.Filename = sourceFile.Filename
				// duplicateFile.Dest = sourceFile.Directory
				// noop
				continue;
			}

			pSourceRec->SetMsiString(CMsiFile::ifqDirectory,*strDestFolder);

			Bool fInUse;
			unsigned int uiExistingDestClusteredSize;
			piErrRec = GetFileInstallState(m_riEngine, *pSourceRec, /* piCompanionFileRec=*/ 0, 
				                           &uiExistingDestClusteredSize,&fInUse,0,
													/* fIgnoreCompanionParentAction=*/ false,
													/* fIncludeHashCheck=*/ false, NULL);
			if (piErrRec)
				return piErrRec;

			// iisAbsent costs
			iNoRbRemoveCost -= uiExistingDestClusteredSize;

			// iisSource costs
			if (pDupRec->GetInteger(idfInstalled) == iisLocal)
				iNoRbSourceCost -= uiExistingDestClusteredSize;

			// iisLocal costs
			if (pSourceRec->GetInteger(CMsiFile::ifqState) == fTrue)
			{
				unsigned int uiDestClusteredSize;
				if ((piErrRec = pDestPath->ClusteredFileSize(uiSourceFileSize, uiDestClusteredSize)) != 0)
					return piErrRec;
				iLocalCost += uiDestClusteredSize;
				iNoRbLocalCost += uiDestClusteredSize;
				iARPLocalCost += uiDestClusteredSize;
				iNoRbARPLocalCost += uiDestClusteredSize;
				if (!fInUse)
				{
					iNoRbLocalCost -= uiExistingDestClusteredSize;
					iNoRbARPLocalCost -= uiExistingDestClusteredSize;
				}
			}

			// file in use
			if(fAddFileInUse && fInUse && iisSourceAction == iisLocal) //!! check remove?????????
			{
				piErrRec = PlaceFileOnInUseList(m_riEngine, *strDestName,
														  *MsiString(pDestPath->GetPath()));
				if(piErrRec)
					return piErrRec;
			}
		}
	}
	return 0;
}



iesEnum DuplicateFiles(IMsiEngine& riEngine)
{
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	const ICHAR sqlDupFiles[] =
	TEXT("SELECT `File_`,`DestName`,`DestFolder`,`Action`,`Directory_` FROM `DuplicateFile`,`Component` WHERE `Component`=`Component_`");

	enum idfEnum
	{
		idfFileKey = 1,
		idfDestName,
		idfDestFolder,
		idfAction,
		idfComponentDestFolder,
		idfNextEnum
	};

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());

	// Open the DuplicateFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	if (pDatabase->FindTable(*MsiString(*sztblDuplicateFile)) != itsUnknown)
	{
		pErrRec = riEngine.OpenView(sqlDupFiles, ivcFetch, *&pView);
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);
	}
	if (!pView)
		return iesSuccess;

	pErrRec = pView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	PMsiRecord pRecParams = &pServices->CreateRecord(IxoFileCopy::Args);

	// We will pass through the DupFile table twice - first to compile the
	// total cost, then to execute the dup actions
	unsigned int cbTotalCost = 0;
	unsigned int cbPerTick = 0;
	Bool fCompile = fTrue;
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
	bool fCheckCRC = 
		MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CHECKCRCS)).TextSize() ? true : false;
	for (int iTotalPasses = 2;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pDupRec(pView->Fetch());
			if (!pDupRec)
				break;

			iisEnum iisAction = (iisEnum) pDupRec->GetInteger(idfAction);
			if (iisAction != iisLocal)
				continue;

			// Our source file is a File Table entry
			MsiString strFileKey(pDupRec->GetMsiString(idfFileKey));
			CMsiFile objSourceFile(riEngine);
			pErrRec = objSourceFile.FetchFile(*strFileKey);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);

			// If our source file is not installed, and isn't going to
			// be installed, then we can't duplicate it.
			PMsiRecord pSourceRec(objSourceFile.GetFileRecord());
			if (!pSourceRec)
				break;

			iisEnum iisSourceAction = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqAction);
			iisEnum iisSourceInstalled = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqInstalled);
			if (iisSourceAction == iisLocal || (iisSourceAction == iMsiNullInteger && iisSourceInstalled == iisLocal))
			{
				if (fCompile)
				{
					cbTotalCost += pSourceRec->GetInteger(CMsiFile::ifqFileSize);
					continue;
				}
			}
			else
				continue;

			// Our source path will be the destination path that the source
			// file was copied to.
			PMsiPath pSourcePath(0);
			pErrRec = objSourceFile.GetTargetPath(*&pSourcePath);
			if (pErrRec)
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}

			// get the extracted source file name.
			MsiString strSourceName;
			if((pErrRec = objSourceFile.GetExtractedTargetFileName(*pSourcePath,*&strSourceName)) != 0)
				return riEngine.FatalError(*pErrRec);

			// Determine our destination path
			MsiString strDestFolder(pDupRec->GetMsiString(idfDestFolder));
			if (strDestFolder.TextSize() == 0)
				strDestFolder = pDupRec->GetMsiString(idfComponentDestFolder);

			PMsiPath pDestPath(0);
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (pErrRec)
			{
				// If destination dir property was never defined, just go on.
				if (pErrRec->GetInteger(1) == idbgDirPropertyUndefined)
				{
					pErrRec = 0;
					continue;
				}
				else
					return riEngine.FatalError(*pErrRec);
			}

			// Set up the ixoFileCopy source folder
			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetSourceFolder::Folder,*MsiString(pSourcePath->GetPath()));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetSourceFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			// Set up the destination name and folder - if no destination given,
			// we use the source name.
			MsiString strDestName;
			MsiString strDestNamePair = pDupRec->GetString(idfDestName);
			if (strDestNamePair.TextSize() == 0)
				strDestName = strSourceName;
			else
			{
				Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
				if((pErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName)) != 0)
					return riEngine.FatalError(*pErrRec);
			}

			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*MsiString(pDestPath->GetPath()));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			// Set up the ixoFileCopy record
			int iAttributes = pSourceRec->GetInteger(CMsiFile::ifqAttributes);
			using namespace IxoFileCopy;
			pRecParams->ClearData();
			pRecParams->SetString(SourceName,strSourceName);
			pRecParams->SetString(DestName,strDestName);
			pRecParams->SetInteger(Attributes,iAttributes &~ msidbFileAttributesPatchAdded); // remove PatchAdded bit for DuplicateFiles
			pRecParams->SetInteger(FileSize,pSourceRec->GetInteger(CMsiFile::ifqFileSize));
			pRecParams->SetString(Version,MsiString(pSourceRec->GetMsiString(CMsiFile::ifqVersion)));
			pRecParams->SetString(Language,MsiString(pSourceRec->GetMsiString(CMsiFile::ifqLanguage)));
			pRecParams->SetInteger(InstallMode, icmOverwriteOlderVersions);
			pRecParams->SetInteger(PerTick,cbPerTick); 
			pRecParams->SetInteger(IsCompressed, 0); // always uncompressed
			pRecParams->SetInteger(VerifyMedia, fFalse);
			pRecParams->SetInteger(CheckCRC, ShouldCheckCRC(fCheckCRC, iisAction, iAttributes));
			if ((iesExecute = riEngine.ExecuteRecord(ixoFileCopy, *pRecParams)) != iesSuccess)
				return iesExecute;

		} 
		// Re-execute the query for the execution phase
		if (fCompile)
		{
			fCompile = fFalse;
			pView->Close();
			pErrRec = pView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if(cbTotalCost)
			{
				pRecParams->ClearData();
				cbPerTick = iBytesPerTick;
				pRecParams->SetInteger(IxoProgressTotal::Total, cbTotalCost);
				pRecParams->SetInteger(IxoProgressTotal::Type, 0); // 0: separate progress and action data messages
				pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
				if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
					return iesExecute;
			}
		}
	}// Next pass

	return iesSuccess;
}


/*---------------------------------------------------------------------------
	RemoveDuplicateFiles action
---------------------------------------------------------------------------*/
iesEnum RemoveDuplicateFiles(IMsiEngine& riEngine)
{
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	const ICHAR sqlDupFiles[] =
	TEXT("SELECT `File_`,`DestName`,`DestFolder`,`Action`, `Directory_` FROM `DuplicateFile`,`Component` WHERE `Component`=`Component_`");

	enum idfEnum
	{
		idfFileKey = 1,
		idfDestName,
		idfDestFolder,
		idfAction,
		idfComponentDestFolder,
		idfNextEnum
	};

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	// Open the DuplicateFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	if (pDatabase->FindTable(*MsiString(*sztblDuplicateFile)) != itsUnknown)
	{
		pErrRec = riEngine.OpenView(sqlDupFiles, ivcFetch, *&pView);
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);
	}
	if (!pView)
		return iesSuccess;

	pErrRec = pView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	PMsiRecord pRecParams = &pServices->CreateRecord(10);

	// We will pass through the DupFile table twice - first to compile the
	// total number of files to delete, then to delete 'em.
	unsigned int uiTotalCount = 0;
	Bool fCompile = fTrue;
	for (int iTotalPasses = 2;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pDupRec(pView->Fetch());
			if (!pDupRec)
				break;

			iisEnum iisAction = (iisEnum) pDupRec->GetInteger(idfAction);
			if (iisAction != iisAbsent && iisAction != iisFileAbsent && iisAction != iisHKCRFileAbsent && iisAction != iisSource)
				continue;

			if (fCompile)
			{
				uiTotalCount++;
				continue;
			}

			// Determine our destination path, and set the target folder
			MsiString strDestFolder(pDupRec->GetMsiString(idfDestFolder));
			if (strDestFolder.TextSize() == 0)
				strDestFolder = pDupRec->GetMsiString(idfComponentDestFolder);

			PMsiPath pDestPath(0);
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (pErrRec)
			{
				// If destination dir property was never defined, just go on.
				if (pErrRec->GetInteger(1) == idbgDirPropertyUndefined)
				{
					pErrRec = 0;
					continue;
				}
				else
					return riEngine.FatalError(*pErrRec);
			}

			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*MsiString(pDestPath->GetPath()));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			// Set up the destination name - if no destination given,
			// we use the source name - then send off the FileRemove record.
			MsiString strDestNamePair(pDupRec->GetString(idfDestName));
			if (strDestNamePair.TextSize() == 0)
			{
				// use file name from source file record
				MsiString strFileKey(pDupRec->GetMsiString(idfFileKey));
				CMsiFile objSourceFile(riEngine);
				pErrRec = objSourceFile.FetchFile(*strFileKey);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);

				PMsiRecord pSourceRec(objSourceFile.GetFileRecord());
				if (!pSourceRec)
					break;

				strDestNamePair = pSourceRec->GetString(CMsiFile::ifqFileName);
			}
			// extract appropriate name from short|long pair
			Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
			MsiString strDestName;
			if((pErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName)) != 0)
				return riEngine.FatalError(*pErrRec);

			pRecParams->ClearData();
			pRecParams->SetString(IxoFileRemove::FileName,strDestName);
			if ((iesExecute = riEngine.ExecuteRecord(ixoFileRemove, *pRecParams)) != iesSuccess)
				return iesExecute;

		} 
		// Re-execute the query for the execution phase
		if (fCompile)
		{
			fCompile = fFalse;
			pView->Close();
			pErrRec = pView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if(uiTotalCount)
			{
				pRecParams->ClearData();
				pRecParams->SetInteger(IxoProgressTotal::Total, uiTotalCount);
				pRecParams->SetInteger(IxoProgressTotal::Type, 1); // ActionData progress
				pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, ibeRemoveFiles);
				if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
					return iesExecute;
			}
		}
	}// Next pass

	return iesSuccess;
}




/*---------------------------------------------------------------------------
	Cost adjuster for all registry actions
---------------------------------------------------------------------------*/
class CMsiRegistryCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iARPNoRbLocalCost);
public:  // constructor
	CMsiRegistryCost(IMsiEngine& riEngine);
protected:
	~CMsiRegistryCost();
private:
	IMsiRecord* LinkToWindowsFolder(const ICHAR* szTable);
	void AdjustRegistryCost(int& iLocalCost);
	TRI		m_tHasTypeLibCostColumn;
	PMsiView	m_pViewTypeLibCost;
	int         m_colRegistryRoot;
	int         m_colRegistryKey;
	int         m_colRegistryRegistry;
	int         m_colRegistryName;
	int         m_colRegistryValue;
	int         m_colRegistryComponent;
	IMsiTable*  m_piRegistryTable;
	IMsiCursor* m_piRegistryCursor;
	
};

CMsiRegistryCost::CMsiRegistryCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine), m_pViewTypeLibCost(0)
{
	m_tHasTypeLibCostColumn = tUnknown;
	m_piRegistryTable = 0;
	m_piRegistryCursor = 0;
}

CMsiRegistryCost::~CMsiRegistryCost()
{

	if (m_piRegistryTable != 0)
	{
		m_piRegistryTable->Release();
		m_piRegistryTable = 0;
	}

	if (m_piRegistryCursor != 0)
	{
		m_piRegistryCursor->Release();
		m_piRegistryCursor = 0;
	}
}

static const ICHAR szComponent[] = TEXT("Component_");

IMsiRecord* CMsiRegistryCost::LinkToWindowsFolder(const ICHAR* szRegTable)
//----------------------------------------------------
{

	PMsiTable pTable(0);
	PMsiCursor pCursor(0);	
	IMsiRecord* piError = 0;
	int icolComponent;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());
	
	if((piError = pDatabase->LoadTable(*MsiString(szRegTable),0,*&pTable)) != 0)
	{
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}
	pCursor = pTable->CreateCursor(fFalse);
	icolComponent = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szComponent));


	MsiStringId idWindowsFolder = pDatabase->EncodeStringSz(IPROPNAME_WINDOWS_FOLDER);
	AssertSz(idWindowsFolder != 0, "WindowsFolder property not set in database");
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	MsiStringId idLast = 0;
	
	while(pCursor->Next())
	{
		MsiStringId idComponent = pCursor->GetInteger(icolComponent);
		if (idComponent != idLast)
		{
			piError = pSelectionMgr->RegisterComponentDirectoryId(idComponent,idWindowsFolder);
			if (piError)
				return piError;
			idLast = idComponent;
		}
	}
	return 0;
}


const ICHAR szRegistryRegistry[]    = TEXT("Registry");
const ICHAR szRegistryRoot[]        = TEXT("Root");
const ICHAR szRegistryKey[]         = TEXT("Key");
const ICHAR szRegistryValue[]       = TEXT("Value");
const ICHAR szRegistryName[]        = TEXT("Name");

IMsiRecord* CMsiRegistryCost::Initialize()
//-------------------------------------------
{
	IMsiRecord* piErrRec;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());

	if((piErrRec = pDatabase->LoadTable(*MsiString(sztblRegistry),0,*&m_piRegistryTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		else
			return piErrRec;
	}
	else
	{
		m_piRegistryCursor = m_piRegistryTable->CreateCursor(fFalse);
		m_colRegistryRoot = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryRoot));
		m_colRegistryKey = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryKey));
		m_colRegistryName = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryName));
		m_colRegistryValue = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryValue));
		m_colRegistryRegistry = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryRegistry));
		m_colRegistryComponent = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szComponent));		
	}
	
	if ((piErrRec = LinkToWindowsFolder(TEXT("Registry"))) != 0)
		return piErrRec;
	if ((piErrRec = LinkToWindowsFolder(TEXT("Class"))) != 0)
		return piErrRec;
	if ((piErrRec = LinkToWindowsFolder(TEXT("Extension"))) != 0)
		return piErrRec;
	if ((piErrRec = LinkToWindowsFolder(TEXT("TypeLib"))) != 0)
		return piErrRec;
	
	//!! Costing is not available yet for the AppId table
	return 0;
}

const int iRegistrySourceCostFudgeFactor = 100;

static const ICHAR sqlRegCost2[] = TEXT("SELECT `Root`,`Key`,`Name` FROM `Registry` WHERE `Registry`=?");

IMsiRecord* CMsiRegistryCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	// initialise all costs to 0
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;

	if (!IsRegistryActivityEnabled(m_riEngine))
		return 0;

	// the registry cost is attributed to the windows folder
	if (riDirectoryString.Compare(iscExact,IPROPNAME_WINDOWS_FOLDER) == 0)
		return 0;

	IMsiRecord* piErrRec = 0;

	// as a fix for bug 318875, only perform dynamic costing if the component is not installed local
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	IMsiTable* piComponentTable = pSelectionMgr->GetComponentTable();

	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
	if (piComponentTable)
	{
		int colComponentKey, colComponentInstalled;
		colComponentKey = piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colComponent));
		colComponentInstalled = piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colInstalled));

		PMsiCursor pComponentCursor(piComponentTable->CreateCursor(fFalse));
		pComponentCursor->SetFilter(iColumnBit(colComponentKey));
		pComponentCursor->PutString(colComponentKey,riComponentString);
		if (pComponentCursor->Next())
		{
			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(colComponentInstalled);
			if (iisLocal == iisInstalled || iisSource == iisInstalled)
			{
				piComponentTable->Release();
				return 0; // no cost since component is already installed and registry keys/values have already been written
			}
		}
		piComponentTable->Release();
	}

	// the registry table	
	int iCostIndividual = 0;

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	// the execute record
	PMsiServices pServices(m_riEngine.GetServices());


	if (m_piRegistryCursor)
	{
		m_piRegistryCursor->Reset();
		m_piRegistryCursor->SetFilter(iColumnBit(m_colRegistryComponent));
		m_piRegistryCursor->PutString(m_colRegistryComponent, riComponentString);

		while(m_piRegistryCursor->Next())
		{
			iCostIndividual += MsiString(m_piRegistryCursor->GetString(m_colRegistryKey)).TextSize();
			iCostIndividual += MsiString(m_piRegistryCursor->GetString(m_colRegistryName)).TextSize();
			iCostIndividual += MsiString(m_piRegistryCursor->GetString(m_colRegistryValue)).TextSize();
		}

		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
	}


	// the typelib table, cost if TypeLib.Cost column is present
	iCostIndividual = 0;
	enum itcEnum
	{
		itcCost = 1,
		itcNextEnum
	};

	if (m_tHasTypeLibCostColumn == tUnknown)
	{
		PMsiView pView(0);
		static const ICHAR sqlFindCostColumn[] = TEXT("SELECT `_Columns`.`Name` FROM `_Columns` WHERE `Table` = 'TypeLib' AND `_Columns`.`Name` = 'Cost'");
		piErrRec = m_riEngine.OpenView(sqlFindCostColumn, ivcFetch, *&pView);
		if (piErrRec)
			return piErrRec;

		if ((piErrRec = pView->Execute(0)) != 0)
			return piErrRec;

		m_tHasTypeLibCostColumn =  (PMsiRecord(pView->Fetch()) != 0) ? tTrue : tFalse; // If fetch returns, the Cost column is present
	}

	PMsiRecord pExecRec(&pServices->CreateRecord(1));
	pExecRec->SetMsiString(1, riComponentString);

	if(m_tHasTypeLibCostColumn == tTrue) // the Cost column is present
	{
		if (m_pViewTypeLibCost == 0)
		{		
			static const ICHAR sqlTypeLibCost[] = TEXT("SELECT `Cost` FROM `TypeLib` WHERE `Component_`=?");
			piErrRec = m_riEngine.OpenView(sqlTypeLibCost, ivcFetch, *&m_pViewTypeLibCost);
			if (piErrRec)
				return piErrRec;
		}
		
		if ((piErrRec = m_pViewTypeLibCost->Execute(pExecRec)) != 0)
		{
			AssertZero(m_pViewTypeLibCost->Close());
			return piErrRec;
		}

		PMsiRecord pTypeLibRec(0);
		while((pTypeLibRec= m_pViewTypeLibCost->Fetch()) != 0)
		{
			if(!pTypeLibRec->IsNull(itcCost))
				iCostIndividual += pTypeLibRec->GetInteger(itcCost);
		}

		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
		AssertZero(PMsiRecord(m_pViewTypeLibCost->Close()));
	}

	// the component table - for component and client registration
	iCostIndividual = 0;
	enum iccEnum
	{
		iccComponentId=1,
		iccKeyPath,
		iccAction,
		iccDirectory,
		iccAttributes,
		iccNextEnum
	};
	static const ICHAR sqlComponentCost[]    = TEXT(" SELECT `ComponentId`, `KeyPath`, `Action`, `Directory_`, `Attributes`    FROM `Component` WHERE `Component` = ?");

	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlComponentCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}

	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	PMsiRecord pComponentRec(0);

	int iLocalCostIndividual = 0;
	int iSourceCostIndividual = 0;
	while((pComponentRec = m_pCostView->Fetch()) != 0)
	{
		iLocalCostIndividual  += MsiString(pComponentRec->GetMsiString(iccComponentId)).TextSize();
		iSourceCostIndividual += MsiString(pComponentRec->GetMsiString(iccComponentId)).TextSize();

		// file, registry or folder
		MsiString strKeyPathKey = pComponentRec->GetMsiString(iccKeyPath);
		PMsiPath pPath(0);
		MsiString strKeyPath;
		if(strKeyPathKey.TextSize()) // file or registry
		{
			if(pComponentRec->GetInteger(iccAttributes) & icaRegistryKeyPath) // registry key path
			{

				enum ircEnum{
					ircRoot,
					ircKey,
					ircName,
				};
				PMsiView pView1(0);
				piErrRec = m_riEngine.OpenView(sqlRegCost2, ivcFetch, *&pView1);
				PMsiRecord pExecRec1(&pServices->CreateRecord(1));
				pExecRec1->SetMsiString(1, *strKeyPathKey);
				if ((piErrRec = pView1->Execute(pExecRec1)) != 0)
					return piErrRec;
				PMsiRecord pRegistryRec(0);

				if((pRegistryRec = pView1->Fetch()) != 0)
				{
					int iCostIndividual = MsiString(pRegistryRec->GetMsiString(ircRoot)).TextSize();
					iCostIndividual += MsiString(pRegistryRec->GetMsiString(ircKey)).TextSize();
					iCostIndividual += MsiString(pRegistryRec->GetMsiString(ircName)).TextSize();
					iLocalCostIndividual += iCostIndividual;
					iSourceCostIndividual +=  iCostIndividual;
				}
			}
			else if (pComponentRec->GetInteger(iccAttributes) & icaODBCDataSource) // ODBC Data source
			{
				//FUTURE: should cost these?
			}
			else
			{

				CMsiFile objFile(m_riEngine);
				piErrRec = objFile.FetchFile(*strKeyPathKey);
				if (piErrRec)
					return piErrRec;

				// local cost
				// get destination path
				if((piErrRec = objFile.GetTargetPath(*&pPath)) != 0)
					return piErrRec;

				// extract appropriate file name from short|long pair
				MsiString strFileName;
				if((piErrRec = objFile.GetExtractedTargetFileName(*pPath, *&strFileName)) != 0)
					return piErrRec;
				if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strKeyPath)) != 0)
					return piErrRec;
				iLocalCostIndividual += strKeyPath.TextSize();

				// source cost
				iSourceCostIndividual += iRegistrySourceCostFudgeFactor;
			}
		}
		else // folder
		{
			if ((piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(pComponentRec->GetMsiString(iccDirectory)),*&pPath)) != 0)
				return piErrRec;
			iLocalCostIndividual += strKeyPath.TextSize();
			iSourceCostIndividual += iRegistrySourceCostFudgeFactor;
		}

		// add client registering cost, product code size + state
		iLocalCostIndividual  += MsiString(m_riEngine.GetProductKey()).TextSize() + sizeof(INSTALLSTATE);
		iSourceCostIndividual += MsiString(m_riEngine.GetProductKey()).TextSize() + sizeof(INSTALLSTATE);

	}

	iSourceCost += iLocalCostIndividual;
	iNoRbSourceCost += iLocalCostIndividual;
	iLocalCost  += iSourceCostIndividual;
	iNoRbLocalCost += iLocalCostIndividual;
	iARPLocalCost += iSourceCostIndividual;
	iNoRbARPLocalCost += iLocalCostIndividual;

	// the class table
	iCostIndividual = 0;
	enum ioc
	{
		iocClass=1,
		iocProgID,
		iocDescription,
		iocContext,
		iocFeature,
		iocComponentId,
		iocInsertable,
		iocAppId,
		iocTypeMask,
		iocDefInprocHandler,
	};
	// make sure the table exists
	if(pDatabase->GetTableState(sztblClass, itsTableExists))// the Class table is present
	{
		static const ICHAR sqlClassSQL[] = TEXT("SELECT `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`,  null, `AppId_`, `FileTypeMask`, `DefInprocHandler`  FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 1 OR `Feature`.`Action` = 2) AND `Component` = ?");

		PMsiView pView(0);
		if ((piErrRec = m_riEngine.OpenView(sqlClassSQL, ivcFetch, *&pView)) != 0)
			return piErrRec;
		if ((piErrRec = pView->Execute(pExecRec)) != 0)
			return piErrRec;

		PMsiRecord piClassRec(0);
		while((piClassRec = pView->Fetch()) != 0)
		{
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocClass)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocProgID)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocDescription)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocContext)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocFeature)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocComponentId)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocInsertable)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocAppId)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocTypeMask)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocDefInprocHandler)).TextSize();
			iCostIndividual += MsiString(m_riEngine.GetProductKey()).TextSize();
		}
		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
	}

	// the extension - verb - mime table
	iCostIndividual = 0;
	enum iecEnum
	{
		iecExtension=1,
		iecProgId,
		iecShellNew,
		iecShellNewValue,
		iecComponentId,
		iecFeature,
		iecNextEnum
	};
	// make sure the table exists
	if(pDatabase->GetTableState(sztblExtension, itsTableExists))// the Extension table is present
	{
		static const ICHAR sqlExtensionSQL[] = TEXT("SELECT `Extension`, `ProgId_`, null, null, `Feature_`, `ComponentId` FROM `Extension`, `Component`, `Feature`  WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 1 OR `Feature`.`Action` = 2) AND `Component` = ?");
		PMsiView pView(0);
		if ((piErrRec = m_riEngine.OpenView(sqlExtensionSQL, ivcFetch, *&pView)) != 0)
			return piErrRec;
		if ((piErrRec = pView->Execute(pExecRec)) != 0)
			return piErrRec;

		PMsiRecord piExtensionRec(0);
		while((piExtensionRec = pView->Fetch()) != 0)
		{
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecExtension)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecProgId)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecShellNew)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecShellNewValue)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecComponentId)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecFeature)).TextSize();
			iCostIndividual  += MsiString(m_riEngine.GetProductKey()).TextSize();

			PMsiView pView1(0);
			PMsiRecord pExecRec1(&pServices->CreateRecord(1));
			// get the cost from the verb table
			if(pDatabase->FindTable(*MsiString(sztblVerb)) != itsUnknown)// the Verb table is present
			{
				enum ivcEnum
				{
					ivcVerb=1,
					ivcCommand,
					ivcArgument,
					ivcNextEnum
				};

				const ICHAR sqlExtensionExSQL[] =  TEXT("SELECT `Verb`, `Command`, `Argument` FROM `Verb` WHERE `Extension_` = ?");
				if ((piErrRec = m_riEngine.OpenView(sqlExtensionExSQL, ivcFetch, *&pView1)) != 0)
					return piErrRec;
				pExecRec1->SetMsiString(1, *MsiString(piExtensionRec->GetMsiString(iecExtension)));
				if ((piErrRec = pView1->Execute(pExecRec1)) != 0)
					return piErrRec;
				PMsiRecord piExtensionExRec(0);
				while((piExtensionExRec = pView1->Fetch()) != 0)
				{
					iCostIndividual  += MsiString(piExtensionExRec->GetMsiString(ivcVerb)).TextSize();
					iCostIndividual  += MsiString(piExtensionExRec->GetMsiString(ivcCommand)).TextSize();
					iCostIndividual  += MsiString(piExtensionExRec->GetMsiString(ivcArgument)).TextSize();
				}
			}

			// get the cost from the mime table
			if(pDatabase->FindTable(*MsiString(sztblMIME)) != itsUnknown)// the MIME table is present
			{
				enum imcEnum
				{
					imcContentType=1,
					imcExtension=1,
					imcClassId=1,

				};
				const ICHAR sqlExtensionEx2SQL[] =  TEXT("SELECT `ContentType`, `Extension_`, `CLSID` FROM `MIME` WHERE `Extension_` = ?");
				if ((piErrRec = m_riEngine.OpenView(sqlExtensionEx2SQL, ivcFetch, *&pView1)) != 0)
					return piErrRec;
				if ((piErrRec = pView1->Execute(pExecRec1)) != 0)
					return piErrRec;
				PMsiRecord piExtensionEx2Rec(0);
				while((piExtensionEx2Rec = pView1->Fetch()) != 0)
				{
					iCostIndividual  += MsiString(piExtensionEx2Rec->GetMsiString(imcContentType)).TextSize();
					iCostIndividual  += MsiString(piExtensionEx2Rec->GetMsiString(imcExtension)).TextSize();
					iCostIndividual  += MsiString(piExtensionEx2Rec->GetMsiString(imcClassId)).TextSize();
				}
			}
		}
		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
	}

	AdjustRegistryCost(iSourceCost);
	AdjustRegistryCost(iNoRbSourceCost);
	AdjustRegistryCost(iLocalCost);
	AdjustRegistryCost(iNoRbLocalCost);
	AdjustRegistryCost(iRemoveCost);
	AdjustRegistryCost(iNoRbRemoveCost);
	AdjustRegistryCost(iARPLocalCost);
	AdjustRegistryCost(iNoRbARPLocalCost);
	return 0;
}



void CMsiRegistryCost::AdjustRegistryCost(int& iLocalCost)
//------------------------------------------
{
	if(m_riEngine.GetPropertyInt(*MsiString(*IPROPNAME_VERSIONNT)) != iMsiNullInteger)
		iLocalCost *= 2;// the registry is UNICODE on NT

	// GetDynamicCost expects cost values to be returned as multiples of iMsiMinClusterSize
	iLocalCost = (iLocalCost + iMsiMinClusterSize - 1) / iMsiMinClusterSize;
}

/*-------------------------------------------------------------------------------
	SFPCatalogCost cost adjuster (InstallSFPCatalogFile action is in shared.cpp)
---------------------------------------------------------------------------------*/
class CMsiSFPCatalogCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiSFPCatalogCost(IMsiEngine& riEngine);
protected:
	~CMsiSFPCatalogCost();
private:
	IMsiTable*  m_piFeatureComponentsTable; // we hold onto the table to keep in memory and control lifetime of our insert temporaries
	IMsiTable*  m_piComponentTable; // we hold onto the table to keep in memory and control lifetime of our insert temporaries
	int			m_colComponentKey;
	int         m_colComponentDirectory;
	int         m_colComponentAttributes;
	MsiString   m_strComponent; // name of dummy component to which attributing cost

	IMsiRecord* GenerateDummyComponent();
};

CMsiSFPCatalogCost::CMsiSFPCatalogCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine), m_strComponent(0),
										m_piFeatureComponentsTable(0), m_piComponentTable(0), m_colComponentKey(0),
										m_colComponentDirectory(0), m_colComponentAttributes(0)
{
}

CMsiSFPCatalogCost::~CMsiSFPCatalogCost()
{
	if (m_piFeatureComponentsTable)
	{
		m_piFeatureComponentsTable->Release();
		m_piFeatureComponentsTable = 0;
	}
	if (m_piComponentTable)
	{
		m_piComponentTable->Release();
		m_piComponentTable = 0;
	}
}


static const ICHAR szSFPCostComponentName[] = TEXT("__SFPCostComponent");

IMsiRecord* CMsiSFPCatalogCost::GenerateDummyComponent()
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// create a unique name to represent the SFPCatalogCost "dummy" component
	IMsiRecord* piErrRec = 0;
	int iMaxTries = 100;
	int iSuffix = 65;
	const int cchMaxComponentTemp=40;
	int cchT;
	
	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pComponentCursor);

	do
	{
		// Max size is 2 chars for __, cchMaxComponentTemp and 11 chars for max 
		// int and trailing null
		ICHAR rgch[2+cchMaxComponentTemp+11];
		StringCbCopy(rgch, sizeof(rgch), TEXT("__"));
		memcpy(&rgch[2], szSFPCostComponentName, (cchT = min(lstrlen(szSFPCostComponentName), cchMaxComponentTemp)) * sizeof(ICHAR));
		ltostr(&rgch[2 + cchT], iSuffix++);
		m_strComponent = rgch;

		// prepare cursor for insert of dummy component
		// SFPCatalog files are installed to the WindowsFolder (this has been set as the
		// directory of the dummy component).

		pComponentCursor->Reset();
		pComponentCursor->PutString(m_colComponentKey, *m_strComponent);
		pComponentCursor->PutString(m_colComponentDirectory, *(MsiString(*IPROPNAME_WINDOWS_FOLDER)));
		pComponentCursor->PutInteger(m_colComponentAttributes, 0);

		iMaxTries--;

	}while (pComponentCursor->InsertTemporary() == fFalse && iMaxTries > 0);

	if (iMaxTries == 0)
		return PostError(Imsg(idbgBadSubcomponentName), *m_strComponent);

	return 0;
}

static const ICHAR szSFPCostFeatureSQL[] = TEXT("SELECT `FeatureComponents`.`Feature_`,`FeatureComponents`.`Component_` FROM `FeatureComponents`, `File`, `FileSFPCatalog` WHERE `File`.`File`=`FileSFPCatalog`.`File_` AND `FeatureComponents`.`Component_`=`File`.`Component_`");
static const ICHAR szSFPCostFeatureMapSQL[] = TEXT("INSERT INTO `FeatureComponents` (`Feature_`,`Component_`) VALUES (?, ?) TEMPORARY");

IMsiRecord* CMsiSFPCatalogCost::Initialize()
{
	enum ifccEnum
	{
		ifccFeature=1,
		ifccComponent=2
	};

	// load Component table
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());
	IMsiRecord* piErrRec = pDatabase->LoadTable(*MsiString(*sztblComponent),0,m_piComponentTable);
	if (piErrRec)
	{
		// nothing to do if Component table missing
		if (idbgDbTableUndefined == piErrRec->GetInteger(1))
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
	m_colComponentKey = m_piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colComponent));
	m_colComponentDirectory = m_piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colDirectory));
	m_colComponentAttributes = m_piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colAttributes));

	// load FeatureComponents table
	piErrRec = pDatabase->LoadTable(*MsiString(*sztblFeatureComponents),0,m_piFeatureComponentsTable);
	if (piErrRec)
	{
		// nothing to do if FeatureComponents table missing
		if (idbgDbTableUndefined == piErrRec->GetInteger(1))
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
		
	// create the dummy component to store the SFPCatalog cost
	if ((piErrRec = GenerateDummyComponent()) != 0)
		return piErrRec;

	// we're going to assign the "dummy" component to every feature containing
	// a component that contains a file that installs a catalog.  This will then
	// look like a shared component and cost will be attributed to each feature
	// (as are shared components) in the UI; although cost is only attributed
	// once per volume in actuality.
	PMsiView pInsertView(0);
	if (0 != (piErrRec = m_riEngine.OpenView(szSFPCostFeatureMapSQL, ivcFetch, *&pInsertView)))
		return piErrRec;

	PMsiView pFeatureCView(0);
	if (0 != (piErrRec = m_riEngine.OpenView(szSFPCostFeatureSQL, ivcFetch, *&pFeatureCView)))
	{
		// File table is missing, nothing to do.
		if (idbgDbQueryUnknownTable == piErrRec->GetInteger(1))
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
	if (0 != (piErrRec = pFeatureCView->Execute(0)))
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);

	PMsiRecord pFeatureRec(0);
	while ((pFeatureRec = pFeatureCView->Fetch()) != 0)
	{
		// cost link our dummy component to the file's component
		// so that we may recost when the file's component action state changes.
		// this is due to the weirdness of catalog files which "break" our
		// current component rules -- feature linking can't be done because the 
		// component state is set after feature linked components have been recosted
		// ... which won't help us here
		if (0 != (piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*MsiString(pFeatureRec->GetMsiString(ifccComponent)), *m_strComponent)))
			return piErrRec;
		
		// map our dummy component to the file component's feature
		// if the insert fails, fine, the mapping already exists.
		pFeatureRec->SetMsiString(ifccComponent, *m_strComponent);
		piErrRec = pInsertView->Execute(pFeatureRec);
		if (piErrRec)
			piErrRec->Release();
		pInsertView->Close();
	}

	return 0;
}

static const ICHAR szSFPCostSQL[] =
		TEXT("SELECT DISTINCT `SFPCatalog`,`Catalog` FROM `SFPCatalog`,`File`,`FileSFPCatalog`,`Component`")
		TEXT(" WHERE `Component`.`Action`=1 AND `File`.`Component_`=`Component`.`Component`")
		TEXT(" AND `File`.`File`=`FileSFPCatalog`.`File_` AND `SFPCatalog`.`SFPCatalog`=`FileSFPCatalog`.`SFPCatalog_`");

IMsiRecord* CMsiSFPCatalogCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
											   Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
											   int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
{
	enum isfpcEnum
	{
		isfpcSFPCatalog=1,
		isfpcCatalog
	};

	// initialize all costs to zero
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;

	// ignore request if we are not costing our dummy component
	if (0 == riComponentString.Compare(iscExact, m_strComponent))
		return 0;

	// - SFPCatalogs are only installed if file is installed local
	// - The only cost we worry about is the local cost.
	// - SFPCatalogs are never removed (i.e. they are permanent)
	// - SFPCatalogs are never run-from-source
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(szSFPCostSQL, ivcFetch, *&pView);
	if (0 != piErrRec)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
	if (0 != (piErrRec = pView->Execute(0)))
		return piErrRec;

	PMsiRecord pCatalogRec(0);

	// we really don't know how they store catalog files on Millennium
	// ...so, we're going to roundup to the nearest cluster what the size
	// will be on the WindowsFolder volume.
	// create the path to the WindowsFolder (indirectly gets the volume)
	PMsiPath pDestPath(0);
	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(riDirectoryString,*&pDestPath);
	if (piErrRec)
		return piErrRec;

	while ((pCatalogRec = pView->Fetch()) != 0)
	{
		// obtain catalog stream
		PMsiData pCatalogData = pCatalogRec->GetMsiData(isfpcCatalog);
		IMsiStream* piStream;
		unsigned int cbStream = 0;
		if (pCatalogData->QueryInterface(IID_IMsiStream, (void**)&piStream) == NOERROR)
		{
			cbStream = piStream->GetIntegerValue();
			piStream->Release();
		}

		// convert our byte size to the clustered file size
		unsigned int uiClusteredSize=0;
		if ((piErrRec = pDestPath->ClusteredFileSize(cbStream, uiClusteredSize)) != 0)
			return piErrRec;

		iLocalCost += uiClusteredSize;
		iARPLocalCost += uiClusteredSize;
	}

	// we can't easily determine if a catalog already exists (must stream to a file and then try
	// to copy it); in short, it's ugly and slow, so we'll have to live with iNoRbLocalCost being
	// equal to iLocalCost until they provide us some API hook to determine the current catalog
	// file size (and whether it already exists)
	iNoRbLocalCost = iLocalCost;
	iNoRbARPLocalCost = iARPLocalCost;
	
	return 0;
}

/*---------------------------------------------------------------------------
	Shortcuts cost adjuster
---------------------------------------------------------------------------*/
class CMsiShortcutCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiShortcutCost(IMsiEngine& riEngine);
protected:
	~CMsiShortcutCost();
private:
	IMsiRecord* GetTargetFileRecord(const IMsiString& riTargetString, IMsiRecord *& rpiFileRec);
};
CMsiShortcutCost::CMsiShortcutCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiShortcutCost::~CMsiShortcutCost(){}


IMsiRecord* CMsiShortcutCost::GetTargetFileRecord(const IMsiString& riTargetString, IMsiRecord *& rpiFileRec)
/*--------------------------------------------------------------
If the given target string resolves to a file in the file table,
a record containing a CMsiFile info block will be returned as
the function result, with a NULL value in field 0).  If an error
occurs (i.e. a nonexistent file table reference is given), an
error record is returned. Otherwise, the return value will be
NULL.
---------------------------------------------------------------*/
{
	rpiFileRec = 0;
	MsiString strTarget(riTargetString.GetMsiStringValue());
	if (strTarget.Compare(iscStart,TEXT("[#")) && strTarget.Compare(iscEnd,TEXT("]")))
	{
		strTarget.Remove(iseFirst, 2);
		strTarget.Remove(iseEnd,1);
		GetSharedEngineCMsiFile(pobjFile, m_riEngine);
		IMsiRecord* piErrRec = pobjFile->FetchFile(*strTarget);
		if (piErrRec)
			return piErrRec;
		else
			rpiFileRec = pobjFile->GetFileRecord();
	}
	return 0;
}


IMsiRecord* CMsiShortcutCost::Initialize()
//-------------------------------------------
{
	static const ICHAR* szTarget = TEXT("Target");
	static const ICHAR* szDirectory = TEXT("Directory_");

	PMsiTable pTable(0);
	PMsiCursor pCursor(0);	
	IMsiRecord* piErrRec = 0;
	int icolComponent, icolTarget, icolDirectory;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());
	
	if((piErrRec = pDatabase->LoadTable(*MsiString(sztblShortcut),0,*&pTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
			return piErrRec;
	}
	pCursor = pTable->CreateCursor(fFalse);
	
	icolComponent = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szComponent));
	icolTarget = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szTarget));
	icolDirectory = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szDirectory));

	
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	while(pCursor->Next())
	{
		MsiStringId idComponent = pCursor->GetInteger(icolComponent);
		MsiStringId idDestFolder = pCursor->GetInteger(icolDirectory);
		piErrRec = pSelectionMgr->RegisterComponentDirectoryId(idComponent,idDestFolder);
		if (piErrRec)
			return piErrRec;

		MsiString strTarget(pCursor->GetString(icolTarget));
		IMsiRecord* piFileRec = 0;
		IMsiRecord* piErrRec = GetTargetFileRecord(*strTarget, piFileRec);
		MsiString strComponent(pDatabase->DecodeString(idComponent));
		if (piErrRec)
			return piErrRec;
			
		if (piFileRec)
		{
			MsiString strFileComponent(piFileRec->GetMsiString(CMsiFile::ifqComponent));
			piFileRec->Release();

			if (strComponent.Compare(iscExact,strFileComponent) == 0)
			{
				if ((piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strFileComponent,*strComponent)) != 0)
					return piErrRec;
			}
		}
		else if(strTarget.Compare(iscStart, TEXT("[")) == 0)
		{
			// Must be a reference to a feature
			if ((piErrRec = pSelectionMgr->RegisterFeatureCostLinkedComponent(*strTarget,*strComponent)) != 0)
				return piErrRec;
		}

	}
	return 0;
}


IMsiRecord* CMsiShortcutCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsShortcutActivityEnabled(m_riEngine))
		return 0;


	static const ICHAR sqlShortcutCost[] =
	TEXT("SELECT `Name`, `Target`,`Directory_` FROM `Shortcut` WHERE `Component_`=? AND `Directory_`=?");
	
	enum iscEnum
	{
		iscShortcutName = 1,
		iscTarget,
		iscDirectory,
		iscNextEnum
	};

	const int iShortcutSize = 1000; // estimate of disk cost for shortcut creation
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlShortcutCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(2));
	pExecRec->SetMsiString(1, riComponentString);
	pExecRec->SetMsiString(2, riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pQueryRec(m_pCostView->Fetch());
		if (!pQueryRec)
			break;

		// Our new shortcut will overwrite any existing shortcut
		PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
		PMsiPath pDestPath(0);
		if ((piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(pQueryRec->GetMsiString(iscDirectory)),*&pDestPath)) != 0)
			return piErrRec; 
		Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
		MsiString strShortcutName;
		if((piErrRec = pServices->ExtractFileName(pQueryRec->GetString(iscShortcutName),fLFN,*&strShortcutName)) != 0)
			return piErrRec;

		ifsEnum ifsExistingState;
		Bool fShouldInstall;
		unsigned int uiExistingFileSize;
		Bool fInUse;
		piErrRec = pDestPath->GetFileInstallState(*strShortcutName,*MsiString(*TEXT("")),*MsiString(*TEXT("")),
																/* pHash=*/ 0, ifsExistingState,
																fShouldInstall,&uiExistingFileSize, &fInUse, icmOverwriteAllFiles, NULL);

		// iisAbsent costs
		iNoRbRemoveCost -= uiExistingFileSize;

		// iisLocal costs
		unsigned int uiDestClusteredSize;
		if ((piErrRec = pDestPath->ClusteredFileSize(iShortcutSize, uiDestClusteredSize)) != 0)
			return piErrRec;
		iLocalCost += uiDestClusteredSize;
		iSourceCost += uiDestClusteredSize;
		iARPLocalCost += uiDestClusteredSize;
		iNoRbLocalCost += uiDestClusteredSize;
		iNoRbSourceCost += uiDestClusteredSize;
		iNoRbARPLocalCost += uiDestClusteredSize;
		if (!fInUse)
		{
			iNoRbLocalCost -= uiExistingFileSize;
			iNoRbSourceCost -= uiExistingFileSize;
			iNoRbARPLocalCost -= uiExistingFileSize;
		}

		// file in use
		if(fAddFileInUse && fInUse)
		{
			piErrRec = PlaceFileOnInUseList(m_riEngine, *strShortcutName, *MsiString(pDestPath->GetPath()));
			if(piErrRec)
				return piErrRec;
		}
	}
	return 0;
}



/*---------------------------------------------------------------------------
	WriteIniFile cost adjuster
---------------------------------------------------------------------------*/
class CMsiIniFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiIniFileCost(IMsiEngine& riEngine);
protected:
	~CMsiIniFileCost();
private:
	//	IMsiRecord* GetDiffFileCost(const IMsiString& riDirectoryString, const ICHAR* szFile, unsigned int& riAddCost, unsigned int& riRemoveCost);
};
CMsiIniFileCost::CMsiIniFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiIniFileCost::~CMsiIniFileCost(){}



IMsiRecord* CMsiIniFileCost::Initialize()
//-------------------------------------------
{
	const ICHAR sqlInitIniFile[] = TEXT("SELECT `Component_`,`DirProperty` FROM `IniFile`");	

	enum iifInitEnum
	{
		iifInitComponent = 1,
		iifInitDirectory,
		iifInitNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitIniFile, ivcFetch, *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pRec(pView->Fetch());
		if (!pRec)
			break;

		MsiString strComponent(pRec->GetMsiString(iifInitComponent));
		MsiString strDirectory;
		if(!pRec->IsNull(iifInitDirectory))
			strDirectory = (pRec->GetMsiString(iifInitDirectory));
		else
			strDirectory = *IPROPNAME_WINDOWS_FOLDER;
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strDirectory);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}


IMsiRecord* CMsiIniFileCost::GetDynamicCost(const IMsiString& /*riComponentString*/, const IMsiString& /*riDirectoryString*/,
										 Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	// no IniFile costing has been performed ever (even in Darwin 1.0) and this was not compelling
	// enough to add for later versions of Darwin

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	return 0;
}

/*
BEGIN: CODE THAT HAS BEEN TURNED OFF SINCE DARWIN 1.0, part of CMsiIniFileCost::GetDynamicCost

	const ICHAR sqlIniFileCost[] =
	TEXT("SELECT `FileName`, `Section`,`Key`, `Value` FROM `IniFile` WHERE `Component_`=? AND `DirProperty`=? ORDER BY `FileName`");

	enum idfEnum
	{
		idcFileName = 1,
		idcSection,
		idcKey,
		idcValue,
		idcNextEnum
	};
	
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = 0;
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		IMsiRecord* piErrRec = m_riEngine.OpenView(sqlIniFileCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
		{
			if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
				return piErrRec;
			else
			{
				piErrRec->Release();
				return 0;
			}
		}
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(2));
	pExecRec->SetMsiString(1, riComponentString);
	pExecRec->SetMsiString(2, riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	return 0; //!! Until debugged!

	PMsiRecord pIniFileRec(0);
	MsiString strFileName;
	unsigned int iAddCost = 0;
	unsigned int iDelCost = 0;
	for(;;)
	{
		pIniFileRec = m_pCostView->Fetch();
		if(pIniFileRec && strFileName.Compare(iscExact, pIniFileRec->GetString(idcFileName)))
		{
			// we are still on the old file
			iAddCost += MsiString(pIniFileRec->GetMsiString(idcSection)).TextSize();
			iAddCost += MsiString(pIniFileRec->GetMsiString(idcKey)).TextSize();
			iAddCost += MsiString(pIniFileRec->GetMsiString(idcValue)).TextSize();
			iDelCost = iAddCost;
		}
		else
		{
			if(strFileName.TextSize())
			{
				// adjust for cluster size
				if((piErrRec = GetDiffFileCost(riDirectoryString, strFileName, iAddCost, iDelCost)) != 0)
					return piErrRec;
				iLocalCost += iAddCost;
				iNoRbLocalCost += iAddCost;
				iSourceCost += iAddCost;
				iNoRbSourceCost += iAddCost;
				iRemoveCost -= iDelCost; // remove cost is negative
				iNoRbRemoveCost -= iDelCost;
				iAddCost = 0;
				iDelCost = 0;
			}
			if(!pIniFileRec)
				break;
			strFileName = pIniFileRec->GetMsiString(idcFileName);
		}
	}
	return 0;
}


IMsiRecord* CMsiIniFileCost::GetDiffFileCost(const IMsiString& riDirectoryString, const ICHAR* szFile, unsigned int& riAddCost, unsigned int& riRemoveCost)
{
	PMsiDirectoryManager piDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	unsigned int iExistingCost = 0;
	unsigned int iExistingClusteredCost = 0;
	PMsiPath piPath(0);
	IMsiRecord* piErrRec;
	if ((piErrRec = piDirectoryMgr->GetTargetPath(riDirectoryString,*&piPath)) != 0)
		return piErrRec;
	Bool fExists;
	piErrRec = piPath->FileExists(szFile,fExists);
	if (piErrRec)
		return piErrRec;

	if(fExists != fFalse)
	{
		piErrRec = piPath->FileSize(szFile,iExistingCost);
		if (piErrRec)
			return piErrRec;
		if ((piErrRec = piPath->ClusteredFileSize(iExistingCost,iExistingClusteredCost)) != 0)
			return piErrRec;
	}
	riAddCost = riAddCost + iExistingCost;
	if ((piErrRec = piPath->ClusteredFileSize(riAddCost,riAddCost)) != 0)
		return piErrRec;
	riAddCost = riAddCost - iExistingClusteredCost;

	if(iExistingCost >= riRemoveCost)
	{
		riRemoveCost = iExistingCost - riRemoveCost;
		{
			if ((piErrRec = piPath->ClusteredFileSize(riRemoveCost,riRemoveCost)) != 0)
				return piErrRec;
			Assert(iExistingClusteredCost > riRemoveCost);
			riRemoveCost = iExistingClusteredCost - riRemoveCost;
		}
	}
	else
		riRemoveCost = 0;// may be missing the ini file, hence may not get back any space
	return 0;
}

  END: CODE THAT HAS BEEN TURNED OFF SINCE DARWIN 1.0
*/



const ICHAR szIndicGrouping[] = TEXT("3;2;0");

void RetrieveNumberFormat(NUMBERFMT *psNumFmt)
/*---------------------------------------------------------------------------------------------
 helper function to obtain number formatting information for formatting the KB value
 used in the OutOfDiskSpace error messages.  These are whole number values so we don't
 want to use any decimals (1496.00 looks ugly!)

 the remaining information in the NUMBERFMT structure is based upon the current user's
 locale.  All WI system information is displayed in the user's locale and not the package
 language

  -NegativeOrder is REG_SZ with a number of 0,1,2,3, or 4
  -Grouping is REG_SZ of #;0 or #;2;0 where # is in range 0-9 (int value is in range 0-9 or 32)
------------------------------------------------------------------------------------------------*/
{
	if (!psNumFmt)
		return;

	ICHAR szDecSep[5] = {0};
	ICHAR szThousandSep[5] = {0};
	ICHAR szGrouping[6] = {0};
	ICHAR szNegativeOrder[2] = {0};

	// retrieve locale info
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecSep, sizeof(szDecSep)/sizeof(ICHAR)));
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandSep, sizeof(szThousandSep)/sizeof(ICHAR)));
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, sizeof(szGrouping)/sizeof(ICHAR)));
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_INEGNUMBER, szNegativeOrder, sizeof(szNegativeOrder)/sizeof(ICHAR)));

	// no digits with decimal or leading zero
	psNumFmt->NumDigits = 0;
	psNumFmt->LeadingZero = 0;

	// use proper separators for locale
	psNumFmt->lpDecimalSep = new ICHAR[5];
	if (psNumFmt->lpDecimalSep)
		StringCchCopy(psNumFmt->lpDecimalSep, 5, szDecSep);
	psNumFmt->lpThousandSep = new ICHAR[5];
	if (psNumFmt->lpThousandSep)
		StringCchCopy(psNumFmt->lpThousandSep, 5, szThousandSep);

	psNumFmt->NegativeOrder = *szNegativeOrder - '0';
	if (psNumFmt->NegativeOrder > 4)
		psNumFmt->NegativeOrder = 1; // default -- invalid entry

	// determine grouping
	if (0 == lstrcmp(szGrouping, szIndicGrouping))
		psNumFmt->Grouping = 32; // indic language
	else if (*szGrouping - '0' < 0 || *szGrouping - '0' > 9)
		psNumFmt->Grouping = 3; // default -- invalid entry
	else
		psNumFmt->Grouping = *szGrouping - '0';
}

IMsiRecord* PostOutOfDiskSpaceError(IErrorCode iErr, const ICHAR* szPath, int iVolCost, UINT64 uiVolSpace)
/*-----------------------------------------------------------------------------------------------------
 Helper function for setting up the OutOfDiskSpace error
-------------------------------------------------------------------------------------------------------*/
{
	// format space requirements
	NUMBERFMT sNumFmt;
	memset((void*)&sNumFmt, 0x00, sizeof(NUMBERFMT));
	RetrieveNumberFormat(&sNumFmt);

	MsiString strVolSpace;
	if ( uiVolSpace < (UINT64)INT_MAX )
		strVolSpace = MsiString((int)uiVolSpace);
	else
	{
		//!! FUTURE: An MsiString(INT64) constructor is needed
		ICHAR rgchBuffer[24]; // _UI64_MAX = 18,446,744,073,709,551,615
		strVolSpace = MsiString(_ui64tot(uiVolSpace, rgchBuffer, 10));
	}
	int cchRequired = GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolSpace, &sNumFmt, NULL, 0);
	ICHAR *szVolSpace = new ICHAR[cchRequired];
	if (szVolSpace)
		AssertNonZero(GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolSpace, &sNumFmt, szVolSpace, cchRequired));
	MsiString strVolCost(iVolCost);
	cchRequired = GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolCost, &sNumFmt, NULL, 0);
	ICHAR *szVolCost = new ICHAR[cchRequired];
	if (szVolCost)
		AssertNonZero(GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolCost, &sNumFmt, szVolCost, cchRequired));

	// set error
	IMsiRecord* piErrRec = PostError(iErr, szPath, szVolCost, szVolSpace);

	// cleanup
	if (szVolSpace)
		delete [] szVolSpace;
	if (szVolCost)
		delete [] szVolCost;
	if (sNumFmt.lpDecimalSep)
		delete [] sNumFmt.lpDecimalSep;
	if (sNumFmt.lpThousandSep)
		delete [] sNumFmt.lpThousandSep;

	return piErrRec;
}

extern iesEnum ResolveSource(IMsiEngine& riEngine);

/*---------------------------------------------------------------------------
	InstallValidate action
---------------------------------------------------------------------------*/
iesEnum InstallValidate(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	PMsiRecord pProgress = &pServices->CreateRecord(2);
	PMsiRecord pErrRec(0);
	PMsiRecord pFileInUseLogRecord = &pServices->CreateRecord(6);


	// If in verbose mode, log the final feature/component states
	if (FDiagnosticModeSet(dmVerboseDebugOutput|dmVerboseLogging))
	{
		const ICHAR sqlLog[][80] = {TEXT(" SELECT `Feature`, `Action`, `ActionRequested`, `Installed` FROM `Feature`"),
			                        TEXT(" SELECT `Component`, `Action`, `ActionRequest`, `Installed` FROM `Component`")};
		const ICHAR szLogType[][12] = {TEXT("Feature"),TEXT("Component")};
		const ICHAR szState[][15] = {TEXT("Absent"),TEXT("Local"),TEXT("Source"),TEXT("Reinstall"),
			                         TEXT("Advertise"),TEXT("Current"),TEXT("FileAbsent"), TEXT(""), TEXT(""), TEXT(""), TEXT(""),
									 TEXT("HKCRAbsent"), TEXT("HKCRFileAbsent"), TEXT("Null")};

		const int iMappedNullInteger = 13;
		PMsiRecord pLogRec(0);
		PMsiView pView(0);
		for (int x = 0;x < 2;x++)
		{
			pErrRec = riEngine.OpenView(sqlLog[x], ivcFetch, *&pView);
			if (!pErrRec)
			{
				pErrRec = pView->Execute(0);
				if (!pErrRec)
				{

					while((pLogRec = pView->Fetch()) != 0)
					{
						ICHAR rgch[256];
						
						MsiString strKey = pLogRec->GetMsiString(1);
						int iAction = pLogRec->GetInteger(2);
						if (iAction == iMsiNullInteger) iAction = iMappedNullInteger;

						int iActionRequested = (iisEnum) pLogRec->GetInteger(3);
						if (iActionRequested == iMsiNullInteger) iActionRequested = iMappedNullInteger;

						int iInstalled = (iisEnum) pLogRec->GetInteger(4);
						if (iInstalled == iMsiNullInteger) iInstalled = iMappedNullInteger;

						StringCbPrintf(rgch, sizeof(rgch), TEXT("%s: %s; Installed: %s;   Request: %s;   Action: %s"), 
							szLogType[x],(const ICHAR*) strKey, szState[iInstalled], szState[iActionRequested], szState[iAction]);
						DEBUGMSGV(rgch);
					
					}
				}
				pView->Close();
			}
		}
	}

	Bool fRetry = fTrue;
	if ( !g_MessageContext.IsOEMInstall() )
	{
	// there's little point in doing these checks for OEM installs since they shouldn't be
	// running any app while blasting software on the machines and they know that there
	// is enough room on the drive(s).

	// if any files are in use, give the user a chance to free them up before continuing.

	riEngine.SetMode(iefCompileFilesInUse, fTrue);

	do
	{
		if (fRetry)
		{
			Bool fCancel;
			if ((pErrRec = pSelectionMgr->RecostAllComponents(fCancel)) != 0)
			{
				int iErr = pErrRec->GetInteger(1);
				if (iErr == imsgUser)
					return iesUserExit;
				// If Selection mgr not active, there's simply no costing to do
				if (iErr != idbgSelMgrNotInitialized)
					return riEngine.FatalError(*pErrRec);
			}
			if (fCancel)
				return iesUserExit;
		}

		fRetry = fFalse;
		if (pDatabase->FindTable(*MsiString(sztblFilesInUse)) != itsUnknown)
		{
			PMsiTable pFileInUseTable = 0;
			pDatabase->LoadTable(*MsiString(*sztblFilesInUse),0,*&pFileInUseTable);
			int iColFileName = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFileName));
			int iColFilePath = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFilePath));
			int iColProcessID = pFileInUseTable->CreateColumn(
												icdPrimaryKey + icdNullable + icdLong,
												*MsiString(*sztblFilesInUse_colProcessID));
			Assert(iColFileName > 0 && iColFilePath > 0);
			Assert(pFileInUseTable);
			PMsiCursor pFileInUseCursor = pFileInUseTable->CreateCursor(fFalse);
			Assert(pFileInUseCursor);
			PMsiCursor pFileInUseSearchCursor = pFileInUseTable->CreateCursor(fFalse);
			Assert(pFileInUseSearchCursor);
			pFileInUseSearchCursor->SetFilter(iColumnBit(iColProcessID));

			// Assume initial maximum number of modules in use (two record fields per module).
			// We'll grow the message record below if estimate is too small.

			// structure to ensure that we call Services::GetModuleUsage on entry and exit of scope
			// this release the internal Services CDetect object that is holding on to tons of
			// allocated space (possibly stale, hence the call on constructor as well)

			struct CEnsureReleaseFileUseObj{
				CEnsureReleaseFileUseObj(IMsiServices& riServices): m_riServices(riServices)
				{
					StartAfresh();
				}
				~CEnsureReleaseFileUseObj()
				{
					StartAfresh();
				}
				void StartAfresh()
				{
					PEnumMsiRecord pEnumModule(0);
					AssertRecord(m_riServices.GetModuleUsage(g_MsiStringNull,*&pEnumModule));
				}
				IMsiServices& m_riServices;
			};

			Assert(pServices);
			CEnsureReleaseFileUseObj EnsureReleaseFileUseObj(*pServices);

			PMsiRecord pFileInUseRecord(0);
			const int iModuleFieldAllocSize = 8;
			int iModuleFieldCount = 0;
			while (pFileInUseCursor->Next())
			{
				if(riEngine.ActionProgress() == imsCancel)
					return iesUserExit;

				int iProcess = pFileInUseCursor->GetInteger(iColProcessID);
				if ( iProcess != iMsiNullInteger )
					// temporary row we've added below
					continue;
				
				MsiString strFileName(pFileInUseCursor->GetString(iColFileName));
				MsiString strFilePath(pFileInUseCursor->GetString(iColFilePath));
				MsiString strProcessName = strFilePath;
				PEnumMsiRecord pEnumModule(0);
				pErrRec = pServices->GetModuleUsage(*strFileName,*&pEnumModule);
				if (pErrRec)
				{
					if (riEngine.Message(imtInfo, *pErrRec) == imsCancel)
						return iesUserExit;
				}
				else if (pEnumModule)
				{
					PMsiRecord pRecProcess(0);
					while (pEnumModule->Next(1, &pRecProcess, 0) == S_OK)
					{
						MsiString strProcessName(pRecProcess->GetString(1));
						MsiString strProcessFileName;
						int iProcId = pRecProcess->GetInteger(2);

						if((DWORD)iProcId != WIN::GetCurrentProcessId() && // don't display ourselves in FileInUse dialog
							(DWORD)iProcId != (DWORD)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_CLIENTPROCESSID))) // dont display client
						{
							strProcessFileName = strProcessName.Extract(iseAfter,chDirSep);
							if( (strProcessFileName.Compare(iscStartI, TEXT("explorer")) == 0)    // don't display if window owner is explorer.exe
								&& (strProcessFileName.Compare(iscStartI, TEXT("msiexec")) == 0)) // don't display ourselves, PID Only catches service on NT, on 95 concurrent installs																						
																					  // If other cases are found, they go here
							{
								// check if the current window title and process #
								// had already been added to pFileInUseRecord
								pFileInUseSearchCursor->Reset();
								AssertNonZero(pFileInUseSearchCursor->PutString(iColFileName,
																								*strFileName));
								AssertNonZero(pFileInUseSearchCursor->PutString(iColFilePath,
																								*strFilePath));
								AssertNonZero(pFileInUseSearchCursor->PutInteger(iColProcessID,
																								iProcId));
								if ( !pFileInUseSearchCursor->Next() )
								{
									// The current window title is not present in pFileInUseRecord.
									// We add a new row that if we will find later on we know
									// that this process had already been reported.
									AssertNonZero(pFileInUseCursor->PutInteger(iColProcessID,
																							iProcId));
									AssertNonZero(pFileInUseCursor->Insert());
									// If initial estimate too low, grow the record.
									if (iModuleFieldCount % iModuleFieldAllocSize == 0)
									{
										PMsiRecord pNewRecord = &pServices->CreateRecord(iModuleFieldCount + iModuleFieldAllocSize);
										for (int i = 0; iModuleFieldCount && i <= iModuleFieldCount; i++)
											pNewRecord->SetString(i,pFileInUseRecord->GetString(i));
										pFileInUseRecord = pNewRecord;

										// Put a description string for the files-in-use dialog in the zeroth field
										if (iModuleFieldCount == 0)
										{
											pFileInUseRecord->SetMsiString(0, *MsiString(riEngine.GetErrorTableString(imsgFileInUseDescription)));
										}
									}

									pFileInUseRecord->SetMsiString(++iModuleFieldCount,*strProcessName); 
									pFileInUseRecord->SetInteger(++iModuleFieldCount,iProcId);
								}
							}
						}
						if (FDiagnosticModeSet(dmLogging))
						{
							AssertNonZero(pFileInUseLogRecord->ClearData());
							ISetErrorCode(pFileInUseLogRecord,Imsg(imsgFileInUseLog));
							AssertNonZero(pFileInUseLogRecord->SetMsiString(2,*strFilePath));
							AssertNonZero(pFileInUseLogRecord->SetMsiString(3,*strFileName));
							AssertNonZero(pFileInUseLogRecord->SetMsiString(4,*strProcessName));
							AssertNonZero(pFileInUseLogRecord->SetInteger(5,iProcId));
							riEngine.Message(imtInfo,*pFileInUseLogRecord);
						}
					}
				}
			}
			if (pFileInUseRecord)
			{
				DEBUGMSG1(TEXT("%d application(s) had been reported to have files in use."),
							 (const ICHAR*)(INT_PTR)(iModuleFieldCount/2));
				imsEnum imsReturn = riEngine.Message(imtFilesInUse, *pFileInUseRecord);
				pFileInUseCursor->Reset();
				while (pFileInUseCursor->Next())
				{
					pFileInUseCursor->Delete();
				}

				if (imsReturn == imsRetry) // IDRETRY
				{
					Bool fUnlocked = pDatabase->LockTable(*MsiString(sztblFilesInUse),fFalse);
					Assert(fUnlocked == fTrue);
					fRetry = fTrue;
				}
				else if (imsReturn == imsCancel) // IDCANCEL
					return iesUserExit;

				// Anything else (IDIGNORE, for instance) means we just go on (no retry)
			}
		}
	}while (fRetry);

	riEngine.SetMode(iefCompileFilesInUse, fFalse);

	// verify that each target volume has enough space for the install
	// If not, a fatal error will be produced.
	fRetry = fTrue;
	while(fRetry)
	{
		if(riEngine.ActionProgress() == imsCancel)
			return iesUserExit;
		Bool fOutOfNoRbDiskSpace;
		Bool fOutOfSpace;
		Bool fUserCancelled = fFalse;
		
		fOutOfSpace = pSelectionMgr->DetermineOutOfDiskSpace(&fOutOfNoRbDiskSpace, &fUserCancelled);
		if (fUserCancelled)
			return iesUserExit;
			
		if(fOutOfSpace == fTrue)
		{
			PMsiTable pVolTable = pSelectionMgr->GetVolumeCostTable();
			if (pVolTable)
			{
				PMsiCursor pVolCursor = pVolTable->CreateCursor(fFalse);
				Assert (pVolCursor);
				int iColSelVolumeObject = pVolTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colVolumeObject));
				int iColSelVolumeCost = pVolTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colVolumeCost));
				int iColSelNoRbVolumeCost = pVolTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colNoRbVolumeCost));
				Assert(iColSelVolumeObject > 0);
				Assert(iColSelVolumeCost > 0);
				fRetry = fFalse; // if no volumes report out of space we will break out of loop
				while (fRetry == fFalse && pVolCursor->Next())
				{
					PMsiVolume pVolume = (IMsiVolume*) pVolCursor->GetMsiData(iColSelVolumeObject);
					Assert(pVolume);
					
					// Disk cost numbers are stored in multiples of 512 bytes, so divide by 2 for KB 
					int iVolCost = (pVolCursor->GetInteger(iColSelVolumeCost))/2;
					int iNoRbVolCost = (pVolCursor->GetInteger(iColSelNoRbVolumeCost))/2;
					UINT64 iVolSpace = (pVolume->FreeSpace())/2;
					if ((UINT64)iVolCost > iVolSpace)
					{
						// Check to see if there would be enough space to install were rollback to be turned off.
						MsiString strRollbackPrompt = riEngine.GetPropertyFromSz(IPROPNAME_PROMPTROLLBACKCOST);
						bool fRbCostSilent = strRollbackPrompt.Compare(iscExactI,IPROPVALUE_RBCOST_SILENT) ? true : false;
						bool fRbCostFail = strRollbackPrompt.Compare(iscExactI,IPROPVALUE_RBCOST_FAIL) ? true : false;
						imtEnum imtOptions = imtEnum(imtOk);
						MsiString strPath(pVolume->GetPath());
						if (fOutOfNoRbDiskSpace == fTrue || fRbCostFail)
						{	// Fail whether there's no space with rollback turned off or not.
							imtOptions = imtEnum(imtRetryCancel | imtOutOfDiskSpace);
							pErrRec = PostOutOfDiskSpaceError(Imsg(imsgOutOfDiskSpace), (const ICHAR*)strPath, fRbCostSilent ? iNoRbVolCost : iVolCost, iVolSpace);
						}
						else if (fRbCostSilent)
						{	// Silently disable rollback
							fRetry = fFalse;
							riEngine.SetMode(iefRollbackEnabled, fFalse);
							pErrRec = 0;
						}
						else
						{	// IPROPNAME_PROMPTROLLBACKCOST either not defined, or anything but IPROPVALUE_RBCOST_FAIL or
							// IPROPVALUE_RBCOST_SILENT, so default to prompting the user.
							imtOptions = imtEnum(imtAbortRetryIgnore | imtOutOfDiskSpace);
							pErrRec = PostOutOfDiskSpaceError(Imsg(imsgOutOfRbDiskSpace), (const ICHAR*)strPath, iVolCost, iVolSpace);
						}
	
						if (pErrRec)
						{
							switch(riEngine.Message(imtOptions, *pErrRec))
							{
							case imsCancel:
							case imsAbort:
								pErrRec = PostError(Imsg(imsgConfirmCancel));
								switch(riEngine.Message(imtEnum(imtUser+imtYesNo+imtDefault2), *pErrRec))
								{
								case imsNo:
									fRetry = fTrue;
									break;
								default: // imsNone, imsYes
									return iesUserExit;
								};
								break;
							case imsRetry:
								fRetry = fTrue;
								break;
							case imsIgnore:
								fRetry = fFalse;
								riEngine.SetMode(iefRollbackEnabled, fFalse);
								break;
							default: // imsNone
								return iesFailure;
							}
						}
					}
				}
			}
			else
			{
				// no volume table even though DetermineOutOfDiskSpace failed
				AssertSz(0,TEXT("Couldn't get volume table in InstallValidate"));
				break;
			}
		}
		else // not out of disk space
			break;
	}

	} // endif IsOEMInstall
		
	bool fRemoveAll = false;

	// If the "REMOVE" property is not already set to all-uppercase "ALL", set it to that
	// value if it is currently mixed-case "All", OR if all features are being removed.
	// This will allow actions following InstallValidate to use a condition of "REMOVE=ALL"
	// to conclusively fire if the entire product is being removed.
	MsiString strRemoveValue = riEngine.GetPropertyFromSz(IPROPNAME_FEATUREREMOVE);
	if (!strRemoveValue.Compare(iscExact, IPROPVALUE_FEATURE_ALL))
	{
		if (strRemoveValue.Compare(iscExactI, IPROPVALUE_FEATURE_ALL) || !FFeaturesInstalled(riEngine, fFalse))
		{
			AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_FEATUREREMOVE), *MsiString(*IPROPVALUE_FEATURE_ALL)));
			fRemoveAll = true;
		}
	}
	else
	{
		fRemoveAll = true;
	}

	// for certain packages, we need to call the ResolveSource action at this point if we are not
	// performing a full uninstall
	if(false == fRemoveAll &&
		riEngine.FPerformAppcompatFix(iacsForceResolveSource))
	{
		DEBUGMSG(TEXT("Resolving source for application compatibility with this install."));
		iesEnum iesRet = ResolveSource(riEngine);
		if(iesRet != iesSuccess)
			return iesRet;
	}
	
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;
		
	return iesSuccess;
}


/*---------------------------------------------------------------------------
	ReserveCost costing (there is no ReserveCost action
---------------------------------------------------------------------------*/
class CMsiReserveCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiReserveCost(IMsiEngine& riEngine);
protected:
	~CMsiReserveCost();
private:
};
CMsiReserveCost::CMsiReserveCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiReserveCost::~CMsiReserveCost(){}


IMsiRecord* CMsiReserveCost::Initialize()
//-------------------------------------------
{
	const ICHAR sqlInitReserveCost[] =
	TEXT("SELECT `Component_`,`ReserveFolder` FROM `ReserveCost`");

	enum ircInitEnum
	{
		ircInitComponent = 1,
		ircReserveFolder,
		ircInitNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitReserveCost, ivcEnum(ivcFetch|ivcUpdate), *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pRec(pView->Fetch());
		if (!pRec)
			break;

		MsiString strComponent(pRec->GetMsiString(ircInitComponent));
		MsiString strReserveFolder(pRec->GetMsiString(ircReserveFolder));
		if (strReserveFolder.TextSize())
		{
			piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strReserveFolder);
			if (piErrRec)
				return piErrRec;
		}
	}
	return 0;
}


IMsiRecord* CMsiReserveCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	const ICHAR sqlReserveCost[] =
	TEXT("SELECT `ReserveFolder`,`Directory_`,`ReserveLocal`,`ReserveSource` FROM `ReserveCost`,`Component` WHERE `Component`=`Component_` ")
	TEXT("AND Component_=?");

	enum idfEnum
	{
		ircReserveFolder = 1,
		ircComponentDir,
		ircLocalCost,
		ircSourceCost,
		idfNextEnum
	};

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;

	// ReserveCost cost adjuster will never get registered
	// and called unless the ReserveCost table is present.
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlReserveCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(1));
	pExecRec->SetMsiString(1, riComponentString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pReserveRec(m_pCostView->Fetch());
		if (!pReserveRec)
			break;

		// If no ReserveFolder given in the table, use the component's directory
		MsiString strReserveFolder(pReserveRec->GetMsiString(ircReserveFolder));
		if (strReserveFolder.TextSize() == 0)
			strReserveFolder = pReserveRec->GetMsiString(ircComponentDir);

		if (riDirectoryString.Compare(iscExact,strReserveFolder) == 0)
			continue;

		PMsiPath pReservePath(0);
		piErrRec = pDirectoryMgr->GetTargetPath(*strReserveFolder,*&pReservePath);
		if (piErrRec)
			return piErrRec;

		unsigned int uiClusteredSize;
		// Local costs
		if ((piErrRec = pReservePath->ClusteredFileSize(pReserveRec->GetInteger(ircLocalCost), uiClusteredSize)) != 0)
			return piErrRec;
		iLocalCost += uiClusteredSize;
		iNoRbLocalCost += uiClusteredSize;

		iARPLocalCost += uiClusteredSize;
		iNoRbARPLocalCost += uiClusteredSize;

		iRemoveCost -= uiClusteredSize;
		iNoRbRemoveCost -= uiClusteredSize;

		// Source costs
		if ((piErrRec = pReservePath->ClusteredF