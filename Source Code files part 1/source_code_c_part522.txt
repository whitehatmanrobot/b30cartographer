SHEET(m_SessionTimeout);
      FETCH_INST_DATA_FROM_SHEET(m_ScriptTimeout);
      FETCH_INST_DATA_FROM_SHEET(m_Languages);
      FETCH_INST_DATA_FROM_SHEET(m_AspServiceFlag);
      FETCH_INST_DATA_FROM_SHEET(m_AspSxsName);
   END_META_INST_READ(err)

   if (GetSheet()->QueryMajorVersion() >= 6)
   {
       m_AspEnableSxs = 0 != (m_AspServiceFlag & 2);
   }

   return err;
}

/* virtual */
HRESULT
CAspMainPage::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   if (m_AspEnableSxs)
       m_AspServiceFlag |= 2;
   else
       m_AspServiceFlag &= ~2;

   BEGIN_META_INST_WRITE(CAppPropSheet)
      STORE_INST_DATA_ON_SHEET(m_EnableSession)
      STORE_INST_DATA_ON_SHEET(m_EnableBuffering)
      STORE_INST_DATA_ON_SHEET(m_EnableParents)
      STORE_INST_DATA_ON_SHEET(m_SessionTimeout)
      STORE_INST_DATA_ON_SHEET(m_ScriptTimeout)
      STORE_INST_DATA_ON_SHEET(m_Languages)
      if (GetSheet()->QueryMajorVersion() >= 6)
      {
          STORE_INST_DATA_ON_SHEET(m_AspServiceFlag)
          STORE_INST_DATA_ON_SHEET(m_AspSxsName)
      }
   END_META_INST_WRITE(err)

   return err;
}

void
CAspMainPage::DoDataExchange(CDataExchange * pDX)
{
	CInetPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAspMainPage)
	DDX_Check(pDX, IDC_ENABLE_SESSION, m_EnableSession);
	DDX_Check(pDX, IDC_ENABLE_BUFFERING, m_EnableBuffering);
	DDX_Check(pDX, IDC_ENABLE_PARENTS, m_EnableParents);
    // This Needs to come before DDX_Text which will try to put text big number into small number
	DDV_MinMaxBalloon(pDX, IDC_SESSION_TIMEOUT, SESSION_TIMEOUT_MIN, SESSION_TIMEOUT_MAX);
	DDX_TextBalloon(pDX, IDC_SESSION_TIMEOUT, m_SessionTimeout);
	// This Needs to come before DDX_Text which will try to put text big number into small number
	DDV_MinMaxBalloon(pDX, IDC_SCRIPT_TIMEOUT, SCRIPT_TIMEOUT_MIN, SCRIPT_TIMEOUT_MAX);
	DDX_TextBalloon(pDX, IDC_SCRIPT_TIMEOUT, m_ScriptTimeout);
	DDX_Text(pDX, IDC_LANGUAGES, m_Languages);
	DDX_Check(pDX, IDC_ENABLE_SXS, m_AspEnableSxs);
	DDX_Control(pDX, IDC_LANGUAGES, m_LanguagesCtrl);
	//}}AFX_DATA_MAP
    DDX_Text(pDX, IDC_MANIFEST, m_AspSxsName);
    if (pDX->m_bSaveAndValidate)
    {
        if (m_AspEnableSxs)
        {
            DDV_MinMaxChars(pDX, m_AspSxsName, 0, MAX_PATH);
            if (    !PathIsValid(m_AspSxsName,FALSE)
                ||  !PathIsFileSpec(m_AspSxsName)
                ||  m_AspSxsName.FindOneOf(_T(" *?/\\<>:|\"")) != -1
                )
            {
                DDV_ShowBalloonAndFail(pDX, IDS_INVALID_MANIFEST_NAME);
            }
        }
    }
}

//////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CAspMainPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAspMainPage)
    ON_BN_CLICKED(IDC_ENABLE_SESSION, OnItemChanged)
    ON_BN_CLICKED(IDC_ENABLE_SXS, OnSxs)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAspMainPage::OnInitDialog()
{
	UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

	CInetPropertyPage::OnInitDialog();

	ASSERT(NULL != GetDlgItem(IDC_TIMEOUT_SPIN));
	SendDlgItemMessage(IDC_TIMEOUT_SPIN,UDM_SETRANGE32, SESSION_TIMEOUT_MIN, SESSION_TIMEOUT_MAX);
	SendDlgItemMessage(IDC_TIMEOUT_SPIN, UDM_SETPOS32, 0, m_SessionTimeout);
	SendDlgItemMessage(IDC_TIMEOUT_SPIN, UDM_SETACCEL, 3, (LPARAM)toAcc);

	ASSERT(NULL != GetDlgItem(IDC_ASPTIMEOUT_SPIN));
	SendDlgItemMessage(IDC_ASPTIMEOUT_SPIN, UDM_SETRANGE32, SCRIPT_TIMEOUT_MIN, SCRIPT_TIMEOUT_MAX);
	SendDlgItemMessage(IDC_ASPTIMEOUT_SPIN, UDM_SETPOS32, 0, m_ScriptTimeout);
	SendDlgItemMessage(IDC_ASPTIMEOUT_SPIN, UDM_SETACCEL, 3, (LPARAM)toAcc);

	GetDlgItem(IDC_ENABLE_SXS)->EnableWindow(GetSheet()->QueryMajorVersion() >= 6);

	SetControlsState();
	OnItemChanged(); 

	return FALSE;
}

void
CAspMainPage::OnItemChanged()
{
	BOOL bEnable = SendDlgItemMessage(IDC_ENABLE_SESSION, BM_GETCHECK, 0, 0);
	::EnableWindow(CONTROL_HWND(IDC_SESSION_TIMEOUT), bEnable);
	::EnableWindow(CONTROL_HWND(IDC_TIMEOUT_SPIN), bEnable);
	SetModified(TRUE);
}

void
CAspMainPage::OnSxs()
{
	m_AspEnableSxs = !m_AspEnableSxs;
	SetControlsState();
    SetModified(TRUE);
}

void
CAspMainPage::SetControlsState()
{
	GetDlgItem(IDC_MANIFEST_STATIC)->EnableWindow(m_AspEnableSxs);
	GetDlgItem(IDC_MANIFEST)->EnableWindow(m_AspEnableSxs);
}

/////////////////////////////////////////////////////////////////////////////

#define EXT_WIDTH          58
#define PATH_WIDTH         204
#define EXCLUSIONS_WIDTH   72

static int CALLBACK SortCallback(LPARAM lp1, LPARAM lp2, LPARAM parSort)
{
    Mapping * pm1 = (Mapping *)lp1;
    ATLASSERT(pm1 != NULL);
    Mapping * pm2 = (Mapping *)lp2;
    ATLASSERT(pm2 != NULL);
    short order = (short)HIWORD(parSort) > 0 ? 1 : -1;
    int col = (int)LOWORD(parSort);
    int res = 0;
    switch (col)
    {
    case 0:
        res = pm1->ext.CompareNoCase(pm2->ext);
        break;
    case 1:
        res = pm1->path.CompareNoCase(pm2->path);
        break;
    case 2:
        res = pm1->verbs.CompareNoCase(pm2->verbs);
        break;
    }
    return order * res;
}

BOOL SortMappings(CListCtrl& list, int col, int order)
{
    return list.SortItems(SortCallback, MAKELPARAM((WORD)col, (WORD)order));
}

CAppMappingPageBase::CAppMappingPageBase(DWORD id, CInetPropertySheet * pSheet)
	: CInetPropertyPage(id, pSheet)
{
}

CAppMappingPageBase::~CAppMappingPageBase()
{
}

HRESULT
CAppMappingPageBase::FetchLoadedValues()
{
	CError err;
	BEGIN_META_INST_READ(CAppPropSheet)
		FETCH_INST_DATA_FROM_SHEET(m_CacheISAPI);
		FETCH_INST_DATA_FROM_SHEET(m_strlMappings);
	END_META_INST_READ(err)
	return err;
}

HRESULT
CAppMappingPageBase::SaveInfo()
{
	ASSERT(IsDirty());
	CError err;
	BEGIN_META_INST_WRITE(CAppPropSheet)
		STORE_INST_DATA_ON_SHEET(m_CacheISAPI)
		STORE_INST_DATA_ON_SHEET(m_strlMappings)
	END_META_INST_WRITE(err)
	return err;
}

void
CAppMappingPageBase::RemoveSelected(CListCtrl& lst)
{
    int sel = -1;
    int count = lst.GetItemCount();
    for (int i = 0; i < count;)
    {
        // We are scanning list looking for selected item, when found we are deleting it,
        // decrementing count and do not advance index, because now index points
        // to next item. It should work for any combination of selections in
        // multiselection list
        UINT state = lst.GetItemState(i, LVIS_SELECTED);
        if ((state & LVIS_SELECTED) != 0)
        {
            Mapping * p = (Mapping *)lst.GetItemData(i);
            delete p;
            if (sel == -1)
            {
                sel = i;
            }
            lst.DeleteItem(i);
            count--;
            continue;
        }
        i++;
    }
    count = lst.GetItemCount();
    if (sel == count)
    {
        sel--;
    }
	lst.SetItemState(sel, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
}

void
CAppMappingPageBase::SetControlsState()
{
    int sel_count = m_list.GetSelectedCount();
    ::EnableWindow(CONTROL_HWND(IDC_EDIT), sel_count == 1);
    ::EnableWindow(CONTROL_HWND(IDC_REMOVE), sel_count > 0);
}

void
CAppMappingPageBase::DoDataExchange(CDataExchange * pDX)
{
	CInetPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAppMappingPageBase)
	DDX_Check(pDX, IDC_CACHE_ISAPI, m_CacheISAPI);
	DDX_Control(pDX, IDC_LIST, m_list);
	//}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate)
    {
        int count = m_list.GetItemCount();
        m_strlMappings.RemoveAll();
        for (int i = 0; i < count; i++)
        {
            Mapping * p = (Mapping *)m_list.GetItemData(i);
	        CString buf;
            p->ToString(buf);
		    m_strlMappings.AddTail(buf);
        }
    }
}

BEGIN_MESSAGE_MAP(CAppMappingPageBase, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppMappingPageBase)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_CACHE_ISAPI, OnDlgItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppMappingPageBase::OnInitDialog()
{
	CInetPropertyPage::OnInitDialog();
	DWORD dwStyle = m_list.GetExtendedStyle();
	m_list.SetExtendedStyle(
		dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP);

	CString str;
	str.LoadString(IDS_EXTENSION);
	m_list.InsertColumn(COL_EXTENSION, str, LVCFMT_LEFT, EXT_WIDTH, 0);
	str.LoadString(IDS_EXECUTABLE_PATH);
	m_list.InsertColumn(COL_PATH, str, LVCFMT_LEFT, PATH_WIDTH, 1);
	str.LoadString(IDS_VERBS);
	m_list.InsertColumn(COL_EXCLUSIONS, str, LVCFMT_LEFT, EXCLUSIONS_WIDTH, 2);
	CString all_verbs;
	all_verbs.LoadString(IDS_ALL);

	POSITION pos = m_strlMappings.GetHeadPosition();
	int idx = 0;
	while (pos != NULL)
	{
		str = m_strlMappings.GetNext(pos);
		Mapping * p = new Mapping(str);
		if (p == NULL)
			break;
		if (StrCmp(p->ext, _T("*")) != 0 || GetSheet()->QueryMajorVersion() < 6)
		{
	        VERIFY(-1 != m_list.InsertItem(idx, p->ext));
	        VERIFY(m_list.SetItemData(idx, (LPARAM)p));
	        VERIFY(m_list.SetItemText(idx, COL_PATH, p->path));
	        VERIFY(m_list.SetItemText(idx, COL_EXCLUSIONS, 
		        p->verbs.IsEmpty() ? all_verbs : p->verbs));
	        idx++;
		}
		else
		{
			delete p;
		}
	}
    CString remainder;
    CMetabasePath::GetRootPath(QueryMetaPath(), str, &remainder);
    ::EnableWindow(CONTROL_HWND(IDC_CACHE_ISAPI), remainder.IsEmpty());
	int count = m_list.GetItemCount();

    m_sortCol = 0;
    m_sortOrder = 1;
	if (count > 0)
	{
        SortMappings(m_list, m_sortCol, m_sortOrder);
		m_list.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
	}
    SetControlsState();

	return FALSE;
}

BOOL 
CAppMappingPageBase::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	ASSERT(pResult != NULL);
	NMHDR* pNMHDR = (NMHDR*)lParam;
    // We are looking only for events from the listview control here.
    // This is the only way to catch notification, MFC screens
    // all this stuff out.
    if (pNMHDR->idFrom == IDC_LIST)
    {
        BOOL processed = FALSE;
	    switch (pNMHDR->code)
        {
        case NM_DBLCLK:
            processed = OnDblClickList(pNMHDR, pResult);
            break;
        case LVN_ITEMCHANGED:
            processed = OnItemChanged(pNMHDR, pResult);
            break;
        case LVN_KEYDOWN:
            processed = OnKeyDown(pNMHDR, pResult);
            break;
        case LVN_COLUMNCLICK:
            processed = OnColumnClick(pNMHDR, pResult);
            break;
        default:
            break;
        }
        if (processed)
            return TRUE;
    }
    return CInetPropertyPage::OnNotify(wParam, lParam, pResult);
}

void
CAppMappingPageBase::OnAdd()
{
	CEditMap dlg(this);
	dlg.m_new = TRUE;
	dlg.m_flags = MD_SCRIPTMAPFLAG_SCRIPT | MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
    dlg.m_pMaps = &m_list;
	dlg.m_bIsLocal = GetSheet()->IsLocal();
	dlg.m_has_global_interceptor = GetSheet()->QueryMajorVersion() >= 6;
	if (dlg.DoModal() == IDOK)
	{
		CString all_verbs;
		VERIFY(all_verbs.LoadString(IDS_ALL));

		Mapping * pmap = new Mapping;
		pmap->ext = dlg.m_ext;
		pmap->path = dlg.m_exec;
		pmap->verbs = dlg.m_verbs;
		pmap->flags = dlg.m_flags;
		int count = m_list.GetItemCount();
		VERIFY(-1 != m_list.InsertItem(count, pmap->ext));
		VERIFY(m_list.SetItemData(count, (LPARAM)pmap));
		VERIFY(m_list.SetItemText(count, COL_PATH, pmap->path));
		VERIFY(m_list.SetItemText(count, COL_EXCLUSIONS, 
			dlg.m_verbs[0] == 0 ? all_verbs : dlg.m_verbs));
		// Now unselect all items and select the new one
		for (int i = 0; i < count; i++)
		{
			m_list.SetItemState(i, 0, LVIS_SELECTED | LVIS_FOCUSED);
		}
		m_list.SetItemState(count, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		SetModified(TRUE);
        SetControlsState();
        SortMappings(m_list, m_sortCol, m_sortOrder);
	}
}

void
CAppMappingPageBase::OnEdit()
{
    int idx = m_list.GetNextItem(-1, LVNI_SELECTED);
	if (LB_ERR != idx)
	{
		CEditMap dlg(this);
		dlg.m_new = FALSE;
		dlg.m_pMaps = &m_list;
		dlg.m_bIsLocal = GetSheet()->IsLocal();
		dlg.m_has_global_interceptor = GetSheet()->QueryMajorVersion() >= 6;
		Mapping * pmap = (Mapping *)m_list.GetItemData(idx);
		ASSERT(pmap != NULL);
		dlg.m_ext = pmap->ext;
		dlg.m_exec = pmap->path;
		dlg.m_verbs = pmap->verbs;
		dlg.m_flags = pmap->flags;
		if (dlg.DoModal() == IDOK)
		{
			CString all_verbs;
			all_verbs.LoadString(IDS_ALL);
			pmap->ext = dlg.m_ext;
			pmap->path = dlg.m_exec;
			pmap->verbs = dlg.m_verbs;
			pmap->flags = dlg.m_flags;
			VERIFY(m_list.SetItemData(idx, (LPARAM)pmap));
			VERIFY(m_list.SetItemText(idx, COL_PATH, pmap->path));
			VERIFY(m_list.SetItemText(idx, COL_EXCLUSIONS, 
				dlg.m_verbs[0] == 0 ? all_verbs : dlg.m_verbs));
			SetModified(TRUE);
			SetControlsState();
			SortMappings(m_list, m_sortCol, m_sortOrder);
		}
	}
}

void
CAppMappingPageBase::OnRemove()
{
    if (IDYES == AfxMessageBox(IDS_CONFIRM_REMOVE_MAP, MB_YESNO))
    {
        RemoveSelected(m_list);
		SetModified(TRUE);
        SetControlsState();
        ::SetFocus(CONTROL_HWND(m_list.GetItemCount() <= 0 ? IDC_ADD : IDC_REMOVE));
    }
}

BOOL
CAppMappingPageBase::OnDblClickList(NMHDR* pNMHDR, LRESULT* pResult)
{
    if (m_list.GetItemCount() > 0)
    {
        OnEdit();
    }
    *pResult = TRUE;
    return *pResult;
}

BOOL
CAppMappingPageBase::OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    SetControlsState();
	SetModified(TRUE);
    *pResult = TRUE;
    return *pResult;
}

void
CAppMappingPageBase::OnDlgItemChanged()
{
    SetControlsState();
	SetModified(TRUE);
}

BOOL
CAppMappingPageBase::OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult)
{
    NMLVKEYDOWN * pKD = (NMLVKEYDOWN *)pNMHDR;
    if (pKD->wVKey == VK_DELETE)
    {
        if (::IsWindowEnabled(CONTROL_HWND(IDC_REMOVE)))
        {
            OnRemove();
            *pResult = TRUE;
        }
    }
    else if (pKD->wVKey == VK_INSERT)
    {
        OnAdd();
        *pResult = TRUE;
    }
    else if (pKD->wVKey == VK_RETURN)
    {
        short state = GetKeyState(VK_MENU);
        if ((0x8000 & state) != 0)
        {
            if (::IsWindowEnabled(CONTROL_HWND(IDC_EDIT)))
            {
                OnEdit();
                *pResult = TRUE;
            }
        }
    }
    else
    {
        *pResult = FALSE;
    }
    return *pResult;
}

BOOL
CAppMappingPageBase::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMLISTVIEW plv = (LPNMLISTVIEW)pNMHDR;
    if (m_sortCol == plv->iSubItem)
    {
        m_sortOrder = -m_sortOrder;
    }
    else
    {
        m_sortCol = plv->iSubItem;
    }
    SortMappings(m_list, m_sortCol, m_sortOrder);
    *pResult = FALSE;
    return *pResult;
}

/////////////////////////////////////////////////////

BOOL
    CEditMapBase::OnInitDialog()
{
    m_file_exists = ((m_flags & MD_SCRIPTMAPFLAG_CHECK_PATH_INFO) != 0);
	CDialog::OnInitDialog();
	m_exec_init = m_exec;
	::EnableWindow(CONTROL_HWND(IDC_BUTTON_BROWSE), m_bIsLocal);
	return FALSE;
}

static int
ExtractPath(LPCTSTR cmd_line, CString& path)
{
	int rc = 0;
    LPTSTR pbuf = (LPTSTR)_alloca(sizeof(TCHAR) * lstrlen(cmd_line) + sizeof(TCHAR));
    if (pbuf != NULL)
    {
	    LPTSTR start = pbuf;
	    _tcscpy(pbuf, cmd_line);
        if (*pbuf == _T('"'))
        {
            LPTSTR end = StrChr(++start, _T('"'));
            if (end == NULL)
            {
			    // Wrong format, closing quotation mark is not set
			    rc = IDS_ERR_PATH_NO_CLOSING_QUOTE;
			    // Return part of the path up to first space
			    PathRemoveArgs(pbuf);
            }
            else
            {
			    ++end;
			    *end = 0;
			    PathUnquoteSpaces(pbuf);
			    start = pbuf;
            }
        }
        else
        {
            PathRemoveArgs(pbuf);
        }
	    if (rc == 0)
	    {
		    path = pbuf;
	    }
    }
	return rc;
}

void
CEditMapBase::DoDataExchange(CDataExchange * pDX)
{
	BOOL bHasSpaces = FALSE;
	DDX_Text(pDX, IDC_EXECUTABLE, m_exec);
    if (pDX->m_bSaveAndValidate)
    {
		int rc = 0;
        CString path, csPathMunged;

		// check if entered path contains spaces...
		bHasSpaces = (_tcschr(m_exec, _T(' ')) != NULL);
		if (bHasSpaces)
		{
			// 
			// This could either be:
			// 1. c:\program files\myfile.exe
			// 2. c:\program files\myfile.exe %1
			// 3. c:\program files\myfilethatdoesntexist.exe
			// 4. c:\program files\myfilethatdoesntexist.exe %1

			// if it has spaces then we have to require that it
			// contain quotation marks
			if (_tcschr(m_exec, _T('"')) != NULL)
			{
				// we found a quote!
				// proceed
			}
			else
			{
				// contains spaces but no quotes, show the error msg and bail!
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_PATH_HAS_SPACES_REQUIRE_QUOTES);
			}
		}

		rc = ExtractPath(m_exec, path);
		if (rc != 0)
		{
            DDV_ShowBalloonAndFail(pDX, rc);
		}
        if (m_exec.CompareNoCase(m_exec_init) != 0 
			&& m_star_maps && m_pMaps != NULL)
        {
            LVFINDINFO fi;
            fi.flags = LVFI_STRING;
            fi.vkDirection = VK_DOWN;
            fi.psz = m_exec;
            int idx = m_pMaps->FindItem(&fi, -1);
            if (idx != -1)
            {
                DDV_ShowBalloonAndFail(pDX, IDS_ERR_USEDPATH);
            }
        }

        csPathMunged = path;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
        GetSpecialPathRealPath(0,path,csPathMunged);
#endif
	    DDV_FilePath(pDX, csPathMunged, m_bIsLocal);
        if (PathIsUNC(csPathMunged))
        {
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_NOUNC);
        }
        if (m_bIsLocal)
        {
            if (PathIsNetworkPath(csPathMunged))
            {
                DDV_ShowBalloonAndFail(pDX, IDS_ERR_NOREMOTE);
            }
            if (PathIsDirectory(csPathMunged))
            {
                DDV_ShowBalloonAndFail(pDX, IDS_ERR_FILENOTEXISTS);
            }
        }
    }
	DDX_Check(pDX, IDC_FILE_EXISTS, m_file_exists);
    if (pDX->m_bSaveAndValidate)
    {
        if (m_file_exists)
		{
            m_flags |= MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
		}
        else
		{
            m_flags &= ~MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
		}
    }
}

BOOL
CEditMapBase::SetControlsState()
{
    BOOL bRes = ::GetWindowTextLength(CONTROL_HWND(IDC_EXECUTABLE)) > 0;
	::EnableWindow(CONTROL_HWND(IDOK), bRes);
    return bRes;
}

BEGIN_MESSAGE_MAP(CEditMapBase, CDialog)
    //{{AFX_MSG_MAP(CEditMapBase)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_EN_CHANGE(IDC_EXECUTABLE, OnExecutableChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void
CEditMapBase::OnButtonBrowse()
{
    ASSERT(m_bIsLocal);

    CString mask((LPCTSTR) m_IDS_BROWSE_BUTTON_MASK);
    
//#if 0
    TCHAR buf[MAX_PATH];
    _tcscpy(buf, _T(""));

    for (int i = 0; i < mask.GetLength(); i++)
    {
        if (mask.GetAt(i) == _T('|'))
            mask.SetAt(i, 0);
    }
    
    OPENFILENAME ofn = {0};
    ZeroMemory(&ofn, sizeof(OPENFILENAME));

    ofn.lStructSize = sizeof(OPENFILENAME);
    //ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFilter = mask;
    ofn.lpstrFile = buf;
    //ofn.lpstrInitialDir = buf2;
    ofn.nMaxFile = MAX_PATH;
	ofn.Flags |= 
        OFN_DONTADDTORECENT
        |OFN_HIDEREADONLY
        |OFN_ENABLESIZING
        |OFN_EXPLORER
        |OFN_FILEMUSTEXIST
        |OFN_NONETWORKBUTTON;

    CThemeContextActivator activator(theApp.GetFusionInitHandle());
    
    if (GetOpenFileName(&ofn))
    {
		::SetWindowText(CONTROL_HWND(IDC_EXECUTABLE), ofn.lpstrFile);
		OnExecutableChanged();
    }
    else
    {
        // Failure
        if (CommDlgExtendedError() != 0)
        {
            DebugTrace(_T("GetOpenFileName failed, 0x%08lx\n"),CommDlgExtendedError());
        }
    }

#if 0
//#else
    CFileDialog dlgBrowse(
        TRUE, 
        NULL, 
        NULL, 
        OFN_HIDEREADONLY, 
        mask, 
        this
        );
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

	INT_PTR rc = dlgBrowse.DoModal();
    if (rc == IDOK)
    {
		::SetWindowText(CONTROL_HWND(IDC_EXECUTABLE), dlgBrowse.GetPathName());
		OnExecutableChanged();
    }
	else if (rc == IDCANCEL)
	{
		DWORD err = CommDlgExtendedError();
	}
#endif

}

void
CEditMapBase::OnExecutableChanged()
{
    SetControlsState();
}

///===================

BOOL
CEditMap::OnInitDialog()
{
    m_verbs_index = m_verbs.IsEmpty() ? 0 : 1;
    m_script_engine = ((m_flags & MD_SCRIPTMAPFLAG_SCRIPT) != 0);
    CEditMapBase::OnInitDialog();

    SetControlsState();
    return FALSE;
}

void
CEditMap::DoDataExchange(CDataExchange * pDX)
{
    CEditMapBase::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EXTENSION, m_ext);
    if (pDX->m_bSaveAndValidate && m_new)
    {
        CString ext = m_ext;
        ext.TrimLeft();
        ext.TrimRight();

        if (0 == ext.Compare(_T(".")))
        {
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
        }
        if (0 == ext.GetLength())
        {
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
        }
        if (ext.ReverseFind(_T('.')) > 0)
        {
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
        }
		size_t n, len = ext.GetLength();
		if ((n = _tcscspn(ext, _T(",\"| /\\:?<>"))) < len)
		{
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
		}
		if (m_has_global_interceptor)
	    {
			if (ext.GetAt(0) == _T('*') || ext.Compare(_T(".*")) == 0)
			{
				// Change it later to more explicit message
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
			}
			else if (ext.Find(_T('*')) != -1)
			{
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
			}
	    }
		else if (ext.Find(_T('*')) != -1)
		{
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
		}
        if (ext.GetAt(0) == _T('*'))
            ext = ext.Left(1);
        else if (ext.Compare(_T(".*")) == 0)
            ext = _T("*");
        else if (ext.GetAt(0) != _T('.'))
            ext = _T('.') + ext;
		if (ext.GetAt(0) != _T('.') && ext.Find(_T('*')) > 1)
		{
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_BADEXT);
		}
        LVFINDINFO fi;
        fi.flags = LVFI_STRING;
        fi.vkDirection = VK_DOWN;
        fi.psz = ext;
        if (m_pMaps->FindItem(&fi) != -1)
        {
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_USEDEXT);
        }
		m_ext = ext;
    }
    DDX_Radio(pDX, IDC_ALL_VERBS, m_verbs_index);
    DDX_Text(pDX, IDC_VERBS, m_verbs);
    if (pDX->m_bSaveAndValidate)
    {
        if (m_verbs_index > 0)
        {
            DDV_MinMaxChars(pDX, m_verbs, 1, MAX_PATH);
        }
        else
        {
            m_verbs.Empty();
        }
    }
	DDX_Check(pDX, IDC_SCRIPT_ENGINE, m_script_engine);
	if (pDX->m_bSaveAndValidate)
	{
        if (m_script_engine)
            m_flags |= MD_SCRIPTMAPFLAG_SCRIPT;
        else
            m_flags &= ~MD_SCRIPTMAPFLAG_SCRIPT;
	}
}

BOOL
CEditMap::SetControlsState()
{
    BOOL bRes = CEditMapBase::SetControlsState();
    BOOL lim_verbs = ((CButton*)GetDlgItem(IDC_LIMIT_VERBS))->GetCheck() == BST_CHECKED;
    ::EnableWindow(CONTROL_HWND(IDC_VERBS), lim_verbs);
    ::EnableWindow(CONTROL_HWND(IDC_EXTENSION), m_new);
    if (bRes)
    {
        bRes = GetDlgItem(IDC_EXTENSION)->GetWindowTextLength() > 0;
        if (lim_verbs)
        {
            bRes = GetDlgItem(IDC_VERBS)->GetWindowTextLength() > 0;
        }
        ::EnableWindow(CONTROL_HWND(IDOK), bRes);
    }
    return bRes;
}

BEGIN_MESSAGE_MAP(CEditMap, CEditMapBase)
    //{{AFX_MSG_MAP(CEditMapBase)
    ON_EN_CHANGE(IDC_EXTENSION, OnExtChanged)
    ON_BN_CLICKED(IDC_HELPBTN, OnHelp)
    ON_BN_CLICKED(IDC_ALL_VERBS, OnVerbs)
    ON_BN_CLICKED(IDC_LIMIT_VERBS, OnVerbs)
    ON_EN_CHANGE(IDC_VERBS, OnVerbsChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void
CEditMap::OnExtChanged()
{
    SetControlsState();
}

void
CEditMap::OnVerbs()
{
    SetControlsState();
}

void
CEditMap::OnVerbsChanged()
{
    SetControlsState();
}

void
CEditMap::OnHelp()
{
    ::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, CEditMap::IDD + WINHELP_NUMBER_BASE);
}

BEGIN_MESSAGE_MAP(CEditStarMap, CEditMapBase)
    ON_BN_CLICKED(IDC_HELPBTN, OnHelp)
END_MESSAGE_MAP()

void
CEditStarMap::OnHelp()
{
    ::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, CEditStarMap::IDD + WINHELP_NUMBER_BASE);
}

///=====================

BOOL
CAppMappingPage::OnInitDialog()
{
    BOOL bres = CAppMappingPageBase::OnInitDialog();

    DWORD dwStyle = m_list_exe.GetExtendedStyle();
    m_list_exe.SetExtendedStyle(
        dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);
    RECT rc;
    m_list_exe.GetClientRect(&rc);
    CString buf;
    buf.LoadString(IDS_EXECUTABLE_PATH);
    VERIFY(-1 != m_list_exe.InsertColumn(0, buf, LVCFMT_LEFT, rc.right - rc.left));

    POSITION pos = m_strlMappings.GetHeadPosition();
    int idx = 0;
    while (pos != NULL)
    {
        buf = m_strlMappings.GetNext(pos);
		Mapping * p = new Mapping(buf);
		if (p == NULL)
			break;
		if (StrCmp(p->ext, _T("*")) == 0)
		{
	        VERIFY(-1 != m_list_exe.InsertItem(idx, p->path));
	        VERIFY(m_list_exe.SetItemData(idx, (LPARAM)p));
	        idx++;
		}
		else
		{
			delete p;
		}
    }

    if (idx > 0)
    {
		m_list_exe.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    SetControlsState();

    return bres;
}

void
CAppMappingPage::DoDataExchange(CDataExchange * pDX)
{
	CAppMappingPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAppMappingPageBase)
	DDX_Check(pDX, IDC_CACHE_ISAPI, m_CacheISAPI);
	DDX_Control(pDX, IDC_LIST_EXE, m_list_exe);
	//}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate)
    {
        int count = m_list_exe.GetItemCount();
        for (int i = 0; i < count; i++)
        {
            Mapping * p = (Mapping *)m_list_exe.GetItemData(i);
	        CString buf;
            p->ToString(buf);
		    m_strlMappings.AddTail(buf);
        }
    }
}

void
CAppMappingPage::SetControlsState()
{
    CAppMappingPageBase::SetControlsState();
    int count = m_list_exe.GetItemCount();
    int sel_count = m_list_exe.GetSelectedCount();
    int sel = m_list_exe.GetNextItem(-1, LVNI_SELECTED);
    BOOL bEnableUp = sel > 0 && sel_count == 1;
    BOOL bEnableDown = sel >= 0 && sel_count == 1 && sel < count - 1;
    ::EnableWindow(CONTROL_HWND(IDC_EDIT_EXE), sel_count == 1);
    ::EnableWindow(CONTROL_HWND(IDC_REMOVE_EXE), sel_count > 0);
    ::EnableWindow(CONTROL_HWND(IDC_MOVE_UP), bEnableUp);
    ::EnableWindow(CONTROL_HWND(IDC_MOVE_DOWN), bEnableDown);
}

void 
CAppMappingPage::MoveItem(CListCtrl& lst, int from, int to)
{
    Mapping * pFrom = (Mapping *)lst.GetItemData(from);
    Mapping * pTo = (Mapping *)lst.GetItemData(to);
    lst.SetItemText(from, 0, pTo->path);
    lst.SetItemData(from, (DWORD_PTR)pTo);
    lst.SetItemState(from, 0, LVIS_SELECTED | LVIS_FOCUSED);
    lst.SetItemText(to, 0, pFrom->path);
    lst.SetItemData(to, (DWORD_PTR)pFrom);
    lst.SetItemState(to, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
}


BOOL 
CAppMappingPage::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	ASSERT(pResult != NULL);
	NMHDR* pNMHDR = (NMHDR*)lParam;
    // We are looking only for events from the starmaps listview control here.
    // This is the only way to catch notification, MFC screens
    // all this stuff out.
    if (pNMHDR->idFrom == IDC_LIST_EXE)
    {
        BOOL processed = FALSE;
	    switch (pNMHDR->code)
        {
        case NM_DBLCLK:
            processed = OnDblClickListExe(pNMHDR, pResult);
            break;
        case LVN_ITEMCHANGED:
            processed = OnItemChangedExe(pNMHDR, pResult);
            break;
        case LVN_KEYDOWN:
            processed = OnKeyDownExe(pNMHDR, pResult);
            break;
        default:
            break;
        }
        if (processed)
            return TRUE;
    }
    return CAppMappingPageBase::OnNotify(wParam, lParam, pResult);
}

BEGIN_MESSAGE_MAP(CAppMappingPage, CAppMappingPageBase)
    ON_BN_CLICKED(IDC_INSERT, OnInsert)
    ON_BN_CLICKED(IDC_EDIT_EXE, OnEditExe)
    ON_BN_CLICKED(IDC_REMOVE_EXE, OnRemoveExe)
    ON_BN_CLICKED(IDC_MOVE_UP, OnMoveUp)
    ON_BN_CLICKED(IDC_MOVE_DOWN, OnMoveDown)
END_MESSAGE_MAP()

void
CAppMappingPage::OnInsert()
{
	CEditStarMap dlg(this);
	dlg.m_new = TRUE;
	dlg.m_flags = MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
    dlg.m_pMaps = &m_list_exe;
	dlg.m_bIsLocal = GetSheet()->IsLocal();
	if (dlg.DoModal() == IDOK)
	{
		CString all_verbs;
		VERIFY(all_verbs.LoadString(IDS_ALL));
		Mapping * pmap = new Mapping;
		pmap->ext = _T("*");
		pmap->path = dlg.m_exec;
		pmap->verbs = all_verbs;
		pmap->flags = dlg.m_flags;
		int count = m_list_exe.GetItemCount();
		VERIFY(-1 != m_list_exe.InsertItem(count, pmap->path));
        m_list_exe.SetItemData(count, (DWORD_PTR)pmap);
		// Now unselect all items and select the new one
		for (int i = 0; i < count; i++)
		{
			m_list_exe.SetItemState(i, 0, LVIS_SELECTED | LVIS_FOCUSED);
		}
		m_list_exe.SetItemState(count, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        SetModified(TRUE);
        SetControlsState();
	}
}

void
CAppMappingPage::OnRemoveExe()
{
    if (IDYES == AfxMessageBox(IDS_CONFIRM_REMOVE_MAP, MB_YESNO))
    {
        RemoveSelected(m_list_exe);
        SetModified(TRUE);
        SetControlsState();
		::SetFocus(CONTROL_HWND(m_list_exe.GetItemCount() <= 0 ? IDC_INSERT : IDC_REMOVE_EXE));
    }
}

void
CAppMappingPage::OnEditExe()
{
    int idx = m_list_exe.GetNextItem(-1, LVNI_SELECTED);
    if (idx != -1)
    {
	    CEditStarMap dlg(this);
	    dlg.m_new = FALSE;
        dlg.m_pMaps = &m_list_exe;
	    dlg.m_bIsLocal = GetSheet()->IsLocal();
        Mapping * p = (Mapping *)m_list_exe.GetItemData(idx);
        ASSERT(p != NULL);
        dlg.m_exec = p->path;
        dlg.m_flags = p->flags;
	    if (dlg.DoModal() == IDOK)
	    {
		    p->path = dlg.m_exec;
		    p->flags = dlg.m_flags;
		    VERIFY(m_list_exe.SetItemText(idx, 0, dlg.m_exec));
            SetModified(TRUE);
	    }
    }
}

void
CAppMappingPage::OnMoveUp()
{
    int from = m_list_exe.GetNextItem(-1, LVNI_SELECTED);
    MoveItem(m_list_exe, from, from - 1);
    SetControlsState();
    SetModified(TRUE);
    ::SetFocus(CONTROL_HWND(
        ::IsWindowEnabled(CONTROL_HWND(IDC_MOVE_UP)) ? IDC_MOVE_UP : IDC_MOVE_DOWN));
}

void
CAppMappingPage::OnMoveDown()
{
    int from = m_list_exe.GetNextItem(-1, LVNI_SELECTED);
    MoveItem(m_list_exe, from, from + 1);
    SetControlsState();
    SetModified(TRUE);
    ::SetFocus(CONTROL_HWND(
        ::IsWindowEnabled(CONTROL_HWND(IDC_MOVE_DOWN)) ? IDC_MOVE_DOWN : IDC_MOVE_UP));
}

BOOL
CAppMappingPage::OnDblClickListExe(NMHDR* pNMHDR, LRESULT* pResult)
{
    if (m_list_exe.GetItemCount() > 0)
    {
        OnEditExe();
    }
    *pResult = TRUE;
    return *pResult;
}

BOOL
CAppMappingPage::OnItemChangedExe(NMHDR* pNMHDR, LRESULT* pResult)
{
    SetControlsState();
    *pResult = TRUE;
    return *pResult;
}

BOOL
CAppMappingPage::OnKeyDownExe(NMHDR* pNMHDR, LRESULT* pResult)
{
    NMLVKEYDOWN * pKD = (NMLVKEYDOWN *)pNMHDR;
    if (pKD->wVKey == VK_DOWN)
    {
        short state = GetKeyState(VK_CONTROL);
        if ((0x8000 & state) != 0)
        {
            if (::IsWindowEnabled(CONTROL_HWND(IDC_MOVE_DOWN)))
            {
                OnMoveDown();
                *pResult = TRUE;
            }
        }
    }
    else if (pKD->wVKey == VK_UP)
    {
        short state = GetKeyState(VK_CONTROL);
        if ((0x8000 & state) != 0)
        {
            if (::IsWindowEnabled(CONTROL_HWND(IDC_MOVE_UP)))
            {
                OnMoveUp();
                *pResult = TRUE;
            }
        }
    }
    else if (pKD->wVKey == VK_DELETE)
    {
        if (::IsWindowEnabled(CONTROL_HWND(IDC_REMOVE_EXE)))
        {
            OnRemoveExe();
            *pResult = TRUE;
        }
    }
    else if (pKD->wVKey == VK_INSERT)
    {
        OnInsert();
        *pResult = TRUE;
    }
    else if (pKD->wVKey == VK_RETURN)
    {
        short state = GetKeyState(VK_MENU);
        if ((0x8000 & state) != 0)
        {
            if (::IsWindowEnabled(CONTROL_HWND(IDC_EDIT_EXE)))
            {
                OnEditExe();
                *pResult = TRUE;
            }
        }
    }
    else
    {
        *pResult = FALSE;
    }
    return *pResult;
}

//////////////////////////

BEGIN_MESSAGE_MAP(CAppMappingPage_iis5, CAppMappingPageBase)
END_MESSAGE_MAP()

//////////////////////////

CAppCacheBase::CAppCacheBase(DWORD id, CInetPropertySheet * pSheet)
	: CInetPropertyPage(id, pSheet)
{
}

CAppCacheBase::~CAppCacheBase()
{
}

BOOL
CAppCacheBase::OnInitDialog()
{
    UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};
    CInetPropertyPage::OnInitDialog();
    SETUP_SPIN(m_ScriptEngCacheMaxSpin, 0, 2000000000, m_ScriptEngCacheMax);
    return FALSE;
}

void
CAppCacheBase::DoDataExchange(CDataExchange * pDX)
{
	CInetPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAppCache)
    if (pDX->m_bSaveAndValidate)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
        DDV_MinMaxBalloon(pDX, IDC_ENGINES, SCRIPT_ENG_MIN, SCRIPT_ENG_MAX);
    }
	DDX_TextBalloon(pDX, IDC_ENGINES, m_ScriptEngCacheMax);
    DDX_Control(pDX, IDC_ENG_CACHED_SPIN, m_ScriptEngCacheMaxSpin);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppCacheBase, CInetPropertyPage)
    ON_EN_CHANGE(IDC_ENGINES, OnItemChanged)
END_MESSAGE_MAP()

void
CAppCacheBase::SetControlsState()
{
    ((CButton *)GetDlgItem(IDC_NO_CACHE))->SetCheck(m_NoCache ? BST_CHECKED : BST_UNCHECKED);
    ((CButton *)GetDlgItem(IDC_UNLIMITED_CACHE))->SetCheck(m_UnlimCache ? BST_CHECKED : BST_UNCHECKED);
    ((CButton *)GetDlgItem(IDC_LIMITED_CACHE))->SetCheck(m_LimCache ? BST_CHECKED : BST_UNCHECKED);
}

void
CAppCacheBase::OnItemChanged()
{
    SetControlsState();
    SetModified(TRUE);
}

///////////////////////////////////////////

CAppCache::CAppCache(CInetPropertySheet * pSheet) : CAppCacheBase(CAppCache::IDD, pSheet)
{
}

CAppCache::~CAppCache()
{
}

HRESULT
CAppCache::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPropSheet)
      FETCH_INST_DATA_FROM_SHEET(m_ScriptEngCacheMax);
      FETCH_INST_DATA_FROM_SHEET(m_NoCache);
      FETCH_INST_DATA_FROM_SHEET(m_LimCache);
      FETCH_INST_DATA_FROM_SHEET(m_UnlimCache);
      FETCH_INST_DATA_FROM_SHEET(m_LimDiskCache);
      FETCH_INST_DATA_FROM_SHEET(m_LimCacheMemSize);
      FETCH_INST_DATA_FROM_SHEET(m_LimCacheDiskSize);
      FETCH_INST_DATA_FROM_SHEET(m_DiskCacheDir);
   END_META_INST_READ(err)

   return err;
}

HRESULT
CAppCache::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPropSheet)
      STORE_INST_DATA_ON_SHEET(m_ScriptEngCacheMax)
      STORE_INST_DATA_ON_SHEET(m_NoCache);
      STORE_INST_DATA_ON_SHEET(m_LimCache);
      STORE_INST_DATA_ON_SHEET(m_UnlimCache);
      STORE_INST_DATA_ON_SHEET(m_LimDiskCache);
      STORE_INST_DATA_ON_SHEET(m_LimCacheMemSize);
      STORE_INST_DATA_ON_SHEET(m_LimCacheDiskSize);
      STORE_INST_DATA_ON_SHEET(m_DiskCacheDir);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppCache::DoDataExchange(CDataExchange * pDX)
{
	CAppCacheBase::DoDataExchange(pDX);
	
    if (pDX->m_bSaveAndValidate)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
	    DDV_MinMaxBalloon(pDX, IDC_CACHE_SIZE_EDIT, 0, 2000000000);
    }
	DDX_TextBalloon(pDX, IDC_CACHE_SIZE_EDIT, m_LimCacheMemSize);

    if (pDX->m_bSaveAndValidate)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
	    DDV_MinMaxBalloon(pDX, IDC_DISK_UNLIM_EDIT, 0, 2000000000);
    }
	DDX_TextBalloon(pDX, IDC_DISK_UNLIM_EDIT, m_LimCacheDiskSize);

	DDX_Text(pDX, IDC_CACHE_PATH, m_DiskCacheDir);
    DDV_FolderPath(pDX, m_DiskCacheDir, GetSheet()->IsLocal());
    DDX_Control(pDX, IDC_CACHE_SIZE_SPIN, m_LimCacheMemSizeSpin);
    DDX_Control(pDX, IDC_DISK_UNLIM_SPIN, m_LimCacheDiskSizeSpin);
}

void
CAppCache::SetControlsState()
{
    CAppCacheBase::SetControlsState();
    // Edit control left to limited cache button
    ::EnableWindow(CONTROL_HWND(IDC_CACHE_SIZE_EDIT), m_LimCache);
    ::EnableWindow(CONTROL_HWND(IDC_CACHE_SIZE_SPIN), m_LimCache);
    // Two radio buttons under limited cache button
    ::EnableWindow(CONTROL_HWND(IDC_CACHE_UNLIMITED_DISK), m_LimCache);
    ::EnableWindow(CONTROL_HWND(IDC_CACHE_LIMITED_DISK), m_LimCache);
    // Edit control for limited disk cache button
    ::EnableWindow(CONTROL_HWND(IDC_DISK_UNLIM_EDIT), m_LimCache && m_LimDiskCache);
    ::EnableWindow(CONTROL_HWND(IDC_DISK_UNLIM_SPIN), m_LimCache && m_LimDiskCache);
}

BOOL
CAppCache::OnInitDialog()
{
    UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};
    CAppCacheBase::OnInitDialog();
    ((CButton *)GetDlgItem(IDC_CACHE_UNLIMITED_DISK))->SetCheck(!m_LimDiskCache ? BST_CHECKED : BST_UNCHECKED);
    ((CButton *)GetDlgItem(IDC_CACHE_LIMITED_DISK))->SetCheck(m_LimDiskCache ? BST_CHECKED : BST_UNCHECKED);
    ::EnableWindow(CONTROL_HWND(IDC_BROWSE), GetSheet()->IsLocal());
    SETUP_SPIN(m_LimCacheMemSizeSpin, 0, 2000000000, m_LimCacheMemSize);
    SETUP_SPIN(m_LimCacheDiskSizeSpin, 0, 2000000000, m_LimCacheDiskSize);
    SetControlsState();
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_CACHE_PATH),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_CACHE_PATH),FALSE);
#endif
    return FALSE;
}

BEGIN_MESSAGE_MAP(CAppCache, CAppCacheBase)
    ON_BN_CLICKED(IDC_NO_CACHE, OnNoCache)
    ON_BN_CLICKED(IDC_UNLIMITED_CACHE, OnUnlimitedCache)
    ON_BN_CLICKED(IDC_LIMITED_CACHE, OnLimitedCache)
    ON_BN_CLICKED(IDC_CACHE_UNLIMITED_DISK, OnUnlimitedDiskCache)
    ON_BN_CLICKED(IDC_CACHE_LIMITED_DISK, OnLimitedDiskCache)
    ON_EN_CHANGE(IDC_CACHE_PATH, OnItemChanged)
    ON_EN_CHANGE(IDC_DISK_UNLIM_EDIT, OnItemChanged)
    ON_EN_CHANGE(IDC_CACHE_SIZE_EDIT, OnItemChanged)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
END_MESSAGE_MAP()

//void
//CAppCache::OnItemChanged()
//{
//    SetControlsState();
//    SetModified(TRUE);
//}
//

void
CAppCache::OnNoCache()
{
    m_NoCache = TRUE;
    m_UnlimCache = FALSE;
    m_LimCache = FALSE;
    SetControlsState();
    SetModified(TRUE);
}

void
CAppCache::OnUnlimitedCache()
{
    m_NoCache = FALSE;
    m_UnlimCache = TRUE;
    m_LimCache = FALSE;
    SetControlsState();
    SetModified(TRUE);
}

void
CAppCache::OnLimitedCache()
{
    m_NoCache = FALSE;
    m_UnlimCache = FALSE;
    m_LimCache = TRUE;
    SetControlsState();
    SetModified(TRUE);
}

void
CAppCache::OnLimitedDiskCache()
{
    m_LimDiskCache = TRUE;
    SetControlsState();
    SetModified(TRUE);
}
void
CAppCache::OnUnlimitedDiskCache()
{
    m_LimDiskCache = FALSE;
    SetControlsState();
    SetModified(TRUE);
}

static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CAppCache * pThis = (CAppCache *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CAppCache::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

void
CAppCache::OnBrowse() 
{
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   GetDlgItem(IDC_CACHE_PATH)->GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH] = {0};
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
       
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       GetDlgItem(IDC_CACHE_PATH)->SetWindowText(str);
       SetModified(TRUE);
       SetControlsState();
   }
}

////////////////////////////////////////////

CAppCache_iis5::CAppCache_iis5(CInetPropertySheet * pSheet) : CAppCacheBase(CAppCache_iis5::IDD, pSheet)
{
}

CAppCache_iis5::~CAppCache_iis5()
{
}

HRESULT
CAppCache_iis5::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPropSheet)
      FETCH_INST_DATA_FROM_SHEET(m_ScriptEngCacheMax);
      FETCH_INST_DATA_FROM_SHEET(m_NoCache);
      FETCH_INST_DATA_FROM_SHEET(m_LimCache);
      FETCH_INST_DATA_FROM_SHEET(m_UnlimCache);
      FETCH_INST_DATA_FROM_SHEET(m_AspScriptFileCacheSize);
   END_META_INST_READ(err)

   return err;
}

HRESULT
CAppCache_iis5::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPropSheet)
      STORE_INST_DATA_ON_SHEET(m_ScriptEngCacheMax)
      STORE_INST_DATA_ON_SHEET(m_NoCache);
      STORE_INST_DATA_ON_SHEET(m_LimCache);
      STORE_INST_DATA_ON_SHEET(m_UnlimCache);
      STORE_INST_DATA_ON_SHEET(m_AspScriptFileCacheSize);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppCache_iis5::DoDataExchange(CDataExchange * pDX)
{
	CAppCacheBase::DoDataExchange(pDX);
    if (m_LimCache)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
		DDV_MinMaxBalloon(pDX, IDC_CACHE_SIZE_EDIT, 0, 2000000000);
	    DDX_TextBalloon(pDX, IDC_CACHE_SIZE_EDIT, m_AspScriptFileCacheSize);
    }
    DDX_Control(pDX, IDC_CACHE_SIZE_SPIN, m_AspScriptFileCacheSizeSpin);
}

void
CAppCache_iis5::SetControlsState()
{
    CAppCacheBase::SetControlsState();
    // Edit control left to limited cache button
    ::EnableWindow(CONTROL_HWND(IDC_CACHE_SIZE_EDIT), m_LimCache);
    ::EnableWindow(CONTROL_HWND(IDC_CACHE_SIZE_SPIN), m_LimCache);
}

BOOL
CAppCache_iis5::OnInitDialog()
{
    UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};
    CAppCacheBase::OnInitDialog();
    if (!m_LimCache)
    {
        SetDlgItemInt(IDC_CACHE_SIZE_EDIT, 250, FALSE);
    }
    SETUP_SPIN(m_AspScriptFileCacheSizeSpin, 0, 2000000000, m_AspScriptFileCacheSize);
    SetControlsState();
    return FALSE;
}

BEGIN_MESSAGE_MAP(CAppCache_iis5, CAppCacheBase)
    ON_BN_CLICKED(IDC_NO_CACHE, OnNoCache)
    ON_BN_CLICKED(IDC_UNLIMITED_CACHE, OnUnlimitedCache)
    ON_BN_CLICKED(IDC_LIMITED_CACHE, OnLimitedCache)
    ON_EN_CHANGE(IDC_CACHE_SIZE_EDIT, OnItemChanged)
END_MESSAGE_MAP()

void
CAppCache_iis5::OnItemChanged()
{
    SetControlsState();
    SetModified(TRUE);
}


void
CAppCache_iis5::OnNoCache()
{
    m_NoCache = TRUE;
    m_UnlimCache = FALSE;
    m_LimCache = FALSE;
    SetControlsState();
    SetModified(TRUE);
}

void
CAppCache_iis5::OnUnlimitedCache()
{
    m_NoCache = FALSE;
    m_UnlimCache = TRUE;
    m_LimCache = FALSE;
    SetControlsState();
    SetModified(TRUE);
}

void
CAppCache_iis5::OnLimitedCache()
{
    m_NoCache = FALSE;
    m_UnlimCache = FALSE;
    m_LimCache = TRUE;
    SetControlsState();
    SetModified(TRUE);
}

////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAspDebug, CInetPropertyPage)

CAspDebug::CAspDebug(CInetPropertySheet * pSheet)
	: CInetPropertyPage(CAspDebug::IDD, pSheet)
{
#if 0
	// hack to have new struct size with old MFC and new NT 5.0 headers
	ZeroMemory(&m_psp_ex, sizeof(PROPSHEETPAGE));
	memcpy(&m_psp_ex, &m_psp, m_psp.dwSize);
	m_psp_ex.dwSize = sizeof(PROPSHEETPAGE);
#endif
}

CAspDebug::~CAspDebug()
{
}

HRESULT
CAspDebug::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPropSheet)
      FETCH_INST_DATA_FROM_SHEET(m_ServerDebug);
      FETCH_INST_DATA_FROM_SHEET(m_ClientDebug);
      FETCH_INST_DATA_FROM_SHEET(m_SendAspError);
      FETCH_INST_DATA_FROM_SHEET(m_DefaultError);
   END_META_INST_READ(err)

   return err;
}

/* virtual */
HRESULT
CAspDebug::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPropSheet)
      STORE_INST_DATA_ON_SHEET(m_ServerDebug);
      STORE_INST_DATA_ON_SHEET(m_ClientDebug);
      STORE_INST_DATA_ON_SHEET(m_SendAspError);
      STORE_INST_DATA_ON_SHEET(m_DefaultError);
   END_META_INST_WRITE(err)

   return err;
}

void
CAspDebug::DoDataExchange(CDataExchange * pDX)
{
	CInetPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAspMainPage)
	DDX_Check(pDX, IDC_SERVER_DEBUG, m_ServerDebug);
	DDX_Check(pDX, IDC_CLIENT_DEBUG, m_ClientDebug);
	DDX_Text(pDX, IDC_DEFAULT_ERROR, m_DefaultError);
	//}}AFX_DATA_MAP
}

//////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CAspDebug, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAspDebug)
    ON_BN_CLICKED(IDC_SERVER_DEBUG, OnItemChanged)
    ON_BN_CLICKED(IDC_CLIENT_DEBUG, OnItemChanged)
    ON_BN_CLICKED(IDC_SEND_DETAILED_ERROR, OnChangedError)
    ON_BN_CLICKED(IDC_SEND_DEF_ERROR, OnChangedError)
    ON_EN_CHANGE(IDC_DEFAULT_ERROR, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAspDebug::OnInitDialog()
{
	CInetPropertyPage::OnInitDialog();

    ((CButton *)GetDlgItem(
        m_SendAspError ? IDC_SEND_DETAILED_ERROR : IDC_SEND_DEF_ERROR))->SetCheck(BST_CHECKED);
    ::EnableWindow(CONTROL_HWND(IDC_DEFAULT_ERROR), !m_SendAspError);

	return FALSE;
}

void
CAspDebug::OnItemChanged()
{
    SetModified(TRUE);
}

void
CAspDebug::OnChangedError()
{
    m_SendAspError = ((CButton *)GetDlgItem(IDC_SEND_DETAILED_ERROR))->GetCheck() == BST_CHECKED;
    ::EnableWindow(CONTROL_HWND(IDC_DEFAULT_ERROR), !m_SendAspError);
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\authent.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        authent.cpp

   Abstract:
        WWW Authentication Dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "inetmgrapp.h"
#include "supdlgs.h"
#include "certmap.h"
#include "authent.h"
#define INITGUID
#include <initguid.h>
#include <dsclient.h>
#include <wincrui.h>
#include <Dsgetdc.h>
#include <Lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define HIDD_DOMAINACCTS		0x50334

CAuthenticationDlg::CAuthenticationDlg(
    IN LPCTSTR lpstrServerName, 
    IN DWORD   dwInstance,      
    IN CString & strBasicDomain,
    IN CString & strRealm,
    IN DWORD & dwAuthFlags,
    IN DWORD & dwAccessPermissions,
    IN CString & strUserName,
    IN CStrPassword & strPassword,
    IN BOOL & fPasswordSync,
    IN BOOL fAdminAccess,
    IN BOOL fHasDigest,
    IN CWnd * pParent           OPTIONAL
    )
/*++

Routine Description:

    Authentication dialog constructor

Arguments:

    LPCTSTR lpstrServerName     : Server name
    DWORD   dwInstance          : Instance number
    CString & strBasicDomain    : Basic domain name
    DWORD & dwAuthFlags         : Authorization flags
    DWORD & dwAccessPermissions : Access permissions
    CString & strUserName       : Anonymous user name
    CStrPassword & strPassword  : Anonymous user pwd
    BOOL & fPasswordSync        : Password sync setting
    BOOL fAdminAccess           : TRUE if user has admin access
    BOOL fHasDigest             : TRUE if machine supports digest auth.
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CAuthenticationDlg::IDD, pParent),
      m_strServerName(lpstrServerName),
      m_strBasicDomain(strBasicDomain),
      m_strRealm(strRealm),
      m_strUserName(strUserName),
      m_strPassword(strPassword),
      m_dwInstance(dwInstance),
      m_dwAuthFlags(dwAuthFlags),
      m_dwAccessPermissions(dwAccessPermissions),
      m_fAdminAccess(fAdminAccess),
      m_fHasDigest(fHasDigest),
      m_fPasswordSync(fPasswordSync),
      m_fPasswordSyncChanged(FALSE),
      m_fUserNameChanged(FALSE),
      m_fPasswordSyncMsgShown(FALSE),
      m_fChanged(FALSE),
      m_fInDomain(TRUE),
      m_fHasPassport(TRUE)
{
#if 0 // Class Wizard happy
    //{{AFX_DATA_INIT(CAuthenticationDlg)
    m_fClearText = FALSE;
    m_fDigest = FALSE;
    m_fChallengeResponse = FALSE;
    m_fAnonymous = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

    m_fClearText = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_BASIC);
    m_fDigest = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_MD5);
    m_fChallengeResponse = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_NT);
    m_fAnonymous = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_ANONYMOUS);
    m_fPassport = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_PASSPORT);
}


void 
CAuthenticationDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
	if (pDX->m_bSaveAndValidate && !m_fChanged)
    {
       return;
    }
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAuthenticationDlg)
    DDX_Control(pDX, IDC_CHECK_ANONYMOUS, m_check_Anonymous);
    DDX_Check(pDX, IDC_CHECK_ANONYMOUS, m_fAnonymous);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Check(pDX, IDC_CHECK_CLEAR_TEXT, m_fClearText);
    DDX_Check(pDX, IDC_CHECK_DIGEST, m_fDigest);
    DDX_Check(pDX, IDC_CHECK_NT_CHALLENGE_RESPONSE, m_fChallengeResponse);
    DDX_Check(pDX, IDC_PASSPORT, m_fPassport);
    DDX_Control(pDX, IDC_CHECK_NT_CHALLENGE_RESPONSE, m_check_ChallengeResponse);
    DDX_Control(pDX, IDC_CHECK_DIGEST, m_check_Digest);
    DDX_Control(pDX, IDC_CHECK_CLEAR_TEXT, m_check_ClearText);
    DDX_Control(pDX, IDC_BASDOM, m_edit_BasicDomain);
    DDX_Control(pDX, IDC_BASDOM_SELECT, m_btn_SelectDomain);
    DDX_Control(pDX, IDC_REALM, m_edit_Realm);
    DDX_Control(pDX, IDC_REALM_SELECT, m_btn_SelectRealm);
    DDX_Control(pDX, IDC_PASSPORT, m_chk_Passport);
    //}}AFX_DATA_MAP
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);
    DDX_Text(pDX, IDC_BASDOM, m_strBasicDomain);
    DDX_Text(pDX, IDC_REALM, m_strRealm);
    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_strUserName.TrimLeft();
    while (*m_strUserName == '\\')
    {
        m_strUserName = m_strUserName.Mid(2);
    }

    //
    // Display the remote password sync message if
    // password sync is on, the account is not local,
    // password sync has changed or username has changed
    // and the message hasn't already be shown.
    //
	if (pDX->m_bSaveAndValidate)
	{
		BOOL bLocal;
		CString user, domain;
		CError err = CredUIParseUserName(
				m_strUserName, 
				user.GetBuffer(CRED_MAX_USERNAME_LENGTH), CRED_MAX_USERNAME_LENGTH,
				domain.GetBuffer(MAX_PATH), MAX_PATH);
		user.ReleaseBuffer();
		domain.ReleaseBuffer();
		bLocal = domain.IsEmpty() || domain.CompareNoCase(m_strServerName) == 0;
		if (m_dwVersionMajor < 6)
		{
			if (m_fPasswordSync && !bLocal 
				&& (m_fPasswordSyncChanged || m_fUserNameChanged)
				&& !m_fPasswordSyncMsgShown
				)
			{
				//
				// Don't show it again
				//
				m_fPasswordSyncMsgShown = TRUE;
				if (IDYES != ::AfxMessageBox(IDS_WRN_PWSYNC, MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION ))
				{
					pDX->Fail();
				}
			}
		}

        // See if we need to get the new password...
        if (m_fAnonymous)
        {
            // only save password/and ask for password confirmation
            // if anonymous is enabled.
            DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
        }

		// Convert to standard domain\user format
		if (!bLocal)
		{
			m_strUserName = domain;
			m_strUserName += _T('\\');
			m_strUserName += user;
		}
	}
	else
	{
        DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
	}

	if (!m_fPasswordSync)
	{
        DDV_MaxCharsBalloon_SecuredString(pDX, m_strPassword, PWLEN);
	}

	if (pDX->m_bSaveAndValidate)
	{
		m_fChanged = FALSE;
	}

    //CString csTempPassword;m_strPassword.CopyTo(csTempPassword);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CAuthenticationDlg, CDialog)
    //{{AFX_MSG_MAP(CAuthenticationDlg)
    ON_BN_CLICKED(IDC_CHECK_ANONYMOUS, OnCheckAnonymous)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_CHECK_CLEAR_TEXT, OnCheckClearText)
    ON_BN_CLICKED(IDC_CHECK_DIGEST, OnCheckDigest)
    ON_BN_CLICKED(IDC_CHECK_NT_CHALLENGE_RESPONSE, OnItemChanged)
    ON_BN_CLICKED(IDC_BASDOM_SELECT, OnButtonSelectDomain)
    ON_BN_CLICKED(IDC_REALM_SELECT, OnButtonSelectRealm)
    ON_BN_CLICKED(IDC_PASSPORT, OnCheckPassport)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_BASDOM, OnItemChanged)
    ON_EN_CHANGE(IDC_REALM, OnItemChanged)
END_MESSAGE_MAP()

void
CAuthenticationDlg::OnItemChanged()
{
	m_fChanged = TRUE;
}

void
CAuthenticationDlg::SetControlStates()
/*++

Routine Description:
    Set control states depending on current data in the dialog

--*/
{
    m_edit_UserName.EnableWindow(m_fAnonymous);
    GetDlgItem(IDC_BUTTON_BROWSE_USERS)->EnableWindow(m_fAnonymous);
    m_chk_PasswordSync.EnableWindow(m_dwVersionMajor < 6 && m_fAnonymous);
	m_edit_Password.EnableWindow((m_dwVersionMajor >= 6 || !m_fPasswordSync) && m_fAnonymous);
    // Windows
    m_check_ChallengeResponse.EnableWindow(!m_fPassport);
    // Basic
    m_check_ClearText.EnableWindow(!m_fPassport);
    // Digest
    m_check_Digest.EnableWindow(m_fHasDigest && !m_fPassport);
    // disable both domain fields if nothing is selected
    GetDlgItem(IDC_STATIC_DOMAIN)->EnableWindow(FALSE);
    m_edit_BasicDomain.EnableWindow(FALSE);
    m_btn_SelectDomain.EnableWindow(FALSE);
    GetDlgItem(IDC_STATIC_REALM)->EnableWindow(FALSE);
    m_edit_Realm.EnableWindow(FALSE);
    m_btn_SelectRealm.EnableWindow(FALSE);

    if (m_fPassport)
    {
        GetDlgItem(IDC_STATIC_DOMAIN)->EnableWindow(TRUE);
        m_edit_BasicDomain.EnableWindow(TRUE);
        m_btn_SelectDomain.EnableWindow(m_fInDomain);
    }
    else
    {
        if (m_fDigest && !m_fClearText)
        {
            GetDlgItem(IDC_STATIC_REALM)->EnableWindow(TRUE);
            m_edit_Realm.EnableWindow(TRUE);
            m_btn_SelectRealm.EnableWindow(m_fInDomain);
        }
        else if (m_fClearText)
        {
            GetDlgItem(IDC_STATIC_REALM)->EnableWindow(TRUE);
            m_edit_Realm.EnableWindow(TRUE);
            m_btn_SelectRealm.EnableWindow(m_fInDomain);

            GetDlgItem(IDC_STATIC_DOMAIN)->EnableWindow(TRUE);
            m_edit_BasicDomain.EnableWindow(TRUE);
            m_btn_SelectDomain.EnableWindow(m_fInDomain);
        }
    }
}

BOOL 
CAuthenticationDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
    // Check if computer is joined to domain
    COMPUTER_NAME_FORMAT fmt = ComputerNamePhysicalDnsDomain;
    TCHAR buf[MAX_PATH];
    DWORD n = MAX_PATH;
    m_fInDomain = (GetComputerNameEx(fmt, buf, &n) && n > 0);

    SetControlStates();  

    if (m_dwVersionMajor < 6)
    {
		// Show/Hide Passport stuff
        m_chk_Passport.EnableWindow(FALSE);
	}
	else
	{
		// Hide password syncronization
		GetDlgItem(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION)->EnableWindow(FALSE);
		GetDlgItem(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION)->ShowWindow(SW_HIDE);
		m_fPasswordSync = FALSE;
		m_fPasswordSyncChanged = FALSE;
		m_fPasswordSyncMsgShown = TRUE;
    }

    return TRUE;  
}

void 
CAuthenticationDlg::OnButtonBrowseUsers()
{
    CString str;

    if (GetIUsrAccount(m_strServerName, this, str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);
	    CString user, domain;
		CError err = CredUIParseUserName(str, 
			  user.GetBuffer(CRED_MAX_USERNAME_LENGTH), CRED_MAX_USERNAME_LENGTH,
			  domain.GetBuffer(MAX_PATH), MAX_PATH);
		user.ReleaseBuffer();
		domain.ReleaseBuffer();
		if (m_dwVersionMajor < 6)
		{
			m_fPasswordSync = 
				domain.IsEmpty() || domain.CompareNoCase(m_strServerName) == 0;
			m_chk_PasswordSync.SetCheck(m_fPasswordSync);
		}
		if (!m_fPasswordSync)
		{
			m_edit_Password.SetWindowText(_T(""));
			m_edit_Password.SetFocus();
		}
        OnItemChanged();
    }
}

void CAuthenticationDlg::OnButtonSelectDomain()
{
    HRESULT hr = BrowseDomain(m_strBasicDomain);
    if (SUCCEEDED(hr))
    {
        UpdateData(FALSE);
        OnItemChanged();
    }
}

void CAuthenticationDlg::OnButtonSelectRealm()
{
    HRESULT hr = BrowseDomain(m_strRealm);
    if (SUCCEEDED(hr))
    {
        UpdateData(FALSE);
        OnItemChanged();
    }
}

HRESULT
CAuthenticationDlg::BrowseDomain(CString& domain)
{
   CString prev = domain;
   CComPtr<IDsBrowseDomainTree> spDsDomains;

   CError err = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          reinterpret_cast<void **>(&spDsDomains));
   if (err.Succeeded())
   {
      err = spDsDomains->SetComputer(m_strServerName, NULL, NULL); // use default credential
      if (err.Succeeded())
      {
         LPTSTR pDomainPath = NULL;
         err = spDsDomains->BrowseTo(m_hWnd, &pDomainPath, 
            /*DBDTF_RETURNINOUTBOUND |*/ DBDTF_RETURNEXTERNAL | DBDTF_RETURNMIXEDDOMAINS);
         if (err.Succeeded() && pDomainPath != NULL)
         {
            domain = pDomainPath;
            if (domain.CompareNoCase(prev) != 0)
            {
				OnItemChanged();
            }
            CoTaskMemFree(pDomainPath);
         }
// When user click on Cancel in this browser, it returns 80070001 (Incorrect function). 
// I am not quite sure what does it mean. We are filtering out the case when domain browser doesn't
// work at all (in workgroup), so here we could safely skip error processing.
//         else
//         {
//            err.MessageBox();
//         }
      }
   }
   return err;
}

void
CAuthenticationDlg::OnCheckEnablePwSynchronization()
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates();
    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}

void 
CAuthenticationDlg::OnChangeEditUsername() 
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}

void 
CAuthenticationDlg::OnCheckClearText() 
{
    if (m_check_ClearText.GetCheck() == 1)
    {
        CClearTxtDlg dlg;
        if (dlg.DoModal() != IDOK)
        {
            m_check_ClearText.SetCheck(0);
            return;
        }
    }

    m_fClearText = !m_fClearText;
    OnItemChanged();
    SetControlStates();
}



void 
CAuthenticationDlg::OnCheckDigest() 
{
    ASSERT(m_fHasDigest);

    if (m_check_Digest.GetCheck() == 1)
    {
		CString cap, msg;
		msg.LoadString(IDS_WRN_DIGEST);
		cap.LoadString(IDS_APP_NAME);
		if (IDNO == IisMessageBox(m_hWnd, IDS_WRN_DIGEST, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2, HIDD_DOMAINACCTS))
        {
            m_check_Digest.SetCheck(0);
            return;
        }
    }

    m_fDigest = !m_fDigest;
    OnItemChanged();
    SetControlStates();
}



void 
CAuthenticationDlg::OnCheckAnonymous() 
{
    m_fAnonymous = !m_fAnonymous;
    OnItemChanged();
    SetControlStates();
}

void
CAuthenticationDlg::OnCheckPassport()
{
    m_fPassport = !m_fPassport;
    OnItemChanged();
    SetControlStates();
}

void 
CAuthenticationDlg::OnOK() 
{
    if (UpdateData(TRUE))
    {
        SET_FLAG_IF(m_fPassport, m_dwAuthFlags, MD_AUTH_PASSPORT);
        SET_FLAG_IF(m_fClearText, m_dwAuthFlags, MD_AUTH_BASIC);
        SET_FLAG_IF(m_fChallengeResponse, m_dwAuthFlags, MD_AUTH_NT);
        SET_FLAG_IF(m_fAnonymous, m_dwAuthFlags, MD_AUTH_ANONYMOUS);
        SET_FLAG_IF(m_fDigest, m_dwAuthFlags, MD_AUTH_MD5);

        //
        // Provide warning if no authentication is selected
        //
        if (!m_dwAuthFlags 
         && !m_dwAccessPermissions 
         && !NoYesMessageBox(IDS_WRN_NO_AUTH)
           )
        {
            //
            // Don't dismiss the dialog
            //
            return;
        }

        CDialog::OnOK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\authent.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        authent.cpp

   Abstract:
        WWW Authentication Dialog Definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/



class CAuthenticationDlg : public CDialog
{
//
// Construction
//
public:
    CAuthenticationDlg(
        IN LPCTSTR lpstrServerName, // For API name only
        IN DWORD   dwInstance,      // For use in ocx only
        IN CString & strBasicDomain,
        IN CString & strRealm,
        IN DWORD & dwAuthFlags,
        IN DWORD & dwAccessPermissions,
        IN CString & strUserName,
        IN CStrPassword & strPassword,
        IN BOOL & fPasswordSync,
        IN BOOL fAdminAccess,
        IN BOOL fHasDigest,
        IN CWnd * pParent = NULL
        );   

    DWORD m_dwVersionMajor;
    DWORD m_dwVersionMinor;
//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAuthenticationDlg)
    enum { IDD = IDD_AUTHENTICATION };
    CButton m_check_Anonymous;
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CButton m_chk_PasswordSync;
    BOOL    m_fClearText;
    BOOL    m_fDigest;
    BOOL    m_fChallengeResponse;
    BOOL    m_fAnonymous;
    CButton m_check_ChallengeResponse;
    CButton m_check_ClearText;
    CButton m_check_Digest;
    CEdit   m_edit_BasicDomain;
    CButton m_btn_SelectDomain;
    CEdit   m_edit_Realm;
    CButton m_btn_SelectRealm;
    CButton m_chk_Passport;
    BOOL    m_fPassport;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAuthenticationDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CAuthenticationDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnChangeEditUsername();
    virtual void OnOK();
    afx_msg void OnCheckClearText();
    afx_msg void OnCheckAnonymous();
    afx_msg void OnCheckDigest();
    afx_msg void OnButtonSelectDomain();
    afx_msg void OnButtonSelectRealm();
    afx_msg void OnCheckPassport();
    //}}AFX_MSG
    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    HRESULT BrowseDomain(CString& domain);

private:
    BOOL& m_fPasswordSync;
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fAdminAccess;
    BOOL m_fHasDigest;
    BOOL m_fHasPassport;
	BOOL m_fChanged;
    BOOL m_fInDomain;
    DWORD& m_dwAuthFlags;
    DWORD& m_dwAccessPermissions;
    DWORD m_dwInstance;
    CString& m_strBasicDomain;
    CString& m_strRealm;
    CString& m_strUserName;
    BOOL m_fUserNameChanged;
    CStrPassword& m_strPassword;
    CString m_strServerName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\certauth.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

#ifndef __CERTAUTH_H_
#define __CERTAUTH_H_

// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCertAuth wrapper class

class CCertAuth : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertAuth)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0x996ff6f, 0xb6a1, 0x11d0, { 0x92, 0x92, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    short GetBorderStyle();
    void SetBorderStyle(short);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetMachineName(LPCTSTR szMachineName);
    void SetServerInstance(LPCTSTR szServerInstance);
    void DoClick(long dwButtonNumber);
    void AboutBox();
};

#endif // __CERTAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\certwiz.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "certwiz.h"

/////////////////////////////////////////////////////////////////////////////
// CCertWiz

IMPLEMENT_DYNCREATE(CCertWiz, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCertWiz properties

/////////////////////////////////////////////////////////////////////////////
// CCertWiz operations

void CCertWiz::SetMachineName(LPCTSTR MachineName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         MachineName);
}

void CCertWiz::SetServerInstance(LPCTSTR InstanceName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         InstanceName);
}

void CCertWiz::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\certmap.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "certmap.h"

// Dispatch interfaces referenced by this interface
#include "Font.h"

/////////////////////////////////////////////////////////////////////////////
// CCertmap

IMPLEMENT_DYNCREATE(CCertmap, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCertmap properties

COleFont CCertmap::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CCertmap::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

BOOL CCertmap::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CCertmap::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

short CCertmap::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CCertmap::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

CString CCertmap::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CCertmap::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CCertmap operations

void CCertmap::SetServerInstance(LPCTSTR szServerInstance)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szServerInstance);
}

void CCertmap::SetMachineName(LPCTSTR szMachineName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\connects.cpp ===
/*++

   Copyright    (c)    1994-2001   Microsoft Corporation

   Module  Name :
        connects.cpp

   Abstract:
        "Connect to a single server" dialog

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonoc (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "connects.h"
#include "objpick.h"



#define MAX_SERVERNAME_LEN (255)

const LPCTSTR g_cszInetSTPBasePath_ = _T("Software\\Microsoft\\InetStp");
const LPCTSTR g_cszMajorVersion_	   = _T("MajorVersion");


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


extern CInetmgrApp theApp;

//
// CLoginDlg Dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CLoginDlg::CLoginDlg(
    IN int nType,               
    IN CIISMachine * pMachine,
    IN CWnd * pParent           OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    int nType               : Type of dialog to bring up:

                              LDLG_ACCESS_DENIED    - Access Denied dlg
                              LDLG_ENTER_PASS       - Enter password dlg
                              LDLG_IMPERSONATION    - Impersonation dlg

    CIISMachine * pMachine  : Machine object
    CWnd * pParent          : Parent window
    
Return Value:

--*/
    : CDialog(CLoginDlg::IDD, pParent),
      m_nType(nType),
      m_strOriginalUserName(),
      m_strUserName(),
      m_strPassword(),
      m_pMachine(pMachine)
{
#if 0 // Keep Classwizard happy

    //{{AFX_DATA_INIT(CLoginDlg)
    m_strPassword = _T("");
    m_strUserName = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    ASSERT_PTR(m_pMachine);
}



void 
CLoginDlg::DoDataExchange(
    IN OUT CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:
    
    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CLoginDlg)
    DDX_Text(pDX, IDC_EDIT_USER_NAME, m_strUserName);
    //DDX_Text(pDX, IDC_EDIT_PASSWORD2, m_strPassword);
    DDX_Text_SecuredString(pDX, IDC_EDIT_PASSWORD2, m_strPassword);
    //DDV_MaxCharsBalloon(pDX, m_strPassword, PWLEN);
    DDV_MaxCharsBalloon_SecuredString(pDX, m_strPassword, PWLEN);
    DDX_Control(pDX, IDC_EDIT_USER_NAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD2, m_edit_Password);
    DDX_Control(pDX, IDC_STATIC_PROMPT2, m_static_Prompt);
    DDX_Control(pDX, IDOK, m_button_Ok);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CLoginDlg, CDialog)
    //{{AFX_MSG_MAP(CLoginDlg)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_USER_NAME, SetControlStates)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CLoginDlg::SetControlStates()
/*++

Routine Description:

    Set UI control enabled/disabled states

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(m_edit_UserName.GetWindowTextLength() > 0);
}



BOOL 
CLoginDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    CString str;

    switch(m_nType)
    {
    case LDLG_ENTER_PASS:
        //
        // Change text for the "Enter Password" dialog
        //
        VERIFY(str.LoadString(IDS_ENTER_PASSWORD));
        SetWindowText(str);

        str.Format(IDS_RESOLVE_PASSWORD, m_pMachine->QueryServerName());
        m_static_Prompt.SetWindowText(str);

        //
        // Fall through
        //

    case LDLG_ACCESS_DENIED:
        //
        // This is the default text on the dialog
        //
        m_strUserName = m_strOriginalUserName = m_pMachine->QueryUserName();

        if (!m_strUserName.IsEmpty())
        {
            m_edit_UserName.SetWindowText(m_strUserName);
            m_edit_Password.SetFocus();
        }
        else
        {
            m_edit_UserName.SetFocus();
        }
        break;

    case LDLG_IMPERSONATION:
        VERIFY(str.LoadString(IDS_IMPERSONATION));
        SetWindowText(str);
       
        str.Format(IDS_IMPERSONATION_PROMPT, m_pMachine->QueryServerName());
        m_static_Prompt.SetWindowText(str);
        m_edit_UserName.SetFocus();
        break;

    default:
        ASSERT_MSG("Invalid dialog type");
    }

    SetControlStates();
    
    return FALSE;  
}



void 
CLoginDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Attempt to connect to the machine specified.  If 
    machiname is ok, dismiss the dialog.  Otherwise put up an error message
    and stay active.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT_PTR(m_pMachine);

    if (UpdateData(TRUE))
    {
        CString csTempPassword;
        m_strPassword.CopyTo(csTempPassword);
        CError err(m_pMachine->Impersonate(m_strUserName, csTempPassword));

        if (err.Failed())
        {
            //
            // Not a proper impersonation created.  Keep the dialog
            // open to make corrections. 
            //
            m_pMachine->DisplayError(err, m_hWnd);
            m_edit_Password.SetSel(0, -1);
            m_edit_Password.SetFocus();
            return;
        }
    }
    
    EndDialog(IDOK);
}



//
// Connect to server dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



ConnectServerDlg::ConnectServerDlg(
    IN IConsoleNameSpace * pConsoleNameSpace,
    IN IConsole * pConsole,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor.

Arguments:

    CWnd * pParent : Optional pointer to parent window

Return Value:

    N/A

--*/
    : CDialog(ConnectServerDlg::IDD, pParent),
      m_fImpersonate(FALSE),
      m_strServerName(),
      m_strPassword(),
      m_strUserName(),
      m_pMachine(NULL),
      m_pConsoleNameSpace(pConsoleNameSpace),
      m_pConsole(pConsole)
{
#if 0 // Keep Classwizard happy

    //{{AFX_DATA_INIT(ConnectServerDlg)
    m_fImpersonate = FALSE;
    m_strServerName = _T("");
    m_strUserName = _T("");
    m_strPassword = _T("");
    //}}AFX_DATA_INIT

#endif // 0
}



void
ConnectServerDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:
    
    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(ConnectServerDlg)
    DDX_Check(pDX, IDC_CHECK_CONNECT_AS, m_fImpersonate);
    DDX_Text(pDX, IDC_SERVERNAME, m_strServerName);
    DDV_MaxCharsBalloon(pDX, m_strServerName, MAX_SERVERNAME_LEN);
    DDX_Text(pDX, IDC_EDIT_USER_NAME, m_strUserName);
    //DDX_Text(pDX, IDC_EDIT_PASSWORD2, m_strPassword);
    DDX_Text_SecuredString(pDX, IDC_EDIT_PASSWORD2, m_strPassword);
    //DDV_MaxCharsBalloon(pDX, m_strPassword, PWLEN);
    DDV_MaxCharsBalloon_SecuredString(pDX, m_strPassword, PWLEN);
    DDX_Control(pDX, IDC_EDIT_USER_NAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD2, m_edit_Password);
    DDX_Control(pDX, IDC_SERVERNAME, m_edit_ServerName);
    DDX_Control(pDX, IDC_STATIC_USER_NAME, m_static_UserName);
    DDX_Control(pDX, IDC_STATIC_PASSWORD2, m_static_Password);
    DDX_Control(pDX, IDOK, m_button_Ok);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(ConnectServerDlg, CDialog)
    //{{AFX_MSG_MAP(ConnectServerDlg)
    ON_BN_CLICKED(IDC_CHECK_CONNECT_AS, OnCheckConnectAs)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(ID_HELP, OnButtonHelp)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_SERVERNAME, SetControlStates)
    ON_EN_CHANGE(IDC_EDIT_USER_NAME, SetControlStates)
END_MESSAGE_MAP()



void
ConnectServerDlg::SetControlStates()
/*++

Routine Description:

    Set UI control enabled/disabled states.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_UserName.EnableWindow(m_fImpersonate);
    m_static_Password.EnableWindow(m_fImpersonate);
    m_edit_UserName.EnableWindow(m_fImpersonate);
    m_edit_Password.EnableWindow(m_fImpersonate);

    m_button_Ok.EnableWindow(
        m_edit_ServerName.GetWindowTextLength() > 0 &&
        (m_edit_UserName.GetWindowTextLength() > 0 || !m_fImpersonate)
        );
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
ConnectServerDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    SetControlStates();
    
    return TRUE;  
}



void 
ConnectServerDlg::OnButtonBrowse() 
/*++

Routine Description:

    'Browse' button handler.  Browse for a computer name

Arguments:

    None

Return Value:

    None

--*/
{
    CGetComputer picker;
    if (picker.GetComputer(m_hWnd))
    {
        m_edit_ServerName.SetWindowText(picker.m_strComputerName);
        SetControlStates();
        m_button_Ok.SetFocus();
    }
#ifdef _DEBUG
    else
    {
       TRACE(_T("ConnectServerDlg::OnButtonBrowse() -> Cannot get computer name from browser\n"));
    }
#endif
}



void 
ConnectServerDlg::OnCheckConnectAs() 
/*++

Routine Description:

    "Connect As" checbox event handler.  Enable/Disable username/password
    controls.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fImpersonate = !m_fImpersonate;

    SetControlStates();

    if (m_fImpersonate)
    {
        m_edit_UserName.SetFocus();
        m_edit_UserName.SetSel(0, -1);
    }
}



void 
ConnectServerDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Attempt to connect to the machine specified.  If 
    machiname is ok, dismiss the dialog.  Otherwise put up an error message
    and stay active.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_pMachine == NULL);

    CError err;

    if (UpdateData(TRUE))
    {
        do
        {
            CString csTempPassword;
            m_strPassword.CopyTo(csTempPassword);
            LPCTSTR lpszUserName = m_fImpersonate ? (LPCTSTR)m_strUserName : NULL;
            LPCTSTR lpszPassword = m_fImpersonate ? (LPCTSTR)csTempPassword : NULL;

			CString server = m_strServerName;
			if (PathIsUNCServer(m_strServerName))
			{
				server = m_strServerName.Mid(2);
			}
			else
			{
				server = m_strServerName;
			}

            m_pMachine = new CIISMachine(m_pConsoleNameSpace,m_pConsole,CComAuthInfo(server,lpszUserName,lpszPassword));
            if (m_pMachine)
            {
                //
                // Verify the machine object is created. 
                //
                err = CIISMachine::VerifyMachine(m_pMachine);
                if (err.Failed())
                {
                    //
                    // Not a proper machine object created.  Keep the dialog
                    // open to make corrections. 
                    //
                    m_pMachine->DisplayError(err, m_hWnd);
                    m_edit_ServerName.SetSel(0, -1);
                    m_edit_ServerName.SetFocus();
					m_pMachine->Release();
                    m_pMachine = NULL;
                }
				else
				{
					// IIS5.1 block for iis6 remote administration
					CRegKey rk;
					rk.Create(HKEY_LOCAL_MACHINE, g_cszInetSTPBasePath_);
					DWORD major;
					if (ERROR_SUCCESS == rk.QueryValue(major, g_cszMajorVersion_))
					{
						if (m_pMachine->QueryMajorVersion() == 6 && major == 5)
						{
                            DoHelpMessageBox(m_hWnd,IDS_UPGRADE_TO_IIS6, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
							m_pMachine->Release();
                            m_pMachine = NULL;
						}
					}
				}

            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                err.MessageBox(m_hWnd);
            }
        }
        while(FALSE);
    }
    
    if (m_pMachine != NULL)
    {
        EndDialog(IDOK);
    }
}

#define HIDD_CONNECT_SERVER      0x29cd9

void 
ConnectServerDlg::OnButtonHelp()
{
    WinHelpDebug(HIDD_CONNECT_SERVER);
   ::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, HIDD_CONNECT_SERVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\certmap.h ===
#ifndef __CERTMAP_H__
#define __CERTMAP_H__

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCertmap wrapper class

class CCertmap : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertmap)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xbbd8f29b, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0x0, 0x2b, 0x2c, 0x6f, 0x32 } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    short GetBorderStyle();
    void SetBorderStyle(short);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetServerInstance(LPCTSTR szServerInstance);
    void SetMachineName(LPCTSTR szMachineName);
};

#endif // __CERTMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\connects.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        connects.h

   Abstract:
        "Connect to a single server" dialog definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
--*/
#ifndef __CONNECTS_H__
#define __CONNECTS_H__

class CIISMachine;


#define EXTGUID TCHAR



//
// CLoginDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Different ways to display this dialog
//
enum
{
    LDLG_ACCESS_DENIED,     // Access denied
    LDLG_ENTER_PASS,        // Enter password
    LDLG_IMPERSONATION,     // Change impersonation
};



class CLoginDlg : public CDialog
/*++

Class Description:

    Log-in dialog.  Brought up either to enter the password, or to provide
    both username and password

Public Interface:

--*/
{
//
// Construction
//
public:
    CLoginDlg(
        IN int nType,               // See LDLG_ definitions above
        IN CIISMachine * pMachine,
        IN CWnd * pParent           = NULL
        );   

//
// Access
//
public:
    BOOL UserNameChanged() const;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CLoginDlg)
    enum { IDD = IDD_LOGIN };
    CString m_strUserName;
    CStrPassword m_strPassword;
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CStatic m_static_Prompt;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CLoginDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CLoginDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    int m_nType;
    CIISMachine * m_pMachine;
    CString m_strOriginalUserName;
};



class ConnectServerDlg : public CDialog
{
/*++

Class Description:

    Connect to a server dialog.  Also used to ask for the cluster controller
    or for a server to add to the cluster.

Public Interface:

    ConnectServerDlg : Constructor

    GetMachine       : Get the created machine object (may or may not have a created
                       interface)

--*/
//
// Construction
//
public:
    ConnectServerDlg(
        IN IConsoleNameSpace * pConsoleNameSpace,
        IN IConsole * pConsole,
        IN CWnd * pParent = NULL
        );   

//
// Access Functions
//
public:
    CIISMachine * GetMachine() { return m_pMachine; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(ConnectServerDlg)
    enum { IDD = IDD_CONNECT_SERVER };
    BOOL    m_fImpersonate;
    CString m_strServerName;
    CString m_strUserName;
    CStrPassword m_strPassword;
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CEdit   m_edit_ServerName;
    CStatic m_static_UserName;
    CStatic m_static_Password;
    CButton m_button_Ok;
    //}}AFX_DATA
   

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(ConnectServerDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(ConnectServerDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnCheckConnectAs();
    afx_msg void OnButtonBrowse();
	afx_msg void OnButtonHelp();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISMachine * m_pMachine;
    IConsoleNameSpace * m_pConsoleNameSpace;
    IConsole * m_pConsole;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CLoginDlg::UserNameChanged() const
{
    //
    // TRUE if the user name is not the original user name
    //
    return m_strOriginalUserName.CompareNoCase(m_strUserName);
}

#endif // __CONNECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\deffs.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        deffs.cpp

   Abstract:
        Default Ftp Site Dialog

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "ftpsht.h"
#include "deffs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/* static */
void
CDefFtpSitePage::ParseMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
    //
    // Special case: If dwMaxBandwidth is 0(an invalid value), the 
    // value likely could not be inherited from the root (the user
    // is an operator and can't see the properties there).  Adjust
    // the value to a possibly misleading value.
    //
    if (dwMaxBandwidth == 0L)
    {
        TRACEEOLID("Adjusting invalid bandwidth throttling value -- "
                   "are you an operator?");
        dwMaxBandwidth = INFINITE_BANDWIDTH;
    }

    fLimitBandwidth = (dwMaxBandwidth != INFINITE_BANDWIDTH);
    dwMaxBandwidthDisplay = fLimitBandwidth ?
      (dwMaxBandwidth / KILOBYTE) : (DEF_BANDWIDTH / KILOBYTE);
}

IMPLEMENT_DYNCREATE(CDefFtpSitePage, CInetPropertyPage)

CDefFtpSitePage::CDefFtpSitePage(
    IN CInetPropertySheet * pSheet
    )
    : CInetPropertyPage(CDefFtpSitePage::IDD, pSheet)
{
}

CDefFtpSitePage::~CDefFtpSitePage()
{
}

void
CDefFtpSitePage::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDefWebSitePage)
    DDX_Check(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_fLimitBandwidth);
    DDX_Control(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_LimitBandwidth);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH, m_MaxBandwidth);
    DDX_TextBalloon(pDX, IDC_MAX_BANDWIDTH, m_dwMaxBandwidthDisplay);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH_SPIN, m_MaxBandwidthSpin);
    //}}AFX_DATA_MAP
    if (!pDX->m_bSaveAndValidate || m_fLimitBandwidth)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
		DDV_MinMaxBalloon(pDX, IDC_MAX_BANDWIDTH, BANDWIDTH_MIN, BANDWIDTH_MAX);
        DDX_TextBalloon(pDX, IDC_MAX_BANDWIDTH, m_dwMaxBandwidthDisplay);
    }
}

/* virtual */
HRESULT
CDefFtpSitePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_dwMaxBandwidth);
        ParseMaxNetworkUse(
            m_dwMaxBandwidth, 
            m_dwMaxBandwidthDisplay, 
            m_fLimitBandwidth
            );
    END_META_INST_READ(err)

    return err;
}

/* virtual */
HRESULT
CDefFtpSitePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving Ftp default site page now...");

    CError err;

    BuildMaxNetworkUse(
        m_dwMaxBandwidth, 
        m_dwMaxBandwidthDisplay, 
        m_fLimitBandwidth
        );
    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_dwMaxBandwidth);
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}

BOOL
CDefFtpSitePage::SetControlStates()
{
    if (::IsWindow(m_LimitBandwidth.m_hWnd))
    {
        BOOL fLimitOn = m_LimitBandwidth.GetCheck() > 0
//        && HasBwThrottling()
//        && HasAdminAccess()
            ;

        m_MaxBandwidth.EnableWindow(fLimitOn);
        m_MaxBandwidthSpin.EnableWindow(fLimitOn);
        return fLimitOn;
    }
    return FALSE;
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CDefFtpSitePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3PerfPage)
    ON_BN_CLICKED(IDC_CHECK_LIMIT_NETWORK_USE, OnCheckLimitNetworkUse)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_MAX_BANDWIDTH, OnItemChanged)
END_MESSAGE_MAP()

BOOL
CDefFtpSitePage::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();
   //
   // Disable some settings based on what's possible
   //
#if 0
   m_LimitBandwidth.EnableWindow(
        !IsMasterInstance()
     && HasBwThrottling()
     && HasAdminAccess()
        );
#endif
   SETUP_EDIT_SPIN(m_fLimitBandwidth, m_MaxBandwidth, m_MaxBandwidthSpin, 
      BANDWIDTH_MIN, BANDWIDTH_MAX, m_dwMaxBandwidthDisplay);

   SetControlStates();

   return TRUE;
}

void
CDefFtpSitePage::OnItemChanged()
{
    SetControlStates();
    SetModified(TRUE);
}

void
CDefFtpSitePage::OnCheckLimitNetworkUse()
{
    if (SetControlStates())
    {
        m_MaxBandwidth.SetSel(0, -1);
        m_MaxBandwidth.SetFocus();
    }
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\certwiz.h ===
#if !defined(AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_)
#define AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CCertWiz wrapper class

class CCertWiz : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertWiz)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xd4be8632, 0xc85, 0x11d2, { 0x91, 0xb1, 0x0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
    void SetMachineName(LPCTSTR MachineName);
    void SetServerInstance(LPCTSTR InstanceName);
    void DoClick();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__46A3FC8A_E61B_11D2_A771_00A0C922E79C__INCLUDED_)
#define AFX_DLLDATAX_H__46A3FC8A_E61B_11D2_A771_00A0C922E79C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__46A3FC8A_E61B_11D2_A771_00A0C922E79C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\dlldatax.c ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        dlldatax.c

   Abstract:

        wrapper for dlldata.c

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


#ifdef _MERGE_PROXYSTUB     // merge proxy stub DLL



#define REGISTER_PROXY_DLL  // DllRegisterServer, etc.
#define USE_STUBLESS_PROXY  // defined only with MIDL switch /Oicf



#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")



#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow



#include "dlldata.c"
#include "inetmgr_p.c"



#ifdef _NOPROXY //no midl generated dlldata.c



#define STRICT 1
#include <ole2.h>



BOOL 
WINAPI 
PrxDllMain(
    IN HINSTANCE hInstance, 
    IN DWORD dwReason, 
    IN LPVOID lpReserved
    )
{
    return TRUE;
}



STDAPI 
PrxDllCanUnloadNow()
{
    return S_OK;
}



STDAPI 
PrxDllGetClassObject(
    IN REFCLSID rclsid, 
    IN REFIID riid, 
    IN LPVOID * ppv
    )
{
    return CLASS_E_CLASSNOTAVAILABLE;
}



STDAPI 
PrxDllRegisterServer()
{
    return S_OK;
}



STDAPI 
PrxDllUnregisterServer()
{
    return S_OK;
}



#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\deffs.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        deffs.h

   Abstract:
        Default Ftp Site Dialog

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __DEFFS_H__
#define __DEFFS_H__


class CDefFtpSitePage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CDefFtpSitePage)

//
// Construction
//
public:
    CDefFtpSitePage(CInetPropertySheet * pSheet = NULL);
    ~CDefFtpSitePage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CDefWebSitePage)
    enum { IDD = IDD_FTP_DEFAULT_SITE };
    BOOL m_fLimitBandwidth;
    CButton m_LimitBandwidth;
    DWORD m_dwMaxBandwidthDisplay;
    CEdit m_MaxBandwidth;
    CSpinButtonCtrl m_MaxBandwidthSpin;
    //}}AFX_DATA
    DWORD m_dwMaxBandwidth;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

   static void 
   ParseMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

   static void
   BuildMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefWebSitePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CDefWebSitePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckLimitNetworkUse();
    afx_msg void OnItemChanged();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();

private:
};

inline /* static */ void 
CDefFtpSitePage::BuildMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
   dwMaxBandwidth = fLimitBandwidth ?
      dwMaxBandwidthDisplay * KILOBYTE : INFINITE_BANDWIDTH;
}

#endif // __DEFFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\defws.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :
        defws.cpp

   Abstract:
        Default Web Site Dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "defws.h"
//#include "mime.h"
#include "iisobj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Directory Size Units
//
#define DS_UNITS MEGABYTE

//
// Default Web Site Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

IMPLEMENT_DYNCREATE(CDefWebSitePage, CInetPropertyPage)

CDefWebSitePage::CDefWebSitePage(
    CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW Default Web Site page

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A


--*/
    : CInetPropertyPage(CDefWebSitePage::IDD, pSheet),
      m_ppropCompression(NULL),
      m_fFilterPathFound(FALSE),
      m_fCompressionDirectoryChanged(FALSE),
      m_fCompatMode(FALSE)
{
#if 0 // Keep Class Wizard happy
   //{{AFX_DATA_INIT(CDefWebSitePage)
   m_fEnableDynamic = FALSE;
   m_fEnableStatic = FALSE;
   m_fCompatMode = FALSE;
   m_strDirectory = _T("");
   m_nUnlimited = -1;
   m_ilSize = 0L;
   //}}AFX_DATA_INIT
#endif // 0
   m_fInitCompatMode = m_fCompatMode;
}

CDefWebSitePage::~CDefWebSitePage()
{
}

void
CDefWebSitePage::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDefWebSitePage)
    DDX_Control(pDX, IDC_EDIT_COMPRESS_DIRECTORY, m_edit_Directory);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_COMPRESS_DIRECTORY_SIZE, m_edit_DirectorySize);
    DDX_Check(pDX, IDC_CHECK_DYNAMIC_COMPRESSION, m_fEnableDynamic);
    DDX_Check(pDX, IDC_CHECK_STATIC_COMPRESSION, m_fEnableStatic);
    DDX_Check(pDX, IDC_COMPAT_MODE, m_fCompatMode);
    DDX_Radio(pDX, IDC_RADIO_COMPRESS_UNLIMITED, m_nUnlimited);
    //}}AFX_DATA_MAP

    if (HasCompression())
    {
        if (!pDX->m_bSaveAndValidate || m_fEnableStatic)
        {
            DDX_Text(pDX, IDC_EDIT_COMPRESS_DIRECTORY, m_strDirectory);
            DDV_MaxCharsBalloon(pDX, m_strDirectory, _MAX_PATH);
        }

        if (pDX->m_bSaveAndValidate && m_fEnableStatic)
        {
            TCHAR buf[MAX_PATH];
            CString csPathMunged;
            DDX_Text(pDX, IDC_EDIT_COMPRESS_DIRECTORY, m_strDirectory);
            DDV_MaxCharsBalloon(pDX, m_strDirectory, _MAX_PATH);
            ExpandEnvironmentStrings(m_strDirectory, buf, MAX_PATH);

            csPathMunged = buf;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
            GetSpecialPathRealPath(0,buf,csPathMunged);
#endif
            
            if (!PathIsValid(csPathMunged,FALSE) || !IsFullyQualifiedPath(csPathMunged))
            {
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_INVALID_PATH);
            }
            //
            // Perform some additional smart checking on the compression
            // directory if the current machine is local, and the 
            // directory has changed
            //
            if (IsLocal() && m_fCompressionDirectoryChanged)
            {
                //
                // Should exist on the local machine.
                //
                DWORD dwAttr = GetFileAttributes(csPathMunged);
                if (dwAttr == 0xffffffff 
                    || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0
                    || IsNetworkPath(csPathMunged)
                    )
                {
					DDV_ShowBalloonAndFail(pDX, IDS_ERR_COMPRESS_DIRECTORY);
                }

                //
                // Now check to make sure the volume is of the correct
                // type.
                //
                DWORD dwFileSystemFlags;

                if (::GetVolumeInformationSystemFlags(csPathMunged, &dwFileSystemFlags))
                {
                    if (!(dwFileSystemFlags & FS_PERSISTENT_ACLS))
                    {
                        //
                        // No ACLS
                        //
                        if (!NoYesMessageBox(IDS_NO_ACL_WARNING))
                        {
                            pDX->Fail();
                        }
                    }

                    if (dwFileSystemFlags & FS_VOL_IS_COMPRESSED
                        || dwAttr & FILE_ATTRIBUTE_COMPRESSED)
                    {
                        //
                        // Compression cache directory is itself compressed
                        //
                        if (!NoYesMessageBox(IDS_COMPRESS_WARNING))
                        {
                            pDX->Fail();
                        }
                    }
                }
            }
        }

        if (!pDX->m_bSaveAndValidate || (m_fEnableLimiting && m_fEnableStatic))
        {
			// This Needs to come before DDX_Text which will try to put text big number into small number
			DDV_MinMaxBalloon(pDX, IDC_EDIT_COMPRESS_DIRECTORY_SIZE, 1, 1024L);
            DDX_Text(pDX, IDC_EDIT_COMPRESS_DIRECTORY_SIZE, m_ilSize);
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDefWebSitePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CDefWebSitePage)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_RADIO_COMPRESS_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_COMPRESS_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_CHECK_DYNAMIC_COMPRESSION, OnCheckDynamicCompression)
    ON_BN_CLICKED(IDC_CHECK_STATIC_COMPRESSION, OnCheckStaticCompression)
    ON_BN_CLICKED(IDC_COMPAT_MODE, OnCheckCompatMode)
    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY, OnChangeEditCompressDirectory)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY_SIZE, OnItemChanged)

END_MESSAGE_MAP()



void 
CDefWebSitePage::SetControlStates()
/*++

Routine Description:

    Enable/disable control states depending on the state of
    the dialog.

Arguments:

    None

Return Value:

    None

--*/
{
    GetDlgItem(IDC_STATIC_COMPRESS_DIRECTORY)->EnableWindow(m_fEnableStatic);
    m_edit_Directory.EnableWindow(m_fEnableStatic);
    m_edit_DirectorySize.EnableWindow(m_fEnableStatic && m_fEnableLimiting);
    GetDlgItem(IDC_RADIO_COMPRESS_LIMITED)->EnableWindow(m_fEnableStatic);
    GetDlgItem(IDC_RADIO_COMPRESS_UNLIMITED)->EnableWindow(m_fEnableStatic);
    GetDlgItem(IDC_STATIC_MAX_COMPRESS_SIZE)->EnableWindow(m_fEnableStatic);

    //
    // Browse on the local machine only
    //
    m_button_Browse.EnableWindow(IsLocal() && m_fEnableStatic);
}



/* virtual */
HRESULT
CDefWebSitePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    ASSERT(m_ppropCompression == NULL);

    m_ppropCompression = new CIISCompressionProps(QueryAuthInfo());
    if (m_ppropCompression)
    {
        err = m_ppropCompression->LoadData();
        m_fFilterPathFound = err.Succeeded();
        
        if (err.Succeeded())
        {
            m_fEnableDynamic = m_ppropCompression->m_fEnableDynamicCompression;
            m_fEnableStatic = m_ppropCompression->m_fEnableStaticCompression;
            m_fEnableLimiting = m_ppropCompression->m_fLimitDirectorySize;
            m_strDirectory = m_ppropCompression->m_strDirectory;
            m_nUnlimited = m_fEnableLimiting ? RADIO_LIMITED : RADIO_UNLIMITED;

            if (m_ppropCompression->m_dwDirectorySize == 0xffffffff)
            {
                m_ilSize = DEF_MAX_COMPDIR_SIZE / DS_UNITS;
            }
            else
            {
                m_ilSize = m_ppropCompression->m_dwDirectorySize / DS_UNITS;
            }
        }
        else if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Fail quietly
            //
            TRACEEOLID("No compression filters installed");
            err.Reset();    
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

	if (err.Succeeded())
	{
		if (GetSheet()->QueryMajorVersion() >= 6)
		{
			CMetaKey mk(QueryAuthInfo(), QueryMetaPath(), METADATA_PERMISSION_READ);
			err = mk.QueryResult();
			if (err.Succeeded())
			{
				err = mk.QueryValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, m_fCompatMode);
				if (err.Succeeded())
				{
				   m_fInitCompatMode = m_fCompatMode;
				}
			}
		 }
		 else
		 {
			 m_fInitCompatMode = m_fCompatMode = TRUE;
		 }

	}
    return err;
}



HRESULT
CDefWebSitePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
   ASSERT(IsDirty());

   TRACEEOLID("Saving W3 default web site page now...");

   CError err;
   BeginWaitCursor();

   if (HasCompression())
   {
      ASSERT(m_ppropCompression);
      DWORD dwSize = m_ilSize * DS_UNITS;

      m_ppropCompression->m_fEnableDynamicCompression = m_fEnableDynamic;
      m_ppropCompression->m_fEnableStaticCompression  = m_fEnableStatic;
      m_ppropCompression->m_fLimitDirectorySize       = m_fEnableLimiting;
      // TODO: Replace back %WINDIR% or another system settings in path
      m_ppropCompression->m_strDirectory              = m_strDirectory;
      m_ppropCompression->m_dwDirectorySize           = dwSize;
      err = m_ppropCompression->WriteDirtyProps();
      if (err.Succeeded())
      {
         m_fCompressionDirectoryChanged = FALSE;
      }
   }
   if (err.Succeeded())
   {
        if (GetSheet()->QueryMajorVersion() >= 6)
        {
            CMetaKey mk(QueryAuthInfo(), QueryMetaPath(), METADATA_PERMISSION_WRITE);
            err = mk.QueryResult();
            if (err.Succeeded())
            {
                err = mk.SetValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, m_fCompatMode);
                if (err.Succeeded() && m_fCompatMode != m_fInitCompatMode)
                {
                    // We don't need to save this parameter to sheet,
                    // it is important to App Protection combo only, and
                    // this combo is disabled for Master props, so it doesn't matter.
                    GetSheet()->SetRestartRequired(TRUE);
                    m_fInitCompatMode = m_fCompatMode;
                }
            }
        }
        NotifyMMC(PROP_CHANGE_REENUM_VDIR | PROP_CHANGE_REENUM_FILES);
   }
   EndWaitCursor();

   return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            



BOOL
CDefWebSitePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Check to make sure compression is supported
    //
    GetDlgItem(IDC_STATIC_COMPRESS_GROUP)->EnableWindow(HasCompression());
    GetDlgItem(IDC_CHECK_DYNAMIC_COMPRESSION)->EnableWindow(HasCompression());
    GetDlgItem(IDC_CHECK_STATIC_COMPRESSION)->EnableWindow(HasCompression());
    GetDlgItem(IDC_RADIO_COMPRESS_UNLIMITED)->EnableWindow(HasCompression());
    GetDlgItem(IDC_RADIO_COMPRESS_LIMITED)->EnableWindow(HasCompression());
    GetDlgItem(IDC_EDIT_COMPRESS_DIRECTORY)->EnableWindow(HasCompression());
    GetDlgItem(IDC_STATIC_MAX_COMPRESS_SIZE)->EnableWindow(HasCompression());
    GetDlgItem(IDC_STATIC_COMPRESS_DIRECTORY)->EnableWindow(HasCompression());
    GetDlgItem(IDC_EDIT_COMPRESS_DIRECTORY_SIZE)->EnableWindow(HasCompression());
    GetDlgItem(IDC_COMPAT_MODE)->EnableWindow(GetSheet()->QueryMajorVersion() >= 6);

    SetControlStates();
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_COMPRESS_DIRECTORY),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_COMPRESS_DIRECTORY),FALSE);
#endif

    return TRUE;
}



void 
CDefWebSitePage::OnItemChanged()
/*++

Routine Description:
    
    Handle change in control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
    SetControlStates();
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CDefWebSitePage * pThis = (CDefWebSitePage *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CDefWebSitePage::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void 
CDefWebSitePage::OnButtonBrowse() 
{
   ASSERT(IsLocal());
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Directory.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
	     ExpandEnvironmentStrings(str, buf, MAX_PATH);
		 str = buf;
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = NULL;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Directory.SetWindowText(str);
       OnItemChanged();
   }
}



void 
CDefWebSitePage::OnChangeEditCompressDirectory() 
/*++

Routine Description:

    Handle change in compression directory edit box.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fCompressionDirectoryChanged = TRUE;
    OnItemChanged();
}



void 
CDefWebSitePage::OnRadioLimited() 
/*++

Routine Description:

    'Limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fEnableLimiting)
    {
        m_nUnlimited = RADIO_LIMITED;
        m_fEnableLimiting = TRUE;
        OnItemChanged();

        m_edit_DirectorySize.SetSel(0, -1);
        m_edit_DirectorySize.SetFocus();
    }
}



void 
CDefWebSitePage::OnRadioUnlimited() 
/*++

Routine Description:

    'Unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fEnableLimiting)
    {
        m_nUnlimited = RADIO_UNLIMITED;
        m_fEnableLimiting = FALSE;
        OnItemChanged();
    }
}



void 
CDefWebSitePage::OnCheckDynamicCompression() 
/*++

Routine Description:

    "Enable Dynamic Compression' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableDynamic = !m_fEnableDynamic;
    OnItemChanged();
}



void 
CDefWebSitePage::OnCheckStaticCompression() 
/*++

Routine Description:

    "Enable Dynamic Compression' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableStatic = !m_fEnableStatic;
    OnItemChanged();
    if (m_fEnableStatic)
    {
        m_edit_Directory.SetSel(0, -1);
        m_edit_Directory.SetFocus();
    }
}



void 
CDefWebSitePage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    SAFE_DELETE(m_ppropCompression);
}

void
CDefWebSitePage::OnCheckCompatMode()
{
   OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\defws.h ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        defws.h

   Abstract:
        Default Web Site Dialog

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
--*/
#ifndef __DEFWS_H__
#define __DEFWS_H__


class CDefWebSitePage : public CInetPropertyPage
/*++

Class Description:

    WWW Errors property page

Public Interface:

    CDefWebSitePage       : Constructor
    CDefWebSitePage       : Destructor

--*/
{
    DECLARE_DYNCREATE(CDefWebSitePage)

//
// Construction
//
public:
    CDefWebSitePage(CInetPropertySheet * pSheet = NULL);
    ~CDefWebSitePage();

	int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CDefWebSitePage)
    enum { IDD = IDD_DEFAULT_SITE };
    int     m_nUnlimited;
    BOOL    m_fEnableDynamic;
    BOOL    m_fEnableStatic;
    BOOL    m_fCompatMode;
    CString m_strDirectory;
    CEdit   m_edit_DirectorySize;
    CEdit   m_edit_Directory;
    CButton m_button_Browse;
    //}}AFX_DATA

    BOOL   m_fEnableLimiting;
    BOOL   m_fCompressionDirectoryChanged;
    BOOL   m_fInitCompatMode;
    CILong m_ilSize;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefWebSitePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CDefWebSitePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowse();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    afx_msg void OnCheckDynamicCompression();
    afx_msg void OnCheckStaticCompression();
    afx_msg void OnCheckCompatMode();
    afx_msg void OnChangeEditCompressDirectory();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

//    HRESULT BuildInstanceList();
//    DWORD FetchInstanceSelected();
    void SetControlStates();
    BOOL HasCompression() const;

private:
    CIISCompressionProps * m_ppropCompression;
    BOOL m_fFilterPathFound;
	LPTSTR m_pPathTemp;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CDefWebSitePage::HasCompression() const
{
    return m_fFilterPathFound 
		&& CInetPropertyPage::IsCompressionConfigurable()
		&& CInetPropertyPage::HasCompression();
}


#endif // __DEFWS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\docum.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        docum.cpp

   Abstract:
        WWW Documents Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "supdlgs.h"
#include "docum.h"

#include <lmcons.h>



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CAddDefDocDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CAddDefDocDlg::CAddDefDocDlg(CWnd * pParent OPTIONAL)
    : CDialog(CAddDefDocDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddDefDocDlg)
    m_strDefDocument = _T("");
    //}}AFX_DATA_INIT
	m_pParent = NULL;
}



void 
CAddDefDocDlg::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddDefDocDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_DEF_DOCUMENT, m_edit_DefDocument);
    DDX_Text(pDX, IDC_EDIT_DEF_DOCUMENT, m_strDefDocument);
    DDV_MaxCharsBalloon(pDX, m_strDefDocument, MAX_PATH);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
		m_strDefDocument.TrimRight();
		m_strDefDocument.TrimLeft();

        CString csPathMunged;
        CString csPathMungedCleaned;
        csPathMunged = m_strDefDocument;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
        GetSpecialPathRealPath(0,m_strDefDocument,csPathMunged);
#endif

        // Check if it has a '?' character in it...
        csPathMungedCleaned = csPathMunged;
        INT iQuestionMarkPos = csPathMunged.Find(_T("?"));
        if (iQuestionMarkPos >= 0)
        {
            // there is aquestion mark in there.
            // trim it off and create a new csPathMunged...
            csPathMungedCleaned = csPathMunged.Left(iQuestionMarkPos);
        }
        
        // Check if it's empty
        if (csPathMungedCleaned.IsEmpty())
        {
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_INVALID_DOCNAME_CHARS);
        }

		// we could have only one forward slash here
        int pos = 0;
		if ((pos = csPathMungedCleaned.Find(_T('/'))) != -1
			&& csPathMungedCleaned.ReverseFind(_T('/')) != pos)
		{
			DDV_ShowBalloonAndFail(pDX, IDS_ERR_NO_COMPLETE_PATH);
		}

        // check if it's a full path.
        //
        // PathIsFileSpec will return 0 if its c:\temp\myfile
        // PathIsFileSpec will erturn 1 if it doesn't find : or "\"
		if (!PathIsFileSpec(csPathMungedCleaned))
		{
			DDV_ShowBalloonAndFail(pDX, IDS_ERR_NO_COMPLETE_PATH);
		}

        // at this point we have something that doesn't have slash or : in it...
        // check if the filename has bad characters in it...
        //Bad Characters = _T("|<>*\"\t\r\n");
        BOOL bBadChar = FALSE;
        if (-1 != csPathMungedCleaned.Find(_T("|"))){bBadChar = TRUE;}
        else if (-1 != csPathMungedCleaned.Find(_T("<"))){bBadChar = TRUE;}
        else if (-1 != csPathMungedCleaned.Find(_T(">"))){bBadChar = TRUE;}
        else if (-1 != csPathMungedCleaned.Find(_T("*"))){bBadChar = TRUE;}
        else if (-1 != csPathMungedCleaned.Find(_T("\""))){bBadChar = TRUE;}
        else if (-1 != csPathMungedCleaned.Find(_T("\t"))){bBadChar = TRUE;}
        else if (-1 != csPathMungedCleaned.Find(_T("\r"))){bBadChar = TRUE;}
        else if (-1 != csPathMungedCleaned.Find(_T("\n"))){bBadChar = TRUE;}
        if (bBadChar)
        {
            DDV_ShowBalloonAndFail(pDX, IDS_ERR_INVALID_DOCNAME_CHARS);
        }

		ASSERT(m_pParent != NULL);
		if (LB_ERR != m_pParent->DocExistsInList(csPathMungedCleaned))
		{
			DDV_ShowBalloonAndFail(pDX, IDS_DUPLICATE_DOC);
		}
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CAddDefDocDlg, CDialog)
    //{{AFX_MSG_MAP(CAddDefDocDlg)
    ON_EN_CHANGE(IDC_EDIT_DEF_DOCUMENT, OnChangeEditDefDocument)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CAddDefDocDlg::OnChangeEditDefDocument() 
/*++

Routine Description:

    Respond to a change in the default document edit box

Arguments:

    None./

--*/
{
    m_button_Ok.EnableWindow(m_edit_DefDocument.GetWindowTextLength() > 0);
}



//
// WWW Documents Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CW3DocumentsPage, CInetPropertyPage)



//
// Static Initialization
//
const LPCTSTR CW3DocumentsPage::s_lpstrSep = _T(",");
const LPCTSTR CW3DocumentsPage::s_lpstrFILE = _T("FILE:");
const LPCTSTR CW3DocumentsPage::s_lpstrSTRING = _T("STRING:");
const LPCTSTR CW3DocumentsPage::s_lpstrURL = _T("URL:");



CW3DocumentsPage::CW3DocumentsPage(CInetPropertySheet * pSheet) 
    : CInetPropertyPage(CW3DocumentsPage::IDD, pSheet),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_LOADDEFAULT)
{

#if 0 // Keep Class-wizard happy

    //{{AFX_DATA_INIT(CW3DocumentsPage)
    m_strFooter = _T("");
    m_fEnableDefaultDocument = FALSE;
    m_fEnableFooter = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

}



CW3DocumentsPage::~CW3DocumentsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3DocumentsPage::MakeFooterCommand(CString & strFooter)
/*++

Routine Description:
    Convert the footer document to a full footer string.

Arguments:
    CString & strFooter : On input this is the footer document,
                          at output this will be a full footer command

Return Value:
    None.

Notes:
    Only support FILE: for now

--*/
{
    strFooter.TrimLeft();
    strFooter.TrimRight();

    ASSERT(!PathIsRelative(strFooter));
    strFooter = s_lpstrFILE + strFooter;
}



void
CW3DocumentsPage::ParseFooterCommand(CString & strFooter)
/*++

Routine Description:
    Trim the command from the rest of this command 

Arguments:
    CString & strFooter : On input this is a footer command
                          at output this will be just the footer document
--*/
{
    LPCTSTR lp = strFooter.GetBuffer(0);
    if (!_tcsnccmp(lp, s_lpstrFILE, 5))
    {
        lp += lstrlen(s_lpstrFILE);
    }
    else if (!_tcsnccmp(lp, s_lpstrSTRING, 7))
    {
        lp += lstrlen(s_lpstrSTRING);
    }
    else if (!::_tcsnccmp(lp, s_lpstrURL, 4))
    {
        lp += lstrlen(s_lpstrURL);
    }
    if (lp != strFooter.GetBuffer(0))
    {
        strFooter = lp;
    }
    strFooter.TrimLeft();
}



void
CW3DocumentsPage::StringToListBox()
/*++

Routine Description:

    Parse the default document string, and add each doc
    to the listbox

Arguments:

    None

Return Value:

    None

--*/
{
    int start = 0, end;
    int skip = lstrlen(s_lpstrSep);
    BOOL done = FALSE;
    do
    {
        end = m_strDefaultDocument.Find(s_lpstrSep, start);
        if (end == -1)
        {
            done = TRUE;
            end = m_strDefaultDocument.GetLength();
        }
        CString str = m_strDefaultDocument.Mid(start, end - start);
        if (!str.IsEmpty())
        {
            str.TrimLeft();
            str.TrimRight();
            m_list_DefDocuments.AddString(str);
        }
        start = end + skip;
    }
    while (!done);
}



BOOL
CW3DocumentsPage::StringFromListBox()
/*++

Routine Description:

    Build up list of default documents from the contents of 
    the listbox.

Arguments:

    None

Return Value:

    TRUE if at least one document was added.

--*/
{
    m_strDefaultDocument.Empty();

    int i;
    for (i = 0; i < m_list_DefDocuments.GetCount(); ++i)
    {
        CString str;
        m_list_DefDocuments.GetText(i, str);
        if (i)
        {
            m_strDefaultDocument += s_lpstrSep;
        }

        m_strDefaultDocument += str;
    }

    return i > 0;
}



void 
CW3DocumentsPage::DoDataExchange(CDataExchange * pDX)
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3DocumentsPage)
    DDX_Check(pDX, IDC_CHECK_ENABLE_DEFAULT_DOCUMENT, m_fEnableDefaultDocument);
    DDX_Check(pDX, IDC_CHECK_ENABLE_DOCUMENT_FOOTER, m_fEnableFooter);
    DDX_Control(pDX, IDC_LIST_DEFAULT_DOCUMENT, m_list_DefDocuments);
    DDX_Control(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_edit_Footer);
    DDX_Control(pDX, IDC_CHECK_ENABLE_DOCUMENT_FOOTER, m_check_EnableFooter);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_BUTTON_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTTON_DOWN, m_button_Down);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (m_fEnableDefaultDocument)
        {
            if (!StringFromListBox())
            {
//				EditShowBalloon(m_list_DefDocuments.m_hWnd, IDS_ERR_DOCUMENTS);
                DoHelpMessageBox(m_hWnd,IDS_ERR_DOCUMENTS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
				pDX->Fail();
            }
        }

        if (m_fEnableFooter)
        {
            BeginWaitCursor();
            DDX_Text(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_strFooter);
            DDV_MinMaxChars(pDX, m_strFooter, 1, MAX_PATH);
            CString csPathMunged;
            csPathMunged = m_strFooter;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
            GetSpecialPathRealPath(0,m_strFooter,csPathMunged);
#endif
            if (PathIsRelative(csPathMunged))
            {
                //
                // Footer doc must be a complete path
                //
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_COMPLETE_PATH);
            }
            else if (IsLocal() && PathIsNetworkPath(csPathMunged))
            {
                //
                // Footer doc must be on local machine.
                //
				DDV_ShowBalloonAndFail(pDX, IDS_NOT_LOCAL_FOOTER);
            }
            else if (IsLocal() && (::GetFileAttributes(csPathMunged) & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // And lastly, but not leastly, the footer document should exist
                //
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_FILE_NOT_FOUND);
            }
            else
            {
                MakeFooterCommand(m_strFooter);
            }
            EndWaitCursor();
        }
//        else
//        {
//            csPathMunged.Empty();
//        }
    }
    else
    {
        ParseFooterCommand(m_strFooter);
        DDX_Text(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_strFooter);
        DDV_MinMaxChars(pDX, m_strFooter, 1, MAX_PATH);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DocumentsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DocumentsPage)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_DEFAULT_DOCUMENT, OnCheckEnableDefaultDocument)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_DOCUMENT_FOOTER, OnCheckEnableDocumentFooter)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
    ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
    ON_LBN_SELCHANGE(IDC_LIST_DEFAULT_DOCUMENT, OnSelchangeListDefaultDocument)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_DEFAULT_DOCUMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOCUMENT_FOOTER, OnItemChanged)

END_MESSAGE_MAP()



void 
CW3DocumentsPage::SetUpDownStates()
{
    int nLast = m_list_DefDocuments.GetCount() - 1;
    int nSel = m_list_DefDocuments.GetCurSel();

    m_button_Up.EnableWindow(nSel > 0);
    m_button_Down.EnableWindow(nSel >= 0 && nSel < nLast);
}



BOOL
CW3DocumentsPage::SetRemoveState()
{
    BOOL fEnabled = m_fEnableDefaultDocument
        && (m_list_DefDocuments.GetCurSel() != LB_ERR);

    m_button_Remove.EnableWindow(fEnabled);

    return fEnabled;
}



BOOL 
CW3DocumentsPage::SetDefDocumentState(BOOL fEnabled)
/*++

Routine Description:

    Set the enabled states of the Default Documents state

Arguments:

    BOOL fEnabled       : TRUE if default document is on

Return Value:

    TRUE if default document is on

--*/
{
    m_button_Add.EnableWindow(fEnabled);
    m_button_Up.EnableWindow(fEnabled);
    m_button_Down.EnableWindow(fEnabled);
    m_list_DefDocuments.EnableWindow(fEnabled);
    SetRemoveState();

    return fEnabled;
}



BOOL 
CW3DocumentsPage::SetDocFooterState(BOOL fEnabled)
/*++

Routine Description:

    Set the enabled state of the footer documents

Arguments:

    BOOL fEnabled       : TRUE if footers are on

Return Value:

    TRUE if footers are on

--*/
{
    m_edit_Footer.EnableWindow(fEnabled);
    m_button_Browse.EnableWindow(IsLocal() && fEnabled);

    return fEnabled;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DocumentsPage::OnItemChanged()
{
    SetModified(TRUE);
}



void 
CW3DocumentsPage::OnCheckEnableDefaultDocument()
{
    m_fEnableDefaultDocument = !m_fEnableDefaultDocument;
    SetDefDocumentState(m_fEnableDefaultDocument);
    OnItemChanged();
}



void 
CW3DocumentsPage::OnCheckEnableDocumentFooter()
{
    m_fEnableFooter = !m_fEnableFooter;
    if (SetDocFooterState(m_fEnableFooter))
    {
        m_edit_Footer.SetSel(0,-1);
        m_edit_Footer.SetFocus();        
    }

    OnItemChanged();
}



BOOL 
CW3DocumentsPage::OnInitDialog()
{
    CInetPropertyPage::OnInitDialog();

    StringToListBox();
    SetDefDocumentState(m_fEnableDefaultDocument);
    SetDocFooterState(m_fEnableFooter);
    SetUpDownStates();
    SetRemoveState();
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_DOCUMENT_FOOTER),TRUE);
    LimitInputPath(CONTROL_HWND(IDC_EDIT_DEF_DOCUMENT),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_DOCUMENT_FOOTER),FALSE);
    LimitInputPath(CONTROL_HWND(IDC_EDIT_DEF_DOCUMENT),FALSE);
#endif
    return TRUE;  
}



/* virtual */
HRESULT
CW3DocumentsPage::FetchLoadedValues()
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
        FETCH_DIR_DATA_FROM_SHEET(m_strDefaultDocument);
        FETCH_DIR_DATA_FROM_SHEET(m_fEnableFooter);
        FETCH_DIR_DATA_FROM_SHEET(m_strFooter);
        m_fEnableDefaultDocument = IS_FLAG_SET(
            m_dwDirBrowsing, 
            MD_DIRBROW_LOADDEFAULT
            );
    END_META_DIR_READ(err)

    return err;
}



HRESULT
CW3DocumentsPage::SaveInfo()
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 documents page now...");

    CError err;

    SET_FLAG_IF(m_fEnableDefaultDocument, m_dwDirBrowsing, MD_DIRBROW_LOADDEFAULT);

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_strDefaultDocument)
        //STORE_DIR_DATA_ON_SHEET_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_fEnableFooter)
        CString buf = m_strFooter;
        if (!m_fEnableFooter)
        {
           m_strFooter.Empty();
        }
        STORE_DIR_DATA_ON_SHEET(m_strFooter)
        m_strFooter = buf;
    END_META_DIR_WRITE(err)
    if (err.Succeeded())
    {
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
    }

    EndWaitCursor();

    return err;
}



int
CW3DocumentsPage::DocExistsInList(LPCTSTR lpDoc)
/*++

Routine Description:

    Check to see if the given document exists in the list

Arguments:

    LPCTSTR lpDoc   : Document to check

Return Value:

    The index where the item exists or LB_ERR if it doesn't exist.

--*/
{
    CString str;
    for (int n = 0; n < m_list_DefDocuments.GetCount(); ++n)
    {
        m_list_DefDocuments.GetText(n, str);
        if (!str.CompareNoCase(lpDoc))
        {
            return n;
        }
    }

    return LB_ERR;
}


void 
CW3DocumentsPage::OnButtonAdd() 
{
    CAddDefDocDlg dlg;
	dlg.m_pParent = this;
    if (dlg.DoModal() == IDOK)
    {
        //
        // Check to see if it existed already
        //
        try
        {
            int nSel;
            CString strNewDoc(dlg.GetDefDocument());
            
            if ((nSel = DocExistsInList(strNewDoc)) != LB_ERR)
            {
                m_list_DefDocuments.SetCurSel(nSel);
                return;
            }

            nSel = m_list_DefDocuments.AddString(strNewDoc);
            if (nSel >= 0)
            {
                m_list_DefDocuments.SetCurSel(nSel);
                SetUpDownStates();
                SetRemoveState();
                OnItemChanged();
            }
        }
        catch(CMemoryException * e)
        {
            e->ReportError();
            e->Delete();
        }
    }
}



void 
CW3DocumentsPage::OnButtonRemove() 
{
    int nSel = m_list_DefDocuments.GetCurSel();
    if (nSel >= 0)
    {
        m_list_DefDocuments.DeleteString(nSel);
        if (nSel >= m_list_DefDocuments.GetCount())
        {
           --nSel;
        }
        m_list_DefDocuments.SetCurSel(nSel);
        SetUpDownStates();
        OnItemChanged();

        if (!SetRemoveState())
        {
            //
            // Make sure we don't focus on a disabled button
            //
            m_button_Add.SetFocus();
        }
    }
}



void 
CW3DocumentsPage::OnButtonBrowse() 
{
    ASSERT(IsLocal());

    //
    // Pop up the file dialog and let the user select the footer htm file.
    //
    CString str;
    str.LoadString(IDS_HTML_MASK);
    CFileDialog dlgBrowse(TRUE, NULL, NULL, OFN_HIDEREADONLY, str, this);

    //
    // If the new style of file-open dialog is requested, comment
    // out the DoModal, and remove the other two comments.
    //
    dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

    if (dlgBrowse.DoModal() == IDOK)
    //if (GetOpenFileName(&dlgBrowse.m_ofn))
    {
        m_edit_Footer.SetWindowText(dlgBrowse.GetPathName());
    }
}



void
CW3DocumentsPage::ExchangeDocuments(
    IN int nLow,
    IN int nHigh
    )
/*++

Routine Description:

    Exchange two documents in the listbox

Arguments:

    int nLow   : Low item
    int nHigh  : High item

Return Value:

    None.

--*/
{
    ASSERT(nLow < nHigh);
    CString str;
    m_list_DefDocuments.GetText(nLow, str);
    m_list_DefDocuments.DeleteString(nLow);
    m_list_DefDocuments.InsertString(nHigh, str);
    OnItemChanged();
}



void 
CW3DocumentsPage::OnButtonUp() 
/*++

Routine Description:

    Move the currently selected doc up

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_DefDocuments.GetCurSel();
    ExchangeDocuments(nCurSel - 1, nCurSel);
    m_list_DefDocuments.SetCurSel(nCurSel - 1);
    m_list_DefDocuments.SetFocus();
    SetUpDownStates();
}



void 
CW3DocumentsPage::OnButtonDown() 
/*++

Routine Description:

    Move the currently selected doc down

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_DefDocuments.GetCurSel();
    ExchangeDocuments(nCurSel, nCurSel + 1);
    m_list_DefDocuments.SetCurSel(nCurSel + 1);
    m_list_DefDocuments.SetFocus();
    SetUpDownStates();
}



void 
CW3DocumentsPage::OnSelchangeListDefaultDocument() 
{
    SetUpDownStates();
    SetRemoveState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\errordlg.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        errordlg.cpp

   Abstract:
        Error edit dialog

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "errordlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// HTTP Custom Error Definition
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Static Initialization
//
LPCTSTR CCustomError::s_szSep = _T(",");
LPCTSTR CCustomError::s_szURL = _T("URL");
LPCTSTR CCustomError::s_szFile = _T("FILE");
LPCTSTR CCustomError::s_szNoSubError = _T("*");

#define GET_FIELD()\
    end = strError.Find(s_szSep, start);\
    if (end == -1) \
        end = strError.GetLength()
#define SKIP()\
    start = end + skip
#define GET_INT_FIELD(n)\
    GET_FIELD();\
    (n) = StrToInt(strError.Mid(start, end - start));\
    SKIP()


/* static */
BOOL
CCustomError::CrackErrorString(
    IN  LPCTSTR lpstrErrorString, 
    OUT UINT & nError, 
    OUT UINT & nSubError,
    OUT ERT & nType, 
    OUT CString & str
    )
/*++

Routine Description

    Helper function to parse error string into component parts

Arguments:

    LPCTSTR lpstrErrorString    : Error input string
    UINT & nError               : Error 
    UINT & nSubError            : Sub Error
    int & nType                 : Error type
    CString & str               : Text parameter
    
Return Value:

    TRUE for success, FALSE for failure

--*/
{
    BOOL fSuccess = FALSE;

    do
    {
        CString strError(lpstrErrorString);
        TRACEEOLID(strError);

        int start = 0, end, skip = lstrlen(s_szSep);

        GET_INT_FIELD(nError);
        ASSERT(nError > 0);
        GET_INT_FIELD(nSubError);
        GET_FIELD();
        nType = strError.Mid(start, end - start).CompareNoCase(s_szURL) == 0 ? ERT_URL : ERT_FILE;
        SKIP();
        if (-1 != (end = strError.ReverseFind((TCHAR) s_szSep)))
            str = strError.Mid(start, end - start);
        else
            str = strError.Right(strError.GetLength() - start);
        fSuccess = TRUE;
    }
    while(FALSE);

    return fSuccess;
}



/* static */
void 
CCustomError::CrackErrorDescription(
    IN  LPCTSTR lpstrErrorString, 
    OUT UINT & nError, 
    OUT UINT & nSubError,
    OUT BOOL & fURLSupported,
    OUT CString & str
    )
/*++

Routine Description

    Helper function to parse error description into component parts

Arguments:

    LPCTSTR lpstrErrorString    : Error input string
    UINT & nError               : Error 
    UINT & nSubError            : Sub Error
    BOOL & fURLSupported        : Return TRUE if urls are allowed
    CString & str               : Text parameter
    
Return Value:

    None.

--*/
{
    try
    {
        CString strError(lpstrErrorString);
        TRACEEOLID(strError);

        int start = 0, end, skip = lstrlen(s_szSep);
        fURLSupported = FALSE;

        do
        {
            GET_INT_FIELD(nError);
            ASSERT(nError > 0);
            GET_INT_FIELD(nSubError);
            GET_FIELD();
            str = strError.Mid(start, end - start);
            SKIP();
            GET_FIELD();
            if (nSubError > 0)
            {
                str += _T(" - ");
                str += strError.Mid(start, end - start);
            }
            SKIP();
            GET_FIELD();
            fURLSupported = end != -1 && end > start ? 
                0 == StrToInt(strError.Mid(start, end - start)) : FALSE;
        }
        while (FALSE);
/*
        LPTSTR lp = strError.GetBuffer(0);
        LPTSTR lpField = StringTok(lp, s_szSep);
        nError = _ttoi(lpField);
        ASSERT(nError > 0);
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        nSubError = lpField != NULL ? _ttoi(lpField) : 0;
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        str = lpField;
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        if (nSubError > 0)
        {
            //
            // Add sub error text
            //
            ASSERT(nSubError > 0);
            str += _T(" - ");
            str += lpField;
            lpField = StringTok(NULL, s_szSep);
        }

        ASSERT(lpField != NULL);
        fURLSupported = lpField != NULL ? (_ttoi(lpField) == 0) : FALSE;
*/
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }
}




CCustomError::CCustomError(
    IN LPCTSTR lpstrErrorString
    )
/*++

Routine Description:

   Construct error definition from metabase string
  
Arguments:

    LPCTSTR lpstrErrorString : Error string
    
Return Value:

    N/A 

--*/
    : m_nType(ERT_DEFAULT)
{
    CrackErrorDescription(
        lpstrErrorString,
        m_nError,
        m_nSubError,
        m_fURLSupported,
        m_strDefault
        );
}



void 
CCustomError::BuildErrorString(
    OUT CString & str
    )
/*++

Routine Description:

    Build metabase-ready error string out of the current values

Arguments:

    CString & str : String

Return Value:

    None

--*/
{
    ASSERT(!IsDefault());

    try
    {
        if (m_nSubError > 0)
        {
            str.Format(_T("%d,%d,%s,%s"),
                m_nError,
                m_nSubError,
                IsFile() ? s_szFile : s_szURL,
                (LPCTSTR)m_str
                );
        }
        else
        {
            str.Format(
                _T("%d,%s,%s,%s"),
                m_nError,
                s_szNoSubError,
                IsFile() ? s_szFile : s_szURL,
                (LPCTSTR)m_str
                );
        }
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}


int
CCustomError::OrderByErrorNum(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two custom errors against each other, and sort on Number first, and
    order secondarily.

Arguments:

    const CObjectPlus * pobAccess : This really refers to another
                                    CCustomError to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    const CCustomError * pob = (CCustomError *)pobAccess;

    if (pob->m_nError != m_nError)
    {
		// sort by error in small to big order
        return m_nError - pob->m_nError;
    }

    //
    // Sort by sub error in small to big order
    //
    return m_nSubError - pob->m_nSubError;
}




//
// Custom Errors property page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CCustomErrorDlg::CCustomErrorDlg(
    IN OUT CCustomError * pErr,
    IN BOOL fLocal,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Error editing dialog

Arguments:

    CCustomError * pErr   : Error definition to be edited
    BOOL fLocal     : TRUE if the current computer is local
    CWnd * pParent  : Optional parent window or NULL

Return Value:

    N/A

--*/
    : CDialog(CCustomErrorDlg::IDD, pParent),
      m_fLocal(fLocal),
      m_pErr(pErr),
      m_nMessageType(pErr->m_nType),
      m_strTextFile(pErr->m_str),
      m_strDefText(pErr->m_strDefault)
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CCustomErrorDlg)
    m_nMessageType = -1;
    m_strTextFile = _T("");
    m_strDefText = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    VERIFY(m_strFile.LoadString(IDS_FILE_PROMPT));
    VERIFY(m_strURL.LoadString(IDS_URL_PROMPT));
}



void 
CCustomErrorDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCustomErrorDlg)
    DDX_CBIndex(pDX, IDC_COMBO_MESSAGE_TYPE, m_nMessageType);
    DDX_Text(pDX, IDC_STATIC_DEF_TEXT, m_strDefText);
    DDX_Control(pDX, IDC_EDIT_TEXT_FILE, m_edit_TextFile);
    DDX_Control(pDX, IDC_STATIC_SUB_PROMPT, m_static_SubErrorPrompt);
    DDX_Control(pDX, IDC_STATIC_SUB_ERROR_CODE, m_static_SubError);
    DDX_Control(pDX, IDC_STATIC_TEXT_FILE_PROMT, m_static_TextFilePrompt);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_COMBO_MESSAGE_TYPE, m_combo_MessageType);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP

    DDX_TextBalloon(pDX, IDC_STATIC_ERROR_CODE, m_pErr->m_nError);
    DDX_TextBalloon(pDX, IDC_STATIC_SUB_ERROR_CODE, m_pErr->m_nSubError);

    DDX_Text(pDX, IDC_EDIT_TEXT_FILE, m_strTextFile);
    m_strTextFile.TrimLeft();
    m_strTextFile.TrimRight();
    if (pDX->m_bSaveAndValidate)
    {
        if (m_nMessageType == CCustomError::ERT_FILE)
        {
			DDV_FilePath(pDX, m_strTextFile, m_fLocal);
        }
        else if (m_nMessageType == CCustomError::ERT_URL)
        {
            // We are accepting only absolute URLs within the site, i.e. /foo/bar/error.html
            if (!IsRelURLPath(m_strTextFile))
            {
                pDX->PrepareEditCtrl(IDC_EDIT_TEXT_FILE);
                DDV_ShowBalloonAndFail(pDX, IDS_BAD_ERROR_URL);
            }
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CCustomErrorDlg, CDialog)
    //{{AFX_MSG_MAP(CCustomErrorDlg)
    ON_CBN_SELCHANGE(IDC_COMBO_MESSAGE_TYPE, OnSelchangeComboMessageType)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_EN_CHANGE(IDC_EDIT_TEXT_FILE, OnChangeEditTextFile)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
CCustomErrorDlg::SetControlStates()
/*++

Routine Description:

    Set the enabled states of the dialog controls depending on the current
    state of the dialog

Arguments:

    None

Return Value:

    TRUE if file/url is selected, FALSE otherwise

--*/
{
    int nCurSel = m_combo_MessageType.GetCurSel();
    BOOL fFile = nCurSel == CCustomError::ERT_FILE;
    BOOL fDefault = nCurSel == CCustomError::ERT_DEFAULT;
    
    ActivateControl(m_button_Browse, m_fLocal && fFile);

    ActivateControl(m_edit_TextFile,         !fDefault);
    ActivateControl(m_static_TextFilePrompt, !fDefault);
    m_static_TextFilePrompt.SetWindowText(fFile ? m_strFile : m_strURL);

    m_button_OK.EnableWindow(fDefault
        || m_edit_TextFile.GetWindowTextLength() > 0);

    return !fDefault;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CCustomErrorDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Browsing available locally only
    //
    m_button_Browse.EnableWindow(m_fLocal);

    CString str;
    VERIFY(str.LoadString(IDS_DEFAULT_ERROR));
    m_combo_MessageType.AddString(str);
    VERIFY(str.LoadString(IDS_FILE));
    m_combo_MessageType.AddString(str);

    if (m_pErr->URLSupported() || m_nMessageType == CCustomError::ERT_URL)
    {
        VERIFY(str.LoadString(IDS_URL));
        m_combo_MessageType.AddString(str);
    }

    m_combo_MessageType.SetCurSel(m_nMessageType);

    if (m_pErr->m_nSubError == 0)
    {
        DeActivateControl(m_static_SubErrorPrompt);
        DeActivateControl(m_static_SubError);
    }

    SetControlStates();
//	if (m_nMessageType == CCustomError::ERT_FILE)
//	{
// #ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
//		LimitInputPath(CONTROL_HWND(IDC_EDIT_TEXT_FILE),TRUE);
// #else
//		LimitInputPath(CONTROL_HWND(IDC_EDIT_TEXT_FILE),FALSE);
// #endif
//	}
//	else if (m_nMessageType == CCustomError::ERT_URL)
//	{
//	}
    
    return TRUE;
}



void 
CCustomErrorDlg::OnSelchangeComboMessageType()
/*++

Routine Description:

    Handle change in message type combo box

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = m_combo_MessageType.GetCurSel();
    if (m_nMessageType == nSel)
    {
        //
        // Selection didn't change
        //
        return;
    }

    m_nMessageType = nSel;

    if (SetControlStates())
    {
        m_edit_TextFile.SetWindowText(_T(""));
        m_edit_TextFile.SetFocus();
    }
}



void 
CCustomErrorDlg::OnChangeEditTextFile()
/*++

Routine Description:

    Handle change in text/file edit box

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CCustomErrorDlg::OnOK()
/*++

Routine Description:

    Handle the OK button being pressed

Arguments:
    
    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        m_pErr->m_nType = (CCustomError::ERT)m_nMessageType;
        m_pErr->m_str = m_strTextFile;
    
        CDialog::OnOK();
    }
}

void 
CCustomErrorDlg::OnButtonBrowse()
/*++

Routine Description:

    Browse for HTML File
    
Arguments:

    None
    
Return Value:

    None 

--*/
{
    ASSERT(m_fLocal);

    //
    // popup the file dialog and let the user select the error htm file
    //
    CString str;
    str.LoadString(IDS_HTML_MASK);
    CFileDialog dlgBrowse(TRUE, NULL, NULL, OFN_HIDEREADONLY, str, this);
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

    if (dlgBrowse.DoModal() == IDOK)
    {
        m_pErr->m_str = dlgBrowse.GetPathName();
        m_edit_TextFile.SetWindowText(m_pErr->m_str);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\docum.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        docum.h

   Abstract:
        WWW Documents Page Definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __DOCUM_H__
#define __DOCUM_H__

class CW3DocumentsPage;

class CAddDefDocDlg : public CDialog
/*++

Class Description:
    Add default document dialog

Public Interface:
    CAddDefDocDlg       : Constructor
    GetDefDocument      : Get the default document entered

--*/
{
//
// Construction
//
public:
    CAddDefDocDlg(IN CWnd * pParent = NULL);

//
// Access:
//
public:                                                   
    CString & GetDefDocument() { return m_strDefDocument; }
	CW3DocumentsPage * m_pParent;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAddDefDocDlg)
    enum { IDD = IDD_DEFAULT_DOCUMENT };
    CString m_strDefDocument;
    CButton m_button_Ok;
    CEdit   m_edit_DefDocument;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddDefDocDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddDefDocDlg)
    afx_msg void OnChangeEditDefDocument();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


class CW3DocumentsPage : public CInetPropertyPage
/*++

Class Description:

    Documents property page

Public Interface:

    CW3DocumentsPage      : Constructor
    ~CW3DocumentsPage     : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3DocumentsPage)

//
// Construction
//
public:
    CW3DocumentsPage(CInetPropertySheet * pSheet = NULL);
    ~CW3DocumentsPage();
    BOOL DocExistsInList(LPCTSTR lpDoc);

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3DocumentsPage)
    enum { IDD = IDD_DIRECTORY_DOCUMENTS };
    BOOL     m_fEnableDefaultDocument;
    BOOL     m_fEnableFooter;
    CString  m_strFooter;
    CEdit    m_edit_Footer;
    CButton  m_check_EnableDefaultDocument;
    CButton  m_check_EnableFooter;
    CButton  m_button_Add;
    CButton  m_button_Remove;
    CButton  m_button_Browse;
    CListBox m_list_DefDocuments;
    //}}AFX_DATA

    DWORD       m_dwDirBrowsing;
    DWORD       m_dwBitRangeDirBrowsing;
    CString     m_strDefaultDocument;

    CUpButton   m_button_Up;
    CDownButton m_button_Down;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3DocumentsPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3DocumentsPage)
    afx_msg void OnCheckEnableDefaultDocument();
    afx_msg void OnCheckEnableDocumentFooter();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonUp();
    afx_msg void OnButtonDown();
    afx_msg void OnSelchangeListDefaultDocument();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    BOOL SetDefDocumentState(BOOL fEnabled);
    BOOL SetDocFooterState(BOOL fEnabled);
    BOOL SetRemoveState();
    BOOL StringFromListBox();
    void SetUpDownStates();
    void ExchangeDocuments(int nLow, int nHigh);
    void MakeFooterCommand(CString & strFooter);
    void ParseFooterCommand(CString & strFooter);
    void StringToListBox();

protected:
    static const LPCTSTR s_lpstrSep;
    static const LPCTSTR s_lpstrFILE;
    static const LPCTSTR s_lpstrSTRING;
    static const LPCTSTR s_lpstrURL;
};


#endif // __DOCUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\errors.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errors.cpp

   Abstract:

        HTTP errors property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "errors.h"
#include "errordlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CCustomErrorsListBox : a listbox of CCustomError objects
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Column width relative weights
//
#define WT_HTTP_ERROR     3
#define WT_OUTPUT_TYPE    2
#define WT_CONTENTS       8

//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Errors");

//
// Key under w3svc where the error descriptions live
//
const TCHAR g_cszErrorLocation[] = _T("Info");



IMPLEMENT_DYNAMIC(CCustomErrorsListBox, CHeaderListBox);



const int CCustomErrorsListBox::nBitmaps = 3;



CCustomErrorsListBox::CCustomErrorsListBox(
    IN UINT nIDDefault,
    IN UINT nIDFile,
    IN UINT nIDURL
    )
/*++

Routine Description:

    Error listbox constructor

Arguments:

    UINT nIDDefault : String ID for 'default'
    UINT nIDFile    : String ID for 'file'
    UINT nIDURL     : String ID for 'URL'

--*/
     : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    VERIFY(m_str[CCustomError::ERT_DEFAULT].LoadString(nIDDefault));
    VERIFY(m_str[CCustomError::ERT_FILE].LoadString(nIDFile));
    VERIFY(m_str[CCustomError::ERT_URL].LoadString(nIDURL));
}


void
CCustomErrorsListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CCustomError * p = (CCustomError *)ds.m_ItemData;
    ASSERT(p != NULL);

    DrawBitmap(ds, 0, p->m_nType);

    CString strError, strText;

    if (p->m_nSubError > 0)
    {
        strError.Format(_T("%d;%d"), p->m_nError, p->m_nSubError);
    }
    else
    {
        strError.Format(_T("%d"), p->m_nError);
    }

    ColumnText(ds, 0, TRUE, strError);
    ColumnText(ds, 1, FALSE, m_str[p->m_nType] );

    if (p->IsDefault())
    {
        strText.Format(_T("\"%s\""), p->m_strDefault);
    }
    else
    {
        strText = p->m_str;
    }

    ColumnText(ds, 2, FALSE, strText);
}



/* virtual */
BOOL
CCustomErrorsListBox::Initialize()
/*++

Routine Description:

    initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE if initialized successfully, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    HINSTANCE hInst = AfxGetResourceHandle();
    InsertColumn(0, WT_HTTP_ERROR, IDS_HTTP_ERROR, hInst);
    InsertColumn(1, WT_OUTPUT_TYPE, IDS_OUTPUT_TYPE, hInst);
    InsertColumn(2, WT_CONTENTS, IDS_CONTENTS, hInst);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    SetRedraw(TRUE);

    return TRUE;
}



CHTTPErrorDescriptions::CHTTPErrorDescriptions(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Constructor for default errors object.  This fetches the default
    error definitions

Arguments:

    LPCTSTR lpServerName : Server name

Return Value:

    None

--*/
    : CMetaProperties(
        QueryAuthInfo(),
        CMetabasePath(g_cszSvc, MASTER_INSTANCE, g_cszErrorLocation)
        )
{       
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = MULTISZ_METADATA;
}



/* virtual */
void
CHTTPErrorDescriptions::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_CUSTOM_ERROR_DESC, m_strlErrorDescriptions)
    END_PARSE_META_RECORDS
}



//
// Errors property page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CW3ErrorsPage, CInetPropertyPage)



CW3ErrorsPage::CW3ErrorsPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW error property page

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A


--*/
    : CInetPropertyPage(CW3ErrorsPage::IDD, pSheet),
      m_list_Errors(IDS_DEFAULT_ERROR, IDS_FILE, IDS_URL),
      m_ListBoxRes(IDB_ERRORS, m_list_Errors.nBitmaps),
      m_strlCustomErrors(),
      m_strlErrorDescriptions(),
      m_oblErrors()
{
    //{{AFX_DATA_INIT(CW3ErrorsPage)
    //}}AFX_DATA_INIT

    m_list_Errors.AttachResources(&m_ListBoxRes);
}



CW3ErrorsPage::~CW3ErrorsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}

void
CW3ErrorsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3ErrorsPage)
    DDX_Control(pDX, IDC_BUTTON_SET_TO_DEFAULT, m_button_SetDefault);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_ERRORS, m_list_Errors);

    if (pDX->m_bSaveAndValidate)
    {
        CError err(StoreErrors());
        if (err.MessageBoxOnFailure(m_hWnd))
        {
            pDX->Fail();
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3ErrorsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3ErrorsPage)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_SET_TO_DEFAULT, OnButtonSetToDefault)
    ON_LBN_DBLCLK(IDC_LIST_ERRORS, OnDblclkListErrors)
    ON_LBN_SELCHANGE(IDC_LIST_ERRORS, OnSelchangeListErrors)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CW3ErrorsPage::FillListBox()
/*++

Routine Description:

    Populate the listbox with the directory entries

Arguments:

    None

Return Value:

    None

--*/
{
    CObListIter obli(m_oblErrors);
    CCustomError * pError;

    //
    // Remember the selection.
    //
    int nCurSel = m_list_Errors.GetCurSel();

    m_list_Errors.SetRedraw(FALSE);
    m_list_Errors.ResetContent();

    int cItems = 0;

    for (/**/; pError = (CCustomError *)obli.Next(); ++cItems)
    {
        m_list_Errors.AddItem(pError);
    }

    m_list_Errors.SetRedraw(TRUE);
    m_list_Errors.SetCurSel(nCurSel);
}


DWORD
CW3ErrorsPage::SortCustomErrorsList()
{
    BeginWaitCursor();
    DWORD dw =  m_oblErrors.Sort(
		(CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CCustomError::OrderByErrorNum);
    EndWaitCursor();
    return dw;
}

HRESULT
CW3ErrorsPage::StoreErrors()
/*++

Routine Description:

    Build errors stringlist from the error oblist built up.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    try
    {
        m_strlCustomErrors.RemoveAll();
        POSITION pos = m_oblErrors.GetHeadPosition();

        while(pos)
        {
            CCustomError * pErr = (CCustomError *)m_oblErrors.GetNext(pos);
            if (!pErr->IsDefault())
            {
                CString str;
                pErr->BuildErrorString(str);
                m_strlCustomErrors.AddTail(str);
            }
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}



CCustomError *
CW3ErrorsPage::FindError(
    IN UINT nError,
    IN UINT nSubError
    )
/*++

Routine Description:

    Find error in the list with the given error code and suberror code

Arguments:

    UINT nError     : Error code
    UINT nSubError  : Sub error code

Return Value:

    Pointer to the error or NULL if not found.

--*/
{
    CCustomError * pErr = NULL;

    POSITION pos = m_oblErrors.GetHeadPosition();
    while(pos)
    {
        pErr = (CCustomError *)m_oblErrors.GetNext(pos);
        ASSERT(pErr != NULL);
        if (pErr->m_nError == nError && pErr->m_nSubError == nSubError)
        {
            //
            // Found it!
            //
            return pErr;
        }
    }

    //
    // Not found!
    //
    return NULL;
}



HRESULT
CW3ErrorsPage::FetchErrors()
/*++

Routine Description:

    Build up the errors list

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    CWaitCursor wait;

    do
    {
        try
        {
            //
            // First get the default descriptions
            //
            CHTTPErrorDescriptions ed(QueryServerName());
            err = ed.LoadData();
            if (err.Failed())
            {
                break;
            }

            if (!ed.GetErrorDescriptions().IsEmpty())
            {
                POSITION pos = ed.GetErrorDescriptions().GetHeadPosition();

                while(pos)
                {
                    CString & str = ed.GetErrorDescriptions().GetNext(pos);
                    m_oblErrors.AddTail(new CCustomError(str));
                }
            }
            else
            {
                DoHelpMessageBox(m_hWnd,IDS_NO_DEF_ERRORS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
                break;
            }

            //
            // Now match up the overrides if any
            //
            POSITION pos = m_strlCustomErrors.GetHeadPosition();
            while(pos)
            {
                CString & strError = m_strlCustomErrors.GetNext(pos);

                TRACEEOLID(strError);

                UINT nError;
                UINT nSubError;
                CCustomError::ERT nType;
                CString str;
                CCustomError * pErr = NULL;

                if (CCustomError::CrackErrorString(
                    strError, 
                    nError, 
                    nSubError, 
                    nType, 
                    str
                    ))
                {
                    pErr = FindError(nError, nSubError);
                }

                if (pErr != NULL)
                {
                    pErr->SetValue(nType, str);
                }
                else
                {
                    CString strFmt;
                    strFmt.LoadString(IDS_BAD_ERROR);

                    str.Format(strFmt, nError, nSubError);
                    ::AfxMessageBox(str);
                    break;
                }
            }

			SortCustomErrorsList();
            FillListBox();
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }
    while(FALSE);

    return err;
}



void
CW3ErrorsPage::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on the state of
    the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    CCustomError * pErr = GetSelectedListItem();

    m_button_Edit.EnableWindow(pErr != NULL);
    m_button_SetDefault.EnableWindow(m_list_Errors.GetSelCount() > 0);
}


INT_PTR
CW3ErrorsPage::ShowPropertyDialog()
/*++

Routine Description:

    Display the add/edit dialog.  The return
    value is the value returned by the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel;
    CCustomError * pErr = GetSelectedListItem(&nCurSel);

    if (pErr == NULL)
    {
        //
        // Must be from a double click on extended selection
        //
        return IDCANCEL;
    }
    
    CCustomErrorDlg dlgError(pErr, IsLocal(), this);
    INT_PTR nReturn = dlgError.DoModal();

    if (nReturn == IDOK)
    {
        //
        // Re-display the text
        //
        m_list_Errors.InvalidateSelection(nCurSel);
        SetModified(TRUE);
    }

    return nReturn;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3ErrorsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_list_Errors.Initialize();

    //
    // Build filters oblist
    //
    CError err(FetchErrors());
    err.MessageBoxOnFailure(m_hWnd);
    SetControlStates();

    return TRUE;
}



void
CW3ErrorsPage::OnButtonEdit()
/*++

Routine Description:

    'edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertyDialog() == IDOK)
    {
        SetControlStates();
        SetModified(TRUE);
    }
}



void
CW3ErrorsPage::OnButtonSetToDefault()
/*++

Routine Description:

    'set to default' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Apply to each selected item
    //
    m_list_Errors.SetRedraw(FALSE);

    int nSel = 0;
    int cChanges = 0;
    CCustomError * pErr;
    while ((pErr = GetNextSelectedItem(&nSel)) != NULL)
    {
        if (!pErr->IsDefault())
        {
            //
            // Force a redraw of the current item
            //
            pErr->MakeDefault();
            m_list_Errors.InvalidateSelection(nSel);
            ++cChanges;
        }

        ++nSel;
    }

    if (cChanges)
    {    
        SetModified(TRUE);
    }

    m_list_Errors.SetRedraw(TRUE);
    SetControlStates();
}



void
CW3ErrorsPage::OnDblclkListErrors()
/*++

Routine Description:

    error list 'double click' handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CW3ErrorsPage::OnSelchangeListErrors()
/*++

Routine Description:

    error list selection change handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



/* virtual */
HRESULT
CW3ErrorsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_strlCustomErrors);
    END_META_DIR_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3ErrorsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 errors page now...");

    CError err;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_strlCustomErrors)
    END_META_DIR_WRITE(err)

	if (err.Succeeded())
	{
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
	}

    EndWaitCursor();

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\facc.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        facc.h

   Abstract:

        FTP Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FACC_H__
#define __FACC_H__

class CFtpAccountsPage : public CInetPropertyPage
{
/*++

Class Description:

    FTP Service property page

Public Interface:

    CFtpAccountsPage  : Constructor
    ~CFtpAccountsPage : Destructor

--*/
    DECLARE_DYNCREATE(CFtpAccountsPage)

//
// Constructor/Destructor
//
public:
    CFtpAccountsPage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpAccountsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpAccountsPage)
    enum { IDD = IDD_FTP_ACCOUNTS };
    BOOL    m_fAllowAnonymous;
    BOOL    m_fOnlyAnonymous;
    BOOL    m_fPasswordSync;
    CString m_strUserName;
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    CStatic m_static_Password;
    CStatic m_static_UserName;
    CStatic m_static_AccountPrompt;
    CButton m_button_CheckPassword;
    CButton m_button_Browse;
    CButton m_button_CurrentSessions;
    CButton m_chk_PasswordSync;
    CButton m_chk_AllowAnymous;
    CButton m_chk_OnlyAnonymous;
    //}}AFX_DATA

    CStrPassword m_strPassword;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpAccountsPage)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    void SetControlStates(BOOL fAllowAnonymous);

    //{{AFX_MSG(CFtpAccountsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnButtonBrowseUser();
    afx_msg void OnCheckAllowAnonymous();
    afx_msg void OnCheckAllowOnlyAnonymous();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnSelchangeListAdministrators();
    afx_msg void OnChangeEditUsername();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fUserNameChanged;
    CString m_strServerName;
};



#endif // __FACC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\facc.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        facc.cpp

   Abstract:
        FTP Accounts Property Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "ftpsht.h"
#include "facc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CFtpAccountsPage, CInetPropertyPage)

CFtpAccountsPage::CFtpAccountsPage(
    IN CInetPropertySheet * pSheet
    )
    : CInetPropertyPage(CFtpAccountsPage::IDD, pSheet),
      m_fUserNameChanged(FALSE),
	  m_fPasswordSync(FALSE),
      m_fPasswordSyncChanged(FALSE),
      m_fPasswordSyncMsgShown(TRUE)
{
#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
#endif // _DEBUG
}

CFtpAccountsPage::~CFtpAccountsPage()
{
}

void
CFtpAccountsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpAccountsPage)
    DDX_Check(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_fAllowAnonymous);
    DDX_Check(pDX, IDC_CHECK_ONLY_ANYMOUS, m_fOnlyAnonymous);
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_STATIC_PW, m_static_Password);
    DDX_Control(pDX, IDC_STATIC_USERNAME, m_static_UserName);
    DDX_Control(pDX, IDC_STATIC_ACCOUNT_PROMPT, m_static_AccountPrompt);
    DDX_Control(pDX, IDC_BUTTON_CHECK_PASSWORD, m_button_CheckPassword);
    DDX_Control(pDX, IDC_BUTTON_BROWSE_USER, m_button_Browse);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Control(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_chk_AllowAnymous);
    DDX_Control(pDX, IDC_CHECK_ONLY_ANYMOUS, m_chk_OnlyAnonymous);
    //}}AFX_DATA_MAP

    //
    // Set password/username only during load stage,
    // or if saving when allowing anonymous logons
    //
    if (!pDX->m_bSaveAndValidate || m_fAllowAnonymous)
    {
        DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
        DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);

        //
        // Some people have a tendency to add "\\" before
        // the computer name in user accounts.  Fix this here.
        //
        m_strUserName.TrimLeft();

        while (*m_strUserName == '\\')
        {
            m_strUserName = m_strUserName.Mid(2);
        }


        //
        // Display the remote password sync message if
        // password sync is on, the account is not local,
        // password sync has changed or username has changed
        // and the message hasn't already be shown.
        //
        if (pDX->m_bSaveAndValidate)
		{
			if (GetSheet()->QueryMajorVersion() < 6)
			{
				if (m_fPasswordSync 
					&& !IsLocalAccount(m_strUserName)
					&& (m_fPasswordSyncChanged || m_fUserNameChanged)
					&& !m_fPasswordSyncMsgShown
					)
				{
					//
					// Don't show it again
					//
					m_fPasswordSyncMsgShown = TRUE;
					if (!NoYesMessageBox(IDS_WRN_PWSYNC))
					{
						pDX->Fail();
					}
				}
			}
        }
		//DDX_Password(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
        DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);

        if (!m_fPasswordSync)
        {
            //DDV_MaxCharsBalloon(pDX, m_strPassword, PWLEN);
            DDV_MaxCharsBalloon_SecuredString(pDX, m_strPassword, PWLEN);
        }
    }

}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpAccountsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpAccountsPage)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_ALLOW_ANONYMOUS, OnCheckAllowAnonymous)
    ON_BN_CLICKED(IDC_CHECK_ONLY_ANYMOUS, OnCheckAllowOnlyAnonymous)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USER, OnButtonBrowseUser)
END_MESSAGE_MAP()



void
CFtpAccountsPage::SetControlStates(
    IN BOOL fAllowAnonymous
    )
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    BOOL fAllowAnonymous : If TRUE, 'allow anonymous' is on.

Return Value:

    None

--*/
{
    m_static_Password.EnableWindow(fAllowAnonymous && !m_fPasswordSync && HasAdminAccess());
    m_edit_Password.EnableWindow(fAllowAnonymous && !m_fPasswordSync && HasAdminAccess());
    m_button_CheckPassword.EnableWindow(fAllowAnonymous && !m_fPasswordSync && HasAdminAccess());
    m_static_AccountPrompt.EnableWindow(fAllowAnonymous);
    m_static_UserName.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_edit_UserName.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_button_Browse.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_chk_PasswordSync.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_chk_OnlyAnonymous.EnableWindow(fAllowAnonymous);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL
CFtpAccountsPage::OnInitDialog()
{
    CInetPropertyPage::OnInitDialog();

    CWaitCursor wait;

	if (GetSheet()->QueryMajorVersion() >= 6)
	{
		GetDlgItem(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION)->EnableWindow(FALSE);
		GetDlgItem(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION)->ShowWindow(SW_HIDE);
	}
	else
	{
		m_fPasswordSyncMsgShown = FALSE;
	}
    BOOL bADIsolated = ((CFtpSheet *)GetSheet())->HasADUserIsolation();
    ::EnableWindow(CONTROL_HWND(IDC_CHECK_ALLOW_ANONYMOUS), !bADIsolated);
    SetControlStates(m_fAllowAnonymous);

    return TRUE;
}



/* virtual */
HRESULT
CFtpAccountsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_strUserName);
        FETCH_INST_DATA_FROM_SHEET_PASSWORD(m_strPassword);
        if (!((CFtpSheet *)GetSheet())->HasADUserIsolation())
        {
            FETCH_INST_DATA_FROM_SHEET(m_fAllowAnonymous);
        }
        else
        {
            m_fAllowAnonymous = FALSE;
        }
        FETCH_INST_DATA_FROM_SHEET(m_fOnlyAnonymous);
		if (GetSheet()->QueryMajorVersion() < 6)
		{
			FETCH_INST_DATA_FROM_SHEET(m_fPasswordSync);
		}
    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CFtpAccountsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    CError err;
    BeginWaitCursor();
    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_strUserName)
        if (!((CFtpSheet *)GetSheet())->HasADUserIsolation())
        {
            STORE_INST_DATA_ON_SHEET(m_fOnlyAnonymous)
            STORE_INST_DATA_ON_SHEET(m_fAllowAnonymous)
        }
		if (GetSheet()->QueryMajorVersion() < 6)
		{
			STORE_INST_DATA_ON_SHEET(m_fPasswordSync)
			if (m_fPasswordSync)
			{
				//
				// Delete password
				//
				// CODEWORK: Shouldn't need to know ID number.
				// Implement m_fDelete flag in CMP template maybe?
				//
				FLAG_INST_DATA_FOR_DELETION(MD_ANONYMOUS_PWD);
			}
			else
			{
				STORE_INST_DATA_ON_SHEET(m_strPassword);
			}
		}
		else
		{
			STORE_INST_DATA_ON_SHEET(m_strPassword);
		}
    END_META_INST_WRITE(err)
    EndWaitCursor();

    return err;
}



void
CFtpAccountsPage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);
}



void
CFtpAccountsPage::OnCheckAllowAnonymous()
/*++

Routine Description:

    Respond to 'allow anonymous' checkbox being pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_chk_AllowAnymous.GetCheck() == 0)
    {
        //
        // Show security warning
        //
        CClearTxtDlg dlg;

        if (dlg.DoModal() != IDOK)
        {
            m_chk_AllowAnymous.SetCheck(1);
            return;
        }
    }

    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);
    OnItemChanged();
}



void
CFtpAccountsPage::OnCheckAllowOnlyAnonymous()
/*++

Routine Description:

    Respond to 'allow only anonymous' checkbox being pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_chk_OnlyAnonymous.GetCheck() == 0)
    {
        //
        // Show security warning
        //
        CClearTxtDlg dlg;

        if (dlg.DoModal() != IDOK)
        {
            m_chk_OnlyAnonymous.SetCheck(1);
            return;
        }
    }

    OnItemChanged();
}

void 
CFtpAccountsPage::OnButtonBrowseUser()
/*++

Routine Description:

    User browser button has been pressed.  Browse for IUSR account name

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);
        if (GetSheet()->QueryMajorVersion() >= 6 || !(m_fPasswordSync = IsLocalAccount(str)))
        {
            m_edit_Password.SetWindowText(_T(""));
            m_edit_Password.SetFocus();
        }
	    if (GetSheet()->QueryMajorVersion() < 6)
		{
			m_chk_PasswordSync.SetCheck(m_fPasswordSync);
		}
        OnItemChanged();
    }
}



void 
CFtpAccountsPage::OnButtonCheckPassword() 
/*++

Routine Description:

    Check password button has been pressed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CString csTempPassword;
    m_strPassword.CopyTo(csTempPassword);
    CError err(CComAuthInfo::VerifyUserPassword(m_strUserName, csTempPassword));

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        DoHelpMessageBox(m_hWnd,IDS_PASSWORD_OK, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
    }
}

void 
CFtpAccountsPage::OnCheckEnablePwSynchronization() 
/*++

Routine Description:

    Handler for 'enable password synchronization' checkbox press

Arguments:

    None

Return Value:

    None

--*/
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);

    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}

void 
CFtpAccountsPage::OnChangeEditUsername() 
/*++

Routine description:

    Handler for 'username' edit box change messages

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\errors.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errors.h

   Abstract:

        HTTP errors property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Forward definitions
//
class CCustomError;



class CCustomErrorsListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of CCustomError objects

Public Interface:

    CCustomErrorsListBox    : Constructor

    GetItem                 : Get error object at index
    AddItem                 : Add item to listbox
    InsertItem              : Insert item into the listbox
    Initialize              : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CCustomErrorsListBox);

public:
    static const nBitmaps;  // Number of bitmaps

public:
    CCustomErrorsListBox(UINT nIDDefault, UINT nIDFile, UINT nIDURL);

public:
    CCustomError * GetItem(UINT nIndex);
    int AddItem(CCustomError * pItem);
    int InsertItem(int nPos, CCustomError * pItem);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    CString m_str[3];
};



class CHTTPErrorDescriptions : public CMetaProperties
/*++

Class Description:

    List of HTTP error descriptions

Public Interface:

    CHTTPErrorDescriptions  : Constructor

--*/
{
//
// Constructor
//
public:
    CHTTPErrorDescriptions(LPCTSTR lpServerName);

//
// Access
//
public:
    CStringList & GetErrorDescriptions() { return m_strlErrorDescriptions; }

protected:
    virtual void ParseFields();

//
// Data
//
private:
    MP_CStringListEx m_strlErrorDescriptions;
};



class CW3ErrorsPage : public CInetPropertyPage
/*++

Class Description:

    WWW Errors property page

Public Interface:

    CW3ErrorsPage       : Constructor
    CW3ErrorsPage       : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3ErrorsPage)

//
// Construction
//
public:
    CW3ErrorsPage(CInetPropertySheet * pSheet = NULL);
    ~CW3ErrorsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3ErrorsPage)
    enum { IDD = IDD_DIRECTORY_ERRORS };
    CButton m_button_SetDefault;
    CButton m_button_Edit;
    //}}AFX_DATA

    CCustomErrorsListBox  m_list_Errors;
    CStringListEx         m_strlCustomErrors;
    CStringListEx         m_strlErrorDescriptions;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3ErrorsPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3ErrorsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnDblclkListErrors();
    afx_msg void OnSelchangeListErrors();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonSetToDefault();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    void FillListBox();
    INT_PTR ShowPropertyDialog();
    CCustomError * GetSelectedListItem(int * pnSel = NULL);
    CCustomError * GetNextSelectedItem(int * pnStartingIndex);
    CCustomError * FindError(UINT nError, UINT nSubError);
    HRESULT FetchErrors();
    HRESULT StoreErrors();
	DWORD SortCustomErrorsList();

private:
    CRMCListBoxResources m_ListBoxRes;
    CObListPlus m_oblErrors;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CCustomError * CCustomErrorsListBox::GetItem(UINT nIndex)
{
    return (CCustomError *)GetItemDataPtr(nIndex);
}

inline int CCustomErrorsListBox::AddItem(CCustomError * pItem)
{
    return AddString((LPCTSTR)pItem);
}

inline int CCustomErrorsListBox::InsertItem(int nPos, CCustomError * pItem)
{
    return InsertString(nPos, (LPCTSTR)pItem);
}

inline CCustomError * CW3ErrorsPage ::GetSelectedListItem(
    OUT int * pnSel OPTIONAL
    )
{
    return (CCustomError *)m_list_Errors.GetSelectedListItem(pnSel);
}

inline CCustomError * CW3ErrorsPage::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CCustomError *)m_list_Errors.GetNextSelectedItem(pnStartingIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\filters.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        filters.cpp

   Abstract:
        WWW Filters Property Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "filters.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Column width relative weights
//
#define WT_STATUS             (7)
#define WT_FILTER            (12)
#define WT_PRIORITY           (8)

//
// Bitmap indices
//
enum
{
    BMPID_DISABLED,
    BMPID_LOADED,
    BMPID_UNLOADED,
    BMPID_NOT_COMMITTED,
    /**/
    BMPID_TOTAL
};

IMPLEMENT_DYNAMIC(CFiltersListBox, CListCtrl);

CFiltersListBox::CFiltersListBox()
{
    VERIFY(m_str[FLTR_PR_INVALID].LoadString(IDS_UNKNOWN_PRIORITY));
    VERIFY(m_str[FLTR_PR_LOW].LoadString(IDS_LOW));
    VERIFY(m_str[FLTR_PR_MEDIUM].LoadString(IDS_MEDIUM));
    VERIFY(m_str[FLTR_PR_HIGH].LoadString(IDS_HIGH));
}

CIISFilter * 
CFiltersListBox::GetItem(UINT nIndex)
{
    return (CIISFilter *)GetItemData(nIndex);
}

void
CFiltersListBox::SelectItem(int idx, BOOL bSelect)
{
    UINT state = bSelect ? LVIS_SELECTED | LVIS_FOCUSED : 0;
    SetItemState(idx, state, LVIS_SELECTED | LVIS_FOCUSED);
}

//void
//CFiltersListBox::MoveSelectedItem(int direction)
//{
//	// This item should be selected and we want to keep selection on it
//	int idx = GetSelectionMark();
//	int count = GetItemCount();
//	// sanity check
//	ASSERT(idx != -1);
//	ASSERT((direction < 0 && idx + direction >= 0) || (direction > 0 && idx + direction <= count));
//	CIISFilter * p = GetItem(idx);
//	DeleteItem(idx);
//	InsertItem(idx + direction, p);
//	SelectItem(idx + direction, TRUE);
//}

int
CFiltersListBox::InsertItem(int idx, CIISFilter * p)
{
    int n;
    if (p->IsDirty() || p->m_dwState == MD_FILTER_STATE_UNDEFINED)
    {
        n = BMPID_NOT_COMMITTED;
    }
    else if (!p->IsEnabled())
    {   
        n = BMPID_DISABLED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_LOADED)
    {
        n = BMPID_LOADED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_UNLOADED)
    {
        n = BMPID_UNLOADED;
    }
    else
    {
        n = BMPID_DISABLED;
    }
    int i = CListCtrl::InsertItem(LVIF_PARAM | LVIF_IMAGE, idx, NULL, 0, 0, n, (LPARAM)p);
    if (i != -1)
    {
        BOOL res = SetItemText(idx, 1, p->m_strName);
        if (p->m_nPriority >= FLTR_PR_INVALID && p->m_nPriority <= FLTR_PR_HIGH)
        {
            res = SetItemText(idx, 2, m_str[p->m_nPriority]);
        }
        else
        {
            //
            // Just in case
            //
            res = SetItemText(idx, 2, m_str[FLTR_PR_INVALID]);
        }
    }
    return i;
}

int 
CFiltersListBox::AddItem(CIISFilter * p)
{
    int count = GetItemCount();
    return InsertItem(count, p);
}

int 
CFiltersListBox::SetListItem(int idx, CIISFilter * p)
{
    int count = GetItemCount();
    int n;

    if (p->IsDirty() || p->m_dwState == MD_FILTER_STATE_UNDEFINED)
    {
        n = BMPID_NOT_COMMITTED;
    }
    else if (!p->IsEnabled())
    {   
        n = BMPID_DISABLED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_LOADED)
    {
        n = BMPID_LOADED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_UNLOADED)
    {
        n = BMPID_UNLOADED;
    }
    else
    {
        n = BMPID_DISABLED;
    }
    int i = SetItem(idx, 0, LVIF_PARAM | LVIF_IMAGE, NULL, n, 0, 0, (LPARAM)p);
    if (i != 0)
    {
        BOOL res = SetItemText(idx, 1, p->m_strName);
        if (p->m_nPriority >= FLTR_PR_INVALID && p->m_nPriority <= FLTR_PR_HIGH)
        {
            res = SetItemText(idx, 2, m_str[p->m_nPriority]);
        }
        else
        {
            res = SetItemText(idx, 2, m_str[FLTR_PR_INVALID]);
        }
    }
    return idx;
}

BOOL 
CFiltersListBox::Initialize()
{
    HIMAGELIST hImage 
        = ImageList_LoadImage(AfxGetResourceHandle(), 
                MAKEINTRESOURCE(IDB_FILTERS), 17, 4, RGB(0,255,0), IMAGE_BITMAP, LR_DEFAULTCOLOR);
    ListView_SetImageList(m_hWnd, hImage, LVSIL_SMALL);

    CString buf;
    CRect rc;
    GetClientRect(&rc);
    buf.LoadString(IDS_STATUS);
    InsertColumn(0, buf, LVCFMT_LEFT, rc.Width() * WT_STATUS / 27);
    buf.LoadString(IDS_FILTER_NAME);
    InsertColumn(1, buf, LVCFMT_LEFT, rc.Width() * WT_FILTER / 27);
    buf.LoadString(IDS_PRIORITY);
    InsertColumn(2, buf, LVCFMT_LEFT, rc.Width() * WT_PRIORITY / 27);

    SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

    return TRUE;
}



IMPLEMENT_DYNCREATE(CW3FiltersPage, CInetPropertyPage)

CW3FiltersPage::CW3FiltersPage(CInetPropertySheet * pSheet) 
    : CInetPropertyPage(CW3FiltersPage::IDD, pSheet),
      m_pfltrs(NULL)
{

#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

    VERIFY(m_strYes.LoadString(IDS_YES));
    VERIFY(m_strNo.LoadString(IDS_NO));
    VERIFY(m_strStatus[FLTR_DISABLED].LoadString(IDS_DISABLED));
    VERIFY(m_strStatus[FLTR_LOADED].LoadString(IDS_LOADED));
    VERIFY(m_strStatus[FLTR_UNLOADED].LoadString(IDS_UNLOADED));
    VERIFY(m_strStatus[FLTR_UNKNOWN].LoadString(IDS_UNKNOWN));
    VERIFY(m_strStatus[FLTR_DIRTY].LoadString(IDS_NOT_COMMITTED));
    VERIFY(m_strPriority[FLTR_PR_INVALID].LoadString(IDS_UNKNOWN_PRIORITY));
    VERIFY(m_strPriority[FLTR_PR_LOW].LoadString(IDS_LOW));
    VERIFY(m_strPriority[FLTR_PR_MEDIUM].LoadString(IDS_MEDIUM));
    VERIFY(m_strPriority[FLTR_PR_HIGH].LoadString(IDS_HIGH));
    VERIFY(m_strEnable.LoadString(IDS_ENABLE));
    VERIFY(m_strDisable.LoadString(IDS_DISABLED));

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3FiltersPage)
    m_strFiltersPrompt = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    //
    // Change filters prompt on the master
    //
    VERIFY(m_strFiltersPrompt.LoadString(IsMasterInstance() ? IDS_MASTER_FILTERS : IDS_INSTANCE_FILTERS));
}

CW3FiltersPage::~CW3FiltersPage()
{
}

void 
CW3FiltersPage::DoDataExchange(CDataExchange * pDX)
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3FiltersPage)
    DDX_Control(pDX,  IDC_STATIC_FILTER_NAME_PROMPT, m_static_NamePrompt);
    DDX_Control(pDX,  IDC_STATIC_FILTER_NAME, m_static_Name);
    DDX_Control(pDX, IDC_STATIC_STATUS_PROMPT, m_static_StatusPrompt);
    DDX_Control(pDX, IDC_STATIC_STATUS, m_static_Status);
    DDX_Control(pDX, IDC_STATIC_EXECUTABLE_PROMPT, m_static_ExecutablePrompt);
    DDX_Control(pDX, IDC_STATIC_EXECUTABLE, m_static_Executable);
    DDX_Control(pDX, IDC_STATIC_PRIORITY, m_static_Priority);
    DDX_Control(pDX, IDC_STATIC_PRIORITY_PROMPT, m_static_PriorityPrompt);
    DDX_Control(pDX, IDC_STATIC_DETAILS, m_static_Details);
    DDX_Control(pDX, IDC_BUTTON_DISABLE, m_button_Disable);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Text(pDX, IDC_STATIC_FILTERS, m_strFiltersPrompt);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_FILTERS, m_list_Filters);
    DDX_Control(pDX, IDC_BUTTON_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTTON_DOWN, m_button_Down);
}

void
CW3FiltersPage::FillFiltersListBox(CIISFilter * pSelection)
/*++

Routine Description:
    Populate the listbox with the filter entries.

Arguments:
    CIISFilter * pSelection : Item to be selected

--*/
{
    ASSERT(m_pfltrs != NULL);

    m_pfltrs->ResetEnumerator();

    m_list_Filters.SetRedraw(FALSE);
    m_list_Filters.DeleteAllItems();
    int cItems = 0;
    while(m_pfltrs->MoreFilters())
    {
        CIISFilter * pFilter = m_pfltrs->GetNextFilter();

        if (!pFilter->IsFlaggedForDeletion())
        {
            m_list_Filters.AddItem(pFilter);
            ++cItems;
        }
    }
    m_list_Filters.SetRedraw(TRUE);

    if (pSelection)
    {
        LVFINDINFO fi;
        fi.flags = LVFI_PARAM;
        fi.lParam = (LPARAM)pSelection;
        fi.vkDirection = VK_DOWN;
        int i = m_list_Filters.FindItem(&fi);
        if (i != -1)
        {
            m_list_Filters.SelectItem(i);
        }
    }
}

void
CW3FiltersPage::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

--*/
{
    SetDetailsText();

    CIISFilter * pFilter = NULL;

    BOOL fCanGoUp = FALSE;
    BOOL fCanGoDown = FALSE;
    int count = m_list_Filters.GetItemCount();
    int sel_count = m_list_Filters.GetSelectedCount();
    int sel = m_list_Filters.GetNextItem(-1, MAKELPARAM(LVNI_SELECTED, 0));;

    if (sel_count == 1)
    {
        //
        // Can only sort within the same priority
        //
        pFilter = m_list_Filters.GetItem(sel);
        m_button_Disable.SetWindowText(pFilter->m_fEnabled ? m_strEnable : m_strDisable);
        if (sel > 0)
        {
            CIISFilter * pPrev = m_list_Filters.GetItem(sel - 1);
            if (pFilter->m_nPriority == pPrev->m_nPriority)
            {
                fCanGoUp = TRUE;
            }
        }
        if (sel < (count - 1))
        {
            CIISFilter * pNext = m_list_Filters.GetItem(sel + 1);
            if (pFilter->m_nPriority == pNext->m_nPriority)
            {
                fCanGoDown = TRUE;
            }
        }
    }

    m_button_Disable.EnableWindow(FALSE);
    m_button_Edit.EnableWindow(sel_count == 1);
    m_button_Remove.EnableWindow(sel_count > 0);
	if (!fCanGoUp && ::GetFocus() == m_button_Up.m_hWnd)
	{
		::SetFocus(GetDlgItem(IDC_BUTTON_ADD)->m_hWnd);
	}
    m_button_Up.EnableWindow(fCanGoUp);
	if (!fCanGoDown && ::GetFocus() == m_button_Down.m_hWnd)
	{
		::SetFocus(GetDlgItem(IDC_BUTTON_ADD)->m_hWnd);
	}
    m_button_Down.EnableWindow(fCanGoDown);
}

/* virtual */
HRESULT
CW3FiltersPage::FetchLoadedValues()
/*++

Routine Description:
    Move configuration data from sheet to dialog controls

--*/
{
    CError err;

    CString path = QueryMetaPath();
	if (!IsMasterInstance())
	{
		CMetabasePath::GetInstancePath(QueryMetaPath(), path);
	}
    m_pfltrs = new CIISFilterList(QueryAuthInfo(), path);
    err = m_pfltrs ? m_pfltrs->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

    return err;
}

/* virtual */
HRESULT
CW3FiltersPage::SaveInfo()
/*++

Routine Description:
    Save the information on this property page

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 filters page now...");

    if (m_pfltrs)
    {
        BeginWaitCursor();
        CError err(m_pfltrs->WriteIfDirty());
        EndWaitCursor();

        if (err.Failed())
        {
            return err;
        }    
    }
    
    SetModified(FALSE);                                             

    return S_OK;
}

INT_PTR
CW3FiltersPage::ShowFiltersPropertyDialog(BOOL fAdd)
/*++

Routine Description:
    Display the add/edit dialog.  The return
    value is the value returned by the dialog

Arguments:
    BOOL fAdd       : TRUE if we're adding a new filter

Return Value:
    Dialog return value; ID_OK or ID_CANCEL

--*/
{
    CIISFilter flt;
    CIISFilter * pFlt = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        nCurSel = m_list_Filters.GetSelectionMark();
        ASSERT(nCurSel >= 0);

        if (nCurSel != LB_ERR)
        {
            //
            // Get filter properties
            //
            pFlt = m_list_Filters.GetItem(nCurSel);
        }
    }
    else
    {
        //
        // Point to the empty filter
        //
        pFlt = &flt;
    }

    ASSERT(pFlt != NULL);
    CFilterDlg dlgFilter(*pFlt, m_pfltrs, IsLocal(), this);
    INT_PTR nReturn = dlgFilter.DoModal();

    if (nReturn == IDOK)
    {
        try
        {
            //
            // When editing, delete and re-add (to make sure the
            // list is properly sorted)
            //
            pFlt = new CIISFilter(dlgFilter.GetFilter());

            if (!fAdd)
            {
                ASSERT(m_pfltrs);
                m_pfltrs->RemoveFilter(nCurSel);
                m_list_Filters.DeleteItem(nCurSel);
            }

            ASSERT(pFlt->IsInitialized());

            //
            // Add to list and listbox
            //
            m_pfltrs->AddFilter(pFlt);
			for (int i = 0; i < m_list_Filters.GetItemCount(); i++)
			{
				m_list_Filters.SelectItem(i, FALSE);
			}
			int idx = m_list_Filters.AddItem(pFlt);
            m_list_Filters.SelectItem(idx);

            //
            // Remember to store this one later
            //
            pFlt->Dirty();
            OnItemChanged();
        }
        catch(CMemoryException * e)
        {
            e->Delete();
        }
    }

    return nReturn;
}



void 
CW3FiltersPage::ShowProperties(BOOL fAdd)
/*++

Routine Description:
    Edit/add filter
    
Arguments:
    BOOL fAdd    : TRUE if we're adding a filter

--*/
{
    INT_PTR nResult = ShowFiltersPropertyDialog(fAdd);
    if (nResult == IDOK)
    {
        SetControlStates();
        SetModified(TRUE);
    }
}

void 
CW3FiltersPage::SetDetailsText()
/*++

Routine Description:
    Set the details text based on the currently selected filter

--*/
{
//    int nSel = m_list_Filters.GetSelectionMark();
    int nSel = m_list_Filters.GetNextItem(-1, MAKELPARAM(LVNI_SELECTED, 0));;
    BOOL fShow = (nSel != -1 && m_list_Filters.GetItemCount() > 0);

    ActivateControl(m_static_NamePrompt,        fShow);
    ActivateControl(m_static_Name,              fShow);
    ActivateControl(m_static_Priority,          fShow);
    ActivateControl(m_static_PriorityPrompt,    fShow);
    ActivateControl(m_static_Executable,        fShow);
    ActivateControl(m_static_ExecutablePrompt,  fShow);
    ActivateControl(m_static_Status,            fShow);
    ActivateControl(m_static_StatusPrompt,      fShow);
    ActivateControl(m_static_Details,           fShow);

    if (fShow)
    {
        CIISFilter * pFilter = m_list_Filters.GetItem(nSel);
        ASSERT(pFilter != NULL);

        //
        // Display path in truncated form
        //    
        FitPathToControl(m_static_Executable, pFilter->m_strExecutable, TRUE);

        int i;

        if (pFilter->IsDirty())
        {
            i = FLTR_DIRTY;
        }
        else if (!pFilter->IsEnabled())
        {
            i = FLTR_DISABLED;
        }
        else if (pFilter->IsLoaded())
        {
            i = FLTR_LOADED;
        }
        else if (pFilter->IsUnloaded())
        {
            i = FLTR_UNLOADED;
        }
        else
        {
            i = FLTR_UNKNOWN;
        }

        m_static_Name.SetWindowText(pFilter->QueryName());
        m_static_Status.SetWindowText(m_strStatus[i]);

        if (pFilter->IsDirty())
        {
            m_static_Priority.SetWindowText(m_strPriority[FLTR_PR_INVALID]);
        }
        else
        {
            m_static_Priority.SetWindowText(m_strPriority[pFilter->m_nPriority]);
        }
    }
}

void
CW3FiltersPage::ExchangeFilterPositions(int nSel1, int nSel2)
/*++

Routine Description:
    Exchange 2 filter objects, as indicated by their
    indices.  Selection will take place both in the
    listbox and in the oblist.

Arguments:
    int nSel1           : Index of item 1
    int nSel2           : Index of item 2

--*/
{
    CIISFilter * p1, * p2;

    if (m_pfltrs->ExchangePositions(nSel1, nSel2, p1, p2))
    {
        m_list_Filters.SetListItem(nSel1, p1);
        m_list_Filters.SetListItem(nSel2, p2); 
        SetModified(TRUE);
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3FiltersPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3FiltersPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_DISABLE, OnButtonDisable)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
    ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
    ON_WM_DESTROY()
    ON_NOTIFY(NM_DBLCLK, IDC_LIST_FILTERS, OnDblclkListFilters)
    ON_NOTIFY(NM_CLICK, IDC_LIST_FILTERS, OnClickListFilters)
    ON_NOTIFY(LVN_KEYDOWN, IDC_LIST_FILTERS, OnKeydownFilters)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_FILTERS, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void
CW3FiltersPage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

--*/
{
    SetModified(TRUE);
}

void 
CW3FiltersPage::OnButtonAdd()
{
    ShowProperties(TRUE);
}

void 
CW3FiltersPage::OnButtonEdit()
{
    ShowProperties(FALSE);
}

void 
CW3FiltersPage::OnButtonDisable()
{
    int nCurSel = m_list_Filters.GetSelectionMark();
    CIISFilter * pFilter = m_list_Filters.GetItem(nCurSel);
    ASSERT(pFilter);

/*
    pFilter->m_fEnabled = !pFilter->m_fEnabled;
    m_list_Filters.InvalidateSelection(nCurSel);
    SetControlStates();
*/
}

void 
CW3FiltersPage::OnButtonRemove()
{
    int nSel = 0;
    int cChanges = 0;
    int nCurSel = m_list_Filters.GetSelectionMark();

    CIISFilter * pFilter = NULL;

    POSITION pos = m_list_Filters.GetFirstSelectedItemPosition();
    if (pos != NULL)
    {
        while (pos)
        {
            int i = m_list_Filters.GetNextSelectedItem(pos);
            pFilter = m_list_Filters.GetItem(i);
            if (pFilter != NULL)
            {
                pFilter->FlagForDeletion();
            }
            m_list_Filters.DeleteItem(i);
            ++cChanges;
        }
    }
    if (cChanges)
    {
        int count = m_list_Filters.GetItemCount();
        if (count > 0)
        {
            m_list_Filters.SelectItem(nCurSel < count ? nCurSel : --nCurSel);
            GetDlgItem(IDC_BUTTON_REMOVE)->SetFocus();
        }
        else
        {
            m_list_Filters.SelectItem(nCurSel, FALSE);
            GetDlgItem(IDC_BUTTON_ADD)->SetFocus();
        }
        SetControlStates();
        OnItemChanged();
    }
}

void 
CW3FiltersPage::OnDblclkListFilters(NMHDR * pNMHDR, LRESULT * pResult)
{
    if (GetDlgItem(IDC_BUTTON_EDIT)->IsWindowEnabled())
	{
		OnButtonEdit();
	}
    *pResult = 0;
}

void 
CW3FiltersPage::OnKeydownFilters(NMHDR * pNMHDR, LRESULT* pResult) 
{
	LV_KEYDOWN * pLVKeyDow = (LV_KEYDOWN *)pNMHDR;
	switch (pLVKeyDow->wVKey)
	{
	case VK_INSERT:
		SendMessage(WM_COMMAND, IDC_BUTTON_ADD);
		break;
	case VK_DELETE:
		SendMessage(WM_COMMAND, IDC_BUTTON_REMOVE);
		break;
    case VK_RETURN:
        {
            short state = GetKeyState(VK_MENU);
            if ((0x8000 & state) != 0)
            {
                if (GetDlgItem(IDC_BUTTON_EDIT)->IsWindowEnabled())
                {
                    OnButtonEdit();
                }
                *pResult = 1;
            }
        }
        break;
    case VK_UP:
        {
            short state = GetKeyState(VK_CONTROL);
            if ((0x8000 & state) != 0)
            {
                if (GetDlgItem(IDC_BUTTON_UP)->IsWindowEnabled())
                {
                    OnButtonUp();
                }
                *pResult = 1;
            }
        }
        break;
    case VK_DOWN:
        {
            short state = GetKeyState(VK_CONTROL);
            if ((0x8000 & state) != 0)
            {
                if (GetDlgItem(IDC_BUTTON_DOWN)->IsWindowEnabled())
                {
                    OnButtonDown();
                }
                *pResult = 1;
            }
        }
        break;
    default:
        *pResult = 0;
        break;
	}
}

void
CW3FiltersPage::OnItemChanged(NMHDR * pNMHDR, LRESULT* pResult)
{
    SetControlStates();
}

void 
CW3FiltersPage::OnClickListFilters(NMHDR * pNMHDR, LRESULT * pResult)
{
    SetControlStates();
    *pResult = 0;
}

BOOL 
CW3FiltersPage::OnInitDialog()
{
    CError err;

    CInetPropertyPage::OnInitDialog();

    m_list_Filters.Initialize();

    //
    // Add filters to the listbox
    //
    err = m_pfltrs->LoadAllFilters();
    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // Filters path not yet created, this is ok 
        //
//        ASSERT(m_pfltrs && m_pfltrs->GetCount() == 0);
        err.Reset();
    }

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        FillFiltersListBox();    
    }

    SetControlStates();
    
    return TRUE; 
}

void 
CW3FiltersPage::OnButtonDown() 
/*++

Routine Description:

    Down button handler.  Exchange positions of the current item
    with the next lower item

--*/
{
    int idx = m_list_Filters.GetNextItem(-1, MAKELPARAM(LVNI_SELECTED, 0));
    ExchangeFilterPositions(idx, idx + 1);
    m_list_Filters.SetItemState(idx, 0, LVIS_SELECTED | LVIS_FOCUSED);
    m_list_Filters.SetItemState(idx + 1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
}

void 
CW3FiltersPage::OnButtonUp() 
/*++

Routine Description:

    Up button handler.  Exchange positions of the current item
    with the next higher item

--*/
{
    int idx = m_list_Filters.GetNextItem(-1, MAKELPARAM(LVNI_SELECTED, 0));
    ExchangeFilterPositions(idx - 1, idx);
    m_list_Filters.SetItemState(idx, 0, LVIS_SELECTED | LVIS_FOCUSED);
    m_list_Filters.SetItemState(idx - 1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
}

void 
CW3FiltersPage::OnDestroy() 
{
    CInetPropertyPage::OnDestroy();
    
    //
    // Filters and extensions lists will clean themself up
    //
    SAFE_DELETE(m_pfltrs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\errordlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errordlg.h

   Abstract:

        Error dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __ERRORDLG_H__
#define __ERRORDLG_H__



class CCustomError : public CObjectPlus
/*++

Class Description:

    Error definitions

Public Interface:

    CCustomError        : Constructors

    IsURL               : TRUE if the custom error is an URL
    IsFILE              : TRUE if the custom error is a file
    IsDefault           : TRUE if the custom error is a default error
    URLSupported        : TRUE if URLS are supported for this error type
    SetValue            : Set the value on the custom error
    MakeDefault         : Make the error a default error

--*/
{
//
// Error types
//
public:
    enum ERT
    {
        ERT_DEFAULT,
        ERT_FILE,
        ERT_URL,
    };

//
// Constructor
//
public:
    //
    // Construct error definition from metabase error
    // error description string.
    //
    CCustomError(LPCTSTR lpstrErrorString);

//
// Access
//
public:
    BOOL IsURL() const;
    BOOL IsFile() const;
    BOOL IsDefault() const;
    BOOL URLSupported() const { return m_fURLSupported; }
    void MakeDefault();
    void SetValue(
        IN ERT nType,
        IN LPCTSTR lpText
        );

//
// Helper Functions
//
public:
    //
    // Build error string
    //
    void BuildErrorString(
        OUT CString & str
        );

    //
    // Parse the error string into component parts
    //  
    static BOOL CrackErrorString(
        IN  LPCTSTR lpstrErrorString, 
        OUT UINT & nError, 
        OUT UINT & nSubError,
        OUT ERT & nType, 
        OUT CString & str
        ); 

    //
    // Sorting helper
    //
    int OrderByErrorNum(
        IN const CObjectPlus * pobAccess
        ) const;


protected:
    //
    // Parse error description string into component parts
    //
    static void CrackErrorDescription(
        IN  LPCTSTR lpstrErrorString, 
        OUT UINT & nError, 
        OUT UINT & nSubError,
        OUT BOOL & fURLSupported,
        OUT CString & str
        ); 

//
// Metabase values
//
protected:
    static LPCTSTR s_szSep;
    static LPCTSTR s_szFile;
    static LPCTSTR s_szURL;
    static LPCTSTR s_szNoSubError;

public:
    ERT m_nType;
    UINT m_nError;
    UINT m_nSubError;
    BOOL m_fURLSupported;
    CString m_str;
    CString m_strDefault;
};



class CCustomErrorDlg : public CDialog
/*++

Class Description:

    HTTP Error dialog

Public Interface:

    CCustomErrorDlg       : Constructor

--*/
{
//
// Construction
//
public:
    CCustomErrorDlg(
        IN CCustomError * pErr,
        IN BOOL fLocal,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CCustomErrorDlg)
    enum { IDD = IDD_ERROR_MAPPING };
    int     m_nMessageType;
    CString m_strTextFile;
    CEdit   m_edit_TextFile;
    CStatic m_static_SubErrorPrompt;
    CStatic m_static_SubError;
    CStatic m_static_TextFilePrompt;
    CButton m_button_Browse;
    CButton m_button_OK;
    CComboBox m_combo_MessageType;
    CString m_strDefText;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCustomErrorDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CCustomErrorDlg)
    afx_msg void OnSelchangeComboMessageType();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnChangeEditTextFile();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();

private:
    BOOL m_fLocal;
    CString m_strFile;
    CString m_strURL;
    CCustomError * m_pErr;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CCustomError::IsURL() const
{
    return m_nType == ERT_URL;
}

inline BOOL CCustomError::IsFile() const
{
    return m_nType == ERT_FILE;
}

inline BOOL CCustomError::IsDefault() const
{
    return m_nType == ERT_DEFAULT;
}

inline void CCustomError::SetValue(
    IN ERT nType,
    IN LPCTSTR lpText
    )
{
    m_str = lpText;
    m_nType = nType;
}

inline void CCustomError::MakeDefault()
{
    m_nType = ERT_DEFAULT;
}

#endif // __ERRORDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fltdlg.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fltdlg.cpp

   Abstract:
        WWW Filters Property Dialog

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "w3sht.h"
#include "fltdlg.h"

extern CInetmgrApp theApp;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define FILTER_NAME_MAX		24


CFilterDlg::CFilterDlg(
    IN OUT CIISFilter & flt,
    IN CIISFilterList * & pFilters,
    IN BOOL fLocal,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Filter properties dialog constructor

Arguments:

    CIISFilter & flt          : Filter being edited
    CFilters * & pFilters     : List of filters that exist
    BOOL fLocal               : TRUE on the local system
    CWnd * pParent OPTIONAL   : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CFilterDlg::IDD, pParent),
      m_fLocal(fLocal),
      m_pFilters(pFilters),
      m_fEditMode(FALSE),
      m_flt(flt)
{
    //{{AFX_DATA_INIT(CFilterDlg)
    m_strExecutable = m_flt.m_strExecutable;
    m_strFilterName = m_flt.m_strName;
    //}}AFX_DATA_INIT

    //
    // Map priority to string ID
    //
    m_strPriority.LoadString(IDS_HIGH + 3 - m_flt.m_nPriority);
}


static BOOL
PathIsValidFilter(LPCTSTR path)
{
    LPCTSTR p = path;
    BOOL rc = TRUE;
    if (p == NULL || *p == 0)
        return FALSE;
    while (*p != 0)
    {
        switch (*p)
        {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('/'):
        case TEXT('?'):
        case TEXT('*'):
//        case TEXT(';'):
        case TEXT(','):
        case TEXT('"'):
            rc = FALSE;
            break;
        default:
            if (*p < TEXT(' '))
            {
                rc = FALSE;
            }
            break;
        }
        if (!rc)
        {
            break;
        }
        p++;
    }
    return rc;
}


static BOOL
PathIsValidFilterName(LPCTSTR name)
{
    LPCTSTR p = name;
    BOOL rc = TRUE;
    if (p == NULL || *p == 0)
        return FALSE;
    while (*p != 0)
    {
        switch (*p)
        {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('/'):
		case TEXT('\\'):
        case TEXT('?'):
        case TEXT('*'):
        case TEXT(';'):
        case TEXT(','):
        case TEXT('"'):
            rc = FALSE;
            break;
        default:
            if (*p < TEXT(' '))
            {
                rc = FALSE;
            }
            break;
        }
        if (!rc)
        {
            break;
        }
        p++;
    }
    return rc;
}


void 
CFilterDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFilterDlg)
    DDX_Control(pDX, IDC_STATIC_PRIORITY_VALUE, m_static_Priority);
    DDX_Control(pDX, IDC_STATIC_PRIORITY, m_static_PriorityPrompt);
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_FILTERNAME, m_edit_FilterName);
    DDX_Control(pDX, IDC_EDIT_EXECUTABLE, m_edit_Executable);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Text(pDX, IDC_STATIC_PRIORITY_VALUE, m_strPriority);
    //}}AFX_DATA_MAP

	DDX_Text(pDX, IDC_EDIT_EXECUTABLE, m_strExecutable);
    if (pDX->m_bSaveAndValidate)
    {
		DDV_FilePath(pDX, m_strExecutable, m_fLocal);
	}
    DDX_Text(pDX, IDC_EDIT_FILTERNAME, m_strFilterName);
	DDV_MaxCharsBalloon(pDX, m_strFilterName, FILTER_NAME_MAX);
    if (pDX->m_bSaveAndValidate)
    {
		m_strFilterName.TrimLeft();
		m_strFilterName.TrimRight();
		if (m_strFilterName.IsEmpty() || !PathIsValidFilterName(m_strFilterName))
		{
			DDV_ShowBalloonAndFail(pDX, IDS_ERR_INVALID_FILTER_NAME);
		}
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFilterDlg, CDialog)
    //{{AFX_MSG_MAP(CFilterDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
	ON_BN_CLICKED(ID_HELP, OnHelp)
    ON_EN_CHANGE(IDC_EDIT_EXECUTABLE, OnExecutableChanged)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_FILTERNAME, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CFilterDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Available on local connections only
    //
    m_button_Browse.EnableWindow(m_fLocal);

    if ((m_fEditMode = m_edit_FilterName.GetWindowTextLength() > 0))
    {
        m_edit_FilterName.SetReadOnly();
    }

    SetControlStates();
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_EXECUTABLE),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_EXECUTABLE),FALSE);
#endif
    
    return TRUE;
}


void
CFilterDlg::OnHelp()
{
    WinHelpDebug(0x20000 + CFilterDlg::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CFilterDlg::IDD);
}


void 
CFilterDlg::OnButtonBrowse() 
/*++

Routine Description:

    Browse button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_fLocal);

    CString strFilterMask((LPCTSTR)IDS_FILTER_MASK);

    //
    // CODEWORK: Derive a class from CFileDialog that allows
    // the setting of the initial path
    //

    //CString strPath;
    //m_edit_Executable.GetWindowText(strPath);
    CFileDialog dlgBrowse(
        TRUE, 
        NULL, 
        NULL, 
        OFN_HIDEREADONLY, 
        strFilterMask, 
        this
        );
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

	INT_PTR rc = dlgBrowse.DoModal();
    if (rc == IDOK)
    {
        m_edit_Executable.SetWindowText(dlgBrowse.GetPathName());
    }
	else if (rc == IDCANCEL)
	{
		DWORD err = CommDlgExtendedError();
	}

    OnItemChanged();
}



void 
CFilterDlg::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    BOOL fAllowAnonymous : If TRUE, 'allow anonymous' is on.

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(
        m_edit_FilterName.GetWindowTextLength() > 0
     && m_edit_Executable.GetWindowTextLength() > 0);

    ActivateControl(m_static_PriorityPrompt, m_flt.m_nPriority != FLTR_PR_INVALID);
    ActivateControl(m_static_Priority,       m_flt.m_nPriority != FLTR_PR_INVALID);
}



void
CFilterDlg::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFilterDlg::OnExecutableChanged()
/*++

Routine Description:

    Handle change in executable edit box.  Remove priority as this
    is no longer valid

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Priority no longer makes sense.
    // 
    m_flt.m_nPriority = FLTR_PR_INVALID;
    OnItemChanged();
}



BOOL
CFilterDlg::FilterNameExists(
    IN LPCTSTR lpName
    )
/*++

Routine Description:

    Look for a given filter name in the list

Arguments:

    LPCTSTR lpName  : Filter name to look for

Return Value:

    TRUE if the name already existed in the list

--*/
{
    m_pFilters->ResetEnumerator();

    while(m_pFilters->MoreFilters())
    {
        CIISFilter * pFilter = m_pFilters->GetNextFilter();
        ASSERT(pFilter != NULL);

        if (!pFilter->IsFlaggedForDeletion())
        {
            if (!pFilter->m_strName.CompareNoCase(lpName))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

void 
CFilterDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Save data

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        //
        // Make sure the filter name is unique
        //
        if (!m_fEditMode && FilterNameExists(m_strFilterName))
        {
			EditShowBalloon(m_edit_FilterName.m_hWnd, IDS_ERR_DUP_FILTER);
            return;
        }
        m_flt.m_strExecutable = m_strExecutable;
        m_flt.m_strName = m_strFilterName;
        //
        // Anyway to load this from the DLL?
        //
        //m_flt.m_nPriority = FLTR_PR_MEDIUM;
        CDialog::OnOK();
    }

    //
    // Don't dismiss the dialog
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\filters.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        filters.h

   Abstract:
        WWW Filters Property Page Definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef _FILTERS_H
#define _FILTERS_H

class CIISFilter;

class CFiltersListBox : public CListCtrl
{
    DECLARE_DYNAMIC(CFiltersListBox);

public:
    CFiltersListBox();

public:
    BOOL Initialize();
    CIISFilter * GetItem(UINT nIndex);
	int InsertItem(int idx, CIISFilter * p);
    int AddItem(CIISFilter * pItem);
    int SetListItem(int idx, CIISFilter * pItem);
    void SelectItem(int idx, BOOL bSelect = TRUE);
//	void MoveSelectedItem(int direction);

private:
    CString m_str[FLT_PR_NUM]; 
};

class CW3FiltersPage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CW3FiltersPage)

public:
    CW3FiltersPage(CInetPropertySheet * pSheet = NULL);
    ~CW3FiltersPage();

protected:
    //{{AFX_DATA(CW3FiltersPage)
    enum { IDD = IDD_FILTERS };
    CString m_strFiltersPrompt;
    CStatic m_static_NamePrompt;
    CStatic m_static_Name;
    CStatic m_static_StatusPrompt;
    CStatic m_static_Status;
    CStatic m_static_ExecutablePrompt;
    CStatic m_static_Executable;
    CStatic m_static_Priority;
    CStatic m_static_PriorityPrompt;
    CButton m_static_Details;
    CButton m_button_Disable;
    CButton m_button_Edit;
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Up;
    CButton m_button_Down;
    //}}AFX_DATA
    CFiltersListBox m_list_Filters;
    CStringList m_strlScriptMaps;

protected:
    //{{AFX_VIRTUAL(CW3FiltersPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

protected:
    //{{AFX_MSG(CW3FiltersPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonDisable();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonDown();
    afx_msg void OnButtonUp();
    afx_msg void OnDestroy();
    afx_msg void OnDblclkListFilters(NMHDR * pNMHDR, LRESULT * pResult);
    afx_msg void OnClickListFilters(NMHDR * pNMHDR, LRESULT * pResult);
    afx_msg void OnKeydownFilters(NMHDR * pNMHDR, LRESULT * pResult);
    afx_msg void OnItemChanged(NMHDR * pNMHDR, LRESULT* pResult);
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void    ExchangeFilterPositions(int nSel1, int nSel2);
    void    SetControlStates();
    void    FillFiltersListBox(CIISFilter * pSelection = NULL);
    void    SetDetailsText();
    void    ShowProperties(BOOL fAdd = FALSE);
    INT_PTR ShowFiltersPropertyDialog(BOOL fAdd = FALSE);
    LPCTSTR BuildFilterOrderString(CString & strFilterOrder);

private:
    CString m_strYes;
    CString m_strNo;
    CString m_strStatus[5];
    CString m_strPriority[FLT_PR_NUM];
    CString m_strEnable;
    CString m_strDisable;
    CIISFilterList * m_pfltrs;
};

#endif //_FILTERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fmessage.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fmessage.cpp

   Abstract:
        FTP Messages property page

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "ftpsht.h"
#include "fmessage.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



IMPLEMENT_DYNCREATE(CFtpMessagePage, CInetPropertyPage)

CFtpMessagePage::CFtpMessagePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP message property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpMessagePage::IDD, pSheet)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CFtpMessagePage)
    m_strExitMessage = _T("");
    m_strMaxConMsg = _T("");
    m_strWelcome = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    m_hInstRichEdit = LoadLibrary(_T("RichEd20.dll"));
}



CFtpMessagePage::~CFtpMessagePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
   if (m_hInstRichEdit != NULL)
      FreeLibrary(m_hInstRichEdit);
}



void
CFtpMessagePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpMessagePage)
    DDX_Control(pDX, IDC_EDIT_EXIT, m_edit_Exit);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxCon);
    DDX_Text(pDX, IDC_EDIT_EXIT, m_strExitMessage);
    DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_strMaxConMsg);
    DDX_Text(pDX, IDC_EDIT_WELCOME, m_strWelcome);
    DDX_Text(pDX, IDC_EDIT_BANNER, m_strBanner);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpMessagePage, CInetPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_EXIT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_WELCOME, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_BANNER, OnItemChanged)
END_MESSAGE_MAP()


BOOL
CFtpMessagePage::OnInitDialog()
{
    CInetPropertyPage::OnInitDialog();

    CHARFORMAT2 cf;
    ZeroMemory(&cf, sizeof(cf));
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_FACE | CFM_WEIGHT;
    cf.wWeight = FW_REGULAR;
    lstrcpyn((LPTSTR)cf.szFaceName, _T("Courier New"), LF_FACESIZE);

    DWORD event;
    if (GetSheet()->QueryMajorVersion() >= 6)
    {
        SendDlgItemMessage(IDC_EDIT_BANNER, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
        event = (DWORD)SendDlgItemMessage(IDC_EDIT_BANNER, EM_GETEVENTMASK, 0, 0);
        event |= ENM_CHANGE;
        SendDlgItemMessage(IDC_EDIT_BANNER, EM_SETEVENTMASK, 0, (LPARAM)event);
    }
    else
    {
        CRect rcText, rcBanner, rcWelcome;
        CWnd * pbt, * pwt, * pbe, * pwe;
        pbt = GetDlgItem(IDC_STATIC_BANNER);
        pbe = GetDlgItem(IDC_EDIT_BANNER);
        pwt = GetDlgItem(IDC_STATIC_WELCOME);
        pwe = GetDlgItem(IDC_EDIT_WELCOME);
        pbt->GetWindowRect(&rcText);
        ScreenToClient(&rcText);
        pbe->GetWindowRect(&rcBanner);
        ScreenToClient(&rcBanner);
        pbt->EnableWindow(FALSE);
        pbt->ShowWindow(SW_HIDE);
        pbe->EnableWindow(FALSE);
        pbe->ShowWindow(SW_HIDE);
        pwt->SetWindowPos(NULL, rcText.left, rcText.top, 0, 0,
            SWP_NOSIZE | SWP_NOZORDER);
        pwe->GetWindowRect(&rcWelcome);
        ScreenToClient(&rcWelcome);
        pwe->SetWindowPos(NULL, rcBanner.left, rcBanner.top, 
            rcWelcome.Width(), rcWelcome.bottom - rcBanner.top,
            SWP_NOZORDER);
    }
    SendDlgItemMessage(IDC_EDIT_WELCOME, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    event = (DWORD)SendDlgItemMessage(IDC_EDIT_WELCOME, EM_GETEVENTMASK, 0, 0);
    event |= ENM_CHANGE;
    SendDlgItemMessage(IDC_EDIT_WELCOME, EM_SETEVENTMASK, 0, (LPARAM)event);

    return TRUE;
}



/* virtual */
HRESULT
CFtpMessagePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)

        //
        // Use m_ notation because the message cracker functions require it.
        //
        CStringListEx m_strlWelcome, m_strlBanner;
        FETCH_INST_DATA_FROM_SHEET(m_strExitMessage);
        FETCH_INST_DATA_FROM_SHEET(m_strMaxConMsg);
        FETCH_INST_DATA_FROM_SHEET(m_strlWelcome);
        FETCH_INST_DATA_FROM_SHEET(m_strlBanner);

        //
        // Incoming strings contain '\r' at the end of each string.
        // Append a '\n' for internal consumption
        //
        ConvertStringListToSepLine(m_strlWelcome, m_strWelcome, _T("\n"));
        ConvertStringListToSepLine(m_strlBanner, m_strBanner, _T("\n"));

    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CFtpMessagePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP message page now...");

    CError err;

    BeginWaitCursor();

    //
    // Use m_ notation because the message cracker macros require
    // it.
    //
    CStringListEx m_strlWelcome, m_strlBanner;
    ConvertSepLineToStringList(m_strWelcome, m_strlWelcome, _T("\n"));
    ConvertSepLineToStringList(m_strBanner, m_strlBanner, _T("\n"));

    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_strExitMessage)
        STORE_INST_DATA_ON_SHEET(m_strMaxConMsg)
        STORE_INST_DATA_ON_SHEET(m_strlWelcome)
        STORE_INST_DATA_ON_SHEET(m_strlBanner)
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}



void
CFtpMessagePage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fltdlg.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        fltdlg.h

   Abstract:

        WWW Filters Property Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FLTDLG_H__
#define __FLTDLG_H__



enum
{
    FLTR_DISABLED,
    FLTR_LOADED,
    FLTR_UNLOADED,
    FLTR_DIRTY,
    /**/
    FLTR_UNKNOWN
};

enum
{
    FLTR_PR_INVALID,
    FLTR_PR_LOW,
    FLTR_PR_MEDIUM,
    FLTR_PR_HIGH,
};



//
// Num priority levels
//
#define FLT_PR_NUM  (FLTR_PR_HIGH + 1)


//
// CFilterDlg dialog
//
class CFilterDlg : public CDialog
/*++

Class Description:

    Filter property dialog

Public Interface:

    CFilterDlg    : Constructor
    GetFilter     : Get the filter object being edited

--*/
{
//
// Construction
//
public:
    CFilterDlg(
        IN CIISFilter &flt,
        IN CIISFilterList *& pFilters,
        IN BOOL fLocal,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFilterDlg)
    enum { IDD = IDD_FILTER };
    CString m_strExecutable;
    CString m_strFilterName;
    CString m_strPriority;
    CEdit   m_edit_FilterName;
    CEdit   m_edit_Executable;
    CStatic m_static_Priority;
    CStatic m_static_PriorityPrompt;
    CButton m_button_Browse;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFilterDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Access
//
public:
    CIISFilter & GetFilter() { return m_flt; }

//
// Implementation
//
protected:
    //{{AFX_MSG(CFilterDlg)
    afx_msg void OnButtonBrowse();
    afx_msg void OnExecutableChanged();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
	afx_msg void OnHelp();

    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    BOOL FilterNameExists(LPCTSTR lpName);

private:
    BOOL m_fLocal;
    BOOL m_fEditMode;
    CIISFilter m_flt;
    CIISFilterList *& m_pFilters;
};

#endif // __FLTDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
    CString result;
    GetProperty(0x0, VT_BSTR, (void*)&result);
    return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
    SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
    CY result;
    GetProperty(0x2, VT_CY, (void*)&result);
    return result;
}

void COleFont::SetSize(const CY& propVal)
{
    SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
    BOOL result;
    GetProperty(0x3, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetBold(BOOL propVal)
{
    SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
    BOOL result;
    GetProperty(0x4, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetItalic(BOOL propVal)
{
    SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
    BOOL result;
    GetProperty(0x5, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
    SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
    BOOL result;
    GetProperty(0x6, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
    SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
    short result;
    GetProperty(0x7, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetWeight(short propVal)
{
    SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
    short result;
    GetProperty(0x8, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetCharset(short propVal)
{
    SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\font.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
    COleFont() {}       // Calls COleDispatchDriver default constructor
    COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    CString GetName();
    void SetName(LPCTSTR);
    CY GetSize();
    void SetSize(const CY&);
    BOOL GetBold();
    void SetBold(BOOL);
    BOOL GetItalic();
    void SetItalic(BOOL);
    BOOL GetUnderline();
    void SetUnderline(BOOL);
    BOOL GetStrikethrough();
    void SetStrikethrough(BOOL);
    short GetWeight();
    void SetWeight(short);
    short GetCharset();
    void SetCharset(short);

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fsecure.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        security.h

   Abstract:

        FTP Security Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __FSECURITY_H__
#define __FSECURITY_H__



class CFtpSecurityPage : public CInetPropertyPage
/*++

Class Description:

    FTP Security property page

Public Interface:

    CFtpSecurityPage     : Constructor
    ~CFtpSecurityPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpSecurityPage)

//
// Construction
//
public:
    CFtpSecurityPage(CInetPropertySheet * pSheet = NULL);
    ~CFtpSecurityPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpSecurityPage)
    enum { IDD = IDD_FTP_DIRECTORY_SECURITY };
    int     m_nGrantedDenied;
    CStatic m_icon_Granted;
    CStatic m_icon_Denied;
    CButton m_radio_Granted;
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    //}}AFX_DATA

    CIPAccessDescriptorListBox m_list_IpAddresses;
    CButton m_radio_Denied;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpSecurityPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpSecurityPage)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListIpAddresses();
    afx_msg void OnErrspaceListIpAddresses();
    afx_msg void OnRadioGranted();
    afx_msg void OnRadioDenied();
    afx_msg void OnSelchangeListIpAddresses();
    afx_msg int  OnVKeyToItem(UINT nKey, CListBox * pListBox, UINT nIndex);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    void    FillListBox(CIPAccessDescriptor * pSelection = NULL);
    BOOL    SetControlStates();
    DWORD   SortAccessList();

private:
    BOOL m_fDefaultGranted;
    BOOL m_fOldDefaultGranted;
    BOOL m_fIpDirty;
    CObListPlus m_oblAccessList;
    CRMCListBoxResources m_ListBoxRes;
};


#endif //__SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fservic.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        fservic.cpp

   Abstract:

        FTP Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "ftpsht.h"
#include "fservic.h"
#include "usersess.h"
#include "iisobj.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Some sanity values on max connections
//
#define MAX_MAX_CONNECTIONS      (2000000001L)
#define INITIAL_MAX_CONNECTIONS  (      1000L)
#define UNLIMITED_CONNECTIONS    (2000000000L)

#define MAX_TIMEOUT              (0x7FFFFFFF)

#define LIMITED_CONNECTIONS_MIN    (10)
#define LIMITED_CONNECTIONS_MAX    (40)



IMPLEMENT_DYNCREATE(CFtpServicePage, CInetPropertyPage)



CFtpServicePage::CFtpServicePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP service property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpServicePage::IDD, pSheet)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CFtpServicePage)
    m_strComment = _T("");
    m_nTCPPort = 20;
    m_nUnlimited = RADIO_LIMITED;
    m_nIpAddressSel = -1;
    m_fEnableLogging = FALSE;
    //}}AFX_DATA_INIT

    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
    m_nConnectionTimeOut = 600;
    m_iaIpAddress = (LONG)0L;
    m_strDomainName = _T("");

#endif // 0
}



CFtpServicePage::~CFtpServicePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpServicePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        m_fEnableLogging = LoggingEnabled(m_dwLogType);
    }

    //{{AFX_DATA_MAP(CFtpServicePage)
    DDX_Radio(pDX, IDC_RADIO_UNLIMITED, m_nUnlimited);
    DDX_Check(pDX, IDC_CHECK_ENABLE_LOGGING, m_fEnableLogging);
    DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
    DDV_MinMaxChars(pDX, m_strComment, 0, MAX_PATH);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxConnections);
    DDX_Control(pDX, IDC_STATIC_LOG_PROMPT, m_static_LogPrompt);
    DDX_Control(pDX, IDC_BUTTON_PROPERTIES, m_button_LogProperties);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESS, m_combo_IpAddresses);
    DDX_Control(pDX, IDC_COMBO_LOG_FORMATS, m_combo_LogFormats);
    //}}AFX_DATA_MAP

    if (!IsMasterInstance())
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
        DDV_MinMaxBalloon(pDX, IDC_EDIT_TCP_PORT, 1, 65535);
    }
	DDX_TextBalloon(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        pDX->Fail();
    }

    //
    // Private DDX/DDV Routines
    //
    int nMin = IsMasterInstance() ? 0 : 1;


    if (!m_f10ConnectionLimit && !m_fUnlimitedConnections)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
        DDV_MinMaxBalloon(pDX, IDC_EDIT_MAX_CONNECTIONS, 0, UNLIMITED_CONNECTIONS);
    }

    if (!pDX->m_bSaveAndValidate || !m_fUnlimitedConnections )
    {
        DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nVisibleMaxConnections);
    }

    if (m_f10ConnectionLimit)
    {
        //
        // Special validation for unlimited connections.  We use a bogus
        // numeric check for data validation.  Number adjustment happens 
        // later.
        //
        if (pDX->m_bSaveAndValidate && 
            (m_nVisibleMaxConnections < 0 || 
             m_nVisibleMaxConnections > UNLIMITED_CONNECTIONS))
        {
            TCHAR szMin[32];
            TCHAR szMax[32];
            wsprintf(szMin, _T("%ld"), 0);
            wsprintf(szMax, _T("%ld"), 40);
            CString prompt;
            AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
            AfxMessageBox(prompt, MB_ICONEXCLAMATION);
            prompt.Empty(); // exception prep
            pDX->Fail();
        }
    }

	// This Needs to come before DDX_Text which will try to put text big number into small number
	DDV_MinMaxBalloon(pDX, IDC_EDIT_CONNECTION_TIMEOUT, nMin, MAX_TIMEOUT);
    DDX_Text(pDX, IDC_EDIT_CONNECTION_TIMEOUT, m_nConnectionTimeOut);

    if (pDX->m_bSaveAndValidate)
    {
        EnableLogging(m_dwLogType, m_fEnableLogging);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpServicePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpServicePage)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_LOGGING, OnCheckEnableLogging)
    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_BUTTON_CURRENT_SESSIONS, OnButtonCurrentSessions)
    ON_BN_CLICKED(IDC_BUTTON_PROPERTIES, OnButtonProperties)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnItemChanged)
    ON_CBN_EDITCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_LOG_FORMATS, OnItemChanged)

END_MESSAGE_MAP()



void
CFtpServicePage::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_edit_MaxConnections.m_hWnd)
    {
        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
    }
}



void
CFtpServicePage::PopulateKnownIpAddresses()
/*++

Routine Description:

    Fill the combo box with known ip addresses

Arguments:

    None

Return Value:

    None

--*/
{
    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        QueryServerName(),
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel 
        );
    EndWaitCursor();
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CFtpServicePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CInetPropertyPage::OnInitDialog();

    //
    // Take our direction from a phony button
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_LogProperties.Create(
        _T("LogUI"),
        WS_BORDER,
        rc,
        this,
        IDC_LOGUICTRL
        );

    //
    // Initialize the logging ocx; pass it the metabase path of the 
    // virtual server.
    // TODO: Rewrite this crappy logui control to make it more predictable.
    // Here metabase path should not contain leading / and trailing Root
    //
    CString path_inst = QueryMetaPath();
    CString path;
    if (IsMasterInstance())
    {
       CMetabasePath::GetServicePath(path_inst, path);
    }
    else
    {
       CMetabasePath::GetInstancePath(path_inst, path);
    }
    if (path[0] == _T('/'))
    {
        path = path.Right(path.GetLength() - 1);
    }
    m_ocx_LogProperties.SetAdminTarget(QueryServerName(), path);
    m_ocx_LogProperties.SetUserData(QueryAuthInfo()->QueryUserName(), QueryAuthInfo()->QueryPassword());
    m_ocx_LogProperties.SetComboBox(m_combo_LogFormats.m_hWnd);

    GetDlgItem(IDC_RADIO_UNLIMITED)->EnableWindow(!m_f10ConnectionLimit);

    if (IsMasterInstance() || !HasAdminAccess())
    {
        GetDlgItem(IDC_STATIC_IPADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_TCP_PORT)->EnableWindow(FALSE);
        m_combo_IpAddresses.EnableWindow(FALSE);
		GetDlgItem(IDC_STATIC_DESCRIPTION)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_COMMENT)->EnableWindow(FALSE);
    }

    PopulateKnownIpAddresses();
    SetControlStates();
    SetLogState();

    GetDlgItem(IDC_BUTTON_CURRENT_SESSIONS)->EnableWindow(!IsMasterInstance());

    return TRUE;
}



/* virtual */
HRESULT
CFtpServicePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    m_f10ConnectionLimit = Has10ConnectionLimit();

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_nConnectionTimeOut);
        FETCH_INST_DATA_FROM_SHEET(m_iaIpAddress);
        FETCH_INST_DATA_FROM_SHEET(m_nTCPPort);
        FETCH_INST_DATA_FROM_SHEET(m_strDomainName);
        FETCH_INST_DATA_FROM_SHEET(m_strComment);
        FETCH_INST_DATA_FROM_SHEET(m_dwLogType);
        
        m_fUnlimitedConnections = m_nMaxConnections >= MAX_MAX_CONNECTIONS;

        if (m_f10ConnectionLimit)
        {
            m_fUnlimitedConnections = FALSE;
            if ((LONG)m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
            {
                m_nMaxConnections = LIMITED_CONNECTIONS_MAX;
            }
        }

        m_nVisibleMaxConnections = m_fUnlimitedConnections
            ? INITIAL_MAX_CONNECTIONS
            : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;

        m_nOldTCPPort = m_nTCPPort;
    END_META_INST_READ(err)

    return err;
}




HRESULT
CFtpServicePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP service page now...");

    CError err;

    m_nMaxConnections = m_fUnlimitedConnections 
        ? MAX_MAX_CONNECTIONS : m_nVisibleMaxConnections;

    //
    // Check to make sure we're not violating the license
    // agreement
    //
    if (m_f10ConnectionLimit)
    {
        if (m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
        {
            DoHelpMessageBox(m_hWnd,IDS_CONNECTION_LIMIT, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
            m_nMaxConnections = LIMITED_CONNECTIONS_MIN;
        }
        else if (m_nMaxConnections >  LIMITED_CONNECTIONS_MIN
              && m_nMaxConnections <= LIMITED_CONNECTIONS_MAX)
        {
            DoHelpMessageBox(m_hWnd,IDS_WRN_CONNECTION_LIMIT, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
        }
    }

    CString strBinding;
    CStringListEx m_strlBindings;

    CInstanceProps::BuildBinding(
        strBinding, 
        m_iaIpAddress, 
        m_nTCPPort, 
        m_strDomainName
        );
    m_strlBindings.AddTail(strBinding);
    m_ocx_LogProperties.ApplyLogSelection();

    BeginWaitCursor();
    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nConnectionTimeOut);
        STORE_INST_DATA_ON_SHEET(m_dwLogType);
        STORE_INST_DATA_ON_SHEET(m_strComment);
        STORE_INST_DATA_ON_SHEET(m_strlBindings);
    END_META_INST_WRITE(err)
    EndWaitCursor();

    if (err.Succeeded())
    {
		CIISMBNode * pNode = (CIISMBNode *)GetSheet()->GetParameter();
		ASSERT(pNode != NULL);
		pNode->Refresh(FALSE);
    }

    return err;
}



void
CFtpServicePage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0, -1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}



void
CFtpServicePage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}



void
CFtpServicePage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    SetModified(TRUE);
}



void
CFtpServicePage::SetLogState()
/*++

Routine Description:

    Set the enabled state of the logging controls depending on
    whether logging is currently enabled

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_LogPrompt.EnableWindow(m_fEnableLogging);
    m_combo_LogFormats.EnableWindow(m_fEnableLogging);
    m_button_LogProperties.EnableWindow(m_fEnableLogging);
}



void
CFtpServicePage::OnCheckEnableLogging()
/*++

Routine Description:

    'Enable logging' checkbox has been toggled.  Reset the state
    of the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableLogging = !m_fEnableLogging;
    SetLogState();
    OnItemChanged();
}



void 
CFtpServicePage::OnButtonProperties() 
/*++

Routine Description:

    Pass on "log properties" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    m_ocx_LogProperties.DoClick();
}



void
CFtpServicePage::OnButtonCurrentSessions()
/*++

Routine Description:

    'Current Sessions' button has been pressed.  Bring up the current
    sessions dialog

Arguments:

    None

Return Value:

    None

-*/
{
    CComAuthInfo * pAuth = GetSheet()->QueryAuthInfo();
    ASSERT(pAuth != NULL);
    CUserSessionsDlg dlg(
        pAuth->QueryServerName(), 
        QueryInstance(), 
        pAuth->QueryUserName(),
        pAuth->QueryPassword(),
        this,
		GetSheet()->IsLocal()
		);
    dlg.DoModal();
}



void 
CFtpServicePage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    if (m_ocx_LogProperties.m_hWnd)
    {
        m_ocx_LogProperties.Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fmessage.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fmessage.h

   Abstract:
        FTP Message property page

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/


class CFtpMessagePage : public CInetPropertyPage
/*++

Class Description:

    FTP Messages property page

Public Interface:

    CFtpMessagePage  : Constructor
    ~CFtpMessagePage : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpMessagePage)

//
// Construction
//
public:
    CFtpMessagePage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpMessagePage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpMessagePage)
    enum { IDD = IDD_FTP_MESSAGES };
    CString m_strExitMessage;
    CString m_strMaxConMsg;
    CString m_strWelcome;
	CString m_strBanner;
    CEdit   m_edit_Exit;
    CEdit   m_edit_MaxCon;
    //}}AFX_DATA

    HMODULE m_hInstRichEdit;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpMessagePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpMessagePage)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fsecure.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        security.cpp

   Abstract:
        FTP Security Property Page 

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "ftpsht.h"
#include "fvdir.h"
#include "fsecure.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Needed for granted/denied icons
//
//#include "..\comprop\resource.h"



IMPLEMENT_DYNCREATE(CFtpSecurityPage, CInetPropertyPage)



CFtpSecurityPage::CFtpSecurityPage(
    IN CInetPropertySheet * pSheet
    )
    : CInetPropertyPage(
        CFtpSecurityPage::IDD, 
        pSheet, 
        USE_DEFAULT_CAPTION, 
        TRUE                    // Enable enhanced fonts
        ),
      m_ListBoxRes(
        IDB_ACCESS,
        m_list_IpAddresses.nBitmaps
        ),
      m_oblAccessList(),
      m_list_IpAddresses(TRUE),
      m_fIpDirty(FALSE),
      m_fOldDefaultGranted(TRUE),
      m_fDefaultGranted(TRUE)   // By default, we grant access
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CFtpSecurityPage)
    m_nGrantedDenied = 0;
    //}}AFX_DATA_INIT

#endif // 0

    m_list_IpAddresses.AttachResources(&m_ListBoxRes);
}



CFtpSecurityPage::~CFtpSecurityPage()
{
    //
    // The access list will clean itself up
    //
}



void
CFtpSecurityPage::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpSecurityPage)
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_ICON_GRANTED, m_icon_Granted);
    DDX_Control(pDX, IDC_ICON_DENIED, m_icon_Denied);
    DDX_Control(pDX, IDC_RADIO_GRANTED, m_radio_Granted);
    DDX_Radio(pDX, IDC_RADIO_GRANTED, m_nGrantedDenied);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_RADIO_DENIED, m_radio_Denied);
    DDX_Control(pDX, IDC_LIST_IP_ADDRESSES, m_list_IpAddresses);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpSecurityPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpSecurityPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_RADIO_GRANTED, OnRadioGranted)
    ON_BN_CLICKED(IDC_RADIO_DENIED, OnRadioDenied)
    ON_LBN_DBLCLK(IDC_LIST_IP_ADDRESSES, OnDblclkListIpAddresses)
    ON_LBN_ERRSPACE(IDC_LIST_IP_ADDRESSES, OnErrspaceListIpAddresses)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRESSES, OnSelchangeListIpAddresses)
    ON_WM_VKEYTOITEM()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
HRESULT
CFtpSecurityPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    m_nGrantedDenied = 0;

    //
    // Build the IPL list
    //
    CError err(BuildIplOblistFromBlob(
        ((CFtpSheet *)GetSheet())->GetDirectoryProperties().m_ipl,
        m_oblAccessList,
        m_fDefaultGranted
        ));

    err.MessageBoxOnFailure(m_hWnd);
    m_nGrantedDenied = m_fDefaultGranted ? DEFAULT_GRANTED : DEFAULT_DENIED;
    m_fOldDefaultGranted = m_fDefaultGranted;

    return S_OK;
}



/* virtual */
HRESULT
CFtpSecurityPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP security page now...");
    
    BOOL fIplDirty = m_fIpDirty || (m_fOldDefaultGranted != m_fDefaultGranted);

    //
    // Use m_ notation because the message crackers require it.
    //
    CBlob m_ipl;

    if (fIplDirty)
    {
        BuildIplBlob(m_oblAccessList, m_fDefaultGranted, m_ipl);
    }

    CError err;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CFtpSheet)
        if (fIplDirty)
        {
            STORE_DIR_DATA_ON_SHEET(m_ipl);
        }
    END_META_DIR_WRITE(err)

    EndWaitCursor();

    if (err.Succeeded())
    {
        m_fIpDirty = FALSE;
        m_fOldDefaultGranted = m_fDefaultGranted;
    }

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CFtpSecurityPage::OnButtonAdd() 
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        SetControlStates();
        m_fIpDirty = TRUE;
        OnItemChanged();
    }
}



void
CFtpSecurityPage::OnButtonEdit() 
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        SetControlStates();
        m_fIpDirty = TRUE;
        OnItemChanged();
    }
}



void
CFtpSecurityPage::OnButtonRemove() 
{
    int nSel = 0;
    int nCurSel = m_list_IpAddresses.GetCurSel();

    while (m_list_IpAddresses.GetNextSelectedItem(&nSel))
    {
        m_oblAccessList.RemoveIndex(nSel);
        m_list_IpAddresses.DeleteString(nSel);
    }

    m_fIpDirty = TRUE;
    OnItemChanged();

    if (nCurSel > 0)
    {
        --nCurSel;
    }

    m_list_IpAddresses.SetCurSel(nCurSel);

    if (!SetControlStates())
    {
        m_button_Add.SetFocus();
    }
}



BOOL
CFtpSecurityPage::SetControlStates()
/*++

Routine Description:
    
    Set the enabled status of the controls depending on the current
    state of the dialog

Arguments:

    None

Return Value:

    TRUE if at least one item is currently selected in the listbox

--*/
{
    BOOL fSomeSelection = m_list_IpAddresses.GetSelCount() > 0;

    m_button_Edit.EnableWindow(m_list_IpAddresses.GetSelCount() == 1);
    m_button_Remove.EnableWindow(m_list_IpAddresses.GetSelCount() > 0);

    return fSomeSelection;
}



void
CFtpSecurityPage::FillListBox(
    IN CIPAccessDescriptor * pSelection OPTIONAL
    )
/*++

Routine Description:

    Populate the listbox with the access list
    entries

Arguments:

    CIPAccessDescriptor * pSelection : Item to be selected or NULL.

Return Value:

    None

--*/
{
    CObListIter obli(m_oblAccessList);
    const CIPAccessDescriptor * pAccess;

    m_list_IpAddresses.SetRedraw(FALSE);
    m_list_IpAddresses.ResetContent();

    int cItems = 0 ;
    int nSel = LB_ERR, nItem;

    for ( /**/ ; pAccess = (CIPAccessDescriptor *)obli.Next(); ++cItems)
    {
        //
        // We only list those not adhering to the default
        //
        if (pAccess->HasAccess() != m_fDefaultGranted)
        {
            nItem = m_list_IpAddresses.AddItem(pAccess);

            if (pAccess == pSelection)
            {
                //
                // Found item to be selected
                //
                nSel = nItem;
            }
        }
    }

    m_list_IpAddresses.SetCurSel(nSel);
    m_list_IpAddresses.SetRedraw(TRUE);
}



DWORD
CFtpSecurityPage::SortAccessList()
/*++

Routine Description:

    Sorting the access list by grant denied and ip address
    FillListBox() should be called after this because
    the listbox will no longer reflect the true status
    of the list of directories.

Arguments:

    None

Return Value:
    
    Error return code

--*/
{
    BeginWaitCursor();
    DWORD dw =  m_oblAccessList.Sort(
        (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CIPAccessDescriptor::OrderByAddress);
    EndWaitCursor();

    return dw;
}



INT_PTR
CFtpSecurityPage::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit. Return the value returned 
    by the dialog

Arguments:

    BOOL fAdd : If TRUE, create new item.  Otherwise, edit existing item

Return Value:

    Dialog return code (IDOK/IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CIPAccessDescriptor * pAccess = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        //
        // Edit existing entry -- there better be only one...
        //
        pAccess = m_list_IpAddresses.GetSelectedItem();
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            //
            // Double click?
            //
            return IDCANCEL;
        }
    }

    CIPAccessDlg dlgAccess(
        m_fDefaultGranted, 
        pAccess, 
        &m_oblAccessList, 
        this
        );

    INT_PTR nReturn = dlgAccess.DoModal();

    if (nReturn == IDOK)
    {
        CError err;
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            try
            {
                if (fAdd)
                {
                    m_oblAccessList.AddTail(pAccess);
                }

                SortAccessList();
                FillListBox(pAccess);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;    
                e->Delete();
            }
        }

        err.MessageBoxOnFailure(m_hWnd);
    }

    return nReturn;
}



void
CFtpSecurityPage::OnDblclkListIpAddresses()
/*++

Routine Description:

    Map listbox double click to the edit button

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CFtpSecurityPage::OnErrspaceListIpAddresses()
/*++

Routine Description:

    Handle error condition in the ip address listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFtpSecurityPage::OnSelchangeListIpAddresses()
/*++

Routine Description:

    Handle change in the selection of the listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFtpSecurityPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function
    
Arguments:

    None
    
Return Value:

    None

--*/
{
    SetModified(TRUE);
}



BOOL
CFtpSecurityPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_icon_Granted.SetIcon(::AfxGetApp()->LoadIcon(IDI_GRANTED));
    m_icon_Denied.SetIcon(::AfxGetApp()->LoadIcon(IDI_DENIED));

    m_list_IpAddresses.Initialize();

    m_list_IpAddresses.EnableWindow(HasIPAccessCheck());
    m_button_Add.EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_RADIO_GRANTED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_RADIO_DENIED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_GRANTED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_DENIED)->EnableWindow(HasIPAccessCheck());

    FillListBox();
    SetControlStates();

    return TRUE;  
}



void
CFtpSecurityPage::OnRadioGranted()
/*++

Routine Description:

    Granted by default has been selected.
    Refill the listbox with items that have
    been explicitly denied.  Although we can
    only have a deny list or a grant list,
    we keep both of them around until it comes
    time to saving the information.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fDefaultGranted)
    {
        m_fDefaultGranted = TRUE;
        FillListBox();
        OnItemChanged();
        SetControlStates();
    }
}



void
CFtpSecurityPage::OnRadioDenied()
/*++

Routine Description:

    As above, but reverse granted and denied 

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fDefaultGranted)
    {
        m_fDefaultGranted = FALSE;
        FillListBox();
        OnItemChanged();
        SetControlStates();
    }
}



int
CFtpSecurityPage::OnVKeyToItem(
    IN UINT nKey, 
    IN CListBox * pListBox, 
    IN UINT nIndex
    ) 
/*++

Routine Description:

    Map insert and delete keys for the listbox

Arguments:

    UINT nKey               : Key pressed
    CListBox * pListBox     : Listbox
    UINT nIndex             : Index selected

Return Value:

    -2 if fully handled, -1 if partially handled, 0+ if not
    handled at all    

--*/
{
    switch(nKey)
    {
    case VK_DELETE:
        OnButtonRemove();
        break;

    case VK_INSERT:
        OnButtonAdd();
        break;

    default:
        //
        // Not completely handled by this function, let
        // windows handle the remaining default action.
        //
        return -1;
    }

    //
    // No further action is neccesary.
    //
    return -2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\ftpaddnew.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        FtpAddNew.cpp

   Abstract:
        Classes for new FTP site and virtual directory creation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/8/2000       sergeia     Initial creation
--*/

#ifndef _FTP_NEW_WIZARD_H
#define _FTP_NEW_WIZARD_H

class CFtpWizSettings : public CObjectPlus
/*++

Class Description:

    FTP Wizard settings intended to pass along from page
    to page

--*/
{
//
// Constructor/Destructor
//
public:
    CFtpWizSettings(
        CMetaKey * pMetaKey,
        LPCTSTR lpszServerName,
        BOOL fNewSite,
        DWORD   dwInstance   = MASTER_INSTANCE,
        LPCTSTR lpszParent   = NULL
        );

//
// Public Properties
//
public:
    DWORD   m_VersionMajor;
    BOOL    m_fNewSite;
    BOOL    m_fLocal;
    BOOL    m_fUNC;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fDelegation;
    DWORD   m_dwInstance;        // site instance number
    CString m_strParent;
    CString m_strServerName;     // machine name
    CString m_strDescription;
    CString m_strBinding;
    CString m_strAlias;
    CString m_strPath;
    CString m_strUserName;
    CStrPassword m_strPassword;
	int     m_UserIsolation;
	CString m_strIsolationUserName;
	CStrPassword m_strIsolationUserPassword;
	CString m_strIsolationDomain;
    HRESULT m_hrResult;
    CMetaKey * m_pKey;
};


//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CFtpWizDescription : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizDescription)
//
// Construction
//
public:
    CFtpWizDescription(CFtpWizSettings * pwsSettings = NULL);
    ~CFtpWizDescription();

//
// Dialog Data
//
protected:
    enum { IDD = IDD_FTP_NEW_INST_DESCRIPTION };
    //{{AFX_DATA(CFtpWizDescription)
    CEdit   m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizDescription)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizDescription)
    afx_msg void OnChangeEditDescription();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
};



//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizBindings : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizBindings)

//
// Construction
//
public:
    CFtpWizBindings(CFtpWizSettings * pSettings = NULL);
    ~CFtpWizBindings();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizBindings)
    enum { IDD = IDD_FTP_NEW_INST_BINDINGS };
    int        m_nIpAddressSel;
    UINT       m_nTCPPort;
    CComboBox  m_combo_IpAddresses;
    //}}AFX_DATA

    CIPAddress  m_iaIpAddress;
    CObListPlus m_oblIpAddresses;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizBindings)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizBindings)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
};



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizAlias : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizAlias)

//
// Construction
//
public:
    CFtpWizAlias(CFtpWizSettings * pwsSettings = NULL);
    ~CFtpWizAlias();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizAlias)
    enum { IDD = IDD_FTP_NEW_DIR_ALIAS };
    CEdit   m_edit_Alias;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizAlias)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizAlias)
    afx_msg void OnChangeEditAlias();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();


private:
    CFtpWizSettings * m_pSettings;
};



//
// Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizPath : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizPath)

//
// Construction
//
public:
    CFtpWizPath(
		CFtpWizSettings * pwsSettings = NULL,
        BOOL bVDir = TRUE
        );
    ~CFtpWizPath();

    int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizPath)
    enum { IDD = -1 };
    CEdit   m_edit_Path;
    CButton m_button_Browse;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizPath)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizPath)
    afx_msg void OnChangeEditPath();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
    LPTSTR m_pPathTemp;
    CString m_strBrowseTitle;
};



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizUserName : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizUserName)

//
// Construction
//
public:
    CFtpWizUserName(
        IN CFtpWizSettings * pSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CFtpWizUserName();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizUserName)
    enum { IDD = IDD_FTP_NEW_USER_PASSWORD };
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    CButton m_chk_Delegation;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizUserName)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizUserName)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnChangeEditUsername();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnCheckDelegation();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
	BOOL m_fMovingBack;
};



//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizPermissions : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizPermissions)

//
// Construction
//
public:
    CFtpWizPermissions(
        IN CFtpWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CFtpWizPermissions();

//
// Dialog Data
//
    //{{AFX_DATA(CFtpWizPermissions)
    enum { IDD = IDD_FTP_NEW_PERMS };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizPermissions)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizPermissions)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
    BOOL m_bVDir;
};

class CFtpWizUserIsolation : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizUserIsolation)

//
// Construction
//
public:
    CFtpWizUserIsolation(
        IN CFtpWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = FALSE
        );

    ~CFtpWizUserIsolation();

//
// Dialog Data
//
    //{{AFX_DATA(CFtpWizUserIsolation)
    enum { IDD = IDD_FTP_NEW_USER_ISOLATION };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizUserIsolation)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizUserIsolation)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
    BOOL m_bVDir;
};

class CFtpWizUserIsolationAD : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizUserIsolationAD)

//
// Construction
//
public:
    CFtpWizUserIsolationAD(
        IN CFtpWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = FALSE
        );

    ~CFtpWizUserIsolationAD();

//
// Dialog Data
//
    CEdit   m_edit_UserName;
    //{{AFX_DATA(CFtpWizUserIsolationAD)
    enum { IDD = IDD_FTP_NEW_USER_ISOLATION_AD };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizUserIsolationAD)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    virtual LRESULT OnWizardBack();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizUserIsolationAD)
    virtual BOOL OnInitDialog();
	afx_msg void OnBrowseUsers();
	afx_msg void OnBrowseDomains();
	afx_msg void OnControlsChanged();
	afx_msg void OnChangeUserName();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
    BOOL m_bVDir;
    BOOL m_fInDomain;
	BOOL m_fOnBack;
	BOOL m_fOnNext;
};

#endif //_FTP_NEW_WIZARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fservic.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        fservic.h

   Abstract:

        FTP Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FSERVIC_H__
#define __FSERVIC_H__


//{{AFX_INCLUDES()
#include "logui.h"
//}}AFX_INCLUDES



class CFtpServicePage : public CInetPropertyPage
/*++

Class Description:

    FTP Service property page

Public Interface:

    CFtpServicePage  : Constructor
    ~CFtpServicePage : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpServicePage)

//
// Constructors/Destructors
//
public:
    CFtpServicePage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpServicePage();

//
// Dialog Data
//
protected:
    //
    //  Radio button IDs for unlimited radio control
    //
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CFtpServicePage)
    enum { IDD = IDD_FTP_SERVICE };
    int         m_nUnlimited;
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    BOOL        m_fEnableLogging;
    CString     m_strComment;
    CEdit       m_edit_MaxConnections;
    CStatic     m_static_LogPrompt;
    CButton     m_button_LogProperties;
    CComboBox   m_combo_IpAddresses;
    CComboBox   m_combo_LogFormats;
    //}}AFX_DATA

    UINT        m_nOldTCPPort;
    BOOL        m_fUnlimitedConnections;
    DWORD       m_dwLogType;
    CILong      m_nConnectionTimeOut;
    CILong      m_nMaxConnections;
    CILong      m_nVisibleMaxConnections;
    CString     m_strDomainName;
    CIPAddress  m_iaIpAddress;
    CLogUI      m_ocx_LogProperties;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpServicePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    void SetControlStates();
    void SetLogState();
    void PopulateKnownIpAddresses();
    //LPCTSTR QueryMetaPath();

    //{{AFX_MSG(CFtpServicePage)
    afx_msg void OnCheckEnableLogging();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    afx_msg void OnButtonCurrentSessions();
    afx_msg void OnButtonProperties();
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

protected:
    CObListPlus m_oblIpAddresses;
    BOOL m_f10ConnectionLimit;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

/*
inline LPCTSTR CFtpServicePage::QueryMetaPath()
{
    return ((CFtpSheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}
*/

#endif // __FSERVIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\ftpsht.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        machsht.cpp

   Abstract:
        IIS Machine Property sheet classes

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager (cluster edition)

   Revision History:

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "ftpsht.h"



//
// Help IDs.  Home directory gets substituted.
//
#define HIDD_FTP_DIRECTORY_PROPERTIES       (IDD_FTP_DIRECTORY_PROPERTIES + 0x20000)
#define HIDD_FTP_HOME_DIRECTORY_PROPERTIES  (HIDD_FTP_DIRECTORY_PROPERTIES + 0x20000)



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



CFTPInstanceProps::CFTPInstanceProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor for FTP instance properties

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    N/A

--*/
    : CInstanceProps(pAuthInfo, lpszMDPath, 21U),
      m_nMaxConnections((LONG)0L),
      m_nConnectionTimeOut((LONG)0L),
      m_dwLogType(MD_LOG_TYPE_DISABLED),
      /**/
      m_strUserName(),
      m_strPassword(),
      m_fAllowAnonymous(FALSE),
      m_fOnlyAnonymous(FALSE),
      m_fPasswordSync(TRUE),
      m_acl(),
      /**/
      m_strExitMessage(),
      m_strMaxConMsg(),
      m_strlWelcome(),
	  m_strlBanner(),
      /**/
      m_fDosDirOutput(TRUE),
      /**/
      m_dwDownlevelInstance(1)
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
    m_UserIsolation = 0;
}



/* virtual */
void
CFTPInstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CInstanceProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      //
      // Service Page
      //
      HANDLE_META_RECORD(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      HANDLE_META_RECORD(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      HANDLE_META_RECORD(MD_LOG_TYPE,            m_dwLogType)
      //
      // Accounts Page
      //
      HANDLE_META_RECORD(MD_ANONYMOUS_USER_NAME,   m_strUserName)
      HANDLE_META_RECORD(MD_ANONYMOUS_PWD,         m_strPassword)
      HANDLE_META_RECORD(MD_ANONYMOUS_ONLY,        m_fOnlyAnonymous)
      HANDLE_META_RECORD(MD_ALLOW_ANONYMOUS,       m_fAllowAnonymous)
//	  if (QueryMajorVersion() < 6)
	  {
          HANDLE_META_RECORD(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
	  }
      HANDLE_META_RECORD(MD_ADMIN_ACL,             m_acl)
      //
      // Message Page
      //
      HANDLE_META_RECORD(MD_EXIT_MESSAGE,        m_strExitMessage)
      HANDLE_META_RECORD(MD_MAX_CLIENTS_MESSAGE, m_strMaxConMsg)
      HANDLE_META_RECORD(MD_GREETING_MESSAGE,    m_strlWelcome)
      HANDLE_META_RECORD(MD_BANNER_MESSAGE,		 m_strlBanner)
      //
      // Directory Properties Page
      //
      HANDLE_META_RECORD(MD_MSDOS_DIR_OUTPUT,    m_fDosDirOutput);
      //
      // Default Site
      //
      HANDLE_META_RECORD(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance)
      HANDLE_META_RECORD(MD_MAX_BANDWIDTH, m_dwMaxBandwidth)
      //
      HANDLE_META_RECORD(MD_USER_ISOLATION, m_UserIsolation);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CFTPInstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CInstanceProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    BEGIN_META_WRITE()
      //
      // Service Page
      //
      META_WRITE(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      META_WRITE(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      META_WRITE(MD_LOG_TYPE,            m_dwLogType)
      //
      // Accounts Page
      //
      META_WRITE(MD_ANONYMOUS_USER_NAME,   m_strUserName)
      META_WRITE(MD_ANONYMOUS_PWD,         m_strPassword)
      META_WRITE(MD_ANONYMOUS_ONLY,        m_fOnlyAnonymous)
      META_WRITE(MD_ALLOW_ANONYMOUS,       m_fAllowAnonymous)
//	  if (QueryMajorVersion() < 6)
	  {
          META_WRITE(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
	  }
      META_WRITE(MD_ADMIN_ACL,             m_acl)
      //
      // Message Page
      //
      META_WRITE(MD_EXIT_MESSAGE,        m_strExitMessage)
      META_WRITE(MD_MAX_CLIENTS_MESSAGE, m_strMaxConMsg)
      META_WRITE(MD_GREETING_MESSAGE,    m_strlWelcome)
      META_WRITE(MD_BANNER_MESSAGE,		 m_strlBanner)
      //
      // Directory Properties Page
      //
      META_WRITE(MD_MSDOS_DIR_OUTPUT,    m_fDosDirOutput);
      //
      // Default Site
      //
      META_WRITE(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance)
      META_WRITE(MD_MAX_BANDWIDTH, m_dwMaxBandwidth)
    END_META_WRITE(err);

    return err;
}



CFTPDirProps::CFTPDirProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    FTP Directory properties object

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    N/A.

--*/
    : CChildNodeProps(
        pAuthInfo,
        lpszMDPath,
        WITH_INHERITANCE,
        FALSE               // Complete information
        ),
      /**/
      m_fDontLog(FALSE),
      m_ipl()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CFTPDirProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CChildNodeProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,  m_pbMDData)
      HANDLE_META_RECORD(MD_VR_USERNAME,      m_strUserName)
      HANDLE_META_RECORD(MD_VR_PASSWORD,      m_strPassword)
      HANDLE_META_RECORD(MD_DONT_LOG,         m_fDontLog);
      HANDLE_META_RECORD(MD_IP_SEC,           m_ipl);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CFTPDirProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CChildNodeProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    //
    // CODEWORK: Consider DDX/DDV like methods which do both
    // ParseFields and WriteDirtyProps in a single method.  Must
    // take care not to write data which should only be read, not
    // written
    //
    BEGIN_META_WRITE()
      META_WRITE(MD_VR_USERNAME,      m_strUserName)
      META_WRITE(MD_VR_PASSWORD,      m_strPassword)
      META_WRITE(MD_DONT_LOG,         m_fDontLog);
      META_WRITE(MD_IP_SEC,           m_ipl);
    END_META_WRITE(err);

    return err;
}



//
// FTP Property Sheet Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CFtpSheet::CFtpSheet(
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMetaPath,
    CWnd *  pParentWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    UINT iSelectPage          
    )
/*++

Routine Description:

    FTP Property sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pAuthInfo,
        lpszMetaPath,
        pParentWnd,
        lParam,
        lParamParent,
        iSelectPage
        ),
      m_ppropInst(NULL),
      m_ppropDir(NULL)
{
}



CFtpSheet::~CFtpSheet()
/*++

Routine Description:

    FTP Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    FreeConfigurationParameters();
}


HRESULT
CFtpSheet::SetSheetType(int fSheetType)
{
    m_fSheetType = fSheetType;
	return S_OK;
}


void
CFtpSheet::WinHelp(
    IN DWORD dwData,
    IN UINT  nCmd
    )
/*++

Routine Description:

    FTP Property sheet help handler

Arguments:

    DWORD dwData            : WinHelp data (dialog ID)
    UINT nCmd               : WinHelp command

Return Value:

    None

Notes:

    Replace the dialog ID if this is the directory tab.  We have
    different help depending on virtual directory, home, file, directory.

--*/
{
    ASSERT(m_ppropDir != NULL);

    if (dwData == HIDD_FTP_DIRECTORY_PROPERTIES)
    {
        if (m_fSheetType == SHEET_TYPE_FILE)
        {
            // do nothing...
        }
        else if (m_fSheetType == SHEET_TYPE_DIR)
        {
            // do nothing...
        }
        else if (m_fSheetType == SHEET_TYPE_VDIR)
        {
            dwData = HIDD_FTP_DIRECTORY_PROPERTIES;
        }
        else if (m_fSheetType == SHEET_TYPE_SERVER)
        {
            dwData = HIDD_FTP_HOME_DIRECTORY_PROPERTIES;
        }
        else if  (m_fSheetType == SHEET_TYPE_SITE)
        {
            dwData = HIDD_FTP_HOME_DIRECTORY_PROPERTIES;
		}
        else
        {
            ASSERT(m_ppropDir != NULL);
            if (!::lstrcmpi(m_ppropDir->m_strAlias, g_cszRoot))
            {
                //
                // It's a home virtual directory -- change the ID
                //
                dwData = HIDD_FTP_HOME_DIRECTORY_PROPERTIES;
            }
        }

    }

    WinHelpDebug(dwData);
    CInetPropertySheet::WinHelp(dwData, nCmd);
}



/* virtual */ 
HRESULT 
CFtpSheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Load base properties
    //
    CError err(CInetPropertySheet::LoadConfigurationParameters());

    if (err.Failed())
    {
        return err;
    }

    if (m_ppropInst == NULL)
    {
        //
        // First call -- load values
        //
        ASSERT(m_ppropDir == NULL);

        m_ppropInst = new CFTPInstanceProps(QueryAuthInfo(), QueryInstancePath());
        m_ppropDir  = new CFTPDirProps(QueryAuthInfo(), QueryDirectoryPath());

        if (!m_ppropInst || !m_ppropDir)
        {
            TRACEEOLID("LoadConfigurationParameters: OOM");
            SAFE_DELETE(m_ppropDir);
            SAFE_DELETE(m_ppropInst);

            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_ppropInst->LoadData();

        if (err.Succeeded())
        {
            err = m_ppropDir->LoadData();
        }
    }

    return err;
}



/* virtual */ 
void 
CFtpSheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Base class
    //
    CInetPropertySheet::FreeConfigurationParameters();

    ASSERT(m_ppropInst != NULL);
    ASSERT(m_ppropDir  != NULL);

    SAFE_DELETE(m_ppropInst);
    SAFE_DELETE(m_ppropDir);
}




//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\ftpaddnew.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        FtpAddNew.cpp

   Abstract:

        Implementation for classes used in creation of new FTP site and virtual directory

   Author:

        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        11/8/2000       sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "wizard.h"
#include "FtpAddNew.h"
#include <dsclient.h>
#include <Dsgetdc.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define DEF_PORT        (21)
#define MAX_ALIAS_NAME (240)        // Ref Bug 241148

HRESULT
RebindInterface(OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue, IN  DWORD dwCancelError);

extern CComModule _Module;
extern CInetmgrApp theApp;

HRESULT
CIISMBNode::AddFTPSite(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    DWORD * inst
    )
{

   CFtpWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName(),
      TRUE
      );
   ws.m_VersionMajor = m_pOwner->QueryMajorVersion();

   CIISWizardSheet sheet(
      IDB_WIZ_FTP_LEFT, IDB_WIZ_FTP_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_FTP_NEW_SITE_WELCOME, 
        IDS_FTP_NEW_SITE_WIZARD, 
        IDS_FTP_NEW_SITE_BODY
        );
   CFtpWizDescription pgDescr(&ws);
   CFtpWizBindings pgBindings(&ws);
   CFtpWizUserIsolation pgUserIsolate(&ws, FALSE);
   CFtpWizPath pgHome(&ws, FALSE);
   CFtpWizUserName pgUserName(&ws, FALSE);
   CFtpWizUserIsolationAD pgUserIsolateAD(&ws, FALSE);
   CFtpWizPermissions pgPerms(&ws, FALSE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_FTP_NEW_SITE_SUCCESS,
        IDS_FTP_NEW_SITE_FAILURE,
        IDS_FTP_NEW_SITE_WIZARD
        );

   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgDescr);
   sheet.AddPage(&pgBindings);
   if (GetOwner()->QueryMajorVersion() >= 6)
   {
      sheet.AddPage(&pgUserIsolate);
      sheet.AddPage(&pgUserIsolateAD);
   }
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   CThemeContextActivator activator(theApp.GetFusionInitHandle());

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
   if (inst != NULL && ws.m_dwInstance != 0)
   {
      *inst = ws.m_dwInstance;
   }
   return ws.m_hrResult;
}

HRESULT
CIISMBNode::AddFTPVDir(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    CString& alias
    )
{

   CFtpWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName(),
      FALSE
      );
   CComBSTR path;
   BuildMetaPath(path);
   ws.m_strParent = path;
   CIISWizardSheet sheet(
      IDB_WIZ_FTP_LEFT, IDB_WIZ_FTP_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_FTP_NEW_VDIR_WELCOME, 
        IDS_FTP_NEW_VDIR_WIZARD, 
        IDS_FTP_NEW_VDIR_BODY
        );
   CFtpWizAlias pgAlias(&ws);
   CFtpWizPath pgHome(&ws, TRUE);
   CFtpWizUserName pgUserName(&ws, TRUE);
   CFtpWizPermissions pgPerms(&ws, TRUE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_FTP_NEW_VDIR_SUCCESS,
        IDS_FTP_NEW_VDIR_FAILURE,
        IDS_FTP_NEW_VDIR_WIZARD
        );

   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgAlias);
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   CThemeContextActivator activator(theApp.GetFusionInitHandle());

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
   if (SUCCEEDED(ws.m_hrResult))
   {
       alias = ws.m_strAlias;
   }
   return ws.m_hrResult;
}

CFtpWizSettings::CFtpWizSettings(
        CMetaKey * pMetaKey,
        LPCTSTR lpszServerName,     
        BOOL fNewSite,
        DWORD   dwInstance,
        LPCTSTR lpszParent
        ) :
        m_hrResult(S_OK),
        m_pKey(pMetaKey),
        m_fNewSite(fNewSite),
        m_fUNC(FALSE),
        m_fRead(FALSE),
        m_fWrite(FALSE),
		m_fDelegation(TRUE), // on by default
        m_dwInstance(dwInstance)
{
    ASSERT(lpszServerName != NULL);

    m_strServerName = lpszServerName;
    m_fLocal = IsServerLocal(m_strServerName);
    if (lpszParent)
    {
        m_strParent = lpszParent;
    }
}


IMPLEMENT_DYNCREATE(CFtpWizDescription, CIISWizardPage)

CFtpWizDescription::CFtpWizDescription(CFtpWizSettings * pData)
    : CIISWizardPage(
        CFtpWizDescription::IDD, IDS_FTP_NEW_SITE_WIZARD, HEADER_PAGE
        ),
      m_pSettings(pData)
{
}

CFtpWizDescription::~CFtpWizDescription()
{
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizDescription, CIISWizardPage)
   //{{AFX_MSG_MAP(CFtpWizDescription)
   ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void
CFtpWizDescription::OnChangeEditDescription()
{
   SetControlStates();
}

LRESULT
CFtpWizDescription::OnWizardNext()
{
   if (!ValidateString(m_edit_Description, 
         m_pSettings->m_strDescription, 1, MAX_PATH))
   {
      return -1;
   }
   return CIISWizardPage::OnWizardNext();
}

BOOL
CFtpWizDescription::OnSetActive()
{
   SetControlStates();
   return CIISWizardPage::OnSetActive();
}

void
CFtpWizDescription::DoDataExchange(CDataExchange * pDX)
{
   CIISWizardPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CFtpWizDescription)
   DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
   //}}AFX_DATA_MAP
}

void
CFtpWizDescription::SetControlStates()
{
   DWORD dwFlags = PSWIZB_BACK;

   if (m_edit_Description.GetWindowTextLength() > 0)
   {
      dwFlags |= PSWIZB_NEXT;
   }
    
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);
}

///////////////////////////////////////////

//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CFtpWizAlias, CIISWizardPage)



CFtpWizAlias::CFtpWizAlias(
    IN OUT CFtpWizSettings * pSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CFtpWizAlias::IDD,
        IDS_FTP_NEW_VDIR_WIZARD,
        HEADER_PAGE
        ),
      m_pSettings(pSettings)
      //m_strAlias()
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CFtpWizAlias)
    m_strAlias = _T("");
    //}}AFX_DATA_INIT

#endif // 0
}



CFtpWizAlias::~CFtpWizAlias()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpWizAlias::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizAlias)
    DDX_Control(pDX, IDC_EDIT_ALIAS, m_edit_Alias);
    //}}AFX_DATA_MAP
}



LRESULT
CFtpWizAlias::OnWizardNext() 
/*++

Routine Description:

    prevent the / and \ characters from being in the alias name

Arguments:

    None

Return Value:

    None

--*/
{
    if (!ValidateString(
        m_edit_Alias, 
        m_pSettings->m_strAlias, 
        1, 
        MAX_ALIAS_NAME
        ))
    {
        return -1;
    }

    //
    // Find the illegal characters. If they exist tell 
    // the user and don't go on.
    //
    if (m_pSettings->m_strAlias.FindOneOf(_T("/\\?*")) >= 0)
    {
		EditShowBalloon(m_edit_Alias.m_hWnd, IDS_ILLEGAL_ALIAS_CHARS);
        //
        // prevent the wizard page from changing
        //
        return -1;
    }

    //
    // Allow the wizard to continue
    //
    return CIISWizardPage::OnWizardNext();
}



void
CFtpWizAlias::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Alias.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizAlias, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizAlias)
    ON_EN_CHANGE(IDC_EDIT_ALIAS, OnChangeEditAlias)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CFtpWizAlias::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void
CFtpWizAlias::OnChangeEditAlias() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}


///////////////////////////////////////////


IMPLEMENT_DYNCREATE(CFtpWizBindings, CIISWizardPage)


CFtpWizBindings::CFtpWizBindings(
    IN OUT CFtpWizSettings * pSettings
    ) 
    : CIISWizardPage(CFtpWizBindings::IDD,
        IDS_FTP_NEW_SITE_WIZARD, HEADER_PAGE
        ),
      m_pSettings(pSettings),
      m_iaIpAddress(),
      m_oblIpAddresses()
{
    //{{AFX_DATA_INIT(CFtpWizBindings)
    m_nTCPPort = DEF_PORT;
    m_nIpAddressSel = -1;
    //}}AFX_DATA_INIT
}

CFtpWizBindings::~CFtpWizBindings()
{
}

void
CFtpWizBindings::DoDataExchange(
   IN CDataExchange * pDX
   )
{
   CIISWizardPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CFtpWizBindings)
   DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_EDIT_TCP_PORT, 1, 65535);
   DDX_TextBalloon(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
   //}}AFX_DATA_MAP

   DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

   if (pDX->m_bSaveAndValidate)
   {
      if (!FetchIpAddressFromCombo(
            m_combo_IpAddresses,
            m_oblIpAddresses,
            m_iaIpAddress
            ))
      {
         pDX->Fail();
      }

      CString strDomain;
      CInstanceProps::BuildBinding(
            m_pSettings->m_strBinding, 
            m_iaIpAddress, 
            m_nTCPPort, 
            strDomain
            );
   }
}

void
CFtpWizBindings::SetControlStates()
{
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT | PSWIZB_BACK);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizBindings, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizBindings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CFtpWizBindings::OnInitDialog() 
{
    CIISWizardPage::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_pSettings->m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();
    
    return TRUE;
}

BOOL
CFtpWizBindings::OnSetActive() 
{
   SetControlStates();
   return CIISWizardPage::OnSetActive();
}

///////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizPath, CIISWizardPage)

CFtpWizPath::CFtpWizPath(
    IN OUT CFtpWizSettings * pSettings,
    IN BOOL bVDir 
    ) 
    : CIISWizardPage(
        (bVDir ? IDD_FTP_NEW_DIR_PATH : IDD_FTP_NEW_INST_HOME),
        (bVDir ? IDS_FTP_NEW_VDIR_WIZARD : IDS_FTP_NEW_SITE_WIZARD),
        HEADER_PAGE
        ),
      m_pSettings(pSettings)
{

#if 0 // Keep ClassWizard happy

    //{{AFX_DATA_INIT(CFtpWizPath)
    m_strPath = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}

CFtpWizPath::~CFtpWizPath()
{
}

void
CFtpWizPath::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizPath)
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_PATH, m_pSettings->m_strPath);
    DDV_MaxCharsBalloon(pDX, m_pSettings->m_strPath, MAX_PATH);
	// We are not using DDV_FolderPath here -- it will be called too often
}

void 
CFtpWizPath::SetControlStates()
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Path.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizPath, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizPath)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnChangeEditPath)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CFtpWizPath::OnSetActive() 
{
    if (m_pSettings->m_UserIsolation == 2)
    {
        return 0;
    }
    SetControlStates();
    return CIISWizardPage::OnSetActive();
}

LRESULT
CFtpWizPath::OnWizardNext() 
{
    CString csPathMunged = m_pSettings->m_strPath;

    if (!ValidateString(m_edit_Path, m_pSettings->m_strPath, 1, MAX_PATH))
    {
        return -1;
    }
    if (!PathIsValid(m_pSettings->m_strPath,TRUE))
    {
        m_edit_Path.SetSel(0,-1);
        m_edit_Path.SetFocus();
		EditShowBalloon(m_edit_Path.m_hWnd, IDS_ERR_BAD_PATH);
		return -1;
    }

    // -------------------------------------------------------------
    // Before we do anything we need to see if it's a "special" path
    //
    // Everything after this function must validate against csPathMunged...
    // this is because IsSpecialPath could have munged it...
    // -------------------------------------------------------------
    csPathMunged = m_pSettings->m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,m_pSettings->m_strPath,csPathMunged);
#endif
    
    m_pSettings->m_fUNC = IsUNCName(csPathMunged);

    DWORD dwAllowed = CHKPATH_ALLOW_DEVICE_PATH;
    dwAllowed |= CHKPATH_ALLOW_UNC_PATH; // allow UNC type dir paths
    dwAllowed |= CHKPATH_ALLOW_UNC_SERVERSHARE_ONLY;
    // don't allow these type of paths commented out below:
    //dwAllowed |= CHKPATH_ALLOW_RELATIVE_PATH;
    //dwAllowed |= CHKPATH_ALLOW_UNC_SERVERNAME_ONLY;
    DWORD dwCharSet = CHKPATH_CHARSET_GENERAL;
    FILERESULT dwValidRet = MyValidatePath(csPathMunged,m_pSettings->m_fLocal,CHKPATH_WANT_DIR,dwAllowed,dwCharSet);
    if (FAILED(dwValidRet))
    {
        int ids = IDS_ERR_BAD_PATH;
        if (dwValidRet == CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST)
        {
            ids = IDS_ERR_PATH_NOT_FOUND;
        }
        m_edit_Path.SetSel(0,-1);
        m_edit_Path.SetFocus();
		EditShowBalloon(m_edit_Path.m_hWnd, IDS_ERR_PATH_NOT_FOUND);
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}

void
CFtpWizPath::OnChangeEditPath() 
{
    SetControlStates();
}

static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CFtpWizPath * pThis = (CFtpWizPath *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CFtpWizPath::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

void
CFtpWizPath::OnButtonBrowse() 
{
   ASSERT(m_pSettings->m_fLocal);

   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(m_pSettings->m_fNewSite ? 
            IDS_FTP_NEW_SITE_WIZARD : IDS_FTP_NEW_VDIR_WIZARD);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Path.SetWindowText(str);
       SetControlStates();
   }
}

BOOL
CFtpWizPath::OnInitDialog() 
{
   CIISWizardPage::OnInitDialog();

   m_button_Browse.EnableWindow(m_pSettings->m_fLocal);
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
   LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),TRUE);
#else
   LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),FALSE);
#endif

   return TRUE;  
}

///////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizUserName, CIISWizardPage)

CFtpWizUserName::CFtpWizUserName(
    IN OUT CFtpWizSettings * pSettings,    
    IN BOOL bVDir
    ) 
    : CIISWizardPage(
        CFtpWizUserName::IDD,
        (bVDir ? IDS_FTP_NEW_VDIR_WIZARD : IDS_FTP_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_SECURITY_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_SECURITY_SUBTITLE)
        ),
      m_pSettings(pSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CFtpWizUserName)
    //}}AFX_DATA_INIT

#endif // 0
}

CFtpWizUserName::~CFtpWizUserName()
{
}

void
CFtpWizUserName::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizUserName)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_DELEGATION, m_chk_Delegation);
    DDX_Check(pDX, IDC_DELEGATION, m_pSettings->m_fDelegation);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_pSettings->m_strUserName);
    if (pDX->m_bSaveAndValidate && !m_pSettings->m_fDelegation)
    {
        DDV_MaxCharsBalloon(pDX, m_pSettings->m_strUserName, UNLEN);
    }

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_pSettings->m_strUserName.TrimLeft();
    while (*m_pSettings->m_strUserName == '\\')
    {
        m_pSettings->m_strUserName = m_pSettings->m_strUserName.Mid(2);
    }

    if (!m_pSettings->m_fDelegation && !m_fMovingBack)
    {
		//DDX_Password(pDX, IDC_EDIT_PASSWORD, m_pSettings->m_strPassword, g_lpszDummyPassword);
        DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_pSettings->m_strPassword, g_lpszDummyPassword);
		if (pDX->m_bSaveAndValidate)
		{
			//DDV_MaxCharsBalloon(pDX, m_pSettings->m_strPassword, PWLEN);
            DDV_MaxCharsBalloon_SecuredString(pDX, m_pSettings->m_strPassword, PWLEN);
		}
    }
}



void 
CFtpWizUserName::SetControlStates()
{
    DWORD dwFlags = PSWIZB_BACK;
    BOOL bEnable = BST_CHECKED != m_chk_Delegation.GetCheck();
    if (m_edit_UserName.GetWindowTextLength() > 0 || !bEnable)
    {
        dwFlags |= PSWIZB_NEXT;
    }

	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);

    m_edit_UserName.EnableWindow(bEnable);
    m_edit_Password.EnableWindow(bEnable);
    GetDlgItem(IDC_BUTTON_BROWSE_USERS)->EnableWindow(bEnable);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizUserName, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizUserName)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_DELEGATION, OnCheckDelegation)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CFtpWizUserName::OnSetActive() 
{
    if (	!m_pSettings->m_fUNC 
		||	m_pSettings->m_UserIsolation == 1 
		||	m_pSettings->m_UserIsolation == 2
		)
    {
        return 0;
    }
    BOOL bRes = CIISWizardPage::OnSetActive();
    SetControlStates();
    return bRes;
}

BOOL
CFtpWizUserName::OnInitDialog() 
{
    CIISWizardPage::OnInitDialog();
    return TRUE;  
}

LRESULT
CFtpWizUserName::OnWizardNext() 
{
	m_fMovingBack = FALSE;
    if (BST_CHECKED != m_chk_Delegation.GetCheck())
    {
        if (!ValidateString(m_edit_UserName, m_pSettings->m_strUserName, 1, UNLEN))
        {
            return -1;
        }
    }    
    return CIISWizardPage::OnWizardNext();
}

LRESULT
CFtpWizUserName::OnWizardBack() 
{
	m_fMovingBack = TRUE;
    return CIISWizardPage::OnWizardNext();
}

void
CFtpWizUserName::OnButtonBrowseUsers() 
{
    CString str;

    if (GetIUsrAccount(m_pSettings->m_strServerName, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}

void
CFtpWizUserName::OnChangeEditUsername() 
{
   m_edit_Password.SetWindowText(_T(""));
   SetControlStates();
}

void
CFtpWizUserName::OnCheckDelegation()
{
    SetControlStates();
}

void 
CFtpWizUserName::OnButtonCheckPassword() 
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CString csTempPassword;
    m_pSettings->m_strPassword.CopyTo(csTempPassword);
    CError err(CComAuthInfo::VerifyUserPassword(
        m_pSettings->m_strUserName, 
        csTempPassword
        ));

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
       DoHelpMessageBox(m_hWnd,IDS_PASSWORD_OK, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
    }
}

////////////////// User Isolation page //////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizUserIsolation, CIISWizardPage)

CFtpWizUserIsolation::CFtpWizUserIsolation(
    IN OUT CFtpWizSettings * pSettings,
    IN BOOL bVDir
    ) 
    : CIISWizardPage(
        CFtpWizUserIsolation::IDD,
        IDS_FTP_NEW_SITE_WIZARD,
        HEADER_PAGE,
        USE_DEFAULT_CAPTION,
        USE_DEFAULT_CAPTION
        ),
      m_bVDir(bVDir),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CFtpWizUserIsolation)
    //}}AFX_DATA_INIT
    m_pSettings->m_UserIsolation  = 0;
}

CFtpWizUserIsolation::~CFtpWizUserIsolation()
{
}

void
CFtpWizUserIsolation::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizPermissions)
    //}}AFX_DATA_MAP
    DDX_Radio(pDX, IDC_NO_ISOLATION,  m_pSettings->m_UserIsolation);
}

void
CFtpWizUserIsolation::SetControlStates()
{
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizUserIsolation, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizUserIsolation)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BOOL
CFtpWizUserIsolation::OnSetActive() 
{
    if (m_pSettings->m_VersionMajor < 6)
    {
        return 0;
    }
    SetControlStates();
    return CIISWizardPage::OnSetActive();
}

LRESULT
CFtpWizUserIsolation::OnWizardNext() 
{
    if (!UpdateData(TRUE))
    {
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}

////////////////// User Isolation AD page //////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizUserIsolationAD, CIISWizardPage)

CFtpWizUserIsolationAD::CFtpWizUserIsolationAD(
    IN OUT CFtpWizSettings * pSettings,
    IN BOOL bVDir
    ) 
    : CIISWizardPage(
        CFtpWizUserIsolationAD::IDD,
        IDS_FTP_NEW_SITE_WIZARD,
        HEADER_PAGE,
        USE_DEFAULT_CAPTION,
        USE_DEFAULT_CAPTION
        ),
      m_bVDir(bVDir),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CFtpWizPermissions)
    //}}AFX_DATA_INIT
}

CFtpWizUserIsolationAD::~CFtpWizUserIsolationAD()
{
}

void
CFtpWizUserIsolationAD::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizPermissions)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    //}}AFX_DATA_MAP
    DDX_Text(pDX, IDC_EDIT_USERNAME,  m_pSettings->m_strIsolationUserName);
	DDV_MaxCharsBalloon(pDX, m_pSettings->m_strIsolationUserName, UNLEN);
    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_pSettings->m_strIsolationUserName.TrimLeft();
    while (*m_pSettings->m_strIsolationUserName == '\\')
    {
        m_pSettings->m_strIsolationUserName = m_pSettings->m_strIsolationUserName.Mid(2);
    }

	if (!m_fOnBack)
	{
		//DDX_Password(pDX, IDC_EDIT_PASSWORD, m_pSettings->m_strIsolationUserPassword, g_lpszDummyPassword);
        DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_pSettings->m_strIsolationUserPassword, g_lpszDummyPassword);
		//DDV_MaxCharsBalloon(pDX, m_pSettings->m_strIsolationUserPassword, PWLEN);
        DDV_MaxCharsBalloon_SecuredString(pDX, m_pSettings->m_strIsolationUserPassword, PWLEN);
	}
	DDX_Text(pDX, IDC_EDIT_DOMAIN,  m_pSettings->m_strIsolationDomain);
	DDV_MaxCharsBalloon(pDX, m_pSettings->m_strIsolationDomain, MAX_PATH);
#if 0
	if (pDX->m_bSaveAndValidate && !m_fOnBack)
	{
		// we could have domain1\user and domain2 case, so this is wrong
		CString name = m_pSettings->m_strIsolationDomain;
		if (!name.IsEmpty())
		{
			name += _T('\\');
		}
		name += m_pSettings->m_strIsolationUserName;
        CString csTempPassword;
        m_pSettings->m_strIsolationUserPassword.CopyTo(csTempPassword);
		CError err(CComAuthInfo::VerifyUserPassword(name, csTempPassword));
	//        CError err(IsValidDomainUser(name, m_pSettings->m_strIsolationUserPassword));
		if (err.MessageBoxOnFailure(m_hWnd))
		{
   			SetWizardButtons(PSWIZB_BACK);
			pDX->PrepareEditCtrl(IDC_EDIT_PASSWORD);
			pDX->Fail();
		}
	}
#endif
}

void
CFtpWizUserIsolationAD::SetControlStates()
{
    DWORD dwFlags = PSWIZB_BACK;

    if (	GetDlgItem(IDC_EDIT_USERNAME)->GetWindowTextLength() > 0
		&&	GetDlgItem(IDC_EDIT_PASSWORD)->GetWindowTextLength() > 0
		&&	GetDlgItem(IDC_EDIT_DOMAIN)->GetWindowTextLength() > 0
		)
    {
        dwFlags |= PSWIZB_NEXT;
    }

	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);

    GetDlgItem(IDC_BUTTON_BROWSE_DOMAINS)->EnableWindow(m_fInDomain);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizUserIsolationAD, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizUserIsolationAD)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnBrowseUsers)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_DOMAINS, OnBrowseDomains)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeUserName)
    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnControlsChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN, OnControlsChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BOOL
CFtpWizUserIsolationAD::OnInitDialog()
{
	m_fOnBack = FALSE;
	m_fOnNext = FALSE;
    CIISWizardPage::OnInitDialog();

    // Check if computer is joined to domain
    COMPUTER_NAME_FORMAT fmt = ComputerNamePhysicalDnsDomain;
    TCHAR buf[MAX_PATH];
    DWORD n = MAX_PATH;
    m_fInDomain = (GetComputerNameEx(fmt, buf, &n) && n > 0);

    return TRUE;  
}

BOOL
CFtpWizUserIsolationAD::OnSetActive() 
{
    if (m_pSettings->m_VersionMajor < 6 || m_pSettings->m_UserIsolation != 2)
    {
        return 0;
    }
	m_fOnBack = FALSE;
	m_fOnNext = FALSE;
	if (m_pSettings->m_strIsolationUserName.IsEmpty())
	{
		m_pSettings->m_strIsolationUserName = m_pSettings->m_strUserName;
		m_pSettings->m_strIsolationUserPassword = m_pSettings->m_strPassword;
	}
    SetControlStates();
    return CIISWizardPage::OnSetActive();
}

LRESULT
CFtpWizUserIsolationAD::OnWizardNext() 
{
    if (!ValidateString(m_edit_UserName, m_pSettings->m_strIsolationUserName, 
			1, UNLEN))
    {
        return -1;
    }
	m_fOnNext = TRUE;
    return CIISWizardPage::OnWizardNext();
}

LRESULT
CFtpWizUserIsolationAD::OnWizardBack() 
{
	m_fOnBack = TRUE;
    return CIISWizardPage::OnWizardNext();
}

void
CFtpWizUserIsolationAD::OnBrowseUsers()
{
    CString str;
    if (GetIUsrAccount(m_pSettings->m_strServerName, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        GetDlgItem(IDC_EDIT_USERNAME)->SetWindowText(str);
        GetDlgItem(IDC_EDIT_PASSWORD)->SetFocus();
    }
}

void
CFtpWizUserIsolationAD::OnBrowseDomains()
{
   GetDlgItem(IDC_EDIT_DOMAIN)->GetWindowText(m_pSettings->m_strIsolationDomain);
   CString prev = m_pSettings->m_strIsolationDomain;
   CComPtr<IDsBrowseDomainTree> spDsDomains;

   CError err = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          reinterpret_cast<void **>(&spDsDomains));
   if (err.Succeeded())
   {
       CString csTempPassword;
       m_pSettings->m_strIsolationUserPassword.CopyTo(csTempPassword);
      err = spDsDomains->SetComputer(m_pSettings->m_strServerName, 
		  m_pSettings->m_strIsolationUserName, csTempPassword);
      if (err.Succeeded())
      {
         LPTSTR pDomainPath = NULL;
         err = spDsDomains->BrowseTo(m_hWnd, &pDomainPath, 
            /*DBDTF_RETURNINOUTBOUND |*/ DBDTF_RETURNEXTERNAL | DBDTF_RETURNMIXEDDOMAINS);
         if (err.Succeeded() && pDomainPath != NULL)
         {
             m_pSettings->m_strIsolationDomain = pDomainPath;
             if (m_pSettings->m_strIsolationDomain.CompareNoCase(prev) != 0)
             {
				 GetDlgItem(IDC_EDIT_DOMAIN)->SetWindowText(m_pSettings->m_strIsolationDomain);
				 OnControlsChanged();
             }
             CoTaskMemFree(pDomainPath);
         }
// When user clicks on Cancel in this browser, it returns 80070001 (Incorrect function). 
// I am not quite sure what does it mean. We are filtering out the case when domain browser doesn't
// work at all (in workgroup), so here we could safely skip error processing.
//         else
//         {
//            err.MessageBox();
//         }
      }
   }
}

void
CFtpWizUserIsolationAD::OnChangeUserName()
{
	GetDlgItem(IDC_EDIT_PASSWORD)->SetWindowText(_T(""));
	SetControlStates();
}

void
CFtpWizUserIsolationAD::OnControlsChanged()
{
	SetControlStates();
}

///////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizPermissions, CIISWizardPage)

CFtpWizPermissions::CFtpWizPermissions(
    IN OUT CFtpWizSettings * pSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is a vdir page, 
                                  FALSE if this is an instance page

Return Value:

    None

--*/
    : CIISWizardPage(
        CFtpWizPermissions::IDD,
        (bVDir ? IDS_FTP_NEW_VDIR_WIZARD : IDS_FTP_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_PERMS_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_PERMS_SUBTITLE)
        ),
      m_bVDir(bVDir),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CFtpWizPermissions)
    //}}AFX_DATA_INIT

    m_pSettings->m_fRead  = TRUE;
    m_pSettings->m_fWrite = FALSE;
}

CFtpWizPermissions::~CFtpWizPermissions()
{
}

void
CFtpWizPermissions::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizPermissions)
    //}}AFX_DATA_MAP

    DDX_Check(pDX, IDC_CHECK_READ,  m_pSettings->m_fRead);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_pSettings->m_fWrite);
}

void
CFtpWizPermissions::SetControlStates()
{
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizPermissions, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizPermissions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
CFtpWizPermissions::OnSetActive() 
{
   SetControlStates();
   return CIISWizardPage::OnSetActive();
}

LRESULT
CFtpWizPermissions::OnWizardNext() 
{
    if (!UpdateData(TRUE))
    {
        return -1;
    }

    ASSERT(m_pSettings != NULL);

    CWaitCursor wait;
    CError err;
    BOOL fRepeat;

    //
    // Build permissions DWORD
    //
    DWORD dwPermissions = 0L;

    SET_FLAG_IF(m_pSettings->m_fRead, dwPermissions, MD_ACCESS_READ);
    SET_FLAG_IF(m_pSettings->m_fWrite, dwPermissions, MD_ACCESS_WRITE);

    // if UserIsolation 2 is selected
    // then Permissions must be set to specific values
    if (m_pSettings->m_UserIsolation == 2)
    {
        SET_FLAG_IF(TRUE, dwPermissions, MD_ACCESS_NO_PHYSICAL_DIR);
    }

    if (m_bVDir)
    {
        //
        // First see if by any chance this name already exists
        //
        CMetabasePath target(FALSE, 
            m_pSettings->m_strParent, m_pSettings->m_strAlias);
        CChildNodeProps node(
            m_pSettings->m_pKey,
            target);

        do
        {
            fRepeat = FALSE;
            err = node.LoadData();
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);

        if (err.Succeeded())
        {
            BOOL fNotUnique = TRUE;
            //
            // If the item existed without a VrPath, we'll just blow it
            // away, as a vdir takes presedence over a directory/file.
            //
            if (node.GetPath().IsEmpty())
            {
                err = CChildNodeProps::Delete(
                    m_pSettings->m_pKey,
                    m_pSettings->m_strParent,
                    m_pSettings->m_strAlias
                    );
                fNotUnique = !err.Succeeded();
            }
            //
            // This one already exists and exists as a virtual
            // directory, so away with it.
            //
            if (fNotUnique)
            {
                ::AfxMessageBox(IDS_ERR_ALIAS_NOT_UNIQUE);
                return IDD_FTP_NEW_DIR_ALIAS;
            }
        }

        //
        // Create new vdir
        //
        do
        {
            fRepeat = FALSE;
            CString csTempPassword;
            m_pSettings->m_strPassword.CopyTo(csTempPassword);

            err = CChildNodeProps::Add(
                m_pSettings->m_pKey,
                m_pSettings->m_strParent,
                m_pSettings->m_strAlias,        // Desired alias name
                m_pSettings->m_strAlias,        // Name returned here (may differ)
                &dwPermissions,                 // Permissions
                NULL,                           // dir browsing
                m_pSettings->m_strPath,         // Physical path of this directory
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC ? (LPCTSTR)csTempPassword : NULL),
                TRUE                            // Name must be unique
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);
    }
    else
    {
        //
        // Create new instance
        //
        do
        {
            fRepeat = FALSE;
            CString csTempPassword;
            m_pSettings->m_strPassword.CopyTo(csTempPassword);

            err = CFTPInstanceProps::Add(
                m_pSettings->m_pKey,
                SZ_MBN_FTP,
                m_pSettings->m_strPath,
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC ? (LPCTSTR)csTempPassword : NULL),
                m_pSettings->m_strDescription,
                m_pSettings->m_strBinding,
                NULL,
                &dwPermissions,
                NULL,
                NULL,
                &m_pSettings->m_dwInstance
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);
		if (err.Succeeded())
		{
			CMetabasePath path(SZ_MBN_FTP, m_pSettings->m_dwInstance);
			// Add user isolation stuff
			if (m_pSettings->m_VersionMajor >= 6)
			{
				CMetaKey mk(m_pSettings->m_pKey, path, METADATA_PERMISSION_WRITE);
				err = mk.QueryResult();
				if (err.Succeeded())
				{
					err = mk.SetValue(MD_USER_ISOLATION, m_pSettings->m_UserIsolation);
					if (err.Succeeded() && m_pSettings->m_UserIsolation == 2)
					{
						err = mk.SetValue(MD_AD_CONNECTIONS_USERNAME, m_pSettings->m_strIsolationUserName);
						err = mk.SetValue(MD_AD_CONNECTIONS_PASSWORD, m_pSettings->m_strIsolationUserPassword);
						err = mk.SetValue(MD_DEFAULT_LOGON_DOMAIN, m_pSettings->m_strIsolationDomain);
                        /*
                        when creating an FTP site with AD User Isolation (UIM=2), the AllowAnonymous property inherited from the service level allows anonymous access, but the anonymous user is not configured. This may lead to anonymous access to the C:\ on the FTP server. We must block this.
                        For UIM=2, add set the property at the site level:
                        AllowAnonymous="FALSE"
                        */
                        err = mk.SetValue(MD_ALLOW_ANONYMOUS, FALSE);
					}
				}
			}
			// Start new site
			CInstanceProps ip(m_pSettings->m_pKey->QueryAuthInfo(), path);
			err = ip.LoadData();
			if (err.Succeeded())
			{
				if (ip.m_dwState != MD_SERVER_STATE_STARTED)
				{
					err = ip.ChangeState(MD_SERVER_COMMAND_START);
				}
			}
		}
    }
    m_pSettings->m_hrResult = err;
    
    return CIISWizardPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
RebindInterface(
    OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue,
    IN  DWORD dwCancelError
    )
/*++

Routine Description:

    Rebind the interface

Arguments:

    CMetaInterface * pInterface : Interface to rebind
    BOOL * pfContinue           : Returns TRUE to continue.
    DWORD  dwCancelError        : Return code on cancel

Return Value:

    HRESULT

--*/
{
    CError err;
    CString str, strFmt;

    ASSERT(pInterface != NULL);
    ASSERT(pfContinue != NULL);

    VERIFY(strFmt.LoadString(IDS_RECONNECT_WARNING));
    str.Format(strFmt, (LPCTSTR)pInterface->QueryServerName());

    if (*pfContinue = (YesNoMessageBox(str)))
    {
        //
        // Attempt to rebind the handle
        //
        err = pInterface->Regenerate();
    }
    else
    {
        //
        // Do not return an error in this case.
        //
        err = dwCancelError;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\ftpsht.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        ftpsht.h

   Abstract:
        FTP Property sheet definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager (cluster edition)

   Revision History:

--*/


#ifndef __FTPSHT_H__
#define __FTPSHT_H__


#include "shts.h"


#ifndef LOGGING_ENABLED
#define LOGGING_ENABLED
inline BOOL LoggingEnabled(
    IN DWORD dwLogType
    )
{
    return (dwLogType == MD_LOG_TYPE_ENABLED);
}
#endif


#ifndef ENABLE_LOGGING
#define ENABLE_LOGGING
inline void EnableLogging(
    OUT DWORD & dwLogType, 
    IN  BOOL fEnabled = TRUE
    )
{
    dwLogType = fEnabled ? MD_LOG_TYPE_ENABLED : MD_LOG_TYPE_DISABLED;
}
#endif


class CFTPInstanceProps : public CInstanceProps
/*++

Class Description:

    FTP Properties

Public Interface:

    CFTPInstanceProps   : Constructor

--*/
{
public:
    //
    // Constructor
    //
    CFTPInstanceProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

    BOOL HasADUserIsolation()
    {
        return MP_V(m_UserIsolation) == 2;
    }

    BOOL HasUserIsolation()
    {
        return MP_V(m_UserIsolation) == 1;
    }

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Service Page
    //
    MP_CILong        m_nMaxConnections;
    MP_CILong        m_nConnectionTimeOut;
    MP_DWORD         m_dwLogType;

    //
    // Accounts Page
    //
    MP_CString       m_strUserName;
    MP_CStrPassword  m_strPassword;
    MP_BOOL          m_fAllowAnonymous;
    MP_BOOL          m_fOnlyAnonymous;
    MP_BOOL          m_fPasswordSync;
    MP_CBlob         m_acl;

    //
    // Message Page
    //
    MP_CString       m_strExitMessage;
    MP_CString       m_strMaxConMsg;
    MP_CStringListEx m_strlWelcome;
    MP_CStringListEx m_strlBanner;

    //
    // Directory Properties Page
    //
    MP_BOOL          m_fDosDirOutput;

    //
    // Default Site page
    //
    MP_DWORD         m_dwDownlevelInstance;
    MP_DWORD         m_dwMaxBandwidth;
    // Supporting properties
    MP_DWORD         m_UserIsolation;
};



class CFTPDirProps : public CChildNodeProps
/*++

Class Description:

    FTP Directory properties

Public Interface:

    CFTPDirProps        : Constructor

--*/
{
public:
    CFTPDirProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Directory properties page
    //
    MP_CString     m_strUserName;
    MP_CStrPassword  m_strPassword;
    MP_BOOL        m_fDontLog;
    MP_CBlob       m_ipl;
};




class CFtpSheet : public CInetPropertySheet
/*++

Class Description:

    Ftp Property sheet

Public Interface:

    CFtpSheet     : Constructor

    Initialize    : Initialize config data

--*/
{
public:
    //
    // Constructor
    //
    CFtpSheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN CWnd *  pParentWnd  = NULL,
        IN LPARAM  lParam      = 0L,
        IN LPARAM  lParamParent= 0L,
        IN UINT    iSelectPage = 0
        );

    ~CFtpSheet();

public:
    HRESULT QueryInstanceResult() const;
    HRESULT QueryDirectoryResult() const;
    CFTPInstanceProps & GetInstanceProperties() { return *m_ppropInst; }
    CFTPDirProps & GetDirectoryProperties() { return *m_ppropDir; }
    BOOL HasADUserIsolation()
    {
        return m_ppropInst->HasADUserIsolation();
    }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();
	enum
	{
        SHEET_TYPE_SERVER,
		SHEET_TYPE_SITE,
        SHEET_TYPE_VDIR,
        SHEET_TYPE_DIR,
		SHEET_TYPE_FILE
	};
    HRESULT SetSheetType(int fSheetType);
protected:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    //{{AFX_MSG(CFtpSheet)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    CFTPInstanceProps * m_ppropInst;
    CFTPDirProps      * m_ppropDir;
    int              m_fSheetType;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CFtpSheet::QueryInstanceResult() const
{
    //
    // BUGBUG: S_OK if object not yet instantiated
    //
    return m_ppropInst ? m_ppropInst->QueryResult() : S_OK;
}

inline HRESULT CFtpSheet::QueryDirectoryResult() const
{
    //
    // BUGBUG: S_OK if object not yet instantiated
    //
    return m_ppropDir ? m_ppropDir->QueryResult() : S_OK;
}



#endif // __FTPSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fvdir.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fvdir.h

   Abstract:
        FTP Virtual Directory Properties dialog definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __FVDIR_H__
#define __FVDIR_H__



class CFtpDirectoryPage : public CInetPropertyPage
/*++

Class Description:

    FTP Virtual Directory Page.

Public Interface:

    CFtpDirectoryPage    : Constructor
    ~CFtpDirectoryPage   : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpDirectoryPage)

//
// Construction
//
public:
    CFtpDirectoryPage(
        IN CInetPropertySheet * pSheet = NULL, 
        IN BOOL fHome                  = FALSE
        );

    ~CFtpDirectoryPage();

	int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    //
    // Directory Type
    //
    enum
    {
        RADIO_DIRECTORY,
        RADIO_NETDIRECTORY,
    };

    //
    // Unix/DOS radio button values
    //
    enum
    {
        RADIO_UNIX,
        RADIO_DOS,
    };

    //{{AFX_DATA(CFtpDirectoryPage)
    enum { IDD = IDD_FTP_DIRECTORY_PROPERTIES };
    int     m_nUnixDos;
    int     m_nPathType;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fLogAccess;
    CString m_strPath;
    CStatic m_static_PathPrompt;
    CButton m_check_LogAccess;
    CButton m_check_Write;
    CButton m_check_Read;
    CButton m_button_AddPathType;
    CButton m_button_Browse;
    CButton m_radio_Dir;
    CEdit   m_edit_Path;
    //}}AFX_DATA

    BOOL    m_fOriginallyUNC;
    DWORD   m_dwAccessPerms;
    CString m_strAlias;
    CButton m_radio_Unc;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpDirectoryPage)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpDirectoryPage)
    afx_msg void OnButtonBrowse();
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckWrite();
    afx_msg void OnButtonEditPathType();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioUnc();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    void SetStateByType();
    void SetPathType(LPCTSTR lpstrPath);
    void ChangeTypeTo(int nNewType);

    BOOL IsHome() const { return m_fHome; }

private:
    BOOL    m_fHome;
    CString m_strOldPath;
    CString m_strUserName;
    CStrPassword m_strPassword;
    CString m_strPathPrompt;
    CString m_strSharePrompt;
	LPTSTR m_pPathTemp;
	CString m_strBrowseTitle;
};

#endif // __FVDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\fvdir.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fvdir.cpp

   Abstract:
        FTP Virtual Directory Properties dialog

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "ftpsht.h"
#include "fvdir.h"
#include "iisobj.h"
#include <lmcons.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Directory Properties Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CFtpDirectoryPage, CInetPropertyPage)



CFtpDirectoryPage::CFtpDirectoryPage(
    IN CInetPropertySheet * pSheet,
    IN BOOL fHome
    ) 
/*++

Routine Description:

    Constructor for directory property page

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer
    BOOL fHome                  : TRUE if this is a home directory


--*/
    : CInetPropertyPage(CFtpDirectoryPage::IDD, pSheet,
          fHome ? IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY),
      m_fHome(fHome),
      m_fOriginallyUNC(FALSE)
{
    VERIFY(m_strPathPrompt.LoadString(IDS_PATH));
    VERIFY(m_strSharePrompt.LoadString(IDS_SHARE));

#if 0 // Keep Class-wizard happy

    //{{AFX_DATA_INIT(CFtpDirectoryPage)
    m_nPathType = RADIO_DIRECTORY;
    m_nUnixDos = 0;
    m_fRead = FALSE;
    m_fWrite = FALSE;
    m_fLogAccess = FALSE;
    m_strPath = _T("");
    m_strDefaultDocument = _T("");
    m_strFooter = _T("");
    m_fBrowsingAllowed = FALSE;
    m_fEnableDefaultDocument = FALSE;
    m_fEnableFooter = FALSE;
    m_dwAccessPerms = 0;
    //}}AFX_DATA_INIT

#endif // 0

}



CFtpDirectoryPage::~CFtpDirectoryPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpDirectoryPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control Data

Arguments:

    CDataExchange * pDX : DDX/DDV struct

Return Value:

    None.

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpDirectoryPage)
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
    DDX_Control(pDX, IDC_CHECK_LOG_ACCESS, m_check_LogAccess);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);
    DDX_Control(pDX, IDC_BUTTON_EDIT_PATH_TYPE, m_button_AddPathType);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_STATIC_PATH, m_static_PathPrompt);
    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_Radio(pDX, IDC_RADIO_UNIX, m_nUnixDos);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_RADIO_UNC, m_radio_Unc);
    DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
    m_strPath.TrimLeft();
    DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

    if (pDX->m_bSaveAndValidate)
    {
        CString csPathMunged;
        //
        // Make sure a field names are correct
        //
        if (m_nPathType == RADIO_NETDIRECTORY)
        {
			DDV_UNCFolderPath(pDX, m_strPath,IsLocal());
            if (IsLocal())
            {
				// do this check only if a change was made.
				if (IsDirty())
				{
                    csPathMunged = m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif
                    if (PathIsUNCServerShare(csPathMunged))
					{
						if (FALSE == DoesUNCShareExist(csPathMunged))
						{
							CError err;
							err = ERROR_PATH_NOT_FOUND;
							if (IDCANCEL == err.MessageBox(m_hWnd,MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2,NO_HELP_CONTEXT))
							{
								pDX->Fail();
							}
						}
					}
				}
            }
        }
        else // Local Directory
        {
            ASSERT(m_nPathType == RADIO_DIRECTORY);
            if (!IsMasterInstance())
            {
				DDV_FolderPath(pDX, m_strPath, IsLocal());
			}
        }
    }
    else
    {
        if (!IsMasterInstance())
        {
            DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
        }
    }
}



void
CFtpDirectoryPage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        DeActivateControl(m_button_AddPathType);

	    if (IsLocal() && !IsMasterInstance() && HasAdminAccess())
        {
			ActivateControl(m_button_Browse);
        }
		else
        {
			DeActivateControl(m_button_Browse);
        }

        m_static_PathPrompt.SetWindowText(m_strPathPrompt);
        break;

    case RADIO_NETDIRECTORY:
        ActivateControl(m_button_AddPathType);
        DeActivateControl(m_button_Browse);
        m_static_PathPrompt.SetWindowText(m_strSharePrompt);
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
    }
}



void
CFtpDirectoryPage::SetPathType(
    IN LPCTSTR lpstrPath
    )
/*++

Routine Description:

    Set path type from given path

Arguments:

    LPCTSTR lpstrPath       : Path string

Return Value:

    None

--*/
{
    CString csPathMunged;
    csPathMunged = lpstrPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,lpstrPath,csPathMunged);
#endif

    if (PathIsUNC(csPathMunged))
    {
        m_nPathType = RADIO_NETDIRECTORY;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(1);
    }
    else
    {
        m_nPathType =  RADIO_DIRECTORY;
        m_radio_Unc.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }

    SetStateByType();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpDirectoryPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpDirectoryPage)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_PATH_TYPE, OnButtonEditPathType)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_UNC, OnRadioUnc)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PATH, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_READ, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
    ON_BN_CLICKED(IDC_RADIO_MSDOS, OnItemChanged)
    ON_BN_CLICKED(IDC_RADIO_UNIX, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CFtpDirectoryPage::OnItemChanged()
/*++

Routine Description:

    Handle change in data on the item

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CFtpDirectoryPage * pThis = (CFtpDirectoryPage *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CFtpDirectoryPage::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

void
CFtpDirectoryPage::OnButtonBrowse() 
/*++

Routine Description:

    "Browse" button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(IsLocal());
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
		 ExpandEnvironmentStrings(str, buf, MAX_PATH);
		 str = buf;
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(m_fHome ? 
            IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
	   m_strPath = str;
       m_edit_Path.SetWindowText(str);
       SetPathType(m_strPath);
       OnItemChanged();
   }
}



BOOL
CFtpDirectoryPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_button_Browse.EnableWindow(
        IsLocal()
     && !IsMasterInstance()
     && HasAdminAccess());

    SetPathType(m_strPath);

    //
    // Directory listing style dependent on whether or not
    // this is a home directory
    //
    ActivateControl(*GetDlgItem(IDC_STATIC_DIRLISTING), m_fHome);
    ActivateControl(*GetDlgItem(IDC_RADIO_UNIX),        m_fHome);
    ActivateControl(*GetDlgItem(IDC_RADIO_MSDOS),       m_fHome);

    //
    // Some items not available on master instance
    //
    CFTPInstanceProps ip(GetSheet()->QueryAuthInfo(), GetSheet()->QueryMetaPath());
    ip.LoadData();
	BOOL bUserIsolation = ip.HasADUserIsolation() || ip.HasUserIsolation();

    GetDlgItem(IDC_STATIC_PATH_TYPE)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_RADIO_DIR)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_RADIO_UNC)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_STATIC_PATH)->EnableWindow(
        !IsMasterInstance());
    GetDlgItem(IDC_EDIT_PATH)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_BUTTON_EDIT_PATH_TYPE)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess() && !bUserIsolation);

    m_check_Write.EnableWindow(HasAdminAccess());
    m_check_Read.EnableWindow(HasAdminAccess());

    //
    // Store the original value of fUNC of reference later when 
    // saving out --BoydM
    //
    m_fOriginallyUNC = (m_nPathType == RADIO_NETDIRECTORY);
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),FALSE);
#endif

    return TRUE;  
}



void
CFtpDirectoryPage::ChangeTypeTo(
    IN int nNewType
    )
/*++

Routine Description

    Change the directory type

Arguments:

    int nNewType    : New radio value

Return Value:

    None

--*/
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        //
        // No change
        //
        return;
    }

    OnItemChanged();
    SetStateByType();

    LPCTSTR lpKeepPath = NULL;

    int nID = -1;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        {
            CString csPathMunged;
            csPathMunged = m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif
            if (!PathIsUNC(csPathMunged) && (!PathIsRelative(csPathMunged) || IsDevicePath(csPathMunged)))
            {
                //
                // The old path info is acceptable, propose it
                // as a default
                //
                lpKeepPath = m_strPath;
            }

            nID = IDS_DIRECTORY_MASK;
            break;
        }

    case RADIO_NETDIRECTORY:
        {
            CString csPathMunged;
            csPathMunged = m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif
            
            if (PathIsUNC(csPathMunged))
            {
                //
                // The old path info is acceptable, propose it
                // as a default
                //
                lpKeepPath = m_strPath;
            }

            nID = IDS_UNC_MASK;
            break;
        }
    }

    if (lpKeepPath != NULL)
    {
        //
        // Restore the old path
        //
        m_edit_Path.SetWindowText(lpKeepPath);
    }
    else
    {
        //
        // Load mask resource, and display
        // this in the directory
        //
        CString str;
        VERIFY(str.LoadString(nID));
        m_edit_Path.SetWindowText(str);
    }

    m_edit_Path.SetSel(0,-1);
    m_edit_Path.SetFocus();
}



void
CFtpDirectoryPage::OnRadioDir() 
/*++

Routine Description:

    'directory' radio button handler

Arguments:

    None

Return Value:

    None.

--*/
{
    ChangeTypeTo(RADIO_DIRECTORY);
}



void
CFtpDirectoryPage::OnRadioUnc() 
/*++

Routine Description:

    'network directory' radio button handler

Arguments:

    None

Return Value:

    None.

--*/
{
    ChangeTypeTo(RADIO_NETDIRECTORY);
}



/* virtual */
HRESULT
CFtpDirectoryPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CFtpSheet)
        //
        // Use 'm_' notation because the message crackers require it.
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strAlias);
        FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
        FETCH_DIR_DATA_FROM_SHEET_PASSWORD(m_strPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_strPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);

        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fLogAccess = !m_fDontLog;
    END_META_DIR_READ(err)

    BEGIN_META_INST_READ(CFtpSheet)
        BOOL  m_fDosDirOutput;

        FETCH_INST_DATA_FROM_SHEET(m_fDosDirOutput);
        m_nUnixDos = m_fDosDirOutput ? RADIO_DOS : RADIO_UNIX;
    END_META_INST_READ(err)

    CString csPathMunged;
    csPathMunged = m_strPath;

#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif
    
    m_nPathType = PathIsUNC(csPathMunged) ? 
        RADIO_NETDIRECTORY : RADIO_DIRECTORY;

    //
    // Make sure we were passed the right home directory
    // flag
    //
    ASSERT(IsMasterInstance()
        || (m_fHome && !::lstrcmp(m_strAlias, g_cszRoot))
        || (!m_fHome && ::lstrcmp(m_strAlias, g_cszRoot))
        );

    return err;
}



/* virtual */
HRESULT
CFtpDirectoryPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP virtual directory page now...");

    CError err;

    SET_FLAG_IF(m_fRead, m_dwAccessPerms, MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms, MD_ACCESS_WRITE);

    //
    // Use m_ notation because the message crackers require them
    //
    BOOL m_fDontLog = !m_fLogAccess;
    BOOL m_fDosDirOutput = (m_nUnixDos == RADIO_DOS);
    BOOL fUNC = (m_nPathType == RADIO_NETDIRECTORY);
//    BOOL fUserNameWritten = FALSE;

    BeginWaitCursor();
    BEGIN_META_DIR_WRITE(CFtpSheet)
        if (fUNC)      
        {
//            STORE_DIR_DATA_ON_SHEET_REMEMBER(m_strUserName, fUserNameWritten)
//            if (fUserNameWritten)
//            {
                STORE_DIR_DATA_ON_SHEET(m_strUserName);
                STORE_DIR_DATA_ON_SHEET(m_strPassword);
//            }
        }
        else
        {
            if (m_fOriginallyUNC)
            {
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_USERNAME);
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_PASSWORD);
            }
        }
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_strPath)
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        BEGIN_META_INST_WRITE(CFtpSheet)
            STORE_INST_DATA_ON_SHEET(m_fDosDirOutput);  
        END_META_INST_WRITE(err)
    }

    if (err.Succeeded())
    {
		NotifyMMC(PROP_CHANGE_DISPLAY_ONLY);
    }

    EndWaitCursor();

    return err;
}



void
CFtpDirectoryPage::OnButtonEditPathType() 
/*++

Routine Description:

    'Connect As..." button handler

Arguments:

    None

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    CString csTempPassword;
    m_strPassword.CopyTo(csTempPassword);

    CUserAccountDlg dlg(
        QueryServerName(), 
        m_strUserName,
        csTempPassword, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        m_strUserName = dlg.m_strUserName;
        m_strPassword = dlg.m_strPassword;
        OnItemChanged();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\hdrdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        hdrdlg.cpp

   Abstract:

        HTTP Headers dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
//#include "fltdlg.h"
#include "hdrdlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CHeaderDlg::CHeaderDlg(
    IN LPCTSTR lpstrHeader,
    IN LPCTSTR lpstrValue,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for HTTP heade dialog

Arguments:

    LPCTSTR lpstrHeader     : Header string
    LPCTSTR lpstrValue      : Value string
    CWnd * pParent          : Parent window
    
Return Value:

    None    

--*/
    : CDialog(CHeaderDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CHeaderDlg)
    m_strHeader = lpstrHeader ? lpstrHeader : _T("");
    m_strValue = lpstrValue ? lpstrValue : _T("");
    //}}AFX_DATA_INIT
}



void 
CHeaderDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CHeaderDlg)
    DDX_Control(pDX, IDC_EDIT_HEADER, m_edit_Header);
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Text(pDX, IDC_EDIT_HEADER, m_strHeader);
	DDV_MaxCharsBalloon(pDX, m_strHeader, 100);
    DDX_Text(pDX, IDC_EDIT_VALUE, m_strValue);
	DDV_MaxCharsBalloon(pDX, m_strValue, 100);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CHeaderDlg, CDialog)
    //{{AFX_MSG_MAP(CHeaderDlg)
    ON_EN_CHANGE(IDC_EDIT_HEADER, OnChangeEditHeader)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CHeaderDlg::OnChangeEditHeader()
/*++

Routine Description:

    change edit handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(m_edit_Header.GetWindowTextLength() > 0);
}



BOOL 
CHeaderDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    OnChangeEditHeader();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\guids.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        guids.h

   Abstract:

        GUIDs as used by IIS snapin definition

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/
#ifndef _GUIDS_H
#define _GUIDS_H

//
// New Clipboard format that has the Type and Cookie
//
extern const wchar_t * ISM_SNAPIN_INTERNAL;

//
// Published context information for extensions to extend
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

extern const wchar_t * MYCOMPUT_MACHINE_NAME;
extern const wchar_t * ISM_SNAPIN_MACHINE_NAME;
extern const wchar_t * ISM_SNAPIN_SERVICE;
extern const wchar_t * ISM_SNAPIN_INSTANCE;
extern const wchar_t * ISM_SNAPIN_PARENT_PATH;
extern const wchar_t * ISM_SNAPIN_NODE;
extern const wchar_t * ISM_SNAPIN_META_PATH;

//
// GUIDS
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Snapin GUID
//
extern const CLSID CLSID_Snapin;                 // In-Proc server GUID
extern const CLSID CLSID_About;                  // About GUID

//
// IIS Object GUIDS
//
extern "C" const GUID cInternetRootNode;             // Internet root node       num
extern "C" const GUID cMachineNode;                  // Machine node             num
extern "C" const GUID cServiceCollectorNode;         // Service Collector node   num
extern "C" const GUID cInstanceCollectorNode;        // Instance Collector node  num
extern "C" const GUID cInstanceNode;                 // Instance node            num
extern "C" const GUID cChildNode;                    // Child node               num
extern "C" const GUID cFileNode;                     // File node                num
extern "C" const GUID cAppPoolsNode;
extern "C" const GUID cAppPoolNode;
extern "C" const GUID cApplicationNode;
extern "C" const GUID cWebServiceExtensionContainer;
extern "C" const GUID cWebServiceExtension;
extern "C" const GUID cCompMgmtService;
BOOL GetFriendlyGuidName(GUID InputGUID, CString & strReturnedString);

#endif //_GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\guids.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        guids.cpp

   Abstract:

        GUIDs as used by IIS snapin

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

//
// Internal private clipboard format
//
const wchar_t * ISM_SNAPIN_INTERNAL = L"ISM_SNAPIN_INTERNAL";

//
// Published formats
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const wchar_t * MYCOMPUT_MACHINE_NAME   = L"MMC_SNAPIN_MACHINE_NAME"; 
const wchar_t * ISM_SNAPIN_MACHINE_NAME = L"ISM_SNAPIN_MACHINE_NAME"; 
const wchar_t * ISM_SNAPIN_SERVICE =      L"ISM_SNAPIN_SERVICE";
const wchar_t * ISM_SNAPIN_INSTANCE =     L"ISM_SNAPIN_INSTANCE";
const wchar_t * ISM_SNAPIN_PARENT_PATH =  L"ISM_SNAPIN_PARENT_PATH";
const wchar_t * ISM_SNAPIN_NODE =         L"ISM_SNAPIN_NODE";
const wchar_t * ISM_SNAPIN_META_PATH =    L"ISM_SNAPIN_META_PATH";

//
// GUIDs
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Snapin GUID
//
// {A841B6C2-7577-11d0-BB1F-00A0C922E79C}
//
//const CLSID CLSID_Snapin = {0xa841b6c2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// About GUID
//
// {A841B6D2-7577-11d0-BB1F-00A0C922E79C}
//
//const CLSID CLSID_About =  {0xa841b6d2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// IIS Object GUIDS
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Internet Root Node GUID
//
extern "C" const GUID cInternetRootNode 
    = {0xa841b6c3, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Machine Node GUID
//
extern "C" const GUID cMachineNode 
    = {0xa841b6c4, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Service Collector Node GUID
//
extern "C" const GUID cServiceCollectorNode 
    = {0xa841b6c5, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Instance Collector Node GUID
//
extern "C" const GUID cInstanceCollectorNode 
    = {0xa841b6c6, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Instance Node GUID
//
extern "C" const GUID cInstanceNode 
    = {0xa841b6c7, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Child Node GUID
//
extern "C" const GUID cChildNode 
    = {0xa841b6c8, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// File Node GUID
//
extern "C" const GUID cFileNode 
    = {0xa841b6c9, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// AppPools container Node GUID
//
extern "C" const GUID cAppPoolsNode 
    = {0xa841b6ca, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// AppPool Node GUID
//
extern "C" const GUID cAppPoolNode 
    = {0xa841b6cb, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Application Node GUID
//
extern "C" const GUID cApplicationNode
    = {0xa841b6cc, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// cWebServiceExtension container Node GUID
//
extern "C" const GUID cWebServiceExtensionContainer
    = {0xa841b6cd, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// cWebServiceExtension Node GUID
//
extern "C" const GUID cWebServiceExtension
    = {0xa841b6ce, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// CompMgnt node that we are extending
//
extern "C" const GUID cCompMgmtService 
    = {0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0}};

BOOL GetFriendlyGuidName(GUID InputGUID, CString & strReturnedString)
{
    if (InputGUID == cInternetRootNode)
    {
        strReturnedString = _T("cInternetRootNode");
        return TRUE;
    }
 
    if (InputGUID == cMachineNode)
    {
        strReturnedString = _T("cMachineNode");
        return TRUE;
    }

    if (InputGUID == cServiceCollectorNode)
    {
        strReturnedString = _T("cServiceCollectorNode");
        return TRUE;
    }
 
    if (InputGUID == cInstanceCollectorNode)
    {
        strReturnedString = _T("cInstanceCollectorNode");
        return TRUE;
    }
 
    if (InputGUID == cInstanceNode)
    {
        strReturnedString = _T("cInstanceNode");
        return TRUE;
    }
 
    if (InputGUID == cChildNode)
    {
        strReturnedString = _T("cChildNode");
        return TRUE;
    }
 
    if (InputGUID == cFileNode)
    {
        strReturnedString = _T("cFileNode");
        return TRUE;
    }

    if (InputGUID == cAppPoolsNode)
    {
        strReturnedString = _T("cAppPoolsNode");
        return TRUE;
    }

    if (InputGUID == cAppPoolNode)
    {
        strReturnedString = _T("cAppPoolNode");
        return TRUE;
    }

    if (InputGUID == cWebServiceExtensionContainer)
    {
        strReturnedString = _T("cWebServiceExtensionContainer");
        return TRUE;
    }

    if (InputGUID == cWebServiceExtension)
    {
        strReturnedString = _T("cWebServiceExtension");
        return TRUE;
    }

    if (InputGUID == cCompMgmtService)
    {
        strReturnedString = _T("cCompMgmtService ");
        return TRUE;
    }

    return FALSE;
}

#include <initguid.h>
#include "iwamreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iishelp.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;
DWORD g_dwInetmgrParamFlags = 0;

void DebugTrace(LPTSTR lpszFormat, ...)
{
    // Only do this if the flag is set.
    if (0 != g_iDebugOutputLevel)
    {
	    int nBuf;
	    TCHAR szBuffer[_MAX_PATH];

	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);
		szBuffer[_MAX_PATH - 1] = L'\0'; // null terminate the string 
	    ASSERT(nBuf < sizeof(szBuffer)/sizeof(szBuffer[0])); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);

        // if it does not end if '\r\n' then make one.
        int nLen = _tcslen(szBuffer);
        if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
    }
}

void WinHelpDebug(DWORD_PTR dwWinHelpID)
{
	if (DEBUG_FLAG_HELP & g_iDebugOutputLevel)
	{
		TCHAR szBuffer[30];
		_stprintf(szBuffer,_T("WinHelp:0x%x,%d\r\n"),dwWinHelpID,dwWinHelpID);

		DebugTrace(szBuffer);
	}
    return;
}

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		// Defined in inc\DebugDefs.h
		g_iDebugOutputLevel = rc;
	}
    return;
}

void GetInetmgrParamFlag(void)
{
    DWORD rc, size, type;
    HKEY  hkey;
	g_dwInetmgrParamFlags = 0;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr\\Parameters"), &hkey))
    {
        size = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,_T("InetMgrFlags"),0,&type,(LPBYTE)&rc,&size))
        {
            if (type == REG_DWORD)
            {
				// Defined in inc\DebugDefs.h
				g_dwInetmgrParamFlags = rc;
            }
        }
        RegCloseKey(hkey);
    }
#if defined(_DEBUG) || DBG
	DebugTrace(_T("g_dwInetmgrParamFlags=0x%x\r\n"),g_dwInetmgrParamFlags);
#endif
}

BOOL SetInetmgrParamFlag(DWORD dwFlagToSet,BOOL bState)
{
	BOOL bSuccessfullyWrote = FALSE;
	HKEY hKey = NULL;

	// Grab the existing params
	// and change only our settings
	if (bState)
	{
		// ON the setting
		g_dwInetmgrParamFlags |= dwFlagToSet;
	}
	else
	{
		// OFF the setting
		g_dwInetmgrParamFlags &= ~dwFlagToSet;
	}

    if (ERROR_SUCCESS  == RegOpenKeyEx( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr\\Parameters"), 0, KEY_WRITE, &hKey ))
    {
        if (ERROR_SUCCESS == RegSetValueEx( hKey, _T("InetMgrFlags"), 0, REG_DWORD, (BYTE *) &g_dwInetmgrParamFlags, sizeof( DWORD ) ))
		{
			bSuccessfullyWrote = TRUE;
		}
		if( NULL != hKey )
		{
			RegCloseKey( hKey );
			hKey = NULL;
		}
    }
#if defined(_DEBUG) || DBG
	DebugTrace(_T("SetInetmgrParamFlag:g_dwInetmgrParamFlags=0x%x\r\n"),g_dwInetmgrParamFlags);
#endif
	return bSuccessfullyWrote;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\hdrdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        hdrdlg.h

   Abstract:

        HTTP Headers dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __HDRDLG_H__
#define __HDRDLG_H__



class CHeaderDlg : public CDialog
/*++

Class Description:

    HTTP Header dialog

Public Interface:

    CHeaderDlg          : Constructor
    GetHeader           : Get header name
    GetValue            : Get header value

--*/
{
//
// Construction
//
public:
    CHeaderDlg(
        IN LPCTSTR lpstrHeader = NULL,
        IN LPCTSTR lpstrValue  = NULL,
        IN CWnd * pParent      = NULL
        );

//
// Access
//
public:
    CString & GetHeader() { return m_strHeader; }
    CString & GetValue()  { return m_strValue; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CHeaderDlg)
    enum { IDD = IDD_CUSTOM_HEADER };
    CString m_strHeader;
    CString m_strValue;
    CEdit   m_edit_Header;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CHeaderDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CHeaderDlg)
    afx_msg void OnChangeEditHeader();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // __HDRDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\httppage.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        httppage.h

   Abstract:

        HTTP Headers property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __HTTPPAGE_H__
#define __HTTPPAGE_H__



//{{AFX_INCLUDES()
#include "rat.h"
//}}AFX_INCLUDES



class CHeader : public CObjectPlus
/*++

Class Description:

    HTTP Header definition

Public Interface:

    CHeader               : Constructor
    DisplayString         : Build display string
    CrackDisplayString    : Convert from crack display string

--*/
{
//
// Constructor
//
public:
    CHeader(
        IN LPCTSTR lpstrHeader, 
        IN LPCTSTR lpstrValue
        );

    //
    // Parse header info from name:value string
    //
    CHeader(LPCTSTR lpstrDisplayString);

//
// Access
//
public:
    LPCTSTR QueryHeader() const { return m_strHeader; }
    LPCTSTR QueryValue() const { return m_strValue; }
    CString & GetHeader() { return m_strHeader;}
    CString & GetValue() { return m_strValue; }
    void SetHeader(LPCTSTR lpszHeader);
    void SetValue(LPCTSTR lpszValue);

//
// Interface:
public:
    //
    // Build output display string
    //
    LPCTSTR DisplayString(OUT CString & str);

protected:
    //
    // Parse the display string into fields
    //
    static void CrackDisplayString(
        IN  LPCTSTR lpstrDisplayString,
        OUT CString & strHeader,
        OUT CString & strValue
        );

private:
    CString m_strHeader;
    CString m_strValue;
};



class CW3HTTPPage : public CInetPropertyPage
/*++

Class Description:

    HTTP Custom Headers property page

Public Interface:

    CW3HTTPPage     : Constructor

--*/
{
    DECLARE_DYNCREATE(CW3HTTPPage)

//
// Construction
//
public:
    CW3HTTPPage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3HTTPPage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_IMMEDIATELY,
        RADIO_EXPIRE,
        RADIO_EXPIRE_ABS,
    };

    enum
    {
        COMBO_MINUTES,
        COMBO_HOURS,
        COMBO_DAYS,
    };

    //{{AFX_DATA(CW3HTTPPage)
    enum { IDD = IDD_DIRECTORY_HTTP };
    int         m_nTimeSelector;
    int         m_nImmediateTemporary;
    BOOL        m_fEnableExpiration;
    CEdit       m_edit_Expire;
    CButton     m_radio_Immediately;
    CButton     m_button_Delete;
    CButton     m_button_Edit;
    CButton     m_button_PickDate;
    CButton     m_button_FileTypes;
    CStatic     m_static_Contents;
    CComboBox   m_combo_Time;
    //}}AFX_DATA

    DWORD           m_dwRelTime;
    CILong          m_nExpiration;
    CTime           m_tm;
    CTime           m_tmNow;
    CRat            m_ocx_Ratings;
    CButton         m_radio_Time;
    CButton         m_radio_AbsTime;
    CDateTimeCtrl   m_dtpDate;
    CDateTimeCtrl   m_dtpTime;
    CRMCListBox     m_list_Headers;
    CStringListEx   m_strlCustomHeaders;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3HTTPPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3HTTPPage)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonDelete();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonFileTypes();
    afx_msg void OnButtonRatingsTemplate();
    afx_msg void OnCheckExpiration();
    afx_msg void OnSelchangeComboTime();
    afx_msg void OnSelchangeListHeaders();
    afx_msg void OnDblclkListHeaders();
    afx_msg void OnRadioImmediately();
    afx_msg void OnRadioTime();
    afx_msg void OnRadioAbsTime();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void    SetTimeFields();
    void    FillListBox();
    void    FetchHeaders();
    void    StoreTime();
    void    StoreHeaders();
    void    MakeExpirationString(CString & strExpiration);
    BOOL    SetControlStates();
    BOOL    CrackExpirationString(CString & strExpiration);
    BOOL    HeaderExists(LPCTSTR lpHeader);
    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    LPCTSTR QueryMetaPath();

private:
    BOOL          m_fValuesAdjusted;
    CStringListEx m_strlMimeTypes;
    CObListPlus   m_oblHeaders;
    CMimeTypes *  m_ppropMimeTypes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CHeader::CHeader(
    IN LPCTSTR lpstrHeader, 
    IN LPCTSTR lpstrValue
    )
    : m_strHeader(lpstrHeader),
      m_strValue(lpstrValue)
{
}

inline CHeader::CHeader(
    IN LPCTSTR lpstrDisplayString
    )
{
    CrackDisplayString(lpstrDisplayString, m_strHeader, m_strValue);
}

inline LPCTSTR CHeader::DisplayString(
    OUT CString & str
    )
{
    str.Format(_T("%s: %s"), (LPCTSTR)m_strHeader, (LPCTSTR)m_strValue);
    return str;
}

inline void CHeader::SetHeader(
    IN LPCTSTR lpszHeader
    )
{
    m_strHeader = lpszHeader;
}

inline void CHeader::SetValue(
    IN LPCTSTR lpszValue
    )
{
    m_strValue = lpszValue;
}

inline LPCTSTR CW3HTTPPage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().QueryMetaRoot();
}

#endif // __HTTPPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iisdirectory.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        iisdirectory.cpp

   Abstract:

        IIS Directory node Object

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        10/28/2000      sergeia     Split from iisobj.cpp

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "w3sht.h"
#include "wdir.h"
#include "docum.h"
#include "wfile.h"
#include "wsecure.h"
#include "httppage.h"
#include "errors.h"
#include "fltdlg.h"
#include "tracker.h"
#include <lm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

extern CPropertySheetTracker g_OpenPropertySheetTracker;


//
// CIISDirectory Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Site Result View definition
//
/* static */ int 
CIISDirectory::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_NAME,
    IDS_RESULT_PATH,
    IDS_RESULT_STATUS,
};
    

/* static */ int 
CIISDirectory::_rgnWidths[COL_TOTAL] =
{
    180,
    200,
	200,
};

#if 0
/* static */ CComBSTR CIISDirectory::_bstrName;
/* static */ CComBSTR CIISDirectory::_bstrPath;
/* static */ BOOL     CIISDirectory::_fStaticsLoaded = FALSE;
#endif

CIISDirectory::CIISDirectory(
    IN CIISMachine * pOwner,
    IN CIISService * pService,
    IN LPCTSTR szNodeName
    )
/*++

Routine Description:

    Constructor which does not resolve all display information at 
    construction time.

Arguments:

    CIISMachine * pOwner        : Owner machine
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name

Return Value:

    N/A

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_bstrDisplayName(szNodeName),
      m_fResolved(FALSE),
      //
      // Default Data
      //
      m_fEnabledApplication(FALSE),
      m_dwWin32Error(ERROR_SUCCESS),
	  m_dwEnumError(ERROR_SUCCESS)
{
    ASSERT_PTR(m_pService);
    m_pService->AddRef();
}



CIISDirectory::CIISDirectory(
    CIISMachine * pOwner,
    CIISService * pService,
    LPCTSTR szNodeName,
    BOOL fEnabledApplication,
    DWORD dwWin32Error,
    LPCTSTR strRedirPath
    )
/*++

Routine Description:

    Constructor that takes full information

Arguments:

    CIISMachine * pOwner        : Owner machine
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name

Return Value:

    N/A

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_bstrDisplayName(szNodeName),
      m_fResolved(TRUE),
      //
      // Data
      //
      m_fEnabledApplication(fEnabledApplication),
      m_dwWin32Error(dwWin32Error),
	  m_dwEnumError(ERROR_SUCCESS)
{
    m_strRedirectPath = strRedirPath;
    ASSERT_PTR(m_pService);
    m_pService->AddRef();
}



/* virtual */
CIISDirectory::~CIISDirectory()
{
    m_pService->Release();
}



/* virtual */
HRESULT
CIISDirectory::RefreshData()
/*++
    Refresh relevant configuration data required for display.
--*/
{
    CError err;

    CWaitCursor wait;
    CComBSTR bstrPath;
    CMetaKey * pKey = NULL;

    do
    {
        err = BuildMetaPath(bstrPath);
		BREAK_ON_ERR_FAILURE(err)

        BOOL fContinue = TRUE;
        while (fContinue)
        {
            fContinue = FALSE;
            pKey = new CMetaKey(QueryInterface(), bstrPath);

            if (!pKey)
            {
                TRACEEOLID("RefreshData: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            err = pKey->QueryResult();

            if (IsLostInterface(err))
            {
                SAFE_DELETE(pKey);
                fContinue = OnLostInterface(err);
            }
            else
            {
                // reset error if an other error other than No interface
                err.Reset();
            }
        }
		BREAK_ON_ERR_FAILURE(err)

        CChildNodeProps child(pKey, NULL /*bstrPath*/, WITH_INHERITANCE, FALSE);
        err = child.LoadData();
        if (err.Failed())
        {
            //
            // Filter out the non-fatal errors
            //
            switch(err.Win32Error())
            {
            case ERROR_ACCESS_DENIED:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                err.Reset();
                break;

            default:
                TRACEEOLID("Fatal error occurred " << err);
            }
        }
        m_dwWin32Error = child.QueryWin32Error();
        m_fEnabledApplication = child.IsEnabledApplication();
		if (!child.IsRedirected())
		{
			CString dir;
			CString alias;
			if (GetPhysicalPath(bstrPath, alias, dir))
			{
                m_bstrPath = dir;
				if (PathIsUNCServerShare(dir))
				{
                    if (FALSE == DoesUNCShareExist(dir))
                    {
                        err = ERROR_BAD_NETPATH;
                        break;
                    }
				}
				else if (!PathIsDirectory(dir))
				{
					err = ERROR_PATH_NOT_FOUND;
					break;
				}
			}
            m_strRedirectPath.Empty();
		}
        else
        {
            m_strRedirectPath = child.GetRedirectedPath();
        }
    }
    while(FALSE);

    SAFE_DELETE(pKey);

	m_dwEnumError = err.Win32Error();

    return err;
}



/* virtual */
HRESULT 
CIISDirectory::EnumerateScopePane(HSCOPEITEM hParent)
{
    CError err = EnumerateVDirs(hParent, m_pService);
    if (err.Succeeded() && IsWebDir() && m_strRedirectPath.IsEmpty())
    {
        if (m_dwEnumError == ERROR_SUCCESS)
        {
            err = EnumerateWebDirs(hParent, m_pService);
        }
    }
    if (err.Failed())
    {
        m_dwEnumError = err.Win32Error();
        RefreshDisplay();
    }
    return err;
}



/* virtual */
int      
CIISDirectory::QueryImage() const
/*++

Routine Description:

    Return bitmap index for the site

Arguments:

    None

Return Value:

    Bitmap index

--*/
{
    ASSERT_PTR(m_pService);
	if (!m_fResolved)
	{
        if (m_hScopeItem == NULL)
        {
            return iError;
        }
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CIISDirectory * that = (CIISDirectory *)this;
        CError err = that->RefreshData();
        that->m_fResolved = err.Succeeded();
	}
    if (!m_pService)
    {
        return iError;
    }

	if (IsEnabledApplication())
	{
		return SUCCEEDED(m_dwWin32Error) ? iApplication : iApplicationErr; 
	}
	else
	{
		return SUCCEEDED(m_dwWin32Error) ? 
			m_pService->QueryVDirImage() : m_pService->QueryVDirImageErr(); 
	}
}
    
    
void 
CIISDirectory::InitializeChildHeaders(LPHEADERCTRL lpHeader)
{
    CIISDirectory::InitializeHeaders(lpHeader);
}

/* static */
void
CIISDirectory::InitializeHeaders(LPHEADERCTRL lpHeader)
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
}

/* virtual */
LPOLESTR 
CIISDirectory::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_ALIAS:
        return QueryDisplayName();

    case COL_PATH:
       if (!m_strRedirectPath.IsEmpty())
       {
           AFX_MANAGE_STATE(::AfxGetStaticModuleState());
           CString buf;
           buf.Format(IDS_REDIRECT_FORMAT, m_strRedirectPath);
           _bstrRedirectPathBuf = buf;
           return _bstrRedirectPathBuf;
       }
       if (m_bstrPath.Length() == 0)
       {
          CComBSTR mp;
          BuildMetaPath(mp);
          CString name, pp;
          GetPhysicalPath(mp, name, pp);
          m_bstrPath = pp;
       }
       return m_bstrPath;

    case COL_STATUS:
       {
          AFX_MANAGE_STATE(::AfxGetStaticModuleState());
          CError err(m_dwWin32Error);
          if (err.Succeeded())
          {
              return OLESTR("");
          }
   
          _bstrResult = err;
          return _bstrResult;
       }
    }
    TRACEEOLID("CIISDirectory: Bad column number" << nCol);
    return OLESTR("");
}

/*virtual*/
HRESULT
CIISDirectory::AddMenuItems(
    LPCONTEXTMENUCALLBACK piCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(piCallback);
    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        piCallback,
        pInsertionAllowed,
        type
        );
    if (SUCCEEDED(hr))
    {
       ASSERT(pInsertionAllowed != NULL);
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
       {
           AddMenuSeparator(piCallback);
           if (IsFtpDir())
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR);
              if (IsConfigImportExportable())
              {
                  AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR_FROM_FILE);
              }
           }
           else if (IsWebDir())
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR);
              if (IsConfigImportExportable())
              {
                  AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR_FROM_FILE);
              }
           }
       }

       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuSeparator(piCallback);
           if (IsConfigImportExportable())
           {
               AddMenuItemByCommand(piCallback, IDM_TASK_EXPORT_CONFIG_WIZARD);
           }
       }
    }
    return hr;
}

HRESULT
CIISDirectory::InsertNewAlias(CString alias)
{
    CError err;
    if (!IsExpanded())
    {
        SelectScopeItem();
        IConsoleNameSpace2 * pConsoleNameSpace
                = (IConsoleNameSpace2 *)GetConsoleNameSpace();
        pConsoleNameSpace->Expand(QueryScopeItem());
		HSCOPEITEM hChildItem = NULL;
		LONG_PTR cookie;
		HRESULT hr = pConsoleNameSpace->GetChildItem(m_hScopeItem, &hChildItem, &cookie);
		while(SUCCEEDED(hr) && hChildItem)
		{
			CIISObject * pItem = (CIISObject *)cookie;
			ASSERT_PTR(pItem);
			if (0 == alias.Compare(pItem->QueryDisplayName()))
			{
				pItem->SelectScopeItem();
				break;
			}
			hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
		}
    }
	else
	{
		// Now we should insert and select this new site
		CIISDirectory * pAlias = new CIISDirectory(m_pOwner, m_pService, alias);
		if (pAlias != NULL)
		{
			pAlias->AddRef();
			err = pAlias->AddToScopePaneSorted(QueryScopeItem(), FALSE);
			if (err.Succeeded())
			{
				VERIFY(SUCCEEDED(pAlias->SelectScopeItem()));
			}
			else
			{
				pAlias->Release();
			}
		}
		else
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
		}
	}
    return err;
}

/* virtual */
HRESULT
CIISDirectory::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString alias;
    CError err;
    CComBSTR bstrMetaPath;

    switch (lCommandID)
    {
    case IDM_NEW_FTP_VDIR:
        BuildMetaPath(bstrMetaPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            hr = CIISMBNode::AddFTPVDir(pObj, type, alias);
            if (!alias.IsEmpty())
            {
                hr = InsertNewAlias(alias);
            }
        }
        break;

    case IDM_NEW_WEB_VDIR:
        BuildMetaPath(bstrMetaPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            hr = CIISMBNode::AddWebVDir(pObj, type, alias,
						    m_pOwner->QueryMajorVersion(), m_pOwner->QueryMinorVersion());
            if (!alias.IsEmpty())
            {
                hr = InsertNewAlias(alias);
            }
        }
        break;
        
    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}

/* virtual */
HRESULT
CIISDirectory::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CError  err;

	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }
	if (err.Succeeded())
	{
		CComBSTR bstrPath;
		//
		// CODEWORK: What to do with m_err?  This might be 
		// a bad machine object in the first place.  Aborting
		// when the machine object has an error code isn't 
		// such a bad solution here.
		//

		/*
		if (m_err.Failed())
		{
			m_err.MessageBox();
			return m_err;
		}
		*/
		err = BuildMetaPath(bstrPath);
		if (err.Succeeded())
		{
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
            if (!IsLostInterface(err))
            {
                // reset error if an other error other than No interface
                err.Reset();
            }
            if (err.Succeeded())
            {
                // cache handle for user in MMCPropertyChangeNotify
                m_ppHandle = handle;
			    err = ShowPropertiesDlg(lpProvider, QueryAuthInfo(), 
				    bstrPath, GetMainWindow(GetConsole()), (LPARAM)this, (LPARAM)GetParentNode(),handle);
            }
		}
	}
	err.MessageBoxOnFailure();
	return err;
}

HRESULT 
CIISDirectory::OnViewChange(BOOL fScope, 
    IResultData * pResult, IHeaderCtrl * pHeader, DWORD hint)
{
    // If there is win32 error set, we should clear it to enable web dirs enumeration again
    m_dwWin32Error = ERROR_SUCCESS;
	CError err = CIISMBNode::OnViewChange(fScope, pResult, pHeader, hint);
	// If parent node is selected, this node will be displayed on result
	// pane, we may need to update the status, path, etc 
	if (err.Succeeded() && 0 != (hint & PROP_CHANGE_DISPLAY_ONLY))
	{
        // This is a VDir, so it's a scope only item....
        RefreshDisplay(FALSE);
	}
	return err;
}

///////////////////////////////////////////////////////////////////

CIISFileName::CIISFileName(
      CIISMachine * pOwner,
      CIISService * pService,
      const DWORD dwAttributes,
      LPCTSTR alias,
      LPCTSTR redirect
      )
   : CIISMBNode(pOwner, alias),
     m_dwAttribute(dwAttributes),
     m_pService(pService),
     m_bstrFileName(alias),
     m_RedirectString(redirect),
     m_fEnabledApplication(FALSE),
     m_dwWin32Error(0),
     m_dwEnumError(ERROR_SUCCESS),
	 m_fResolved(FALSE)
{
    ASSERT_PTR(pService);
    m_pService->AddRef();
}

/* virtual */
LPOLESTR 
CIISFileName::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_ALIAS:
        return QueryDisplayName();

    case COL_PATH:
       if (!m_strRedirectPath.IsEmpty())
       {
           AFX_MANAGE_STATE(::AfxGetStaticModuleState());
           CString buf;
           buf.Format(IDS_REDIRECT_FORMAT, m_strRedirectPath);
           _bstrRedirectPathBuf = buf;
           return _bstrRedirectPathBuf;
       }
       return OLESTR("");

    case COL_STATUS:
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());
            CError err(m_dwWin32Error);
            if (err.Succeeded())
            {
                return OLESTR("");
            }
            _bstrResult = err;
            return _bstrResult;
        }
    }
    TRACEEOLID("CIISFileName: Bad column number" << nCol);
    return OLESTR("");
}

void 
CIISFileName::InitializeChildHeaders(LPHEADERCTRL lpHeader)
{
    CIISDirectory::InitializeHeaders(lpHeader);
}

/* virtual */
HRESULT 
CIISFileName::EnumerateScopePane(HSCOPEITEM hParent)
{
    CError err = EnumerateVDirs(hParent, m_pService, FALSE);
    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        err.Reset();
    }
    if (err.Succeeded() && /*IsWebDir() &&*/ m_strRedirectPath.IsEmpty())
    {
        if (m_dwEnumError == ERROR_SUCCESS)
        {
            err = EnumerateWebDirs(hParent, m_pService);
        }
    }
    if (err.Failed())
    {
        m_dwEnumError = err.Win32Error();
        RefreshDisplay();
    }
    return err;
}

/* virtual */
int      
CIISFileName::QueryImage() const
{
    ASSERT_PTR(m_pService);
	if (!m_fResolved)
	{
        if (m_hScopeItem == NULL)
        {
            TRACEEOLID("BUGBUG: Prematurely asked for display information");
            return MMC_IMAGECALLBACK;
        }
        //
        // Required for the wait cursor
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CIISFileName * that = (CIISFileName *)this;
        CError err = that->RefreshData();
        that->m_fResolved = err.Succeeded();
	}

    if (!m_pService)
    {
        return iError;
    }
    if (IsDir())
    {
		if (IsEnabledApplication())
		{
			return SUCCEEDED(m_dwWin32Error) ? iApplication : iApplicationErr; 
		}
		else
		{
			return SUCCEEDED(m_dwWin32Error) ? iFolder : iError; 
		}
    }
    return SUCCEEDED(m_dwWin32Error) ? iFile : iError; 
}

    
HRESULT
CIISFileName::DeleteNode(IResultData * pResult)
{
    CError err;
    CString path;
    BOOL bDeletedPhysical = FALSE;

    // check if they have the property sheet open on it.
    if (IsMyPropertySheetOpen())
    {
        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
        return S_OK;
    }

    // this could be an orphaned property sheet
    // check if an orphaned property sheet is open on this item.
    CIISObject * pAlreadyOpenProp = NULL;
    if (TRUE == g_OpenPropertySheetTracker.FindAlreadyOpenPropertySheet(this,&pAlreadyOpenProp))
    {
        // Bring it to the foreground, and bail
        HWND hHwnd = 0;
        if (pAlreadyOpenProp)
        {
            if (hHwnd = pAlreadyOpenProp->IsMyPropertySheetOpen())
            {
                if (hHwnd && (hHwnd != (HWND) 1))
                {
                    // Perhapse we should cancel the already
                    // opened property sheet...just a thought
                    if (!SetForegroundWindow(hHwnd))
                    {
                        // wasn't able to bring this property sheet to
                        // the foreground, the propertysheet must not
                        // exist anymore.  let's just clean the hwnd
                        // so that the user will be able to open propertysheet
                        pAlreadyOpenProp->SetMyPropertySheetOpen(0);
                    }
                    else
                    {
                        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
                        return S_OK;
                    }
                }
            }
        }
    }

    CComBSTR bstrMetaPath;
    err = BuildMetaPath(bstrMetaPath);
    if (err.Succeeded())
    {
        err = CheckForMetabaseAccess(METADATA_PERMISSION_WRITE,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
    }

    if (err.Succeeded())
    {
		CString physPath, alias, csPathMunged;
        GetPhysicalPath(CString(bstrMetaPath), alias, physPath);
        physPath.TrimRight(_T("/"));

        csPathMunged = physPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
        GetSpecialPathRealPath(0,physPath,csPathMunged);
#endif

        if (IsDevicePath(csPathMunged))
        {
            // check if the device path
            // points to an actual dir/file
            // if it does then enumerate it.
            if (IsSpecialPath(csPathMunged,TRUE,TRUE))
            {
                // Remunge this one more time!
                CString csBefore;
                csBefore = csPathMunged;
                GetSpecialPathRealPath(1,csBefore,csPathMunged);
            }
            else
            {
                return E_FAIL;
            }
        }

        // WARNING:physPath could be empty!
        csPathMunged.TrimLeft();
        csPathMunged.TrimRight();
        if (csPathMunged.IsEmpty())
        {
            // Physical path is empty!
            bDeletedPhysical = TRUE;
        }
        else
        {
            if (m_pService->IsLocal() || PathIsUNC(csPathMunged))
            {
                //
                // Local directory, or already a unc path
                //
                path = csPathMunged;
            }
            else
            {
                ::MakeUNCPath(path, m_pService->QueryMachineName(), csPathMunged);
            }
            LPTSTR p = path.GetBuffer(MAX_PATH);
            PathRemoveBlanks(p);
            PathRemoveBackslash(p);
            path += _T('\0');

            TRACEEOLID("Attempting to remove file/directory: " << path);

            CWnd * pWnd = AfxGetMainWnd();

            //
            // Attempt to delete using shell APIs
            //
            SHFILEOPSTRUCT sos;
            ZeroMemory(&sos, sizeof(sos));
            sos.hwnd = pWnd ? pWnd->m_hWnd : NULL;
            sos.wFunc = FO_DELETE;
            sos.pFrom = path;
            sos.fFlags = (GetAsyncKeyState(VK_SHIFT) < 0) ? 0 : FOF_ALLOWUNDO;

            // Use assignment to avoid conversion and wrong constructor call
            err = ::SHFileOperation(&sos);
            if (err.Succeeded() && !sos.fAnyOperationsAborted)
            {
                bDeletedPhysical = TRUE;
            }
        }

        if (bDeletedPhysical)
        {
            CMetaInterface * pInterface = QueryInterface();
            ASSERT(pInterface != NULL);
            bstrMetaPath = _T("");
            err = BuildMetaPath(bstrMetaPath);
            if (err.Succeeded()) 
            {
                CMetaKey mk(pInterface, METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_WRITE);
                if (mk.Succeeded())
                {
                    err = mk.DeleteKey(bstrMetaPath);
                }
			    // don't hold the Metabasekey open
			    // (RemoveScopeItem may do a lot of things,and lock the metabase for other read requests)
			    mk.Close();
            }
		    if (IsDir())
		    {
			    err = RemoveScopeItem();
		    }
		    else
		    {
			    CIISMBNode * pParent = GetParentNode();
			    ASSERT(pParent != NULL);
			    if (pParent)
			    {
				    err = pParent->RemoveResultNode(this, pResult);
			    }
		    }
        }
    }

    if (err.Failed())
    {
        DisplayError(err);
    }
    path.ReleaseBuffer();
    return err;
}

HRESULT
CIISFileName::RenameItem(LPOLESTR new_name)
{
    CError err;
    CComBSTR old_name;
    CComBSTR MetabaseParentPath;
    CComBSTR MetabasePathOld;
    CString  PhysPathMetabase, PhysPathFrom, PhysPathTo;
    CString  alias, csPathMunged;
    CIISMBNode * pParentNode = NULL;
    CMetaInterface * pInterface = NULL;
    SHFILEOPSTRUCT sos;
    BOOL bDeletedPhysical = FALSE;
    CWnd * pWnd = AfxGetMainWnd();

    if (new_name == NULL || lstrlen(new_name) == 0)
    {
        return S_OK;
    }

    // Make sure we have a metabase conneciton...
    err = BuildMetaPath(MetabasePathOld);
    if (err.Succeeded())
    {
        err = CheckForMetabaseAccess(METADATA_PERMISSION_WRITE,this,TRUE,MetabasePathOld);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
    }

    pInterface = QueryInterface();
    if (!pInterface)
    {
        err = E_FAIL;
        goto RenameItem_Exit;
    }

    //
    // Get all of the needed paths we need..
    //

    // get old paths...
    old_name = QueryNodeName();
    if (err.Succeeded())
    {
        GetPhysicalPath(CString(MetabasePathOld), alias, PhysPathMetabase);
        PhysPathMetabase.TrimRight(_T("/"));
    }

    // get new paths...
    if (err.Succeeded())
    {
        err = E_FAIL;
        pParentNode = GetParentNode();
        if (pParentNode)
        {
            err = pParentNode->BuildMetaPath(MetabaseParentPath);
        }
    }

    // if anything fails up till this point, abort
    if (err.Succeeded())
    {
        //
        //  Do the actual work
        //
        csPathMunged = PhysPathMetabase;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
        GetSpecialPathRealPath(0,PhysPathMetabase,csPathMunged);
#endif

        if (IsDevicePath(csPathMunged))
        {
            // check if the device path
            // points to an actual dir/file
            // if it does then enumerate it.
            if (IsSpecialPath(csPathMunged,TRUE,TRUE))
            {
                // Remunge this one more time!
                CString csBefore;
                csBefore = csPathMunged;
                GetSpecialPathRealPath(1,csBefore,csPathMunged);
            }
            else
            {
                err = E_FAIL;
                goto RenameItem_Exit;
            }
        }

        // WARNING:physPath could be empty!
        csPathMunged.TrimLeft();
        csPathMunged.TrimRight();
        if (csPathMunged.IsEmpty())
        {
            // Physical path is empty!
            bDeletedPhysical = TRUE;
        }
        else
        {
            if (m_pService->IsLocal() || PathIsUNC(csPathMunged))
            {
                //
                // Local directory, or already a unc path
                //
                PhysPathFrom = csPathMunged;
            }
            else
            {
                ::MakeUNCPath(PhysPathFrom, m_pService->QueryMachineName(), csPathMunged);
            }
            LPTSTR p = PhysPathFrom.GetBuffer(MAX_PATH);
            PathRemoveBlanks(p);
            PathRemoveBackslash(p);
            PhysPathFrom.ReleaseBuffer();
            PhysPathFrom += _T('\0');

            PhysPathTo = PhysPathFrom;
            p = PhysPathTo.GetBuffer(MAX_PATH);
            PathRemoveFileSpec(p);
            PathAppend(p, new_name);
            PhysPathTo.ReleaseBuffer();
            PhysPathTo += _T('\0');

            //
            // Attempt to delete using shell APIs
            //
            ZeroMemory(&sos, sizeof(sos));
            sos.hwnd = pWnd ? pWnd->m_hWnd : NULL;
            sos.wFunc = FO_RENAME;
            sos.pFrom = PhysPathFrom;
            sos.pTo = PhysPathTo;
            sos.fFlags = FOF_ALLOWUNDO;

            // Use assignment to avoid conversion and wrong constructor call
            err = ::SHFileOperation(&sos);
            if (err.Succeeded() && !sos.fAnyOperationsAborted)
            {
                bDeletedPhysical = TRUE;
            }
        }

        if (bDeletedPhysical)
        {
            // rename the metabase path too...
            if (pInterface)
            {
                err = CChildNodeProps::Rename(pInterface,
                                            MetabaseParentPath,
                                            old_name,
                                            new_name
                                            );
                if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
                {
                    err.Reset();
                }
                if (err.Win32Error() == ERROR_ALREADY_EXISTS)
                {
                    CComBSTR MetabasePathNew;

                    // perhapes the path we are renaming to
                    // already is there???
                    // what should we do then????
                    // if we got this far, then the filename that this is being renamed to.
                    // cannot exists, therefore the metabase properties that were there for
                    // it is invalid...
                    MetabasePathNew = MetabaseParentPath;
                    MetabasePathNew.Append(_cszSeparator);
                    MetabasePathNew.Append(new_name);

                    //delete key and try again...
                    CMetaKey mk(pInterface, METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_WRITE);
                    if (mk.Succeeded())
                    {
                        err = mk.DeleteKey(MetabasePathNew);
                        mk.Close();
                    }

                    err = CChildNodeProps::Rename(pInterface,
                                                MetabaseParentPath,
                                                old_name,
                                                new_name
                                                );
                    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
                    {
                        err.Reset();
                    }
                }

            }
            else
            {
                err = E_FAIL;
            }

            if (err.Failed())
            {
                // if we failed to rename the metabase path in the 
                // metabase, then revert the file rename...
                ZeroMemory(&sos, sizeof(sos));
                sos.hwnd = pWnd ? pWnd->m_hWnd : NULL;
                sos.wFunc = FO_RENAME;
                sos.pFrom = PhysPathTo;
                sos.pTo = PhysPathFrom;
                sos.fFlags = FOF_ALLOWUNDO;
                ::SHFileOperation(&sos);
                DisplayError(err);
                goto RenameItem_Exit;
            }

            if (err.Succeeded())
            {
                IConsole * pConsole = (IConsole *)GetConsole();
                // Update result item in the mmc
                CComQIPtr<IResultData, &IID_IResultData> lpResultData(pConsole);
                m_bstrFileName = new_name;
                err = lpResultData->UpdateItem(m_hResultItem);
                m_bstrNode = new_name;
            }
        }
        else
        {
            if (err.Failed())
            {
                DisplayError(err);
            }
        }
    }

RenameItem_Exit:
    return err;
}

/* virtual */
HRESULT
CIISFileName::RefreshData()
/*++
    Refresh relevant configuration data required for display.
--*/
{
    CError err;

    CWaitCursor wait;
    CComBSTR bstrPath;
    CMetaKey * pKey = NULL;

    do
    {
        err = BuildMetaPath(bstrPath);
        if (err.Failed())
        {
            break;
        }

        BOOL fContinue = TRUE;

        while (fContinue)
        {
            fContinue = FALSE;
            pKey = new CMetaKey(QueryInterface(), bstrPath);

            if (!pKey)
            {
                TRACEEOLID("RefreshData: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
			err = pKey->QueryResult();
            if (IsLostInterface(err))
            {
				SAFE_DELETE(pKey);
                fContinue = OnLostInterface(err);
            }
        }

        if (err.Failed())
        {
            //
            // Filter out the non-fatal errors
            //
            switch(err.Win32Error())
            {
            case ERROR_ACCESS_DENIED:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                err.Reset();
                break;

            default:
                TRACEEOLID("Fatal error occurred " << err);
            }
            // No metabase path: nothing more to do
            break;
        }
		CChildNodeProps child(pKey, NULL /*bstrPath*/, WITH_INHERITANCE, FALSE);
		err = child.LoadData();
		m_dwWin32Error = child.QueryWin32Error();
		if (err.Succeeded())
		{
			CString buf = child.m_strAppRoot;
			m_fEnabledApplication = (buf.CompareNoCase(bstrPath) == 0) && child.IsEnabledApplication();
		}
        m_strRedirectPath.Empty();
        if (child.IsRedirected())
        {
            m_strRedirectPath = child.GetRedirectedPath();
        }
    }
    while(FALSE);

    SAFE_DELETE(pKey);
    m_dwEnumError = err.Win32Error();

    return err;
}

/*virtual*/
HRESULT
CIISFileName::AddMenuItems(
    LPCONTEXTMENUCALLBACK piCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(piCallback);
    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        piCallback,
        pInsertionAllowed,
        type
        );
    if (SUCCEEDED(hr))
    {
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
       {
           AddMenuSeparator(piCallback);
           if (_tcsicmp(m_pService->QueryServiceName(), SZ_MBN_FTP) == 0)
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR);
           }
           else if (_tcsicmp(m_pService->QueryServiceName(), SZ_MBN_WEB) == 0)
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR);
              if (_tcsicmp(GetKeyType(),IIS_CLASS_WEB_DIR_W) == 0)
              {
                  if (IsConfigImportExportable())
                  {
                      AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR_FROM_FILE);
                  }
              }
           }
       }
       ASSERT(pInsertionAllowed != NULL);
    }
    return hr;
}


/* virtual */
HRESULT
CIISFileName::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString alias;
    CError err;
    CComBSTR bstrMetaPath;
    BOOL bNeedMetabase = FALSE;
    BOOL bHaveMetabase = FALSE;

    switch (lCommandID)
    {
        case IDM_NEW_FTP_VDIR:
        case IDM_NEW_WEB_VDIR:
            bNeedMetabase = TRUE;
            break;
        case IDM_BROWSE:
            if (m_hResultItem != 0)
            {
                bNeedMetabase = TRUE;
            }
            break;
        default:
            bNeedMetabase = FALSE;
    }

    if (bNeedMetabase)
    {
        // WARNING:bstrMetaPath will be used by switch statement below
        VERIFY(SUCCEEDED(BuildMetaPath(bstrMetaPath)));
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            bHaveMetabase = TRUE;
        }
    }

    switch (lCommandID)
    {

    case IDM_NEW_FTP_VDIR:
        if (bHaveMetabase)
        {
            hr = CIISMBNode::AddFTPVDir(pObj, type, alias);
            if (!alias.IsEmpty())
            {
                hr = InsertNewAlias(alias);
            }
        }
        break;

    case IDM_NEW_WEB_VDIR:
        if (bHaveMetabase)
        {
            hr = CIISMBNode::AddWebVDir(pObj, type, alias,
						    m_pOwner->QueryMajorVersion(), m_pOwner->QueryMinorVersion());
            if (!alias.IsEmpty())
            {
                hr = InsertNewAlias(alias);
            }
        }
        break;

	case IDM_BROWSE:
		if (m_hResultItem != 0)
		{
            if (bHaveMetabase)
            {
			    BuildURL(m_bstrURL);
			    if (m_bstrURL.Length())
			    {
			        ShellExecute(GetMainWindow(GetConsole())->m_hWnd, _T("open"), m_bstrURL, NULL, NULL, SW_SHOWNORMAL);
			    }
            }
		}
		else
		{
			hr = CIISMBNode::Command(lCommandID, pObj, type);
		}
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

//    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT
CIISFileName::InsertNewAlias(CString alias)
{
    CError err;
    if (!IsExpanded())
    {
        SelectScopeItem();
        IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
        pConsoleNameSpace->Expand(QueryScopeItem());
		HSCOPEITEM hChildItem = NULL;
		LONG_PTR cookie;
		HRESULT hr = pConsoleNameSpace->GetChildItem(m_hScopeItem, &hChildItem, &cookie);
		while(SUCCEEDED(hr) && hChildItem)
		{
			CIISObject * pItem = (CIISObject *)cookie;
			ASSERT_PTR(pItem);
			if (0 == alias.Compare(pItem->QueryDisplayName()))
			{
				pItem->SelectScopeItem();
				break;
			}
			hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
		}
    }
	else
	{
		// Now we should insert and select this new site
		CIISDirectory * pAlias = new CIISDirectory(m_pOwner, m_pService, alias);
		if (pAlias != NULL)
		{
			pAlias->AddRef();
			err = pAlias->AddToScopePaneSorted(QueryScopeItem(), FALSE);
			if (err.Succeeded())
			{
				VERIFY(SUCCEEDED(pAlias->SelectScopeItem()));
			}
			else
			{
				pAlias->Release();
			}
		}
		else
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
		}
	}
    return err;
}

/* virtual */
HRESULT
CIISFileName::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CError  err;
	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }
	if (err.Succeeded())
	{
		CComBSTR bstrPath;
		CError err(BuildMetaPath(bstrPath));

		if (err.Succeeded())
		{
			//
			// If there's already a property sheet open on this item
			// then make it the foreground window and bail.
			HWND MyPropWindow = IsMyPropertySheetOpen();
			if (MyPropWindow && (MyPropWindow != (HWND) 1))
			{
				if (SetForegroundWindow(MyPropWindow))
				{
					if (handle)
					{
						MMCFreeNotifyHandle(handle);
						handle = 0;
					}
					return S_FALSE;
				}
				else
				{
					// wasn't able to bring this property sheet to
					// the foreground, the propertysheet must not
					// exist anymore.  let's just clean the hwnd
					// so that the user will be able to open propertysheet
					SetMyPropertySheetOpen(0);
				}
			}

            // cache handle for user in MMCPropertyChangeNotify
            m_ppHandle = handle;

            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
            if (!IsLostInterface(err))
            {
                // reset error if an other error other than No interface
                err.Reset();
            }
            if (err.Succeeded())
            {
			    if (IsDir())
			    {
				    err = ShowDirPropertiesDlg(
					    lpProvider, QueryAuthInfo(), bstrPath,
					    GetMainWindow(GetConsole()), (LPARAM)this, (LPARAM)GetParentNode(), handle
					    );
			    }
			    else
			    {
				    err = ShowFilePropertiesDlg(
					    lpProvider, QueryAuthInfo(), bstrPath,
					    GetMainWindow(GetConsole()), (LPARAM)this, (LPARAM)GetParentNode(), handle
					    );
			    }
            }
		}
        err.MessageBoxOnFailure();
	}
    return err;
}

HRESULT
CIISFileName::ShowDirPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LPARAM  lParamParent,
    LONG_PTR handle
    )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT_PTR(lpProvider);

    CError err;

	if (TRUE == m_fFlaggedForDeletion)
	{
		// this item was marked for deletion during the RefreshData
		// so don't display it's property page.
		// instead popup an error.
		err = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	else
	{
		CW3Sheet * pSheet = new CW3Sheet(
			pAuthInfo,
			lpszMDPath,
			0, 
			pMainWnd,
			lParam,
            lParamParent
			);

		if (pSheet)
		{
			pSheet->SetModeless();

			//
			// Add file pages
			//
			pSheet->SetSheetType(pSheet->SHEET_TYPE_DIR);
			err = AddMMCPage(lpProvider, new CW3DirPage(pSheet));
			err = AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
			err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, FALSE, FILE_ATTRIBUTE_DIRECTORY));
			err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
			err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));
		}
		else
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
		}
	}

    return err;
}

HRESULT
CIISFileName::ShowFilePropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LPARAM  lParamParent,
    LONG_PTR handle
    )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT_PTR(lpProvider);

    CError err;

	if (TRUE == m_fFlaggedForDeletion)
	{
		// this item was marked for deletion during the RefreshData
		// so don't display it's property page.
		// instead popup an error.
		err = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	else
	{
		CW3Sheet * pSheet = new CW3Sheet(
			pAuthInfo,
			lpszMDPath,
			0, 
			pMainWnd,
			lParam,
            lParamParent
			);

		if (pSheet)
		{
			pSheet->SetModeless();
			//
			// Add file pages
			//
			pSheet->SetSheetType(pSheet->SHEET_TYPE_FILE);
			err = AddMMCPage(lpProvider, new CW3FilePage(pSheet));
			err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, FALSE, 0));
			err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
			err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));
		}
		else
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
		}
	}

    return err;
}

HRESULT
CIISFileName::OnViewChange(BOOL fScope, 
    IResultData * pResult, IHeaderCtrl * pHeader, DWORD hint)
{
    // If there is win32 error set, we should clear it to enable web dirs enumeration again
    m_dwWin32Error = ERROR_SUCCESS;
	CError err = CIISMBNode::OnViewChange(fScope, pResult, pHeader, hint);
	// If parent node is selected, this node will be displayed on result
	// pane, we may need to update the status, path, etc 
	//if (err.Succeeded() && 0 != (hint & PROP_CHANGE_DISPLAY_ONLY))
	//{
 //       pResult->UpdateItem(IsDir() ? m_hScopeItem : m_hResultItem);
	//}
	return err;
}

HRESULT
CIISFileName::OnDblClick(IComponentData * pcd, IComponent * pc)
{
    if (IsDir())
    {
        return CIISMBNode::OnDblClick(pcd, pc);
    }
    else
    {
        CComQIPtr<IPropertySheetProvider, &IID_IPropertySheetProvider> spProvider(GetConsole());
        IDataObject * pdo = NULL;
        GetDataObject(&pdo, CCT_RESULT);
        CError err = spProvider->FindPropertySheet(reinterpret_cast<MMC_COOKIE>(this), 0, pdo);
        if (err != S_OK)
        {
            err = spProvider->CreatePropertySheet(m_bstrFileName, TRUE, (MMC_COOKIE)this, pdo, MMC_PSO_HASHELP);
            if (err.Succeeded())
            {
                err = spProvider->AddPrimaryPages(
                    pc,
                    TRUE,   // we may want to get property change notifications
                    NULL,   // according to docs
                    FALSE   // for result item only
                    );
                if (err.Succeeded())
                {
                    err = spProvider->AddExtensionPages();
                }
            }
            if (err.Succeeded())
            {
                HWND hWnd = NULL;
                VERIFY(SUCCEEDED(GetConsole()->GetMainWindow(&hWnd)));
                VERIFY(SUCCEEDED(spProvider->Show((LONG_PTR)hWnd, 0)));
            }
            else
            {
                spProvider->Show(-1, 0);
            }
        }
	    return err;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iishelp.h ===
void GetInetmgrParamFlag(void);
BOOL SetInetmgrParamFlag(DWORD dwFlagToSet,BOOL bState);
void GetOutputDebugFlag(void);
void DebugTrace(LPTSTR lpszFormat, ...);
void WinHelpDebug(DWORD_PTR dwWinHelpID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\httppage.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        httppage.cpp

   Abstract:
        HTTP Headers property page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "hdrdlg.h"
#include "HTTPPage.h"
#include "mime.h"
#include "iisobj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/* static */
void
CHeader::CrackDisplayString(
    IN  LPCTSTR lpstrDisplayString,
    OUT CString & strHeader,
    OUT CString & strValue
    )
/*++

Routine Description:

    Crack the display string into component formats

Arguments:

    LPCTSTR lpstrDisplayString  : Input display string
    CString & strHeader         : Header
    CString & strValue          : Value

Return Value:

    N/A

--*/
{
    strHeader = lpstrDisplayString;
    strHeader.TrimLeft();
    strHeader.TrimRight();
    int nColon = strHeader.Find(_T(':'));
    if (nColon >= 0)
    {
        strValue = (lpstrDisplayString + nColon + 1);
        strHeader.ReleaseBuffer(nColon);
    }

    strValue.TrimLeft();
    strValue.TrimRight();
}



//
// HTTP Custom Header Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


#define MINUTE              (60L)
#define HOUR                (60L * MINUTE)
#define DAY                 (24L * HOUR)
#define YEAR                (365 * DAY)

#define EXPIRE_IMMEDIATELY  ((LONG)(0L))
#define EXPIRE_INFINITE     ((LONG)(0xffffffff))
#define EXPIRE_DEFAULT      ((LONG)(1L * DAY)) // 1 day
#define DEFAULT_DYN_EXPIRE  (10L * DAY)
#define EXPIRE_MIN_NUMBER   (1)
#define EXPIRE_MAX_NUMBER   (32767)



IMPLEMENT_DYNCREATE(CW3HTTPPage, CInetPropertyPage)



CW3HTTPPage::CW3HTTPPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Property page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet data

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3HTTPPage::IDD, pSheet),
      m_fValuesAdjusted(FALSE),
      m_ppropMimeTypes(NULL),
      m_tmNow(CTime::GetCurrentTime())
{

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CW3HTTPPage)
//    m_nTimeSelector = -1;
//    m_nImmediateTemporary = -1;
    m_fEnableExpiration = FALSE;
//    m_nExpiration = 0L;
    m_strlCustomHeaders = _T("");
    //}}AFX_DATA_INIT

#endif // 0
    m_nExpiration = 1L;
    m_nImmediateTemporary = RADIO_EXPIRE;
	m_nTimeSelector = COMBO_DAYS;
}



CW3HTTPPage::~CW3HTTPPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3HTTPPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3HTTPPage)
    DDX_Control(pDX, IDC_BUTTON_FILE_TYPES, m_button_FileTypes);
    DDX_Radio(pDX, IDC_RADIO_IMMEDIATELY, m_nImmediateTemporary);
    DDX_Check(pDX, IDC_CHECK_EXPIRATION, m_fEnableExpiration);
    DDX_Control(pDX, IDC_EDIT_EXPIRE, m_edit_Expire);
    DDX_Control(pDX, IDC_RADIO_IMMEDIATELY, m_radio_Immediately);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_Delete);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_STATIC_CONTENT_SHOULD, m_static_Contents);
    DDX_Control(pDX, IDC_COMBO_TIME, m_combo_Time);
    //}}AFX_DATA_MAP
    //
    // Only store and validate immediate expiration date if immediate
    // is selected.
    //
    if (!pDX->m_bSaveAndValidate || m_nImmediateTemporary == RADIO_EXPIRE)
    {
        DDX_CBIndex(pDX, IDC_COMBO_TIME, m_nTimeSelector);
		if (m_fEnableExpiration)
		{
			// This Needs to come before DDX_Text which will try to put text big number into small number
			DDV_MinMaxBalloon(pDX, IDC_EDIT_EXPIRE, EXPIRE_MIN_NUMBER, EXPIRE_MAX_NUMBER);
		}
		DDX_Text(pDX, IDC_EDIT_EXPIRE, m_nExpiration);
    }

    DDX_Control(pDX, IDC_RADIO_TIME, m_radio_Time);
    DDX_Control(pDX, IDC_RADIO_ABS_TIME, m_radio_AbsTime);
    DDX_Control(pDX, IDC_DTP_ABS_DATE, m_dtpDate);
    DDX_Control(pDX, IDC_DTP_ABS_TIME, m_dtpTime);
    DDX_Control(pDX, IDC_LIST_HEADERS, m_list_Headers);

    if (pDX->m_bSaveAndValidate)
    {
        StoreTime();
        StoreHeaders();
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CW3HTTPPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3HTTPPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_FILE_TYPES, OnButtonFileTypes)
    ON_BN_CLICKED(IDC_BUTTON_RATINGS_TEMPLATE, OnButtonRatingsTemplate)
    ON_BN_CLICKED(IDC_CHECK_EXPIRATION, OnCheckExpiration)
    ON_CBN_SELCHANGE(IDC_COMBO_TIME, OnSelchangeComboTime)
    ON_LBN_SELCHANGE(IDC_LIST_HEADERS, OnSelchangeListHeaders)
    ON_LBN_DBLCLK(IDC_LIST_HEADERS, OnDblclkListHeaders)
    ON_BN_CLICKED(IDC_RADIO_IMMEDIATELY, OnRadioImmediately)
    ON_BN_CLICKED(IDC_RADIO_TIME, OnRadioTime)
    ON_BN_CLICKED(IDC_RADIO_ABS_TIME, OnRadioAbsTime)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_EXPIRE, OnItemChanged)

END_MESSAGE_MAP()



BOOL
AdjustIfEvenMultiple(
    IN OUT CILong & ilValue,
    IN LONG lMultiple
    )
/*++

Routine Description:

    Check to see if ilValue is an even multiple of lMultiple.
    If so, divide ilValue by lMultiple

Arguments:

    CILong & ilValue      : Value
    LONG lMultiple        : Multiple

Return Value:

    TRUE if ilValue is an even multiple of lMultiple.

--*/
{
    DWORD dw = (DWORD)(LONG)ilValue / (DWORD)lMultiple;
    if (dw * (DWORD)lMultiple == (DWORD)(LONG)ilValue)
    {
        ilValue = (LONG)dw;
        return TRUE;
    }

    return FALSE;
}



BOOL
CW3HTTPPage::CrackExpirationString(
    IN CString & strExpiration
    )
/*++

Routine Description:

    Crack the expiration string into component parts.  Using either N or a blank
    string to signify "No expiration"

Arguments:

    None

Return Value:

    return TRUE if the values had to be adjusted because they were out of
    range.

--*/
{
    strExpiration.TrimLeft();
    strExpiration.TrimRight();
    BOOL fValueAdjusted = FALSE;

    m_fEnableExpiration = !strExpiration.IsEmpty();
    LPCTSTR lp = strExpiration;
    BOOL fAbs = FALSE;
    if (m_fEnableExpiration)
    {
        switch(*lp)
        {
        case _T('D'):
        case _T('d'):
            lp += 2;
            while (_istspace(*lp)) ++lp;
            CvtStringToLong(lp, &m_dwRelTime);
            break;

        case _T('S'):
        case _T('s'):
            lp += 2;
            while (_istspace(*lp)) ++lp;
            m_dwRelTime = EXPIRE_DEFAULT;

            time_t tm;
            if (!CvtGMTStringToInternal(lp, &tm))
            {
                DoHelpMessageBox(m_hWnd,IDS_ERR_EXPIRE_RANGE, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
                fValueAdjusted = TRUE;
            }

            m_tm = tm;
            fAbs = TRUE;
            break;

        case _T('N'):
        case _T('n'):
            m_fEnableExpiration = FALSE;
            break;

        default:
            TRACEEOLID("Expiration string in bogus format");
            m_fEnableExpiration = FALSE;
        }
    }

    //
    // Set Values:
    //
    m_nExpiration = (LONG)m_dwRelTime;

    m_nImmediateTemporary = fAbs
        ? RADIO_EXPIRE_ABS
        : (m_nExpiration == EXPIRE_IMMEDIATELY)
            ? RADIO_IMMEDIATELY
            : RADIO_EXPIRE;

    //
    // Adjust time
    //
    if (m_nExpiration == EXPIRE_INFINITE
     || m_nExpiration == EXPIRE_IMMEDIATELY)
    {
        m_nExpiration = EXPIRE_DEFAULT;
    }

    if (AdjustIfEvenMultiple(m_nExpiration, DAY))
    {
        m_nTimeSelector = COMBO_DAYS;
    }
    else if (AdjustIfEvenMultiple(m_nExpiration, HOUR))
    {
        m_nTimeSelector = COMBO_HOURS;
    }
    else
    {
        m_nExpiration /= MINUTE;
        m_nExpiration = __max((DWORD)(LONG)m_nExpiration, 1L);
        if (m_nExpiration < EXPIRE_MIN_NUMBER ||
            m_nExpiration > EXPIRE_MAX_NUMBER)
        {
            m_nExpiration = (EXPIRE_DEFAULT / MINUTE);
            DoHelpMessageBox(m_hWnd,IDS_ERR_EXPIRE_RANGE, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
        }

        m_nTimeSelector = COMBO_MINUTES;
    }

    return fValueAdjusted;
}



void
CW3HTTPPage::MakeExpirationString(
    OUT CString & strExpiration
    )
/*++

Routine Description:

    Make the expiration string from component parts

Arguments:

    None

Return Value:

    None

--*/
{
    strExpiration.Empty();

    DWORD dwExpiration = m_nExpiration;

    if (m_fEnableExpiration)
    {
        switch(m_nImmediateTemporary)
        {
        case RADIO_IMMEDIATELY:
            strExpiration = _T("D, 0");
            break;

        case RADIO_EXPIRE:
            switch(m_nTimeSelector)
            {
            case COMBO_MINUTES:
                dwExpiration *= MINUTE;
                break;

            case COMBO_HOURS:
                dwExpiration *= HOUR;
                break;

            case COMBO_DAYS:
                dwExpiration *= DAY;
                break;

            default:
                ASSERT(FALSE);
            }

            strExpiration.Format(_T("D, 0x%0x"), dwExpiration);
            break;

        case RADIO_EXPIRE_ABS:
            CvtInternalToGMTString(m_tm.GetTime(), strExpiration);
            strExpiration = _T("S, ") + strExpiration;
            break;

        default:
            TRACEEOLID("Unknown expiration format");
            ASSERT(FALSE);

            return;
        }
    }
}



/* virtual */
HRESULT
CW3HTTPPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    BEGIN_META_DIR_READ(CW3Sheet)
        CString m_strExpiration;

        FETCH_DIR_DATA_FROM_SHEET(m_strExpiration);
        FETCH_DIR_DATA_FROM_SHEET(m_strlCustomHeaders);

        //
        // Set up some defaults.
        //
        m_dwRelTime = EXPIRE_DEFAULT;

        m_tm = CTime(
            m_tmNow.GetYear(),
            m_tmNow.GetMonth(),
            m_tmNow.GetDay(),
            0, 0, 0          // Midnight
            );
        m_tm += DEFAULT_DYN_EXPIRE;

        m_fValuesAdjusted = CrackExpirationString(m_strExpiration);
    END_META_DIR_READ(err)

    //
    // Fetch the properties from the metabase
    //
    ASSERT(m_ppropMimeTypes == NULL);

    CError err;

    m_ppropMimeTypes = new CMimeTypes(
        QueryAuthInfo(),
//        CMetabasePath(g_cszSvc, QueryInstance(), SZ_MBN_ROOT)
		QueryMetaPath()
        );

    if (m_ppropMimeTypes)
    {
        err = m_ppropMimeTypes->LoadData();
        if (err.Succeeded())
        {
            m_strlMimeTypes = m_ppropMimeTypes->m_strlMimeTypes;
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



void
CW3HTTPPage::StoreTime()
/*++

Routine Description:

    Built datetime by combining current date with the time from the time
    controls.

Arguments:

    None

Return Value:

    None

--*/
{
    SYSTEMTIME tmDate, tmTime;

    m_dtpDate.GetTime(&tmDate);
    m_dtpTime.GetTime(&tmTime);

    m_tm = CTime(
        tmDate.wYear,
        tmDate.wMonth,
        tmDate.wDay,
        tmTime.wHour,
        tmTime.wMinute,
        tmTime.wSecond
        );
}



void
CW3HTTPPage::SetTimeFields()
/*++

Routine Description:

    Set time fields from CTime structure

Arguments:

    None

Return Value:

    None

--*/
{
    SYSTEMTIME stm =
    {
        (WORD)m_tm.GetYear(),
        (WORD)m_tm.GetMonth(),
        (WORD)m_tm.GetDayOfWeek(),
        (WORD)m_tm.GetDay(),
        (WORD)m_tm.GetHour(),
        (WORD)m_tm.GetMinute(),
        (WORD)m_tm.GetSecond(),
        0   // Milliseconds
    };

    m_dtpDate.SetTime(&stm);
    m_dtpTime.SetTime(&stm);
}



void
CW3HTTPPage::FillListBox()
/*++

Routine Description:

    Fill the custom headers listbox with the custom headers entries

Arguments:

    None

Return Value:

    None

--*/
{
    CObListIter obli(m_oblHeaders);
    CHeader * pHeader;

    //
    // Remember the selection.
    //
    int nCurSel = m_list_Headers.GetCurSel();

    m_list_Headers.SetRedraw(FALSE);
    m_list_Headers.ResetContent();
    int cItems = 0 ;

    CString strCustom;
    for ( /**/ ; pHeader = (CHeader *)obli.Next() ; cItems++ )
    {
        m_list_Headers.AddString(pHeader->DisplayString(strCustom));
    }

    m_list_Headers.SetRedraw(TRUE);
    m_list_Headers.SetCurSel(nCurSel);
}



BOOL
CW3HTTPPage::SetControlStates()
/*++

Routine Description:

    Set the control enabled/disabled states depending on the state of the
    dialog

Arguments:

    None

Return Value:

    TRUE if an item was selected in the headers listbox, FALSE otherwise.

--*/
{
    BOOL fSingleSelection = m_list_Headers.GetSelCount() == 1;

    m_button_Edit.EnableWindow(fSingleSelection);
    m_button_Delete.EnableWindow(m_list_Headers.GetSelCount() > 0);

    BOOL fExpire = (m_nImmediateTemporary == RADIO_EXPIRE);
    BOOL fExpireAbs = (m_nImmediateTemporary == RADIO_EXPIRE_ABS);

    m_static_Contents.EnableWindow(m_fEnableExpiration);

    m_radio_Immediately.EnableWindow(m_fEnableExpiration);
    m_radio_Time.EnableWindow(m_fEnableExpiration);
    m_radio_AbsTime.EnableWindow(m_fEnableExpiration);

    m_edit_Expire.EnableWindow(m_fEnableExpiration && fExpire);
    m_combo_Time.EnableWindow(m_fEnableExpiration && fExpire);

    m_dtpDate.EnableWindow(m_fEnableExpiration && fExpireAbs);
    m_dtpTime.EnableWindow(m_fEnableExpiration && fExpireAbs);

    return fSingleSelection;
}



void
CW3HTTPPage::FetchHeaders()
/*++

Routine Description:

    Build custom headers oblist

Arguments:

    None

Return Value:

    None

--*/
{
    POSITION pos = m_strlCustomHeaders.GetHeadPosition();

    while(pos)
    {
        CString & str = m_strlCustomHeaders.GetNext(pos);
        m_oblHeaders.AddTail(new CHeader(str));
    }
}



BOOL
CW3HTTPPage::HeaderExists(
    IN LPCTSTR lpHeader
    )
/*++

Routine Description:

    Check to see if a given header exists in the list

Arguments:

    LPCTSTR strHeader   : Header name

Return Value:

    TRUE if the entry exists, FALSE otherwise.

--*/
{
    POSITION pos = m_oblHeaders.GetHeadPosition();
    while(pos)
    {
        CHeader * pHeader = (CHeader *)m_oblHeaders.GetNext(pos);
        ASSERT(pHeader);
        if (!pHeader->GetHeader().CompareNoCase(lpHeader))
        {
            return TRUE;
        }
    }

    return FALSE;
}



void
CW3HTTPPage::StoreHeaders()
/*++

Routine Description:

    Convert the headers oblist to a stringlist

Arguments:

    None

Return Value:

    None

--*/
{
    m_strlCustomHeaders.RemoveAll();

    POSITION pos = m_oblHeaders.GetHeadPosition();
    while(pos)
    {
        CHeader * pHdr = (CHeader *)m_oblHeaders.GetNext(pos);
        ASSERT(pHdr != NULL);

        CString str;
        pHdr->DisplayString(str);
        m_strlCustomHeaders.AddTail(str);
    }
}



INT_PTR
CW3HTTPPage::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit.
    return the value returned by the dialog

Arguments:

    None

Return Value:

    Return value of the dialog (IDOK or IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CHeader * pHeader = NULL;
    LPCTSTR lpstrHeader = NULL;
    LPCTSTR lpstrValue = NULL;
    int nCurSel = LB_ERR;
    INT_PTR nReturn;

    if (!fAdd)
    {
        nCurSel = m_list_Headers.GetCurSel();
        ASSERT(nCurSel != LB_ERR);
        pHeader = (CHeader *)m_oblHeaders.GetAt(m_oblHeaders.FindIndex(nCurSel));
        ASSERT(pHeader != NULL);
        lpstrHeader = pHeader->QueryHeader();
        lpstrValue = pHeader->QueryValue();
    }

    CHeaderDlg dlg(lpstrHeader, lpstrValue, this);
    nReturn = dlg.DoModal();

    if (nReturn == IDOK)
    {
        CString strEntry;

        if (fAdd)
        {
            if (HeaderExists(dlg.GetHeader()))
            {
                DoHelpMessageBox(m_hWnd,IDS_ERR_DUP_HEADER, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
                return IDCANCEL;
            }

            pHeader = new CHeader(dlg.GetHeader(), dlg.GetValue());
            m_oblHeaders.AddTail(pHeader);
            m_list_Headers.SetCurSel(m_list_Headers.AddString(
                pHeader->DisplayString(strEntry))
                );
        }
        else
        {
            pHeader->SetHeader(dlg.GetHeader());
            pHeader->SetValue(dlg.GetValue());
            m_list_Headers.DeleteString(nCurSel);
            m_list_Headers.InsertString(
                nCurSel, 
                pHeader->DisplayString(strEntry)
                );
            m_list_Headers.SetCurSel(nCurSel);
        }
    }

    return nReturn;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


void
CW3HTTPPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}



void
CW3HTTPPage::OnButtonAdd()
/*++

Routine Description:

    'add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        SetControlStates();
        OnItemChanged();
    }
}



void
CW3HTTPPage::OnButtonDelete()
/*++

Routine Description:

    'delete' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Headers.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_Headers.GetCount())
    {
        if (m_list_Headers.GetSel(nSel))
        {
            m_oblHeaders.RemoveIndex(nSel);
            m_list_Headers.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_Headers.SetCurSel(nCurSel);
        if (!SetControlStates())
        {
            //
            // Delete button will be disabled, move focus elsewhere
            //
            GetDlgItem(IDC_BUTTON_ADD)->SetFocus();
        }

        OnItemChanged();
    }
}



void
CW3HTTPPage::OnButtonEdit()
/*++

Routine Description:

    'edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        SetControlStates();
        OnItemChanged();
    }
}



void
CW3HTTPPage::OnCheckExpiration()
/*++

Routine Description:

    'expiration' checkbox

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableExpiration = !m_fEnableExpiration;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnSelchangeComboTime()
/*++

Routine Description:

    'selection change' in time combobox handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    OnItemChanged();
}



void 
CW3HTTPPage::OnSelchangeListHeaders()
/*++

Routine Description:

    'selection change' in headers listbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CW3HTTPPage::OnDblclkListHeaders()
/*++

Routine Description:

    'double click' in headers listbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CW3HTTPPage::OnRadioImmediately()
/*++

Routine Description:

    'immediate' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_IMMEDIATELY;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnRadioTime()
/*++

Routine Description:

    'expire' radio button

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_EXPIRE;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnRadioAbsTime()
/*++

Routine Description:

    'absolute expire' radio button

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_EXPIRE_ABS;
    SetControlStates();
    OnItemChanged();
}



BOOL
CW3HTTPPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_button_FileTypes.EnableWindow(m_ppropMimeTypes != NULL);
    m_list_Headers.Initialize();

    //
    // Fill combo box with (Minutes, hours, days)
    //
    CString str;
    VERIFY(str.LoadString(IDS_MINUTES));
    m_combo_Time.AddString(str);
    VERIFY(str.LoadString(IDS_HOURS));
    m_combo_Time.AddString(str);
    VERIFY(str.LoadString(IDS_DAYS));
    m_combo_Time.AddString(str);

    m_combo_Time.SetCurSel(m_nTimeSelector);

    //
    // Set the minimum of the date picker to today
    // and the maximum to Dec 31, 2035.
    //
    CTime m_tmNow(CTime::GetCurrentTime());
    CTime tmThen(2035, 12, 31, 23, 59, 59);
    m_dtpDate.SetRange(&m_tmNow, &tmThen);
    //
    // Create a hidden ratings OCX, which is activated by a press
    // on the ratings button.  We never did get our problems with
    // mnemonics straightened out so that we could use the ocx
    // directly.
    //
    m_ocx_Ratings.Create(_T("Rat"), WS_BORDER, CRect(0, 0, 0, 0), this, IDC_BUTTON_RATINGS);
	CComBSTR url;
	CIISMBNode * pNode = (CIISMBNode *)GetSheet()->GetParameter();
	pNode->BuildURL(url);
    m_ocx_Ratings.SetAdminTarget(QueryAuthInfo()->QueryServerName(), QueryMetaPath());
    m_ocx_Ratings.SetUserData(QueryAuthInfo()->QueryUserName(), QueryAuthInfo()->QueryPassword());
    m_ocx_Ratings.SetUrl(url);

    SetTimeFields();
    FetchHeaders();
    FillListBox();
    SetControlStates();

    if (m_fValuesAdjusted)
    {
        //
        // One or more input values was adjusted
        //
        OnItemChanged();
        m_fValuesAdjusted = FALSE;
    }

    return TRUE;
}



HRESULT
CW3HTTPPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 HTTP directory page now...");

    CError err;

    CString m_strExpiration;
    MakeExpirationString(m_strExpiration);

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_strExpiration)
        STORE_DIR_DATA_ON_SHEET(m_strlCustomHeaders)
    END_META_DIR_WRITE(err)

    if (err.Succeeded() && m_ppropMimeTypes)
    {
        m_ppropMimeTypes->m_strlMimeTypes = m_strlMimeTypes;
        err = m_ppropMimeTypes->WriteDirtyProps();
		if (err.Succeeded())
		{
			err = ((CW3Sheet *)GetSheet())->SetKeyType();
		}
    }
    EndWaitCursor();

    return err;
}


void
CW3HTTPPage::OnButtonFileTypes()
/*++

Routine Description:

    'file types' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CMimeDlg dlg(m_strlMimeTypes, this);
    if (dlg.DoModal() == IDOK)
    {
        OnItemChanged();
    }
}


void
CW3HTTPPage::OnButtonRatingsTemplate()
/*++

Routine Description:

    Pass on "ratings" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
	CError err;
	CString mpath = GetSheet()->QueryMetaPath();
	{
		CMetaKey mk(m_ppropMimeTypes->QueryAuthInfo(), METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_READ);
		err = mk.DoesPathExist(mpath);
	}
	BOOL key = err.Failed();
    m_ocx_Ratings.DoClick();
	if (key)
	{
		// User may cancel dialog, and path wasn't created
		CMetaKey mk(m_ppropMimeTypes->QueryAuthInfo(), METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_READ);
		err = mk.DoesPathExist(mpath);
		key = err.Succeeded();
	}
	// This is pretty annoying, but metabase should not be locked to set a key type
	if (key)
	{
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
		ASSERT(err.Succeeded());
	}
}




void 
CW3HTTPPage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();

    SAFE_DELETE(m_ppropMimeTypes);
}



BOOL 
CW3HTTPPage::OnNotify(
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT * pResult
    ) 
/*++

Routine Description:

    Handle notification changes

Arguments:

    WPARAM wParam           : Control ID
    LPARAM lParam           : NMHDR *
    LRESULT * pResult       : Result pointer

Return Value:

    TRUE if handled, FALSE if not

--*/
{
    //
    // Message cracker crashes - so checking this here instead
    //
    if (wParam == IDC_DTP_ABS_DATE || wParam == IDC_DTP_ABS_TIME)
    {
        NMHDR * pHdr = (NMHDR *)lParam;
        if (pHdr->code == DTN_DATETIMECHANGE)
        {
            OnItemChanged();
        }
    }
    
    //
    // Default behaviour -- go to the message map
    //
    return CInetPropertyPage::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iismachine.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        iismachine.cpp

   Abstract:

        IIS Machine node

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        10/28/2000      sergeia     Split from iisobj.cpp

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "metaback.h"
#include "iisobj.h"
#include "shutdown.h"
#include "machsht.h"
#include "w3sht.h"
#include "fltdlg.h"
#include "savedata.h"
#include "util.h"
#include "tracker.h"
#include "iishelp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

extern CPropertySheetTracker g_OpenPropertySheetTracker;
extern CWNetConnectionTrackerGlobal g_GlobalConnections;
extern CInetmgrApp theApp;
#if defined(_DEBUG) || DBG
	extern CDebug_IISObject g_Debug_IISObject;
#endif

extern DWORD g_dwInetmgrParamFlags;

DWORD WINAPI CIISMachine::GetProcessModeThread(LPVOID pInfo)
{
    CError err(ERROR_NOT_FOUND);
    GET_PROCESS_MODE_STRUCT * pMyStructOfInfo = (GET_PROCESS_MODE_STRUCT *) pInfo;

    // 
    // This thread needs its own CoInitialize
    //
    CoInitialize(NULL);

    // Do the work
    CIISAppPool pool(pMyStructOfInfo->pComAuthInfo, (LPCTSTR) _T("LM/W3SVC"));
    DWORD dwProcessMode = -1;
    pMyStructOfInfo->dwProcessMode = dwProcessMode;
    err = pool.GetProcessMode(&dwProcessMode);
    if (err.Succeeded())
    {
        pMyStructOfInfo->dwProcessMode = dwProcessMode;
    }

    pMyStructOfInfo->dwReturnStatus = err;
    return err;
}


BOOL CIISMachine::GetProcessMode(GET_PROCESS_MODE_STRUCT * pMyStructOfInfo)
{
    BOOL bReturn = FALSE;
    DWORD ThreadID = 0;
    DWORD status = 0;

    HANDLE hMyThread = ::CreateThread(NULL,0,GetProcessModeThread,pMyStructOfInfo,0,&ThreadID);
    if (hMyThread)
    {
        // wait for 10 secs only
        DWORD res = WaitForSingleObject(hMyThread,10*1000);
        if (res == WAIT_TIMEOUT)
        {
		    GetExitCodeThread(hMyThread, &status);
		    if (status == STILL_ACTIVE) 
            {
			    if (hMyThread != NULL)
                    {TerminateThread(hMyThread, 0);}
		    }
        }
        else
        {
            GetExitCodeThread(hMyThread, &status);
		    if (status == STILL_ACTIVE) 
            {
			    if (hMyThread != NULL)
                    {TerminateThread(hMyThread, 0);}
		    }
            else
            {
                if (ERROR_SUCCESS == status)
                   {
                       bReturn = TRUE;
                   }
            }

            if (hMyThread != NULL)
                {CloseHandle(hMyThread);}
        }
    }
    return bReturn;
}


/* static */ LPOLESTR CIISMachine::_cszNodeName = _T("LM");
/* static */ CComBSTR CIISMachine::_bstrYes;
/* static */ CComBSTR CIISMachine::_bstrNo;
/* static */ CComBSTR CIISMachine::_bstrVersionFmt;
/* static */ BOOL     CIISMachine::_fStaticsLoaded = FALSE;

//
// Define result view for machine objects
//
/* static */ int CIISMachine::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_COMPUTER_NAME,
    IDS_RESULT_COMPUTER_LOCAL,
    IDS_RESULT_COMPUTER_VERSION,
    IDS_RESULT_STATUS,
};
    


/* static */ int CIISMachine::_rgnWidths[COL_TOTAL] =
{
    200,
    50,
    //100,
    150,
    200,
};



/* static */
void
CIISMachine::InitializeHeaders(
    LPHEADERCTRL lpHeader
    )
{
    BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);

    if (!_fStaticsLoaded)
    {
        _fStaticsLoaded =
            _bstrYes.LoadString(IDS_YES)                      &&
            _bstrNo.LoadString(IDS_NO)                        &&
            _bstrVersionFmt.LoadString(IDS_VERSION_FMT);
    }
}

/* virtual */
void 
CIISMachine::InitializeChildHeaders(
    LPHEADERCTRL lpHeader
    )
{
    CIISService::InitializeHeaders(lpHeader);
}

/* static */
HRESULT
CIISMachine::VerifyMachine(
    CIISMachine *& pMachine
    )
/*++

Routine Description:

    Create the interface on the given machine object.

Arguments:

    CIISMachine *& pMachine         : Machine object
    BOOL fAskBeforeRedirecting

Return Value:

    HRESULT

Notes:

    THe CIISMachine object pass in may refer to the cluster master
    on return.

--*/
{
    CError err;

    if (pMachine)
    {
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());

        CWaitCursor wait;

        //
        // Attempt to create the interface to ensure the machine
        // contains a metabase.  
        //
        err = pMachine->CreateInterface(FALSE); 
    }

    return err;
}


CIISMachine::CIISMachine(
    IConsoleNameSpace * pConsoleNameSpace,
    IConsole * pConsole,
    CComAuthInfo * pAuthInfo,
    CIISRoot * pRoot
    )
    : m_pInterface(NULL),
      m_bstrDisplayName(NULL),
      m_auth(pAuthInfo),
      m_pRootExt(pRoot),
      m_err(),
      //
      // By default we assume the password is entered.
      // If this machine object is constructed from the
      // cache, it will get reset by InitializeFromStream()
      //
      m_fPasswordEntered(TRUE),
      m_dwVersion(MAKELONG(5, 0)),       // Assume as a default
      m_pAppPoolsContainer(NULL),
      m_pWebServiceExtensionContainer(NULL),
      CIISMBNode(this, _cszNodeName),
	  m_MachineWNetConnections(&g_GlobalConnections)
{
    //
    // Load one-liner error messages
    //
    SetErrorOverrides(m_err, TRUE);
    SetDisplayName();

    SetConsoleData(pConsoleNameSpace,pConsole);

    m_fIsLocalHostIP = FALSE;
    m_fLocalHostIPChecked = FALSE;
}



CIISMachine::~CIISMachine()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_bstrDisplayName)
    {
        ::SysFreeString(m_bstrDisplayName);
    }

	// Disconnect all connections made from this iismachine.
	m_MachineWNetConnections.Clear();

    SAFE_DELETE(m_pInterface);
}



/* static */
HRESULT 
CIISMachine::ReadFromStream(
    IStream * pStream,
    CIISMachine ** ppMachine,
    IConsoleNameSpace * pConsoleNameSpace,
    IConsole * pConsole
    )
/*++

Routine Description:

    Static helper function to allocate a new CIISMachine object read
    from the storage stream.

Arguments:

    IStream * pStream           : Stream to read from
    CIISMachine ** ppMachine    : Returns CIISMachine object

Return Value:

    HRESULT

--*/
{
    CComBSTR strMachine, strUser;

    ASSERT_WRITE_PTR(ppMachine);
    ASSERT_READ_WRITE_PTR(pStream);

    CError  err;
    *ppMachine = NULL;
    
    do
    {
        err = strMachine.ReadFromStream(pStream);
        BREAK_ON_ERR_FAILURE(err);
        err = strUser.ReadFromStream(pStream);
        BREAK_ON_ERR_FAILURE(err);

        *ppMachine = new CIISMachine(pConsoleNameSpace,pConsole,CComAuthInfo(strMachine, strUser));

        if (!*ppMachine)
        {   
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = (*ppMachine)->InitializeFromStream(pStream);
    }
    while(FALSE);

    return err;
}



HRESULT 
CIISMachine::WriteToStream(
    IStream * pStgSave
    )
/*++

Routine Description:

    Write machine information to stream.

Arguments:

    IStream * pStgSave      : Open stream

Return Value:

    HRESULT

Notes:

    Be sure to keep this information in sync with CIISMachine::InitializeFromStream()

--*/
{
    ASSERT_READ_WRITE_PTR(pStgSave);

    CComBSTR bstrServerName(m_auth.QueryServerName());
    CComBSTR bstrUserName(m_auth.QueryUserName());

    CError  err;
    ULONG   cb;
    
    do
    {
        err = bstrServerName.WriteToStream(pStgSave);
        BREAK_ON_ERR_FAILURE(err);
        err = bstrUserName.WriteToStream(pStgSave);
        BREAK_ON_ERR_FAILURE(err);

        //
        // Now cache the dynamically-generated information, such
        // as version number, snapin status etc. This will be
        // displayed in the result view before the interface is
        // created.
        //
        err = pStgSave->Write(&m_dwVersion, sizeof(m_dwVersion), &cb);
        BREAK_ON_ERR_FAILURE(err);
    }
    while(FALSE);

    return err;
}



HRESULT
CIISMachine::InitializeFromStream(
    IStream * pStream
    )
/*++

Routine Description:

    Read version number and other cached parameters that will
    be overridden at runtime when the interface is created.
    This is cached, because it's required before the interface
    is created.

Arguments:
    
    IStream * pStream      : Open stream

Return Value:

    HRESULT

Notes:

    Be sure to keep this information in sync with CIISMachine::WriteToStream()

--*/
{
    ASSERT_READ_PTR(pStream);

    CError  err;
    ULONG   cb;

    //
    // Passwords are never cached.  IIS status will
    // always be verified when the actual interface
    // is created.
    //
    m_fPasswordEntered = FALSE;

    //
    // Version number
    //
    err = pStream->Read(&m_dwVersion, sizeof(m_dwVersion), &cb);
    return err;
}



void
CIISMachine::SetDisplayName()
/*++

Routine Description:

    Create a special display name for this machine object if it's
    either the local machine, or 

--*/
{
    CString fmt;

    if (IsLocal())
    {
        //
        // Use the local computer name, and not the name
        // that's on the server object, because that could
        // be and ip address or "localhost".
        //
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        VERIFY(::GetComputerName(szLocalServer, &dwSize));
        fmt.Format(IDS_LOCAL_COMPUTER, szLocalServer);
    }
    else
    {
        //
        // No special display name necessary
        //
        m_bstrDisplayName = NULL;
        return;
    }

    m_bstrDisplayName = ::SysAllocStringLen(fmt, fmt.GetLength());
    TRACEEOLID("Machine display name: " << m_bstrDisplayName);
}



LPOLESTR 
CIISMachine::QueryDisplayName()
/*++

Routine Description:

    Get the display name for the machine/cluster object

Arguments:

    None

Return Value:

    Display Name

--*/
{ 
    if (m_pRootExt != NULL)
        return m_pRootExt->QueryDisplayName();
    else
        return  m_bstrDisplayName ? m_bstrDisplayName : QueryServerName(); 
}



int 
CIISMachine::QueryImage() const 
/*++

Routine Description:

    Return machine bitmap index appropriate for the current
    state of this machine object.

Arguments:

    None

Return Value:

    Bitmap index

--*/
{
    if (m_pRootExt != NULL)
    {
        return m_pRootExt->QueryImage();
    }
    else
    {
        if (m_err.Failed())
        {
			return IsLocal() ? iLocalMachineErr : iMachineErr;
        }
		else
		{
			return IsLocal() ? iLocalMachine : iMachine;
		}
    }
}



HRESULT
CIISMachine::CreateInterface(
    BOOL fShowError
    )
/*++

Routine Description:

    Create the interface.  If the interface is already created, recreate it.

Arguments:

    BOOL fShowError     : TRUE to display error messages

Return Value:

    HRESULT

Notes:

    This function is deliberately NOT called from the constructor for performance
    reasons.

--*/
{
    CError err;
	BOOL bHasInterface = FALSE;

	bHasInterface = HasInterface();
    if (bHasInterface)
    {
        //
        // Recreate the interface (this should re-use the impersonation)
        //
        TRACEEOLID("Warning: Rebinding existing interface.");
        err = m_pInterface->Regenerate();
    }
    else
    {
        //
        // Create new interface
        //
        m_pInterface = new CMetaKey(&m_auth);
        err = m_pInterface 
            ? m_pInterface->QueryResult() 
            : ERROR_NOT_ENOUGH_MEMORY;
    }

    if (err.Succeeded())
    {

        //
        // Load its display parameters
        //
        err = RefreshData();
		if (bHasInterface)
		{
			// Do extra stuff if we regenerated an existing interface...
		}

        CMetabasePath path;
        err = DetermineIfAdministrator(
            m_pInterface, 
            path,
            &m_fIsAdministrator,
            &m_dwMetabaseSystemChangeNumber
            );

        // Set the latest system change number.
        RefreshMetabaseSystemChangeNumber();
    }

    if (err.Failed())
    {
        if (fShowError)
        {
			CWnd * pWnd = GetMainWindow(GetConsole());
			DisplayError(err,pWnd ? pWnd->m_hWnd : NULL);
        }

        //
        // Kill bogus interface
        //
        SAFE_DELETE(m_pInterface);
    }

    return err;
}


/* virtual */
int 
CIISMachine::CompareScopeItem(
    CIISObject * pObject
    )
/*++

Routine Description:

    Compare against another CIISMachine object.

Arguments:

    CIISObject * pObject : Object to compare against

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // pObject is a CIISMachine object (same sortweight)
    //
    CIISMachine * pMachine = (CIISMachine *)pObject;

    //
    // Next sort on local key (local sorts before non-local)
    //
    n1 = IsLocal() ? 0 : 1;
    n2 = pMachine->IsLocal() ? 0 : 1;

    if (n1 != n2)
    {
        return n1 - n2;
    }

    if (!n1 && !n2)
    {
        //
        // This is the local machine, even if the name is different
        //
        return 0;
    }

    //
    // Else sort on name.
    //
    return _tcsicmp(QueryServerName(), pMachine->QueryServerName());
}



BOOL
CIISMachine::SetCacheDirty()
/*++

Routine Description:

    Set the cache as dirty

Arguments:

    None

Return Value:

    TRUE for success, FALSE if the cache was not found

--*/
{
    ASSERT(m_pRootExt == NULL);
    //
    // Cache is stored at the root object
    //
    CIISRoot * pRoot = GetRoot();

    ASSERT_PTR(pRoot);

    if (pRoot)
    {
        pRoot->m_scServers.SetDirty();
        return TRUE;
    }

    return FALSE;
}



int
CIISMachine::ResolvePasswordFromCache()
/*++

Routine Description:

    Look through the machine cache for machines with the same username
    as this object.  If they have a password entered, grab it.

Arguments:

    None

Return Value:

    TRUE if a machine with the same username was found whose password
    we stole.  FALSE otherwise.

--*/
{
    BOOL fUpdated = FALSE;

    //
    // Doesn't make sense if this machine object doesn't use impersonation
    // or already has a password.
    //
    ASSERT(UsesImpersonation() && !PasswordEntered());

    CIISRoot * pRoot = GetRoot();

    ASSERT_PTR(pRoot);

    if (pRoot)
    {
        CIISMachine * pMachine = pRoot->m_scServers.GetFirst();

        while(pMachine)
        {
            if (pMachine->UsesImpersonation() && pMachine->PasswordEntered())
            {
                if (!_tcsicmp(QueryUserName(), pMachine->QueryUserName()))
                {
                    TRACEEOLID("Swiping cached password from " << pMachine->QueryServerName());
                    StorePassword(pMachine->QueryPassword());
                    ++fUpdated;
                    break;
                }
            }

            pMachine = pRoot->m_scServers.GetNext();
        }
    }

    return fUpdated;
}



HRESULT
CIISMachine::Impersonate(
    LPCTSTR szUserName,
    LPCTSTR szPassword
    )
/*++

Routine Description:

    Set and store proxy blanket security information.  Store username/password
    for use by metaback and other interfaces.

Arguments:

    LPCTSTR szUserName  : Username (domain\username)
    LPCTSTR szPassword  : Password

Return Value:

    None

--*/
{
    ASSERT_READ_PTR(szUserName);
    CError err;

    if (m_pInterface)
    {
        //
        // Already have an interface created; Change the 
        // the security blanket.
        //
        err = m_pInterface->ChangeProxyBlanket(szUserName, szPassword);
    }

    if (err.Succeeded())
    {
        //
        // Store new username/password
        //
        m_auth.SetImpersonation(szUserName, szPassword);
        m_fPasswordEntered = TRUE;
    }

    return err;
}



void 
CIISMachine::RemoveImpersonation() 
/*++

Routine Description:

    Remove impersonation parameters.  Destroy any existing interface.

Arguments:

    None

Return Value:

    N/A

--*/
{ 
    m_auth.RemoveImpersonation(); 
    m_fPasswordEntered = FALSE;

    SAFE_DELETE(m_pInterface);
}



void
CIISMachine::StorePassword(
    LPCTSTR szPassword
    )
/*++

Routine Description:

    Store password.

Arguments:

    LPCTSTR szPassword  : Password

Return Value:

    None

--*/
{
    ASSERT_READ_PTR(szPassword);
    m_auth.StorePassword(szPassword);
    m_fPasswordEntered = TRUE;
}



BOOL
CIISMachine::ResolveCredentials()
/*++

Routine Description:

    If this machine object uses impersonation, but hasn't entered a password
    yet, check to see if there are any other machines in the cache with the
    same username and grab its password.  If not, prompt the user for it.

Arguments:

    None

Return Value:

    TRUE if a password was entered.  FALSE otherwise.

--*/
{
    BOOL fPasswordEntered = FALSE;

    if (UsesImpersonation() && !PasswordEntered())
    {
        //
        // Attempt to find the password from the cache
        //
        if (!ResolvePasswordFromCache())
        {
            //
            // Didn't find the password in the cache.  Prompt
            // the user for it.
            //
            CLoginDlg dlg(LDLG_ENTER_PASS, this, GetMainWindow(GetConsole()));
            if (dlg.DoModal() == IDOK)
            {
                fPasswordEntered = TRUE;

                if (dlg.UserNameChanged())
                {
                    //
                    // User name has changed -- remember to
                    // save the machine cache later.
                    //
                    SetCacheDirty();
                }
            }
            else
            {
                //
                // Pressing cancel on this dialog means the user
                // wants to stop using impersonation. 
                //
                RemoveImpersonation();
                SetCacheDirty();
            }
        }
    }

    return fPasswordEntered;
}



BOOL
CIISMachine::HandleAccessDenied(
    CError & err
    )
/*++

Routine Description:

    After calling interface method, pass the error object to this function
    to handle the access denied case.  If the error is access denied,
    give the user a chance to change credentials.  Since we assume an
    attempt has been made to create an interface at least -- the interface
    will be recreated with the new credentials.

Arguments:

    CError & err    : Error object.  Checked for ACCESS_DENIED on entry,
                      will contain new error code on exit if the interface
                      was recreated.

Return Value:

    TRUE if new credentials were applied

--*/
{
    BOOL fPasswordEntered = FALSE;

    //
    // If access denied occurs here -- give another chance
    // at entering the password.
    //
    if (err.Win32Error() == ERROR_ACCESS_DENIED)
    {
        CLoginDlg dlg(LDLG_ACCESS_DENIED, this, GetMainWindow(GetConsole()));
        if (dlg.DoModal() == IDOK)
        {
            fPasswordEntered = TRUE;
            err.Reset();

            if (!HasInterface())
            {
                //
                // If we already had an interface, the login dialog
                // will have applied the new security blanket.
                // If we didn't have an interface, it needs to be
                // recreated with the new security blanket.
                //
                CWaitCursor wait;
                err = CreateInterface(FALSE);
            }
        }
    }

    return fPasswordEntered;
}



HRESULT
CIISMachine::CheckCapabilities()
/*++

Routine Description:

    Load the capabilities information for this server.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err = AssureInterfaceCreated(TRUE);
	if (err.Succeeded())
	{
		//
		// Fetch capability bits and version numbers.
		//
		CString strMDInfo;
		CMetabasePath::GetServiceInfoPath(_T(""), strMDInfo,SZ_MBN_WEB);

		//
		// Reuse existing interface we have lying around.
		//
		CMetaKey mk(m_pInterface);
		err = mk.QueryResult();
		if (err.Succeeded())
		{
			if (FAILED(mk.DoesPathExist(strMDInfo)))
			{
				CMetabasePath::GetServiceInfoPath(_T(""),strMDInfo,SZ_MBN_FTP);
				if (FAILED(mk.DoesPathExist(strMDInfo)))
				{       
                    CMetabasePath::GetServiceInfoPath(_T(""),strMDInfo,SZ_MBN_SMTP);
                    if (FAILED(mk.DoesPathExist(strMDInfo)))
                    {
                            CMetabasePath::GetServiceInfoPath(_T(""),strMDInfo,SZ_MBN_NNTP);
                            if (FAILED(mk.DoesPathExist(strMDInfo)))
                            {
                                TRACEEOLID("No services exist:W3SVC,MSFTPSVC,SMTPSVC,NNTPSVC");
                            }
                    }
				}
			}
		}
				
        //if (m_pInterface)
        {
		    CServerCapabilities sc(m_pInterface, strMDInfo);
		    err = sc.LoadData();
		    if (err.Succeeded())
		    {
			    DWORD dwVersion = sc.QueryMajorVersion();
			    if (dwVersion)
			    {
				    m_dwVersion = dwVersion | (sc.QueryMinorVersion() << SIZE_IN_BITS(WORD));
			    }
			    m_fCanAddInstance = sc.HasMultipleSites();
			    m_fHas10ConnectionsLimit = sc.Has10ConnectionLimit();
				m_fIsWorkstation = sc.IsWorkstation();
				m_fIsPerformanceConfigurable = sc.IsPerformanceConfigurable();
				m_fIsServiceLevelConfigurable = sc.IsServiceLevelConfigurable();
		    }
        }
	}
    return err;
}



/* virtual */
HRESULT 
CIISMachine::RefreshData()
/*++

Routine Description:

    Refresh relevant configuration data required for display.

Arguments:

    None

Return Value:

    HRESULT

--*/
{ 
    CError err;
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();

    // Check if we have a valid connection to the metabase
    err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METADATA_MASTER_ROOT_HANDLE);
	if (err.Succeeded())
    {
        //
        // Check capability and version information.
        //
        err  = CheckCapabilities();
        SetDisplayName();
        if (err.Succeeded())
        {
	        // check if we should be showing the App Pools node...
	        if (QueryMajorVersion() >= 6)
	        {
		        BOOL fCompatMode = FALSE;

		        CMetabasePath path(TRUE, SZ_MBN_WEB);
		        CMetaKey mk(QueryAuthInfo(), path, METADATA_PERMISSION_READ);
		        err = mk.QueryResult();
		        if (err.Succeeded())
		        {
			        err = mk.QueryValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, fCompatMode);
		        }
		        // If we fail here, then we have no Web service or no standard mode property defined
		        // That means that we are either not in standard mode or it doesn't matter
		        err.Reset();

		        // Loop thru the scope items to see what we actually have displayed...
		        CIISMBNode * pBadGuy = NULL;
		        CIISService * pWebService = NULL;

		        HSCOPEITEM hChild = NULL, hCurrent;
		        LONG_PTR cookie = 0;
		        BOOL bAppPoolsNodeExists = FALSE;
                HSCOPEITEM hScope = QueryScopeItem();
                if (hScope)
                {
		            HRESULT hr = pConsoleNameSpace->GetChildItem(hScope, &hChild, &cookie);
		            while (SUCCEEDED(hr) && hChild != NULL)
		            {
			            CIISMBNode * pNode = (CIISMBNode *)cookie;

			            if (IsEqualGUID(* (GUID *)pNode->GetNodeType(),cAppPoolsNode))
			            {
				            pBadGuy = pNode;
				            bAppPoolsNodeExists = TRUE;
				            // Check if the Application Node container exists...
				            // if it does, then make sure we're in the right mode.
			            }
			            else
			            {
				            if (0 == _tcsicmp(pNode->GetNodeName(), SZ_MBN_WEB))
				            {
					            pWebService = (CIISService *) pNode;
				            }
			            }

			            hCurrent = hChild;
			            hr = pConsoleNameSpace->GetNextItem(hCurrent, &hChild, &cookie);
		            }

					if (pWebService)
					{
                        // do this check only if we have a W3SVC service
                        // that's because if the user only installed FTP
                        // we won't have the interface required for AppPool (WAM interface)
                        // and this may potential AV!!!!
                        //
                        // Find out what mode IIS is R-E-A-L-L-Y running as...
                        GET_PROCESS_MODE_STRUCT MyStructOfInfo;
                        MyStructOfInfo.pComAuthInfo = QueryAuthInfo();
                        MyStructOfInfo.dwReturnStatus = 0;
                        MyStructOfInfo.dwProcessMode = -1;
                        if (GetProcessMode(&MyStructOfInfo))
                        {
                            // We got it back in time (no timeout)
                            if (-1 != MyStructOfInfo.dwProcessMode)
                            {
                                fCompatMode = FALSE;
                                if (0 == MyStructOfInfo.dwProcessMode)
                                {
                                    fCompatMode = TRUE;
                                }
                                TRACEEOLID("GetProcessMode:" << MyStructOfInfo.dwProcessMode);
                            }
                        }
                        else
                        {
                            // Leave it at whatever we got from the metabase...
                        }
					}

		            // fCompatMode = 1 means there should be No App Pools (bAppPoolsNodeExists should be 0)
		            // fCompatMode = 0 means there should be App Pools (bAppPoolsNodeExists should be 1)
                    TRACEEOLID("fCompatMode:" << fCompatMode);
	                if (fCompatMode == bAppPoolsNodeExists)
		            {
			            if (fCompatMode && bAppPoolsNodeExists)
			            {
				            // find it and delete it.
				            if (pBadGuy->IsMyPropertySheetOpen())
				            {
					            // don't remove it if the property sheet is open on it.
				            }
				            else
				            {
					            pBadGuy->RemoveScopeItem();
				            }
			            }
			            else if (!fCompatMode && !bAppPoolsNodeExists)
			            {
				            if (pWebService)
				            {
                                m_pAppPoolsContainer = NULL;
					            CAppPoolsContainer * pPools = new CAppPoolsContainer(this, pWebService);
					            if (pPools)
					            {
						            // Insert pools container before Web Services node
						            pPools->AddRef();
						            pPools->AddToScopePane(pWebService->QueryScopeItem(), FALSE, TRUE);
                                    m_pAppPoolsContainer = pPools;
					            }
				            }
			            }
		            }
                }
	        }
        }
    }

#if defined(_DEBUG) || DBG	
	//DumpAllScopeItems(pConsoleNameSpace,m_hScopeItem,0);
#endif
    return err;
}



/* virtual */
void 
CIISMachine::SetInterfaceError(
    HRESULT hr
    )
/*++

Routine Description:

    Set the interface error.  If different from current error,
    change the display icon

Arguments:

    HRESULT hr      : Error code (S_OK is acceptable)

Return Value:

    None

--*/
{
    if (m_err.HResult() != hr)
    {
        //
        // Change to error/machine icon for the parent machine.
        //
        m_err = hr;
        RefreshDisplay();
    }
}



/* virtual */
HRESULT
CIISMachine::BuildMetaPath(
    CComBSTR & bstrPath
    ) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents

Arguments:

    CComBSTR & bstrPath : Returns metabase path

Return Value:

    HRESULT

--*/
{
    //
    // This starts off the path
    //
    bstrPath.Append(_cszSeparator);
    bstrPath.Append(QueryNodeName());

    return S_OK;
}


/* virtual */
HRESULT 
CIISMachine::BuildURL(
    CComBSTR & bstrURL
    ) const
/*++

Routine Description:

    Recursively build up the URL from the current node
    and its parents.  The URL built up from a machine node
    doesn't make a lot of sense, but for want of anything better,
    this will bring up the default web site.

Arguments:

    CComBSTR & bstrURL : Returns URL

Return Value:

    HRESULT

--*/
{
    CString strOwner;

    if (IsLocal())
    {
        //
        // Security reasons restrict this to "localhost" oftentimes
        //
        strOwner = _bstrLocalHost;
    }
    else
    {
        LPOLESTR lpOwner = QueryMachineName();
        strOwner = PURE_COMPUTER_NAME(lpOwner);
    }

    //
    // An URL on the machine node is built in isolation.
    //
    // ISSUE: Is this really a desirable URL?  Maybe we should
    //        use something else.
    //
    bstrURL = _T("http://");
    bstrURL.Append(strOwner);

    return S_OK;
}


/* virtual */
HRESULT
CIISMachine::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CError  err;

	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }
	if (err.Succeeded())
	{
		CComBSTR bstrPath;
		//
		// ISSUE: What to do with m_err?  This might be 
		// a bad machine object in the first place.  Aborting
		// when the machine object has an error code isn't 
		// such a bad solution here.  If the error condition
		// no longer exists, a refresh will cure.
		//
		if (m_err.Failed())
		{
			m_err.MessageBox();
			return m_err;
		}

		err = BuildMetaPath(bstrPath);
		if (err.Succeeded())
		{
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
            if (err.Succeeded())
            {
			    CIISMachineSheet * pSheet = new CIISMachineSheet(
				    QueryAuthInfo(), bstrPath, GetMainWindow(GetConsole()),
				    (LPARAM)this,(LPARAM) NULL
				    );

			    if (pSheet)
			    {
                    // cache handle for user in MMCPropertyChangeNotify
                    m_ppHandle = handle;

				    pSheet->SetModeless();
				    err = AddMMCPage(lpProvider, new CIISMachinePage(pSheet));
			    }
			    else
			    {
				    err = ERROR_NOT_ENOUGH_MEMORY;
			    }
            }
		}
	}
    err.MessageBoxOnFailure();
    return err;
}



/* virtual */
HRESULT 
CIISMachine::EnumerateScopePane(
    HSCOPEITEM hParent
    )
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    ASSERT(m_hScopeItem == hParent);

    CError err;
    CString str;
    CIISService * pService, * pWebService = NULL;

    CWaitCursor wait;
    CMetaEnumerator * pme = NULL;

	if (IsExpanded())
	{
		//
		// Verify user credentials are satisfactorily resolved.
		// Machines objects are loaded from the cache without a
		// password, so the function below will ask for it.
		//
		ResolveCredentials();
		wait.Restore();    

		BOOL fShouldRefresh = !HasInterface();
        BOOL fCompatMode = FALSE;
		err = AssureInterfaceCreated(FALSE);

        if (err.Succeeded() && QueryMajorVersion() >= 6)
        {
            CMetabasePath path(TRUE, SZ_MBN_WEB);
            CMetaKey mk(QueryAuthInfo(), path, METADATA_PERMISSION_READ);
            err = mk.QueryResult();
            if (err.Succeeded())
            {
                err = mk.QueryValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, fCompatMode);
            }
            // If we fail here, then we have no Web service or no standard mode property defined
            // That means that we are either not in standard mode or it doesn't matter
            err.Reset();
        }

		if (err.Succeeded())
		{
			//
			// Creation of the interface will have loaded display parameters, which
			// may differ from the cached parameters.
			//
			if (fShouldRefresh)
			{
				RefreshDisplay();
			}

			err = CreateEnumerator(pme);
		}

		//
		// Only check for acces denied now, because virtually any idiot
		// is allowed to create a metabase interface, but will get the
		// access denied when calling a method, such as enumeration.
		//
		if (HandleAccessDenied(err))
		{
			wait.Restore();

			//
			// Credentials were changed.  Try again (interface should be
			// created already)
			//
			SAFE_DELETE(pme);

			if (err.Succeeded())
			{
				err = RefreshData();
				CMetabasePath path;
				err = DetermineIfAdministrator(
					m_pInterface, 
					path,
					&m_fIsAdministrator,
					&m_dwMetabaseSystemChangeNumber
				);

				// Set the latest system change number.
				RefreshMetabaseSystemChangeNumber();
				err = CreateEnumerator(pme);
			}
		}

		//
		// Enumerate administerable services from the metabase
		//
		while (err.Succeeded())
		{
			err = pme->Next(str);

			if (err.Succeeded())
			{
				TRACEEOLID("Enumerating node: " << str);
				pService = new CIISService(this, str);        

				if (!pService)
				{
					err = ERROR_NOT_ENOUGH_MEMORY;
					break;
				}

				//
				// See if we care
				//
				if (pService->IsManagedService())
				{
					pService->AddRef();
					// update the service state
					pService->GetServiceState();
					err = pService->AddToScopePane(hParent);
					if (err.Succeeded())
					{
						if (0 == _tcsicmp(pService->GetNodeName(), SZ_MBN_WEB))
						{
						   pWebService = pService;
						}
					}
                    else
                    {
                        pService->Release();
                    }
				}
				else
				{
					//
					// Node is not a managed service, or we're managing the 
					// cluster and the service is not clustered.
					//
					pService->Release();
				}
			}
		}
    
		if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
		{
			err.Reset();
		}

	    if (pWebService)
	    {
            // do this check only if we have a W3SVC service
            // that's because if the user only installed FTP
            // we won't have the interface required for AppPool (WAM interface)
            // and this may potential AV!!!!
            //
            // Find out what mode IIS is R-E-A-L-L-Y running as...
            GET_PROCESS_MODE_STRUCT MyStructOfInfo;
            MyStructOfInfo.pComAuthInfo = QueryAuthInfo();
            MyStructOfInfo.dwReturnStatus = 0;
            MyStructOfInfo.dwProcessMode = -1;
            if (GetProcessMode(&MyStructOfInfo))
            {
                // We got it back in time (no timeout)
                if (-1 != MyStructOfInfo.dwProcessMode)
                {
                    fCompatMode = FALSE;
                    if (0 == MyStructOfInfo.dwProcessMode)
                    {
                        fCompatMode = TRUE;
                    }
                    TRACEEOLID("GetProcessMode:" << MyStructOfInfo.dwProcessMode);
                }
            }
            else
            {
                // Leave it at whatever we got from the metabase...
            }
	    }

		// If we are encountered web service, we should add 
		// Application Pools container before this service
		//
        m_pAppPoolsContainer = NULL;
		if (err.Succeeded() && pWebService != NULL && !fCompatMode)
		{
			// We could have iis5 machine which doesn't have any pools
			//
            CMetabasePath path(TRUE, SZ_MBN_WEB, SZ_MBN_APP_POOLS);
			CMetaKey mk(pme, path);
			if (mk.Succeeded())
			{
				CAppPoolsContainer * pPools = new CAppPoolsContainer(
					this, pWebService);
				if (!pPools)
				{
					err = ERROR_NOT_ENOUGH_MEMORY;
					goto Fail;
				}
				// Insert pools container before Web Services node
                pPools->AddRef();
				err = pPools->AddToScopePane(pWebService->QueryScopeItem(), FALSE, TRUE);
                m_pAppPoolsContainer = pPools;
			}
		}

		// If we are encountered web service, we should add 
		// this container before after the web service
		//
        m_pWebServiceExtensionContainer = NULL;
		if (err.Succeeded() && pWebService != NULL)
		{
            if (QueryMajorVersion() >= 6)
            {
			    // We could have iis5 machine which doesn't have any extensions
				CWebServiceExtensionContainer * pNode = new CWebServiceExtensionContainer(this, pWebService);
				if (!pNode)
				{
					err = ERROR_NOT_ENOUGH_MEMORY;
					goto Fail;
				}
				// Insert container AFTER Web Services node
                pNode->AddRef();
				err = pNode->AddToScopePane(pWebService->QueryScopeItem(), FALSE, FALSE);
                m_pWebServiceExtensionContainer = pNode;
            }
		}

	Fail:
		if (err.Failed())
		{
			CWnd * pWnd = GetMainWindow(GetConsole());
			DisplayError(err,pWnd ? pWnd->m_hWnd : NULL);
		}

		SetInterfaceError(err);   

		//
		// Clean up
		//
		SAFE_DELETE(pme);
	}
    return err;
}



/* virtual */
HRESULT 
CIISMachine::RemoveScopeItem()
/*++

Routine Description:

    Remove the machine from the scope view and the cache.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(m_pRootExt == NULL);
    //
    // Find out root before deleting scope node
    //
    CIISRoot * pRoot = GetRoot();
    ASSERT_PTR(pRoot);
    //
    // Remove from the tree
    //

#if defined(_DEBUG) || DBG	
    // check if we have open property pages...
    g_OpenPropertySheetTracker.Dump();

	// dump out any open connections
    m_MachineWNetConnections.Dump();
#endif

    HRESULT hr = CIISMBNode::RemoveScopeItem();
    if (SUCCEEDED(hr) && pRoot)
    {
		// Disconnect all connections made from this iismachine.
		m_MachineWNetConnections.Clear();

        pRoot->m_scServers.Remove(this);

#if defined(_DEBUG) || DBG	
	// check if we leaked anything.
	g_Debug_IISObject.Dump(2);
#endif

    }

    return hr;
}

HRESULT
CIISMachine::DeleteChildObjects(HSCOPEITEM hItem)
{
	CMetaInterface * pInterface = QueryInterface();
	if (pInterface)
	{
		pInterface->SaveData();
	}
    
    return CIISMBNode::DeleteChildObjects(hItem);
}

BOOL
CIISMachine::IsLocalHost()
{
    if (FALSE == m_fLocalHostIPChecked)
    {
        BOOL bIsLocalHost = FALSE;
        LPOLESTR lpOwner = QueryMachineName();
        CString strCleanName;
        strCleanName = PURE_COMPUTER_NAME(lpOwner);

        // Check if MachineName is mapped to 127.0.0.1 or localhost...
        // if the machine specified
        // is not the local machine...
        if (!::IsLocalHost(strCleanName,&bIsLocalHost))
        {
            // WinSockFailure
        }
        m_fIsLocalHostIP = bIsLocalHost;
        m_fLocalHostIPChecked = TRUE;
    }
    return m_fIsLocalHostIP;
}

/* virtual */
LPOLESTR 
CIISMachine::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    if (m_pRootExt != NULL)
    {
        return m_pRootExt->GetResultPaneColInfo(nCol);
    }

    ASSERT(_fStaticsLoaded);

    switch(nCol)
    {
    case COL_NAME:
        return QueryDisplayName();
    
    case COL_LOCAL: 
        return IsLocalHost() ? _bstrYes : _bstrNo;

    case COL_VERSION:
        {
            CString str;

            str.Format(_bstrVersionFmt, QueryMajorVersion(), QueryMinorVersion());
            _bstrResult = str;

        }
        return _bstrResult;

    case COL_STATUS:
        {
            if (m_err.Succeeded())
            {
                return OLESTR("");
            }

            AFX_MANAGE_STATE(::AfxGetStaticModuleState());

            return m_err;
        }
    }

    ASSERT_MSG("Bad column number");

    return OLESTR("");
}


/* virtual */
HRESULT
CIISMachine::GetResultViewType(
    LPOLESTR * lplpViewType,
    long * lpViewOptions
    )
/*++

Routine Description:

    If we have an URL built up, display our result view as that URL,
    and destroy it.  This is done when 'browsing' a metabase node.
    The derived class will build the URL, and reselect the node.

Arguments:

    BSTR * lplpViewType   : Return view type here
    long * lpViewOptions  : View options

Return Value:

    S_FALSE to use default view type, S_OK indicates the
    view type is returned in *ppViewType

--*/
{

    if (m_bstrURL.Length())
    {
        *lpViewOptions = MMC_VIEW_OPTIONS_NONE;
        *lplpViewType  = (LPOLESTR)::CoTaskMemAlloc(
            (m_bstrURL.Length() + 1) * sizeof(WCHAR)
            );

        if (*lplpViewType)
        {
            lstrcpy(*lplpViewType, m_bstrURL);

            //
            // Destroy URL so we get a normal result view next time
            //
            m_bstrURL.Empty();
			m_fSkipEnumResult = TRUE;
            return S_OK;
        }

        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);    
    }

    //
    // No URL waiting -- use standard result view
    //
    return CIISObject::GetResultViewType(lplpViewType, lpViewOptions);
}


/* virtual */
HRESULT
CIISMachine::AddMenuItems(
    LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Add menu items to the context menu

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Context menu callback
    long * pInsertionAllowed                    : Insertion allowed
    DATA_OBJECT_TYPES type                      : Object type

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_PTR(lpContextMenuCallback);
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr))
    {
       if (IsAdministrator() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuItemByCommand(lpContextMenuCallback, IDM_METABACKREST);
           AddMenuItemByCommand(lpContextMenuCallback, IDM_SHUTDOWN);
	   }
       // Check if we can do save data on this version of iis...
       if (IsConfigFlushable() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuItemByCommand(lpContextMenuCallback, IDM_SAVE_DATA);           
       }
#if 0
        if (CanAddInstance())
        {
            ASSERT(pInsertionAllowed != NULL);
            if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
            {

#define ADD_SERVICE_MENU(x)\
   if (!bSepAdded)\
   {\
      AddMenuSeparator(lpContextMenuCallback);\
      bSepAdded = TRUE;\
   }\
   AddMenuItemByCommand(lpContextMenuCallback, (x))

               HSCOPEITEM hChild = NULL, hCurrent;
               LONG_PTR cookie;
               BOOL bSepAdded = FALSE;

               hr = pConsoleNameSpace->GetChildItem(QueryScopeItem(), &hChild, &cookie);
               while (SUCCEEDED(hr) && hChild != NULL)
               {
                  CIISMBNode * pNode = (CIISMBNode *)cookie;
                  ASSERT(pNode != NULL);
                  if (_tcsicmp(pNode->GetNodeName(), SZ_MBN_FTP) == 0)
                  {
                     ADD_SERVICE_MENU(IDM_NEW_FTP_SITE);
                  }
                  else if (_tcsicmp(pNode->GetNodeName(), SZ_MBN_WEB) == 0)
                  {
                     ADD_SERVICE_MENU(IDM_NEW_WEB_SITE);
                  }
                  else if (_tcsicmp(pNode->GetNodeName(), SZ_MBN_APP_POOLS) == 0)
                  {
                     ADD_SERVICE_MENU(IDM_NEW_APP_POOL);
                  }
                  hCurrent = hChild;
                  hr = pConsoleNameSpace->GetNextItem(hCurrent, &hChild, &cookie);
               }
            }
        }
#endif
        //
        // CODEWORK: Add new instance commands for each of the services
        //           keeping in mind which ones are installed and all.
        //           add that info to the table, remembering that this
        //           is per service.
        //
    }

    return hr;
}

#if 0
// BUGBUG: It should be quite different -> we don't know in advance
// which service is this site for
HRESULT
CIISMachine::InsertNewInstance(DWORD inst)
{
    CError err;
    // Now we should insert and select this new site
    TCHAR buf[16];
    CIISSite * pSite = new CIISSite(m_pOwner, this, _itot(inst, buf, 10));
    if (pSite != NULL)
    {
        // If machine is not expanded we will get error and no effect
        if (!IsExpanded())
        {
            SelectScopeItem();
            IConsoleNameSpace2 * pConsole 
                    = (IConsoleNameSpace2 *)GetConsoleNameSpace();
            pConsole->Expand(QueryScopeItem());
        }
        // Now we should find the relevant service node, and inset this one under
        // this node
        pSite->AddRef();
        err = pSite->AddToScopePaneSorted(QueryScopeItem(), FALSE);
        if (err.Succeeded())
        {
            VERIFY(SUCCEEDED(pSite->SelectScopeItem()));
        }
        else
        {
            pSite->Release();
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}
#endif

HRESULT
CIISMachine::Command(
    long lCommandID,     
    CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    switch (lCommandID)
    {
    case IDM_DISCONNECT:
        hr = OnDisconnect();
        break;

    case IDM_METABACKREST:
        hr = OnMetaBackRest();
        break;

    case IDM_SHUTDOWN:
        hr = OnShutDown();
        break;

    case IDM_SAVE_DATA:
        hr = OnSaveData();
        break;
#if 0
    case IDM_NEW_FTP_SITE:
        CError err;
        CComBSTR bstrMetaPath;
        BuildMetaPath(bstrMetaPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            if (SUCCEEDED(hr = AddFTPSite(pObj, type, &inst)))
            {
                hr = InsertNewInstance(inst);
            }
        }
       break;

    case IDM_NEW_WEB_SITE:
        CError err;
        CComBSTR bstrMetaPath;
        BuildMetaPath(bstrMetaPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            if (SUCCEEDED(hr = AddWebSite(pObj, type, &inst)))
            {
                hr = InsertNewInstance(inst);
            }
        }
       break;

    case IDM_NEW_APP_POOL:
        CError err;
        CComBSTR bstrMetaPath;
        BuildMetaPath(bstrMetaPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            hr = AddAppPool(pObj, type);
        }
       break;
#endif

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}



HRESULT
CIISMachine::OnDisconnect()
/*++

Routine Description:

    Disconnect this machine.  Confirm user choice.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());


    CString str;
    str.Format(IDS_CONFIRM_DISCONNECT, QueryDisplayName());
    BOOL bOpenPropertySheets = FALSE;

    CIISObject * pOpenItem = NULL;
    if (g_OpenPropertySheetTracker.IsPropertySheetOpenComputer(this,TRUE,&pOpenItem))
    {
        g_OpenPropertySheetTracker.Dump();
        if (pOpenItem)
        {
            HWND hHwnd = pOpenItem->IsMyPropertySheetOpen();
            // a property sheet is open somewhere..
            // make sure they close it before proceeding with refresh...
            // Highlight the property sheet.
            if (hHwnd && (hHwnd != (HWND) 1))
            {
                DoHelpMessageBox(NULL,IDS_CLOSE_ALL_PROPERTY_SHEET_DISCONNECT, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
                
                if (!SetForegroundWindow(hHwnd))
                {
                    // wasn't able to bring this property sheet to
                    // the foreground, the propertysheet must not
                    // exist anymore.  let's just clean the hwnd
                    // so that the user will be able to open propertysheet
                    pOpenItem->SetMyPropertySheetOpen(0);
                }
                bOpenPropertySheets = TRUE;
            }
        }
    }

    if (!bOpenPropertySheets)
    {
        if (NoYesMessageBox(str))
        {
            return RemoveScopeItem();
        }
    }

    return S_OK;
}



HRESULT
CIISMachine::OnMetaBackRest()
/*++

Routine Description:

    Backup/Restore the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    //
    // Verify user credentials are satisfactorily resolved.
    // Machines objects are loaded from the cache without a
    // password, so the function below will ask for it.
    //
    ResolveCredentials();

	// ensure the dialog gets themed
	CThemeContextActivator activator(theApp.GetFusionInitHandle());

    CBackupDlg dlg(this, QueryServerName(), GetMainWindow(GetConsole()));
    dlg.DoModal();

    if (dlg.ServicesWereRestarted())
    {
        //
        // Rebind all metabase handles on this server
        //
        err = CreateInterface(TRUE);

        //
        // Now do a refresh on the computer node.  Since we've forced
        // the rebinding already, we should not get the disconnect warning.
        //
        if (err.Succeeded())
        {
            err = Refresh(TRUE);
        }
    }
    else
    {
        if (dlg.HasChangedMetabase())
        {
            //
            // Refresh and re-enumerate child objects
            //
            err = Refresh(TRUE);
        }
    }

    return err;
}



HRESULT
CIISMachine::OnShutDown()
/*++

Routine Description:

    Bring up the IIS shutdown dialog.  If the services on the remote
    machine are restarted, the metabase interface should be recreated.
    
Arguments:

    None
    
Return Value:

    HRESULT    

--*/
{
    CError err;
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    //
    // Verify user credentials are satisfactorily resolved.
    // Machines objects are loaded from the cache without a
    // password, so the function below will ask for it.
    //
    ResolveCredentials();

	// ensure the dialog gets themed
	CThemeContextActivator activator(theApp.GetFusionInitHandle());

    CIISShutdownDlg dlg(this, GetMainWindow(GetConsole()));
    dlg.DoModal();

    if (dlg.ServicesWereRestarted())
    {
        //
        // Rebind all metabase handles on this server
        //
        err = CreateInterface(TRUE);

        //
        // Now do a refresh on the computer node.  Since we've forced
        // the rebinding already, we should not get the disconnect warning.
        //
        if (err.Succeeded())
        {
            err = Refresh(TRUE);
        }
    }

    return err;
}

HRESULT
CIISMachine::OnSaveData()
/*++

Routine Description:

    Flush the metabase to disk and display saved config file
    
Arguments:

    None
    
Return Value:

    HRESULT    

--*/
{
    CError err;
    CComBSTR bstrPath;

    err = BuildMetaPath(bstrPath);
    err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
    if (err.Succeeded())
    {
        err = DoOnSaveData(::GetActiveWindow(), QueryServerName(),QueryInterface(),TRUE,GetMetabaseSystemChangeNumber());
        RefreshMetabaseSystemChangeNumber();
    }
    return err;
}

HRESULT 
CIISMachine::RefreshMetabaseSystemChangeNumber() 
/*++

Routine Description:


Arguments:

    None

Return Value:

    HRESULT

--*/
{ 
    return QueryInterface()->GetSystemChangeNumber(&m_dwMetabaseSystemChangeNumber);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\impexp.h ===
#if !defined(AFX_IMPORT_EXPORT_CONFIG_H_INCLUDED_)
#define AFX_IMPORT_EXPORT_CONFIG_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////

HRESULT DoNodeExportConfig(BSTR bstrMachineName,BSTR bstrUserName,BSTR bstrUserPassword,BSTR bstrMetabasePath);
HRESULT DoNodeImportConfig(BSTR bstrMachineName,BSTR bstrUserName,BSTR bstrUserPassword,BSTR bstrMetabasePath,BSTR bstrKeyType);

#endif // !defined(AFX_IMPORT_EXPORT_CONFIG_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\impexp.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "inetmgrapp.h"
#include "impexp.h"
#include "iisuiobj.h"

extern CInetmgrApp theApp;

inline HRESULT SetBlanket(LPUNKNOWN pIUnk)
{
  return CoSetProxyBlanket( pIUnk,
                            RPC_C_AUTHN_WINNT,    // NTLM authentication service
                            RPC_C_AUTHZ_NONE,     // default authorization service...
                            NULL,                 // no mutual authentication
                            RPC_C_AUTHN_LEVEL_DEFAULT,      // authentication level
                            RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
                            NULL,                 // use current token
                            EOAC_NONE );          // no special capabilities    
}

HRESULT DoNodeExportConfig(BSTR bstrMachineName,BSTR bstrUserName,BSTR bstrUserPassword,BSTR bstrMetabasePath)
{
    HRESULT hResult = E_FAIL;
    BOOL bPleaseDoCoUninit = FALSE;
    IImportExportConfig *pTheObject = NULL;
    CLSID clsID;

    if (!bstrMetabasePath)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if(FAILED(hResult = CoInitialize(NULL)))
    {
        return hResult;
    }
    bPleaseDoCoUninit = TRUE;

	if (FAILED(hResult = CLSIDFromProgID(OLESTR("IISUIObj.ImportExportConfig"), &clsID)))
    {
        goto DoNodeExportConfig_Exit;
    }

    if (FAILED(hResult = CoCreateInstance(clsID,NULL,CLSCTX_SERVER,__uuidof(IImportExportConfig),(void **)&pTheObject)))
    {
        goto DoNodeExportConfig_Exit;
    }

    SetBlanket(pTheObject);

    // at this point we were able to instantiate the com object on the server (local or remote)
    if (bstrMachineName)
    {
        hResult = pTheObject->put_MachineName(bstrMachineName);
    }

    if (bstrUserName)
    {
        hResult = pTheObject->put_UserName(bstrUserName);
    }

    if (bstrUserPassword)
    {
        hResult = pTheObject->put_UserPassword(bstrUserPassword);
    }

    {
		// ensure the dialog gets themed
        CThemeContextActivator activator(theApp.GetFusionInitHandle());
        // call the export object
        if (FAILED(hResult= pTheObject->ExportConfigToFileUI(bstrMetabasePath)))
        {
            goto DoNodeExportConfig_Exit;
        }
    }
DoNodeExportConfig_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return hResult;
}

HRESULT DoNodeImportConfig(BSTR bstrMachineName,BSTR bstrUserName,BSTR bstrUserPassword,BSTR bstrMetabasePath,BSTR bstrKeyType)
{
    HRESULT hResult = E_FAIL;
    BOOL bPleaseDoCoUninit = FALSE;
    IImportExportConfig *pTheObject = NULL;
    CLSID clsID;

    if (!bstrMetabasePath)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if (!bstrKeyType)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if(FAILED(hResult = CoInitialize(NULL)))
    {
        return hResult;
    }
    bPleaseDoCoUninit = TRUE;

	if (FAILED(hResult = CLSIDFromProgID(OLESTR("IISUIObj.ImportExportConfig"), &clsID)))
    {
        goto DoNodeImportConfig_Exit;
    }

    if (FAILED(hResult = CoCreateInstance(clsID,NULL,CLSCTX_SERVER,__uuidof(IImportExportConfig),(void **)&pTheObject)))
    {
        goto DoNodeImportConfig_Exit;
    }

    SetBlanket(pTheObject);

    // at this point we were able to instantiate the com object on the server (local or remote)
    if (bstrMachineName)
    {
        hResult = pTheObject->put_MachineName(bstrMachineName);
    }

    if (bstrUserName)
    {
        hResult = pTheObject->put_UserName(bstrUserName);
    }

    if (bstrUserPassword)
    {
        hResult = pTheObject->put_UserPassword(bstrUserPassword);
    }

	{
		// ensure the dialog gets themed
		CThemeContextActivator activator(theApp.GetFusionInitHandle());
		// call the import object
		if (FAILED(hResult = pTheObject->ImportConfigFromFileUI(bstrMetabasePath,bstrKeyType)))
		{
			goto DoNodeImportConfig_Exit;
		}
	}

DoNodeImportConfig_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iissite.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        iissite.cpp

   Abstract:
        IIS Site Object

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        10/28/2000      sergeia     Split from iisobj.cpp

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "machsht.h"
#include "errors.h"
#include "impexp.h"
#include "tracker.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

extern CPropertySheetTracker g_OpenPropertySheetTracker;

//
// CIISSite implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Site Result View definition
//
/* static */ int 
CIISSite::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_SERVICE_ID,
    IDS_RESULT_SERVICE_STATE,
    IDS_RESULT_SERVICE_DOMAIN_NAME,
    IDS_RESULT_SERVICE_IP_ADDRESS,
    IDS_RESULT_SERVICE_TCP_PORT,
    IDS_RESULT_SERVICE_SSL_PORT,
    IDS_RESULT_STATUS,
};

int 
CIISSite::_rgnLabels2[COL_TOTAL2] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_SERVICE_ID,
    IDS_RESULT_SERVICE_STATE,
//    0, // blank
    IDS_RESULT_SERVICE_IP_ADDRESS,
    IDS_RESULT_SERVICE_TCP_PORT,
//    0, // blank
    IDS_RESULT_STATUS,
};    

/* static */ int 
CIISSite::_rgnWidths[COL_TOTAL] =
{
    180,
    90,
    70,
    120,
    105,
    40,
    60,
    200,
};

/* static */ int 
CIISSite::_rgnWidths2[COL_TOTAL2] =
{
    180,
    90,
    70,
//    0, // blank
    105,
    40,
//    0, // blank
    200,
};

/* static */ CComBSTR CIISSite::_bstrStarted;
/* static */ CComBSTR CIISSite::_bstrStopped;
/* static */ CComBSTR CIISSite::_bstrPaused;
/* static */ CComBSTR CIISSite::_bstrUnknown;
/* static */ CComBSTR CIISSite::_bstrPending;
/* static */ CComBSTR CIISSite::_bstrAllUnassigned;
/* static */ BOOL     CIISSite::_fStaticsLoaded = FALSE;

/* static */
void
CIISSite::LoadStatics()
{
    if (!_fStaticsLoaded)
    {
        _fStaticsLoaded =
            _bstrStarted.LoadString(IDS_STARTED)  &&
            _bstrStopped.LoadString(IDS_STOPPED)  &&
            _bstrPaused.LoadString(IDS_PAUSED)    &&
            _bstrUnknown.LoadString(IDS_UNKNOWN)  &&
            _bstrPending.LoadString(IDS_PENDING)  &&
            _bstrAllUnassigned.LoadString(IDS_IP_ALL_UNASSIGNED);
    }
}


/* static */
void
CIISSite::InitializeHeaders(LPHEADERCTRL lpHeader)
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL lpHeader : Header control

Return Value:

    None

--*/
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
//	CIISDirectory::InitializeHeaders(lpHeader);
    LoadStatics();
}

void
CIISSite::InitializeHeaders2(LPHEADERCTRL lpHeader)
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL lpHeader : Header control

Return Value:

    None

--*/
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL2, _rgnLabels2, _rgnWidths2);
//	CIISDirectory::InitializeHeaders(lpHeader);
    LoadStatics();
}


/* virtual */
void 
CIISSite::InitializeChildHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Build result view for immediate descendant type

Arguments:

    LPHEADERCTRL lpHeader      : Header control

Return Value:

    None

--*/
{
    CIISDirectory::InitializeHeaders(lpHeader);
}


CIISSite::CIISSite(
    IN CIISMachine * pOwner,
    IN CIISService * pService,
    IN LPCTSTR szNodeName
    )
/*++

Routine Description:

    Constructor.  Determine if the given service is administrable, 
    and resolve the details

Arguments:

    CIISMachine * pOwner        : Owner machine object
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name (numeric)

Return Value:

    N/A

Notes:

    This constructor does not immediately resolve the display name of the 
    site.  It will only resolve its display information when asked

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_fResolved(FALSE),
      m_strDisplayName(),
      //
      // Data members -- plonk in some defaults
      //
      m_dwState(MD_SERVER_STATE_INVALID),
      m_fWolfPackEnabled(FALSE),
      m_fFrontPageWeb(FALSE),
      m_sPort(80),
      m_sSSLPort(443),
      m_dwID(::_ttol(szNodeName)),
      m_dwIPAddress(0L),
      m_dwWin32Error(ERROR_SUCCESS),
	  m_dwEnumError(ERROR_SUCCESS),
      m_bstrHostHeaderName(),
      m_bstrComment(),
      m_fUsingActiveDir(FALSE)
{
    ASSERT_PTR(m_pService);
    m_pService->AddRef();
}



CIISSite::CIISSite(
    IN CIISMachine * pOwner,
    IN CIISService * pService,
    IN LPCTSTR  szNodeName,
    IN DWORD    dwState,
    IN BOOL     fClusterEnabled,
    IN USHORT   sPort,
    IN DWORD    dwID,
    IN DWORD    dwIPAddress,
    IN DWORD    dwWin32Error,
    IN LPOLESTR szHostHeaderName,
    IN LPOLESTR szComment
    )
/*++

Routine Description:

    Construct with full information

Arguments:

    CIISMachine * pOwner        : Owner machine object
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name (numeric)

    plus datamembers

Return Value:

    N/A

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_fResolved(TRUE),
      m_strDisplayName(),
      //
      // Data Members
      //
      m_dwState(dwState),
      m_fWolfPackEnabled(fClusterEnabled),
      m_sPort(sPort),
      m_dwID(dwID),
      m_dwIPAddress(dwIPAddress),
      m_dwWin32Error(dwWin32Error),
      m_bstrHostHeaderName(szHostHeaderName),
      m_bstrComment(szComment),
      m_fUsingActiveDir(FALSE)
{
    ASSERT_PTR(m_pService);
    m_pService->AddRef();
}



CIISSite::~CIISSite()
{
    m_pService->Release();
}



/* virtual */
HRESULT
CIISSite::RefreshData()
/*++

Routine Description:

    Refresh relevant configuration data required for display.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    CWaitCursor wait;
    CComBSTR bstrPath;
    CMetaKey * pKey = NULL;

    do
    {
        err = BuildMetaPath(bstrPath);
        BREAK_ON_ERR_FAILURE(err);
        // We need instance key here
        CString path_inst;
        CMetabasePath::GetInstancePath(bstrPath, path_inst);

        BOOL fContinue = TRUE;
        while (fContinue)
        {
            fContinue = FALSE;
            if (NULL == (pKey = new CMetaKey(QueryInterface(), path_inst)))
            {
                TRACEEOLID("RefreshData: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            err = pKey->QueryResult();
            if (IsLostInterface(err))
            {
                SAFE_DELETE(pKey);
                fContinue = OnLostInterface(err);
            }
        }
        BREAK_ON_ERR_FAILURE(err);

        CInstanceProps inst(pKey, _T(""), m_dwID);
        err = inst.LoadData();

        BREAK_ON_ERR_FAILURE(err);

        m_dwState = inst.m_dwState;

        //
        // Don't be confused -- cluster enabled refers
        // to wolfpack and has nothing to do with app server
        //
        m_fWolfPackEnabled = inst.IsClusterEnabled();
        m_sPort = (SHORT)inst.m_nTCPPort;
        m_dwID = inst.QueryInstance();
        m_dwIPAddress = inst.m_iaIpAddress;
        m_dwWin32Error = inst.m_dwWin32Error;
        m_bstrHostHeaderName = inst.m_strDomainName;
        m_bstrComment = inst.m_strComment;
        
		m_strDisplayName.Empty();
        {
            CStringListEx list;
            pKey->QueryValue(MD_SECURE_BINDINGS, list);
            UINT port = 0;
            CInstanceProps::FindMatchingSecurePort(list, inst.m_iaIpAddress, port);
            m_sSSLPort = (USHORT)port;
        }
        // Check if it is Frontpage controlled site
        pKey->QueryValue(MD_FRONTPAGE_WEB, m_fFrontPageWeb);

        // check if it's using ActiveDirectory...
        if (IsFtpSite())
        {
            INT iFtpUserIsolation = 0;
            m_fUsingActiveDir = FALSE;
            pKey->QueryValue(MD_USER_ISOLATION, iFtpUserIsolation);
            if (2 == iFtpUserIsolation)
            {
                m_fUsingActiveDir = TRUE;
            }
        }

        CChildNodeProps child(pKey, SZ_MBN_ROOT);
        err = child.LoadData();
        BREAK_ON_ERR_FAILURE(err);

        m_strRedirectPath = child.GetRedirectedPath();
    }
    while(FALSE);

    SAFE_DELETE(pKey);
    m_dwEnumError = err.Win32Error();

    return err;
}



/* virtual */
int      
CIISSite::QueryImage() const
/*++

Routine Description:

    Return bitmap index for the site

Arguments:

    None

Return Value:

    Bitmap index

--*/
{ 
    ASSERT_PTR(m_pService);
    if (!m_fResolved)
    {
        TRACEEOLID("Resolving name for site #" << QueryNodeName());

        if (m_hScopeItem == NULL)
        {
            //
            // BUGBUG:
            //
            // This is probably related to MMC bug #324519
            // where we're asked for the display info immediately
            // after adding the item to the console view.  This
            // appears to fail only on refresh because the scope
            // item handle is missing, and we can't build a metabase
            // path yet.
            //
            TRACEEOLID("BUGBUG: Prematurely asked for display information");
            //ASSERT(FALSE);
            return iError;
        }
	    CIISSite * that = (CIISSite *)this;
        CError err = that->RefreshData();
        that->m_fResolved = err.Succeeded();
    }
	if (!m_fResolved || m_pService == NULL)
	{
		return iError;
	}
	if (FAILED(m_dwWin32Error))
	{
		return m_pService->QuerySiteImageErr();
	}
	else
	{
		if (m_dwState == MD_SERVER_STATE_STOPPED)
		{
			return m_pService->QuerySiteImageStopped();
		}
		else
		{
			return m_pService->QuerySiteImage();
		}
	}
}



/* virtual */
LPOLESTR 
CIISSite::QueryDisplayName()
/*++

Routine Description:

    Return primary display name of this site.
    
Arguments:

    None

Return Value:

    The display name

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    if (!m_fResolved)
    {
        TRACEEOLID("Resolving name for site #" << QueryNodeName());

        if (m_hScopeItem == NULL)
        {
            //
            // BUGBUG:
            //
            // This is probably related to MMC bug #324519
            // where we're asked for the display info immediately
            // after adding the item to the console view.  This
            // appears to fail only on refresh because the scope
            // item handle is missing, and we can't build a metabase
            // path yet.
            //
            TRACEEOLID("BUGBUG: Prematurely asked for display information");
            //ASSERT(FALSE);
            return OLESTR("");
        }

        CError err = RefreshData();
        m_fResolved = err.Succeeded();
    }

    if (m_strDisplayName.IsEmpty())
    {
        CIPAddress ia(m_dwIPAddress);
        CInstanceProps::GetDisplayText(
            m_strDisplayName,
            m_bstrComment,
            m_bstrHostHeaderName,
            ia,
            m_sPort,
            m_dwID
            );
    }
    CString buf = m_strDisplayName;
    if (m_dwState == MD_SERVER_STATE_STOPPED)
    {
        buf.Format(IDS_STOPPED_SITE_FMT, m_strDisplayName);
    }
    else if (m_dwState == MD_SERVER_STATE_PAUSED)
    {
        buf.Format(IDS_PAUSED_SITE_FMT, m_strDisplayName);
    }
    m_bstrDisplayNameStatus = buf;
//    return (LPTSTR)(LPCTSTR)m_strDisplayName;
    return m_bstrDisplayNameStatus;
}



/* virtual */
LPOLESTR 
CIISSite::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    ASSERT(_fStaticsLoaded);

    TCHAR sz[255];

    if(IsFtpSite())
    {
        switch(nCol)
        {
            case COL_ID2:
                nCol = COL_ID;
                break;
            case COL_DESCRIPTION2:
                nCol = COL_DESCRIPTION;
                break;
            case COL_STATE2:
                nCol = COL_STATE;
                break;
            case COL_IP_ADDRESS2:
                nCol = COL_IP_ADDRESS;
                break;
            case COL_TCP_PORT2:
                nCol = COL_TCP_PORT;
                break;
            case COL_STATUS2:
                nCol = COL_STATUS;
                break;
            default:
                nCol = 0;
                break;
        }
    }

    switch(nCol)
    {
    case COL_ID:
        {
            CString buf;
            buf.Format(_T("%u"), m_dwID);
            _bstrResult = buf;
            return _bstrResult;
        }
    case COL_DESCRIPTION:
        return QueryDisplayName();

    case COL_STATE:
        switch(m_dwState)
        {
        case MD_SERVER_STATE_STARTED:
            return _bstrStarted;

        case MD_SERVER_STATE_PAUSED:
            return _bstrPaused;

        case MD_SERVER_STATE_STOPPED:
            return _bstrStopped;

        case MD_SERVER_STATE_STARTING:
        case MD_SERVER_STATE_PAUSING:
        case MD_SERVER_STATE_CONTINUING:
        case MD_SERVER_STATE_STOPPING:
            return _bstrPending;
        }

        return OLESTR("");

    case COL_DOMAIN_NAME:
        return m_bstrHostHeaderName;

    case COL_IP_ADDRESS:
        {
            CIPAddress ia(m_dwIPAddress);

            if (ia.IsZeroValue())
            {
                _bstrResult = _bstrAllUnassigned;
            }
            else
            {
                _bstrResult = ia;
            }
        }
        return _bstrResult;

    case COL_SSL_PORT:
        if (m_sSSLPort != 0)
        {
            _bstrResult = ::_itot(m_sSSLPort, sz, 10);
            return _bstrResult;
        }
        else
            return OLESTR("");

    case COL_TCP_PORT:
        _bstrResult = ::_itot(m_sPort, sz, 10);
        return _bstrResult;

    case COL_STATUS:
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());
            CError err(m_dwWin32Error);
            if (err.Succeeded())
            {
                return OLESTR("");
            }
			SetErrorOverrides(err, TRUE);
            _bstrResult = err;
        }
        return _bstrResult;
    }

    ASSERT_MSG("Bad column number");

    return OLESTR("");
}



/* virtual */
int 
CIISSite::CompareResultPaneItem(CIISObject * pObject, int nCol)
/*++

Routine Description:

    Compare two CIISObjects on sort item criteria

Arguments:

    CIISObject * pObject : Object to compare against
    int nCol             : Column number to sort on

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    if (nCol == 0)
    {
        return CompareScopeItem(pObject);
    }

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Both are CIISSite objects
    //
    CIISSite * pSite = (CIISSite *)pObject;

    if(IsFtpSite())
    {
        switch(nCol)
        {
            case COL_ID2:
                nCol = COL_ID;
                break;
            case COL_DESCRIPTION2:
                nCol = COL_DESCRIPTION;
                break;
            case COL_STATE2:
                nCol = COL_STATE;
                break;
            case COL_IP_ADDRESS2:
                nCol = COL_IP_ADDRESS;
                break;
            case COL_TCP_PORT2:
                nCol = COL_TCP_PORT;
                break;
            case COL_STATUS2:
                nCol = COL_STATUS;
                break;
            default:
                nCol = 0;
                break;
        }
    }

    switch(nCol)
    {
    //
    // Special case columns
    //
    case COL_IP_ADDRESS:
        {
            CIPAddress ia1(m_dwIPAddress);
            CIPAddress ia2(pSite->QueryIPAddress());
            
            return ia1.CompareItem(ia2);
        }

    case COL_ID:
        n1 = GetInstance();
        n2 = pSite->GetInstance();
        return n1 - n2;

    case COL_TCP_PORT:
        n1 = QueryPort();
        n2 = pSite->QueryPort();
        return n1 - n2;

    case COL_SSL_PORT:
        n1 = QuerySSLPort();
        n2 = pSite->QuerySSLPort();
        return n1 - n2;

    case COL_STATUS:
        {
            DWORD dw1 = QueryWin32Error();
            DWORD dw2 = pSite->QueryWin32Error();

            return dw1 - dw2;
        }

    case COL_DESCRIPTION:
    case COL_STATE:
    case COL_DOMAIN_NAME:
    default:
        //
        // Lexical sort
        //
        return ::lstrcmpi(
            GetResultPaneColInfo(nCol), 
            pObject->GetResultPaneColInfo(nCol)
            );
    }
}

/* virtual */
HRESULT 
CIISSite::BuildURL(CComBSTR & bstrURL) const
/*++

Routine Description:

    Recursively build up the URL from the current node
    and its parents.  For a site node, add the machine name.

Arguments:

    CComBSTR & bstrURL  : Returns URL

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    //
    // Prepend parent portion (protocol in this case)
    //
    CIISMBNode * pNode = GetParentNode();

    if (pNode)
    {
        hr = pNode->BuildURL(bstrURL);
    }

    if (SUCCEEDED(hr))
    {
        CString strOwner;

        ///////////////////////////////////////////////////////////////////////////
        //
        // Try to build an URL.  Use in order of priority:
        //
        //     Domain name:port/root
        //     ip address:port/root
        //     computer name:port/root
        //    
        if (m_bstrHostHeaderName.Length())
        {
            strOwner = m_bstrHostHeaderName;
        }
        else if (m_dwIPAddress != 0L)
        {
            CIPAddress ia(m_dwIPAddress);
            ia.QueryIPAddress(strOwner);
        }
        else
        {
            if (IsLocal())
            {
                //
                // Security reasons restrict this to "localhost" oftentimes
                //
                strOwner = _bstrLocalHost;
            }
            else
            {
                LPOLESTR lpOwner = QueryMachineName();
                strOwner = PURE_COMPUTER_NAME(lpOwner);
            }
        }

        TCHAR szPort[6]; // 65536 max.
        _itot(m_sPort, szPort, 10);

        strOwner += _T(":");
        strOwner += szPort;

        bstrURL.Append(strOwner);
    }

    return hr;
}


/*virtual*/
HRESULT
CIISSite::AddMenuItems(
    LPCONTEXTMENUCALLBACK piCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(piCallback);
    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        piCallback,
        pInsertionAllowed,
        type
        );
    if (SUCCEEDED(hr))
    {
       ASSERT(pInsertionAllowed != NULL);
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
       {
           AddMenuSeparator(piCallback);
           if (IsFtpSite())
           {
              if (GetOwner()->CanAddInstance() && !GetOwner()->IsWorkstation())
              {
                 AddMenuItemByCommand(piCallback, IDM_NEW_FTP_SITE);
                 if (IsConfigImportExportable())
                 {
                     AddMenuItemByCommand(piCallback, IDM_NEW_FTP_SITE_FROM_FILE);
                 }
              }
              AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR);
              if (IsConfigImportExportable())
              {
                  AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR_FROM_FILE);
              }
           }
           else if (IsWebSite())
           {
              if (GetOwner()->CanAddInstance() && !GetOwner()->IsWorkstation())
              {
                 AddMenuItemByCommand(piCallback, IDM_NEW_WEB_SITE);
                 if (IsConfigImportExportable())
                 {
                     AddMenuItemByCommand(piCallback, IDM_NEW_WEB_SITE_FROM_FILE);
                 }
              }
              AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR);
              if (IsConfigImportExportable())
              {
                  AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR_FROM_FILE);
              }
           }
       }
       if (IsConfigImportExportable() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuSeparator(piCallback);
           AddMenuItemByCommand(piCallback, IDM_TASK_EXPORT_CONFIG_WIZARD);
       }
    }
    return hr;
}

HRESULT
CIISSite::InsertNewInstance(DWORD inst)
{
	return m_pService->InsertNewInstance(inst);
}

HRESULT
CIISSite::InsertNewAlias(CString alias)
{
    CError err;
    if (!IsExpanded())
    {
        SelectScopeItem();
        IConsoleNameSpace2 * pConsoleNameSpace
                = (IConsoleNameSpace2 *)GetConsoleNameSpace();
        pConsoleNameSpace->Expand(QueryScopeItem());
		HSCOPEITEM hChildItem = NULL;
		LONG_PTR cookie;
		HRESULT hr = pConsoleNameSpace->GetChildItem(m_hScopeItem, &hChildItem, &cookie);
		while(SUCCEEDED(hr) && hChildItem)
		{
			CIISObject * pItem = (CIISObject *)cookie;
			ASSERT_PTR(pItem);
			if (0 == alias.Compare(pItem->QueryDisplayName()))
			{
				pItem->SelectScopeItem();
				break;
			}
			hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
		}
    }
	else
	{
		// Now we should insert and select this new site
		CIISDirectory * pAlias = new CIISDirectory(m_pOwner, m_pService, alias);
		if (pAlias != NULL)
		{
			pAlias->AddRef();
			err = pAlias->AddToScopePaneSorted(QueryScopeItem(), FALSE);
			if (err.Succeeded())
			{
				VERIFY(SUCCEEDED(pAlias->SelectScopeItem()));
			}
			else
			{
				pAlias->Release();
			}
		}
		else
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
		}
	}
    return err;
}

/* virtual */
HRESULT
CIISSite::Command(
    long lCommandID,     
    CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    DWORD dwCommand = 0;
    DWORD inst = 0;
    CError err;
    CString alias;
    CComBSTR bstrMetaPath;
    BOOL bNeedMetabase = FALSE;
    BOOL bHaveMetabase = FALSE;

    switch (lCommandID)
    {
        case IDM_STOP:
        case IDM_START:
        case IDM_PAUSE:
        case IDM_NEW_FTP_SITE:
        case IDM_NEW_FTP_VDIR:
        case IDM_NEW_WEB_SITE:
        case IDM_NEW_WEB_VDIR:
            bNeedMetabase = TRUE;
            break;
        default:
            bNeedMetabase = FALSE;
    }

    if (bNeedMetabase)
    {
        // WARNING:bstrMetaPath will be used by switch statement below
        VERIFY(SUCCEEDED(BuildMetaPath(bstrMetaPath)));
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            bHaveMetabase = TRUE;
        }
    }


    switch (lCommandID)
    {
    case IDM_STOP:
        if (bHaveMetabase)
        {
            dwCommand = MD_SERVER_COMMAND_STOP;
        }
        break;

    case IDM_START:
        if (bHaveMetabase)
        {
            dwCommand = m_dwState == MD_SERVER_STATE_PAUSED ?
                MD_SERVER_COMMAND_CONTINUE : MD_SERVER_COMMAND_START;
        }
        break;

    case IDM_PAUSE:
        if (bHaveMetabase)
        {
            dwCommand = m_dwState == MD_SERVER_STATE_PAUSED ?
                MD_SERVER_COMMAND_CONTINUE : MD_SERVER_COMMAND_PAUSE;
        }
        break;

    case IDM_NEW_FTP_SITE:
        if (bHaveMetabase)
        {
            hr = AddFTPSite(pObj, type, &inst);
            if (inst != 0)
            {
                hr = InsertNewInstance(inst);
            }
        }
        break;

    case IDM_NEW_FTP_VDIR:
        if (bHaveMetabase)
        {
            hr = CIISMBNode::AddFTPVDir(pObj, type, alias);
            if (!alias.IsEmpty())
            {
                hr = InsertNewAlias(alias);
            }
        }
        break;

    case IDM_NEW_WEB_SITE:
        if (bHaveMetabase)
        {
            hr = AddWebSite(pObj, type, &inst, 
						    m_pOwner->QueryMajorVersion(), m_pOwner->QueryMinorVersion());
            if (inst != 0)
            {
                hr = InsertNewInstance(inst);
            }
        }
        break;

    case IDM_NEW_WEB_VDIR:
        if (bHaveMetabase)
        {
            hr = CIISMBNode::AddWebVDir(pObj, type, alias,
						    m_pOwner->QueryMajorVersion(), m_pOwner->QueryMinorVersion());
            if (!alias.IsEmpty())
            {
                hr = InsertNewAlias(alias);
            }
        }
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    if (dwCommand)
    {
        DWORD svc_mode, svc_state;
        CString name, buf;

        hr = m_pService->GetServiceState(svc_mode, svc_state, name);
        if (FAILED(hr))
        {
            return hr;
        }
        switch (svc_mode)
        {
        case SERVICE_DISABLED:
            AfxFormatString1(buf, IDS_NO_START_SERVICE_DISABLED, name);
            if (IDYES == AfxMessageBox(buf, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1))
            {
                hr = m_pService->EnableService();
                break;
            }
            return hr;
        case SERVICE_DEMAND_START:
            AfxFormatString1(buf, IDS_NO_START_SERVICE_MANUAL, name);
            if (svc_state != SERVICE_RUNNING)
            {
                if (IDYES == AfxMessageBox(buf, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1))
                {
                    hr = m_pService->StartService();
                    break;
                }
                return hr;
            }
            break;
        default:
            break;
        }
        hr = ChangeState(dwCommand);

        // make sure if a site has been started, 
        // that the service is shown as started too...
        if (SUCCEEDED(m_pService->RefreshData()))
        {
            m_pService->RefreshDisplay(FALSE);
            // Refresh our data if we refreshed the service level one...
            RefreshDisplay();
        }
       
    }
    return hr;
}




/* virtual */
HRESULT
CIISSite::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CError  err;

	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }
	if (err.Succeeded())
	{
		CComBSTR bstrPath;
		err = BuildMetaPath(bstrPath);
		if (err.Succeeded())
		{
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
            if (err.Succeeded())
            {
                // cache handle for user in MMCPropertyChangeNotify
                m_ppHandle = handle;

			    err = ShowPropertiesDlg(
				    lpProvider, QueryAuthInfo(), bstrPath,
				    GetMainWindow(GetConsole()), (LPARAM)this, (LPARAM)GetParentNode(), handle
				    );
            }
		}
	}
    err.MessageBoxOnFailure();
    return err;
}



HRESULT 
CIISSite::ChangeState(DWORD dwCommand)
/*++

Routine Description:

    Change the state of this instance (started/stopped/paused)

Arguments:

    DWORD dwCommand         : MD_SERVER_COMMAND_START, etc.

Return Value:

    HRESULT

--*/
{
    CError err;
    CComBSTR bstrPath;

    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	SetErrorOverrides(err);
    
    do
    {
        CWaitCursor wait;

        err = BuildMetaPath(bstrPath);
        // We need instance key here
        CString path_inst;
        CMetabasePath::GetInstancePath(bstrPath, path_inst);
        BREAK_ON_ERR_FAILURE(err)

        CInstanceProps ip(QueryAuthInfo(), path_inst);

        err = ip.LoadData();
        BREAK_ON_ERR_FAILURE(err)

        err = ip.ChangeState(dwCommand);
        BREAK_ON_ERR_FAILURE(err)

        err = RefreshData();
        if (err.Succeeded())
        {
            err = RefreshDisplay();
        }
    }
    while(FALSE);

    if (ERROR_ALREADY_EXISTS ==  err.Win32Error())
    {
        // if the service is trying to start
        // and the Port is already in use by another
        // site then it will report this error...
        if (MD_SERVER_COMMAND_START == dwCommand ||
            MD_SERVER_COMMAND_CONTINUE == dwCommand)
        {
            ::AfxMessageBox(IDS_ERR_PORT_USED,MB_ICONEXCLAMATION);
        }
        else
        {
            err.MessageBoxOnFailure();
        }
    }
    else
    {
        err.MessageBoxOnFailure();
    }

    return err;
}



/* virtual */
HRESULT 
CIISSite::EnumerateScopePane(HSCOPEITEM hParent)
{
	m_dwEnumError = 0;
    CError err = EnumerateVDirs(hParent, m_pService);
    if (err.Succeeded() && !IsFtpSite() && m_strRedirectPath.IsEmpty())
    {
        if (m_dwEnumError == ERROR_SUCCESS)
        {
            err = EnumerateWebDirs(hParent, m_pService);
        }
    }
    if (err.Failed())
    {
        m_dwEnumError = err.Win32Error();
        RefreshDisplay();
    }
    return err;
}

/*virtual*/
HRESULT 
CIISSite::EnumerateResultPane(BOOL fExp, IHeaderCtrl * pHdr, IResultData * pResData, BOOL bForRefresh)
{
	m_dwEnumError = 0;
	CError err = CIISObject::EnumerateResultPane(fExp, pHdr, pResData, bForRefresh);
    if (    err.Succeeded() 
//        &&  QueryWin32Error() == ERROR_SUCCESS
        &&  !IsFtpSite() 
        &&  m_strRedirectPath.IsEmpty()
        )
    {
		err = CIISMBNode::EnumerateResultPane_(fExp, pHdr, pResData, m_pService);
		if (err.Failed())
		{
			m_dwEnumError = err.Win32Error();
		}
	}
	return err;
}

/* virtual */
HRESULT
CIISSite::BuildMetaPath(CComBSTR & bstrPath) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents

Arguments:

    CComBSTR & bstrPath     : Returns metabase path

Return Value:

    HRESULT

Notes:

    This will return the home directory path, e.g. "lm/w3svc/2/root",
    not the path of the instance.

--*/
{
    //
    // Build instance path
    //
    HRESULT hr = CIISMBNode::BuildMetaPath(bstrPath);
    
    if (SUCCEEDED(hr))
    {
        //
        // Add root directory path
        //
        bstrPath.Append(_cszSeparator);
        bstrPath.Append(g_cszRoot);
    }

    return hr;
}


// CODEWORK: make it work from CIISMBNode::DeleteNode
HRESULT
CIISSite::DeleteNode(IResultData * pResult)
{
   CError err;
   CComBSTR path;

    // check if they have the property sheet open on it.
    if (IsMyPropertySheetOpen())
    {
        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
        return S_OK;
    }

    // this could be an orphaned property sheet
    // check if an orphaned property sheet is open on this item.
    CIISObject * pAlreadyOpenProp = NULL;
    if (TRUE == g_OpenPropertySheetTracker.FindAlreadyOpenPropertySheet(this,&pAlreadyOpenProp))
    {
        // Bring it to the foreground, and bail
        HWND hHwnd = 0;
        if (pAlreadyOpenProp)
        {
            if (hHwnd = pAlreadyOpenProp->IsMyPropertySheetOpen())
            {
                if (hHwnd && (hHwnd != (HWND) 1))
                {
                    // Perhapse we should cancel the already
                    // opened property sheet...just a thought
                    if (!SetForegroundWindow(hHwnd))
                    {
                        // wasn't able to bring this property sheet to
                        // the foreground, the propertysheet must not
                        // exist anymore.  let's just clean the hwnd
                        // so that the user will be able to open propertysheet
                        pAlreadyOpenProp->SetMyPropertySheetOpen(0);
                    }
                    else
                    {
                        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
                        return S_OK;
                    }
                }
            }
        }
    }

    err = CIISMBNode::BuildMetaPath(path);
    if (err.Succeeded())
    {
        err = CheckForMetabaseAccess(METADATA_PERMISSION_WRITE,this,TRUE,path);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
    }
    if (err.Succeeded())
    {
        if (!NoYesMessageBox(IDS_CONFIRM_DELETE))
            return err;

        do
        {
            CMetaInterface * pInterface = QueryInterface();
            ASSERT(pInterface != NULL);

			path.Empty();
            err = CIISMBNode::BuildMetaPath(path);
            if (err.Failed())
			{
                TRACEEOLID("BuildMetaPath failed path=" << path);
                break;
			}
            CMetaKey mk(pInterface, METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_WRITE);
            if (!mk.Succeeded())
			{
                break;
			}
            err = mk.DeleteKey(path);
            if (err.Failed()) 
			{
                TRACEEOLID("BuildMetaPath DeleteKey path=" << path);
                break;
			}

	        // don't hold the Metabasekey open
	        // (RemoveScopeItem may do a lot of things,and lock the metabase for other read requests)
	        mk.Close();

            err = RemoveScopeItem();

            if (!IsFtpSite())
            {
                // Also, if we delete a w3svc site, it's probably using 
                // a application, so we have to refresh that stuff too
                // this CAppPoolsContainer will only be here if it's iis6
                CIISMachine * pOwner = GetOwner();
                if (pOwner)
                {
                    CAppPoolsContainer * pPools = pOwner->QueryAppPoolsContainer();
                    if (pPools)
                    {
                        if (pPools->IsExpanded())
                        {
                            pPools->RefreshData();
                            pPools->RefreshDataChildren(_T(""),FALSE); // refresh all app pools, who knows..
                        }
                    }
                }
            }

        } while (FALSE);
    }

   if (err.Failed())
   {
      DisplayError(err);
   }
   return err;
}

//
// We are not supporting empty comments on sites. Even if it is OK for
// metabase, it will bring more problems in UI. Empty name will be displayed
// as [Site #N] in UI, and when user will try to rename it again, it could be
// stored in metabase in this format.
//
HRESULT
CIISSite::RenameItem(LPOLESTR new_name)
{
   CString strNewName(new_name);
   CComBSTR path;
   CError err;
   if (new_name != NULL && lstrlen(new_name) > 0)
   {
       err = BuildMetaPath(path);
       if (err.Succeeded())
       {
            // We need instance key here
            CString path_inst;
            CMetabasePath::GetInstancePath(path, path_inst);
            CMetaKey mk(QueryInterface(), path_inst, METADATA_PERMISSION_WRITE);
            err = mk.QueryResult();
            if (err.Succeeded())
            {
                // remove extra string that was added to 
                // the end for display purposes...
                if (m_dwState == MD_SERVER_STATE_STOPPED || m_dwState == MD_SERVER_STATE_PAUSED)
                {
                    // These stopped and paused sites will
                    // Add on to the end of the string (Stopped) or (Paused),
                    // take it out.
                    CString buf = _T(".");
                    if (m_dwState == MD_SERVER_STATE_STOPPED)
                        {buf.Format(IDS_STOPPED_SITE_FMT, _T(" "));}
                    else
                        {buf.Format(IDS_PAUSED_SITE_FMT, _T(" "));}
                    buf.TrimLeft();
                    buf.TrimRight();

                    // Take it out from the new string if it's there...
                    if (strNewName.GetLength() >= buf.GetLength())
                    {
                        CString buf2;
                        buf2 = strNewName.Right(buf.GetLength());
                        if (0 == buf2.Compare(buf))
                        {
                            // Found it, Trim it off
                            buf2 = strNewName.Left(strNewName.GetLength() - buf.GetLength());
                            strNewName = buf2;
                        }
                    }
                }

                err = mk.SetValue(MD_SERVER_COMMENT, strNewName);
                if (err.Succeeded())
                {
                    m_strDisplayName = strNewName;
                }
            }
       }
   }
   return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iisobj.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        iisobj.cpp

   Abstract:
        IIS Object

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "w3sht.h"
#include "fltdlg.h"
#include "util.h"
#include "tracker.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

extern CInetmgrApp theApp;
extern INT g_iDebugOutputLevel;
extern DWORD g_dwInetmgrParamFlags;

// global list keep to track of open property sheets, project wide.
CPropertySheetTracker g_OpenPropertySheetTracker;
CWNetConnectionTrackerGlobal g_GlobalConnections;

#if defined(_DEBUG) || DBG
	CDebug_IISObject g_Debug_IISObject;
#endif

#define GLOBAL_DEFAULT_HELP_PATH  _T("::/htm/iiswelcome.htm")

BOOL IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    BOOL bRet = FALSE;

    // simple version using Win-32 APIs for pointer validation.
    if (lp == NULL)
    {
        return FALSE;
    }

#ifndef _WIN64
    if (lp == (const void *) 0xfeeefeee){return FALSE;}
    if (lp == (const void *) 0xfefefefe){return FALSE;}
    if (lp == (const void *) 0xdddddddd){return FALSE;}
    if (lp == (const void *) 0x0badf00d){return FALSE;}
    if (lp == (const void *) 0xbaadf00d){return FALSE;}
    if (lp == (const void *) 0xbadf00d2){return FALSE;}
    if (lp == (const void *) 0xbaadf000){return FALSE;}
    if (lp == (const void *) 0xdeadbeef){return FALSE;}
#else
    if (lp == (const void *) 0xfeeefeeefeeefeee){return FALSE;}
    if (lp == (const void *) 0xfefefefefefefefe){return FALSE;}
    if (lp == (const void *) 0xdddddddddddddddd){return FALSE;}
    if (lp == (const void *) 0x0badf00d0badf00d){return FALSE;}
    if (lp == (const void *) 0xbaadf00dbaadf00d){return FALSE;}
    if (lp == (const void *) 0xbadf00d2badf00d2){return FALSE;}
    if (lp == (const void *) 0xbaadf000baadf000){return FALSE;}
    if (lp == (const void *) 0xdeadbeefdeadbeef){return FALSE;}
#endif
    // Check for valid read ptr
    // this will break into debugger on Chk build
    if (0 == IsBadReadPtr(lp, nBytes))
    {
        bRet = TRUE;
    }

    // Check for bad write ptr
    // this will break into debugger on Chk build
    if (TRUE == bRet && bReadWrite)
    {
        bRet = FALSE;
        if (0 == IsBadWritePtr((LPVOID)lp, nBytes))
        {
            bRet = TRUE;
        }
    }

    if (FALSE == bRet)
    {
        DebugTrace(_T("Bad Pointer:%p"),lp);
    }

    return bRet;
}

//
// CInetMgrComponentData
//
static const GUID CInetMgrGUID_NODETYPE 
    = {0xa841b6c2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//BOOL CIISObject::m_fIsExtension = FALSE;

#define TB_COLORMASK        RGB(192,192,192)    // Lt. Gray


LPOLESTR
CoTaskDupString(
    IN LPCOLESTR szString
    )
/*++

Routine Description:

    Helper function to duplicate a OLESTR

Arguments:

    LPOLESTR szString       : Source string

Return Value:

    Pointer to the new string or NULL

--*/
{
    OLECHAR * lpString = (OLECHAR *)CoTaskMemAlloc(
        sizeof(OLECHAR)*(lstrlen(szString) + 1)
        );

    if (lpString != NULL)
    {
        lstrcpy(lpString, szString);
    }

    return lpString;
}

const GUID *    CIISObject::m_NODETYPE = &CLSID_InetMgr; //&CInetMgrGUID_NODETYPE;
const OLECHAR * CIISObject::m_SZNODETYPE = OLESTR("A841B6C2-7577-11d0-BB1F-00A0C922E79C");
const CLSID *   CIISObject::m_SNAPIN_CLASSID = &CLSID_InetMgr;


//
// Backup/restore taskpad gif resource
//
#define RES_TASKPAD_BACKUP          _T("/img\\backup.gif")



//
// CIISObject implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Important!  The array indices below must ALWAYS be one
// less than the menu ID -- keep in sync with enumeration
// in iisobj.h!!!!
//
/* static */ CIISObject::CONTEXTMENUITEM_RC CIISObject::_menuItemDefs[] = 
{
    //
    // Menu Commands in toolbar order
    //
    //nNameID                           nStatusID                           nDescriptionID               lCmdID                    lInsertionPointID                  fSpecialFlags
    //                                                                                                                                                                   lpszMouseOverBitmap   lpszMouseOffBitmap    lpszLanguageIndenpendentID
    { IDS_MENU_CONNECT,                 IDS_MENU_TT_CONNECT,                -1,                          IDM_CONNECT,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_CONNECT"),        },
    { IDS_MENU_DISCOVER,                IDS_MENU_TT_DISCOVER,               -1,                          IDM_DISCOVER,             CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_DISCOVER"),        },
    { IDS_MENU_START,                   IDS_MENU_TT_START,                  -1,                          IDM_START,                CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_START"),        },
    { IDS_MENU_STOP,                    IDS_MENU_TT_STOP,                   -1,                          IDM_STOP,                 CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_STOP"),        },
    { IDS_MENU_PAUSE,                   IDS_MENU_TT_PAUSE,                  -1,                          IDM_PAUSE,                CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_PAUSE"),        },
    //
    // These are menu commands that do not show up in the toolbar
    //
    { IDS_MENU_EXPLORE,                 IDS_MENU_TT_EXPLORE,                -1,                          IDM_EXPLORE,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_EXPLORE"),        },
    { IDS_MENU_OPEN,                    IDS_MENU_TT_OPEN,                   -1,                          IDM_OPEN,                 CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_OPEN"),        },
    { IDS_MENU_BROWSE,                  IDS_MENU_TT_BROWSE,                 -1,                          IDM_BROWSE,               CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_BROWSE"),        },
    { IDS_MENU_RECYCLE,                 IDS_MENU_TT_RECYCLE,                -1,                          IDM_RECYCLE,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_RECYCLE"),        },
    { IDS_MENU_PERMISSION,              IDS_MENU_TT_PERMISSION,             -1,                          IDM_PERMISSION,           CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_PERMISSION"),        },

#if defined(_DEBUG) || DBG
    { IDS_MENU_IMPERSONATE,             IDS_MENU_TT_IMPERSONATE,            -1,                          IDM_IMPERSONATE,          CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_IMPERSONATE"),        },
    { IDS_MENU_REM_IMPERS,              IDS_MENU_TT_REM_IMPERS,             -1,                          IDM_REMOVE_IMPERSONATION, CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_REM_IMPERS"),        },
#endif // _DEBUG

    { IDS_MENU_PROPERTIES,              IDS_MENU_TT_PROPERTIES,             -1,                          IDM_CONFIGURE,            CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_PROPERTIES"),        },
    { IDS_MENU_DISCONNECT,              IDS_MENU_TT_DISCONNECT,             -1,                          IDM_DISCONNECT,           CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 _T("IDS_MENU_DISCONNECT"),        },
    { IDS_MENU_BACKUP,                  IDS_MENU_TT_BACKUP,                 IDS_MENU_TT_BACKUP,          IDM_METABACKREST,         CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, NULL,                 NULL,                 _T("IDS_MENU_BACKUP"),        },
    { IDS_MENU_SHUTDOWN_IIS,            IDS_MENU_TT_SHUTDOWN_IIS,           -1,                          IDM_SHUTDOWN,             CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, NULL,                 NULL,                 _T("IDS_MENU_SHUTDOWN_IIS"),        },
    { IDS_MENU_SAVE_DATA,               IDS_MENU_TT_SAVE_DATA,              -1,                          IDM_SAVE_DATA,            CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, NULL,                 NULL,                 _T("IDS_MENU_SAVE_DATA"),        },
    { IDS_MENU_NEWVROOT,                IDS_MENU_TT_NEWVROOT,               IDS_MENU_DS_NEWVROOT,        IDM_NEW_VROOT,            CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWVROOT, RES_TASKPAD_NEWVROOT, _T("IDS_MENU_NEWVROOT"),        },
    { IDS_MENU_NEWINSTANCE,             IDS_MENU_TT_NEWINSTANCE,            IDS_MENU_DS_NEWINSTANCE,     IDM_NEW_INSTANCE,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  _T("IDS_MENU_NEWINSTANCE"),        },
    { IDS_MENU_NEWFTPSITE,              IDS_MENU_TT_NEWFTPSITE,             IDS_MENU_DS_NEWFTPSITE,      IDM_NEW_FTP_SITE,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  _T("IDS_MENU_NEWFTPSITE"),        },
    { IDS_MENU_NEWFTPSITE_FROMFILE,     IDS_MENU_TT_NEWFTPSITE_FROMFILE,    -1,                          IDM_NEW_FTP_SITE_FROM_FILE,CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, NULL,   NULL,   _T("IDS_MENU_NEWFTPSITE_FROMFILE"),        },
    { IDS_MENU_NEWFTPVDIR,              IDS_MENU_TT_NEWFTPVDIR,             IDS_MENU_DS_NEWFTPVDIR,      IDM_NEW_FTP_VDIR,          CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  _T("IDS_MENU_NEWFTPVDIR"),        },
    { IDS_MENU_NEWFTPVDIR_FROMFILE,     IDS_MENU_TT_NEWFTPVDIR_FROMFILE,    -1,                          IDM_NEW_FTP_VDIR_FROM_FILE,CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, NULL,   NULL,   _T("IDS_MENU_NEWFTPVDIR_FROMFILE"),        },
    { IDS_MENU_NEWWEBSITE,              IDS_MENU_TT_NEWWEBSITE,             IDS_MENU_DS_NEWWEBSITE,      IDM_NEW_WEB_SITE,          CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  _T("IDS_MENU_NEWWEBSITE"),        },
    { IDS_MENU_NEWWEBSITE_FROMFILE,     IDS_MENU_TT_NEWWEBSITE_FROMFILE,    -1,                          IDM_NEW_WEB_SITE_FROM_FILE,CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, NULL,   NULL,   _T("IDS_MENU_NEWWEBSITE_FROMFILE"),        },
    { IDS_MENU_NEWWEBVDIR,              IDS_MENU_TT_NEWWEBVDIR,             IDS_MENU_DS_NEWWEBVDIR,      IDM_NEW_WEB_VDIR,          CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  _T("IDS_MENU_NEWWEBVDIR"),        },
    { IDS_MENU_NEWWEBVDIR_FROMFILE,     IDS_MENU_TT_NEWWEBVDIR_FROMFILE,    -1,                          IDM_NEW_WEB_VDIR_FROM_FILE,CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, NULL,   NULL,   _T("IDS_MENU_NEWWEBVDIR_FROMFILE"),        },
    { IDS_MENU_NEWAPPPOOL,              IDS_MENU_TT_NEWAPPPOOL,             IDS_MENU_DS_NEWAPPPOOL,      IDM_NEW_APP_POOL,          CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  _T("IDS_MENU_NEWAPPPOOL"),        },
    { IDS_MENU_NEWAPPPOOL_FROMFILE,     IDS_MENU_TT_NEWAPPPOOL_FROMFILE,    -1,                          IDM_NEW_APP_POOL_FROM_FILE,CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, NULL,   NULL,   _T("IDS_MENU_NEWAPPPOOL_FROMFILE"),        },
    { IDS_MENU_TASKPAD,                 IDS_MENU_TT_TASKPAD,                -1,                          IDM_VIEW_TASKPAD,          CCM_INSERTIONPOINTID_PRIMARY_VIEW,0, NULL,                 NULL,                 _T("IDS_MENU_TASKPAD"),        },
    { IDS_MENU_EXPORT_CONFIG_WIZARD,    IDS_MENU_TT_EXPORT_CONFIG_WIZARD,   -1,                          IDM_TASK_EXPORT_CONFIG_WIZARD, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, NULL,   NULL,   _T("IDS_MENU_EXPORT_CONFIG_WIZARD"),        },
    { IDS_MENU_WEBEXT_CONTAINER_ADD1,              IDS_MENU_TT_WEBEXT_CONTAINER_ADD1,             -1,      IDM_WEBEXT_CONTAINER_ADD1,           CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_WEBEXT_CONTAINER_ADD1"),        },
    { IDS_MENU_WEBEXT_CONTAINER_ADD2,              IDS_MENU_TT_WEBEXT_CONTAINER_ADD2,             -1,      IDM_WEBEXT_CONTAINER_ADD2,           CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_WEBEXT_CONTAINER_ADD2"),        },
    { IDS_MENU_WEBEXT_CONTAINER_PROHIBIT_ALL,      IDS_MENU_TT_WEBEXT_CONTAINER_PROHIBIT_ALL,     -1,      IDM_WEBEXT_CONTAINER_PROHIBIT_ALL,   CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_WEBEXT_CONTAINER_PROHIBIT_ALL"),        },
    { IDS_MENU_WEBEXT_ALLOW,              IDS_MENU_TT_WEBEXT_ALLOW,             -1,      IDM_WEBEXT_ALLOW,           CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_WEBEXT_ALLOW"),        },
    { IDS_MENU_WEBEXT_PROHIBIT,           IDS_MENU_TT_WEBEXT_PROHIBIT,          -1,      IDM_WEBEXT_PROHIBIT,        CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_WEBEXT_PROHIBIT"),        },
//    { IDS_MENU_SERVICE_START, IDS_MENU_TT_SERVICE_START, -1, IDM_SERVICE_START, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_SERVICE_START"),        },
//    { IDS_MENU_SERVICE_STOP, IDS_MENU_TT_SERVICE_STOP, -1, IDM_SERVICE_STOP, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_SERVICE_STOP"),        },
//    { IDS_MENU_SERVICE_ENABLE, IDS_MENU_TT_SERVICE_ENABLE, -1, IDM_SERVICE_ENABLE, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, NULL,  NULL,  _T("IDS_MENU_SERVICE_ENABLE"),        },
};

/* static */ CComBSTR CIISObject::_bstrResult;
/* static */ CComBSTR CIISObject::_bstrLocalHost = _T("localhost");
/* static */ CComPtr<IComponent>        CIISObject::_lpComponent        = NULL;
/* static */ CComPtr<IComponentData>    CIISObject::_lpComponentData    = NULL;
/* static */ IToolbar * CIISObject::_lpToolBar          = NULL;
   

/* static */
HRESULT
CIISObject::SetImageList(
    IN LPIMAGELIST lpImageList
    )
/*++

Routine Description:

    Set the image list

Arguments:

    LPIMAGELIST lpImageList

Return Value:

    HRESULT

--*/
{
    HBITMAP hImage16 = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_INETMGR16));
    HBITMAP hImage32 = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_INETMGR32));
    ASSERT(hImage16 != NULL);
    ASSERT(hImage32 != NULL);
	HRESULT hr = S_OK;

	if (hImage16 != NULL && hImage32 != NULL)
	{
	    if (S_OK != lpImageList->ImageListSetStrip(
	        (LONG_PTR *)hImage16, 
	        (LONG_PTR *)hImage32, 
	        0, 
	        RGB_BK_IMAGES
	        ))
	    {
	        hr = E_UNEXPECTED;
	    }
		::DeleteObject(hImage16);
		::DeleteObject(hImage32);
	}
	else
	{
		hr = E_UNEXPECTED;
	}
    return hr;
}


IConsoleNameSpace * CIISObject::GetConsoleNameSpace()
{
    if (!_lpConsoleNameSpace)
    {
        // Our Machine node should this info for us.
        CIISObject * pMyMachine = GetMachineObject();
        if (pMyMachine)
        {
            if (pMyMachine != this)
            {
             _lpConsoleNameSpace = pMyMachine->GetConsoleNameSpace();
            }
        }
    }
    ASSERT(_lpConsoleNameSpace);
    return _lpConsoleNameSpace;
}

IConsole * CIISObject::GetConsole() 
{
    if (!_lpConsole)
    {
        // Our Machine node should this info for us.
        CIISObject * pMyMachine = GetMachineObject();
        if (pMyMachine)
        {
            if (pMyMachine != this)
            {
                _lpConsole = pMyMachine->GetConsole();
            }
        }
    }
    ASSERT(_lpConsole);
    return _lpConsole;
}


/* static */
void
CIISObject::BuildResultView(
    IN LPHEADERCTRL lpHeader,
    IN int cColumns,
    IN int * pnIDS,
    IN int * pnWidths
    )
/*++

Routine Description:

    Build the result view columns.

Routine Description:

    LPHEADERCTRL lpHeader   : Header control
    int cColumns            : Number of columns
    int * pnIDS             : Array of column header strings
    int * pnWidths          : Array of column widths

Routine Description:

    None

--*/
{
    ASSERT_READ_PTR(lpHeader);

    CComBSTR bstr;

    for (int n = 0; n < cColumns; ++n)
    {
        if (pnIDS[n] != 0)
        {
            VERIFY(bstr.LoadString(pnIDS[n]));
            lpHeader->InsertColumn(n, bstr, LVCFMT_LEFT, pnWidths[n]);
        }
    }
}


/* static */
CWnd * 
CIISObject::GetMainWindow(IConsole * pConsole)
/*++

Routine Description:

    Get a pointer to main window object.

Arguments:

    None

Return Value:

    Pointer to main window object.  This object is temporary and should not be
    cached.

--*/
{
    HWND hWnd;
    CWnd * pWnd = NULL;
    if (pConsole)
    {
        HRESULT hr = pConsole->GetMainWindow(&hWnd);
        if (SUCCEEDED(hr))
        {
            pWnd = CWnd::FromHandle(hWnd);
        }
    }
    return pWnd;
}



/* static */
HRESULT
CIISObject::AddMMCPage(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CPropertyPage * pPage
    )
/*++

Routine Description:

    Add MMC page to providers sheet.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Property sheet provider
    CPropertyPage * pPage               : Property page to add

Return:

    HRESULT

--*/
{
    ASSERT_READ_PTR(pPage);

    if (pPage == NULL)
    {
        TRACEEOLID("NULL page pointer passed to AddMMCPage");
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    PROPSHEETPAGE_LATEST pspLatest;
	ZeroMemory(&pspLatest, sizeof(PROPSHEETPAGE_LATEST));
    CopyMemory (&pspLatest, &pPage->m_psp, pPage->m_psp.dwSize);
    pspLatest.dwSize = sizeof(pspLatest);
    //
    // MFC Bug work-around.
    //
    MMCPropPageCallback(&pspLatest);

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pspLatest);
    if (hPage == NULL)
    {
        return E_UNEXPECTED;
    }

    return lpProvider->AddPage(hPage);
}

HRESULT 
CIISObject::GetProperty(
    LPDATAOBJECT pDataObject,
    BSTR szPropertyName,
    BSTR* pbstrProperty)
{
    CString strProperty;

    if (!_wcsicmp(L"CCF_HTML_DETAILS",szPropertyName))
    {
        // return back html/javascript into strProperty
		//*pbstrProperty = ::SysAllocString(strProperty);
    }
    else if (!_wcsicmp(L"CCF_DESCRIPTION",szPropertyName))
    {
        // Display data in Description field...
    }
    else
    {
        return S_FALSE; // unknown strPropertyName
    }

    return S_OK;
}


CIISObject::CIISObject()
    : m_hScopeItem(NULL),
    m_use_count(0),
    m_hResultItem(0),
    m_fSkipEnumResult(FALSE),
    m_fFlaggedForDeletion(FALSE),
    m_hwnd(NULL),
    m_ppHandle(NULL)
{
	m_fIsExtension = FALSE;
#if defined(_DEBUG) || DBG
	// Add to the global list of CIISObjects
	// and keep track of it.
	g_Debug_IISObject.Add(this);
#endif
}

CIISObject::~CIISObject()
{
#if defined(_DEBUG) || DBG
	// Add to the global list of CIISObjects
	// and keep track of it.
	g_Debug_IISObject.Del(this);
#endif
}

/* virtual */
HRESULT
CIISObject::ControlbarNotify(
    IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg, 
    IN LPARAM param
    )
/*++

Routine Description:

    Handle control bar notification messages, such as select or click.

Arguments:

    MMC_NOTIFY_TYPE event       : Notification message
    long arg                    : Message specific argument
    long param                  : Message specific parameter

Return Value:

    HRESULT

--*/
{
    BOOL fSelect = (BOOL)HIWORD(arg);
    BOOL fScope  = (BOOL)LOWORD(arg); 
    HRESULT hr = S_OK;

    switch(event)
    {
    case MMCN_SELECT:
        {
            //
            // Handle selection of this node by attaching the toolbar
            // and enabling/disabling specific buttons
            //
		    _lpToolBar = (IToolbar *) (* (LPUNKNOWN *) param);
			if (_lpToolBar)
			{
				SetToolBarStates(_lpToolBar);
			}
        }
        break;

    case MMCN_BTN_CLICK:
        //
        // Handle button-click by passing the command ID of the 
        // button to the command handler
        //
        hr = Command((long)param, NULL, fScope ? CCT_SCOPE : CCT_RESULT);
        break;

    case MMCN_HELP:
        break;

    default:
        ASSERT_MSG("Invalid control bar notification received");
    };

    return hr;
}



/* virtual */
HRESULT
CIISObject::SetToolBarStates(CComPtr<IToolbar> lpToolBar)
/*++

Routine Description:

    Set the toolbar states depending on the state of this object

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if (lpToolBar)
    {
        lpToolBar->SetButtonState(IDM_CONNECT, ENABLED,       IsConnectable());
        lpToolBar->SetButtonState(IDM_PAUSE,   ENABLED,       IsPausable());
        lpToolBar->SetButtonState(IDM_START,   ENABLED,       IsStartable());
        lpToolBar->SetButtonState(IDM_STOP,    ENABLED,       IsStoppable());
        lpToolBar->SetButtonState(IDM_PAUSE,   BUTTONPRESSED, IsPaused());
    }
    return S_OK;
}



HRESULT 
CIISObject::GetScopePaneInfo(
    IN OUT LPSCOPEDATAITEM lpScopeDataItem
    )
/*++

Routine Description:

    Return information about scope pane.

Arguments:

    LPSCOPEDATAITEM lpScopeDataItem  : Scope data item

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_WRITE_PTR(lpScopeDataItem);

    if (lpScopeDataItem->mask & SDI_STR)
    {
        lpScopeDataItem->displayname = QueryDisplayName();
    }

    if (lpScopeDataItem->mask & SDI_IMAGE)
    {
        lpScopeDataItem->nImage = QueryImage();
    }

    if (lpScopeDataItem->mask & SDI_OPENIMAGE)
    {
        lpScopeDataItem->nOpenImage = QueryImage();
    }

    if (lpScopeDataItem->mask & SDI_PARAM)
    {
        lpScopeDataItem->lParam = (LPARAM)this;
    }

    if (lpScopeDataItem->mask & SDI_STATE)
    {
        //
        // BUGBUG: Wotz all this then?
        //
        ASSERT_MSG("State requested");
        lpScopeDataItem->nState = 0;
    }

    //
    // TODO : Add code for SDI_CHILDREN 
    //
    return S_OK;
}



/* virtual */
int 
CIISObject::CompareScopeItem(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Standard comparison method to compare lexically on display name.
    Derived classes should override if anything other than lexical 
    sort on the display name is required.

Arguments:

    CIISObject * pObject : Object to compare against

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Else sort lexically on the display name.
    //
    return ::lstrcmpi(QueryDisplayName(), pObject->QueryDisplayName());
}



/* virtual */
int 
CIISObject::CompareResultPaneItem(
    IN CIISObject * pObject, 
    IN int nCol
    )
/*++

Routine Description:

    Compare two CIISObjects on sort item criteria

Arguments:

    CIISObject * pObject : Object to compare against
    int nCol             : Column number to sort on

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    if (nCol == 0)
    {
        return CompareScopeItem(pObject);
    }

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Sort lexically on column text
    //
    return ::lstrcmpi(
        GetResultPaneColInfo(nCol), 
        pObject->GetResultPaneColInfo(nCol)
        );
}



HRESULT 
CIISObject::GetResultPaneInfo(LPRESULTDATAITEM lpResultDataItem)
/*++

Routine Description:

    Get information about result pane item

Arguments:

    LPRESULTDATAITEM lpResultDataItem   : Result data item

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_WRITE_PTR(lpResultDataItem);

    if (lpResultDataItem->mask & RDI_STR)
    {
        lpResultDataItem->str = GetResultPaneColInfo(lpResultDataItem->nCol);
    }

    if (lpResultDataItem->mask & RDI_IMAGE)
    {
        lpResultDataItem->nImage = QueryImage();
    }

    if (lpResultDataItem->mask & RDI_PARAM)
    {
        lpResultDataItem->lParam = (LPARAM)this;
    }

    if (lpResultDataItem->mask & RDI_INDEX)
    {
        //
        // BUGBUG: Wotz all this then?
        //
        ASSERT_MSG("INDEX???");
        lpResultDataItem->nIndex = 0;
    }

    return S_OK;
}



/* virtual */
LPOLESTR 
CIISObject::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    if (nCol == 0)
    {
        return QueryDisplayName();
    }

    ASSERT_MSG("Override GetResultPaneColInfo");

    return OLESTR("Override GetResultPaneColInfo");
}



/* virtual */
HRESULT
CIISObject::GetResultViewType(
    OUT LPOLESTR * lplpViewType,
    OUT long * lpViewOptions
    )
/*++

Routine Description:

    Tell MMC what our result view looks like

Arguments:

    BSTR * lplpViewType   : Return view type here
    long * lpViewOptions  : View options

Return Value:

    S_FALSE to use default view type, S_OK indicates the
    view type is returned in *ppViewType

--*/
{
    *lplpViewType  = NULL;
    *lpViewOptions = MMC_VIEW_OPTIONS_USEFONTLINKING;
    //
    // Default View
    //
    return S_FALSE;
}



/* virtual */
HRESULT
CIISObject::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT

--*/
{
    CComQIPtr<IPropertySheetProvider, &IID_IPropertySheetProvider> sp(GetConsole());
    CError err = sp->FindPropertySheet(
        reinterpret_cast<MMC_COOKIE>(this),
        0,
        (LPDATAOBJECT)this);
    if (err == S_OK)
    {
        return S_FALSE;
    }
	return S_OK;
}



/* virtual */
HRESULT    
CIISObject::QueryPagesFor(
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Check to see if a property sheet should be brought up for this data
    object

Arguments:

    DATA_OBJECT_TYPES type      : Data object type

Return Value:

    S_OK, if properties may be brought up for this item, S_FALSE otherwise

--*/
{
    return IsConfigurable() ? S_OK : S_FALSE;
}



/* virtual */
CIISRoot * 
CIISObject::GetRoot()
/*++

Routine Description:

    Get the CIISRoot object of this tree.

Arguments:

    None

Return Value:

    CIISRoot * or NULL

--*/
{
    ASSERT(!m_fIsExtension);
    LONG_PTR cookie;
    HSCOPEITEM hParent;    
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();

    HRESULT hr = pConsoleNameSpace->GetParentItem(m_hScopeItem, &hParent, &cookie);
    if (SUCCEEDED(hr))
    {
        CIISMBNode * pNode = (CIISMBNode *)cookie;
        ASSERT_PTR(pNode);
        ASSERT_PTR(hParent);

        if (pNode)
        {
            return pNode->GetRoot();
        }
    }

    ASSERT_MSG("Unable to find CIISRoot object!");

    return NULL;
}



HRESULT
CIISObject::AskForAndAddMachine()
/*++

Routine Description:

    Ask user to add a computer name, verify the computer is alive, and add it to 
    the list.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	// ensure the dialog gets themed
	CThemeContextActivator activator(theApp.GetFusionInitHandle());

    ConnectServerDlg dlg(GetConsoleNameSpace(),GetConsole(),GetMainWindow(GetConsole()));

    if (dlg.DoModal() == IDOK)
    {
        CIISMachine * pMachine = dlg.GetMachine();

        //
        // The machine object we get from the dialog
        // is guaranteed to be good and valid.
        //
        ASSERT_PTR(pMachine);
        ASSERT(pMachine->HasInterface());

        CIISRoot * pRoot = GetRoot();

        if (pRoot)
        {
            pMachine->SetConsoleData(pRoot->GetConsoleNameSpace(),pRoot->GetConsole());
            //
            // Add new machine object as child of the IIS root
            // object.  
            //
            if (pRoot->m_scServers.Add(pMachine))
            {
				pMachine->AddRef();
                err = pMachine->AddToScopePaneSorted(pRoot->QueryScopeItem());
                if (err.Succeeded())
                {
                    //
                    // Select the item in the scope view
                    //
                    err = pMachine->SelectScopeItem();
                }
            }
            else
            {
                //
                // Duplicate machine already in cache.  Find it and select
                // it.
                //
                TRACEEOLID("Machine already in scope view.");
                CIISObject * pIdentical = pRoot->FindIdenticalScopePaneItem(pMachine);
                //
                // Duplicate must exist!
                //
                ASSERT_READ_PTR(pIdentical);

                if (pIdentical)
                {
                    err = pIdentical->SelectScopeItem();
                }

                pMachine->Release();
            }
        }
    }

    return err;
}



/* static */
HRESULT
CIISObject::AddMenuItemByCommand(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN LONG lCmdID,
    IN LONG fFlags
    )
/*++

Routine Description:

    Add menu item by command

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Callback pointer
    LONG lCmdID                                 : Command ID
    LONG fFlags                                 : Flags

Return Value:

    HRESULT

--*/
{
    BOOL bAdded = FALSE;
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Offset 1 menu commands
    //
    LONG l = lCmdID -1;

    CComBSTR strName;
    CComBSTR strStatus;

    VERIFY(strName.LoadString(_menuItemDefs[l].nNameID));
    VERIFY(strStatus.LoadString(_menuItemDefs[l].nStatusID));

    // Try to use IContextMenuCallback2 because of language independent string 
    CONTEXTMENUITEM2 contextmenuitem;
    IContextMenuCallback2*	pIContextMenuCallback2 = NULL;
    HRESULT hr = lpContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (void**)&pIContextMenuCallback2);
    if(hr == S_OK && pIContextMenuCallback2 != NULL)
    {
        ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
        contextmenuitem.strName = strName;
        contextmenuitem.strStatusBarText = strStatus;
        contextmenuitem.lCommandID = _menuItemDefs[l].lCmdID;
        contextmenuitem.lInsertionPointID = _menuItemDefs[l].lInsertionPointID;
        contextmenuitem.fFlags = fFlags;
        contextmenuitem.fSpecialFlags = _menuItemDefs[l].fSpecialFlags;
        // Here is the language independent ID
        // We must use this to refer to the Menu item otherwise we will have problems in every language (mainly far east (FE) languages.
        contextmenuitem.strLanguageIndependentName = (LPWSTR) _menuItemDefs[l].lpszLanguageIndenpendentID;
        hr = pIContextMenuCallback2->AddItem( &contextmenuitem );
        if( hr == S_OK)
        {
            bAdded = TRUE;
        }
        pIContextMenuCallback2->Release();
        pIContextMenuCallback2 = NULL;
    }

    if (!bAdded)
    {
        CONTEXTMENUITEM cmi;
        cmi.strName = strName;
        cmi.strStatusBarText = strStatus;
        cmi.lCommandID = _menuItemDefs[l].lCmdID;
        cmi.lInsertionPointID = _menuItemDefs[l].lInsertionPointID;
        cmi.fFlags = fFlags;
        cmi.fSpecialFlags = _menuItemDefs[l].fSpecialFlags;
        hr = lpContextMenuCallback->AddItem(&cmi);
    }

    return hr;
}



/* static */ 
HRESULT 
CIISObject::AddMenuSeparator(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN LONG lInsertionPointID
    )
/*++

Routine Description:

    Add a separator to the given insertion point menu.

Arguments:
    
    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Callback pointer
    LONG lInsertionPointID                      : Insertion point menu id.

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    CONTEXTMENUITEM menuSep = 
    {
        NULL,
        NULL,
        -1,
        lInsertionPointID,
        0,
        CCM_SPECIAL_SEPARATOR
    };

    return lpContextMenuCallback->AddItem(&menuSep);
}



BOOL 
CIISObject::IsExpanded() const
/*++

Routine Description:

    Determine if this object has been expanded.

Arguments:

    None

Return Value:

    TRUE if the node has been expanded,
    FALSE if it has not.

--*/
{
    ASSERT(m_hScopeItem != NULL);
    SCOPEDATAITEM  scopeDataItem;
    CIISObject * ThisConst = (CIISObject *)this;

    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *) ThisConst->GetConsoleNameSpace();

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = SDI_STATE;
        
    scopeDataItem.ID = m_hScopeItem;
    
    HRESULT hr = pConsoleNameSpace->GetItem(&scopeDataItem);

    return SUCCEEDED(hr) && 
        scopeDataItem.nState == MMC_SCOPE_ITEM_STATE_EXPANDEDONCE;
}


CIISObject *
CIISObject::FindIdenticalScopePaneItem(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Find CIISObject in the scope view.  The scope view is assumed
    to be sorted.

Arguments:

    CIISObject * pObject    : Item to search for

Return Value:

    Pointer to iis object, or NULL if the item was not found

Notes:

    Note that any item with a 0 comparison value is returned, not
    necessarily the identical CIISObject.

--*/
{
    ASSERT(m_hScopeItem != NULL);

    //
    // Find proper insertion point
    //
    HSCOPEITEM hChildItem = NULL;
    CIISObject * pReturn = NULL;
    CIISObject * pItem;
    LONG_PTR cookie;
    int  nSwitch;
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();

    HRESULT hr = pConsoleNameSpace->GetChildItem(
        m_hScopeItem, &hChildItem, &cookie);

    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ASSERT_PTR(pItem);

        nSwitch = pItem->CompareScopeItem(pObject);

        if (nSwitch == 0)
        {
            //
            // Found it.
            //
            pReturn = pItem;
        }

        if (nSwitch > 0)
        {
            //
            // Should have found it by now.
            //
            break;
        }

        //
        // Advance to next child of same parent
        //
        hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    return pReturn;
}



/* virtual */
HRESULT
CIISObject::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Add menu items to the context menu

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Context menu callback
    long * pInsertionAllowed                    : Insertion allowed
    DATA_OBJECT_TYPES type                      : Object type

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    ASSERT(pInsertionAllowed != NULL);
    if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0)
	{
		if (IsConnectable() && !m_fIsExtension)
		{
			AddMenuItemByCommand(lpContextMenuCallback, IDM_CONNECT);
		}

		if (IsDisconnectable() && !m_fIsExtension)
		{
			ASSERT(IsConnectable());
			AddMenuItemByCommand(lpContextMenuCallback, IDM_DISCONNECT);    
		}

        // Check if it should be disabled...
        BOOL bHasFiles = HasFileSystemFiles();
		if (IsExplorable())
		{
            AddMenuSeparator(lpContextMenuCallback);
            AddMenuItemByCommand(lpContextMenuCallback, IDM_EXPLORE, bHasFiles ? 0 : MF_GRAYED);
		}
               
		if (IsOpenable())
		{
			AddMenuItemByCommand(lpContextMenuCallback, IDM_OPEN, bHasFiles ? 0 : MF_GRAYED);
		}

		if (IsPermissionable())
		{
			AddMenuItemByCommand(lpContextMenuCallback, IDM_PERMISSION, bHasFiles ? 0 : MF_GRAYED);
		}

		if (IsBrowsable())
		{
			AddMenuItemByCommand(lpContextMenuCallback, IDM_BROWSE);
		}

		if (IsControllable())
		{
			AddMenuSeparator(lpContextMenuCallback);

			UINT nPauseFlags = IsPausable() ? 0 : MF_GRAYED;

			if (IsPaused())
			{
				nPauseFlags |= MF_CHECKED;
			}

			AddMenuItemByCommand(lpContextMenuCallback, IDM_START,  IsStartable() ? 0 : MF_GRAYED);
			AddMenuItemByCommand(lpContextMenuCallback, IDM_STOP,   IsStoppable() ? 0 : MF_GRAYED);
			AddMenuItemByCommand(lpContextMenuCallback, IDM_PAUSE,  nPauseFlags);
		}

#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Dump(2);
#endif

#if defined(_DEBUG) || DBG	
    CIISObject * pOpenItem = NULL;
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
    g_OpenPropertySheetTracker.IsPropertySheetOpenBelowMe(pConsoleNameSpace,this,&pOpenItem);
#endif

	}

    return S_OK;
}



/* virtual */
HRESULT
CIISObject::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * lpObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * lpObj   : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    switch (lCommandID)
    {
    case IDM_CONNECT:
        hr = AskForAndAddMachine();
        break;
    }

    return hr;
}


#if defined(_DEBUG) || DBG

LPCTSTR
ParseEvent(MMC_NOTIFY_TYPE event)
{
    LPCTSTR p = NULL;
    switch (event)
    {
    case MMCN_ACTIVATE: p = _T("MMCN_ACTIVATE"); break;
    case MMCN_ADD_IMAGES: p = _T("MMCN_ADD_IMAGES"); break;
    case MMCN_BTN_CLICK: p = _T("MMCN_BTN_CLICK"); break;
    case MMCN_CLICK: p = _T("MMCN_CLICK"); break;
    case MMCN_COLUMN_CLICK: p = _T("MMCN_COLUMN_CLICK"); break;
    case MMCN_CONTEXTMENU: p = _T("MMCN_CONTEXTMENU"); break;
    case MMCN_CUTORMOVE: p = _T("MMCN_CUTORMOVE"); break;
    case MMCN_DBLCLICK: p = _T("MMCN_DBLCLICK"); break;
    case MMCN_DELETE: p = _T("MMCN_DELETE"); break;
    case MMCN_DESELECT_ALL: p = _T("MMCN_DESELECT_ALL"); break;
    case MMCN_EXPAND: p = _T("MMCN_EXPAND"); break;
    case MMCN_HELP: p = _T("MMCN_HELP"); break;
    case MMCN_MENU_BTNCLICK: p = _T("MMCN_MENU_BTNCLICK"); break;
    case MMCN_MINIMIZED: p = _T("MMCN_MINIMIZED"); break;
    case MMCN_PASTE: p = _T("MMCN_PASTE"); break;
    case MMCN_PROPERTY_CHANGE: p = _T("MMCN_PROPERTY_CHANGE"); break;
    case MMCN_QUERY_PASTE: p = _T("MMCN_QUERY_PASTE"); break;
    case MMCN_REFRESH: p = _T("MMCN_REFRESH"); break;
    case MMCN_REMOVE_CHILDREN: p = _T("MMCN_REMOVE_CHILDREN"); break;
    case MMCN_RENAME: p = _T("MMCN_RENAME"); break;
    case MMCN_SELECT: p = _T("MMCN_SELECT"); break;
    case MMCN_SHOW: p = _T("MMCN_SHOW"); break;
    case MMCN_VIEW_CHANGE: p = _T("MMCN_VIEW_CHANGE"); break;
    case MMCN_SNAPINHELP: p = _T("MMCN_SNAPINHELP"); break;
    case MMCN_CONTEXTHELP: p = _T("MMCN_CONTEXTHELP"); break;
    case MMCN_INITOCX: p = _T("MMCN_INITOCX"); break;
    case MMCN_FILTER_CHANGE: p = _T("MMCN_FILTER_CHANGE"); break;
    case MMCN_FILTERBTN_CLICK: p = _T("MMCN_FILTERBTN_CLICK"); break;
    case MMCN_RESTORE_VIEW: p = _T("MMCN_RESTORE_VIEW"); break;
    case MMCN_PRINT: p = _T("MMCN_PRINT"); break;
    case MMCN_PRELOAD: p = _T("MMCN_PRELOAD"); break;
    case MMCN_LISTPAD: p = _T("MMCN_LISTPAD"); break;
    case MMCN_EXPANDSYNC: p = _T("MMCN_EXPANDSYNC"); break;
    case MMCN_COLUMNS_CHANGED: p = _T("MMCN_COLUMNS_CHANGED"); break;
    case MMCN_CANPASTE_OUTOFPROC: p = _T("MMCN_CANPASTE_OUTOFPROC"); break;
    default: p = _T("Unknown"); break;
    }
    return p;
}

#endif

extern HRESULT
GetHelpTopic(LPOLESTR *lpCompiledHelpFile);

void CIISObject::DoRunOnce(
	IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg,
    IN LPARAM param
	)
{
	static bActivateCalled = FALSE;
	static iSelectionCount = 0;

    switch (event)
    {
	case MMCN_ACTIVATE:
		{
			bActivateCalled = TRUE;
		}
	case MMCN_SHOW:
		{
			if (!(g_dwInetmgrParamFlags & INETMGR_PARAM_RUNONCE_HAPPENED))
			{
				// only on the Root node
				if (IsEqualGUID(* (GUID *) GetNodeType(),cInternetRootNode))
				{
					// This RunOnce thing will only work
					// if we select the container twice...
					//
					// after the second selection (which is really the 2nd MMCN_SHOW for the root item)
					// it will stick....
					//
					// and this will only also work when the additonal runonce code in 
					// CIISRoot::EnumerateScopePane is executed...
					if (bActivateCalled && iSelectionCount <= 1)
					{
						CIISRoot * pRoot = (CIISRoot *) this;
						if (pRoot)
						{
							CIISMachine * pMach = pRoot->m_scServers.GetFirst();
							if (pMach)
							{
								if (pMach->IsLocal())
								{
									CWebServiceExtensionContainer * pContainer = pMach->QueryWebSvcExtContainer();
									if (pContainer)
									{
										if ((BOOL)arg)
										{
											pContainer->SelectScopeItem();
											iSelectionCount++;
										}
									}
								}
							}
						}

						if (iSelectionCount > 1)
						{
							// Set the flag to say we did runonce already!
							SetInetmgrParamFlag(INETMGR_PARAM_RUNONCE_HAPPENED,TRUE);
						}
					}
				}
			}
		}
		break;

	default:
		break;
	}

	return;
}

HRESULT 
CIISObject::Notify(
    IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg,
    IN LPARAM param,
    IN IComponentData * lpComponentData,
    IN IComponent * lpComponent,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Notification handler

Arguments:

    MMC_NOTIFY_TYPE event               : Notification type
    long arg                            : Event-specific argument
    long param                          : Event-specific parameter
    IComponentData * pComponentData     : IComponentData
    IComponent * pComponent             : IComponent
    DATA_OBJECT_TYPES type              : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	if (g_iDebugOutputLevel & DEBUG_FLAG_MMC_NOTIFY)
	{
		TRACEEOL("CIISObject::Notify -> " << ParseEvent(event));
	}

    static BOOL s_bLastEventSel = FALSE;

    CError err(E_NOTIMPL);
    ASSERT(lpComponentData != NULL || lpComponent != NULL);

//   CComPtr<IConsole> lpConsole;
    IConsole * lpConsole;
    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> lpHeader;
    CComQIPtr<IResultData, &IID_IResultData> lpResultData;

    // Cache the passed in pointers
    _lpComponent = lpComponent;
    _lpComponentData = lpComponentData;

    if (lpComponentData != NULL)
    {
        lpConsole = ((CInetMgr *)lpComponentData)->m_spConsole;
    }
    else
    {
        lpConsole = ((CInetMgrComponent *)lpComponent)->m_spConsole;
    }

    lpHeader = lpConsole;
    lpResultData = lpConsole;

#if defined(_DEBUG) || DBG	
	if (g_iDebugOutputLevel & DEBUG_FLAG_MMC_NOTIFY)
	{
		SCOPEDATAITEM si;
		::ZeroMemory(&si, sizeof(SCOPEDATAITEM));
		si.mask = SDI_PARAM;
		si.ID = m_hScopeItem;
		IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
		if (SUCCEEDED(pConsoleNameSpace->GetItem(&si)))
		{
			CIISObject * pNode = (CIISObject *)si.lParam;
			DumpFriendlyName(pNode);
		}
	}
#endif

    switch (event)
    {

	case MMCN_ACTIVATE:
		if (!(g_dwInetmgrParamFlags & INETMGR_PARAM_RUNONCE_HAPPENED))
		{
			DoRunOnce(event,arg,param);
		}
		err = S_OK;
		break;

    case MMCN_PROPERTY_CHANGE:
//	    err = OnPropertyChange((BOOL)arg, lpResultData);
        TRACEEOLID("MMCN_PROPERTY_CHANGE");
	    break;
    case MMCN_SHOW:
        // The notification is sent to the snap-in's IComponent implementation 
        // when a scope item is selected or deselected. 
        //
        // arg: TRUE if selecting. Indicates that the snap-in should set up the 
        //      result pane and add the enumerated items. FALSE if deselecting. 
        //      Indicates that the snap-in is going out of focus and that it 
        //      should clean up all result item cookies, because the current 
        //      result pane will be replaced by a new one. 
        // param: The HSCOPEITEM of the selected or deselected item. 
		if (m_fSkipEnumResult)
		{
			m_fSkipEnumResult = FALSE;
		}
		else
		{
			if (!m_fFlaggedForDeletion)
			{
				if (IsEqualGUID(* (GUID *) GetNodeType(),cWebServiceExtensionContainer))
				{
					CWebServiceExtensionContainer * pTemp = (CWebServiceExtensionContainer *) this;
					if (pTemp)
					{
						err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,pTemp,FALSE,METABASE_PATH_FOR_RESTRICT_LIST);
					}
					if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
					{
						// if the Metabase is reconnected in EnumerateResultPane() during MMCN_SHOW
						// then it will be hosed.  don't enumerate this node
						// and just let user hit refresh.
						// create the column headers at least
						err = CIISObject::EnumerateResultPane((BOOL)arg, lpHeader, lpResultData);
					}
					else
					{
						EnumerateResultPane((BOOL)arg, lpHeader, lpResultData);
					}
				}
				else
				{
					EnumerateResultPane((BOOL)arg, lpHeader, lpResultData);
				}
				
			}
		}
		if (!(g_dwInetmgrParamFlags & INETMGR_PARAM_RUNONCE_HAPPENED))
		{
			// Call runonce during the MMCN_SHOW
			DoRunOnce(event,arg,param);
		}
		// Fail code will prevent MMC from enabling verbs
        err.Reset();
        break;
    case MMCN_EXPAND:
    {
#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Dump(0);
#endif
        CWaitCursor wait;
		if (!m_fFlaggedForDeletion)
		{
			err = EnumerateScopePane((HSCOPEITEM)param);
		}
    }
        break;
    case MMCN_ADD_IMAGES:
        // The MMCN_ADD_IMAGES notification is sent to the snap-in's IComponent
        // implementation to add images for the result pane. 
        //
        // lpDataObject: [in] Pointer to the data object of the currently selected scope item. 
        // arg: Pointer to the result pane's image list (IImageList). 
        //      This pointer is valid only while the specific MMCN_ADD_IMAGES notification is 
        //      being processed and should not be stored for later use. Additionally, the 
        //      snap-in must not call the Release method of IImageList because MMC is responsible
        //      for releasing it. 
        // param: Specifies the HSCOPEITEM of the currently selected scope item. The snap-in 
        //        can use this parameter to add images that apply specifically to the result
        //        items of this scope item, or the snap-in can ignore this parameter and add 
        //        all possible images. 
        err = AddImages((LPIMAGELIST)arg);
        break;
    case MMCN_DELETE:
	    err = DeleteNode(lpResultData);
        break;
    
    case MMCN_REMOVE_CHILDREN:

#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Dump(0);
#endif
        err = DeleteChildObjects((HSCOPEITEM)arg);
        break;

    case MMCN_VIEW_CHANGE:
        // The MMCN_VIEW_CHANGE notification message is sent to the snap-in's 
        // IComponent implementation so it can update the view when a change occurs.
        // This notification is generated when the snap-in (IComponent or IComponentData)
        // calls IConsole2::UpdateAllViews.
        //
        // lpDataObject: [in] Pointer to the data object passed to IConsole::UpdateAllViews. 
        // arg: [in] The data parameter passed to IConsole::UpdateAllViews. 
        // param: [in] The hint parameter passed to IConsole::UpdateAllViews. 
		err = OnViewChange(type == CCT_SCOPE, lpResultData, lpHeader, (DWORD) param);
		break;

    case MMCN_REFRESH:
        {
        // The MMCN_REFRESH notification message is sent to a snap-in's IComponent 
        // implementation when the refresh verb is selected. Refresh can be invoked 
        // through the context menu, through the toolbar, or by pressing F5.
        //
        // lpDataObject: [in] Pointer to the data object of the currently selected scope item. 
        // arg: Not used. 
        // param: Not used. 

        // Refresh current node, and re-enumerate
        // child nodes of the child nodes had previously
        // been expanded.

        // check if we're doing the IISMachine Node...
        if (IsEqualGUID(* (GUID *) GetNodeType(),cMachineNode))
        {
            CIISObject * pOpenItem = NULL;
            if (g_OpenPropertySheetTracker.IsPropertySheetOpenComputer(this,FALSE,&pOpenItem))
            {
                g_OpenPropertySheetTracker.Dump();
                if (pOpenItem)
                {
                    HWND hHwnd = pOpenItem->IsMyPropertySheetOpen();
                    // a property sheet is open somewhere..
                    // make sure they close it before proceeding with refresh...
                    // Highlight the property sheet.
                    if (hHwnd && (hHwnd != (HWND) 1))
                    {
                        DoHelpMessageBox(NULL,IDS_CLOSE_ALL_PROPERTY_SHEET_REFRESH, MB_OK | MB_ICONINFORMATION, 0);

                        if (!SetForegroundWindow(hHwnd))
                        {
                            // wasn't able to bring this property sheet to
                            // the foreground, the propertysheet must not
                            // exist anymore.  let's just clean the hwnd
                            // so that the user will be able to open propertysheet
                            pOpenItem->SetMyPropertySheetOpen(0);
                        }
                        break;
                    }
                }
            }
        }


        BOOL fReEnumerate = (!IsLeafNode() && IsExpanded());
        if (fReEnumerate)
        {
            // Look for all of the open property sheets that are a child of
            // this node, and orphan it (erase it's scope/result item info)
            // so that it doesn't send a MMCNotify if the user hits ok 
            // (since there is nothing to update anyways and this MMCNotify cause AV).
            IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
            INT iOrphans = g_OpenPropertySheetTracker.OrphanPropertySheetsBelowMe(pConsoleNameSpace,this,TRUE);
        }
        err = Refresh(fReEnumerate);
	    if (err.Succeeded() && HasResultItems(lpResultData))
	    {
            err = CleanResult(lpResultData);
			if (err.Succeeded())
			{
				// We should use fForRefresh = TRUE here, because MMC will add extra
				// columns on refresh when result pane doesn't contain scope items.
				if (!m_fFlaggedForDeletion)
				{
					err = EnumerateResultPane(TRUE, lpHeader, lpResultData, TRUE);
				}
			}
		}

        {
		    // refresh the verbs
		    ASSERT_PTR(lpConsole);
		    CComPtr<IConsoleVerb> lpConsoleVerb;
		    lpConsole->QueryConsoleVerb(&lpConsoleVerb);
		    ASSERT_PTR(lpConsoleVerb);
		    if (lpConsoleVerb)
		    {
			    err = SetStandardVerbs(lpConsoleVerb);
		    }

            // Refresh() will clean out the scope item
            // Reselect the refreshed item.
            if (!s_bLastEventSel)
            {
                // if the last selection event
                // was not ended upon a "selection" but rather a "deselection"
                // make force a selection...
                SelectScopeItem();
            }
        }

#if defined(_DEBUG) || DBG	
	// check if we leaked anything.
	g_Debug_IISObject.Dump(2);
#endif
        }
        break;

    case MMCN_SELECT:
        {
            // The MMCN_SELECT notification is sent to the snap-in's IComponent::Notify
            // or IExtendControlbar::ControlbarNotify method when an item is selected in 
            // either the scope pane or result pane.
            //
            // lpDataObject: [in] Pointer to the data object of the currently 
            //               selected/deselected scope pane or result item. 
            // arg: BOOL bScope = (BOOL) LOWORD(arg); BOOL bSelect = (BOOL) HIWORD(arg); 
            //      bScope is TRUE if the selected item is a scope item, or FALSE if 
            //      the selected item is a result item. For bScope = TRUE, MMC does 
            //      not provide information about whether the scope item is selected 
            //      in the scope pane or in the result pane. bSelect is TRUE if the 
            //      item is selected, or FALSE if the item is deselected.
            // param: ignored. 

#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Dump(0);
#endif
            BOOL bScope = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);
            s_bLastEventSel = bSelect;
            err.Reset();

			//
			// Item has been selected -- set verb states
			//
            if (bSelect)
            {
                SetToolBarStates(_lpToolBar);

			    ASSERT_PTR(lpConsole);
			    CComPtr<IConsoleVerb> lpConsoleVerb;
			    lpConsole->QueryConsoleVerb(&lpConsoleVerb);
			    ASSERT_PTR(lpConsoleVerb);
			    if (lpConsoleVerb)
			    {
				    err = SetStandardVerbs(lpConsoleVerb);
			    }

                if (IsEqualGUID(* (GUID *) GetNodeType(),cWebServiceExtensionContainer))
                {
                    ForceReportMode(lpResultData);
                }

			    // if it's the service node, 
			    // check if we need to update it's icon (started/stopped)
			    if (IsEqualGUID(* (GUID *) GetNodeType(),cServiceCollectorNode))
			    {
				    CIISService * pTemp = (CIISService *) this;
				    // Don't do this on every selection.
				    // The SMTP/NNTP nodes require user to select refresh
				    // to get the latest status of the server
				    // we don't want to stray too far from they're behavior
				    // otherwise, the user might think it should be that
				    // way for SMTP/NNTP as well...
				    pTemp->GetServiceState(); // ahh well...
				    if (pTemp->m_dwServiceStateDisplayed != pTemp->m_dwServiceState)
				    {
					    pTemp->RefreshDisplay(FALSE);
                        RefreshDisplay();
				    }
			    }
            }
        }
        break;
    case MMCN_RENAME:
       err = RenameItem((LPOLESTR)param);
       break;
    case MMCN_DBLCLICK:
       // The MMCN_DBLCLICK notification is sent to the snap-in's IComponent 
       // implementation when a user double-clicks a mouse button on a list 
       // view item or on a scope item in the result pane. Pressing enter 
       // while the list item or scope item has focus in the list view also 
       // generates an MMCN_DBLCLICK notification message.
       //
       // lpDataObject: [in] Pointer to the data object of the currently selected item. 
       // arg: Not used. 
       // param: Not used. 
       err = OnDblClick(lpComponentData, lpComponent);
       break;
	case MMCN_COLUMNS_CHANGED:
	   err = ChangeVisibleColumns((MMC_VISIBLE_COLUMNS *)param);
	   break;
	case MMCN_CONTEXTHELP:
       {
            LPOLESTR pCompiledHelpFile = NULL;
            CError err(E_NOTIMPL);
            err = GetHelpTopic(&pCompiledHelpFile);
            if (err.Succeeded())
            {
                IDisplayHelp * pdh;
	            err = lpConsole->QueryInterface(IID_IDisplayHelp, (void **)&pdh);
                if (err.Succeeded())
                {
                    CString strDefault;
                    CString strHtmlPage;
	                CString topic = ::PathFindFileName(pCompiledHelpFile);

                    strDefault = GLOBAL_DEFAULT_HELP_PATH ;
                    if (SUCCEEDED(GetContextHelp(strHtmlPage)))
                    {
                        if (!strHtmlPage.IsEmpty())
                        {
                            strDefault = strHtmlPage;
                        }
                    }
                    topic += strDefault;

	                LPTSTR p = topic.GetBuffer(topic.GetLength());
                    err = pdh->ShowTopic(p);
	                topic.ReleaseBuffer();
                    pdh->Release();
                }
            }
            err.MessageBoxOnFailure();
            CoTaskMemFree(pCompiledHelpFile);
       }
	   break;
	default:
		return S_FALSE;
    }

	if (!err.Succeeded())
	{
		if (g_iDebugOutputLevel & DEBUG_FLAG_MMC_NOTIFY)
		{
			TRACEEOL("CIISObject::Notify -> " << ParseEvent(event) << " error " << err);
		}
	}
	err.Reset();
    return err;
}

HRESULT
CIISObject::GetContextHelp(CString& strHtmlPage)
{
    strHtmlPage = GLOBAL_DEFAULT_HELP_PATH ;
    return S_OK;
}

HRESULT
CIISObject::AddToScopePane(
    IN HSCOPEITEM hRelativeID,
    IN BOOL       fChild,
    IN BOOL       fNext,
    IN BOOL       fIsParent
    )
/*++

Routine Description:

    Add current object to console namespace.  Either as the last child
    of a parent item, or right before/after sibling item

Arguments:

    HSCOPEITEM hRelativeID      : Relative scope ID (either parent or sibling)
    BOOL       fChild           : If TRUE, object will be added as child of 
                                  hRelativeID
    BOOL       fNext            : If fChild is TRUE, this parameter is ignored
                                  If fChild is FALSE, and fNext is TRUE,
                                    object will be added before hRelativeID
                                  If fChild is FALSE, and fNext is FALSE,
                                    object will be added after hRelativeID
    BOOL       fIsParent        : If TRUE, it will add the [+] to indicate
                                  that this node may have childnodes.

Return Value

    HRESULT

--*/
{

    DWORD dwMask = fChild ? SDI_PARENT : fNext ? SDI_NEXT : SDI_PREVIOUS; 
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
    SCOPEDATAITEM  scopeDataItem;

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = 
		SDI_STR | SDI_IMAGE | SDI_CHILDREN | SDI_OPENIMAGE | SDI_PARAM | dwMask;
    scopeDataItem.displayname = MMC_CALLBACK;
    scopeDataItem.nImage = scopeDataItem.nOpenImage = MMC_IMAGECALLBACK;//QueryImage();
    scopeDataItem.lParam = (LPARAM)this;
    scopeDataItem.relativeID = hRelativeID;
    scopeDataItem.cChildren = fIsParent ? 1 : 0;
    HRESULT hr = pConsoleNameSpace->InsertItem(&scopeDataItem);

    if (SUCCEEDED(hr))
    {
        //
        // Cache the scope item handle
        //
        ASSERT(m_hScopeItem == NULL);
        m_hScopeItem = scopeDataItem.ID;
		// BUGBUG: looks like MMC_IMAGECALLBACK doesn't work in InsertItem. Update it here.
		scopeDataItem.mask = 
			SDI_IMAGE | SDI_OPENIMAGE;
		pConsoleNameSpace->SetItem(&scopeDataItem);
    }

    return hr;
}



HRESULT
CIISObject::AddToScopePaneSorted(
    IN HSCOPEITEM hParent,
    IN BOOL       fIsParent
    )
/*++

Routine Description:

    Add current object to console namespace, sorted in its proper location.

Arguments:

    HSCOPEITEM hParent          : Parent object
    BOOL       fIsParent        : If TRUE, it will add the [+] to indicate
                                  that this node may have childnodes.


Return Value

    HRESULT

--*/
{
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();

    //
    // Find proper insertion point
    //
    BOOL       fChild = TRUE;
    HSCOPEITEM hChildItem = NULL;
    CIISObject * pItem;
    LONG_PTR   cookie;
    int        nSwitch;

    HRESULT hr = pConsoleNameSpace->GetChildItem(hParent, &hChildItem, &cookie);

    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ASSERT_PTR(pItem);

        nSwitch = CompareScopeItem(pItem);

        //
        // Dups should be weeded out by now.
        //
 //       ASSERT(nSwitch != 0);

        if (nSwitch < 0)
        {
            //
            // Insert before this item
            //
            fChild = FALSE;
            break;
        }

        //
        // Advance to next child of same parent
        //
        hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    return AddToScopePane(hChildItem ? hChildItem : hParent, fChild, fIsParent);
}



/* virtual */
HRESULT 
CIISObject::RemoveScopeItem()
/*++

Routine Description:

    Remove the current item from the scope view.  This method is virtual
    to allow derived classes to do cleanup.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(m_hScopeItem != NULL);
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
    m_fFlaggedForDeletion = TRUE;

    //RemoveChildren(m_hScopeItem);
    //DeleteChildObjects(m_hScopeItem);
    HRESULT hr = pConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);
    // set our scope item to point to nothing in the MMC
    ResetScopeItem();
    ResetResultItem();
	return hr;
}

HRESULT
CIISObject::ChangeVisibleColumns(MMC_VISIBLE_COLUMNS * pCol)
{
	return S_OK;
}

HRESULT
CIISObject::OnDblClick(IComponentData * pcd, IComponent * pc)
{
    // Default action is to select this item on scope
    return SelectScopeItem();
}

HRESULT 
CIISObject::SelectScopeItem()
/*++

Routine Description:

    Select this item in the scope view.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    // Fix for bug #519763. I found no way of getting hScope from MMC for the
    // root item.
    if (NULL != QueryScopeItem())
    {
        ASSERT(m_hScopeItem != NULL);
        IConsole * pConsole = (IConsole *)GetConsole();
        return pConsole->SelectScopeItem(m_hScopeItem);
    }
    return S_OK;
}



HRESULT 
CIISObject::SetCookie()
/*++

Routine Description:

    Store the cookie (a pointer to the current CIISObject) in the 
    scope view object associated with it.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(m_hScopeItem != NULL);
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
    SCOPEDATAITEM  scopeDataItem;

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = SDI_PARAM;
        
    scopeDataItem.ID = m_hScopeItem;
    scopeDataItem.lParam = (LPARAM)this;
    
    return pConsoleNameSpace->SetItem(&scopeDataItem);
}



HRESULT
CIISObject::RefreshDisplay(BOOL bRefreshToolBar)
/*++

Routine Description:

    Refresh the display parameters of the current node.  

Arguments:

    None

Return Value

    HRESULT

Note:  This does not fetch any configuration information from the metabase,
       that's done in RefreshData();

--*/
{
   HRESULT hr = S_OK;

   if (m_hResultItem == 0)
   {
      if (bRefreshToolBar)
      {
         SetToolBarStates(_lpToolBar);
      }

      ASSERT(m_hScopeItem != NULL);
	  if (m_hScopeItem != NULL)
	  {
                IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
		SCOPEDATAITEM  scopeDataItem;

		::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
		scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
		scopeDataItem.displayname = MMC_CALLBACK;
		scopeDataItem.nImage = scopeDataItem.nOpenImage = QueryImage();
		scopeDataItem.ID = m_hScopeItem;
	    
		hr = pConsoleNameSpace->SetItem(&scopeDataItem);
	  }
   }
   else
   {
      RESULTDATAITEM ri;
      ::ZeroMemory(&ri, sizeof(ri));
      ri.itemID = m_hResultItem;
      ri.mask = RDI_STR | RDI_IMAGE;
      ri.str = MMC_CALLBACK;
      ri.nImage = QueryImage();
      IConsole * pConsole = (IConsole *)GetConsole();
      CComQIPtr<IResultData, &IID_IResultData> pResultData(pConsole);
      if (pResultData != NULL)
      {
         pResultData->SetItem(&ri);
      }
   }
   ASSERT(SUCCEEDED(hr));
   return hr;
}



/* virtual */
HRESULT
CIISObject::DeleteChildObjects(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Free the iisobject pointers belonging to the descendants of the current
    nodes.  This is in response to a MMCN_REMOVE_CHILDREN objects typically,
    and does not remove the scope nodes from the scope view (for that see 
    RemoveChildren())

Arguments:

    HSCOPEITEM hParent      : Parent scope item handle

Return Value:

    HRESULT

--*/
{
    HSCOPEITEM hChildItem = NULL;
    CIISObject * pItem = NULL;
    LONG_PTR   cookie = NULL;
    void ** ppVoid = NULL;

    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
    HRESULT hr = pConsoleNameSpace->GetChildItem(hParent, &hChildItem, &cookie);
    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ppVoid = (void **) cookie;
        ASSERT_PTR(pItem);

        if (pItem)
        {
            // do this extra check since
            // this cookie object for some reason could be gone already!
            if (ppVoid && (*ppVoid))
            {
                if (pItem != this)
                {
                    //
                    // Recursively commit infanticide
                    // call this objects DeleteChildObjects
                    //
					pItem->m_fFlaggedForDeletion = TRUE;

                    //
                    // Mark the item as orphaned!!
                    pItem->ResetScopeItem();
                    pItem->ResetResultItem();

                    // recursively call on this items children...
                    pItem->DeleteChildObjects(hChildItem);

					// this release will delete the object
                    pItem->Release();
                }
            }
        }

        //
        // Advance to next child of same parent
        //
        hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    //
    // BUGBUG: For some reason GetNextItem() returns 1
    //         when no more child items exist, not a true HRESULT
    //
    return S_OK;
}


/*virtual*/
HRESULT
CIISObject::DeleteNode(IResultData * pResult)
{
   ASSERT(IsDeletable());
   return S_OK;
}

/* virtual */
HRESULT
CIISObject::RemoveChildren(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Similar to DeleteChildObjects() this method will actually remove
    the child nodes from the scope view.

Arguments:

    HSCOPEITEM hParent      : Parent scope item handle

Return Value:

    HRESULT

--*/
{
    HSCOPEITEM hChildItem, hItem;
    CIISObject * pItem;
    LONG_PTR   cookie;

    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
    HRESULT hr = pConsoleNameSpace->GetChildItem(hParent, &hChildItem, &cookie);
    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ASSERT_PTR(pItem);

        hItem = pItem ? hChildItem : NULL;
    
        //
        // Determine next sibling before killing current sibling
        //
        hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);

        //
        // Now delete the current item from the tree
        //
        if (hItem)
        {
			pItem->m_fFlaggedForDeletion = TRUE;

            // get rid of it's scopeitem or result item...
            // this true param should also try to free the item if it's not used.
            hr = pConsoleNameSpace->DeleteItem(hItem, TRUE);
            // set our scope item to point to nothing in the MMC
            pItem->ResetScopeItem();
            pItem->ResetResultItem();

            //
            // ISSUE: Why doesn't DeleteItem above call some sort of 
            //        notification so that I don't have to do this?
            //

			// this release will delete the object
            pItem->Release();
        }
    }

    //
    // BUGBUG: For some reason GetNextItem() returns 1
    //         when no more child items exist, not a true HRESULT
    //
    return S_OK;
}




/* virtual  */
HRESULT 
CIISObject::EnumerateResultPane(
    BOOL fExpand, 
    IHeaderCtrl * lpHeader,
    IResultData * lpResultData,
	BOOL fForRefresh
    )
/*++
Routine Description:
    Enumerate or destroy the result pane.

Arguments:
    BOOL fExpand                : TRUE  to create the result view,
                                  FALSE to destroy it
    IHeaderCtrl * lpHeader      : Header control
    IResultData * pResultData   : Result view
	BOOL fForRefresh			: if true then we don't need to rebuild result view

Return Value:
    HRESULT
--*/
{ 
    if (fExpand)
    {
		if (lpHeader != NULL)
		{
			ASSERT_READ_PTR(lpHeader);
			if (!fForRefresh)
			{
				InitializeChildHeaders(lpHeader);
			}
		}
    }
    else
    {
        //
        // Destroy child result items
        //
    }

    return S_OK; 
}



/* virtual */
HRESULT 
CIISObject::SetStandardVerbs(LPCONSOLEVERB lpConsoleVerb)
/*++

Routine Description:

    Set the standard MMC verbs based on the this object type
    and state.

Arguments:

    LPCONSOLEVERB lpConsoleVerb     : Console verb interface

Return Value:

    HRESULT

--*/
{
    CError err;
    ASSERT_READ_PTR(lpConsoleVerb);

    //
    // Set enabled/disabled verb states
    //
    lpConsoleVerb->SetVerbState(MMC_VERB_COPY,       HIDDEN,  TRUE);
    lpConsoleVerb->SetVerbState(MMC_VERB_PASTE,      HIDDEN,  TRUE);
    lpConsoleVerb->SetVerbState(MMC_VERB_PRINT,      HIDDEN,  TRUE); 

	// cWebServiceExtension needs special handling since it's different from a regular schope item.
	if (IsEqualGUID(* (GUID *) GetNodeType(),cWebServiceExtension))
	{
		if (UseCount() <= 1)
		{
			lpConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, IsRenamable());
		}
		lpConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, IsDeletable());
	}
	else
	{
		if (UseCount() <= 1)
		{
			lpConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, IsRenamable());
			lpConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, IsDeletable());
		}
	}
    lpConsoleVerb->SetVerbState(MMC_VERB_REFRESH,    ENABLED, IsRefreshable());
    lpConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, IsConfigurable());

    //
    // Set default verb
    //
    if (IsConfigurable())
    {
        lpConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }
    
    if (IsOpenable())
    {
        lpConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }

    return err;
}


HRESULT
CIISObject::FillCustomData(CLIPFORMAT cf, LPSTREAM pStream)
{
    ASSERT(FALSE);
    return E_FAIL;
}

HRESULT
CIISObject::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    HRESULT hr = CSnapInItemImpl<CIISObject>::FillData(cf, pStream);
    if (hr == DV_E_CLIPFORMAT)
    {
        hr = FillCustomData(cf, pStream);
    }
    return hr;
}

//
// CIISRoot implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISRoot::CIISRoot() :
    m_fRootAdded(FALSE),
    m_pMachine(NULL)
{
    VERIFY(m_bstrDisplayName.LoadString(IDS_ROOT_NODE));
	TRACEEOL("CIISRoot::CIISRoot");
}

CIISRoot::~CIISRoot()
{
	TRACEEOL("CIISRoot::~CIISRoot");
}

/* virtual */
HRESULT 
CIISRoot::EnumerateScopePane(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Enumerate scope child items of the root object -- i.e. machine nodes.
    The machine nodes are expected to have been filled by via the IPersist
    methods.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    if (m_fIsExtension)
    {
        return EnumerateScopePaneExt(hParent);
    }
    //
    // The CIISRoot item was not added in the conventional way.
    // Cache the scope item handle, and set the cookie, so that
    // GetRoot() will work for child objects. 
    //
    ASSERT(m_hScopeItem == NULL); 
    m_hScopeItem = hParent;

    CError err(SetCookie());

    if (err.Failed())
    {
        //
        // We're in deep trouble.  For some reason, we couldn't
        // store the CIISRoot cookie in the scope view.  That
        // means anything depending on fetching the root object
        // isn't going to work.  Cough up a hairball, and bail
        // out now.
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        ASSERT_MSG("Unable to cache root object");
        err.MessageBox();

        return err;
    }

    //
    // Expand the computer cache 
    //
    if (m_scServers.IsEmpty())
    {
        //
        // Try to create the local machine
        //
        CIISMachine * pLocal = new CIISMachine(GetConsoleNameSpace(),GetConsole());

        if (pLocal)
        {
            //
            // Verify the machine object is created.
            //
            err = CIISMachine::VerifyMachine(pLocal);

            if (err.Succeeded())
            {
                TRACEEOLID("Added local computer to cache: ");
                m_scServers.Add(pLocal);
            }

            err.Reset();
        }
    }

    //
    // Add each cached server to the view...
    //
    CIISMachine * pMachine = m_scServers.GetFirst();

    while (pMachine)
    {
        TRACEEOLID("Adding " << pMachine->QueryServerName() << " to scope pane");
        pMachine->AddRef();
        err = pMachine->AddToScopePane(hParent);

		// Do for runonce
		if (!(g_dwInetmgrParamFlags & INETMGR_PARAM_RUNONCE_HAPPENED))
		{
			IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
			if (pConsoleNameSpace)
			{
				// expand under the covers...
				pConsoleNameSpace->Expand(pMachine->QueryScopeItem());
			}
		}

        if (err.Failed())
        {
            break;
        }

        pMachine = m_scServers.GetNext();
    }
    
    return err;    
}

HRESULT
CIISRoot::EnumerateScopePaneExt(HSCOPEITEM hParent)
{
    CError err;
    ASSERT(m_scServers.IsEmpty());
    if (!m_fRootAdded)
    {
        CComAuthInfo auth(m_ExtMachineName);
        m_pMachine = new CIISMachine(GetConsoleNameSpace(),GetConsole(),&auth, this);
        if (m_pMachine != NULL)
        {
            m_pMachine->AddRef();
            err = m_pMachine->AddToScopePane(hParent);
            m_fRootAdded = err.Succeeded();
            ASSERT(m_hScopeItem == NULL);
            m_hScopeItem = m_pMachine->QueryScopeItem();
        }
        else
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return err;
}

HRESULT
ExtractComputerNameExt(
    IDataObject * pDataObject, 
    CString& strComputer)
{
	//
	// Find the computer name from the ComputerManagement snapin
	//
    CLIPFORMAT CCF_MyComputMachineName = (CLIPFORMAT)RegisterClipboardFormat(MYCOMPUT_MACHINE_NAME);
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { 
        CCF_MyComputMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
    };

    //
    // Allocate memory for the stream
    //
    int len = MAX_PATH;
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
	if(stgmedium.hGlobal == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
    ASSERT(SUCCEEDED(hr));
	//
	// Get the computer name
	//
    strComputer = (LPTSTR)stgmedium.hGlobal;

	GlobalFree(stgmedium.hGlobal);

    return hr;
}

HRESULT
CIISRoot::InitAsExtension(IDataObject * pDataObject)
{
    ASSERT(!m_fIsExtension);
    m_fIsExtension = TRUE;
    CString buf;
    return ExtractComputerNameExt(pDataObject, m_ExtMachineName);
}

HRESULT
CIISRoot::ResetAsExtension()
{
    ASSERT(m_fIsExtension);
    CIISObject::m_fIsExtension = FALSE;
    // Remove machine node from the scope
    CError err = RemoveScopeItem();
    m_hScopeItem = NULL;
    // Delete machine object
    m_pMachine->Release();
    m_pMachine = NULL;
    m_fRootAdded = FALSE;
    // Empty machine name
    m_ExtMachineName.Empty();
    // clean out

    return err;
}


/* virtual */
HRESULT
CIISRoot::DeleteChildObjects(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    We need this method for extension case. CompMgmt send this event when
    snapin is connected to another machine. We should clean all computer relevant
    stuff from here and the root, because after that we will get MMCN_EXPAND, as
    at the very beginning of extension cycle.

Arguments:

    HSCOPEITEM hParent      : Parent scope item handle

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    if (m_pMachine != NULL)
    {
        m_pMachine->AddRef();
        m_pMachine->DeleteChildObjects(m_hScopeItem);
        m_pMachine->ResetScopeItem();
        m_pMachine->ResetResultItem();
		m_pMachine->m_MachineWNetConnections.Clear();
        m_pMachine->Release();
    }
    else
    {
        CIISMachine * pMachine = m_scServers.GetFirst();
        while (pMachine)
        {
            hr = pMachine->DeleteChildObjects(pMachine->QueryScopeItem());
            pMachine->ResetScopeItem();
            pMachine->ResetResultItem();
			pMachine->m_MachineWNetConnections.Clear();
            m_scServers.Remove(pMachine);
            pMachine->Release();
            pMachine = m_scServers.GetNext();
        }
    }
    if (SUCCEEDED(hr) && m_fIsExtension)
    {
        hr = ResetAsExtension();
    }
    return hr;
}


/* virtual */
void 
CIISRoot::InitializeChildHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Build result view for immediate descendant type

Arguments:

    LPHEADERCTRL lpHeader      : Header control

Return Value:

    None

--*/
{
    ASSERT(!m_fIsExtension);
    CIISMachine::InitializeHeaders(lpHeader);
}

HRESULT
CIISRoot::FillCustomData(CLIPFORMAT cf, LPSTREAM pStream)
{
    return E_FAIL;
}


/* virtual */
LPOLESTR 
CIISRoot::GetResultPaneColInfo(int nCol)
{
    if (nCol == 0)
    {
        return QueryDisplayName();
    }
    else if (nCol == 1)
    {
    }
    else if (nCol == 2)
    {
    }
    return OLESTR("");
}

HRESULT CheckForMetabaseAccess(DWORD dwPermissions,
                               CIISMBNode * pIISMBNode,
                               BOOL bReConnect,
                               LPCTSTR path)
{
    CMetaKey * pKey = NULL;
    CMetaInterface * pMyInterface = NULL;
	CError err;
    BOOL fContinue = TRUE;

    if (!pIISMBNode)
    {
        err = E_POINTER;
        goto CheckForMetabaseAccess_Exit;
    }

	// Check if we have a metabase access first...
	while (fContinue)
	{
		fContinue = FALSE;
        pMyInterface = pIISMBNode->QueryInterface();
        if (pMyInterface)
        {
            if (dwPermissions != 0)
            {
                // METADATA_PERMISSION_READ
                pKey = new CMetaKey(pMyInterface, path, dwPermissions);
            }
            else
            {
                pKey = new CMetaKey(pMyInterface, path);
            }

		    if (NULL == pKey)
		    {
			    TRACEEOLID("RefreshData: Out Of Memory");
			    err = ERROR_NOT_ENOUGH_MEMORY;
			    break;
		    }
            else
            {
		        err = pKey->QueryResult();
            }
        }
        else
        {
            err = RPC_S_SERVER_UNAVAILABLE;
        }
		if (pIISMBNode->IsLostInterface(err))
		{
			if (bReConnect)
			{
				SAFE_DELETE(pKey);
				fContinue = pIISMBNode->OnLostInterface(err);
			}
			else
			{
				fContinue = FALSE;
			}
		}
	}

    SAFE_DELETE(pKey);

CheckForMetabaseAccess_Exit:
	return err;
}

HRESULT CheckForMetabaseAccess(DWORD dwPermissions,
                               CMetaInterface * pMyInterface,
                               LPCTSTR path)
{
    CMetaKey * pKey = NULL;
	CError err;

    if (!pMyInterface)
    {
        err = RPC_S_SERVER_UNAVAILABLE;
        goto CheckForMetabaseAccess_Exit;
    }

	// Check if we have a metabase access...
    if (dwPermissions != 0)
    {
        // METADATA_PERMISSION_READ
        pKey = new CMetaKey(pMyInterface, path, dwPermissions);
    }
    else
    {
        pKey = new CMetaKey(pMyInterface, path);
    }

	if (NULL == pKey)
	{
		err = ERROR_NOT_ENOUGH_MEMORY;
	}
    else
    {
		err = pKey->QueryResult();
    }
    SAFE_DELETE(pKey);

CheckForMetabaseAccess_Exit:
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iismbnode.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        iismbnode.cpp

   Abstract:
        CIISMBNode Object

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        10/28/2000      sergeia     Split from iisobj.cpp

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "w3sht.h"
#include "fltdlg.h"
#include "aclpage.h"
#include "impexp.h"
#include "util.h"
#include "tracker.h"
#include <lm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

extern INT g_iDebugOutputLevel;
extern CPropertySheetTracker g_OpenPropertySheetTracker;
//
// CIISMBNode implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */ LPOLESTR CIISMBNode::_cszSeparator = _T("/");
/* static */ CComBSTR CIISMBNode::_bstrRedirectPathBuf;



CIISMBNode::CIISMBNode(
    IN CIISMachine * pOwner,
    IN LPCTSTR szNode
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pOwner         : Owner machine object
    LPCTSTR szNode               : Node name

Return Value:

    N/A

--*/
    : m_bstrNode(szNode),
      m_bstrURL(NULL), 
      m_pOwner(pOwner)
{
    ASSERT_READ_PTR(szNode);
    ASSERT_READ_PTR(pOwner);
    if (this != m_pOwner)
    {
        m_pOwner->AddRef();
    }
    m_pMachineObject = m_pOwner;

    if (g_iDebugOutputLevel & DEBUG_FLAG_CIISMBNODE)
    {
        TRACEEOL("AddRef to m_pOwner: node " << szNode << " count " << m_pOwner->UseCount())
    }
}


CIISMBNode::~CIISMBNode()
{
    if (this != m_pOwner)
    {
        m_pOwner->Release();
    }
	if (g_iDebugOutputLevel & DEBUG_FLAG_CIISMBNODE)
	{
		TRACEEOL("Released m_pOwner: node " << m_bstrNode << " count " << m_pOwner->UseCount())
	}
}

CIISMBNode::CreateTag()
{
    CIISMachine * pMachine = GetOwner();
    if (pMachine)
    {
        CComBSTR bstrPath;
        BuildMetaPath(bstrPath);
        m_strTag = pMachine->QueryDisplayName();
        m_strTag += bstrPath;
    }
}


void
CIISMBNode::SetErrorOverrides(
    IN OUT CError & err,
    IN BOOL fShort
    ) const
/*++

Routine Description:

    Set error message overrides

Arguments:

    CError err      : Error message object
    BOOL fShort     : TRUE to use only single-line errors

Return Value:

    None

--*/
{
    //
    // Substitute friendly message for some ID codes.
    //
    // CODEWORK:  Add global overrides as well.
    //
    err.AddOverride(EPT_S_NOT_REGISTERED,       
        fShort ? IDS_ERR_RPC_NA_SHORT : IDS_ERR_RPC_NA);
    err.AddOverride(RPC_S_SERVER_UNAVAILABLE,   
        fShort ? IDS_ERR_RPC_NA_SHORT : IDS_ERR_RPC_NA);

    err.AddOverride(RPC_S_UNKNOWN_IF, IDS_ERR_INTERFACE);
    err.AddOverride(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);
    err.AddOverride(REGDB_E_CLASSNOTREG, IDS_ERR_NO_INTERFACE);
	err.AddOverride(ERROR_DUP_NAME, fShort ? IDS_ERR_BINDING_SHORT : IDS_ERR_BINDING_LONG);
    if (!fShort)
    {
        err.AddOverride(ERROR_ACCESS_DENIED,    IDS_ERR_ACCESS_DENIED);
    }
}

BOOL 
CIISMBNode::IsAdministrator() const
{
    CIISMBNode * that = (CIISMBNode *)this;
    return that->GetOwner()->HasAdministratorAccess();
}

void 
CIISMBNode::DisplayError(CError& err, HWND hWnd) const
/*++

Routine Description:
    Display error message box. Substituting some friendly messages for
    some specific error codes

Arguments:
    CError & err        : Error object contains code to be displayed

--*/
{
	if (err == E_POINTER)
    {
		err.Reset();
    }
	if (err.Failed())
	{
		SetErrorOverrides(err);
		err.MessageBox(hWnd);
	}
}

CIISMBNode *
CIISMBNode::GetParentNode() const
    
/*++

Routine Description:

    Helper function to return the parent node in the scope tree

Arguments:

    None

Return Value:

    Parent CIISMBNode or NULL.

--*/
{
    LONG_PTR cookie = NULL;
    HSCOPEITEM hParent;    
    CIISMBNode * pNode = NULL;
    HRESULT hr = S_OK;
    SCOPEDATAITEM si;
    ::ZeroMemory(&si, sizeof(SCOPEDATAITEM));

    CIISObject * ThisConst = (CIISObject *)this;

    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)ThisConst->GetConsoleNameSpace();


    if (m_hResultItem != 0)
    {
        si.mask = SDI_PARAM;
        si.ID = m_hScopeItem;
        hr = pConsoleNameSpace->GetItem(&si);
        if (SUCCEEDED(hr))
        {
            cookie = si.lParam;
        }
    }
    else
    {
        // Get our Item
        si.mask = SDI_PARAM;
        si.ID = m_hScopeItem;
        // if we can get our item, then try to get our parents
        // we need to do this because MMC will AV if we don't exist first...
        if (SUCCEEDED(pConsoleNameSpace->GetItem(&si)))
        {
            hr = pConsoleNameSpace->GetParentItem(
                m_hScopeItem,
                &hParent,
                &cookie
                );
        }
    }

    if (SUCCEEDED(hr))
    {
        pNode = (CIISMBNode *)cookie;
        ASSERT_PTR(pNode);
    }

    return pNode;
}



/* virtual */
HRESULT
CIISMBNode::BuildMetaPath(
    OUT CComBSTR & bstrPath
    ) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents

Arguments:

    CComBSTR & bstrPath     : Returns metabase path

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    CIISMBNode * pNode = GetParentNode();

    if (pNode)
    {
        hr = pNode->BuildMetaPath(bstrPath);

        if (SUCCEEDED(hr))
        {
            bstrPath.Append(_cszSeparator);
            bstrPath.Append(QueryNodeName());
        }

        return hr;
    }

    //
    // No parent node
    //
//    ASSERT_MSG("No parent node");
    return E_UNEXPECTED;
}


HRESULT
CIISMBNode::FillCustomData(CLIPFORMAT cf, LPSTREAM pStream)
{
    HRESULT hr = DV_E_CLIPFORMAT;
    ULONG uWritten;

    if (cf == m_CCF_MachineName)
    {
        hr = pStream->Write(
                QueryMachineName(), 
                (ocslen((OLECHAR*)QueryMachineName()) + 1) * sizeof(OLECHAR),
                &uWritten
                );

        ASSERT(SUCCEEDED(hr));
        return hr;
    }
    //
    // Generate complete metabase path for this node
    //
    CString strField;
    CString strMetaPath;
    CComBSTR bstr;
    if (FAILED(hr = BuildMetaPath(bstr)))
    {
        ASSERT(FALSE);
        return hr;
    }
    strMetaPath = bstr;

    if (cf == m_CCF_MetaPath)
    {
        //
        // Whole metabase path requested
        //
		//BUG:670171
		// Path from BuildMetaPath() is returning something like
		// /LM/W3SVC/1/ROOT
		//
		// however, it should be returned as LM/W3SVC/1/ROOT to be
		// backwards compatible with how iis5 used to work...
		if (_T("/") == strMetaPath.Left(1))
		{
			strField = strMetaPath.Right(strMetaPath.GetLength() - 1);
		}
		else
		{
			strField = strMetaPath;
		}
    }
    else
    {
        //
        // A portion of the metabase is requested.  Return the requested
        // portion
        //
        LPCTSTR lpMetaPath = (LPCTSTR)strMetaPath;
        LPCTSTR lpEndPath = lpMetaPath + strMetaPath.GetLength() + 1;
		LPCTSTR lpLM = NULL;
        LPCTSTR lpSvc = NULL;
        LPCTSTR lpInstance = NULL;
        LPCTSTR lpParent = NULL;
        LPCTSTR lpNode = NULL;

        //
        // Break up the metabase path in portions
        //
		if (lpLM = _tcschr(lpMetaPath, _T('/')))
		{
			++lpLM;

			if (lpSvc = _tcschr(lpLM, _T('/')))
			{
				++lpSvc;

				if (lpInstance = _tcschr(lpSvc, _T('/')))
				{
					++lpInstance;

					if (lpParent = _tcschr(lpInstance, _T('/')))
					{
						++lpParent;
						lpNode = _tcsrchr(lpParent, _T('/'));

						if (lpNode)
						{
							++lpNode;
						}
					}
				}
			}
		}

        int n1, n2;
        if (cf == m_CCF_Service)
        {
            //
            // Requested the service string
            //
            if (lpSvc)
            {
                n1 = DIFF(lpSvc - lpMetaPath);
                n2 = lpInstance ? DIFF(lpInstance - lpSvc) : DIFF(lpEndPath - lpSvc);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else if (cf == m_CCF_Instance)
        {
            //
            // Requested the instance number
            //
            if (lpInstance)
            {
                n1 = DIFF(lpInstance - lpMetaPath);
                n2 = lpParent ? DIFF(lpParent - lpInstance) : DIFF(lpEndPath - lpInstance);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else if (cf == m_CCF_ParentPath)
        {
            //
            // Requestd the parent path
            //
            if (lpParent)
            {
                n1 = DIFF(lpParent - lpMetaPath);
                n2 = lpNode ? DIFF(lpNode - lpParent) : DIFF(lpEndPath - lpParent);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else if (cf == m_CCF_Node)
        {
            //
            // Requested the node name
            //
            if (lpNode)
            {
                n1 = DIFF(lpNode - lpMetaPath);
                n2 = DIFF(lpEndPath - lpNode);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else
        {
            ASSERT(FALSE);
            DV_E_CLIPFORMAT;
        }
    }

    TRACEEOLID("Requested metabase path data: " << strField);
    int len = strField.GetLength() + 1;
    hr = pStream->Write(strField, 
            (ocslen(strField) + 1) * sizeof(OLECHAR), &uWritten);
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT
CIISMBNode::BuildURL(
    OUT CComBSTR & bstrURL
    ) const
/*++

Routine Description:

    Recursively build up the URL from the current node
    and its parents.

Arguments:

    CComBSTR & bstrURL : Returns URL

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    //
    // Prepend parent portion
    //
    CIISMBNode * pNode = GetParentNode();

    if (pNode)
    {
        hr = pNode->BuildURL(bstrURL);

        //
        // And our portion
        //
        if (SUCCEEDED(hr))
        {
            bstrURL.Append(_cszSeparator);
            bstrURL.Append(QueryNodeName());
        }

        return hr;
    }

    //
    // No parent node
    //
    ASSERT_MSG("No parent node");
    return E_UNEXPECTED;
}



BOOL
CIISMBNode::OnLostInterface(
    IN OUT CError & err
    )
/*++

Routine Description:

    Deal with lost interface.  Ask the user to reconnect.

Arguments:

    CError & err        : Error object

Return Value:

    TRUE if the interface was successfully recreated.
    FALSE otherwise.  If it tried and failed the error will

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CString str;
    str.Format(IDS_RECONNECT_WARNING, QueryMachineName());

    if (YesNoMessageBox(str))
    {
        //
        // Attempt to recreate the interface
        //
        err = CreateInterface(TRUE);
        return err.Succeeded();
    }
    
    return FALSE;
}

HRESULT
CIISMBNode::DeleteNode(IResultData * pResult)
{
   CError err;

    // check if they have the property sheet open on it.
    if (IsMyPropertySheetOpen())
    {
        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
        return S_OK;
    }

    // this could be an orphaned property sheet
    // check if an orphaned property sheet is open on this item.
    CIISObject * pAlreadyOpenProp = NULL;
    if (TRUE == g_OpenPropertySheetTracker.FindAlreadyOpenPropertySheet(this,&pAlreadyOpenProp))
    {
        // Bring it to the foreground, and bail
        HWND hHwnd = 0;
        if (pAlreadyOpenProp)
        {
            if (hHwnd = pAlreadyOpenProp->IsMyPropertySheetOpen())
            {
                if (hHwnd && (hHwnd != (HWND) 1))
                {
                    // Perhapse we should cancel the already
                    // opened property sheet...just a thought
                    if (!SetForegroundWindow(hHwnd))
                    {
                        // wasn't able to bring this property sheet to
                        // the foreground, the propertysheet must not
                        // exist anymore.  let's just clean the hwnd
                        // so that the user will be able to open propertysheet
                        pAlreadyOpenProp->SetMyPropertySheetOpen(0);
                    }
                    else
                    {
                        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
                        return S_OK;
                    }
                }
            }
        }
    }

    CComBSTR path;
    err = BuildMetaPath(path);
    if (err.Succeeded())
    {
        err = CheckForMetabaseAccess(METADATA_PERMISSION_WRITE,this,TRUE,path);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
    }
    if (err.Succeeded())
    {
        if (!NoYesMessageBox(IDS_CONFIRM_DELETE))
            return err;

        do
        {
            CMetaInterface * pInterface = QueryInterface();
            ASSERT(pInterface != NULL);
            CMetaKey mk(pInterface, METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_WRITE);
            if (!mk.Succeeded())
                break;
            err = mk.DeleteKey(path);
            if (err.Failed()) 
                break;

	        // don't hold the Metabasekey open
	        // (RemoveScopeItem may do a lot of things,and lock the metabase for other read requests)
	        mk.Close();

	        m_fFlaggedForDeletion = TRUE;
            err = RemoveScopeItem();

        } while (FALSE);
    }

   if (err.Failed())
   {
      DisplayError(err);
   }
   return err;
}

HRESULT
CIISMBNode::EnumerateVDirs(
    HSCOPEITEM hParent, CIISService * pService, BOOL bDisplayError)
    /*++

    Routine Description:
    Enumerate scope child items.

    Arguments:
    HSCOPEITEM hParent              : Parent console handle
    CIISService * pService          : Service type

    --*/
{
    ASSERT_PTR(pService);

    CError  err;
    CString strVRoot;
    CIISDirectory * pDir;

    if (pService->QueryMajorVersion() < 6)
    {
        CMetaEnumerator * pme = NULL;
        err = CreateEnumerator(pme);
        while (err.Succeeded())
        {
            err = pme->Next(strVRoot);
            if (err.Succeeded())
            {
                CChildNodeProps child(pme, strVRoot, WITH_INHERITANCE, FALSE);
                err = child.LoadData();
                DWORD dwWin32Error = err.Win32Error();
                if (err.Failed())
                {
                    //
                    // Filter out the non-fatal errors
                    //
                    switch(err.Win32Error())
                    {
                    case ERROR_ACCESS_DENIED:
                    case ERROR_FILE_NOT_FOUND:
                    case ERROR_PATH_NOT_FOUND:
                        err.Reset();
                        break;

                    default:
                        TRACEEOLID("Fatal error occurred " << err);
                    }
                }

                if (err.Succeeded())
                {
                    //
                    // Skip non-virtual directories (that is, those with
                    // inherited vrpaths)
                    //
                    if (!child.IsPathInherited())
                    {
                        //
                        // Construct with full information.
                        //
                        pDir = new CIISDirectory(
                            m_pOwner,
                            pService,
                            strVRoot,
                            child.IsEnabledApplication(),
                            child.QueryWin32Error(),
                            child.GetRedirectedPath()
                            );

                        if (!pDir)
                        {
                            err = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                        pDir->AddRef();
                        err = pDir->AddToScopePane(hParent);
                    }
                }
            }
        }
        SAFE_DELETE(pme);
        if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
        {
            err.Reset();
        }
    }
    else
    {
        do
        {
            CComBSTR bstrPath;
            err = BuildMetaPath(bstrPath);
            BREAK_ON_ERR_FAILURE(err);

            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
            if (!IsLostInterface(err))
            {
                // reset error if an other error other than No interface
                err.Reset();
            }
            BREAK_ON_ERR_FAILURE(err);

            CMetaKey mk(QueryInterface(), bstrPath, METADATA_PERMISSION_READ);
            err = mk.QueryResult();
            BREAK_ON_ERR_FAILURE(err);

            CStringListEx list;
            err = mk.GetChildPaths(list);
            BREAK_ON_ERR_FAILURE(err);

            CString key_type;
            BOOL bPossbileVDir = FALSE;
            POSITION pos = list.GetHeadPosition();
            while (err.Succeeded() && pos != NULL)
            {
                strVRoot = list.GetNext(pos);
                err = mk.QueryValue(MD_KEY_TYPE, key_type, NULL, strVRoot);

                bPossbileVDir = FALSE;
                if (err.Succeeded())
                {
                    if (key_type.CompareNoCase(_T(IIS_CLASS_WEB_VDIR)) == 0 || key_type.CompareNoCase(_T(IIS_CLASS_FTP_VDIR)) == 0)
                    {
                        bPossbileVDir = TRUE;
                    }
                }
                else
                {
                    if (err == (HRESULT)MD_ERROR_DATA_NOT_FOUND)
                    {
                        // there is no KeyType
                        // for backward compatibility reasons -- this could be a VDir!
                        bPossbileVDir = TRUE;
                    }
                }

                if (bPossbileVDir)
                {
                    CChildNodeProps child(&mk, strVRoot, WITH_INHERITANCE, FALSE);
                    err = child.LoadData();
                    DWORD dwWin32Error = err.Win32Error();
                    if (err.Failed())
                    {
                        //
                        // Filter out the non-fatal errors
                        //
                        switch(err.Win32Error())
                        {
                        case ERROR_ACCESS_DENIED:
                        case ERROR_FILE_NOT_FOUND:
                        case ERROR_PATH_NOT_FOUND:
                            err.Reset();
                            break;

                        default:
                            TRACEEOLID("Fatal error occurred " << err);
                        }
                    }
                    if (err.Succeeded())
                    {
                        //
                        // Skip non-virtual directories (that is, those with
                        // inherited vrpaths)
                        //
                        if (!child.IsPathInherited())
                        {
                            pDir = new CIISDirectory(
                                m_pOwner,
                                pService,
                                strVRoot,
                                child.IsEnabledApplication(),
                                child.QueryWin32Error(),
                                child.GetRedirectedPath()
                                );

                            if (!pDir)
                            {
                                err = ERROR_NOT_ENOUGH_MEMORY;
                                break;
                            }
                            pDir->AddRef();
                            err = pDir->AddToScopePane(hParent);
                        }
                    }
                }
                if (err == (HRESULT)MD_ERROR_DATA_NOT_FOUND)
                {
                    err.Reset();
                }
            }
        } while (FALSE);
    }
    if (err.Failed() && bDisplayError)
    {
        DisplayError(err);
    }
    return err;
}

BOOL 
CIISMBNode::GetPhysicalPath(
    LPCTSTR metaPath,
    CString & alias,
    CString & physicalPath
    )
/*++

Routine Description:

    Build a physical path for the current node.  Starting with the current
    node, walk up the tree appending node names until a virtual directory
    with a real physical path is found

Arguments:

    CString & physicalPath       : Returns file path

Return Value:

    Pointer to path

--*/
{
    if (CMetabasePath::IsMasterInstance(metaPath))
        return FALSE;

    BOOL fInherit = FALSE;
    CMetaInterface * pInterface = QueryInterface();
    CError err;

    ASSERT(pInterface != NULL);
    if (pInterface)
    {
        CMetaKey mk(pInterface);
        err = mk.QueryValue(
              MD_VR_PATH, 
              physicalPath, 
              &fInherit, 
              metaPath
              );
        if (err.Succeeded())
        {
            physicalPath.TrimRight();
            physicalPath.TrimLeft();
        }
    }

    if (err.Failed())
    {
        CString lastNode;
        CMetabasePath::GetLastNodeName(metaPath, lastNode);
        PathAppend(lastNode.GetBuffer(MAX_PATH), alias);
        lastNode.ReleaseBuffer();
        CString buf(metaPath);

        if (NULL == CMetabasePath::ConvertToParentPath(buf))
        {
            return FALSE;
        }
        
        else 
        {
            if (GetPhysicalPath(buf, lastNode, physicalPath))
            {
                return TRUE;
            }
        }
    }
    if (!alias.IsEmpty())
    {
        // Check if physicalPath is \\.\ (device type)
        // PathAppend will hose on this and get rid of the \\.\ part
        // example: before \\.\c:\temp, after \\c:\temp
        // obviously this is bad if there are Device path's in there
        if (IsDevicePath(physicalPath))
        {
            CString csTemp;
            csTemp = physicalPath;
            physicalPath = AppendToDevicePath(csTemp, alias);
        }
        else
        {
            PathAppend(physicalPath.GetBuffer(MAX_PATH), alias);
            physicalPath.ReleaseBuffer();
        }
    }
    return TRUE;
}

HRESULT
CIISMBNode::CleanResult(IResultData * lpResultData)
{
	CError err;

	POSITION pos = m_ResultViewList.GetHeadPosition();
	while (pos != NULL)
	{
		POSITION pos_current = pos;
		ResultViewEntry e = m_ResultViewList.GetNext(pos);
		if (e._ResultData == (DWORD_PTR)lpResultData)
		{
			if (!e._ResultItems->IsEmpty())
			{
                // We should do this MMC cleaning before we delete our data
                err = lpResultData->DeleteAllRsltItems();
				POSITION p = e._ResultItems->GetHeadPosition();
				while (p != NULL)
				{
					CIISFileName * pNode = e._ResultItems->GetNext(p);
//					err = lpResultData->DeleteItem(pNode->m_hResultItem, 0);
					if (err.Failed())
					{
						ASSERT(FALSE);
						break;
					}
					pNode->Release();
				}
				e._ResultItems->RemoveAll();
			}
			delete e._ResultItems;
			// pos was updated above in GetNext
			m_ResultViewList.RemoveAt(pos_current);
		}
	}
	return err;
}

HRESULT 
CIISMBNode::EnumerateResultPane_(
    BOOL fExpand, 
    IHeaderCtrl * lpHeader,
    IResultData * lpResultData,
    CIISService * pService
    )
{
    CError err;
	CIISMachine * pMachine = (CIISMachine *) GetMachineObject();
    WIN32_FIND_DATA w32data;
    HANDLE hFind = INVALID_HANDLE_VALUE;

    CString dir;
    CComBSTR root;
    CString physPath, alias, csPathMunged;

	if (m_fFlaggedForDeletion)
	{
		return S_OK;
	}

    if (!HasFileSystemFiles())
    {
		goto EnumerateResultPane__Exit;

	}

	if (!fExpand)
	{
		err = CleanResult(lpResultData);
		goto EnumerateResultPane__Exit;
	}

    BuildMetaPath(root);
    err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,root);
    if (!IsLostInterface(err))
    {
        // reset error if an other error other than No interface
        err.Reset();
    }
	if (err.Failed())
	{
		goto EnumerateResultPane__Exit;
	}

    GetPhysicalPath(CString(root), alias, physPath);

    // -------------------------------------------------------------
    // Before we do anything we need to see if it's a "special" path
    //
    // Everything after this function must validate against csPathMunged...
    // this is because IsSpecialPath could have munged it...
    // -------------------------------------------------------------
    csPathMunged = physPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,physPath,csPathMunged);
#endif

    // Prepare for target machine metabase lookup
    BOOL fCheckMetabase = FALSE;
    if (PathIsUNC(csPathMunged))
    {
        fCheckMetabase = TRUE;
        CMetaKey mk(QueryInterface(), root, METADATA_PERMISSION_READ, METADATA_MASTER_ROOT_HANDLE);
        CError errMB(mk.QueryResult());
        if (errMB.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Metabase path not found, not a problem.
            //
            fCheckMetabase = FALSE;
            errMB.Reset();
        }
    }

    if (IsDevicePath(csPathMunged))
    {
        // check if the device path
        // points to an actual dir/file
        // if it does then enumerate it.
        if (IsSpecialPath(csPathMunged,TRUE,TRUE))
        {
            // Remunge this one more time!
            CString csBefore;
            csBefore = csPathMunged;
            GetSpecialPathRealPath(1,csBefore,csPathMunged);
        }
        else
        {
            return err;
        }
    }

    // WARNING:physPath could be empty!
    csPathMunged.TrimLeft();
    csPathMunged.TrimRight();
    if (csPathMunged.IsEmpty()){goto EnumerateResultPane__Exit;}

    if (pService->IsLocal() || PathIsUNC(csPathMunged))
    {
        dir = csPathMunged;
    }
    else
    {
        ::MakeUNCPath(dir, pService->QueryMachineName(), csPathMunged);
    }

    dir.TrimLeft();
    dir.TrimRight();
    if (dir.IsEmpty()){goto EnumerateResultPane__Exit;}

    if (PathIsUNC(dir))
    {
        CString server, user, password;

		CString MyTestDir;
		MyTestDir = dir;
		MyTestDir += _T("\\*");

		// we are trying to get the servername portion
		// PathFindNextComponent should return something like "servername\mydir\myfile.txt"
		// trim off everything after the 1st slash
        server = PathFindNextComponent(dir);
        int n = server.Find(_T('\\'));
        if (n != -1)
        {
            server = server.Left(n);
        }
        user = QueryInterface()->QueryAuthInfo()->QueryUserName();
        password = QueryInterface()->QueryAuthInfo()->QueryPassword();

		// we need to compare the servername that we want to get to
		// with the servername of the local computer.
		// this way we know if we need to net use to the machine!
		TCHAR szLocalMachineName[MAX_PATH + 1];
		DWORD dwSize = MAX_PATH;
		if (0 == ::GetComputerName(szLocalMachineName, &dwSize))
		{
			err.GetLastWinError();
			goto EnumerateResultPane__Exit;
		}

        //
        // As it turned out in some cases we cannot get access to file system
        // even if we are connected to metabase. We will add connection in this
        // case also.
        //
        if (!pService->IsLocal() 
            || server.CompareNoCase(szLocalMachineName) != 0
            )
        {
            BOOL bEmptyPassword = FALSE;
            // non-local resource, get connection credentials
            if (fCheckMetabase)
            {
                CMetaKey mk(QueryInterface(), root, 
                    METADATA_PERMISSION_READ, METADATA_MASTER_ROOT_HANDLE);
                err = mk.QueryResult();
                if (err.Succeeded())
                {
                    err = mk.QueryValue(MD_VR_USERNAME, user);
                    if (err.Succeeded())
                    {
                        err = mk.QueryValue(MD_VR_PASSWORD, password);
						bEmptyPassword = (err.Failed() ? TRUE : err.Succeeded() && password.IsEmpty());
                    }
                    // these credentials could be empty. try defaults
                    err.Reset();
                }
            }
            // Add net use for this resource
            NETRESOURCE nr;
            nr.dwType = RESOURCETYPE_DISK;
            nr.lpLocalName = NULL;
            nr.lpRemoteName = (LPTSTR)(LPCTSTR)dir;
            nr.lpProvider = NULL;

			CString dir_ipc;
			dir_ipc = _T("\\\\");
			dir_ipc += server;
			dir_ipc += _T("\\ipc$");

			// Ensure we have a connection to this network file
			// if it already exists, it won't create another one
			// these Connections will be cleaned up in ~CIISMachine or when the machine is disconnected.

            // Empty strings below mean no password, which is wrong. NULLs mean
            // default user and default password -- this could work better for local case.
            LPCTSTR p1 = password, p2 = user;
            // In case when password is really was set empty, passing NULL will fail.
            if (password.IsEmpty() && !bEmptyPassword){p1 = NULL;}
            if (user.IsEmpty()){p2 = NULL;}

			// Check if we have access
			// to the resource without netuse
			BOOL bNeedToNetUse = FALSE;
			hFind = INVALID_HANDLE_VALUE;
			hFind = ::FindFirstFile(MyTestDir, &w32data);
			if (hFind != INVALID_HANDLE_VALUE)
			{
				// successfull access
				FindClose(hFind);
			}
			else
			{
				// if we failed then we probably need to 
				// net use to this resource!
				bNeedToNetUse = TRUE;
			}

			// --------------------
			// Ensure we have a connection to this network file
			// if it already exists, it won't create another one
			// these Connections will be cleaned up in ~CIISMachine or when the machine is disconnected.
			// --------------------
			if (pMachine && bNeedToNetUse)
			{
				// try to setup a "net use \\computername\$ipc" connection
				// that everyone can use
				// set the share name to
				// \\machine\IPC$
				nr.lpRemoteName = (LPTSTR)(LPCTSTR) dir_ipc;
				//ERROR_LOGON_FAILURE
				DWORD dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
				if (NO_ERROR == dwRet)
				{
					bNeedToNetUse = FALSE;
				}
				else
				{
					if (ERROR_SESSION_CREDENTIAL_CONFLICT == dwRet || ERROR_ACCESS_DENIED == dwRet)
					{
						pMachine->m_MachineWNetConnections.Disconnect(dir_ipc);
						dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
					}
				}
			}

			// Check if we have access after the 1st net use.
			// We are connecting to a remote machine...
			// Check if we have access
			// to the resource without netuse
			hFind = INVALID_HANDLE_VALUE;
			hFind = ::FindFirstFile(MyTestDir, &w32data);
			if (hFind != INVALID_HANDLE_VALUE)
			{
				// successfull access
				FindClose(hFind);
			}
			else
			{
				// if we failed then we probably need to 
				// net use to this resource!
				bNeedToNetUse = TRUE;
			}

			if (bNeedToNetUse)
			{
				if (pMachine)
				{
					nr.lpRemoteName = (LPTSTR)(LPCTSTR) dir;

					DWORD dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
					if (NO_ERROR != dwRet)
					{
						if (ERROR_ALREADY_ASSIGNED != dwRet)
						{
							if (ERROR_SESSION_CREDENTIAL_CONFLICT == dwRet || ERROR_ACCESS_DENIED == dwRet)
							{
								// Errored with already assigned
								// check if we have accesss...
								hFind = INVALID_HANDLE_VALUE;
								hFind = ::FindFirstFile(MyTestDir, &w32data);
								if (hFind != INVALID_HANDLE_VALUE)
								{
									// successfull access
									FindClose(hFind);
								}
								else
								{
									// stil don't have access
									// kill the current connection and the ipc$ resource
									pMachine->m_MachineWNetConnections.Disconnect(dir);
									pMachine->m_MachineWNetConnections.Disconnect(dir_ipc);

									// try to reconnect with the new path...
									nr.lpRemoteName = (LPTSTR)(LPCTSTR) dir;

									dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
									if (ERROR_SESSION_CREDENTIAL_CONFLICT == dwRet)
									{
										// Clean all connections to this machine and try again.
										pMachine->m_MachineWNetConnections.Clear();
										dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
									}
								}
							}
							else
							{
								err = dwRet;
								goto EnumerateResultPane__Exit;
							}
						}
					}
				}
			}
        }
    }


    if (PathIsUNCServerShare(dir))
    {
        if (FALSE == DoesUNCShareExist(dir))
        {
            err = ERROR_BAD_NETPATH;
            goto EnumerateResultPane__Exit;
        }
    }

    dir += _T("\\*");
	hFind = INVALID_HANDLE_VALUE;
    hFind = ::FindFirstFile(dir, &w32data);
	// Bug:756402, revert previous change.  we need to display if hidden or system.
    const DWORD attr_skip = FILE_ATTRIBUTE_DIRECTORY; // | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;

    if (hFind == INVALID_HANDLE_VALUE)
    {
        err.GetLastWinError();
        goto EnumerateResultPane__Exit;
    }

    ResultItemsList * pResList = AddResultItems(lpResultData);
    do
    {
        LPCTSTR name = w32data.cFileName;
        if ((w32data.dwFileAttributes & attr_skip) == 0)
        {
            CIISFileName * pNode = new CIISFileName(
                GetOwner(), pService, w32data.dwFileAttributes, 
                name, NULL);
            if (!pNode)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            RESULTDATAITEM ri;
            ::ZeroMemory(&ri, sizeof(ri));
            ri.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
            ri.str = MMC_CALLBACK;
            ri.nImage = pNode->QueryImage();
            ri.lParam = (LPARAM)pNode;
            pNode->AddRef();
            err = lpResultData->InsertItem(&ri);
            if (err.Succeeded())
            {
                pNode->SetScopeItem(m_hScopeItem);
                pNode->SetResultItem(ri.itemID);
                pResList->AddTail(pNode);
            }
            else
            {
                pNode->Release();
            }

			// commenting out this refreshdata
			// this is waaay too much of a performance hit
			// and slows down everything drastically.
            //pNode->RefreshData();
        }
    } while (err.Succeeded() && FindNextFile(hFind, &w32data));
    FindClose(hFind);

EnumerateResultPane__Exit:
    return err;
}

ResultItemsList *
CIISMBNode::AddResultItems(IResultData * pResultData)
{
	ResultViewEntry e;
	e._ResultData = (DWORD_PTR)pResultData;
	e._ResultItems = new ResultItemsList;
	m_ResultViewList.AddTail(e);
	POSITION pos = m_ResultViewList.GetTailPosition();
	return m_ResultViewList.GetAt(pos)._ResultItems;
}

HRESULT
CIISMBNode::EnumerateWebDirs(HSCOPEITEM hParent, CIISService * pService)
/*++

Routine Description:

    Enumerate scope file system child items.

Arguments:

    HSCOPEITEM hParent              : Parent console handle
    CIISService * pService          : Service type

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(pService);
    CError err;
	CIISMachine * pMachine = (CIISMachine *) GetMachineObject();
	WIN32_FIND_DATA w32data;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	
    CString dir;
    CComBSTR root;
    BuildMetaPath(root);
    CString physPath, alias, csPathMunged;

    GetPhysicalPath(CString(root), alias, physPath);

    // -------------------------------------------------------------
    // Before we do anything we need to see if it's a "special" path
    //
    // Everything after this function must validate against csPathMunged...
    // this is because IsSpecialPath could have munged it...
    // -------------------------------------------------------------
    csPathMunged = physPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,physPath,csPathMunged);
#endif

    // Prepare for target machine metabase lookup
    BOOL fCheckMetabase = TRUE;
    CMetaKey mk(QueryInterface(), root, METADATA_PERMISSION_READ, METADATA_MASTER_ROOT_HANDLE);
    CError errMB(mk.QueryResult());
    if (errMB.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // Metabase path not found, not a problem.
        //
        fCheckMetabase = FALSE;
        errMB.Reset();
    }

    if (IsDevicePath(csPathMunged))
    {
        // check if the device path
        // points to an actual dir/file
        // if it does then enumerate it.
        if (IsSpecialPath(csPathMunged,TRUE,TRUE))
        {
            // Remunge this one more time!
            CString csBefore;
            csBefore = csPathMunged;
            GetSpecialPathRealPath(1,csBefore,csPathMunged);
        }
        else
        {
			goto EnumerateWebDirs_Exit;
        }
    }

    // WARNING:physPath could be empty!
    csPathMunged.TrimLeft();
    csPathMunged.TrimRight();
    if (csPathMunged.IsEmpty()){goto EnumerateWebDirs_Exit;}

    if (pService->IsLocal() || PathIsUNC(csPathMunged))
    {
        dir = csPathMunged;
    }
    else
    {
        ::MakeUNCPath(dir, pService->QueryMachineName(), csPathMunged);
    }

    dir.TrimLeft();
    dir.TrimRight();
    if (dir.IsEmpty()){goto EnumerateWebDirs_Exit;}
    
	// ------------------------------
	// Check if we need to "net use"
	// to the file resource on a remote machine
	// so we can enum it...
	// ------------------------------
	if (PathIsUNC(dir))
	{
		CString server, user, password;

		CString MyTestDir;
		MyTestDir = dir;
		MyTestDir += _T("\\*");

		// we are trying to get the servername portion
		// PathFindNextComponent should return something like "servername\mydir\myfile.txt"
		// trim off everything after the 1st slash
		server = PathFindNextComponent(dir);
		int n = server.Find(_T('\\'));
		if (n != -1)
			{server = server.Left(n);}
		user = QueryInterface()->QueryAuthInfo()->QueryUserName();
		password = QueryInterface()->QueryAuthInfo()->QueryPassword();

		// we need to compare the servername that we want to get to
		// with the servername of the local computer.
		// this way we know if we need to net use to the machine!
		TCHAR szLocalMachineName[MAX_PATH + 1];
		DWORD dwSize = MAX_PATH;
		if (0 == ::GetComputerName(szLocalMachineName, &dwSize))
		{
			err.GetLastWinError();
			goto EnumerateWebDirs_Exit;
		}

		// Check to see if the localmachine is different that the
		// machine we want to connect to to enum it's files upon...
        if (!pService->IsLocal() 
            || server.CompareNoCase(szLocalMachineName) != 0
            )
		{
			// We are connecting to a path which is different from the computer name!
			BOOL bEmptyPassword = FALSE;

			// non-local resource, get connection credentials
			if (fCheckMetabase && PathIsUNC(csPathMunged))
			{
				err = mk.QueryValue(MD_VR_USERNAME, user);
				if (err.Succeeded())
				{
					err = mk.QueryValue(MD_VR_PASSWORD, password);
					bEmptyPassword = (err.Failed() ? TRUE : err.Succeeded() && password.IsEmpty());
				}
				// these credentials could be empty. try defaults
				err.Reset();
			}

			// Add use for this resource
			NETRESOURCE nr;
			nr.dwType = RESOURCETYPE_DISK;
			nr.lpLocalName = NULL;
			nr.lpRemoteName = (LPTSTR)(LPCTSTR)dir;
			nr.lpProvider = NULL;

			CString dir_ipc;
			dir_ipc = _T("\\\\");
			dir_ipc += server;
			dir_ipc += _T("\\ipc$");

			// Empty strings below mean no password, which is wrong. NULLs mean
			// default user and default password -- this could work better for local case.
			LPCTSTR p1 = password, p2 = user;
			// In case when password is really was set empty, passing NULL will fail.
			if (password.IsEmpty() && !bEmptyPassword){p1 = NULL;}
			if (user.IsEmpty()){p2 = NULL;}

			// Check if we have access
			// to the resource without netuse
			BOOL bNeedToNetUse = FALSE;
			hFind = INVALID_HANDLE_VALUE;
			hFind = ::FindFirstFile(MyTestDir, &w32data);
			if (hFind != INVALID_HANDLE_VALUE)
			{
				// successfull access
				FindClose(hFind);
			}
			else
			{
				// if we failed then we probably need to 
				// net use to this resource!
				bNeedToNetUse = TRUE;
			}

			// --------------------
			// Ensure we have a connection to this network file
			// if it already exists, it won't create another one
			// these Connections will be cleaned up in ~CIISMachine or when the machine is disconnected.
			// --------------------
			if (pMachine && bNeedToNetUse)
			{
				// try to setup a "net use \\computername\$ipc" connection
				// that everyone can use
				// set the share name to
				// \\machine\IPC$
				nr.lpRemoteName = (LPTSTR)(LPCTSTR) dir_ipc;
				DWORD dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
				if (NO_ERROR == dwRet)
				{
					bNeedToNetUse = FALSE;
				}
				else
				{
					if (ERROR_SESSION_CREDENTIAL_CONFLICT == dwRet || ERROR_ACCESS_DENIED == dwRet)
					{
						pMachine->m_MachineWNetConnections.Disconnect(dir_ipc);
						dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
					}
				}
			}

			// Check if we have access after the 1st net use.
			// We are connecting to a remote machine...
			// Check if we have access
			// to the resource without netuse
			hFind = INVALID_HANDLE_VALUE;
			hFind = ::FindFirstFile(MyTestDir, &w32data);
			if (hFind != INVALID_HANDLE_VALUE)
			{
				// successfull access
				FindClose(hFind);
			}
			else
			{
				// if we failed then we probably need to 
				// net use to this resource!
				bNeedToNetUse = TRUE;
			}

			if (bNeedToNetUse)
			{
				if (pMachine)
				{
					nr.lpRemoteName = (LPTSTR)(LPCTSTR) dir;

					DWORD dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
					if (NO_ERROR != dwRet)
					{
						if (ERROR_ALREADY_ASSIGNED != dwRet)
						{
							if (ERROR_SESSION_CREDENTIAL_CONFLICT == dwRet || ERROR_ACCESS_DENIED == dwRet)
							{
								// Errored with already assigned
								// check if we have accesss...
								hFind = INVALID_HANDLE_VALUE;
								hFind = ::FindFirstFile(MyTestDir, &w32data);
								if (hFind != INVALID_HANDLE_VALUE)
								{
									// successfull access
									FindClose(hFind);
								}
								else
								{
									// stil don't have access
									// kill the current connection and the ipc$ resource
									pMachine->m_MachineWNetConnections.Disconnect(dir);
									pMachine->m_MachineWNetConnections.Disconnect(dir_ipc);

									// try to reconnect with the new path...
									nr.lpRemoteName = (LPTSTR)(LPCTSTR) dir;

									dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
									if (ERROR_SESSION_CREDENTIAL_CONFLICT == dwRet)
									{
										// Clean all connections to this machine and try again.
										pMachine->m_MachineWNetConnections.Clear();
										dwRet = pMachine->m_MachineWNetConnections.Connect(&nr,p1,p2,0);
									}
									else
									{
										if (NO_ERROR != dwRet)
										{
											// Final failure, what now?
										}
									}
								}
							}
							else
							{
								err = dwRet;
								goto EnumerateWebDirs_Exit;
							}
						}
					}
				}
			}
		}
	}

	// -----------------------------------
	// Enum thru the Physical file path...
	// -----------------------------------
    dir += _T("\\*");
	hFind = INVALID_HANDLE_VALUE;
    hFind = ::FindFirstFile(dir, &w32data);
	// Bug:756402, revert previous change.  we need to display if hidden or system.
	// const DWORD attr_skip = FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;

    if (hFind == INVALID_HANDLE_VALUE)
    {
        err.GetLastWinError();
		goto EnumerateWebDirs_Exit;
    }
    do
    {
        LPCTSTR name = w32data.cFileName;
        if (  (w32data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 
			// Bug:756402, revert previous change.  we need to display if hidden or system.
			// && (w32data.dwFileAttributes & attr_skip) == 0
            && lstrcmp(name, _T(".")) != 0 
            && lstrcmp(name, _T("..")) != 0
            )
        {
            CIISFileName * pNode = new CIISFileName(m_pOwner, 
                pService, w32data.dwFileAttributes, name, NULL);
            if (!pNode)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto EnumerateWebDirs_Exit;
            }

            if (fCheckMetabase)
            {
                errMB = mk.DoesPathExist(w32data.cFileName);
                if (errMB.Succeeded())
                {
					//
					// Match up with metabase properties.  If the item
					// is found in the metabase with a non-inherited vrpath,
					// than a virtual root with this name exists, and this 
					// file/directory should not be shown.
					//
					CString vrpath;
					BOOL f = FALSE;
					DWORD attr = 0;
					errMB = mk.QueryValue(MD_VR_PATH, vrpath, NULL, w32data.cFileName, &attr);
					if (errMB.Succeeded() && (attr & METADATA_ISINHERITED) == 0) 
					{
						TRACEEOLID("file/directory exists as vroot -- tossing" << w32data.cFileName);
						pNode->Release();
						continue;
					}
                }
            }
			pNode->AddRef();
            err = pNode->AddToScopePane(hParent);
        }
    } while (err.Succeeded() && FindNextFile(hFind, &w32data));
    FindClose(hFind);

EnumerateWebDirs_Exit:
    if (err.Failed())
    {
        DisplayError(err);
    }
    return err;
}

HRESULT 
CIISMBNode::CreateEnumerator(CMetaEnumerator *& pEnum)
/*++

Routine Description:

    Create enumerator object for the current path.  Requires interface
    to already be initialized

Arguments:

    CMetaEnumerator *& pEnum                : Returns enumerator

Return Value:

    HRESULT

--*/
{
    ASSERT(pEnum == NULL);
    ASSERT(m_hScopeItem != NULL);

    CComBSTR bstrPath;

    CError err(BuildMetaPath(bstrPath));
    if (err.Succeeded())
    {
        TRACEEOLID("Build metabase path: " << bstrPath);

        BOOL fContinue = TRUE;

        while(fContinue)
        {
            fContinue = FALSE;

            pEnum = new CMetaEnumerator(QueryInterface(), bstrPath);

            err = pEnum ? pEnum->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

            if (IsLostInterface(err))
            {
                SAFE_DELETE(pEnum);

                fContinue = OnLostInterface(err);
            }
        }
    }

    return err;
}



/* virtual */ 
HRESULT 
CIISMBNode::Refresh(BOOL fReEnumerate)
/*++

Routine Description:
    Refresh current node, and optionally re-enumerate child objects

Arguments:
    BOOL fReEnumerate       : If true, kill child objects, and re-enumerate

--*/
{
    CError err;

    //
    // Set MFC state for wait cursor
    //
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    CWaitCursor wait;

    err = RefreshData();
	if (err.Succeeded())
	{
		if (fReEnumerate)
		{
			//
			// Kill child objects
			//
            TRACEEOLID("Killing child objects");
		
			ASSERT(m_hScopeItem != NULL);
			if (m_hScopeItem != NULL)
			{
				err = RemoveChildren(m_hScopeItem);
				if (err.Succeeded())
				{
					err = EnumerateScopePane(m_hScopeItem);
				}
			}
		}
		err = RefreshDisplay();
	}
    return err;
}

/* virtual */
HRESULT
CIISMBNode::GetResultViewType(
    OUT LPOLESTR * lplpViewType,
    OUT long * lpViewOptions
    )
/*++

Routine Description:

    If we have an URL built up, display our result view as that URL,
    and destroy it.  This is done when 'browsing' a metabase node.
    The derived class will build the URL, and reselect the node.

Arguments:

    BSTR * lplpViewType   : Return view type here
    long * lpViewOptions  : View options

Return Value:

    S_FALSE to use default view type, S_OK indicates the
    view type is returned in *ppViewType

--*/
{
    if (m_bstrURL.Length())
    {
        *lpViewOptions = MMC_VIEW_OPTIONS_NONE;
        *lplpViewType  = (LPOLESTR)::CoTaskMemAlloc(
            (m_bstrURL.Length() + 1) * sizeof(WCHAR)
            );

        if (*lplpViewType)
        {
            lstrcpy(*lplpViewType, m_bstrURL);

            //
            // Destroy URL so we get a normal result view next time
            //
            m_bstrURL.Empty();
			m_fSkipEnumResult = TRUE;
            return S_OK;
        }

        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);    
    }

    //
    // No URL waiting -- use standard result view
    //
    return CIISObject::GetResultViewType(lplpViewType, lpViewOptions);
}


HRESULT
ShellExecuteDirectory(
    LPCTSTR lpszCommand,
    LPCTSTR lpszOwner,
    LPCTSTR lpszDirectory,
    HWND hWnd
    )
/*++

Routine Description:

    Shell Open or explore on a given directory path

Arguments:

    LPCTSTR lpszCommand    : "open" or "explore"
    LPCTSTR lpszOwner      : Owner server
    LPCTSTR lpszDirectory  : Directory path

Return Value:

    Error return code.

--*/
{
    CString strDir;

    if (::IsServerLocal(lpszOwner) || ::IsUNCName(lpszDirectory))
    {
        //
        // Local directory, or already a unc path
        //
        strDir = lpszDirectory;
    }
    else
    {
        ::MakeUNCPath(strDir, lpszOwner, lpszDirectory);
    }

    TRACEEOLID("Attempting to " << lpszCommand << " Path: " << strDir);

    CError err;
    {
        //
        // AFX_MANAGE_STATE required for wait cursor
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState() );
        CWaitCursor wait;

        if (::ShellExecute(NULL, lpszCommand, strDir, NULL,_T(""), SW_SHOW) <= (HINSTANCE)32)
        {
            err.GetLastWinError();
            if (err.Win32Error() == ERROR_NO_ASSOCIATION)
            {
                // Open shell OpenAs dialog
                SHELLEXECUTEINFO ei = {0};
                ei.cbSize = sizeof(ei);
                ei.fMask = SEE_MASK_NOQUERYCLASSSTORE;
                RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Unknown"), 0, MAXIMUM_ALLOWED, &ei.hkeyClass);
                if (ei.hkeyClass != NULL)
                {
                    ei.fMask |= SEE_MASK_NOQUERYCLASSSTORE;
                }
                ei.lpFile = strDir;
                ei.nShow = SW_SHOW;
                ei.lpVerb = _T("openas");
                ei.hwnd = hWnd;

                err = ShellExecuteEx(&ei);
                if (ei.hkeyClass != NULL)
                {
                    RegCloseKey(ei.hkeyClass);
                }
            }
        }
    }

    return err;
}

HRESULT
CIISMBNode::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
{
	CError err = CIISObject::CreatePropertyPages(lpProvider, handle, pUnk, type);
    if (err == S_FALSE)
	{
		return S_FALSE;
	}

    // Set this objects Tag to compare with something already opened
    CreateTag();

    CIISObject * pAlreadyOpenProp = NULL;
    if (TRUE == g_OpenPropertySheetTracker.FindAlreadyOpenPropertySheet(this,&pAlreadyOpenProp))
    {
        // Bring it to the foreground, and bail
        HWND hHwnd = 0;
        if (pAlreadyOpenProp)
        {
            if (hHwnd = pAlreadyOpenProp->IsMyPropertySheetOpen())
            {
                if (hHwnd && (hHwnd != (HWND) 1))
                {
                    // Perhapse we should cancel the already
                    // opened property sheet...just a thought
                    if (!SetForegroundWindow(hHwnd))
                    {
                        // wasn't able to bring this property sheet to
                        // the foreground, the propertysheet must not
                        // exist anymore.  let's just clean the hwnd
                        // so that the user will be able to open propertysheet
                        pAlreadyOpenProp->SetMyPropertySheetOpen(0);
                    }
                    else
                    {
                        return ERROR_ALREADY_EXISTS;
                    }
                }
            }
        }
    }

	// Check if we are still connected
	if (!GetOwner()->IsLocal())
	{

        // Problem here could be that lpszOwner is not a computername but rather
        // an IP Address!!!!
        LPCTSTR lpszServer = PURE_COMPUTER_NAME(GetOwner()->QueryServerName());
        if (LooksLikeIPAddress(lpszServer))
        {
            //
            // Get by ip address
            //
            CString strTemp;
            CIPAddress ia(lpszServer);
            if (NOERROR != MyGetHostName((DWORD)ia, strTemp))
            {
                // network is down!!!
                err = ERROR_NO_NETWORK;
                return err;
            }
        }

		do
		{
            // WARNING:QueryInterface() Can return NULL
            // and if the CMetakey is created with a NULL
            // pointer, it will AV.
            if (!GetOwner()->QueryInterface())
            {
                return RPC_S_SERVER_UNAVAILABLE;
            }
			CMetaKey mk(GetOwner()->QueryInterface());
			err = mk.QueryResult();
			BREAK_ON_ERR_FAILURE(err);
			CComBSTR path;
			err = BuildMetaPath(path);
			BREAK_ON_ERR_FAILURE(err);
            CString buf = path;
            while (FAILED(mk.DoesPathExist(buf)))
            {
                // Goto parent
                if (NULL == CMetabasePath::ConvertToParentPath(buf))
		        {
			        break;
                }
		    }
		    err = mk.Open(
				    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				    buf
				    );
			BREAK_ON_ERR_FAILURE(err);
			//
			// Write some nonsense
			//
			DWORD dwDummy = 0x1234;
			err = mk.SetValue(MD_ISM_ACCESS_CHECK, dwDummy);
			BREAK_ON_ERR_FAILURE(err);
			//
			// And delete it again
			//
			err = mk.DeleteValue(MD_ISM_ACCESS_CHECK);
		} while (FALSE);
	}
    return err;
}

HRESULT
CIISMBNode::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CError err = ERROR_NOT_ENOUGH_MEMORY;
    CComBSTR bstrMetaPath;
    BOOL bNeedMetabase = FALSE;
    BOOL bHaveMetabase = FALSE;

    switch (lCommandID)
    {
        case IDM_BROWSE:
        case IDM_OPEN:
        case IDM_PERMISSION:
        case IDM_EXPLORE:
        case IDM_NEW_FTP_SITE_FROM_FILE:
        case IDM_NEW_FTP_VDIR_FROM_FILE:
        case IDM_NEW_WEB_SITE_FROM_FILE:
        case IDM_NEW_WEB_VDIR_FROM_FILE:
        case IDM_NEW_APP_POOL_FROM_FILE:
        case IDM_TASK_EXPORT_CONFIG_WIZARD:
            bNeedMetabase = TRUE;
            break;
        default:
            bNeedMetabase = FALSE;
    }

    if (bNeedMetabase)
    {
        // WARNING:bstrMetaPath will be used by switch statement below
        VERIFY(SUCCEEDED(BuildMetaPath(bstrMetaPath)));
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            bHaveMetabase = TRUE;
        }
    }

    switch (lCommandID)
    {

    case IDM_BROWSE:
    {
        if (bHaveMetabase)
        {
            //
            // Build URL for this node, and force a re-select so as to change
            // the result view
            //
            BuildURL(m_bstrURL);
            if (m_bstrURL.Length())
            {
                //
                // After selection, the browsed URL will come up in the result view
                //
                SelectScopeItem();
            }
        }
    }
    break;

    //
    // CODEWORK:  Build path, and, using the explorer URL, put this stuff
    //            in the result view.
    //
    case IDM_OPEN:
    {
        if (bHaveMetabase)
        {
            CString phys_path, alias;
            if (GetPhysicalPath(bstrMetaPath, alias, phys_path))
            {
                hr = ShellExecuteDirectory(_T("open"), QueryMachineName(), phys_path, GetMainWindow(GetConsole())->m_hWnd);
            }
        }
    }
    break;

    case IDM_PERMISSION:
    {
        if (bHaveMetabase)
        {
            CString phys_path, alias, csPathMunged;
            if (GetPhysicalPath(bstrMetaPath, alias, phys_path))
            {
                // -------------------------------------------------------------
                // Before we do anything we need to see if it's a "special" path
                //
                // Everything after this function must validate against csPathMunged...
                // this is because IsSpecialPath could have munged it...
                // -------------------------------------------------------------
                csPathMunged = phys_path;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
                GetSpecialPathRealPath(0,phys_path,csPathMunged);
#endif
                if (!IsDevicePath(csPathMunged))
                {
                    INT_PTR iReturn = PopupPermissionDialog(
                    GetMainWindow(GetConsole())->m_hWnd,
                    QueryMachineName(),
                    csPathMunged);
                }
            }
        }
    }
    break;

    case IDM_EXPLORE:
    {
        if (bHaveMetabase)
        {
            CString phys_path, alias;
            if (GetPhysicalPath(bstrMetaPath, alias, phys_path))
            {
                TCHAR url[MAX_PATH];
                DWORD len = MAX_PATH;
                hr = UrlCreateFromPath(phys_path, url, &len, NULL);
                m_bstrURL = url;
                SelectScopeItem();
            }
        }
    }
    break;

    case IDM_NEW_FTP_SITE_FROM_FILE:
    {
        if (bHaveMetabase)
        {
            CComBSTR bstrServerName(QueryInterface()->QueryAuthInfo()->QueryServerName());
            CComBSTR bstrUserName(QueryInterface()->QueryAuthInfo()->QueryUserName());
            CComBSTR bstrUserPass(QueryInterface()->QueryAuthInfo()->QueryPassword());

            if (ERROR_SUCCESS == (hr = DoNodeImportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath,IIS_CLASS_FTP_SERVER_W)))
            {
                // check if we need to just refresh this node or the node above us...
                CIISMBNode * pNode = GetParentNode();
                if (IsEqualGUID(* (GUID *)pNode->GetNodeType(),cServiceCollectorNode))
                {
                    pNode->Refresh(TRUE);
                }
                else
                {
                    BOOL bExpand = !IsLeafNode();Refresh(bExpand);
                }
            }
        }
    }
    break;

    case IDM_NEW_FTP_VDIR_FROM_FILE:
    {
        if (bHaveMetabase)
        {
            CComBSTR bstrServerName(QueryInterface()->QueryAuthInfo()->QueryServerName());
            CComBSTR bstrUserName(QueryInterface()->QueryAuthInfo()->QueryUserName());
            CComBSTR bstrUserPass(QueryInterface()->QueryAuthInfo()->QueryPassword());

            if (ERROR_SUCCESS == (hr = DoNodeImportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath,IIS_CLASS_FTP_VDIR_W)))
            {
                // check if we need to just refresh this node or the node above us...
                CIISMBNode * pNode = GetParentNode();
                if (IsEqualGUID(* (GUID *)pNode->GetNodeType(),cInstanceNode))
                {
                    pNode->Refresh(TRUE);
                }
                else
                {
                    BOOL bExpand = !IsLeafNode();Refresh(bExpand);
                }
            }
        }
    }
    break;

    case IDM_NEW_WEB_SITE_FROM_FILE:
    {
        if (bHaveMetabase)
        {
            CComBSTR bstrServerName(QueryInterface()->QueryAuthInfo()->QueryServerName());
            CComBSTR bstrUserName(QueryInterface()->QueryAuthInfo()->QueryUserName());
            CComBSTR bstrUserPass(QueryInterface()->QueryAuthInfo()->QueryPassword());

            if (ERROR_SUCCESS == (hr = DoNodeImportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath,IIS_CLASS_WEB_SERVER_W)))
            {
                // check if we need to just refresh this node or the node above us...
                CIISMBNode * pNode = GetParentNode();
                if (IsEqualGUID(* (GUID *)pNode->GetNodeType(),cServiceCollectorNode))
                {
                    pNode->Refresh(TRUE);
                }
                else
                {
                    BOOL bExpand = !IsLeafNode();Refresh(bExpand);
                }
            }
        }
    }
    break;

    case IDM_NEW_WEB_VDIR_FROM_FILE:
    {
        if (bHaveMetabase)
        {
            CComBSTR bstrServerName(QueryInterface()->QueryAuthInfo()->QueryServerName());
            CComBSTR bstrUserName(QueryInterface()->QueryAuthInfo()->QueryUserName());
            CComBSTR bstrUserPass(QueryInterface()->QueryAuthInfo()->QueryPassword());

            if (ERROR_SUCCESS == (hr = DoNodeImportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath,IIS_CLASS_WEB_VDIR_W)))
            {
                // check if we need to just refresh this node or the node above us...
                CIISMBNode * pNode = GetParentNode();
                if (IsEqualGUID(* (GUID *)pNode->GetNodeType(),cInstanceNode))
                {
                    pNode->Refresh(TRUE);
                }
                else
                {
                    BOOL bExpand = !IsLeafNode();Refresh(bExpand);
                }
            }
        }
    }
    break;

    case IDM_NEW_APP_POOL_FROM_FILE:
    {
        if (bHaveMetabase)
        {
            CComBSTR bstrServerName(QueryInterface()->QueryAuthInfo()->QueryServerName());
            CComBSTR bstrUserName(QueryInterface()->QueryAuthInfo()->QueryUserName());
            CComBSTR bstrUserPass(QueryInterface()->QueryAuthInfo()->QueryPassword());

            if (ERROR_SUCCESS == (hr = DoNodeImportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath,L"IIsApplicationPool")))
            {
                // check if we need to just refresh this node or the node above us...
                CIISMBNode * pNode = GetParentNode();
                if (IsEqualGUID(* (GUID *)pNode->GetNodeType(),cAppPoolsNode))
                {
                    pNode->Refresh(TRUE);
                }
                else
                {
                    BOOL bExpand = !IsLeafNode();Refresh(bExpand);
                }
            }
        }
    }
    break;

    case IDM_TASK_EXPORT_CONFIG_WIZARD:
    {
        if (bHaveMetabase)
        {
            CString strNewPath, strRemainder;
            CComBSTR bstrServerName(QueryInterface()->QueryAuthInfo()->QueryServerName());
            CComBSTR bstrUserName(QueryInterface()->QueryAuthInfo()->QueryUserName());
            CComBSTR bstrUserPass(QueryInterface()->QueryAuthInfo()->QueryPassword());

            // Is this the root??
            LPCTSTR lpPath = CMetabasePath::GetRootPath(bstrMetaPath, strNewPath, &strRemainder);
            if (lpPath && (0 == _tcsicmp(lpPath,bstrMetaPath)))
            {
                CString strNewMetaPath;
                //
                // Get the instance properties
                //
                CMetabasePath::GetInstancePath(bstrMetaPath,strNewMetaPath);
                CComBSTR bstrNewMetaPath((LPCTSTR) strNewMetaPath);

                // if empty or if this is an app pool...
                if (IsEqualGUID(* (GUID *) GetNodeType(),cAppPoolNode))
                {
                    hr = DoNodeExportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath);
                }
                else
                {
                    if (strNewMetaPath.IsEmpty())
                    {
                        hr = DoNodeExportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath);
                    }
                    else
                    {
                        hr = DoNodeExportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrNewMetaPath);
                    }
                }
            }
            else
            {
                hr = DoNodeExportConfig(bstrServerName,bstrUserName,bstrUserPass,bstrMetaPath);
            }
        }
    }
    break;

    //
    // Pass on to base class
    //
    default:
        {
            hr = CIISObject::Command(lCommandID, pObj, type);
        }

    } // end switch

    return hr;
}

#if 0
HRESULT
CIISMBNode::OnPropertyChange(BOOL fScope, IResultData * pResult)
{
	CError err;

	err = Refresh(fScope);
    if (err.Succeeded())
	{
		if (	fScope 
			&&	HasFileSystemFiles()
			&&	!m_ResultItems.IsEmpty()
			)
		{
			err = CleanResult(pResult);
			if (err.Succeeded())
			{
				err = EnumerateResultPane(fScope, NULL, pResult);
			}
		}
		else if (!fScope)
		{
			pResult->UpdateItem(m_hResultItem);
		}

	}

	return err;
}
#endif

HRESULT 
CIISMBNode::OnViewChange(BOOL fScope, IResultData * pResult, IHeaderCtrl * pHeader, DWORD hint)
{
    CError err;
    BOOL bReenumResult = 0 != (hint & PROP_CHANGE_REENUM_FILES);
    BOOL bReenumScope = 
        0 != (hint & PROP_CHANGE_REENUM_VDIR) || 0 != (hint & PROP_CHANGE_REENUM_FILES);

    if (QueryScopeItem() || QueryResultItem())
    {
        BOOL bExpand = fScope 
            && !IsLeafNode() 
            && bReenumScope
    //        && IsExpanded()
            ;

        BOOL bHasResult = HasResultItems(pResult);
        if (bHasResult && bReenumResult)
        {
            // Remove files that could be in result pane
            err = CleanResult(pResult);
        }

        // after error this node could be not expanded, we should expand it anyway
        err = Refresh(bExpand);
	    if (err.Succeeded())
	    {
            if (fScope && HasFileSystemFiles() && bReenumResult && bHasResult)
            {
	            err = EnumerateResultPane(TRUE, pHeader, pResult);
            }
            else if (!fScope && (bReenumResult || 0 != (hint & PROP_CHANGE_DISPLAY_ONLY)))
            {
                pResult->UpdateItem(m_hResultItem);
            }
	    }
    }
    return err;
}

HRESULT
CIISMBNode::RemoveResultNode(CIISMBNode * pNode, IResultData * pResult)
{
	CError err;
	ASSERT(HasFileSystemFiles());
	err = pResult->DeleteItem(pNode->m_hResultItem, 0);
	if (err.Succeeded())
	{
		POSITION pos = m_ResultViewList.GetHeadPosition();
		while (pos != NULL)
		{
			ResultViewEntry e = m_ResultViewList.GetNext(pos);
			if (e._ResultData == (DWORD_PTR)pResult)
			{
				BOOL found = FALSE;
				POSITION p = e._ResultItems->GetHeadPosition();
				POSITION pcur;
				while (p != NULL)
				{
					pcur = p;
					if (e._ResultItems->GetNext(p) == pNode)
					{
						found = TRUE;
						break;
					}
				}
				if (found)
				{
					e._ResultItems->RemoveAt(pcur);
                    pNode->Release();
				}
			}
		}
	}
	return err;
}


// See FtpAddNew.cpp for the method CIISMBNode::AddFTPSite
// See WebAddNew.cpp for the method CIISMBNode::AddWebSite
// See add_app_pool.cpp for the method CIISMBNode::AddAppPool
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iisservice.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        iisservice.cpp

   Abstract:

        IISService Object

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        10/28/2000      sergeia  Split from iisobj.cpp

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "fservic.h"
#include "facc.h"
#include "fmessage.h"
#include "fvdir.h"
#include "fsecure.h"
#include "w3sht.h"
#include "wservic.h"
#include "wvdir.h"
#include "wsecure.h"
#include "fltdlg.h"
#include "filters.h"
#include "perform.h"
#include "docum.h"
#include "httppage.h"
#include "defws.h"
#include "deffs.h"
#include "errors.h"
#include "util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW
//
// CIISService Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


/* static */
HRESULT
__cdecl
CIISService::ShowFTPSiteProperties(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR handle
    )
/*++

Routine Description:

    Callback function to display FTP site properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CFtpSheet * pSheet = new CFtpSheet(
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        lParamParent
        );

    if (pSheet)
    {
        pSheet->SetModeless();
        pSheet->SetSheetType(pSheet->SHEET_TYPE_SITE);

        CIISMachine * pOwner = ((CIISMBNode *)lParam)->GetOwner();
        ASSERT(pOwner != NULL);
        CFTPInstanceProps ip(pSheet->QueryAuthInfo(), pSheet->QueryMetaPath());
        ip.LoadData();
        //
        // Add instance pages
        //
        if (pOwner->IsServiceLevelConfigurable() || !CMetabasePath::IsMasterInstance(lpszMDPath))
        {
			err = AddMMCPage(lpProvider, new CFtpServicePage(pSheet));
		}
        if (!ip.HasADUserIsolation())
        {
            err = AddMMCPage(lpProvider, new CFtpAccountsPage(pSheet));
        }
        err = AddMMCPage(lpProvider, new CFtpMessagePage(pSheet));

        //
        // Add directory pages
        //
        if (!ip.HasADUserIsolation())
        {
            err = AddMMCPage(lpProvider, new CFtpDirectoryPage(pSheet, TRUE));
        }
		// BUG:639135
		// 1. enabled for remote admin to iis5, 
		// 2. NOT enabled for remote admin to iis5.1
		// 3. enabled for iis6 
		if (pOwner->QueryMajorVersion() >= 5)
		{
			if (pOwner->QueryMajorVersion() == 5 && pOwner->QueryMinorVersion() == 1)
			{
				// if it's iis5.1 then don't show it.
			}
			else
			{
        		err = AddMMCPage(lpProvider, new CFtpSecurityPage(pSheet));
			}
		}
        //
        // Add master site pages
        //
        //if (CMetabasePath::IsMasterInstance(lpszMDPath) && pOwner->QueryMajorVersion() >= 6)
        //{
        //    err = AddMMCPage(lpProvider, new CDefFtpSitePage(pSheet));
        //}
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



/* static */
HRESULT
__cdecl
CIISService::ShowFTPDirProperties(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LPARAM  lParamParent,
    LONG_PTR handle
    )
/*++

Routine Description:
    Callback function to display FTP dir properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CFtpSheet * pSheet = new CFtpSheet(
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        lParamParent
        );

    if (pSheet)
    {
        pSheet->SetModeless();
        pSheet->SetSheetType(pSheet->SHEET_TYPE_VDIR);

        CIISMachine * pOwner = ((CIISMBNode *)lParam)->GetOwner();
        ASSERT(pOwner != NULL);
        //
        // Add directory pages
        //
        err = AddMMCPage(lpProvider, new CFtpDirectoryPage(pSheet, FALSE));

		// BUG:639135
		// 1. enabled for remote admin to iis5, 
		// 2. NOT enabled for remote admin to iis5.1
		// 3. enabled for iis6 
		if (pOwner->QueryMajorVersion() >= 5)
		{
			if (pOwner->QueryMajorVersion() == 5 && pOwner->QueryMinorVersion() == 1)
			{
				// if it's iis5.1 then don't show it.
			}
			else
			{
        		err = AddMMCPage(lpProvider, new CFtpSecurityPage(pSheet));
			}
		}
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}

/* static */
HRESULT
__cdecl
CIISService::ShowWebSiteProperties(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR handle
    )
/*++

Routine Description:

    Callback function to display Web site properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CW3Sheet * pSheet = new CW3Sheet(
        pAuthInfo,
        lpszMDPath,
        0, 
        pMainWnd,
        lParam,
        lParamParent
        );

    if (pSheet)
    {
        pSheet->SetModeless();
        pSheet->SetSheetType(pSheet->SHEET_TYPE_SITE);

        CIISMachine * pOwner = ((CIISMBNode *)lParam)->GetOwner();
        ASSERT(pOwner != NULL);

		BOOL bMaster = CMetabasePath::IsMasterInstance(lpszMDPath);
		BOOL bClient = pOwner->IsWorkstation();
		BOOL bServiceLevelConfig = pOwner->IsServiceLevelConfigurable();
		BOOL bAddPerformancePage = FALSE;
		BOOL bDownlevel = (pOwner->QueryMajorVersion() == 5 && pOwner->QueryMinorVersion() == 0);
        //
        // Add instance pages
        //
        if (bServiceLevelConfig || !bMaster)
        {
			err = AddMMCPage(lpProvider, new CW3ServicePage(pSheet));
		}

		// see if we need to add the performance page...
		bAddPerformancePage = pOwner->IsPerformanceConfigurable();
        if (!bClient)
		{
			bAddPerformancePage = TRUE;
            if (bDownlevel)
            {
				bAddPerformancePage = FALSE;
				if (!bMaster)
				{
					bAddPerformancePage = TRUE;
				}
            }
        }
		// iis6 allows this page for workstation.
		if (bAddPerformancePage)
		{
			err = AddMMCPage(lpProvider, new CW3PerfPage(pSheet));
		}

        err = AddMMCPage(lpProvider, new CW3FiltersPage(pSheet));
        //
        // Add directory pages
        //
        err = AddMMCPage(lpProvider, new CW3DirectoryPage(pSheet, TRUE));
        err = AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, TRUE, FILE_ATTRIBUTE_VIRTUAL_DIRECTORY));
        err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));
        if (bMaster && pOwner->QueryMajorVersion() >= 6)
        {
			err = AddMMCPage(lpProvider, new CDefWebSitePage(pSheet));
        }
		else
		{
			if (bMaster && bDownlevel)
			{
				err = AddMMCPage(lpProvider, new CDefWebSitePage(pSheet));
			}
		}
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return S_OK;
}



/* static */
HRESULT
__cdecl
CIISService::ShowWebDirProperties(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR handle
    )
/*++

Routine Description:

    Callback function to display Web dir properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CW3Sheet * pSheet = new CW3Sheet(
        pAuthInfo,
        lpszMDPath,
        0, 
        pMainWnd,
        lParam,
        lParamParent
        );

    if (pSheet)
    {
        pSheet->SetModeless();
        pSheet->SetSheetType(pSheet->SHEET_TYPE_VDIR);

        //
        // Add directory pages
        //
        err = AddMMCPage(lpProvider, new CW3DirectoryPage(pSheet, FALSE));
        err = AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, FALSE, FILE_ATTRIBUTE_VIRTUAL_DIRECTORY));
        err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));

    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



//
// Administrable services
//
/* static */ CIISService::SERVICE_DEF CIISService::_rgServices[] = 
{
    { 
        _T("MSFTPSVC"),   
        _T("ftp://"),  
        IDS_SVC_FTP, 
        iFolder,    // TODO: Need service bitmap
		iFolderStop,// TODO: Need service bitmap
        iFTPSite, 
        iFTPSiteStop, 
        iFTPSiteErr, 
        iFTPDir,
        iFTPDirErr,
        iFolder,
        iFile,
		IIS_CLASS_FTP_SERVICE_W,
		IIS_CLASS_FTP_SERVER_W,
		IIS_CLASS_FTP_VDIR_W,
        &CIISService::ShowFTPSiteProperties, 
        &CIISService::ShowFTPDirProperties, 
    },
    { 
        _T("W3SVC"),      
        _T("http://"), 
        IDS_SVC_WEB, 
        iFolder,    // TODO: Need service bitmap
		iFolderStop,// TODO: Need service bitmap
        iWWWSite, 
        iWWWSiteStop, 
        iWWWSiteErr, 
        iWWWDir,
        iWWWDirErr,
        iFolder,
        iFile,
		IIS_CLASS_WEB_SERVICE_W,
		IIS_CLASS_WEB_SERVER_W,
		IIS_CLASS_WEB_VDIR_W,
        &CIISService::ShowWebSiteProperties, 
        &CIISService::ShowWebDirProperties, 
    },
};



/* static */
int
CIISService::ResolveServiceName(
    LPCTSTR szServiceName
    )
/*++

Routine Description:
    Look up the service name in the table.  Return table index.
Arguments:
    LPCTSTR    szServiceName        : Metabase node name
Return Value:
    Table index or -1 if not found.    

--*/
{
    int iDef = -1;

    //
    // Sequential search because we expect just a few entries
    //
    for (int i = 0; i < ARRAY_SIZE(_rgServices); ++i)
    {
        if (!_tcsicmp(szServiceName, _rgServices[i].szNodeName))
        {
            iDef = i;
            break;
        }
    }

    return iDef;
}

CIISService::CIISService(
    CIISMachine * pOwner,
    LPCTSTR szServiceName
    )
    : CIISMBNode(pOwner, szServiceName)
{
    m_iServiceDef = ResolveServiceName(QueryNodeName());
    m_fManagedService = (m_iServiceDef >= 0);
    m_fCanAddInstance = pOwner->CanAddInstance();

	m_dwServiceState = 0;
	m_dwServiceStateDisplayed = 0;

    if (m_fManagedService)
    {
        ASSERT(m_iServiceDef < ARRAY_SIZE(_rgServices));

        VERIFY(m_bstrDisplayName.LoadString(
            _rgServices[m_iServiceDef].nDescriptiveName
            ));

        CString buf = m_bstrDisplayName;
        buf.Format(IDS_DISABLED_SERVICE_FMT, m_bstrDisplayName);
        m_bstrDisplayNameStatus = buf;
    }
}

/* virtual */
CIISService::~CIISService()
{
}

int 
CIISService::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_NAME,
    IDS_RESULT_STATUS,
};

int CIISService::_rgnWidths[COL_TOTAL] =
{
    200,
    300,
};

/* static */ CComBSTR CIISService::_bstrServiceDisabled;
/* static */ CComBSTR CIISService::_bstrServiceRunning;
/* static */ CComBSTR CIISService::_bstrServiceStopped;
/* static */ CComBSTR CIISService::_bstrServicePaused;
/* static */ CComBSTR CIISService::_bstrServiceStopPending;
/* static */ CComBSTR CIISService::_bstrServiceStartPending;
/* static */ CComBSTR CIISService::_bstrServicePausePending;
/* static */ CComBSTR CIISService::_bstrServiceContPending;
/* static */ BOOL     CIISService::_fStaticsLoaded = FALSE;

/* static */
void
CIISService::InitializeHeaders(LPHEADERCTRL lpHeader)
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
    if (!_fStaticsLoaded)
    {
        _fStaticsLoaded =
            _bstrServiceDisabled.LoadString(IDS_SERVICE_DISABLED)&&
            _bstrServiceRunning.LoadString(IDS_SERVICE_RUNNING) &&
            _bstrServiceStopped.LoadString(IDS_SERVICE_STOPPED) &&
            _bstrServicePaused.LoadString(IDS_SERVICE_PAUSED) &&
            _bstrServiceStopPending.LoadString(IDS_SERVICE_STOP_PENDING) &&
            _bstrServiceStartPending.LoadString(IDS_SERVICE_START_PENDING) &&
            _bstrServicePausePending.LoadString(IDS_SERVICE_PAUSE_PENDING) &&
            _bstrServiceContPending.LoadString(IDS_SERVICE_CONT_PENDING);
    }
}

/* virtual */
void 
CIISService::InitializeChildHeaders(
    LPHEADERCTRL lpHeader
    )
{
	BOOL IsFtpType = _tcsicmp(QueryServiceName(), SZ_MBN_FTP) == 0;
    if (IsFtpType)
    {
        CIISSite::InitializeHeaders2(lpHeader);
    }
    else
    {
        CIISSite::InitializeHeaders(lpHeader);
    }
}

#define SERVICE_CONFIG_BUF      2048

HRESULT
CIISService::GetServiceState(DWORD& mode, DWORD& state, CString& name)
{
    HRESULT hr = S_OK;
	state = SERVICE_STOPPED;
    CString strComputerNameToUse;
    strComputerNameToUse = QueryMachineName();

    CIISMachine * pMachineObj = GetOwner();
    if (!pMachineObj)
    {
        return E_FAIL;
    }

    if (pMachineObj->IsLocalHost())
    {
        // Use the local machine name.
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;
        if (::GetComputerName(szLocalServer, &dwSize))
        {
            strComputerNameToUse = _T("\\\\");
            strComputerNameToUse += szLocalServer;
        }
    }

    SC_HANDLE sm = OpenSCManager(strComputerNameToUse, NULL, GENERIC_READ);
    if (sm != NULL)
    {
        SC_HANDLE service = OpenService(sm, QueryServiceName(), 
            SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
        if (service != NULL)
        {
            QUERY_SERVICE_CONFIG * conf;
            DWORD cb;
            conf = (QUERY_SERVICE_CONFIG *)LocalAlloc(LPTR, SERVICE_CONFIG_BUF);
            if (conf != NULL)
            {
                if (QueryServiceConfig(service, conf, SERVICE_CONFIG_BUF, &cb))
                {
                    mode = conf->dwStartType;
                    name = conf->lpDisplayName;
                    SERVICE_STATUS status;
                    if (QueryServiceStatus(service, &status))
                    {
                        state = status.dwCurrentState;
                    }
                    else
                        hr = HRESULT_FROM_WIN32(GetLastError());
                }
                else
                    hr = HRESULT_FROM_WIN32(GetLastError());
                LocalFree(conf);
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            CloseServiceHandle(service);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
        CloseServiceHandle(sm);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

	if (SUCCEEDED(hr))
	{
		if (SERVICE_DISABLED == mode)
		{
			m_dwServiceState = -1;
		}
		else
		{
			m_dwServiceState = state;
		}
	}
	else
	{
		// Calling service api's failed
		// could be because in remote scenario
		m_dwServiceState = SERVICE_RUNNING;
	}
    return hr;
}

HRESULT
CIISService::GetServiceState()
{
	DWORD mode,state;
	CString name;
	return GetServiceState(mode,state,name);

}

HRESULT
CIISService::EnableService()
{
    HRESULT hr = S_OK;
    CString strComputerNameToUse;
    strComputerNameToUse = QueryMachineName();

    CIISMachine * pMachineObj = GetOwner();
    if (!pMachineObj)
    {
        return E_FAIL;
    }

    if (pMachineObj->IsLocalHost())
    {
        // Use the local machine name.
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;
        if (::GetComputerName(szLocalServer, &dwSize))
        {
            strComputerNameToUse = _T("\\\\");
            strComputerNameToUse += szLocalServer;
        }
    }

    SC_HANDLE sm = OpenSCManager(strComputerNameToUse, NULL, GENERIC_READ);
    if (sm != NULL)
    {
        SC_HANDLE service = OpenService(sm, QueryServiceName(), 
            SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_CHANGE_CONFIG);
        if (service != NULL)
        {
            hr = ChangeServiceConfig(
                service,
                SERVICE_NO_CHANGE,
                SERVICE_AUTO_START,
                SERVICE_NO_CHANGE,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                _T(""),
                NULL);
#if 0
            QUERY_SERVICE_CONFIG * conf;
            DWORD cb;
            conf = (QUERY_SERVICE_CONFIG *)LocalAlloc(LPTR, SERVICE_CONFIG_BUF);
            if (conf != NULL)
            {
                if (QueryServiceConfig(service, conf, SERVICE_CONFIG_BUF, &cb))
                {
                    mode = conf->dwStartType;
                    SERVICE_STATUS status;
                    if (QueryServiceStatus(service, &status))
                    {
                        state = status.dwCurrentState;
                    }
                    else
                        hr = HRESULT_FROM_WIN32(GetLastError());
                }
                else
                    hr = HRESULT_FROM_WIN32(GetLastError());
                LocalFree(conf);
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
#endif
            CloseServiceHandle(service);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
        CloseServiceHandle(sm);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
    return hr;
}


HRESULT
CIISService::StartService()
{
    HRESULT hr = S_OK;
    const DWORD dwSvcSleepInterval = 500 ;
    DWORD dwSvcMaxSleep = 180000 ;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    CString strComputerNameToUse;
    strComputerNameToUse = QueryMachineName();

    CIISMachine * pMachineObj = GetOwner();
    if (!pMachineObj)
    {
        return E_FAIL;
    }

    if (pMachineObj->IsLocalHost())
    {
        // Use the local machine name.
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;
        if (::GetComputerName(szLocalServer, &dwSize))
        {
            strComputerNameToUse = _T("\\\\");
            strComputerNameToUse += szLocalServer;
        }
    }

    do
    {
        // set up the service first
        if ((hScManager = OpenSCManager( strComputerNameToUse, NULL, GENERIC_READ )) == NULL || (hService = ::OpenService( hScManager, QueryServiceName(), SERVICE_START )) == NULL )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
        {
            break; // service already started and running
        }

        if ( !::StartService( hService, 0, NULL ))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //  Wait for the service to attain "running" status; but
        //  wait no more than 3 minute.
        DWORD dwSleepTotal;
        for ( dwSleepTotal = 0 ; dwSleepTotal < dwSvcMaxSleep
            && (QueryServiceStatus( hService, &svcStatus ))
            && svcStatus.dwCurrentState == SERVICE_START_PENDING ;
            dwSleepTotal += dwSvcSleepInterval )
        {
            ::Sleep( dwSvcSleepInterval ) ;
        }

        if ( svcStatus.dwCurrentState != SERVICE_RUNNING )
        {
            hr = dwSleepTotal > dwSvcMaxSleep ? HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT) : HRESULT_FROM_WIN32(svcStatus.dwWin32ExitCode);
            break;
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}
    return hr;
}


/* virtual */
LPOLESTR 
CIISService::GetResultPaneColInfo(int nCol)
{
    DWORD mode, state;
    CString name;
    CError err;
    switch (nCol)
    {
    case COL_DESCRIPTION:
        return QueryDisplayName();

    case COL_STATE:
        err = GetServiceState(mode, state, name);
        if (err.Succeeded())
        {
			if (m_dwServiceState)
			{
				if (m_dwServiceStateDisplayed != m_dwServiceState)
				{
					RefreshDisplay();
					break;
				}

                switch (m_dwServiceState)
                {
				case -1:
					return _bstrServiceDisabled;
                case SERVICE_STOPPED:
                    return _bstrServiceStopped;
                case SERVICE_RUNNING:
                    return _bstrServiceRunning;
                case SERVICE_PAUSED:
                    return _bstrServicePaused;
                case SERVICE_START_PENDING:
                    return _bstrServiceStartPending;
                case SERVICE_STOP_PENDING:
                    return _bstrServiceStopPending;
                case SERVICE_PAUSE_PENDING:
                    return _bstrServicePausePending;
                case SERVICE_CONTINUE_PENDING:
                    return _bstrServiceContPending;
                default:
                    break;
                }
			}
        }
        break;
    }
    return OLESTR("");
}

/* virtual */
HRESULT 
CIISService::RefreshData() 
{ 
	CError err = GetServiceState();
    return S_OK;
}

/* virtual */
HRESULT 
CIISService::EnumerateScopePane(HSCOPEITEM hParent)
{
    CError err;
    DWORD dwInstance;
    CString strInstance;
    CMetaEnumerator * pme = NULL;
	CIISSite * psite = NULL;

    if (!IsAdministrator())
    {
        return err;
    }
	if (QueryMajorVersion() < 6)
	{
		err = CreateEnumerator(pme);
		while (err.Succeeded())
		{
			err = pme->Next(dwInstance, strInstance);
			if (err.Succeeded())
			{
				if (NULL != (psite = new CIISSite(m_pOwner, this, strInstance)))
				{
					psite->AddRef();
					err = psite->AddToScopePane(hParent);
				}
				else
				{
					err = ERROR_NOT_ENOUGH_MEMORY;
					break;
				}
			}
		}
		SAFE_DELETE(pme);
		if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
		{
			err.Reset();
		}
	    if (err.Failed())
        {
            DisplayError(err);
        }
	}
	else
	{
        do
        {
		    CComBSTR bstrPath;
		    err = BuildMetaPath(bstrPath);
            BREAK_ON_ERR_FAILURE(err)
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
		    BREAK_ON_ERR_FAILURE(err)
		    if (err.Succeeded())
		    {
			    CMetaKey mk(QueryInterface(), bstrPath, METADATA_PERMISSION_READ);
			    err = mk.QueryResult();
			    if (err.Succeeded())
			    {
				    CStringListEx list;
				    err = mk.GetChildPaths(list);
				    if (err.Succeeded())
				    {
					    CString key_type;
					    POSITION pos = list.GetHeadPosition();
					    while (err.Succeeded() && pos != NULL)
					    {
						    strInstance = list.GetNext(pos);
						    err = mk.QueryValue(MD_KEY_TYPE, key_type, NULL, strInstance);
						    if (err.Succeeded() 
							    && (key_type.CompareNoCase(_T(IIS_CLASS_WEB_SERVER)) == 0 
								    || key_type.CompareNoCase(_T(IIS_CLASS_FTP_SERVER)) == 0)
							    )
						    {
							    if (NULL != (psite = new CIISSite(m_pOwner, this, strInstance)))
							    {
								    psite->AddRef();
								    err = psite->AddToScopePane(hParent);
							    }
							    else
							    {
								    err = ERROR_NOT_ENOUGH_MEMORY;
								    break;
							    }
						    }
						    else if (err == (HRESULT)MD_ERROR_DATA_NOT_FOUND)
						    {
							    err.Reset();
						    }
					    }
				    }
			    }
		    }
        } while (FALSE);
	    if (err.Failed())
        {
            DisplayError(err);
        }
	}

    return err;
}

/* virtual */
HRESULT
CIISService::AddMenuItems(
    LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr) && m_fCanAddInstance)
    {
        ASSERT(pInsertionAllowed != NULL);
        if (IsAdministrator())
        {
#if 0
            if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0)
	        {
                DWORD state = 0;
                hr = GetServiceState(state);
                if (SUCCEEDED(hr))
                {
		            AddMenuSeparator(lpContextMenuCallback);
		            AddMenuItemByCommand(lpContextMenuCallback, 
                        IDM_SERVICE_START, 
                        state == SERVICE_STOPPED ? 0 : MF_GRAYED);
		            AddMenuItemByCommand(lpContextMenuCallback, 
                        IDM_SERVICE_STOP, 
                        state == SERVICE_RUNNING ? 0 : MF_GRAYED);
                    AddMenuItemByCommand(lpContextMenuCallback, 
                        IDM_SERVICE_ENABLE, 
                        state == IIS_SERVICE_DISABLED ? 0 : MF_GRAYED);
                }
            }
#endif
            if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
            {
                AddMenuSeparator(lpContextMenuCallback);

                if (_tcsicmp(GetNodeName(), SZ_MBN_FTP) == 0)
                {
                    AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_FTP_SITE);
                    if (IsConfigImportExportable())
                    {
                        AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_FTP_SITE_FROM_FILE);
                    }
                }
                else if (_tcsicmp(GetNodeName(), SZ_MBN_WEB) == 0)
                {
                    AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_WEB_SITE);
                    if (IsConfigImportExportable())
                    {
                        AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_WEB_SITE_FROM_FILE);
                    }
                }
            }

            // Don't enable export at this level
            // since we won't be able to import from the file that is created...
            if (IsConfigImportExportable() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
            {
                AddMenuSeparator(lpContextMenuCallback);
                AddMenuItemByCommand(lpContextMenuCallback, IDM_TASK_EXPORT_CONFIG_WIZARD);
            }
        }

        //
        // CODEWORK: Add new instance commands for each of the services
        //           keeping in mind which ones are installed and all.
        //           add that info to the table, remembering that this
        //           is per service.
        //
    }

    return hr;
}

HRESULT
CIISService::InsertNewInstance(DWORD inst)
{
    CError err;
	TCHAR buf[16];
    CIISSite * pSite = NULL;

	// WAS needs some time to update status of new site as started
	Sleep(1000);
    // If service is not expanded we will get error and no effect
    if (!IsExpanded())
    {
		// In this case selecting the parent will enumerate all the nodes including new one,
		// which is already in metabase
		SelectScopeItem();
        IConsoleNameSpace2 * pConsoleNameSpace 
                    = (IConsoleNameSpace2 *)GetConsoleNameSpace();
        pConsoleNameSpace->Expand(QueryScopeItem());
		HSCOPEITEM hChildItem = NULL;
		LONG_PTR cookie;
		HRESULT hr = pConsoleNameSpace->GetChildItem(m_hScopeItem, &hChildItem, &cookie);
		while(SUCCEEDED(hr) && hChildItem)
		{
			pSite = (CIISSite *)cookie;
			ASSERT_PTR(pSite);
			if (pSite->GetInstance() == inst)
			{
				pSite->SelectScopeItem();
				break;
			}
			hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
		}
    }
	else
	{
		// Now we should insert and select this new site
		pSite = new CIISSite(m_pOwner, this, _itot(inst, buf, 10));
		if (pSite != NULL)
		{
			pSite->AddRef();
			err = pSite->AddToScopePaneSorted(QueryScopeItem(), FALSE);
			//err = pSite->AddToScopePane(QueryScopeItem(), TRUE, FALSE, TRUE);
			if (err.Succeeded())
			{
				VERIFY(SUCCEEDED(pSite->SelectScopeItem()));
			}
			else
			{
				pSite->Release();
			}
		}
		else
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
		}
    }

    if (err.Succeeded() && pSite)
    {
        if (!pSite->IsFtpSite())
        {
            // Also, if we add a w3svc site, it's probably using 
            // a application, so we have to refresh that stuff too
            // this CAppPoolsContainer will only be here if it's iis6
            CIISMachine * pOwner = GetOwner();
            if (pOwner)
            {
                CAppPoolsContainer * pPools = pOwner->QueryAppPoolsContainer();
                if (pPools)
                {
                    pPools->RefreshData();
                    if (pPools->IsExpanded())
                    {
                        pPools->RefreshDataChildren(_T(""),FALSE); // refresh all app pools, who knows
                    }
                }
            }
        }
    }

    return err;
}

HRESULT
CIISService::Command(
    long lCommandID,     
    CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type
    )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    DWORD inst = 0;
    DWORD dwCommand = 0;
    DWORD state = -1;

    CError err;
    CComBSTR bstrMetaPath;

    switch (lCommandID)
    {
#if 0
    case IDM_SERVICE_STOP:
        dwCommand = SERVICE_COMMAND_STOP;
        break;

    case IDM_SERVICE_START:
        dwCommand = SERVICE_COMMAND_START;
        break;

    case IDM_SERVICE_ENABLE:
        dwCommand = SERVICE_COMMAND_ENABLE;
        break;
#endif
    case IDM_NEW_FTP_SITE:
        BuildMetaPath(bstrMetaPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            hr = AddFTPSite(pObj, type, &inst);
            if (inst != 0)
            {
                hr = InsertNewInstance(inst);
            }
        }
        break;

    case IDM_NEW_WEB_SITE:
        BuildMetaPath(bstrMetaPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            hr = AddWebSite(pObj, type, &inst, 
						    m_pOwner->QueryMajorVersion(), m_pOwner->QueryMinorVersion());
            if (inst != 0)
            {
                hr = InsertNewInstance(inst);
            }
        }
        break;

    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
        break;
    }
    
    if (dwCommand != 0)
    {
        hr = ChangeServiceState(dwCommand);
    }

    return hr;
}

HRESULT
CIISService::ChangeServiceState(DWORD command)
{
	CError err = GetServiceState();
    return err;
}

/* virtual */
HRESULT 
CIISService::BuildURL(
    CComBSTR & bstrURL
    ) const
/*++

Routine Description:
    Recursively build up the URL from the current node
    and its parents.
Arguments:
    CComBSTR & bstrURL  : Returns URL

--*/
{
    ASSERT(m_iServiceDef < ARRAY_SIZE(_rgServices));
    bstrURL = _rgServices[m_iServiceDef].szProtocol;
    return S_OK;
}



HRESULT
CIISService::ShowSitePropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR handle
    )
/*++

Routine Description:

    Display site properties dialog

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT(m_iServiceDef >= 0 && m_iServiceDef < ARRAY_SIZE(_rgServices));
    return (*_rgServices[m_iServiceDef].pfnSitePropertiesDlg)(
        lpProvider,
        pAuthInfo, 
        lpszMDPath,
        pMainWnd,
        lParam,
        lParamParent,
        handle
        );
}



HRESULT
CIISService::ShowDirPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR handle
    )
/*++

Routine Description:

    Display directory properties dialog

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT(m_iServiceDef >= 0 && m_iServiceDef < ARRAY_SIZE(_rgServices));
    return (*_rgServices[m_iServiceDef].pfnDirPropertiesDlg)(
        lpProvider,
        pAuthInfo, 
        lpszMDPath,
        pMainWnd,
        lParam,
        lParamParent,
        handle
        );
}




/* virtual */
HRESULT
CIISService::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CError  err;

	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }
    if (ERROR_NO_NETWORK == err.Win32Error())
    {
        return S_FALSE;
    }
    
	CComBSTR bstrPath;
	err = BuildMetaPath(bstrPath);
	if (err.Succeeded())
	{
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,(LPCTSTR) bstrPath);
        if (err.Succeeded())
        {
            // cache handle for user in MMCPropertyChangeNotify
            m_ppHandle = handle;

		    //
		    // Show master properties
		    //
		    err = ShowSitePropertiesDlg(
			    lpProvider, QueryAuthInfo(), bstrPath,
			    GetMainWindow(GetConsole()), (LPARAM)this, (LPARAM) GetOwner(), handle
			    );
        }
	}
    err.MessageBoxOnFailure();
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\iisobj.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        iisobj.h

   Abstract:
        IIS Object definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef __IISOBJ_H__
#define __IISOBJ_H__

#include "scache.h"
#include "guids.h"
#include "restrictlist.h"
#include "tracknet.h"

BOOL IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);

typedef struct _GET_PROCESS_MODE_STRUCT
{
    CComAuthInfo * pComAuthInfo;
    DWORD dwProcessMode;
    DWORD dwReturnStatus;
} GET_PROCESS_MODE_STRUCT;


#define RES_TASKPAD_NEWVROOT         _T("/img\\newvroot.gif")
#define RES_TASKPAD_NEWSITE          _T("/img\\newsite.gif")
#define RES_TASKPAD_SECWIZ           _T("/img\\secwiz.gif")
//
// Image background colour for the toolbar buttons
//
//#define RGB_BK_IMAGES (RGB(255,0,255))      // purple

//
// Forward Definitions
//
class CIISRoot;
class CIISMachine;
class CIISService;
class CIISFileName;
class CAppPoolsContainer;
class CWebServiceExtensionContainer;

enum
{
    PROP_CHANGE_NO_UPDATE = 0,
    PROP_CHANGE_NOT_VISIBLE = 1,
    PROP_CHANGE_DISPLAY_ONLY = 2,
    PROP_CHANGE_REENUM_VDIR = 4,
    PROP_CHANGE_REENUM_FILES = 8
};

// used to be pack(4) but that didn't work on ia64, changed to pack(8) to make it work
#pragma pack(8)

class CIISObject : public CSnapInItemImpl<CIISObject>
/*++

Class Description:

    Base IIS object
    
Public Interface:


--*/
{
protected:
    //
    // Menu Commands, listed in toolbar order.
    //
    // IMPORTANT! -- this must be kept in sync with MenuItemDefs
    // in iisobj.cpp
    //
    enum
    {
        IDM_INVALID,            /* invalid command ID */
        IDM_CONNECT,
        IDM_DISCOVER,
        IDM_START,
        IDM_STOP,
        IDM_PAUSE,
        /**/
        IDM_TOOLBAR             /* Toolbar commands start here */
    };

    //
    // Additional menu commands that do not show up in the toolbar
    //
    enum
    {
        IDM_EXPLORE = IDM_TOOLBAR,
        IDM_OPEN,
        IDM_BROWSE,
        IDM_RECYCLE,
        IDM_PERMISSION,

#if defined(_DEBUG) || DBG
        IDM_IMPERSONATE,
        IDM_REMOVE_IMPERSONATION,
#endif // _DEBUG

        IDM_CONFIGURE,
        IDM_DISCONNECT,
        IDM_METABACKREST,
        IDM_SHUTDOWN,
        IDM_SAVE_DATA,

        IDM_NEW_VROOT,
        IDM_NEW_INSTANCE,
        IDM_NEW_FTP_SITE,
        IDM_NEW_FTP_SITE_FROM_FILE,
        IDM_NEW_FTP_VDIR,
        IDM_NEW_FTP_VDIR_FROM_FILE,
        IDM_NEW_WEB_SITE,
        IDM_NEW_WEB_SITE_FROM_FILE,
        IDM_NEW_WEB_VDIR,
        IDM_NEW_WEB_VDIR_FROM_FILE,
        IDM_NEW_APP_POOL,
        IDM_NEW_APP_POOL_FROM_FILE,
        IDM_VIEW_TASKPAD,
        IDM_TASK_EXPORT_CONFIG_WIZARD,
        IDM_WEBEXT_CONTAINER_ADD1,
        IDM_WEBEXT_CONTAINER_ADD2,
        IDM_WEBEXT_CONTAINER_PROHIBIT_ALL,
        IDM_WEBEXT_ALLOW,
        IDM_WEBEXT_PROHIBIT,

//        IDM_SERVICE_START,
//        IDM_SERVICE_STOP,
//        IDM_SERVICE_ENABLE,

        //
        // Don't move this last one -- it will be used
        // as an offset for service specific new instance
        // commands
        //
        IDM_NEW_EX_INSTANCE
    };

protected:
    //
    // Sort Weights for CIISObject derived classes
    //
    enum
    {
        SW_ROOT,
        SW_MACHINE,
        SW_APP_POOLS,
        SW_SERVICE,
        SW_WEBSVCEXTS,
        SW_SITE,
        SW_VDIR,
        SW_DIR,
        SW_FILE,
        SW_APP_POOL,
        SW_WEBSVCEXT
    };

//
// Statics
//
public:
   static HRESULT SetImageList(LPIMAGELIST lpImageList);

protected:
   static CComBSTR _bstrResult;

//
// Bitmap indices
//
protected:
    enum
    {
        iIISRoot = 0,
        iLocalMachine,
        iMachine,
        iFolder,
        iFolderStop,
        iFile,
        iError,
        iLocalMachineErr,
        iMachineErr,
        iFTPSiteErr,
        iWWWSiteErr,
        iApplicationErr,
        iWWWDir,
        iWWWDirErr,
        iFTPDir,
        iFTPDirErr,
        iWWWSite,
        iWWWSiteStop,
        iFTPSite,
        iFTPSiteStop,
        iApplication,
		iAppPool,
		iAppPoolStop,
		iAppPoolErr,
		iWebSvcGear,
		iWebSvcGearPlus,
		iWebSvcFilter,
		iWebSvcFilterPlus
    };

protected:
    //
    // Menu item definition that uses resource definitions, and
    // provides some additional information for taskpads. This is replacement
    // for MMC structure CONTEXTMENUITEM defined in mmc.h
    //
    typedef struct tagCONTEXTMENUITEM_RC
    {
        UINT    nNameID;
        UINT    nStatusID;
        UINT    nDescriptionID;
        LONG    lCmdID;
        LONG    lInsertionPointID;
        LONG    fSpecialFlags;
        LPCTSTR lpszMouseOverBitmap;
        LPCTSTR lpszMouseOffBitmap;
        LPCTSTR lpszLanguageIndenpendentID;
    } 
    CONTEXTMENUITEM_RC;

    static CONTEXTMENUITEM_RC _menuItemDefs[];

//
// Constructor/Destructor
//
public:
    CIISObject();
	void AddRef()
	{
		InterlockedIncrement(&m_use_count);
	}
	void Release()
	{
		InterlockedDecrement(&m_use_count);
		if (m_use_count <= 0)
		{
			delete this;
		}
	}
    int UseCount() {return m_use_count;}

    void SetConsoleData(IConsoleNameSpace * pConsoleNameSpace,IConsole * pConsole)
    {
         _lpConsoleNameSpace = pConsoleNameSpace;
         _lpConsole = pConsole;
    }

protected:
    virtual ~CIISObject();

private:
	LONG m_use_count;




//
// Interface:
//
public:
    virtual void * GetNodeType()
    {
        return (void *)&cInternetRootNode;
    }
	void * GetDisplayName()
    {
        return (void *)QueryDisplayName();
    }
    CIISObject * GetMachineObject() {return m_pMachineObject;}
    STDMETHOD(GetScopePaneInfo)(LPSCOPEDATAITEM lpScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(LPRESULTDATAITEM lpResultDataItem);
    STDMETHOD(GetResultViewType)(LPOLESTR *lplpViewType, long * lpViewOptions);
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader) {}
    virtual HRESULT SetToolBarStates(CComPtr<IToolbar> lpToolBar);
    virtual HRESULT RenameItem(LPOLESTR new_name) {return S_OK;}
    virtual HRESULT GetContextHelp(CString& strHtmlPage);
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);
    STDMETHOD (FillCustomData)(CLIPFORMAT cf, LPSTREAM pStream);

    virtual LPOLESTR QueryDisplayName() = 0;
    virtual int QueryImage() const = 0;
    //
    // Comparison methods
    //
    virtual int CompareScopeItem(CIISObject * pObject);
    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);

	void DoRunOnce(
		IN MMC_NOTIFY_TYPE event,
		IN LPARAM arg,
		IN LPARAM param
		);

    STDMETHOD(Notify)( 
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
        IComponentData * pComponentData,
        IComponent * pComponent,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IExtendPropertySheet methods
    //
    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);

//
// Access
//
public:
    //
    // Type Functions
    //
    virtual BOOL IsControllable() const     { return FALSE; }
    virtual BOOL IsPausable() const         { return FALSE; }
    virtual BOOL IsConfigurable() const     { return FALSE; }
    virtual BOOL IsDeletable() const        { return FALSE; }
    virtual BOOL IsRefreshable() const      { return FALSE; }
    virtual BOOL IsConnectable() const      { return FALSE; }
    virtual BOOL IsDisconnectable() const   { return FALSE; }
    virtual BOOL IsLeafNode() const         { return FALSE; }
    virtual BOOL HasFileSystemFiles() const { return FALSE; }
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const { return _T(""); }
    virtual BOOL IsConfigFlushable() const  { return FALSE; }
    virtual BOOL IsConfigImportExportable() const  { return FALSE; }

    //
    // State Functions
    //
    virtual BOOL IsRunning() const          { return FALSE; }
    virtual BOOL IsStopped() const          { return FALSE; }
    virtual BOOL IsPaused() const           { return FALSE; }
    virtual BOOL IsRenamable() const        { return FALSE; }
    virtual BOOL IsClonable() const         { return FALSE; }
    virtual BOOL IsBrowsable() const        { return FALSE; }
    virtual BOOL IsExplorable() const       { return FALSE; }
    virtual BOOL IsOpenable() const         { return FALSE; }
    virtual BOOL IsPermissionable() const   { return FALSE; }
	virtual BOOL HasResultItems(IResultData * pResult) const     
    { 
        return FALSE; 
    }

//
// Assumed Functions
//
public:
    virtual BOOL IsStartable() const { return IsControllable() && !IsRunning(); }
    virtual BOOL IsStoppable() const { return IsControllable() && (IsRunning() || IsPaused() ); }

public:
    BOOL IsExpanded() const;
    CIISObject * FindIdenticalScopePaneItem(CIISObject * pObject);
    HSCOPEITEM QueryScopeItem() const { return m_hScopeItem; }
    void ResetScopeItem() { m_hScopeItem = 0; }
    void ResetResultItem() { m_hResultItem = 0; }
    HSCOPEITEM QueryResultItem() const { return m_hResultItem; }
    HRESULT AskForAndAddMachine();
	void SetMyPropertySheetOpen(HWND hwnd) {m_hwnd = hwnd; }
	HWND IsMyPropertySheetOpen() const { return m_hwnd; }
    HRESULT AddToScopePane(
        HSCOPEITEM hRelativeID,
        BOOL fChild = TRUE,           
        BOOL fNext = TRUE,
        BOOL fIsParent = TRUE
        );

    HRESULT AddToScopePaneSorted(HSCOPEITEM hParent, BOOL fIsParent = TRUE);
    HRESULT RefreshDisplay(BOOL bRefreshToolBar = TRUE);
    HRESULT SetCookie();
    void SetScopeItem(HSCOPEITEM hItem)
    {
#if defined(_DEBUG) || DBG
       // cWebServiceExtension will reset m_hScopeItem
	   ASSERT( IsEqualGUID(* (GUID *) GetNodeType(),cWebServiceExtension) ? TRUE : m_hScopeItem == 0);
#endif
       m_hScopeItem = hItem;
    }
    virtual HRESULT OnDblClick(IComponentData * pcd, IComponent * pc);
    HRESULT SelectScopeItem();
    virtual HRESULT RemoveScopeItem();
    void SetResultItem(HRESULTITEM hItem)
    {
#if defined(_DEBUG) || DBG
		// cWebServiceExtension will reset m_hResultItem
        ASSERT( IsEqualGUID(* (GUID *) GetNodeType(),cWebServiceExtension) ? TRUE : m_hResultItem == 0);
#endif
        m_hResultItem = hItem;
    }
    virtual int QuerySortWeight() const = 0;
    IConsoleNameSpace * GetConsoleNameSpace();
    IConsole * GetConsole();
    virtual HRESULT OnViewChange(BOOL fScope, IResultData * pResult, IHeaderCtrl * pHeader, DWORD hint) 
    {
        return S_OK;
    }
    // Tag is created when propertypage is open
    // tries to uniquely mark the item based on what it is representing
    // thus if you matched another items Tag with this tag and it matched
    // you would know that the item you are pointing to is really the same item.
    virtual CreateTag(){m_strTag = _T("");}

//
// Event Handlers
//
protected:
    virtual HRESULT EnumerateResultPane(BOOL fExpand, IHeaderCtrl * lpHeader,
        IResultData * lpResultData, BOOL fForRefresh = FALSE);
	virtual HRESULT CleanResult(IResultData * pResultData)
	{
		return S_OK;
	}
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent) { return S_OK; }
    virtual HRESULT DeleteChildObjects(HSCOPEITEM hParent);
    virtual HRESULT RemoveChildren(HSCOPEITEM hParent);
    virtual HRESULT Refresh(BOOL fReEnumerate = TRUE) { return S_OK; }
    virtual HRESULT AddImages(LPIMAGELIST lpImageList);
    virtual HRESULT SetStandardVerbs(LPCONSOLEVERB lpConsoleVerb);
    virtual CIISRoot * GetRoot();
    virtual HRESULT DeleteNode(IResultData * pResult);
	virtual HRESULT ChangeVisibleColumns(MMC_VISIBLE_COLUMNS * pCol);
    virtual HRESULT ForceReportMode(IResultData * pResult) const { return S_OK; };

    static HRESULT AddMMCPage(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CPropertyPage * pPage
        );

protected:
    //
    // Add Menu Command helpers
    //
    static HRESULT AddMenuSeparator(
        LPCONTEXTMENUCALLBACK lpContextMenuCallback,
        LONG lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP
        );

    static HRESULT AddMenuItemByCommand(
        LPCONTEXTMENUCALLBACK lpContextMenuCallback,
        LONG lCmdID,
        LONG fFlags = 0
        );

    //
    // Create result view helper
    //
    static void BuildResultView(
        LPHEADERCTRL pHeader,
        int cColumns,
        int * pnIDS,
        int * pnWidths
        );

protected:
    HSCOPEITEM m_hScopeItem;
    HRESULTITEM m_hResultItem;
	BOOL m_fSkipEnumResult;

public:
   static const GUID * m_NODETYPE;
   static const OLECHAR * m_SZNODETYPE;
   static const OLECHAR * m_SZDISPLAY_NAME;
   static const CLSID * m_SNAPIN_CLASSID;
   BOOL m_fIsExtension;
   DWORD m_UpdateFlag;
   BOOL m_fFlaggedForDeletion;
   HWND m_hwnd;
   LONG_PTR m_ppHandle;
   CString m_strTag;
   CIISObject * m_pMachineObject;

public:
   static CWnd * GetMainWindow(IConsole * pConsole);
   // for extended view
   virtual HRESULT GetProperty(LPDATAOBJECT pDataObject,BSTR szPropertyName,BSTR* pbstrProperty);
   CComPtr<IConsole> _lpConsole;
   CComPtr<IConsoleNameSpace> _lpConsoleNameSpace;

protected:
   static IToolbar * _lpToolBar;
   static CComPtr<IComponent> _lpComponent;
   static CComPtr<IComponentData> _lpComponentData;
   static CComBSTR _bstrLocalHost;

public:
    static CLIPFORMAT m_CCF_MachineName;
    static CLIPFORMAT m_CCF_MyComputMachineName;
    static CLIPFORMAT m_CCF_Service;
    static CLIPFORMAT m_CCF_Instance;
    static CLIPFORMAT m_CCF_ParentPath;
    static CLIPFORMAT m_CCF_Node;
    static CLIPFORMAT m_CCF_MetaPath;

    static void Init()
    {
        m_CCF_MachineName = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_MACHINE_NAME);
        m_CCF_MyComputMachineName = (CLIPFORMAT)RegisterClipboardFormat(MYCOMPUT_MACHINE_NAME);
        m_CCF_Service = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_SERVICE);
        m_CCF_Instance = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_INSTANCE);
        m_CCF_ParentPath = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_PARENT_PATH);
        m_CCF_Node = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_NODE);
        m_CCF_MetaPath = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_META_PATH);
    }
};
typedef CList<CIISObject *, CIISObject *&> CIISObjectList;

_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_MachineName = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_MyComputMachineName = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_Service = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_Instance = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_ParentPath = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_Node = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_MetaPath = 0;

class CIISRoot : public CIISObject
{
//
// Constructor/Destructor
//
public:
    CIISRoot();
protected:
    virtual ~CIISRoot();

//
// Interface
//
public:
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual HRESULT DeleteChildObjects(HSCOPEITEM hParent);

//
// Access
//
public:
    virtual BOOL IsConnectable() const      
	{ 
		return !IsExtension(); 
	}
    virtual LPOLESTR QueryDisplayName() { return m_bstrDisplayName; }
    virtual int QueryImage() const { return iIISRoot; } 
    virtual int QuerySortWeight() const { return SW_ROOT; }
    virtual void * GetNodeType()
    {
        return (void *)&cInternetRootNode;
    }
    STDMETHOD (FillCustomData)(CLIPFORMAT cf, LPSTREAM pStream);
    BOOL IsExtension() const 
    {
        return m_fIsExtension;
    }

public:
    CIISServerCache m_scServers;
    HRESULT InitAsExtension(IDataObject * pDataObject);
    HRESULT ResetAsExtension();
    virtual CreateTag(){m_strTag = _T("CIISRoot");}

protected:
    virtual CIISRoot * GetRoot() { return this; }

    HRESULT EnumerateScopePaneExt(HSCOPEITEM hParent);

protected:
    CComBSTR m_bstrDisplayName;
    static OLECHAR * m_SZNODETYPE;
    // we are using this machine name and pointer 
    // only for extension case
    CIISMachine * m_pMachine;
    CString m_ExtMachineName;
    BOOL m_fRootAdded;
};

typedef CList<CIISFileName *, CIISFileName *&> ResultItemsList;

typedef struct _ResultViewEntry
{
	LONG_PTR _ResultData;
    ResultItemsList * _ResultItems;
	struct _ResultViewEntry& operator =(struct _ResultViewEntry& e)
	{
		_ResultData = e._ResultData;
		_ResultItems = e._ResultItems;
		return *this;
	}
} ResultViewEntry;

class CIISMBNode : public CIISObject
/*++

Class Description:

    Metabase node class

Public Interface:

--*/
{
//
// Constructor/Destructor
//
public:
    CIISMBNode(CIISMachine * pOwner, LPCTSTR szNode);
protected:
    ~CIISMBNode();

//
// Access
//
public:
    LPOLESTR QueryNodeName() const { return m_bstrNode; }
    CComBSTR & GetNodeName() { return m_bstrNode; }
    virtual LPOLESTR QueryMachineName() const;
    virtual CComAuthInfo * QueryAuthInfo();
    virtual CMetaInterface * QueryInterface();
    virtual BOOL IsLocal() const;
    virtual BOOL HasInterface() const;
	virtual BOOL HasResultItems(IResultData * pResult) const
	{
	    POSITION pos = m_ResultViewList.GetHeadPosition();
	    while (pos != NULL)
	    {
		    ResultViewEntry e = m_ResultViewList.GetNext(pos);
		    if (e._ResultData == (DWORD_PTR)pResult)
		    {
			    return !e._ResultItems->IsEmpty();
			}
		}
        return FALSE;
	}
    virtual HRESULT CreateInterface(BOOL fShowError);
    virtual HRESULT AssureInterfaceCreated(BOOL fShowError);
    virtual void SetInterfaceError(HRESULT hr);
    BOOL OnLostInterface(CError & err);
    BOOL IsLostInterface(CError & err) const;
    BOOL IsAdministrator() const;
    WORD QueryMajorVersion() const;
    WORD QueryMinorVersion() const;
    CIISMachine * GetOwner() {return m_pOwner;}

//
// Interface:
//
public:
    void DisplayError(CError & err, HWND hWnd = NULL) const;
    virtual BOOL IsRefreshable() const  { return TRUE; }
    virtual HRESULT RefreshData() { return S_OK; }
    virtual HRESULT Refresh(BOOL fReEnumerate = TRUE);
    virtual HRESULT OnDblClick(IComponentData * pcd, IComponent * pc)
    {
        return CIISObject::OnDblClick(pcd, pc);
    }
    virtual HRESULT RenameItem(LPOLESTR new_name) 
    {
       ASSERT(IsRenamable());
       return S_OK;
    }
    STDMETHOD (FillCustomData)(CLIPFORMAT cf, LPSTREAM pStream);
    STDMETHOD (CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );
    virtual void * GetNodeType()
    {
        // We really shouldn't be here
        return CIISObject::GetNodeType();
    }
    virtual HRESULT OnViewChange(BOOL fScope, IResultData * pResult, IHeaderCtrl * pHeader, DWORD hint);

public:
    //
    // Build metabase path
    //
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;

    //
    // Build URL
    //
    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    
    virtual CreateTag();

    CIISMBNode * GetParentNode() const;
	HRESULT RemoveResultNode(CIISMBNode * pNode, IResultData * pResult);

protected:

    HRESULT EnumerateResultPane_(
        BOOL fExpand, 
        IHeaderCtrl * lpHeader,
        IResultData * lpResultData,
        CIISService * pService
        );

	virtual HRESULT CleanResult(IResultData * pResultData);
    HRESULT CreateEnumerator(CMetaEnumerator *& pEnum);
    HRESULT EnumerateVDirs(HSCOPEITEM hParent, CIISService * pService, BOOL bDisplayError = TRUE);
    HRESULT EnumerateWebDirs(HSCOPEITEM hParent, CIISService * pService);
    HRESULT AddFTPSite(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      DWORD * inst
      );

    HRESULT AddFTPVDir(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CString& alias
      );

    HRESULT AddWebSite(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      DWORD * inst,
	  DWORD version_major,
	  DWORD version_minor
      );

    HRESULT AddWebVDir(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CString& alias,
	  DWORD version_major,
	  DWORD version_minor
      );

    HRESULT AddAppPool(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CAppPoolsContainer * pCont,
      CString& name
      );

    BOOL GetPhysicalPath(
        LPCTSTR metaPath, 
        CString & alias,
        CString &physPath);

protected:
    STDMETHOD(GetResultViewType)(LPOLESTR *lplpViewType, long * lpViewOptions);
    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );
    virtual HRESULT DeleteNode(IResultData * pResult);
//
// Helpers
//
protected:
    void SetErrorOverrides(CError & err, BOOL fShort = FALSE) const;
    LPCTSTR BuildPhysicalPath(CString & strPhysicalPath) const;
	ResultItemsList * AddResultItems(IResultData * pResultData);
//	ResultItemsList * FindResultItems(IResultData * pResultData);

protected:
    static LPOLESTR _cszSeparator;
    static CComBSTR _bstrRedirectPathBuf;

protected:
    CComBSTR m_bstrNode;
    CComBSTR m_bstrURL;
    CString m_strRedirectPath;
    CIISMachine * m_pOwner;

	CList<ResultViewEntry, ResultViewEntry&> m_ResultViewList;
};
typedef CList<CIISMBNode *, CIISMBNode *&> CIISMBNodeList;


class CIISMachine : public CIISMBNode
/*++

Class Description:

    IIS Machine object.  This is the object that owns the interface.
    
Public Interface:


--*/
{
//
// Constructor/Destructor
//
public:
    CIISMachine(
        IConsoleNameSpace * pConsoleNameSpace,
        IConsole * pConsole,
        CComAuthInfo * pAuthInfo = NULL,
        CIISRoot * pRoot = NULL);

protected:
    virtual ~CIISMachine();

//
// Access
//
public:
    static DWORD WINAPI GetProcessModeThread(LPVOID pInfo);
    BOOL GetProcessMode(GET_PROCESS_MODE_STRUCT * pMyStructOfInfo);

    virtual BOOL IsConnectable() const 
	{ 
		return (m_pRootExt == NULL); 
	}
    virtual BOOL IsDisconnectable() const 
	{ 
		return (m_pRootExt == NULL); 
	}
    virtual BOOL IsConfigurable() const 
    { 
        // bug:667856 should allow mimemaps for iis6 and iis5, but not for iis5.1.  and not for anything before iis5
        return 
            (
            IsAdministrator() && 
            (
            (QueryMajorVersion() >= 6) || 
            ((QueryMajorVersion() == 5) && (QueryMinorVersion() == 0))
            )); 
    }
    virtual BOOL IsBrowsable() const { return TRUE; }

    virtual BOOL IsConfigFlushable() const 
    { 
        return (QueryMajorVersion() >= 6);
    }

    virtual LPOLESTR QueryDisplayName();
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual int QueryImage() const;
    virtual int CompareScopeItem(CIISObject * pObject);
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const { return IIS_CLASS_COMPUTER_W; }

    virtual LPOLESTR QueryMachineName() const { return QueryServerName();  }
    virtual CComAuthInfo * QueryAuthInfo() { return &m_auth; }
    virtual CMetaInterface * QueryInterface() { return m_pInterface; }
    virtual BOOL HasInterface() const { return m_pInterface != NULL; }
    virtual BOOL IsLocal() const { return m_auth.IsLocal(); }
    BOOL IsLocalHost();
    virtual HRESULT CreateInterface(BOOL fShowError);
    virtual HRESULT AssureInterfaceCreated(BOOL fShowError);
    virtual void SetInterfaceError(HRESULT hr);
   
    HRESULT CheckCapabilities();
    HRESULT Impersonate(LPCTSTR szUserName, LPCTSTR szPassword);
    void RemoveImpersonation();
    BOOL HasAdministratorAccess()
    {
        return m_fIsAdministrator;
    }
    void StorePassword(LPCTSTR szPassword);
    BOOL ResolvePasswordFromCache();
    BOOL ResolveCredentials();
    BOOL HandleAccessDenied(CError & err);
    BOOL SetCacheDirty();
    BOOL UsesImpersonation() const { return m_auth.UsesImpersonation(); }
    BOOL PasswordEntered() const { return m_fPasswordEntered; }
    BOOL CanAddInstance() const { return m_fCanAddInstance; }
    BOOL Has10ConnectionsLimit() const { return m_fHas10ConnectionsLimit; }
	BOOL IsWorkstation() const { return m_fIsWorkstation; }
	BOOL IsPerformanceConfigurable() const { return m_fIsPerformanceConfigurable; }
	BOOL IsServiceLevelConfigurable() const { return m_fIsServiceLevelConfigurable; }

    WORD QueryMajorVersion() const { return LOWORD(m_dwVersion); }
    WORD QueryMinorVersion() const { return HIWORD(m_dwVersion); }

    LPOLESTR QueryServerName() const { return m_auth.QueryServerName(); }
    LPOLESTR QueryUserName() const { return m_auth.QueryUserName(); }
    LPOLESTR QueryPassword() const { return m_auth.QueryPassword(); }

    CAppPoolsContainer * QueryAppPoolsContainer() { return m_pAppPoolsContainer; }
    CWebServiceExtensionContainer * QueryWebSvcExtContainer() { return m_pWebServiceExtensionContainer; }

    virtual CreateTag() {m_strTag = QueryDisplayName();}

    virtual void * GetNodeType()
    {
        return (void *)&cMachineNode;
    }

    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );
    STDMETHOD(Command)(
        long lCommandID,     
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );
    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(GetResultViewType)(LPOLESTR *lplpViewType, long * lpViewOptions);

    DWORD GetMetabaseSystemChangeNumber()
    {
        return m_dwMetabaseSystemChangeNumber;
    }
    HRESULT RefreshMetabaseSystemChangeNumber();

protected:
    void SetDisplayName();
    HRESULT OnMetaBackRest();
    HRESULT OnShutDown();
    HRESULT OnSaveData();
    HRESULT OnDisconnect();
    HRESULT InsertNewInstance(DWORD inst);

//
// Events
//
public:
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;
    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    

public:
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual HRESULT RemoveScopeItem();
    virtual HRESULT RefreshData();
    virtual int     QuerySortWeight() const { return SW_MACHINE; }
    virtual HRESULT DeleteChildObjects(HSCOPEITEM hParent);
	virtual HRESULT DeleteNode(IResultData * pResult) {return S_OK;}

//
// Public Interface:
//
public:
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    static HRESULT VerifyMachine(CIISMachine *& pMachine);

//
// Stream handlers
//
public:
    static  HRESULT ReadFromStream(IStream * pStg, CIISMachine ** ppMachine, IConsoleNameSpace * pConsoleNameSpace,IConsole * pConsole);
    HRESULT WriteToStream(IStream * pStgSave);
    HRESULT InitializeFromStream(IStream * pStg);
    DWORD m_dwMetabaseSystemChangeNumber;
	CWNetConnectionTracker m_MachineWNetConnections;

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_NAME,
        COL_LOCAL,
        COL_VERSION,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
    static LPOLESTR _cszNodeName;
    static CComBSTR _bstrYes;
    static CComBSTR _bstrNo;
    static CComBSTR _bstrVersionFmt;
    static BOOL     _fStaticsLoaded;

private:
    BOOL m_fPasswordEntered;
    BSTR m_bstrDisplayName;
    DWORD m_dwVersion;
    CError m_err;
    CComAuthInfo m_auth;
    CMetaInterface * m_pInterface;
    CIISRoot * m_pRootExt;
    BOOL m_fCanAddInstance;
    BOOL m_fHas10ConnectionsLimit;
	BOOL m_fIsWorkstation;
	BOOL m_fIsPerformanceConfigurable;
	BOOL m_fIsServiceLevelConfigurable;
    BOOL m_fIsAdministrator;
    BOOL m_fIsLocalHostIP;
    BOOL m_fLocalHostIPChecked;

    CAppPoolsContainer * m_pAppPoolsContainer;
    CWebServiceExtensionContainer * m_pWebServiceExtensionContainer;
};



//
// Callback function to bring up site properties dialog
//
typedef HRESULT (__cdecl * PFNPROPERTIESDLG)(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,    
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,             
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR    handle               
    );



class CIISService : public CIISMBNode
/*++

Class Description:

Public: Interface:

--*/
{
//
// Service definition
//
protected:
    typedef struct tagSERVICE_DEF
    {
        LPCTSTR szNodeName;
        LPCTSTR szProtocol;
        UINT    nDescriptiveName;
        int     nServiceImage;
		int     nServiceImageStopped;
        int     nSiteImage;
		int		nSiteImageStopped;
		int		nSiteImageErr;
        int     nVDirImage;
        int     nVDirImageErr;
        int     nDirImage;
        int     nFileImage;
		LPCTSTR szServiceClass;
		LPCTSTR szServerClass;
		LPCTSTR szVDirClass;
        PFNPROPERTIESDLG pfnSitePropertiesDlg;
        PFNPROPERTIESDLG pfnDirPropertiesDlg;
    }
    SERVICE_DEF;

    static SERVICE_DEF _rgServices[];

    static int ResolveServiceName(
         LPCTSTR    szServiceName
        );

//
// Property Sheet callbacks
//
protected:
    static HRESULT __cdecl ShowFTPSiteProperties(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );

    static HRESULT __cdecl ShowFTPDirProperties(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );

    static HRESULT __cdecl ShowWebSiteProperties(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );

    static HRESULT __cdecl ShowWebDirProperties(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );
  
//
// Constructor/Destructor
// 
public:
    CIISService(
        CIISMachine * pOwner,
        LPCTSTR szServiceName
        );
protected:

    virtual ~CIISService();

//
// Events
//
public:
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
	virtual HRESULT RefreshData();

//
// Interface:
//
public:
    HRESULT ShowSitePropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );

    HRESULT ShowDirPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

//
// Access
//
public:
    BOOL IsManagedService() const;
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual LPOLESTR QueryDisplayName() 
    { 
        // Check if the service is disabled...
        // if it is then appened on the "(Disabled)" word...
        m_dwServiceStateDisplayed = m_dwServiceState;
	    if (-1 == m_dwServiceState)
	    {
            return m_bstrDisplayNameStatus;
	    }

        return m_bstrDisplayName;
    }
    virtual int QueryImage() const;
    virtual int QuerySortWeight() const { return SW_SERVICE; }
    LPCTSTR QueryServiceName()
    {
        return _rgServices[m_iServiceDef].szNodeName;
    }
	LPCTSTR QueryServiceClass() const
	{
        return _rgServices[m_iServiceDef].szServiceClass;
	}
	LPCTSTR QueryServerClass() const
	{
        return _rgServices[m_iServiceDef].szServerClass;
	}
	LPCTSTR QueryVDirClass() const
	{
        return _rgServices[m_iServiceDef].szVDirClass;
	}
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const { return QueryServiceClass(); }

//
// Display Types 
//
public:
    int QueryServiceImage () const;
	int QueryServiceImageStopped () const;
    int QuerySiteImage() const;
    int QuerySiteImageStopped() const;
    int QuerySiteImageErr() const;
    int QueryVDirImage() const;
    int QueryVDirImageErr() const;
    int QueryDirImage() const;
    int QueryFileImage() const;
#if 0
    enum
    {
        IIS_SERVICE_DISABLED = 0
    };
    enum
    {
        SERVICE_COMMAND_STOP = 1,
        SERVICE_COMMAND_START,
        SERVICE_COMMAND_ENABLE
    };
#endif
	HRESULT GetServiceState();
    HRESULT GetServiceState(DWORD& mode, DWORD& state, CString& name);
    HRESULT ChangeServiceState(DWORD command);
    HRESULT EnableService();
    HRESULT StartService();
    virtual void * GetNodeType()
    {
        return (void *)&cServiceCollectorNode;
    }
    HRESULT InsertNewInstance(DWORD inst);
//
// Interface:
//
protected:
    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );
    STDMETHOD(Command)(
        long lCommandID,     
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );
//    STDMETHOD(CreatePropertyPages)(
//        LPPROPERTYSHEETCALLBACK lpProvider,
//        LONG_PTR handle, 
//        IUnknown * pUnk,
//        DATA_OBJECT_TYPES type
//        );

    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;

    virtual CreateTag()
    {
        CIISMachine * pMachine = GetOwner();
        if (pMachine)
        {
            // looks like "machinename (local computer)/LM/W3SVC"
            CComBSTR bstrPath;
            BuildMetaPath(bstrPath);
            m_strTag = pMachine->QueryDisplayName();
            m_strTag += bstrPath;
        }
    }

    //
    // Master properties
    //
    virtual BOOL IsConfigurable() const     { return IsAdministrator(); }
    virtual BOOL IsConfigImportExportable() const 
    { 
        return (QueryMajorVersion() >= 6);
    }
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
	virtual HRESULT DeleteNode(IResultData * pResult) {return S_OK;}

protected:
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
        /**/
        COL_TOTAL
    };
    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];
    static CComBSTR _bstrServiceDisabled;
    static CComBSTR _bstrServiceRunning;
    static CComBSTR _bstrServiceStopped;
    static CComBSTR _bstrServicePaused;
    static CComBSTR _bstrServiceStopPending;
    static CComBSTR _bstrServiceStartPending;
    static CComBSTR _bstrServicePausePending;
    static CComBSTR _bstrServiceContPending;
    static BOOL _fStaticsLoaded;

public:
	DWORD     m_dwServiceState;
	DWORD     m_dwServiceStateDisplayed;

private:
    int       m_iServiceDef;
    BOOL      m_fManagedService;
    BOOL      m_fCanAddInstance;
    CComBSTR  m_bstrDisplayName;
    CComBSTR  m_bstrDisplayNameStatus;
};

class CAppPoolNode;
typedef CList<CAppPoolNode *, CAppPoolNode *>	CPoolList;

class CAppPoolsContainer : public CIISMBNode
/*++

Class Description:

Public: Interface:

--*/
{
//
// Property Sheet callbacks
//
protected:
    static HRESULT __cdecl ShowProperties(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,            
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,                     
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR    handle                       
        );

//
// Constructor/Destructor
// 
public:
    CAppPoolsContainer(
        CIISMachine * pOwner,
        CIISService * pWebService
        );

    virtual ~CAppPoolsContainer();

//
// Events
//
public:
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);

//
// Interface:
//
public:
    HRESULT ShowPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,            
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,                     
        LPARAM lParam,                      
        LPARAM lParamParent,                      
        LONG_PTR handle                       
        );

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

//
// Access
//
public:
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual LPOLESTR QueryDisplayName() 
    {
       return m_bstrDisplayName;
    }
    virtual int QueryImage() const {return iFolder;}
    virtual int QuerySortWeight() const {return SW_APP_POOLS;}

    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
	virtual HRESULT DeleteNode(IResultData * pResult) {return S_OK;}
    virtual void * GetNodeType(){return (void *)&cAppPoolsNode;}
    virtual HRESULT RefreshData();
    HRESULT RefreshDataChildren(CString AppPoolToRefresh,BOOL bVerifyChildren);
    HRESULT EnumerateAppPools(CPoolList * pList);
    HRESULT QueryDefaultPoolId(CString& id);
    HRESULT InsertNewPool(CString& id);
    virtual CreateTag()
    {
        CIISMachine * pMachine = GetOwner();
        if (pMachine)
        {
            // looks like "machinename (local computer)/LM/W3SVC/AppPools"
            CComBSTR bstrPath;
            BuildMetaPath(bstrPath);
            m_strTag = pMachine->QueryDisplayName();
            m_strTag += bstrPath;
        }
    }

//
// Interface:
//
protected:
    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );

    //
    // Master properties
    //
    virtual BOOL IsConfigurable() const     { return IsAdministrator(); }
    virtual BOOL IsConfigImportExportable() const 
    { 
        return (QueryMajorVersion() >= 6);
    }

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

private:
    CComBSTR  m_bstrDisplayName;
    CIISService * m_pWebService;
};

class CAppPoolNode : public CIISMBNode
{
//
// Constructor/Destructor
//
public:
    //
    // Constructor which will resolve its properties at display time
    //
    CAppPoolNode(
        CIISMachine * pOwner,
        CAppPoolsContainer * pContainer,
        LPCTSTR szNodeName,
        DWORD dwState
        );


    virtual ~CAppPoolNode();

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual LPOLESTR QueryDisplayName();
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual HRESULT DeleteNode(IResultData * pResult);

public:
    //
    // Type Functions
    //
//    virtual BOOL IsControllable() const { return TRUE; }
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const {return TRUE; }
    virtual BOOL IsRefreshable() const { return TRUE; }
//    virtual BOOL IsRenamable() const { return TRUE; }
    virtual BOOL IsConfigImportExportable() const 
    { 
        return (QueryMajorVersion() >= 6);
    }

    //
    // State Functions
    //
    virtual BOOL IsRunning() const { return m_dwState != MD_APPPOOL_STATE_STOPPED; }
    virtual BOOL IsStopped() const { return m_dwState == MD_APPPOOL_STATE_STOPPED; }
    virtual BOOL IsStartable() const { return !IsRunning(); }
    virtual BOOL IsStoppable() const { return IsRunning(); }


//
// Interface:
//
public:
    virtual HRESULT RefreshData();
    HRESULT RefreshData(BOOL bRefreshChildren,BOOL bVerifyChildren);
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual int QuerySortWeight() const { return SW_APP_POOL; }
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;
    virtual CreateTag()
    {
        CIISMachine * pMachine = GetOwner();
        if (pMachine)
        {
            // looks like "machinename (local computer)/LM/W3SVC/AppPools/DefaultAppPool"
            CComBSTR bstrPath;
            BuildMetaPath(bstrPath);
            m_strTag = pMachine->QueryDisplayName();
            m_strTag += bstrPath;
        }
    }

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cAppPoolNode;
    }

public:
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    HRESULT ChangeState(DWORD dwCommand);

protected:
    HRESULT ShowPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );
    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
		COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
    static CComBSTR _bstrStarted;
    static CComBSTR _bstrStopped;
//    static CComBSTR _bstrPaused;
    static CComBSTR _bstrUnknown;
    static CComBSTR _bstrPending;
    static BOOL _fStaticsLoaded;

private:
    CString m_strDisplayName;
    
    //
    // Data members
    //
    BOOL m_fDeletable;
    DWORD m_dwState;
    DWORD m_dwWin32Error;
    CAppPoolsContainer * m_pContainer;
};

class CIISSite : public CIISMBNode
{
//
// Constructor/Destructor
//
public:
    //
    // Constructor which will resolve its properties at display time
    //
    CIISSite(
        CIISMachine * pOwner,
        CIISService * pService,
        LPCTSTR szNodeName
        );

    //
    // Constructor with full information
    //
    CIISSite(
        CIISMachine * pOwner,
        CIISService * pService,
        LPCTSTR  szNodeName,
        DWORD    dwState,
        BOOL     fClusterEnabled,
        USHORT   sPort,
        DWORD    dwID,
        DWORD    dwIPAddress,
        DWORD    dwWin32Error,
        LPOLESTR szHostHeaderName,
        LPOLESTR szComment
        );
protected:

    virtual ~CIISSite();

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual LPOLESTR QueryDisplayName();
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const 
    { 
        ASSERT_PTR(m_pService);
        if (path != NULL && !CMetabasePath::IsMasterInstance(path))
        {
            return m_pService->QueryVDirClass(); 
        }
        else
        {
            return m_pService->QueryServerClass(); 
        }
    }
    
public:
    //
    // Type Functions
    //
    virtual BOOL IsControllable() const { return TRUE; }
    virtual BOOL IsPausable() const { return IsRunning() || IsPaused(); }
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const 
    {
        // Do not delete the only site for Pro SKU
        CIISSite * that = (CIISSite *)this;
        return !that->GetOwner()->IsWorkstation();
    }
    virtual BOOL IsRenamable() const { return TRUE; }
    virtual BOOL HasFileSystemFiles() const 
    {
        if (TRUE == m_fUsingActiveDir)
        {
            return FALSE;
        }
        return TRUE;
    }

    virtual BOOL IsConfigImportExportable() const 
    { 
        return (QueryMajorVersion() >= 6);
    }

    //
    // State Functions
    //
    virtual BOOL IsRunning() const { return m_dwState == MD_SERVER_STATE_STARTED; }
    virtual BOOL IsStopped() const { return m_dwState == MD_SERVER_STATE_STOPPED; }
    virtual BOOL IsPaused() const  { return m_dwState == MD_SERVER_STATE_PAUSED; }
    virtual BOOL IsBrowsable() const { return TRUE; }
    virtual BOOL IsExplorable() const { return TRUE; }
    virtual BOOL IsOpenable() const { return TRUE; }
    virtual BOOL IsPermissionable() const   { return TRUE; }

//
// Data Access
//
public:
    BOOL   IsWolfPackEnabled() const { return m_fWolfPackEnabled; }
    DWORD  QueryIPAddress() const { return m_dwIPAddress; }
    DWORD  QueryWin32Error() const { return m_dwWin32Error; }
    USHORT QueryPort() const { return m_sPort; }
    USHORT QuerySSLPort() const { return m_sSSLPort; }
    CIISService * QueryServiceContainer() {return m_pService;}
	BOOL IsFtpSite()
	{
		if (m_pService)
		{
			return _tcsicmp(m_pService->QueryServiceName(), SZ_MBN_FTP) == 0;
		}
		return FALSE;
	}
	BOOL IsWebSite()
	{
		if (m_pService)
		{
			return _tcsicmp(m_pService->QueryServiceName(), SZ_MBN_WEB) == 0;
		}
		return FALSE;
	}

//
// Interface:
//
public:
    virtual HRESULT RefreshData();
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual int QuerySortWeight() const { return SW_SITE; }
    virtual HRESULT RenameItem(LPOLESTR new_name);
    virtual HRESULT DeleteNode(IResultData * pResult);

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cInstanceNode;
    }

    virtual CreateTag()
    {
        CIISMachine * pMachine = GetOwner();
        if (pMachine)
        {
            // looks like "machinename (local computer)/LM/W3SVC/1/Root"
            CComBSTR bstrPath;
            BuildMetaPath(bstrPath);
            m_strTag = pMachine->QueryDisplayName();
            m_strTag += bstrPath;
        }
    }

public:
    static void LoadStatics(void);
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    static void InitializeHeaders2(LPHEADERCTRL lpHeader);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
	DWORD GetInstance() { return m_dwID; }

protected:
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;
    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    
    virtual HRESULT EnumerateResultPane(BOOL fExpand, IHeaderCtrl * lpHeader,
        IResultData * lpResultData, BOOL fForRefresh = FALSE);

    HRESULT ChangeState(DWORD dwCommand);

    HRESULT ShowPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );
    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );
    HRESULT InsertNewInstance(DWORD inst);
    HRESULT InsertNewAlias(CString alias);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_ID,
        COL_STATE,
        COL_DOMAIN_NAME,
        COL_IP_ADDRESS,
        COL_TCP_PORT,
        COL_SSL_PORT,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    enum
    {
        COL_DESCRIPTION2,
        COL_ID2,
        COL_STATE2,
        COL_IP_ADDRESS2,
        COL_TCP_PORT2,
        COL_STATUS2,
        /**/
        COL_TOTAL2
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnLabels2[COL_TOTAL2];
    static int _rgnWidths[COL_TOTAL];
    static int _rgnWidths2[COL_TOTAL2];

protected:
    static CComBSTR _bstrStarted;
    static CComBSTR _bstrStopped;
    static CComBSTR _bstrPaused;
    static CComBSTR _bstrUnknown;
    static CComBSTR _bstrAllUnassigned;
    static CComBSTR _bstrPending;
    static BOOL     _fStaticsLoaded;

private:
    BOOL        m_fResolved;
    CString     m_strDisplayName;
    
    //
    // Data members
    //
    BOOL        m_fUsingActiveDir;
    BOOL        m_fWolfPackEnabled;
    BOOL        m_fFrontPageWeb;
    DWORD       m_dwID;
    DWORD       m_dwState;
    DWORD       m_dwIPAddress;
    DWORD       m_dwWin32Error;
	DWORD		m_dwEnumError;
    USHORT      m_sPort;
    USHORT      m_sSSLPort;
    CComBSTR    m_bstrHostHeaderName;
    CComBSTR    m_bstrComment;
    CIISService * m_pService;
    CComBSTR    m_bstrDisplayNameStatus;
};



class CIISDirectory : public CIISMBNode
/*++

Class Description:

    Vroot/dir/file class.

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Constructor which will resolve its properties at display time
    //
    CIISDirectory(
        CIISMachine * pOwner,
        CIISService * pService,
        LPCTSTR szNodeName
        );

    //
    // Constructor with full information
    //
    CIISDirectory(
        CIISMachine * pOwner,
        CIISService * pService,
        LPCTSTR szNodeName,
        BOOL fEnabledApplication,
        DWORD dwWin32Error,
        LPCTSTR redir_path
        );
protected:

    virtual ~CIISDirectory();

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual LPOLESTR QueryDisplayName() { return m_bstrDisplayName; }
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const 
	{ 
		return m_pService->QueryVDirClass(); 
	}
    LPOLESTR QueryPath() { return m_bstrPath; }
    CIISService * QueryServiceContainer() {return m_pService;}

public:
    //
    // Type Functions
    //
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const { return TRUE; }
//    virtual BOOL IsRenamable() const { return TRUE; }
    virtual BOOL IsConfigImportExportable() const 
    { 
        return (QueryMajorVersion() >= 6);
    }

    //
    // State Functions
    //
    virtual BOOL IsBrowsable() const { return TRUE; }
    virtual BOOL IsExplorable() const { return TRUE; }
    virtual BOOL IsOpenable() const { return TRUE; }
    virtual BOOL IsPermissionable() const   { return TRUE; }
    virtual BOOL HasFileSystemFiles() const { return TRUE; }
//
// Data Access
//
public:
    BOOL   IsEnabledApplication() const { return m_fEnabledApplication; }
    DWORD  QueryWin32Error() const { return m_dwWin32Error; }
	BOOL IsFtpDir()
	{
		return _tcsicmp(m_pService->QueryServiceName(), SZ_MBN_FTP) == 0;
	}
	BOOL IsWebDir()
	{
		return _tcsicmp(m_pService->QueryServiceName(), SZ_MBN_WEB) == 0;
	}

//
// Interface:
//
public:
    virtual HRESULT RefreshData();
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual HRESULT OnViewChange(BOOL fScope, IResultData * pResult, IHeaderCtrl * pHeader, DWORD hint);
    virtual int QuerySortWeight() const { return SW_VDIR; }
//    virtual HRESULT RenameItem(LPOLESTR new_name);

    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cChildNode;
    }

    virtual CreateTag()
    {
        CIISMachine * pMachine = GetOwner();
        if (pMachine)
        {
            // looks like "machinename (local computer)/LM/W3SVC/1/Root/TheVDir"
            CComBSTR bstrPath;
            BuildMetaPath(bstrPath);
            m_strTag = pMachine->QueryDisplayName();
            m_strTag += bstrPath;
        }
    }

public:
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    static void InitializeHeaders(LPHEADERCTRL lpHeader);

protected:
    //virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    
    HRESULT InsertNewAlias(CString alias);
    virtual HRESULT EnumerateResultPane(BOOL fExpand, IHeaderCtrl * lpHeader,
        IResultData * lpResultData, BOOL fForRefresh = FALSE)
    {
		CError err = CIISObject::EnumerateResultPane(fExpand, lpHeader, lpResultData, fForRefresh);
		if (    err.Succeeded() 
            &&  !IsFtpDir() 
//            &&  QueryWin32Error() == ERROR_SUCCESS 
            &&  m_strRedirectPath.IsEmpty()
            )
		{
			err = CIISMBNode::EnumerateResultPane_(
				fExpand, lpHeader, lpResultData, m_pService);
		}
		return err;
    }
    HRESULT ShowPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,            
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,                     
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle                       
        );

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS = 0,
        COL_PATH,
		COL_STATUS,
        //
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
//    static CComBSTR _bstrName, _bstrPath;
//    static BOOL     _fStaticsLoaded;

private:
    BOOL        m_fResolved;
    CComBSTR    m_bstrDisplayName;
    CComBSTR    m_bstrPath;
    
    //
    // Data members
    //
    BOOL        m_fEnabledApplication;
    DWORD       m_dwWin32Error;
	DWORD		m_dwEnumError;
    CIISService * m_pService;
};

class CApplicationNode;
typedef CList<CApplicationNode *, CApplicationNode *&> CApplicationList;

class CApplicationNode : public CIISMBNode
{
public:
    CApplicationNode(
        CIISMachine * pOwner,
        LPCTSTR path,
        LPCTSTR name
        )
    : CIISMBNode(pOwner, name),
    m_meta_path(path)
    {
    }
protected:        
        
    virtual ~CApplicationNode()
    {
    }

public:
    virtual BOOL IsLeafNode() const { return TRUE; }
    virtual int QueryImage() const
    {
        return iApplication;
    }
    virtual LPOLESTR QueryDisplayName();
    LPOLESTR QueryDisplayName(BOOL bForceQuery);
    virtual HRESULT BuildMetaPath(CComBSTR& path) const;
    virtual int QuerySortWeight() const
    {
       CString parent, alias;
       CMetabasePath::SplitMetaPathAtInstance(m_meta_path, parent, alias);
       return alias.IsEmpty() ? SW_SITE : SW_VDIR;
    }
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
//    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    virtual void * GetNodeType() {return (void *)&cApplicationNode;}
    virtual CreateTag()
    {
        // This node doesn't have properties
        m_strTag = _T("");
    }

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS,
        COL_PATH,
        //
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

    LPCTSTR FriendlyAppRoot(LPCTSTR lpAppRoot, CString & strFriendly);

private:
    CString m_strDisplayName;
    CString m_meta_path;
};

class CIISFileName : public CIISMBNode
{
public:
   CIISFileName(
      CIISMachine * pOwner,
      CIISService * pService,
      const DWORD dwAttributes,
      LPCTSTR alias,
      LPCTSTR redirect
      );
protected:
	virtual ~CIISFileName()
	{
        m_pService->Release();
	}

public:
   BOOL IsEnabledApplication() const 
   {
      return m_fEnabledApplication;
   }
   DWORD  QueryWin32Error() const 
   { 
       return m_dwWin32Error; 
   }

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual LPOLESTR QueryDisplayName() 
    { 
        return m_bstrFileName; 
    }
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual HRESULT DeleteNode(IResultData * pResult);
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const 
	{ 
		return (m_dwAttribute & FILE_ATTRIBUTE_DIRECTORY) != 0 ?
			IIS_CLASS_WEB_DIR_W : IIS_CLASS_WEB_FILE_W; 
	}
    CIISService * QueryServiceContainer() {return m_pService;}

    //
    // Type Functions
    //
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const { return TRUE; }
    virtual BOOL IsRenamable() const { return TRUE; }
    virtual BOOL IsLeafNode() const { return TRUE; }

    virtual BOOL IsConfigImportExportable() const 
    { 
        return (QueryMajorVersion() >= 6);
    }

    //
    // State Functions
    //
    virtual BOOL IsBrowsable() const { return TRUE; }
    virtual BOOL IsExplorable() const 
    { 
        return IsDir(); 
    }
    virtual BOOL IsOpenable() const 
	{ 
		return TRUE; 
	}
    virtual BOOL IsPermissionable() const
    {
        return TRUE; 
    }
    virtual BOOL HasFileSystemFiles() const 
    { 
        return IsDir(); 
    }

    virtual int QuerySortWeight() const 
    { 
       return IsDir() ? SW_DIR : SW_FILE; 
    }

    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual HRESULT RefreshData();
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual HRESULT OnDblClick(IComponentData * pcd, IComponent * pc);
    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );
    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );
    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cFileNode;
    }
    virtual CreateTag()
    {
        CIISMachine * pMachine = GetOwner();
        if (pMachine)
        {
            // looks like "machinename (local computer)/LM/W3SVC/1/Root/DirOrFilename"
            CComBSTR bstrPath;
            BuildMetaPath(bstrPath);
            m_strTag = pMachine->QueryDisplayName();
            m_strTag += bstrPath;
        }
    }
    virtual HRESULT RenameItem(LPOLESTR new_name);
    virtual HRESULT OnViewChange(BOOL fScope, IResultData * pResult, IHeaderCtrl * pHeader, DWORD hint);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS,
        COL_PATH,
        COL_STATUS,
        //
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

    HRESULT ShowPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );
    
    HRESULT ShowDirPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );

    HRESULT ShowFilePropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );

    HRESULT InsertNewAlias(CString alias);
    virtual HRESULT EnumerateResultPane(BOOL fExpand, IHeaderCtrl * lpHeader,
        IResultData * lpResultData, BOOL fForRefresh = FALSE)
    {
		CError err = CIISObject::EnumerateResultPane(fExpand, lpHeader, lpResultData, fForRefresh);
		if (err.Succeeded() && m_dwWin32Error == ERROR_SUCCESS)
		{
			err = CIISMBNode::EnumerateResultPane_(fExpand,
				lpHeader, lpResultData, m_pService);
		}
		return err;
    }

    BOOL IsDir() const
    {
        return (m_dwAttribute & FILE_ATTRIBUTE_DIRECTORY) != 0;
    }

private:
	BOOL m_fResolved;
    CComBSTR m_bstrFileName;
    CString m_RedirectString;
    BOOL m_fEnabledApplication;
    DWORD m_dwAttribute;
    DWORD m_dwWin32Error;
	DWORD m_dwEnumError;
    CIISService * m_pService;
};

class CWebServiceExtension;
typedef CList<CWebServiceExtension *, CWebServiceExtension *&> CExtensionList;

class CWebServiceExtensionContainer : public CIISMBNode
{
//
// Constructor/Destructor
// 
public:
    CWebServiceExtensionContainer(
        CIISMachine * pOwner,
        CIISService * pWebService
        );

    virtual ~CWebServiceExtensionContainer();

//
// Events
//
public:
    virtual HRESULT EnumerateResultPane(BOOL fExpand, IHeaderCtrl * lpHeader,IResultData * lpResultData, BOOL fForRefresh = FALSE);
    virtual HRESULT CleanResult(IResultData * pResultData);
    HRESULT CacheResult(IResultData * pResultData);
	virtual BOOL HasResultItems(IResultData * pResult) const { return FALSE; }

//
// Interface:
//
public:
    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

//
// Access
//
public:
    virtual BOOL IsLeafNode() const { return TRUE; }
    virtual BOOL IsRefreshable() const { return TRUE; }
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
	virtual HRESULT DeleteNode(IResultData * pResult) {return S_OK;}
    virtual LPOLESTR QueryDisplayName() {return m_bstrDisplayName;}
    virtual int QueryImage() const {return iFolder;}
    virtual int QuerySortWeight() const {return SW_WEBSVCEXTS;}
    virtual void * GetNodeType() {return (void *)&cWebServiceExtensionContainer;}
    virtual HRESULT RefreshData();
    virtual HRESULT ForceReportMode(IResultData * pResult) const;
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual HRESULT GetContextHelp(CString& strHtmlPage);    
    virtual CreateTag()
    {
        // This node doesn't have properties
        m_strTag = _T("");
    }
    // load data from metabase
	HRESULT EnumerateWebServiceExtensions(CExtensionList * pList);
    HRESULT InsertNewExtension(CRestrictionUIEntry * pNewEntry);
	HRESULT QueryResultPaneSelectionID(IResultData * lpResultData,CString& id);
    HRESULT SelectResultPaneSelectionID(IResultData * pResultData,CString id);

//
// Interface:
//
protected:
    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(GetResultViewType)(LPOLESTR *lplpViewType, long * lpViewOptions);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

private:
    CComBSTR  m_bstrDisplayName;
    CIISService * m_pWebService;
    IResultData * m_pResultData;
	CString m_strLastResultSelectionID;
	int     m_iResultPaneCount;
    CExtensionList m_WebSvcExtensionList;
    DWORD m_dwResultDataCachedSignature;
};

class CWebServiceExtension : public CIISMBNode
{
//
// Constructor/Destructor
//
public:
    CWebServiceExtension(
        CIISMachine * pOwner,
        CRestrictionUIEntry * pRestrictionUIEntry,
        CIISService * pWebService
        );
    
    virtual ~CWebServiceExtension();

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual int QueryImageForPropertyPage() const;
    virtual LPOLESTR QueryDisplayName();
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual HRESULT DeleteNode(IResultData * pResult);
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;

public:
//
// Type Functions
//
    virtual BOOL IsLeafNode() const { return TRUE; }
    virtual BOOL IsConfigurable() const;
    virtual BOOL IsDeletable() const;
    virtual BOOL IsRefreshable() const { return TRUE; }

//
// Interface:
//
public:
    virtual HRESULT GetContextHelp(CString& strHtmlPage);
    virtual HRESULT RefreshData();
    HRESULT RefreshData(BOOL bReselect);
    virtual HRESULT OnDblClick(IComponentData * pcd, IComponent * pc);
    virtual int QuerySortWeight() const { return SW_WEBSVCEXT; }
    virtual void * GetNodeType(){return (void *)&cWebServiceExtension;}
    virtual CreateTag()
    {
        CIISMachine * pMachine = GetOwner();
        if (pMachine)
        {
            CComBSTR bstrPath;
            BuildMetaPath(bstrPath);
            m_strTag = pMachine->QueryDisplayName();
            m_strTag += _T("//");
            m_strTag += QueryDisplayName();
        }
    }
    INT GetState() const;
    HRESULT AddToResultPane(IResultData *pResultData,BOOL bSelect = FALSE,BOOL bPleaseAddRef = TRUE);
    HRESULT AddToResultPaneSorted(IResultData *pResultData,BOOL bSelect = FALSE,BOOL bPleaseAddRef = TRUE);
	HRESULT UpdateResultItem(IResultData *pResultData, BOOL bSelect);

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

public:
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    // for extended view
    virtual HRESULT GetProperty(LPDATAOBJECT pDataObject,BSTR szPropertyName,BSTR* pbstrProperty);
    CWebServiceExtensionContainer * QueryContainer() const {return m_pOwner->QueryWebSvcExtContainer();}
	HRESULT FindMyResultItem(IResultData *pResultData,BOOL bDeleteIfFound);
    
protected:
    HRESULT ChangeState(INT iDesiredState);
    HRESULT ShowPropertiesDlg(
        LPPROPERTYSHEETCALLBACK lpProvider,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath,
        CWnd * pMainWnd,
        LPARAM lParam,
        LPARAM lParamParent,
        LONG_PTR handle
        );
    STDMETHOD(AddMenuItems)(
        LPCONTEXTMENUCALLBACK piCallback,
        long * pInsertionAllowed,
        DATA_OBJECT_TYPES type
        );
    STDMETHOD(GetResultViewType)(LPOLESTR *lplpViewType, long * lpViewOptions);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ICON,
        COL_WEBSVCEXT,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
    static CComBSTR _bstrStatusAllowed;
    static CComBSTR _bstrStatusProhibited;
    static CComBSTR _bstrStatusCustom;
    static CComBSTR _bstrStatusInUse;
    static CComBSTR _bstrStatusNotInUse;
    static CString  _bstrMenuAllowOn;
    static CString  _bstrMenuAllowOff;
    static CString  _bstrMenuProhibitOn;
    static CString  _bstrMenuProhibitOff;
    static CString  _bstrMenuPropertiesOn;
    static CString  _bstrMenuPropertiesOff;
    static CString  _bstrMenuTasks;
    static CString  _bstrMenuTask1;
    static CString  _bstrMenuTask2;
    static CString  _bstrMenuTask3;
    static CString  _bstrMenuTask4;
    static CString  _bstrMenuIconBullet;
    static CString  _bstrMenuIconHelp;
    static BOOL _fStaticsLoaded;
    static BOOL _fStaticsLoaded2;

public:
    CRestrictionUIEntry m_RestrictionUIEntry;
    CIISService * m_pWebService;
};


#if 0 
class CIISFileSystem
/*++

Class Description:

    Pure virtual base class to help enumerate the filesystem.  Sites, 
    virtual directory and file/directory nodes will be "is a" nodes
    of this type, in addition to deriving from CIISMBNode.

Public Interface:

--*/
{
//
// Constructor/Destructor
//
public:
    CIISFileSystem(LPCTSTR szFileName, BOOL fTerminal = FALSE);
protected:
    virtual ~CIISFileSystem();

protected:
    HRESULT BuildFilePath(
        IConsoleNameSpace * pConsoleNameSpace,
        HSCOPEITEM hScopeItem,
        CComBSTR & bstrPath
        ) const;

    BOOL IsFileTerminal() const { return m_fTerminal; }
    
private:
    CComBSTR  m_bstrFileName;
    BOOL      m_fTerminal;
};

#endif 0



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CIISObject::AddImages(LPIMAGELIST lpImageList)
{ 
    return SetImageList(lpImageList); 
}

inline /* virtual */ CMetaInterface * CIISMBNode::QueryInterface()
{
    ASSERT_PTR(m_pOwner != NULL);
    ASSERT(m_pOwner->HasInterface());

    return m_pOwner->QueryInterface();
}

inline /* virtual */ CComAuthInfo * CIISMBNode::QueryAuthInfo()
{
    ASSERT_PTR(m_pOwner != NULL);

    return m_pOwner->QueryAuthInfo();
}

inline /* virtual */ LPOLESTR CIISMBNode::QueryMachineName() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->QueryMachineName();
}

inline WORD CIISMBNode::QueryMajorVersion() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->QueryMajorVersion();
}

inline WORD CIISMBNode::QueryMinorVersion() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->QueryMinorVersion();
}

inline /* virtual */ BOOL CIISMBNode::IsLocal() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->IsLocal();
}

inline /* virtual */ BOOL CIISMBNode::HasInterface() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->HasInterface();
}

inline /* virtual */ HRESULT CIISMBNode::CreateInterface(BOOL fShowError)
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->CreateInterface(fShowError);
}
 
inline /* virtual */ HRESULT CIISMBNode::AssureInterfaceCreated(BOOL fShowError)
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->AssureInterfaceCreated(fShowError);
}

inline /* virtual */ void CIISMBNode::SetInterfaceError(HRESULT hr)
{
    ASSERT_PTR(m_pOwner);
    m_pOwner->SetInterfaceError(hr);
}

inline BOOL CIISMBNode::IsLostInterface(CError & err) const 
{ 
    return err.Win32Error() == RPC_S_SERVER_UNAVAILABLE; 
}

inline HRESULT CIISMachine::AssureInterfaceCreated(BOOL fShowError)
{
    return m_pInterface ? S_OK : CreateInterface(fShowError);
}

inline CIISService::QueryImage() const
{
	CIISService * pTemp = (CIISService *) this;
	pTemp->m_dwServiceStateDisplayed = m_dwServiceState;

	if (SERVICE_RUNNING == m_dwServiceState || 0 == m_dwServiceState)
	{
		return QueryServiceImage();
	}
	else
	{
		return QueryServiceImageStopped();
	}
}

inline CIISService::QueryServiceImage() const
{
    ASSERT(m_iServiceDef >= 0);
	return _rgServices[m_iServiceDef].nServiceImage;
}

inline CIISService::QueryServiceImageStopped() const
{
    ASSERT(m_iServiceDef >= 0);
	return _rgServices[m_iServiceDef].nServiceImageStopped;
}

inline CIISService::QuerySiteImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nSiteImage;
}

inline CIISService::QuerySiteImageStopped() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nSiteImageStopped;
}

inline CIISService::QuerySiteImageErr() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nSiteImageErr;
}

inline CIISService::QueryVDirImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nVDirImage;
}

inline CIISService::QueryVDirImageErr() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nVDirImageErr;
}

inline CIISService::QueryDirImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nDirImage;
}

inline CIISService::QueryFileImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nFileImage;
}

inline BOOL CIISService::IsManagedService() const 
{ 
    return m_fManagedService; 
}

inline HRESULT CIISSite::ShowPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR    handle
    )
{
    ASSERT_PTR(m_pService);
    return m_pService->ShowSitePropertiesDlg(
        lpProvider,
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        lParamParent,
        handle
        );
}

inline HRESULT CIISDirectory::ShowPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR    handle
    )
{
    ASSERT_PTR(m_pService);
    return m_pService->ShowDirPropertiesDlg(
        lpProvider,
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        lParamParent,
        handle
        );
}

inline HRESULT 
CIISFileName::ShowPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    LONG_PTR    handle
    )
{
    ASSERT_PTR(m_pService);
    return m_pService->ShowDirPropertiesDlg(
        lpProvider,
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        lParamParent,
        handle
        );
}

HRESULT CheckForMetabaseAccess(DWORD dwPermissions,
                               CIISMBNode * pIISObject,
                               BOOL bReConnect,
                               LPCTSTR path = METADATA_MASTER_ROOT_HANDLE);
HRESULT CheckForMetabaseAccess(DWORD dwPermissions,
                               CMetaInterface * pMyInterface,
                               LPCTSTR path = METADATA_MASTER_ROOT_HANDLE);
#endif // __IISOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\inetmgrapp.h ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        inetmgrapp.h

   Abstract:
        Main MMC snap-in code definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

--*/
#ifndef __INETMGR_H_
#define __INETMGR_H_

#include "resource.h"
#include "inetmgr.h"
#include "toolbar.h"

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include <debugafx.h>

class CAppFusionInit
{
    HANDLE  m_hActCtx;
    HMODULE m_hModule;
    int m_resourceID;
    
public:
    CAppFusionInit(HMODULE hMod, int id) 
        : m_hActCtx(INVALID_HANDLE_VALUE), 
        m_hModule(hMod), 
        m_resourceID(id)
    {
        InitializeFromModuleID(hMod,id);
    }
    ~CAppFusionInit()
    {
        FusionUninitialize();
    }

private:
    // The following is deliberately not implemented.
    CAppFusionInit(const CAppFusionInit&); 
    // The following is deliberately not implemented.
    void operator=(const CAppFusionInit&);
private:
    void InitializeFromModuleID(HMODULE hMod, int id)
    {
        TCHAR szPath[MAX_PATH];
        if (0 == GetModuleFileName(hMod, szPath, sizeof(szPath)/sizeof(TCHAR)))
            return;
        ACTCTX act = {0};
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpResourceName = MAKEINTRESOURCE(id);
        if (INVALID_HANDLE_VALUE == m_hActCtx)
        {
            act.cbSize = sizeof(act);
            act.lpSource = szPath;
            m_hActCtx = CreateActCtxW(&act);
        }
    }
    void FusionUninitialize()
    {
        if (INVALID_HANDLE_VALUE != m_hActCtx)
        {
            ReleaseActCtx(m_hActCtx);
            m_hActCtx = INVALID_HANDLE_VALUE;
        }
    }
public:
    HANDLE GetThemeContextHandle()
    {
        return m_hActCtx;
    }
};

class CInetmgrApp : public CWinApp
/*++

Class Description:

    Main app object

Public Interface:

    InitInstance        : Instance initiation handler
    ExitInstance        : Exit instance handler

--*/
{
public:
    CInetmgrApp();
    virtual BOOL InitInstance();
    virtual int ExitInstance();

//
// Access
//
public:
    LPCTSTR QueryInetMgrHelpPath() const { return m_strInetMgrHelpPath; }
    HANDLE GetFusionInitHandle()
    {
        if (m_pfusionInit)
            return m_pfusionInit->GetThemeContextHandle();
        return NULL;
    }

protected:
    //{{AFX_MSG(CSnapinApp)
    afx_msg void OnHelp();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    LPCTSTR m_lpOriginalHelpPath;
    LPCTSTR m_lpOriginalAppName;
    CString m_strInetMgrHelpPath;
    CString m_strInetMgrAppName;
    CAppFusionInit * m_pfusionInit;
};

class CThemeContextActivator 
{
public:
    CThemeContextActivator(HANDLE hActCtx) 
        : m_ulActivationCookie(0)
    { 
        ActivateActCtx(hActCtx, &m_ulActivationCookie); 
    }

    ~CThemeContextActivator()
    { 
        if (m_ulActivationCookie != 0)
        {
            DeactivateActCtx(0, m_ulActivationCookie);
        }
    }
private:
    ULONG_PTR m_ulActivationCookie;
};

class CInetMgr;

class CInetMgrComponent 
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CSnapInObjectRoot<2, CInetMgr>,
      public IPersistStorage,
      public INodeProperties,
	  public ISnapinHelp2,
      public IExtendContextMenuImpl<CInetMgrComponent>,
      public IExtendPropertySheetImpl<CInetMgrComponent>,
      public IExtendControlbar,
      public IResultDataCompareEx,
      public IComponentImpl<CInetMgrComponent>
/*++

Class Description:

    IComponentImpl implementation

Public Interface:

    See IComponent, IPersistStorage, etc for documentation

--*/
{
//
// Constructor/Destructor
//
public:
    CInetMgrComponent();
	~CInetMgrComponent();

//
// Interface:
//
public:
    BEGIN_COM_MAP(CInetMgrComponent)
        COM_INTERFACE_ENTRY(IComponent)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(INodeProperties)
        COM_INTERFACE_ENTRY(ISnapinHelp2)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IExtendControlbar)
        COM_INTERFACE_ENTRY(IResultDataCompareEx)
    END_COM_MAP()

    //
    // IComponent methods
    //
    STDMETHOD(Notify)(
        LPDATAOBJECT lpDataObject, 
        MMC_NOTIFY_TYPE event, 
        LPARAM arg, 
        LPARAM param
        );

    STDMETHOD(CompareObjects)(
        IN LPDATAOBJECT lpDataObjectA,
        IN LPDATAOBJECT lpDataObjectB
        );

	STDMETHOD(Destroy)(LONG cookie);

    //
    // IPersistStorage methods
    //
    STDMETHOD(GetClassID)(CLSID * pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(InitNew)(IStorage * pStg);
    STDMETHOD(Load)(IStorage * pStg);
    virtual HRESULT STDMETHODCALLTYPE Save(IStorage * pStgSave, BOOL fSameAsLoad);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IStorage * pStgNew);
    virtual HRESULT STDMETHODCALLTYPE HandsOffStorage();

    // INodeProperties function
    virtual HRESULT STDMETHODCALLTYPE GetProperty(LPDATAOBJECT pDataObject,BSTR szPropertyName,BSTR* pbstrProperty);

    // ISnapinHelp helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR *pszHelpFile);
    //
    // IExtendControlbar methods
    //
    STDMETHOD(SetControlbar)(LPCONTROLBAR lpControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IResultDataCompareEx methods
    //
    STDMETHOD(Compare)(RDCOMPARE * prdc, int * pnResult);

public:
   CComPtr<IControlbar> _lpControlBar;
   CComPtr<IToolbar> _lpToolBar;
};

#if 0
class CIISMachine;

class CCompMgrExtData : public CSnapInItemImpl<CCompMgrExtData, TRUE>
{
public:
	static const GUID * m_NODETYPE;
	static const OLECHAR * m_SZNODETYPE;
	static const OLECHAR * m_SZDISPLAY_NAME;
	static const CLSID * m_SNAPIN_CLASSID;

	CCompMgrExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CCompMgrExtData()
	{
	}

//    STDMETHOD(CreatePropertyPages)(
//        LPPROPERTYSHEETCALLBACK lpProvider,
//		LONG_PTR handle, 
//		IUnknown* pUnk,
//		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

    HRESULT EnumerateScopePane(HSCOPEITEM hParent, IConsoleNameSpace2 * pScope);

	IDataObject * m_pDataObject;
	virtual void 
    InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
        VERIFY(SUCCEEDED(Init(pDataObject)));
	}

	CSnapInItem * 
    GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

protected:
    HRESULT Init(IDataObject * pDataObject);

    CString m_ExtMachineName;
//	CIISMachine * m_pMachine;
	HSCOPEITEM m_hScopeItem;
};
#endif

class CIISRoot;

class CInetMgr 
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CSnapInObjectRoot<1, CInetMgr>,
      public IComponentDataImpl<CInetMgr, CInetMgrComponent>,
      public IPersistStorage,
      public INodeProperties,
	  public ISnapinHelp2,
      public IExtendContextMenuImpl<CInetMgr>,
      public IExtendPropertySheetImpl<CInetMgr>,
      public CComCoClass<CInetMgr, &CLSID_InetMgr>
/*++

Class Description:

    IComponentDataImpl implementation

Public Interface:

    See IComponentData, IPersistStorage, IExtendContextMenu etc, for documentation

--*/
{
//
// Constructor/Destructor
//
public:
    CInetMgr();
    ~CInetMgr();

//EXTENSION_SNAPIN_DATACLASS(CCompMgrExtData)
//BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CInetMgr)
//	EXTENSION_SNAPIN_NODEINFO_ENTRY(CCompMgrExtData)
//END_EXTENSION_SNAPIN_NODEINFO_MAP()

//
// Interface
//
public:
    BEGIN_COM_MAP(CInetMgr)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(INodeProperties)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
		COM_INTERFACE_ENTRY(ISnapinHelp2)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_INETMGR)

    DECLARE_NOT_AGGREGATABLE(CInetMgr)

    //
    // IPersistStorage methods
    //
    STDMETHOD(GetClassID)(CLSID * pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(InitNew)(IStorage * pStg);
    STDMETHOD(Load)(IStorage * pStg);
    virtual HRESULT STDMETHODCALLTYPE Save(IStorage * pStgSave, BOOL fSameAsLoad);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IStorage * pStgNew);
    virtual HRESULT STDMETHODCALLTYPE HandsOffStorage();

    // INodeProperties function
    virtual HRESULT STDMETHODCALLTYPE GetProperty(LPDATAOBJECT pDataObject,BSTR szPropertyName,BSTR* pbstrProperty);

    // ISnapinHelp helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR *pszHelpFile);

    HRESULT GetDataClass(
         IDataObject * pDataObject, 
         CSnapInItem ** ppItem, 
         DATA_OBJECT_TYPES * pType);

    //
    // IComponentData methods
    //
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CompareObjects)(
        LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB
        );

	STDMETHOD(Notify)(
		LPDATAOBJECT lpDataObject, 
		MMC_NOTIFY_TYPE event, 
		LPARAM arg, 
		LPARAM param
		);

	STDMETHOD(Destroy)();

	HRESULT OnPropertyChange(LPARAM arg, LPARAM param);

public:
    static void WINAPI ObjectMain(bool bStarting);

protected:
    BOOL IsExtension();
    IConsoleNameSpace * m_pConsoleNameSpace;
    IConsole * m_pConsole;

protected:
    static DWORD   _dwSignature;
    static LPCTSTR _szStream;
};



class ATL_NO_VTABLE CInetMgrAbout  
    : public ISnapinAbout,
      public CComObjectRoot,
      public CComCoClass<CInetMgrAbout, &CLSID_InetMgrAbout>
/*++

Class Description:

    About interface implementation.  Called by MMC to display information
    about the snap-in.

Public Interface:

    See ISnapinAbout for documentation

--*/
{
//
// Interface
//
public:
    CInetMgrAbout()
    {
        m_hSmallImage = m_hLargeImage = NULL;
        m_hSnapinIcon = NULL;
    }

    ~CInetMgrAbout();

    DECLARE_REGISTRY(CInetMgrAbout, _T("InetMgr5xAbout.1"), _T("InetMgr5xAbout.1"), IDS_INETMGR_DESC, THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CInetMgrAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR * lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion);
    STDMETHOD(GetSnapinImage)(HICON * hAppIcon);
    STDMETHOD(GetStaticFolderImage)(
        OUT HBITMAP *  phSmallImage,
        OUT HBITMAP *  phSmallImageOpen,
        OUT HBITMAP *  phLargeImage,
        OUT COLORREF * prgbMask
        );

//
// Helpers
//
protected:
    HRESULT GetStringHelper(UINT nStringID, LPOLESTR * lpString);

    HBITMAP m_hSmallImage, m_hLargeImage;
    HICON m_hSnapinIcon;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CInetMgrAbout::GetSnapinDescription(
    OUT LPOLESTR * lpDescription
    )
{
    return GetStringHelper(IDS_INETMGR_DESC, lpDescription);
}

inline HRESULT CInetMgrAbout::GetProvider(
    OUT LPOLESTR * lpName
    )
{
    return GetStringHelper(IDS_INETMGR_PROVIDER, lpName);
}

#endif // __INETMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\inetmgrapp.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        inetmgrapp.cpp

   Abstract:
        Snapin object

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "inetmgr.h"
#include "dlldatax.h"
#include "common.h"
#include "guids.h"
#include <winsock2.h>

#include "inetmgr_i.c"
#include "inetmgrapp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#ifdef _DEBUG
//
// Allocation tracker
//
BOOL
TrackAllocHook(
    IN size_t nSize,
    IN BOOL   bObject,
    IN LONG   lRequestNumber
    )
{
    //
    // Set breakpoint on specific allocation number
    // to track memory leak.
    //
    //TRACEEOLID("allocation # " << lRequestNumber);

    return TRUE;
}
#endif // _DEBUG

// From stdafx.cpp
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

const LPCTSTR g_cszCLSID           = _T("CLSID");
const LPCTSTR g_cszLS32            = _T("LocalServer32");
const LPCTSTR g_cszIPS32           = _T("InprocServer32");
const LPCTSTR g_cszMMCBasePath     = _T("Software\\Microsoft\\MMC");
const LPCTSTR g_cszSnapins         = _T("Snapins");
const LPCTSTR g_cszNameString      = _T("NameString");
const LPCTSTR g_cszNameStringInd   = _T("NameStringIndirect");
const LPCTSTR g_cszProvider        = _T("Provider");
const LPCTSTR g_cszVersion         = _T("Version");
const LPCTSTR g_cszStandAlone      = _T("StandAlone");
const LPCTSTR g_cszNodeTypes       = _T("NodeTypes");
const LPCTSTR g_cszAbout           = _T("About");
const LPCTSTR g_cszExtensions      = _T("Extensions");
const LPCTSTR g_cszExtensionsView  = _T("Extensions\\View");
const LPCTSTR g_cszNameSpace       = _T("NameSpace");
const LPCTSTR g_cszDynamicExt      = _T("Dynamic Extensions");
const LPCTSTR g_cszValProvider     = _T("Microsoft");
const LPCTSTR g_cszValVersion      = _T("6.0");
const LPCTSTR g_cszMyCompMsc       = _T("%SystemRoot%\\system32\\compmgmt.msc");
const LPCTSTR g_cszServerAppsLoc   = _T("System\\CurrentControlSet\\Control\\Server Applications");
const LPCTSTR g_cszInetMGRBasePath = _T("Software\\Microsoft\\InetMGR");
const LPCTSTR g_cszInetSTPBasePath = _T("Software\\Microsoft\\InetStp");
const LPCTSTR g_cszMinorVersion	   = _T("MinorVersion");
const LPCTSTR g_cszMajorVersion	   = _T("MajorVersion");
const LPCTSTR g_cszParameters      = _T("Parameters");
const LPCTSTR g_cszHelpPath        = _T("HelpLocation");

//const GUID cInternetRootNode = {0xa841b6c3, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cMachineNode = {0xa841b6c4, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cServiceCollectorNode = {0xa841b6c5, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cInstanceCollectorNode = {0xa841b6c6, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cInstanceNode = {0xa841b6c7, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cChildNode = {0xa841b6c8, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cFileNode = {0xa841b6c9, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

#define lstruuidNodetypeServerApps  L"{476e6449-aaff-11d0-b944-00c04fd8d5b0}"

// needed for setting extension views for certain objects
const LPCTSTR g_cszViewGUID = _T("{B708457E-DB61-4C55-A92F-0D4B5E9B1224}");
const LPCTSTR g_cszViewDescript = _T("MMCViewExt 1.0 Object");



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_InetMgr, CInetMgr)
    OBJECT_ENTRY(CLSID_InetMgrAbout, CInetMgrAbout)
END_OBJECT_MAP()

//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetmgrApp, CWinApp)
    //{{AFX_MSG_MAP(CInetmgrApp)
    //}}AFX_MSG_MAP
    //
    // Global help commands
    //
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()


CInetmgrApp theApp;

CInetmgrApp::CInetmgrApp()
    : CWinApp(),
    m_pfusionInit(NULL)
{

#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
    AfxSetAllocHook(TrackAllocHook);
#endif // _DEBUG    
}

BOOL 
CInetmgrApp::InitInstance()
{
#ifdef _MERGE_PROXYSTUB
    hProxyDll = m_hInstance;
#endif

    ::AfxEnableControlContainer();

    //InitErrorFunctionality();

    _Module.Init(ObjectMap, m_hInstance);

    //
    // Save a pointer to the old help file and app name.
    //
    m_lpOriginalHelpPath = m_pszHelpFilePath;
    m_lpOriginalAppName  = m_pszAppName;
    

    //
    // Build up inetmgr help path, expanding
    // the help path if necessary.
    //
    CString strKey;
    strKey.Format(_T("%s\\%s"), g_cszInetMGRBasePath, g_cszParameters);
    CRegKey rk;
    rk.Create(HKEY_LOCAL_MACHINE, strKey);
    DWORD len = MAX_PATH;
    rk.QueryValue(m_strInetMgrHelpPath.GetBuffer(len), g_cszHelpPath, &len);
    m_strInetMgrHelpPath.ReleaseBuffer(-1);
    m_strInetMgrHelpPath += _T("\\inetmgr.hlp");
    TRACEEOLID("Initialized help file " << m_strInetMgrHelpPath);

    m_pszHelpFilePath = m_strInetMgrHelpPath;
#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
#endif // _DEBUG

    InitCommonDll();
    WSADATA wsaData;
    BOOL WinSockInit = (::WSAStartup(MAKEWORD(1, 1), &wsaData) == 0);

    VERIFY(m_strInetMgrAppName.LoadString(IDS_APP_NAME));
    m_pszAppName = m_strInetMgrAppName;

    m_pfusionInit = new CAppFusionInit(m_hInstance, 2 /*SXS_MANIFEST_RESOURCE_ID*/);

    return CWinApp::InitInstance();
}

int 
CInetmgrApp::ExitInstance()
{
    _Module.Term();
    //
    // Restore original help file path and app name, so
    // MFC can safely delete them.
    //
    ASSERT_PTR(m_lpOriginalHelpPath);
    m_pszHelpFilePath = m_lpOriginalHelpPath;
    ASSERT_PTR(m_lpOriginalAppName);
    m_pszAppName = m_lpOriginalAppName;

    if (m_pfusionInit)
        delete m_pfusionInit;

    return CWinApp::ExitInstance();
}



STDAPI 
DllCanUnloadNow()
/*++

Routine Description:

    Used to determine whether the DLL can be unloaded by OLE

Arguments:

    None

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB

    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }

#endif

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}



STDAPI 
DllGetClassObject(
    IN REFCLSID rclsid, 
    IN REFIID riid, 
    IN LPVOID * ppv
    ) 
/*++

Routine Description:

    Returns a class factory to create an object of the requested type

Arguments:

    REFCLSID rclsid
    REFIID riid
    LPVOID * ppv

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}



STDAPI 
DllRegisterServer()
/*++

Routine Description:

    DllRegisterServer - Adds entries to the system registry

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB

   HRESULT hRes = PrxDllRegisterServer();
   if (FAILED(hRes))
   {
      return hRes;
   }

#endif

   CError err(_Module.RegisterServer(TRUE));
   if (err.Succeeded())
   {
      CString str, strKey, strExtKey;

      try
      {
         AFX_MANAGE_STATE(::AfxGetStaticModuleState());

         //
         // Create the primary snapin nodes
         //
         CString strNameString((LPCTSTR)IDS_ROOT_NODE);
         CString strNameStringInd;
         TCHAR path[MAX_PATH];
         GetModuleFileName(_Module.GetResourceInstance(), path, MAX_PATH - 1);
         strNameStringInd.Format(_T("@%s,-%d"), path, IDS_ROOT_NODE);
         TRACEEOLID("MUI-lized snapin name: " << strNameStringInd);

         CString strProvider(g_cszValProvider);
         CString strVersion(g_cszValVersion);
    
         strKey.Format(_T("%s\\%s\\%s"), 
            g_cszMMCBasePath, 
            g_cszSnapins,
            GUIDToCString(CLSID_InetMgr, str)
            );
         TRACEEOLID(strKey);

         CString strAbout;
         GUIDToCString(CLSID_InetMgrAbout, strAbout);

         CRegKey rkSnapins, rkStandAlone, rkNodeTypes;
         
         rkSnapins.Create(HKEY_LOCAL_MACHINE, strKey);
         if (NULL != (HKEY)rkSnapins)
         {
            rkSnapins.SetValue(strAbout, g_cszAbout);
            rkSnapins.SetValue(strNameString, g_cszNameString);
            rkSnapins.SetValue(strNameStringInd, g_cszNameStringInd);
            rkSnapins.SetValue(strProvider, g_cszProvider);
            rkSnapins.SetValue(strVersion, g_cszVersion);
         }
         rkStandAlone.Create(rkSnapins, g_cszStandAlone);
         rkNodeTypes.Create(rkSnapins, g_cszNodeTypes);

         //
         // Create the nodetype GUIDS
         //
         CRegKey rkN1;

         rkN1.Create(rkNodeTypes, GUIDToCString(cInternetRootNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cMachineNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cInstanceNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cChildNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cFileNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cServiceCollectorNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cAppPoolsNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cAppPoolNode, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cWebServiceExtensionContainer, str));
         rkN1.Create(rkNodeTypes, GUIDToCString(cWebServiceExtension, str));
         {
             //
             // Register certain objects to use the 
             // Extension view
             //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                GUIDToCString(cWebServiceExtensionContainer, str),
                g_cszExtensionsView
                );

            TRACEEOLID(strExtKey);

            CRegKey rkMMCNodeTypes0;
            rkMMCNodeTypes0.Create(HKEY_LOCAL_MACHINE, strExtKey);
            if (NULL != (HKEY)rkMMCNodeTypes0)
            {
               rkMMCNodeTypes0.SetValue(            
                  g_cszViewDescript,
                  g_cszViewGUID
                  );
            }
         }
         
         {
            //
            // Register as a dynamic extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

            TRACEEOLID(strExtKey);

            CRegKey rkMMCNodeTypes;
            rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
            if (NULL != (HKEY)rkMMCNodeTypes)
            {
               rkMMCNodeTypes.SetValue(            
                  strNameString,
                  GUIDToCString(CLSID_InetMgr, str)
                  );
            }
         }
         {
            //
            // Register as a namespace extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

            TRACEEOLID(strExtKey);

            CRegKey rkMMCNodeTypes;
            rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
            if (NULL != (HKEY)rkMMCNodeTypes)
            {
               rkMMCNodeTypes.SetValue(            
                  strNameString,
                  GUIDToCString(CLSID_InetMgr, str)
                  );
            }
         }

         //
         // This key indicates that the service in question is available
         // on the local machine
         //
         CRegKey rkCompMgmt;

         rkCompMgmt.Create(HKEY_LOCAL_MACHINE, g_cszServerAppsLoc);
         if (NULL != (HKEY)rkCompMgmt)
         {
            rkCompMgmt.SetValue(strNameString, GUIDToCString(CLSID_InetMgr, str));
         }
      }
      catch(CMemoryException * e)
      {
         e->Delete();
         err = ERROR_NOT_ENOUGH_MEMORY;
      }
      catch(COleException * e)
      {
         e->Delete();
         err = SELFREG_E_CLASS;
      }
   }
   return err;
}



STDAPI 
DllUnregisterServer()
/*++

Routine Description:

    DllUnregisterServer - Removes entries from the system registry

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB

   PrxDllUnregisterServer();

#endif
   CError err;

   try
   {
      CString strKey(g_cszMMCBasePath);
      strKey += _T("\\");
      strKey += g_cszSnapins;

      TRACEEOLID(strKey);

      CString str, strExtKey;
      CRegKey rkBase;
      rkBase.Create(HKEY_LOCAL_MACHINE, strKey);
      ASSERT(NULL != (HKEY)rkBase);
      if (NULL != (HKEY)rkBase)
      {
         CRegKey rkCLSID;
         rkCLSID.Create(rkBase, GUIDToCString(CLSID_InetMgr, str));
         ASSERT(NULL != (HKEY)rkCLSID);
         if (NULL != (HKEY)rkCLSID)
         {
            ::RegDeleteKey(rkCLSID, g_cszStandAlone);
            {
               CRegKey rkNodeTypes;
               rkNodeTypes.Create(rkCLSID, g_cszNodeTypes);
               ASSERT(NULL != (HKEY)rkNodeTypes);
               if (NULL != (HKEY)rkNodeTypes)
               {
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cInternetRootNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cMachineNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cInstanceNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cChildNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cFileNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cServiceCollectorNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cAppPoolsNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cAppPoolNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cWebServiceExtensionContainer, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cWebServiceExtension, str));
               }
            }
            ::RegDeleteKey(rkCLSID, g_cszNodeTypes);
         }
         ::RegDeleteKey(rkBase, GUIDToCString(CLSID_InetMgr, str));
      }

      {
         //
         // Delete a dynamic extension to computer management
         //
         strExtKey.Format(
                _T("%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

         CRegKey rkMMCNodeTypes;
         rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
		 if (NULL != (HKEY)rkMMCNodeTypes)
		 {
			::RegDeleteValue(rkMMCNodeTypes, GUIDToCString(CLSID_InetMgr, str));
		 }
      }

      {
         //
         // Delete the namespace extension to computer management
         //
         strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

         CRegKey rkMMCNodeTypes;
         rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
		 if (NULL != (HKEY)rkMMCNodeTypes)
		 {
			::RegDeleteValue(rkMMCNodeTypes, GUIDToCString(CLSID_InetMgr, str));
		 }
      }

      {
             //
             // Delete Extension view for certain objects
             // 
             //
            strExtKey.Format(_T("%s\\%s"),g_cszMMCBasePath,g_cszNodeTypes);
            CRegKey rkMMCNodeTypes0;
            rkMMCNodeTypes0.Create(HKEY_LOCAL_MACHINE, strExtKey);
            if (NULL != (HKEY)rkMMCNodeTypes0)
            {
                CRegKey rkMMCNodeTypes1;
                rkMMCNodeTypes1.Create(rkMMCNodeTypes0, GUIDToCString(cWebServiceExtensionContainer, str));
                if (NULL != (HKEY)rkMMCNodeTypes1)
                {
                    CRegKey rkMMCNodeTypes2;
                    rkMMCNodeTypes2.Create(rkMMCNodeTypes1, g_cszExtensionsView);
                    if (NULL != (HKEY)rkMMCNodeTypes2)
                    {
                        ::RegDeleteValue(rkMMCNodeTypes2,g_cszViewGUID);
                    }
                    ::RegDeleteKey(rkMMCNodeTypes1, g_cszExtensionsView);
                    ::RegDeleteKey(rkMMCNodeTypes1, g_cszExtensions);
                }
                ::RegDeleteKey(rkMMCNodeTypes0, GUIDToCString(cWebServiceExtensionContainer, str));
            }
      }

      //
      // And the service itself no longer available on the local 
      // computer
      //
      CRegKey rkCompMgmt;
      rkCompMgmt.Create(HKEY_LOCAL_MACHINE, g_cszServerAppsLoc);
	  if (NULL != (HKEY)rkCompMgmt)
	  {
		  ::RegDeleteValue(rkCompMgmt, GUIDToCString(CLSID_InetMgr, str));
	  }
   }
   catch(CException * e)
   {
      err.GetLastWinError();
      e->Delete();
   }

   if (err.Failed())
   {
      return err.Failed();
   }
   return _Module.UnregisterServer();
}

HRESULT CInetMgrAbout::GetSnapinVersion(LPOLESTR * lpVersion)
{
    CRegKey rk;
    rk.Create(HKEY_LOCAL_MACHINE, g_cszInetSTPBasePath);
	DWORD minor, major;
    if (	ERROR_SUCCESS == rk.QueryValue(minor, g_cszMinorVersion)
		&&	ERROR_SUCCESS == rk.QueryValue(major, g_cszMajorVersion)
		)
	{
		CString buf;
		buf.Format(_T("%d.%d"), major, minor);
		*lpVersion = (LPOLESTR)::CoTaskMemAlloc((buf.GetLength() + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
		{
			return E_OUTOFMEMORY;
		}

		::ocscpy(*lpVersion, T2OLE((LPTSTR)(LPCTSTR)buf));

		return S_OK;
	}

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\ipdomdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipdomdlg.h

   Abstract:

        IP and domain security restrictions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IPDOMDLG_H_
#define _IPDOMDLG_H_

class CIPDomainDlg : public CEmphasizedDialog
/*++

Class Description:

    IP address and domain name restrictions dialog

Public Interface:

    CIPDomainDlg        : Constructor
    GetAccessList       : Get the list of granted/denied objects

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CIPDomainDlg(
        IN OUT BOOL & fIpDirty,
        IN OUT BOOL & fDefaultGranted,
        IN OUT BOOL & fOldDefaultGranted,
        IN CObListPlus & oblAccessList,
        IN CWnd * pParent = NULL
        );

//
// Access
//
public:
    CObListPlus & GetAccessList();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIPDomainDlg)
    enum { IDD = IDD_IP_SECURITY };
    int     m_nGrantedDenied;
    CStatic m_icon_Granted;
    CStatic m_icon_Denied;
    CButton m_radio_Granted;
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    CButton m_radio_Denied;
    CIPAccessDescriptorListBox m_list_IpAddresses;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIPDomainDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CIPDomainDlg)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListIpAddresses();
    afx_msg void OnErrspaceListIpAddresses();
    afx_msg void OnRadioGranted();
    afx_msg void OnRadioDenied();
    afx_msg void OnSelchangeListIpAddresses();
    afx_msg int  OnVKeyToItem(UINT nKey, CListBox * pListBox, UINT nIndex);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    void    FillListBox(CIPAccessDescriptor * pSelection = NULL);
    BOOL    SetControlStates();
    DWORD   SortAccessList();

private:
    BOOL & m_fDefaultGranted;
    BOOL & m_fOldDefaultGranted;
    BOOL & m_fIpDirty;
    CObListPlus m_oblAccessListGranted, m_oblAccessListDenied;
	CObListPlus m_oblReturnList;
	CObListPlus * m_pCurrentList;
    CRMCListBoxResources m_ListBoxRes;
};

#endif // _IPDOMDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\inetmgrcomp.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        inetmgr.cpp

   Abstract:

        Main MMC snap-in code

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "toolbar.h"
#include "util.h"
#include "tracker.h"
#include "guids.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


//const GUID * CCompMgrExtData::m_NODETYPE = &cCompMgmtService;
//const OLECHAR * CCompMgrExtData::m_SZNODETYPE = OLESTR("476e6446-aaff-11d0-b944-00c04fd8d5b0");
//const OLECHAR * CCompMgrExtData::m_SZDISPLAY_NAME = OLESTR("CMSnapin");
//const CLSID * CCompMgrExtData::m_SNAPIN_CLASSID = &CLSID_InetMgr;

extern CInetmgrApp theApp;
extern CPropertySheetTracker g_OpenPropertySheetTracker;
extern CWNetConnectionTrackerGlobal g_GlobalConnections;
#if defined(_DEBUG) || DBG
	extern CDebug_IISObject g_Debug_IISObject;
#endif

int g_IISMMCComLoaded = 0;
int g_IISMMCInstanceCount = 0;
int g_IISMMCInstanceCountExtensionMode = 0;

HRESULT
GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
	if (lpCompiledHelpFile == NULL)
		return E_INVALIDARG;
	CString strFilePath, strWindowsPath, strBuffer;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// Use system API to get windows directory.
	UINT uiResult = GetWindowsDirectory(strWindowsPath.GetBuffer(MAX_PATH), MAX_PATH);
	strWindowsPath.ReleaseBuffer();
	if (uiResult <= 0 || uiResult > MAX_PATH)
	{
		return E_FAIL;
	}

	if (!strFilePath.LoadString(IDS_HELPFILE))
	{
		return E_FAIL;
	}
   
	strBuffer = strWindowsPath;
	strBuffer += _T('\\');
	strBuffer += strFilePath;

	*lpCompiledHelpFile 
			= reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((strBuffer.GetLength() + 1) 
					* sizeof(_TCHAR)));
	if (*lpCompiledHelpFile == NULL)
		return E_OUTOFMEMORY;
	USES_CONVERSION;
	_tcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)strBuffer));
	return S_OK;
}

//
// CInetMgrComponent Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CInetMgrComponent::CInetMgrComponent() 
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
{
   _lpControlBar = NULL;
   _lpToolBar = NULL;
   g_IISMMCInstanceCount++;    
   TRACEEOLID("CInetMgrComponent::CInetMgrComponent:g_IISMMCInstanceCount=" << g_IISMMCInstanceCount);
}

CInetMgrComponent::~CInetMgrComponent() 
{
	TRACEEOLID("CInetMgrComponent::~CInetMgrComponent:g_IISMMCInstanceCount=" << g_IISMMCInstanceCount);
}

HRESULT
CInetMgrComponent::Destroy(LONG cookie) 
{
	g_IISMMCInstanceCount--;
	TRACEEOLID("CInetMgrComponent::Destroy:g_IISMMCInstanceCount=" << g_IISMMCInstanceCount);
	return S_OK;
}

HRESULT
CInetMgrComponent::Notify(
    IN LPDATAOBJECT lpDataObject, 
    IN MMC_NOTIFY_TYPE event, 
    IN LPARAM arg, 
    IN LPARAM param
    )
/*++

Routine Description:

    Notification handler.

Arguments:

    LPDATAOBJECT lpDataObject       : Data object
    MMC_NOTIFY_TYPE event           : Notification event
    long arg                        : Event specific argument
    long param                      : Event specific parameter

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_NOTIMPL;

    if (lpDataObject == NULL)
    {
        switch (event)
        {
        case MMCN_PROPERTY_CHANGE:
            {
                TRACEEOLID("CInetMgrComponent::Notify:MMCN_PROPERTY_CHANGE");
			    hr = S_OK;
			    if (m_spConsole != NULL)
			    {
				    CSnapInItem * pNode = (CSnapInItem *)param;
				    LPDATAOBJECT pDataObject = NULL;
					if (pNode)
					{
                        if (IsValidAddress( (const void*) pNode,sizeof(void*),FALSE))
                        {
                            pNode->GetDataObject(&pDataObject, CCT_SCOPE);
                        }
					}
				    hr = m_spConsole->UpdateAllViews(pDataObject, param, 0);
			    }
            }
            break;
        case MMCN_SNAPINHELP:
            break;
        default:
            break;
        }
    }
    else if (lpDataObject != DOBJ_CUSTOMWEB && lpDataObject != DOBJ_CUSTOMOCX)
    {
        //
        // Pass it on to IComponentImpl
        //
        hr = IComponentImpl<CInetMgrComponent>::Notify(lpDataObject, event, arg, param);
    }
	else
	{
		hr = S_OK;
	}
    return hr;
}

HRESULT 
CInetMgrComponent::GetProperty(
    LPDATAOBJECT pDataObject,
    BSTR szPropertyName,
    BSTR* pbstrProperty)
{
    HRESULT hr = S_OK;
    CSnapInItem * pItem = NULL;
    DATA_OBJECT_TYPES type;

	IDataObject * p = (IDataObject *)pDataObject;
	if (p == DOBJ_CUSTOMWEB || p == DOBJ_CUSTOMOCX)
	{
		return S_OK;
	}
    hr = m_pComponentData->GetDataClass((IDataObject *)pDataObject, &pItem, &type);

    // Find out CIISObject this belongs to and pass on the message
    CIISObject * pObject = (CIISObject *)pItem;
    if (SUCCEEDED(hr) && pObject != NULL)
    {
        hr = pObject->GetProperty(pDataObject,szPropertyName,pbstrProperty);
    }

    return hr;
}


HRESULT
CInetMgrComponent::GetClassID(
    OUT CLSID * pClassID
    )
/*++

Routine Description:

    Get class ID for storage stream.

Arguments:

    CLSID * pClassID            : Returns class ID information

Return Value:

    HRESULT

--*/
{
    *pClassID = CLSID_InetMgr;

    return S_OK;
}   


STDMETHODIMP 
CInetMgrComponent::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
	return ::GetHelpTopic(lpCompiledHelpFile);
}

STDMETHODIMP 
CInetMgrComponent::GetLinkedTopics(LPOLESTR *lpCompiledHelpFile)
{
	return S_FALSE;
}


HRESULT
CInetMgrComponent::IsDirty()
/*++

Routine Description:

    Check to see if we need to write to the cache.

Arguments:

    None

Return Value:

    S_OK if dirty, S_FALSE if not

--*/
{
    TRACEEOLID("CInetMgrComponent::IsDirty");

    return S_FALSE;
}



HRESULT
CInetMgrComponent::InitNew(
    IN OUT IStorage * pStg
    )
/*++

Routine Description:

    Initialize storage stream.

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::InitNew");

    return S_OK;
}



HRESULT
CInetMgrComponent::Load(
    IN OUT IStorage * pStg
    )
/*++

Routine Description:

    Load from the storage stream

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::Load");

    return S_OK;
}



/* virtual */
HRESULT 
STDMETHODCALLTYPE 
CInetMgrComponent::Save(
    IN OUT IStorage * pStgSave,
    IN BOOL fSameAsLoad
    )
/*++

Routine Description:

    Save to to the storage stream.

Arguments:

    IStorage * pStgSave     : Storage stream
    BOOL fSameAsLoad        : TRUE if same as load

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::Save");

    return S_OK;
}

    

/* virtual */ 
HRESULT 
STDMETHODCALLTYPE 
CInetMgrComponent::SaveCompleted(IStorage * pStgNew)
/*++

Routine Description:

    Save completed.

Arguments:

    IStorage * pStgNew      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::SaveCompleted");

    return S_OK;
}



/* virtual */
HRESULT 
STDMETHODCALLTYPE 
CInetMgrComponent::HandsOffStorage()
/*++

Routine Description:

    Hands off storage.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::HandsOffStorage");

    return S_OK;

}


/* virtual */ 
HRESULT 
CInetMgrComponent::SetControlbar(
    IN LPCONTROLBAR lpControlBar
    )
/*++

Routine Description:

    Set/Reset the control bar

Arguments:

    LPCONTROLBAR lpControlBar       : Control bar pointer or NULL

Return Value:

    HRESULT

--*/
{
	HRESULT hr = S_OK;

    if (lpControlBar)
    {
		if (_lpControlBar){_lpControlBar.Release();_lpControlBar=NULL;}
		_lpControlBar = lpControlBar;

		// BUG:680625
	    if (_lpToolBar){_lpToolBar.Release();_lpToolBar=NULL;}

		if (_lpToolBar == NULL)
		{
			hr = ToolBar_Create(lpControlBar,this,(IToolbar **) &_lpToolBar);
		}
	}
	else
	{
        if (_lpControlBar != NULL && _lpToolBar != NULL)
		{
            _lpControlBar->Detach(_lpToolBar);
		}
        //
        // Release existing controlbar
        //
		if (_lpControlBar){_lpControlBar.Release();_lpControlBar=NULL;}
	}
	return hr;
}


/* virtual */
HRESULT
CInetMgrComponent::ControlbarNotify(
    IN MMC_NOTIFY_TYPE event, 
    IN LPARAM arg, 
    IN LPARAM param
    )
/*++

Routine Description:

    Handle control bar notification message.  Figure out the CIISObject
    selected, and pass the notification message off to it.

Arguments:

    MMC_NOTIFY_TYPE event       : Notification message
    long arg                    : Message specific argument
    long param                  : Message specific parameter

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    CSnapInItem * pItem = NULL;
    DATA_OBJECT_TYPES type;
    BOOL fSelect = (BOOL)HIWORD(arg);
    BOOL fScope  = (BOOL)LOWORD(arg); 

    //
    // Special casing this is annoying...
    //
    // CODEWORK: Handle MMCN_HELP and others
    //
    if (event == MMCN_BTN_CLICK)
    {
        hr = m_pComponentData->GetDataClass((IDataObject *)arg, &pItem, &type);
    }
    else if (event == MMCN_SELECT)
    {
		IDataObject * p = (IDataObject *)param;
		if (p == DOBJ_CUSTOMWEB || p == DOBJ_CUSTOMOCX)
		{
			return S_OK;
		}
        hr = m_pComponentData->GetDataClass((IDataObject *)param, &pItem, &type);
    }

    //
    // Find out CIISObject this belongs to and pass on
    // the message
    //
    CIISObject * pObject = (CIISObject *)pItem;
    if (SUCCEEDED(hr) && pObject != NULL)
    {
		if (MMCN_SELECT == event)
		{
			arg = (LPARAM)(LPUNKNOWN *) &_lpControlBar;
			param = (LPARAM)(LPUNKNOWN *) &_lpToolBar;
		    if (_lpControlBar)
		    {
			    if (_lpToolBar)
			    {
				    hr = _lpControlBar->Attach(TOOLBAR, _lpToolBar);
			    }
		    }
		}
        if (fSelect)
        {
            if (SUCCEEDED(hr))
            {
				hr = pObject->ControlbarNotify(event, arg, param);            
			}
        }
    }

    return hr;
}



/* virtual */
HRESULT
CInetMgrComponent::Compare(
    IN  RDCOMPARE * prdc, 
    OUT int * pnResult
    )
/*++

Routine Description:

    Compare method used for sorting the result and scope panes.

Arguments:

    RDCOMPARE * prdc    : Compare structure
    int * pnResult      : Returns result

Return Value:

    HRESULT

--*/
{
    if (!pnResult || !prdc || !prdc->prdch1->cookie || !prdc->prdch2->cookie)
    {
        ASSERT_MSG("Invalid parameter(s)");
        return E_POINTER;
    }

    CIISObject * pObjectA = (CIISObject *)prdc->prdch1->cookie;
    CIISObject * pObjectB = (CIISObject *)prdc->prdch2->cookie;

    *pnResult = pObjectA->CompareResultPaneItem(pObjectB, prdc->nColumn);

    return S_OK;
}



/* virtual */
HRESULT
CInetMgrComponent::CompareObjects(
    IN LPDATAOBJECT lpDataObjectA,
    IN LPDATAOBJECT lpDataObjectB
    )
/*++

Routine Description:

    Compare two data objects.  This method is used to see if a property
    sheet for the given data object is already open

Arguments:

    LPDATAOBJECT lpDataObjectA      : A data object
    LPDATAOBJECT lpDataObjectB      : B data object

Return Value:

    S_OK if they match, S_FALSE otherwise

--*/
{
    //
    // Pass it on to IComponentImpl
    //
    return IComponentImpl<CInetMgrComponent>::CompareObjects(lpDataObjectA, lpDataObjectB);
}



//
// CInetMgr Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */ DWORD   CInetMgr::_dwSignature = 0x3517;
/* static */ LPCTSTR CInetMgr::_szStream = _T("CInetMgr");

HRESULT 
CInetMgr::GetProperty(
    LPDATAOBJECT pDataObject,
    BSTR szPropertyName,
    BSTR* pbstrProperty)
{
    HRESULT hr = S_OK;
    CSnapInItem * pItem = NULL;
    DATA_OBJECT_TYPES type;

	IDataObject * p = (IDataObject *)pDataObject;
	if (p == DOBJ_CUSTOMWEB || p == DOBJ_CUSTOMOCX)
	{
		return S_OK;
	}
    hr = m_pComponentData->GetDataClass((IDataObject *)pDataObject, &pItem, &type);

    // Find out CIISObject this belongs to and pass on the message
    CIISObject * pObject = (CIISObject *)pItem;
    if (SUCCEEDED(hr) && pObject != NULL)
    {
        hr = pObject->GetProperty(pDataObject,szPropertyName,pbstrProperty);
    }

    return hr;
}


/* static */ 
void 
WINAPI 
CInetMgr::ObjectMain(
    IN bool bStarting
    )
/*++

Routine Description:

    CInetMgr main entry point

Arguments:

    bool bStarting      : TRUE if starting

Return Value:

    None

--*/
{
    TRACEEOLID("CInetMgr::ObjectMain:g_IISMMCInstanceCount=" << g_IISMMCInstanceCount);
    if (bStarting)
    {
		g_IISMMCComLoaded++;

        // Check regkey if debugging is okay to be turned on..
        GetOutputDebugFlag();

		// Get Special parameters used by the snapin...
		GetInetmgrParamFlag();
        //
        // Register clipboard formats
        //
        CSnapInItem::Init();
        CIISObject::Init();
        ToolBar_Init();
        g_OpenPropertySheetTracker.Init();

#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Init();
#endif

    }
    else
    {
        g_OpenPropertySheetTracker.Clear();
#if defined(_DEBUG) || DBG	
	g_GlobalConnections.Dump();
#endif
		g_GlobalConnections.Clear();
        ToolBar_Destroy();
		g_IISMMCComLoaded--;
    }
}


CInetMgr::CInetMgr() : m_pConsoleNameSpace(NULL),m_pConsole(NULL)
{
   TRACEEOLID("CInetMgr::CInetMgr");
    //
    // Initialize strings we will be using 
    // for the lifetime of the snapin
    //
    m_pNode = new CIISRoot;
    ASSERT_PTR(m_pNode);
    m_pComponentData = this;

    CIISObject * pNode = dynamic_cast<CIISObject *>(m_pNode);
    if (pNode)
    {
        pNode->AddRef();
    }
}


CInetMgr::~CInetMgr()
{
    TRACEEOLID("CInetMgr::~CInetMgr:g_IISMMCInstanceCount=" << g_IISMMCInstanceCount);
	//
    // Clean up the root node
    //
	CIISObject * pNode = dynamic_cast<CIISObject *>(m_pNode);
    if (pNode)
    {
        pNode->Release();
    }
    m_pNode = NULL;
}

HRESULT
CInetMgr::Destroy() 
{
	TRACEEOLID("CInetMgr::Destroy:g_IISMMCInstanceCount=" << g_IISMMCInstanceCount);

#if defined(_DEBUG) || DBG	
	// check if we leaked anything.
	g_Debug_IISObject.Dump(1);
#endif

	return S_OK;
}

HRESULT 
CInetMgr::Initialize(
    IN LPUNKNOWN lpUnknown
    )
/*++

Routine Description:

    Initialize the snap-in
    
Arguments:

    LPUNKNOWN lpUnknown  : IUnknown

Return Value:

    HRESULT

--*/
{
	TRACEEOLID("CInetMgr::Initialize");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = 
        IComponentDataImpl<CInetMgr, CInetMgrComponent>::Initialize(lpUnknown);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Query the interfaces for console name space and console
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> lpConsoleNameSpace(lpUnknown);
    if (!lpConsoleNameSpace)
    {
        TRACEEOLID("failed to query console name space interface");
        return hr;
    }
    m_pConsoleNameSpace = lpConsoleNameSpace;

    CComQIPtr<IConsole, &IID_IConsole> lpConsole(lpConsoleNameSpace);
    if (!lpConsole)
    {
        TRACEEOLID("failed to query console interface");
        return hr;
    }
    m_pConsole = lpConsole;

    CIISObject * pNode = dynamic_cast<CIISObject *>(m_pNode);
    if (pNode)
    {
        pNode->SetConsoleData(m_pConsoleNameSpace,m_pConsole);
    }

    CComPtr<IImageList> lpImageList;
    hr = m_spConsole->QueryScopeImageList(&lpImageList);
    if (FAILED(hr) || lpImageList == NULL)
    {
        TRACEEOLID("IConsole::QueryScopeImageList failed");
        return E_UNEXPECTED;
    }

    return CIISObject::SetImageList(lpImageList);
}


HRESULT 
CInetMgr::OnPropertyChange(LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    if (param != 0)
    {
        CSnapInItem * pNode = (CSnapInItem *)param;
        LPDATAOBJECT pDataObject = NULL;
        if (IsValidAddress( (const void*) pNode,sizeof(void*),FALSE))
        {
            pNode->GetDataObject(&pDataObject, CCT_SCOPE);
            CIISObject * pObj = dynamic_cast<CIISObject *>(pNode);
            ASSERT(pNode != NULL);
            hr = m_spConsole->UpdateAllViews(pDataObject, param, pObj->m_UpdateFlag);
        }
    }
    return hr;
}

HRESULT
CInetMgr::Notify(
    LPDATAOBJECT lpDataObject, 
    MMC_NOTIFY_TYPE event, 
    LPARAM arg, 
    LPARAM param
    )
{
    HRESULT hr = S_OK;

    if (lpDataObject == NULL)
    {
        switch (event)
        {
        case MMCN_PROPERTY_CHANGE:
            TRACEEOLID("CInetMgr::Notify:MMCN_PROPERTY_CHANGE");
            hr = OnPropertyChange(arg, param);
            break;
        case MMCN_SNAPINHELP:
            break;
        default:
            break;
        }
    }
    else
    {
        hr = IComponentDataImpl<CInetMgr, CInetMgrComponent>::Notify(
            lpDataObject, event, arg, param);
    }
    return hr;
}


HRESULT
CInetMgr::GetClassID(CLSID * pClassID)
/*++

Routine Description:

    Get class ID for storage stream

Arguments:

    CLSID * pClassID            : Returns class ID information

Return Value:

    HRESULT

--*/
{
    *pClassID = CLSID_InetMgr;

    return S_OK;
}   


STDMETHODIMP 
CInetMgr::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
	return ::GetHelpTopic(lpCompiledHelpFile);
}


STDMETHODIMP 
CInetMgr::GetLinkedTopics(LPOLESTR *lpCompiledHelpFile)
{
	return S_FALSE;
}

HRESULT
CInetMgr::IsDirty()
/*++

Routine Description:

    Check to see if we need to write to the cache.

Arguments:

    None

Return Value:

    S_OK if dirty, S_FALSE if not

--*/
{
    TRACEEOLID("CInetMgr::IsDirty");
    ASSERT_PTR(m_pNode);

    if (IsExtension())
    {
        return FALSE;
    }
    else
    {
        return ((CIISRoot *)m_pNode)->m_scServers.IsDirty() ? S_OK : S_FALSE;
    }
}



HRESULT
CInetMgr::InitNew(IStorage * pStg)
/*++

Routine Description:

    Initialize new storage stream (newly created console file)

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgr::InitNew");

    //
    // We could create the stream here, but it's just as easy to
    // create it inside Save().
    //
    return S_OK;
}



HRESULT
CInetMgr::Load(IStorage * pStg)
/*++

Routine Description:

    Load machine cache from the storage stream.

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TRACEEOLID("CInetMgr::Load");

    if (IsExtension())
    {
        return S_OK;
    }

    ASSERT_READ_WRITE_PTR(pStg);

    DWORD   cBytesRead;
    DWORD   dw;
    HRESULT hr = S_OK;
    CIISServerCache & cache = ((CIISRoot *)m_pNode)->m_scServers;
    IStream * pStream = NULL;

    ASSERT(cache.IsEmpty());

    do
    {
        hr = pStg->OpenStream(
            _szStream,
            NULL,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            0L,
            &pStream
            );

        if (FAILED(hr))
        {
            break;
        }

        //
        // Read and verify the signature
        //
        hr = pStream->Read(&dw, sizeof(dw), &cBytesRead);
        ASSERT(SUCCEEDED(hr) && cBytesRead == sizeof(dw));

        if (FAILED(hr))
        {
            break;
        }

        if (dw != _dwSignature)
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT);
            break;
        }

        //
        // Read number of machines in the cache
        //
        DWORD cMachines;

        hr = pStream->Read(&cMachines, sizeof(cMachines), &cBytesRead);
        ASSERT(SUCCEEDED(hr) && cBytesRead == sizeof(cMachines));

        if (FAILED(hr))
        {
            break;
        }

        TRACEEOLID("Reading " << cMachines << " machines from cache");

        CIISMachine * pMachine;

        //
        // Read each machine from the cache
        //
        for (dw = 0; dw < cMachines; ++dw)
        {
            hr = CIISMachine::ReadFromStream(pStream, &pMachine,m_pConsoleNameSpace,m_pConsole);

            if (FAILED(hr))
            {
                break;
            }

			pMachine->AddRef();
            if (!cache.Add(pMachine))
            {
                pMachine->Release();
            }
        }
    }
    while(FALSE);

    if (pStream)
    {
        pStream->Release();
    }

    if (hr == STG_E_FILENOTFOUND)
    {
        //
        // Stream was not initialized.  This is acceptable.
        //
        hr = S_OK;
    }

    //
    // Mark cache as clean
    //
    cache.SetDirty(FALSE);

    return hr;
}



/* virtual */
HRESULT STDMETHODCALLTYPE 
CInetMgr::Save(IStorage * pStgSave, BOOL fSameAsLoad)
/*++

Routine Description:

    Save computer cache to to the storage stream.

Arguments:

    IStorage * pStgSave     : Storage stream
    BOOL fSameAsLoad        : TRUE if same as load

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TRACEEOLID("CInetMgr::Save");

    if (IsExtension())
    {
        return S_OK;
    }

    //
    // Write the computer names to the cache
    //
    ASSERT_READ_WRITE_PTR(pStgSave);

    DWORD   cBytesWritten;
    HRESULT hr = STG_E_CANTSAVE;
    IStream * pStream = NULL;
    CIISServerCache & cache = ((CIISRoot *)m_pNode)->m_scServers;

    do
    {
        hr = pStgSave->CreateStream(
            _szStream,
            STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,
            0L,
            0L,
            &pStream
            );

        if (FAILED(hr))
        {
            break;
        }

        //
        // Write the signature
        //
        hr = pStream->Write(&_dwSignature, sizeof(_dwSignature), &cBytesWritten);
        ASSERT(SUCCEEDED(hr) && cBytesWritten == sizeof(_dwSignature));

        if (FAILED(hr))
        {
            break;
        }

        //
        // Write number of entries.
        //
        INT_PTR dw = cache.GetCount();

        hr = pStream->Write(&dw, sizeof(dw), &cBytesWritten);
        ASSERT(SUCCEEDED(hr) && cBytesWritten == sizeof(dw));

        if (FAILED(hr))
        {
            break;
        }

        //
        // Write each string -- but write them in reverse
        // order to improve our sort performance when we load
        // the cache.
        //
        CIISMachine * pMachine = cache.GetLast();

        while(pMachine)
        {
            hr = pMachine->WriteToStream(pStream);

            if (FAILED(hr))
            {
                break;
            }

            pMachine = cache.GetPrev();
        }
    }
    while(FALSE);

    if (pStream)
    {
        pStream->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Mark cache as clean
        //
        cache.SetDirty(FALSE);
    }

    return hr;
}

    

/* virtual */ 
HRESULT 
STDMETHODCALLTYPE 
CInetMgr::SaveCompleted(IStorage * pStgNew)
/*++

Routine Description:

    Save completed notification.

Arguments:

    IStorage * pStgNew      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgr::SaveCompleted");

    //
    // Nothing to do
    //
    return S_OK;
}



/* virtual */
HRESULT 
STDMETHODCALLTYPE 
CInetMgr::HandsOffStorage()
/*++

Routine Description:

    Hands off storage.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgr::HandsOffStorage");

    //
    // Nothing to do
    //
    return S_OK;
}



/* virtual */
HRESULT
CInetMgr::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
/*++

Routine Description:

    Compare two data objects.  This method is used by MMC to see if a property
    sheet for the given data object is already open.

Arguments:

    LPDATAOBJECT lpDataObjectA      : A data object
    LPDATAOBJECT lpDataObjectB      : B data object

Return Value:

    S_OK if they match, S_FALSE otherwise

--*/
{
    HRESULT hr = E_POINTER;

    do
    {
        if (!lpDataObjectA || !lpDataObjectB)
        {
			TRACEEOLID("CInetMgr:IComponentData::CompareObjects called with NULL ptr");
            break;
        }

        CSnapInItem * pItemA;
        CSnapInItem * pItemB;
        DATA_OBJECT_TYPES type;

        hr = m_pComponentData->GetDataClass(lpDataObjectA, &pItemA, &type);

        if (SUCCEEDED(hr))
        {
            hr = m_pComponentData->GetDataClass(lpDataObjectB, &pItemB, &type);
        }

        if (FAILED(hr))
        {
            break;
        }

        if (!pItemA || !pItemB)
        {
            hr = E_POINTER;
            break;
        }

        if (pItemA == pItemB)
        {
            //
            // Literally the same object
            //
            hr = S_OK;
            break;
        }

        CIISObject * pObjectA = (CIISObject *)pItemA;
        CIISObject * pObjectB = (CIISObject *)pItemB;

        hr = !pObjectA->CompareScopeItem(pObjectB) ? S_OK : S_FALSE;
    }
    while(FALSE);

    return hr;
}

HRESULT 
CInetMgr::GetDataClass(
    IDataObject * pDataObject, 
    CSnapInItem ** ppItem, 
    DATA_OBJECT_TYPES * pType)
{
    if (ppItem == NULL)
	    return E_POINTER;
    if (pType == NULL)
	    return E_POINTER;

    *ppItem = NULL;
    *pType = CCT_UNINITIALIZED;
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE,
			NULL,
			DVASPECT_CONTENT,
			-1,
			TYMED_HGLOBAL
		};

	stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID));
    if (stgmedium.hGlobal == NULL)
        return E_OUTOFMEMORY; 

	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
    if (FAILED(hr))
    { 
	    GlobalFree(stgmedium.hGlobal);
	    return hr;
    }

	GUID guid;
	memcpy(&guid, stgmedium.hGlobal, sizeof(GUID));

	GlobalFree(stgmedium.hGlobal);
	hr = S_OK;

	if (IsEqualGUID(guid, cCompMgmtService))
    {
        if (!IsExtension())
        {
			CIISRoot * pRootExt = new CIISRoot;
			if (pRootExt == NULL)
			{
				return E_OUTOFMEMORY;
			}

			hr = pRootExt->InitAsExtension(pDataObject);
			if (FAILED(hr))
			{
				return hr;
			}
                        pRootExt->SetConsoleData(m_pConsoleNameSpace,m_pConsole);
			if (m_pNode != NULL)
			{
				CIISObject * pNode = dynamic_cast<CIISObject *>(m_pNode);
                                if (pNode->GetConsoleNameSpace())
                                {
                                    pRootExt->SetConsoleData(pNode->GetConsoleNameSpace(),pNode->GetConsole());
                                }
				pNode->Release();
			}

                        g_IISMMCInstanceCountExtensionMode++;
			m_pNode = pRootExt;
        }
        *ppItem = m_pNode;

		return hr;
    }
	return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
};

BOOL
CInetMgr::IsExtension()
{
    ASSERT(m_pNode != NULL);
    CIISRoot * pRoot = (CIISRoot *)m_pNode;
    return pRoot->IsExtension();
}


//
// CInetMrgAbout Class
// 
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
CInetMgrAbout::GetStringHelper(UINT nStringID, LPOLESTR * lpString)
/*++

Routine Description:

    Get resource string helper function.  Called from inline string fetcher
    methods.

Arguments:

    UINT nStringID      : String ID from local resource segment
    LPOLESTR * lpString : Returns the string

Return Value:

    HRESULT

--*/
{
    USES_CONVERSION;

    TCHAR szBuf[256];

    if (::LoadString(
        _Module.GetResourceInstance(), 
        nStringID, 
        szBuf, 
        256) == 0)
    {
        return E_FAIL;
    }

    *lpString = (LPOLESTR)::CoTaskMemAlloc(
        (lstrlen(szBuf) + 1) * sizeof(OLECHAR)
        );

    if (*lpString == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ::ocscpy(*lpString, T2OLE(szBuf));

    return S_OK;
}



HRESULT
CInetMgrAbout::GetSnapinImage(HICON * hAppIcon)
/*++

Routine Description:

    Get the icon for this snapin.

Arguments:

    HICON * hAppIcon : Return handle to the icon

Return Value:

    HRESULT

--*/
{
    if (hAppIcon == NULL)
    {
        return E_POINTER;
    }
    m_hSnapinIcon = ::LoadIcon(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDI_INETMGR)
        );

    *hAppIcon = m_hSnapinIcon;

    ASSERT(*hAppIcon != NULL);

    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}



HRESULT
CInetMgrAbout::GetStaticFolderImage(
    HBITMAP *  phSmallImage,
    HBITMAP *  phSmallImageOpen,
    HBITMAP *  phLargeImage,
    COLORREF * prgbMask
    )
/*++

Routine Description:

    Get the static folder images.

Arguments:

    HBITMAP * phSmallImage      : Small folder
    HBITMAP * phSmallImageOpen  : Small open folder
    HBITMAP * phLargeImage      : Large image
    COLORREF * prgbMask         : Mask

Return Value:

    HRESULT

--*/
{
    if (!phSmallImage || !phSmallImageOpen || !phLargeImage || !prgbMask)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    m_hSmallImage = (HBITMAP)::LoadImage(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDB_SMALL_ROOT),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR
        );
    m_hLargeImage = (HBITMAP)::LoadImage(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDB_LARGE_ROOT),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR
        );

    *phSmallImage = m_hSmallImage;
    *phSmallImageOpen = m_hSmallImage;
    *phLargeImage = m_hLargeImage;
    *prgbMask = RGB_BK_IMAGES;

    return *phSmallImage && *phLargeImage ? S_OK : E_FAIL;
}


CInetMgrAbout::~CInetMgrAbout()
{
    if (m_hSmallImage != NULL)
    {
        ::DeleteObject(m_hSmallImage);
    }
    if (m_hLargeImage != NULL)
    {
        ::DeleteObject(m_hLargeImage);
    }
    if (m_hSnapinIcon != NULL)
    {
        ::DestroyIcon(m_hSnapinIcon);
    }
}


#if 0
HRESULT
ExtractComputerNameExt(IDataObject * pDataObject, CString& strComputer)
{
	//
	// Find the computer name from the ComputerManagement snapin
	//
    CLIPFORMAT CCF_MyComputMachineName = (CLIPFORMAT)RegisterClipboardFormat(MYCOMPUT_MACHINE_NAME);
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { 
        CCF_MyComputMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
    };

    //
    // Allocate memory for the stream
    //
    int len = MAX_PATH;
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
	if(stgmedium.hGlobal == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
    ASSERT(SUCCEEDED(hr));
	//
	// Get the computer name
	//
    strComputer = (LPTSTR)stgmedium.hGlobal;

	GlobalFree(stgmedium.hGlobal);

    return hr;
}

HRESULT
CCompMgrExtData::Init(IDataObject * pDataObject)
{
    TRACEEOLID("CCompMgrExtData::Init:g_IISMMCInstanceCount=" << g_IISMMCInstanceCount);
    return ExtractComputerNameExt(pDataObject, m_ExtMachineName);
}

HRESULT 
STDMETHODCALLTYPE 
CCompMgrExtData::Notify(
		MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
{
    TRACEEOLID("CCompMgrExtData::Notify");
	CError err;
    CComPtr<IConsole> pConsole;
    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> pHeader;
    CComQIPtr<IResultData, &IID_IResultData> pResultData;

    if (pComponentData != NULL)
    {
        pConsole = ((CInetMgr *)pComponentData)->m_spConsole;
    }
    else
    {
        pConsole = ((CInetMgrComponent *)pComponent)->m_spConsole;
    }
    CComQIPtr<IConsoleNameSpace2, &IID_IConsoleNameSpace2> pScope = pConsole;
	switch (event)
	{
	case MMCN_EXPAND:
        err = EnumerateScopePane((HSCOPEITEM)param, pScope);
		break;
	default:
		err = CSnapInItemImpl<CCompMgrExtData, TRUE>::Notify(event, arg, param, pComponentData, pComponent, type);
		break;
	}
	return err;
}

HRESULT
CCompMgrExtData::EnumerateScopePane(HSCOPEITEM hParent, IConsoleNameSpace2 * pScope)
{
    TRACEEOLID("CCompMgrExtData::EnumerateScopePane");
    CError err;
    ASSERT_PTR(pScope);

    DWORD dwMask = SDI_PARENT; 

    SCOPEDATAITEM  scopeDataItem;

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = 
		SDI_STR | SDI_IMAGE | SDI_CHILDREN | SDI_OPENIMAGE | SDI_PARAM | dwMask;
    scopeDataItem.displayname = MMC_CALLBACK;
    scopeDataItem.nImage = scopeDataItem.nOpenImage = MMC_IMAGECALLBACK;//QueryImage();
    scopeDataItem.lParam = (LPARAM)this;
    scopeDataItem.relativeID = hParent;
    scopeDataItem.cChildren = 1;

    err = pScope->InsertItem(&scopeDataItem);

    if (err.Succeeded())
    {
        //
        // Cache the scope item handle
        //
        ASSERT(m_hScopeItem == NULL);
        m_hScopeItem = scopeDataItem.ID;
		// MMC_IMAGECALLBACK doesn't work in InsertItem. Update it here.
		scopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
		err = pScope->SetItem(&scopeDataItem);
    }
    return err;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\inetprop.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        inetprop.h

   Abstract:

        Internet Properties base classes definitions

   Author:

        Ronald Meijer (ronaldm)
		  Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _INETPROP_H_
#define _INETPROP_H_

// Some useful macros to set edit control
// and buddy spin control
//
//   (s).SetPos((pos));\
//
#define SETUP_SPIN(s,min,max,pos)\
   (s).SetRange32((min),(max));\
   (s).SetAccel(3, toAcc)

#define SETUP_EDIT_SPIN(f, e, s, min, max, pos)\
   (e).EnableWindow((f));\
   (s).EnableWindow((f));\
   SETUP_SPIN((s),(min),(max),(pos))

//
// InitializeAndFetch parameters
//
#define WITHOUT_INHERITANCE (FALSE)
#define WITH_INHERITANCE    (TRUE)

//
// SSL Port number to use if SSL is not enabled
//
#define SSL_NOT_ENABLED     (0)

//
// Bandwidth and compression definitions
//
#define BANDWIDTH_MIN           (1)
#define BANDWIDTH_MAX           (32767)
#define INFINITE_BANDWIDTH      (0xffffffff)
#define KILOBYTE                (1024L)
#define MEGABYTE                (1024L * KILOBYTE)
#define DEF_BANDWIDTH           (1 * MEGABYTE)
#define DEF_MAX_COMPDIR_SIZE    (1 * MEGABYTE)

//
// Private FILE_ATTRIBUTE used to designate a virtual directory
//
#define FILE_ATTRIBUTE_VIRTUAL_DIRECTORY    (0x10000000)


//
// Attribute crackers
//
#define IS_VROOT(dwAttributes) ((dwAttributes & FILE_ATTRIBUTE_VIRTUAL_DIRECTORY) != 0)
#define IS_DIR(dwAttributes) ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
#define IS_FILE(dwAttributes) ((dwAttributes & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_VIRTUAL_DIRECTORY)) == 0)

//
// Metabase constants
//

//
// TODO: From mdkeys?
//
extern const LPCTSTR g_cszTemplates;
extern const LPCTSTR g_cszCompression;
extern const LPCTSTR g_cszMachine;
extern const LPCTSTR g_cszMimeMap;
extern const LPCTSTR g_cszRoot;
extern const LPCTSTR g_cszSep;
extern const TCHAR g_chSep;

//
// Utility Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Forward Definitions
//
class CIPAddress;

//
// Determine if the currently logged-in user us an administrator
// or operator in the virtual server provided
//
HRESULT
DetermineIfAdministrator(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR lpszMetabasePath,
    OUT BOOL * pfAdministrator,
    IN OUT DWORD * pdwMetabaseSystemChangeNumber
    );



//
// Utility classes
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CMaskedDWORD
/*++

Class Description:

    A masked DWORD class.  This class performs assignments and comparison 
    on a masked range of the DWORD value.  For example, if a mask of 
    0x000000FF is set, any comparisons or assignments will only involve 
    the least significant byte.  A comparison against another DWORD will
    only compare that least significant byte, and an assignment will only
    set the least significant byte, leaving the rest untouched.

Public Interface:

    CMaskedDWORD        : Constructor
    operator ==         : Comparison operator
    operator !=         : Comparison operator
    operator =          : Assignment operator
    operator DWORD      : Cast to the value
    void SetMask        : Set the mask

--*/
{
//
// Constructor/Destructor
//
public:
    CMaskedDWORD(
        IN DWORD dwValue = 0L,
        IN DWORD dwMask  = 0xFFFFFFFF
        )
        : m_dwValue(dwValue),
          m_dwMask(dwMask)
    {
    }

public:
    BOOL operator ==(DWORD dwValue) const;
    BOOL operator !=(DWORD dwValue) const { return !(operator ==(dwValue)); }

    CMaskedDWORD & operator =(DWORD dwValue);
    operator DWORD() const { return m_dwValue; }
    operator DWORD &() { return m_dwValue; }
    void SetMask(DWORD dwMask) { m_dwMask = dwMask; }

private:
    DWORD m_dwValue;
    DWORD m_dwMask;
};


//
// Forward Definitions
//
class CIPAddress;



template <class TYPE, class ARG_TYPE> 
class CMPProp
{
public:
    CMPProp(ARG_TYPE value);
    CMPProp();
    operator ARG_TYPE() const;
    CMPProp<TYPE, ARG_TYPE> & operator =(ARG_TYPE value);
    BOOL m_fDirty;
    TYPE m_value;
};

template <class TYPE, class ARG_TYPE> 
inline CMPProp<TYPE, ARG_TYPE>::CMPProp(ARG_TYPE value)
    : m_value(value),
      m_fDirty(FALSE)
{
}

template <class TYPE, class ARG_TYPE> 
inline CMPProp<TYPE, ARG_TYPE>::CMPProp()
    : m_value(),
      m_fDirty(FALSE)
{
}

template <class TYPE, class ARG_TYPE>
inline CMPProp<TYPE, ARG_TYPE>::operator ARG_TYPE() const
{
    return (ARG_TYPE)m_value;
}

template <class TYPE, class ARG_TYPE>
inline CMPProp<TYPE, ARG_TYPE> & CMPProp<TYPE, ARG_TYPE>::operator =(ARG_TYPE value)
{
    if (m_value != value)
    {
        m_value = value;
        m_fDirty = TRUE;
    }
    
    return *this;
}


//
// MP Access (use operators where possible!)
//
#define MP_V(x) (x.m_value)
#define MP_D(x) (x.m_fDirty)


//
// Common property types
//
typedef CMPProp<CBlob, CBlob&>                   MP_CBlob;
typedef CMPProp<CString, LPCTSTR>                MP_CString;
typedef CMPProp<CStrPassword, CStrPassword&>     MP_CStrPassword;
typedef CMPProp<CStringListEx, CStringListEx &>  MP_CStringListEx;
typedef CMPProp<CILong, LONG>                    MP_CILong;
typedef CMPProp<int, int>                        MP_int;
typedef CMPProp<DWORD, DWORD>                    MP_DWORD;
typedef CMPProp<BOOL, BOOL>                      MP_BOOL;
typedef CMPProp<CMaskedDWORD, DWORD>             MP_CMaskedDWORD;



//
// CODEWORK: Turns these into proper methods
//
#define BEGIN_META_WRITE()\
{                                               \
    HRESULT hr = S_OK;                          \
    do                                          \
    {                                           \
        m_dwaDirtyProps.RemoveAll();            \

#define META_WRITE(id, value)\
        if(MP_D(value))                         \
        {                                       \
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting();          \
                if (FAILED(hr)) break;          \
            }                                   \
            hr = SetValue(id, MP_V(value));     \
            if (FAILED(hr)) break;              \
            MP_D(value) = FALSE;                \
            m_dwaDirtyProps.AddTail(id);        \
        }                                       \

#define META_WRITE_INHERITANCE(id, value, foverride)\
        if(MP_D(value))                         \
        {                                       \
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting();          \
                if (FAILED(hr)) break;          \
            }                                   \
            hr = SetValue(id, MP_V(value), &foverride);\
            if (FAILED(hr)) break;              \
            MP_D(value) = FALSE;                \
            m_dwaDirtyProps.AddTail(id);        \
        }                                       \

#define META_DELETE(id)\
        FlagPropertyForDeletion(id);            \

#define END_META_WRITE(err)\
        POSITION pos;                           \
        pos = m_dwaDeletedProps.GetHeadPosition();\
        while(pos != NULL)                      \
        {                                       \
            DWORD dwID = m_dwaDeletedProps.GetNext(pos);\
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting(FALSE);     \
			}									\
            if (IsOpen() && SUCCEEDED(hr))      \
            {									\
                TRACEEOLID("Deleting #" << dwID);\
                 hr = DeleteValue(dwID);          \
                 m_dwaDirtyProps.AddTail(dwID);   \
            }                                    \
        }                                       \
        m_dwaDeletedProps.RemoveAll();          \
        if (IsOpen()) Close();                  \
        pos = m_dwaDirtyProps.GetHeadPosition();\
        hr = S_OK;                              \
        while(pos != NULL)                      \
        {                                       \
            hr = CheckDescendants(m_dwaDirtyProps.GetNext(pos), &m_auth, m_strMetaRoot); \
            if (FAILED(hr)) break;              \
        }                                       \
    }                                           \
    while(FALSE);                               \
    err = hr;                                   \
}



/* ABSTRACT */ class CMetaProperties : public CMetaKey
/*++

Class Description:

    Abstract base class that reads all metadata at a specific
    metabase path.  

Public Interface:

    QueryResult             : Get result code from construction
    QueryMetaPath           : Get the metabase path

Virtual Interface:

    ParseFields             : Break up data into member variables    

--*/
{
//
// Constructor/Destructor
//
protected:
    //
    // Constructor which creates new interface
    //
    CMetaProperties(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

    //
    // Construct with existing interface
    //
    CMetaProperties(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath
        );

    //
    // Construct with open key
    //
    CMetaProperties(
        IN CMetaKey * pKey,
        IN LPCTSTR lpszMDPath
        );

    //
    // Destructor
    //
    ~CMetaProperties();

public:
    //
    // GetAllData()
    //
    virtual HRESULT LoadData();
    virtual HRESULT WriteDirtyProps();
    void FlagPropertyForDeletion(DWORD dwID);

    virtual HRESULT CMetaProperties::QueryResult() const;
    LPCTSTR QueryMetaRoot() const { return m_strMetaRoot; }

protected:
    virtual void ParseFields() = 0;
    void Cleanup();
    HRESULT OpenForWriting(BOOL fCreate = TRUE);

protected:
    BOOL     m_fInherit;
    HRESULT  m_hResult;
    CString  m_strMetaRoot;
    DWORD    m_dwMDUserType;
    DWORD    m_dwMDDataType;
    CList<DWORD, DWORD> m_dwaDirtyProps;
    CList<DWORD, DWORD> m_dwaDeletedProps;

    //
    // Read all values
    //
    DWORD    m_dwNumEntries;
    DWORD    m_dwMDDataLen;
    PBYTE    m_pbMDData;
};



//
// Machine Properties object
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


class CMachineProps : public CMetaProperties
/*++

Class Description:

    Global machine properties

Public Interface:

    CMachineProps       : Constructor

    WriteDirtyProps     : Write dirty properties

--*/
{
public:
    CMachineProps(CComAuthInfo * pAuthInfo);
    CMachineProps(CMetaInterface * pInterface);

public:
    HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    MP_BOOL m_fEnableMetabaseEdit;
    MP_BOOL m_fUTF8Web;
};



//
// Compression Properties Object
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CIISCompressionProps : public CMetaProperties
/*++

Class Description:

    Compression settings

Public Interface:

    CIISCompressionProps : Constructor

    WriteIfDirty         : Write data if dirty

--*/
{
public:
    CIISCompressionProps(
        IN CComAuthInfo * pAuthInfo
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

    //
    // Load data
    //
    virtual HRESULT LoadData();

public:
    MP_BOOL    m_fEnableStaticCompression;
    MP_BOOL    m_fEnableDynamicCompression;
    MP_BOOL    m_fLimitDirectorySize;
    MP_DWORD   m_dwDirectorySize;
    MP_CString m_strDirectory;

protected:
    virtual void ParseFields();

private:
    BOOL m_fPathDoesNotExist;
};



class CMimeTypes : public CMetaProperties
/*++

Class Description:

    A list of mime types.

Public Interface:

    CMimeTypes          : Constructor

    WriteIfDirty        : Write properties if dirty

--*/
{
public:
    //
    // Constructor that creates new interface
    //
    CMimeTypes(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

    //
    // Constructor that uses an existing interface
    //
    CMimeTypes(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write the data;
    //
    virtual HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    MP_CStringListEx   m_strlMimeTypes;
};



class CServerCapabilities : public CMetaProperties
/*++

Class Description:

    Server capabilities object

Public Interface:

    CServerCapabilities     : Constructor

--*/
{
public:
    //
    // Constructor that creates a new interface
    //
    CServerCapabilities(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath                      // e.g. "lm/w3svc/info"
        );

    //
    // Constructor that uses an existing interface
    //
    CServerCapabilities(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath                      // e.g. "lm/w3svc/info"
        );

public:
    BOOL IsSSLSupported()       const { return (m_dwCapabilities & IIS_CAP1_SSL_SUPPORT) != 0L; }
    BOOL IsSSL128Supported()    const 
    { 
       if (m_dwVersionMajor >= 6)
       {
          // We have this feature ALWAYS enabled in iis6 and iis5.1
          return TRUE;
       }
       else if (m_dwVersionMajor == 5 && m_dwVersionMinor == 1)
       {
          return TRUE;
       }
       else
       {
          return (m_dwConfiguration & MD_SERVER_CONFIG_SSL_128) != 0L; 
       }
    }
    BOOL HasMultipleSites()     const { return (m_dwCapabilities & IIS_CAP1_MULTIPLE_INSTANCE) != 0L; }
    BOOL HasBwThrottling()      const { return (m_dwCapabilities & IIS_CAP1_BW_THROTTLING) != 0L; }
    BOOL Has10ConnectionLimit() const { return (m_dwCapabilities & IIS_CAP1_10_CONNECTION_LIMIT) != 0L; }
    BOOL HasIPAccessCheck()     const { return (m_dwCapabilities & IIS_CAP1_IP_ACCESS_CHECK) != 0L; }
    BOOL HasOperatorList()      const { return (m_dwCapabilities & IIS_CAP1_OPERATORS_LIST) != 0L; }
    BOOL HasFrontPage()         const { return (m_dwCapabilities & IIS_CAP1_FP_INSTALLED) != 0L; }
    BOOL HasCompression()       const { return (m_dwCapabilities & IIS_CAP1_SERVER_COMPRESSION) != 0L; }
    BOOL HasCPUThrottling()     const { return (m_dwCapabilities & IIS_CAP1_CPU_AUDITING) != 0L; }
    BOOL HasDigest()            const { return (m_dwCapabilities & IIS_CAP1_DIGEST_SUPPORT) != 0L; }
    BOOL HasNTCertMapper()      const { return (m_dwCapabilities & IIS_CAP1_NT_CERTMAP_SUPPORT) != 0L; }

	BOOL IsWorkstationLegacyCode()    const 
	{
		// workstation was determined this way in iis4/5/51
		if (Has10ConnectionLimit())
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	BOOL IsWorkstation() const 
	{
		if (m_dwVersionMajor >= 6)
		{
			if (INET_INFO_PRODUCT_NTWKSTA == m_dwPlatform)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
		else
		{
			return IsWorkstationLegacyCode();
		}
	}

    BOOL IsCompressionConfigurable() const 
	{
       if (m_dwVersionMajor >= 6)
       {
		   // Compression is configurable for workstation and server in iis6
		   if (IsWorkstation())
		   {
			   return TRUE;
		   }
		   else
		   {
			   return TRUE;
		   }
       }
	   else
	   {
		   // Compression is not configurable for workstation in pre iis6
		   if (IsWorkstationLegacyCode())
		   {
			   return FALSE;
		   }
		   else
		   {
			   return TRUE;
		   }
	   }
	}

    BOOL IsPerformanceConfigurable()    const 
	{
       if (m_dwVersionMajor >= 6)
       {
		   // Performance is not configurable for workstation in iis6
		   if (IsWorkstation())
		   {
			   return FALSE;
		   }
		   else
		   {
			   return TRUE;
		   }
       }
	   else
	   {
		   // Performance is not configurable for workstation in pre iis6
		   if (IsWorkstationLegacyCode())
		   {
			   return FALSE;
		   }
		   else
		   {
			   return TRUE;
		   }
	   }
	}

    BOOL IsServiceLevelConfigurable() const 
	{
       if (m_dwVersionMajor >= 6)
       {
		   // service level is configurable for workstation and server in iis6
		   if (IsWorkstation())
		   {
			   return TRUE;
		   }
		   else
		   {
			   return TRUE;
		   }
       }
	   else
	   {
		   // Performance is not configurable for workstation in pre iis6
		   if (IsWorkstationLegacyCode())
		   {
			   return FALSE;
		   }
		   else
		   {
			   return TRUE;
		   }
	   }
	}

    DWORD QueryMajorVersion()   const { return m_dwVersionMajor; }
    DWORD QueryMinorVersion()   const { return m_dwVersionMinor; }

protected:
    virtual void ParseFields();

private:
    //
    // Capabilities fields
    //
    MP_DWORD m_dwPlatform;
    MP_DWORD m_dwVersionMajor;
    MP_DWORD m_dwVersionMinor;
    MP_DWORD m_dwCapabilities;
    MP_DWORD m_dwConfiguration;
};



class CInstanceProps : public CMetaProperties
/*++

Class Description:

    Generic instance properties.  Construct with lightweight = TRUE
    to fetch enough information for enumeration only.

Public Interface:

    CInstanceProps:         : Constructor

    Add                     : static method to create new instance
    Remove                  : static method to remove instance
    ChangeState             : Change the state of a property
    QueryError              : Get the win32 error
    GetDisplayText          : Generate display name of instance

--*/
{
public:
    //
    // Public method to convert instance info to display text
    //
    static LPCTSTR GetDisplayText(
        OUT CString & strName,
        IN  LPCTSTR szComment,
        IN  LPCTSTR szHostHeaderName,
        //IN  LPCTSTR szServiceName,
        IN  CIPAddress & ia, 
        IN  UINT uPort,
        IN  DWORD dwID
        );

public:
    //
    // Constructor that creates an interface
    //
    CInstanceProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN UINT    nDefPort     = 0U
        );

    //
    // Constructor that reuses existing interface
    //
    CInstanceProps(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath,
        IN UINT    nDefPort     = 0U
        );

    //
    // Special constructor that uses an open parent key,
    // and uses a relative path off the open key.
    //
    CInstanceProps(
        IN CMetaKey * pKey, 
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwInstance,
        IN UINT    nDefPort     = 0U
        );

public:
    //
    // Parse the binding string into component parts
    //
    static void CrackBinding(
        IN  CString lpszBinding,
        OUT CIPAddress & iaIpAddress, 
        OUT UINT & nTCPPort, 
        OUT CString & strDomainName
        );

    //
    // Parse the secure binding string into component parts
    //
    static void CrackSecureBinding(
        IN  CString lpszBinding,
        OUT CIPAddress & iaIpAddress, 
        OUT UINT & nSSLPort
        );

    //
    // Find the SSL port applicable to the given
    // IP Address.  Return the index where this SSL port
    // was found, or -1 if it was not found.
    //
    static int FindMatchingSecurePort(
        IN  CStringList & strlBindings, 
        IN  CIPAddress & iaIpAddress,
        OUT UINT & m_nSSLPort
        );

    //
    // Find ip address/port combo
    //
    static BOOL IsPortInUse(
        IN CStringList & strlBindings,
        IN CIPAddress & iaIPAddress,
        IN UINT nPort
        );

    //
    // Build binding string
    //
    static void BuildBinding(
        OUT CString & strBinding, 
        IN  CIPAddress & iaIpAddress, 
        IN  UINT & nTCPPort, 
        IN  CString & lpszDomainName
        );

    //
    // Build secure binding string
    //
    static void BuildSecureBinding(
        OUT CString & strBinding, 
        IN  CIPAddress & iaIpAddress, 
        IN  UINT & nSSLPort 
        );

    //
    // Create new instance
    //
    static HRESULT Add(
        IN  CMetaInterface * pInterface,
        IN  LPCTSTR lpszService,
        IN  LPCTSTR lpszHomePath,
        IN  LPCTSTR lpszUserName        = NULL,
        IN  LPCTSTR lpszPassword        = NULL,
        IN  LPCTSTR lpszDescription     = NULL,
        IN  LPCTSTR lpszBinding         = NULL,
        IN  LPCTSTR lpszSecureBinding   = NULL,
        IN  DWORD * pdwPermissions      = NULL,
        IN  DWORD * pdwDirBrowsing      = NULL,
        IN  DWORD * pwdAuthFlags        = NULL,
        OUT DWORD * pdwInstance         = NULL    
        );

    //
    // Remove existing instance
    //
    static HRESULT Delete(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance
        );

//
// Access
//
public:
    //
    // Change the running state of the instance
    //
    HRESULT ChangeState(
        IN DWORD dwCommand
        );

    //
    // Get the WIN32 error
    //
    DWORD QueryError() const { return m_dwWin32Error; }

    //
    // Get the instance number
    //
    DWORD QueryInstance() const { return m_dwInstance; }

    //
    // Check to see if this is a cluster enabled instance
    //
    BOOL IsClusterEnabled() const { return m_fCluster; }

    //
    // Get the friendly name for this instance
    //
    LPCTSTR GetDisplayText(
        OUT CString & strName
        //IN  LPCTSTR szServiceName
        );

    //
    // Get the complete metabase path to the home directory
    //
    LPCTSTR GetHomePath(OUT CString & str);

    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    //
    // Meta values
    //
    MP_BOOL          m_fCluster;
    MP_CStringListEx m_strlBindings;
    MP_CString       m_strComment;
    MP_DWORD         m_dwState;
    MP_DWORD         m_dwWin32Error;

    //
    // Derived Values
    //
    UINT             m_nTCPPort;
    CIPAddress       m_iaIpAddress;
    CString          m_strDomainName;

private:
    DWORD            m_dwInstance;
};



class CChildNodeProps : public CMetaProperties
/*++

Class Description:

    Generic child node properties.  Could be a vdir, a dir
    or a file.

Public Interface:

    CChildNodeProps         : Constructor

    Add                     : Create new virtual directory
    Delete                  : Delete virtual directory
    Rename                  : Rename virtual directory

    QueryError              : Get the win32 error
    IsPathInherited         : Return TRUE if the path was inherited
    FillInstanceInfo        : Fill instance info structure
    FillChildInfo           : Fill child info structure

--*/
{
public:
    //
    // Constructors
    //
    CChildNodeProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

    CChildNodeProps(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

    CChildNodeProps(
        IN CMetaKey * pKey,
        IN LPCTSTR lpszPath     = NULL,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

public:
    //
    // Create new virtual directory
    //
    static HRESULT Add(
        IN CMetaInterface * pInterface,

        IN LPCTSTR lpszParentPath,
        /*
        IN  LPCTSTR lpszService,
        IN  DWORD   dwInstance,         
        IN  LPCTSTR lpszParentPath,     
        */
        IN  LPCTSTR lpszAlias,
        OUT CString & strAliasCreated,
        IN  DWORD * pdwPermissions      = NULL,
        IN  DWORD * pdwDirBrowsing      = NULL,
        IN  LPCTSTR lpszVrPath          = NULL,
        IN  LPCTSTR lpszUserName        = NULL,
        IN  LPCTSTR lpszPassword        = NULL,
        IN  BOOL    fExactName          = TRUE
        );

    //
    // Delete virtual directory
    //
    static HRESULT Delete(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszParentPath,      OPTIONAL
        IN LPCTSTR lpszNode
        );

    //
    // Rename virtual directory
    //
    static HRESULT Rename(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszParentPath,      OPTIONAL
        IN LPCTSTR lpszOldName,
        IN LPCTSTR lpszNewName
        );

public:
    //
    // TRUE, if this is an enabled application
    //
    BOOL IsEnabledApplication() { return m_fIsAppRoot; }

    //
    // Get the alias name
    //
    LPCTSTR QueryAlias() const { return m_strAlias; }
    //CString & GetAlias() { return m_strAlias; }

    //
    // Get the error
    //
    DWORD QueryWin32Error() const { return m_dwWin32Error; }

    //
    // This is how to separate file/dir props from vdirs
    //
    BOOL IsPathInherited() const { return m_fPathInherited; }

    //
    // Empty the path if it was inherited
    //
    void RemovePathIfInherited();

    //
    // CODEWORK: Ugly solution.
    //
    // Call this method to override the inheritance status of the
    // http redirect path
    //
    void MarkRedirAsInherit(BOOL fInherit) { m_fInheritRedirect = fInherit; }

    //
    // Get the path
    //
    CString & GetPath() { return MP_V(m_strPath); }

    //
    // Get the redirected path
    //
    CString & GetRedirectedPath() { return m_strRedirectPath; }

    //
    // Get the access perms
    //
    DWORD QueryAccessPerms() const { return m_dwAccessPerms; }

    //
    // Get dir browsing bits
    //
    DWORD QueryDirBrowsing() const { return m_dwDirBrowsing; }

    //
    // True if the child is redirected
    //
    BOOL IsRedirected() const { return !m_strRedirectPath.IsEmpty(); }

    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

    //
    // Break down redirect statement into component paths
    //
    void ParseRedirectStatement();

    //
    // Reverse the above -- reassemble the redirect statement
    //
    void BuildRedirectStatement();

protected:
    //
    // Redirect tags
    //
    static const TCHAR   _chTagSep;
    static const LPCTSTR _cszExactDestination;
    static const LPCTSTR _cszChildOnly;
    static const LPCTSTR _cszPermanent;

public:
    BOOL            m_fIsAppRoot;
    BOOL            m_fPathInherited;
    BOOL            m_fInheritRedirect;
    BOOL            m_fExact;               // Redirect tag
    BOOL            m_fChild;               // Redirect tag
    BOOL            m_fPermanent;           // Redirect tag
    CString         m_strAlias;
    CString         m_strFullMetaPath;
    CString         m_strRedirectPath;      // Redirect _path_

public:
    MP_BOOL         m_fAppIsolated;
    MP_DWORD        m_dwWin32Error;
    MP_DWORD        m_dwDirBrowsing;
    MP_CString      m_strPath;
    MP_CString      m_strRedirectStatement; // Path + tags
    MP_CString      m_strAppRoot;
    MP_CMaskedDWORD m_dwAccessPerms;
};



inline CMetaKey * GetMetaKeyFromHandle(IN HANDLE hServer)
{
    ASSERT(hServer != NULL);
    return (CMetaKey *)hServer;
}

inline LPCTSTR GetServerNameFromHandle(IN HANDLE hServer)
{
    ASSERT(hServer != NULL);
    return ((CMetaKey *)hServer)->QueryServerName();
}


//
// Metabase Helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Get record data size
//
inline DWORD RecordDataSize(
    IN METADATA_GETALL_RECORD * pAllRecord, 
    IN int iIndex
    )
{
    return pAllRecord[iIndex].dwMDDataLen;
}

//
// Fetch data at index as DWORD
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT DWORD & dwValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    dwValue = *((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as UINT
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT UINT & uValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    uValue = (UINT)*((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as int
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT int & iValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    iValue = (int)*((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as a CString
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CString & strValue
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
}

//
// Fetch data at index as a CStrPassword
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CStrPassword & strValue
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
}

//
// Fetch data at index as a CStringList
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CStringList & strlValue
    )
{
    ConvertDoubleNullListToStringList(
        ((LPCTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset)),
        strlValue,
        (RecordDataSize(pAllRecord, iIndex)) / sizeof(TCHAR)
        );
}

//
// Fetch binary data as a blob
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CBlob & blob
    )
{
    blob.SetValue(
        RecordDataSize(pAllRecord, iIndex), 
        ((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}    

inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CILong & ilValue
    )
{
    ilValue = (LONG)*((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as CString, and check inheritance status
//
inline void FetchInheritedMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CString & strValue,
    OUT BOOL & fIsInherited
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
    fIsInherited = (pAllRecord[iIndex].dwMDAttributes & METADATA_ISINHERITED) != 0;
}

//
// Fetch data at index as CStrPassword, and check inheritance status
//
inline void FetchInheritedMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CStrPassword & strValue,
    OUT BOOL & fIsInherited
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
    fIsInherited = (pAllRecord[iIndex].dwMDAttributes & METADATA_ISINHERITED) != 0;
}

//
// Fetch data at index as CStringListEx, and check inheritance status
//
inline void FetchInheritedMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CStringListEx & strlValue,
    OUT BOOL & fIsInherited
    )
{
    ConvertDoubleNullListToStringList(
        ((LPCTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset)),
        strlValue,
        (RecordDataSize(pAllRecord, iIndex)) / sizeof(TCHAR)
        );
    fIsInherited = (pAllRecord[iIndex].dwMDAttributes & METADATA_ISINHERITED) != 0;
}

//
// Flag Operations
//
#define IS_FLAG_SET(dw, flag) ((((dw) & (flag)) != 0) ? TRUE : FALSE)
#define SET_FLAG(dw, flag)    dw |= (flag)
#define RESET_FLAG(dw, flag)  dw &= ~(flag)
#define SET_FLAG_IF(cond, dw, flag)\
    if (cond)                      \
    {                              \
        SET_FLAG(dw, flag);        \
    }                              \
    else                           \
    {                              \
        RESET_FLAG(dw, flag);      \
    }

//
// Meta record crackers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#define BEGIN_PARSE_META_RECORDS(dwNumEntries, pbMDData)\
{                                                       \
    METADATA_GETALL_RECORD * pAllRecords =              \
        (METADATA_GETALL_RECORD *)pbMDData;             \
    ASSERT(pAllRecords != NULL);                        \
                                                        \
    for (DWORD i = 0; i < dwNumEntries; ++i)            \
    {                                                   \
        METADATA_GETALL_RECORD * pRec = &pAllRecords[i];\
        switch(pRec->dwMDIdentifier)                    \
        {

#define HANDLE_META_RECORD(id, value)\
        case id:                                        \
            FetchMetaValue(pAllRecords, i, MP_V(value));\
            break;

#define HANDLE_INHERITED_META_RECORD(id, value, fIsInherited)\
        case id:                                                               \
            FetchInheritedMetaValue(pAllRecords, i, MP_V(value), fIsInherited);\
            break;


#define END_PARSE_META_RECORDS\
        }                                                \
    }                                                    \
}



//
// Sheet -> page crackers
//
#define BEGIN_META_INST_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryInstanceResult()))                       \
        {                                                                \
            break;                                                       \
        }

#define FETCH_INST_DATA_FROM_SHEET(value)\
    value = pSheet->GetInstanceProperties().value;                       \
    TRACEEOLID(value);

#define FETCH_INST_DATA_FROM_SHEET_PASSWORD(value)\
    value = pSheet->GetInstanceProperties().value;

#define END_META_INST_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_DIR_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryDirectoryResult()))                      \
        {                                                                \
            break;                                                       \
        }

#define FETCH_DIR_DATA_FROM_SHEET(value)\
    value = pSheet->GetDirectoryProperties().value;                      \
    TRACEEOLID(value);

#define FETCH_DIR_DATA_FROM_SHEET_PASSWORD(value)\
    value = pSheet->GetDirectoryProperties().value;

#define END_META_DIR_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}


#define BEGIN_META_INST_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_INST_DATA_ON_SHEET(value)\
        pSheet->GetInstanceProperties().value = value;

#define STORE_INST_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetInstanceProperties().value = value;    \
        dirty = MP_D(((sheet *)GetSheet())->GetInstanceProperties().value);

#define FLAG_INST_DATA_FOR_DELETION(id)\
        pSheet->GetInstanceProperties().FlagPropertyForDeletion(id);

#define END_META_INST_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetInstanceProperties().WriteDirtyProps();            \
}


#define BEGIN_META_DIR_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_DIR_DATA_ON_SHEET(value)\
        pSheet->GetDirectoryProperties().value = value;

#define STORE_DIR_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetDirectoryProperties().value = value;      \
        dirty = MP_D(pSheet->GetDirectoryProperties().value);

#define INIT_DIR_DATA_MASK(value, mask)\
        MP_V(pSheet->GetDirectoryProperties().value).SetMask(mask);

#define FLAG_DIR_DATA_FOR_DELETION(id)\
        pSheet->GetDirectoryProperties().FlagPropertyForDeletion(id);

#define END_META_DIR_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetDirectoryProperties().WriteDirtyProps();           \
}




//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CMaskedDWORD::operator ==(DWORD dwValue) const
{
    return (m_dwValue & m_dwMask) == (dwValue & m_dwMask); 
} 

inline CMaskedDWORD & CMaskedDWORD::operator =(DWORD dwValue) 
{ 
    m_dwValue = ((m_dwValue &= ~m_dwMask) |= (dwValue & m_dwMask));
    return *this;
}

inline /*virtual */ HRESULT CMetaProperties::WriteDirtyProps()
{
    ASSERT_MSG("Not implemented");
    return E_NOTIMPL;
}

inline void CMetaProperties::FlagPropertyForDeletion(DWORD dwID)
{
    m_dwaDeletedProps.AddTail(dwID);
}

inline LPCTSTR CInstanceProps::GetDisplayText(
    OUT CString & strName
    //IN  LPCTSTR szServiceName
    )
{
    return CInstanceProps::GetDisplayText(
        strName, 
        m_strComment, 
        m_strDomainName,
        //szServiceName,
        m_iaIpAddress,
        m_nTCPPort,
        QueryInstance()
        );
}

inline LPCTSTR CInstanceProps::GetHomePath(CString & str)
{
    str = m_strMetaRoot + SZ_MBN_SEP_STR + g_cszRoot;
    return str;
}


inline void CChildNodeProps::RemovePathIfInherited()
{
    if (IsPathInherited())
    {
        MP_V(m_strPath).Empty();
    }
}


/*
inline void CChildNodeProps::FillInstanceInfo(ISMINSTANCEINFO * pii)
{
    _tcsncpy(pii->szPath, GetPath(), STRSIZE(pii->szPath));
    _tcsncpy(pii->szRedirPath, GetRedirectedPath(), STRSIZE(pii->szRedirPath));
    pii->fChildOnlyRedir = m_fChild;
}

inline void CChildNodeProps::FillChildInfo(ISMCHILDINFO * pii)
{
    //
    // Set the output structure
    //
    pii->fInheritedPath = IsPathInherited();
    pii->fEnabledApplication = IsEnabledApplication();
    pii->dwError = QueryWin32Error();

    _tcsncpy(
        pii->szAlias, 
        GetAlias(), 
        STRSIZE(pii->szAlias)
        );

    _tcsncpy(
        pii->szPath, 
        GetPath(),
        STRSIZE(pii->szPath)
        );

    _tcsncpy(
        pii->szRedirPath, 
        IsRedirected() ? GetRedirectedPath() : _T(""),
        STRSIZE(pii->szRedirPath)
        );

    pii->fChildOnlyRedir = m_fChild;
}
*/


#endif // _INETPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\logui.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "logui.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CLogUI

IMPLEMENT_DYNCREATE(CLogUI, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CLogUI properties

CString CLogUI::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CLogUI::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

COleFont CLogUI::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CLogUI::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

BOOL CLogUI::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CLogUI::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

short CLogUI::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CLogUI::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CLogUI operations

void CLogUI::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget);
}

void CLogUI::ApplyLogSelection()
{
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::SetComboBox(HWND hComboBox)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         hComboBox);
}

void CLogUI::Terminate()
{
    InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::SetUserData(LPCTSTR szName, LPCTSTR szPassword)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szName, szPassword);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\inetprop.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        inetprop.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "inetprop.h"
#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//
// Period to sleep while waiting for service to attain desired state
//
#define SLEEP_INTERVAL (500L)

//
// Maximum time to wait for service to attain desired state
//
#define MAX_SLEEP        (180000)       // For a service
#define MAX_SLEEP_INST   ( 30000)       // For an instance

//
// Instance numbers
//
#define FIRST_INSTANCE      (1)
#define LAST_INSTANCE       (0xffffffff)
#define MAX_INSTANCE_LEN    (32)



//
// Calling instance
//
//HINSTANCE hDLLInstance;



//
// Utility Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR g_cszTemplates   = SZ_MBN_INFO SZ_MBN_SEP_STR SZ_MBN_TEMPLATES;
const LPCTSTR g_cszCompression = SZ_MBN_FILTERS SZ_MBN_SEP_STR SZ_MBN_COMPRESSION SZ_MBN_SEP_STR SZ_MBN_PARAMETERS;
const LPCTSTR g_cszMachine     = SZ_MBN_MACHINE;
const LPCTSTR g_cszMimeMap     = SZ_MBN_MIMEMAP;
const LPCTSTR g_cszRoot        = SZ_MBN_ROOT;
const LPCTSTR g_cszSep         = SZ_MBN_SEP_STR;
const LPCTSTR g_cszInfo        = SZ_MBN_INFO;
const TCHAR g_chSep            = SZ_MBN_SEP_CHAR;



/*

NET_API_STATUS
ChangeInetServiceState(
    IN  LPCTSTR lpszServer,
    IN  LPCTSTR lpszService,
    IN  int nNewState,
    OUT int * pnCurrentState
    )
/*++

Routine Description:

    Start/stop/pause or continue a _service_

Arguments:

    LPCTSTR lpszServer   : Server name
    LPCTSTR lpszService  : Service name
    int nNewState        : INetService* definition.
    int * pnCurrentState : Ptr to current state (will be changed)

Return Value:

    Error return code

--/
{
#ifdef NO_SERVICE_CONTROLLER

    *pnCurrentState = INetServiceUnknown;

    return ERROR_SERVICE_REQUEST_TIMEOUT;

#else

    SC_HANDLE hService = NULL;
    SC_HANDLE hScManager = NULL;
    NET_API_STATUS err = ERROR_SUCCESS;

    do
    {
        hScManager = ::OpenSCManager(lpszServer, NULL, SC_MANAGER_ALL_ACCESS);

        if (hScManager == NULL)
        {
            err = ::GetLastError();
            break;
        }

        hService = ::OpenService(hScManager, lpszService, SERVICE_ALL_ACCESS);

        if (hService == NULL)
        {
            err = ::GetLastError();
            break;
        }

        BOOL fSuccess = FALSE;
        DWORD dwTargetState;
        DWORD dwPendingState;
        SERVICE_STATUS ss;

        switch(nNewState)
        {
        case INetServiceStopped:
            dwTargetState = SERVICE_STOPPED;
            dwPendingState = SERVICE_STOP_PENDING;
            fSuccess = ::ControlService(hService, SERVICE_CONTROL_STOP, &ss);
            break;

        case INetServiceRunning:
            dwTargetState = SERVICE_RUNNING;
            if (*pnCurrentState == INetServicePaused)
            {
                dwPendingState = SERVICE_CONTINUE_PENDING;
                fSuccess = ::ControlService(hService,
                    SERVICE_CONTROL_CONTINUE, &ss);
            }
            else
            {
                dwPendingState = SERVICE_START_PENDING;
                fSuccess = ::StartService(hService, 0, NULL);
            }
            break;

        case INetServicePaused:
            dwTargetState = SERVICE_PAUSED;
            dwPendingState = SERVICE_PAUSE_PENDING;
            fSuccess = ::ControlService(hService, SERVICE_CONTROL_PAUSE, &ss);
            break;

        default:
            ASSERT_MSG("Invalid service state requested");
            err = ERROR_INVALID_PARAMETER;
        }

        if (!fSuccess && err == ERROR_SUCCESS)
        {
            err = ::GetLastError();
        }

        //
        // Wait for the service to attain desired state, timeout
        // after 3 minutes.
        //
        DWORD dwSleepTotal = 0L;

        while (dwSleepTotal < MAX_SLEEP)
        {
            if (!::QueryServiceStatus(hService, &ss))
            {
                err = ::GetLastError();
                break;
            }

            if (ss.dwCurrentState != dwPendingState)
            {
                //
                // Done one way or another
                //
                if (ss.dwCurrentState != dwTargetState)
                {
                    //
                    // Did not achieve desired result. Something went
                    // wrong.
                    //
                    if (ss.dwWin32ExitCode)
                    {
                        err = ss.dwWin32ExitCode;
                    }
                }

                break;
            }

            //
            // Still pending...
            //
            ::Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }

        if (dwSleepTotal >= MAX_SLEEP)
        {
            err = ERROR_SERVICE_REQUEST_TIMEOUT;
        }

        //
        // Update state information
        //
        switch(ss.dwCurrentState)
        {
        case SERVICE_STOPPED:
        case SERVICE_STOP_PENDING:
            *pnCurrentState = INetServiceStopped;
            break;

        case SERVICE_RUNNING:
        case SERVICE_START_PENDING:
        case SERVICE_CONTINUE_PENDING:
            *pnCurrentState = INetServiceRunning;
            break;

        case SERVICE_PAUSE_PENDING:
        case SERVICE_PAUSED:
            *pnCurrentState = INetServicePaused;
            break;

        default:
            *pnCurrentState = INetServiceUnknown;
        }
    }
    while(FALSE);

    if (hService)
    {
        ::CloseServiceHandle(hService);
    }

    if (hScManager)
    {
        ::CloseServiceHandle(hScManager);
    }

    return err;

#endif // NO_SERVICE_CONTROLLER
}

*/



BOOL
DoesServerExist(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to make sure the machine exists

Arguments:

    LPCTSTR lpszServer      : machine name

Return Value:

    TRUE if the server exists, FALSE otherwise.

--*/
{
#ifdef NO_SERVICE_CONTROLLER

    //
    // Assume it exists
    //
    return TRUE;

#else

    //
    // CODEWORK: This is not the best way to do this, especially
    //           not across proxies and what not.
    //
    SC_HANDLE hScManager;
    NET_API_STATUS err = ERROR_SUCCESS;

    hScManager = ::OpenSCManager(lpszServer, NULL, SC_MANAGER_CONNECT);

    if (hScManager == NULL)
    {
        err = ::GetLastError();
    }

    ::CloseServiceHandle(hScManager);

    return err != RPC_S_SERVER_UNAVAILABLE;

#endif // NO_SERVICE_CONTROLLER

}



//
// CMetaProperties implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaProperties::CMetaProperties(
    IN CComAuthInfo * pAuthInfo      OPTIONAL,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor -- creates the interface

Arguments:

    CIISServer * pAuthInfo  : Auth info.  NULL indicates the local computer
    LPCTSTR lpszMDPath      : Metabase path

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_fInherit(TRUE),
      m_strMetaRoot(lpszMDPath),
      CMetaKey(pAuthInfo)
{
   CMetabasePath::CleanMetaPath(m_strMetaRoot);
}



CMetaProperties::CMetaProperties(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor -- attach to an existing interface.

Arguments:

    CMetaInterface * pInterface  : Existing interface
    LPCTSTR lpszMDPath           : Metabase path

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_fInherit(TRUE),
      m_strMetaRoot(lpszMDPath),
      CMetaKey(pInterface)
{
   CMetabasePath::CleanMetaPath(m_strMetaRoot);
}



CMetaProperties::CMetaProperties(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    CMetaKey * pKey     : Open key
    LPCTSTR lpszMDPath  : Path

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_strMetaRoot(lpszMDPath),
      m_fInherit(TRUE),
      CMetaKey(FALSE, pKey)
{
   CMetabasePath::CleanMetaPath(m_strMetaRoot);
}



CMetaProperties::~CMetaProperties()
/*++

Routine Description:

    Destructor -- clean up

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    Cleanup();
}



/* virtual */
HRESULT
CMetaProperties::LoadData()
/*++

Routine Description:

    Fetch all data with or without inheritance, and call the derived
    class to parse the data into fields.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Get all data off the master root
    //
    DWORD dwMDAttributes = METADATA_NO_ATTRIBUTES;

    if (m_fInherit)
    {
         dwMDAttributes = METADATA_INHERIT
            | METADATA_PARTIAL_PATH
            | METADATA_ISINHERITED;
    }

    m_hResult = GetAllData(
        dwMDAttributes,
        m_dwMDUserType,
        m_dwMDDataType,
        &m_dwNumEntries,
        &m_dwMDDataLen,
        &m_pbMDData,
        m_strMetaRoot
        );

    if (SUCCEEDED(m_hResult))
    {
        //
        // Call the derived class to break up data into fields
        //
        ParseFields();
    }

    Cleanup();

    return m_hResult;
}



void
CMetaProperties::Cleanup()
/*++

Routine Description:

    Free data

Arguments:

    None

Return Value:

    None

--*/
{
    SAFE_FREEMEM(m_pbMDData);

    m_dwNumEntries = 0;
    m_dwMDDataLen = 0;
}



/* virtual */
HRESULT
CMetaProperties::QueryResult() const
/*++

Routine Description:

    Determine the construction return code

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = CMetaKey::QueryResult();

    return SUCCEEDED(hr) ? m_hResult : hr;
}

HRESULT
RebindInterface(CMetaInterface * pInterface,
    BOOL * pfContinue, IN  DWORD dwCancelError);


HRESULT
CMetaProperties::OpenForWriting(
    IN BOOL fCreate     OPTIONAL
    )
/*++

Routine Description:

    Attempt to open the path for writing.  If fCreate is TRUE
    (default), then create the path if it doesn't yet exist

Arguments:

    BOOL fCreate        : If TRUE, create the path if it doesn't exist.

Return Value:

    HRESULT

Notes:

    If the key is already open, this will fire an ASSERT and close
    it.

--*/
{
    CError err;

    if (IsOpen())
    {
        ASSERT_MSG("Key already open -- closing");
        Close();
    }

    BOOL fNewPath, fRepeat;
    do
    {
        fNewPath = FALSE;
        fRepeat = FALSE;
        err = Open(METADATA_PERMISSION_WRITE, m_strMetaRoot);
        if (err.Win32Error() == ERROR_PATH_NOT_FOUND && fCreate)
        {
            err = CreatePathFromFailedOpen();
            fNewPath = err.Succeeded();
        }
        else if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
        {
            err = RebindInterface(this, &fRepeat, ERROR_CANCELLED);
        }
    } while(fNewPath || fRepeat);

    return err;
}


//
// Machine properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMachineProps::CMachineProps(
    IN CComAuthInfo * pAuthInfo       OPTIONAL
    )
    : CMetaProperties(pAuthInfo, CMetabasePath()),
      m_fEnableMetabaseEdit(TRUE),
      m_fUTF8Web(FALSE)
{
   // The only property we have here should actually be on metabase root
   m_strMetaRoot = SZ_MBN_SEP_CHAR;
   m_strMetaRoot += SZ_MBN_MACHINE;
}

CMachineProps::CMachineProps(
    IN CMetaInterface * pInterface
    )
    : CMetaProperties(pInterface, CMetabasePath()),
      m_fEnableMetabaseEdit(TRUE),
      m_fUTF8Web(FALSE)
{
   // The only property we have here should actually be on metabase root
   m_strMetaRoot = SZ_MBN_SEP_CHAR;
   m_strMetaRoot += SZ_MBN_MACHINE;
}

/* virtual */
void
CMachineProps::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

--*/
{
   BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_ROOT_ENABLE_EDIT_WHILE_RUNNING, m_fEnableMetabaseEdit)
   END_PARSE_META_RECORDS

   CError err;
   BOOL fClose = FALSE;
   do
   {
		if (!IsOpen())
		{
			err = Open(METADATA_PERMISSION_READ, m_strMetaRoot);
			BREAK_ON_ERR_FAILURE(err);
			fClose = TRUE;
		}
		DWORD val = 0;
		err = QueryValue(MD_GLOBAL_LOG_IN_UTF_8, val, NULL, SZ_MBN_WEB);
		BREAK_ON_ERR_FAILURE(err);
		MP_V(m_fUTF8Web) = val;
   } while (FALSE);
   if (fClose)
   {
	   Close();
   }
}



HRESULT
CMachineProps::WriteDirtyProps()
{
   CError err;

   BOOL fFlush = MP_D(m_fEnableMetabaseEdit);
   BEGIN_META_WRITE()
      META_WRITE(MD_ROOT_ENABLE_EDIT_WHILE_RUNNING, m_fEnableMetabaseEdit)
   END_META_WRITE(err);
   if (fFlush)
   {
       err = SaveData();
       //RefreshMetabaseSystemChangeNumber();
   }
   do // manually because it is going to services paths
   {
	   BOOL fClose = FALSE;
       if (MP_D(m_fUTF8Web))
       {
           if (!IsOpen())
           {
               err = OpenForWriting();
               BREAK_ON_ERR_FAILURE(err);
			   fClose = TRUE;
           }
           err = SetValue(MD_GLOBAL_LOG_IN_UTF_8, MP_V(m_fUTF8Web), NULL, SZ_MBN_WEB);
           BREAK_ON_ERR_FAILURE(err);
           MP_D(m_fUTF8Web) = FALSE;
           CMetabasePath path(FALSE, m_strMetaRoot, SZ_MBN_WEB);
           err = CheckDescendants(MD_GLOBAL_LOG_IN_UTF_8, &m_auth, path);
           BREAK_ON_ERR_FAILURE(err);
       }
	   if (fClose)
	   {
		   Close();
	   }
   } while (FALSE);

   return err;
}



//
// Compression Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CIISCompressionProps::CIISCompressionProps(
    IN CComAuthInfo * pAuthInfo         OPTIONAL
    )
/*++

Routine Description:

    Constructor for compression properties object

Arguments:

    CComAuthInfo * pAuthInfo   : Auth info.  NULL indicates the local computer

Return Value:

    N/A

--*/
    : CMetaProperties(
        pAuthInfo,
        CMetabasePath(SZ_MBN_WEB, MASTER_INSTANCE, g_cszCompression)
        ),
      //
      // Default properties
      //
      m_fEnableStaticCompression(FALSE),
      m_fEnableDynamicCompression(FALSE),
      m_fLimitDirectorySize(FALSE),
      m_fPathDoesNotExist(FALSE),
      m_dwDirectorySize(0xffffffff),
      m_strDirectory()
{
    //
    // Override base parameters
    //
    m_fInherit = FALSE;
}



/* virtual */
HRESULT
CIISCompressionProps::LoadData()
/*++

Routine Description:

    Fetch all data with or without inheritance, and call the derived
    class to parse the data into fields.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CMetaProperties::LoadData());
    m_fPathDoesNotExist = (err.Win32Error() == ERROR_PATH_NOT_FOUND);

    return err;
}



/* virtual */
void
CIISCompressionProps::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,           m_pbMDData)
      HANDLE_META_RECORD(MD_HC_DO_STATIC_COMPRESSION,  m_fEnableStaticCompression)
      HANDLE_META_RECORD(MD_HC_DO_DYNAMIC_COMPRESSION, m_fEnableDynamicCompression)
      HANDLE_META_RECORD(MD_HC_DO_DISK_SPACE_LIMITING, m_fLimitDirectorySize)
      HANDLE_META_RECORD(MD_HC_MAX_DISK_SPACE_USAGE,   m_dwDirectorySize)
      HANDLE_META_RECORD(MD_HC_COMPRESSION_DIRECTORY,  m_strDirectory)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CIISCompressionProps::WriteDirtyProps()
/*++

Routine Description:

    Write dirty properties

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_HC_DO_STATIC_COMPRESSION,  m_fEnableStaticCompression)
      META_WRITE(MD_HC_DO_DYNAMIC_COMPRESSION, m_fEnableDynamicCompression)
      META_WRITE(MD_HC_DO_DISK_SPACE_LIMITING, m_fLimitDirectorySize)
      META_WRITE(MD_HC_MAX_DISK_SPACE_USAGE,   m_dwDirectorySize)
      META_WRITE(MD_HC_COMPRESSION_DIRECTORY,  m_strDirectory)
    END_META_WRITE(err);

    return err;
}



//
// Mime Types Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMimeTypes::CMimeTypes(
    IN CComAuthInfo * pAuthInfo         OPTIONAL,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Mime types list constructor

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer
    LPCTSTR lpszMDPath       : Metabase path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pAuthInfo,
        lpszMDPath
        /*
        lpszService,
        dwInstance,
        lpszParent,
        dwInstance == MASTER_INSTANCE  && lpszService == NULL
            ? g_cszMimeMap
            : lpszAlias
        */

        //
        // BUGBUG: dwInstance == MASTER_INSTANCE and g_cszMimeMap not used
        ),
      //
      // Default properties
      //
      m_strlMimeTypes()
{
}



CMimeTypes::CMimeTypes(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Mime types list constructor

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pInterface,
        lpszMDPath
        /*
        lpszService,
        dwInstance,
        lpszParent,
        dwInstance == MASTER_INSTANCE && lpszService == NULL
            ? g_cszMimeMap
            : lpszAlias
        */
        //
        // BUGBUG: MASTER_INSTANCE, g_cszMimeMap not used
        //
        ),
      //
      // Default properties
      //
      m_strlMimeTypes()
{
}



void
CMimeTypes::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:


    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_MIME_MAP, m_strlMimeTypes)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CMimeTypes::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_MIME_MAP, m_strlMimeTypes);
    END_META_WRITE(err);

    return err;
}




//
// Server Capabilities
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CServerCapabilities::CServerCapabilities(
    IN CComAuthInfo * pAuthInfo        OPTIONAL,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor for server capabilities object

Arguments:

    CComAuthInfo * pAuthInfo  : Server name.  NULL indicates the local computer
    LPCTSTR lpszMDPath        : e.g. "lm/w3svc/info"

Return Value:

    N/A

--*/
    : CMetaProperties(pAuthInfo, lpszMDPath),
      //
      // Default properties
      //
      m_dwPlatform(),
      m_dwVersionMajor(),
      m_dwVersionMinor(),
      m_dwCapabilities((DWORD)~IIS_CAP1_10_CONNECTION_LIMIT),
      m_dwConfiguration(0L)
{
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = DWORD_METADATA;
}



CServerCapabilities::CServerCapabilities(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor for server capabilities object that uses an existing interface.

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : e.g. "lm/w3svc/info"

Return Value:

    N/A

--*/
    : CMetaProperties(pInterface, lpszMDPath),
      //
      // Default properties
      //
      m_dwPlatform(),
      m_dwVersionMajor(),
      m_dwVersionMinor(),
      m_dwCapabilities((DWORD)~IIS_CAP1_10_CONNECTION_LIMIT),
      m_dwConfiguration(0L)
{
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = DWORD_METADATA;
}



/* virtual */
void
CServerCapabilities::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Only reading UT_SERVER, DWORD_METADATA.
    //
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,           m_pbMDData)
      HANDLE_META_RECORD(MD_SERVER_PLATFORM,           m_dwPlatform)
      HANDLE_META_RECORD(MD_SERVER_VERSION_MAJOR,      m_dwVersionMajor)
      HANDLE_META_RECORD(MD_SERVER_VERSION_MINOR,      m_dwVersionMinor)
      HANDLE_META_RECORD(MD_SERVER_CAPABILITIES,       m_dwCapabilities)
      HANDLE_META_RECORD(MD_SERVER_CONFIGURATION_INFO, m_dwConfiguration)
    END_PARSE_META_RECORDS
}




//
// Instance Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */
LPCTSTR
CInstanceProps::GetDisplayText(
    OUT CString & strName,
    IN  LPCTSTR szComment,
    IN  LPCTSTR szHostHeaderName,
    IN  CIPAddress & ia,
    IN  UINT uPort,
    IN  DWORD dwID
    )
/*++

Routine Description:

    Build display text from instance information

Arguments:

    CString & strName
    LPCTSTR szComment
    LPCTSTR szHostHeaderName
    LPCTSTR szServiceName
    CIPAddress & ia
    UINT uPort
    DWORD dwID

Return Value:

    Pointer to the name buffer.

--*/
{
    //
    // Generate display name
    //
    // First use the comment,
    // if that's not available, use the host header name,
    // if that's not available, use the IP address:port.
    // If that's not available, use the instance number.
    //
    //
    CComBSTR bstrFmt;

    if (szComment && *szComment)
    {
        strName = szComment;
    }
    else if (szHostHeaderName && *szHostHeaderName)
    {
        strName = szHostHeaderName;
    }
    else
    {
        if(!ia.IsZeroValue() && uPort != 0)
        {
            VERIFY(bstrFmt.LoadString(IDS_INSTANCE_PORT_FMT));
            strName.Format(bstrFmt,(LPCTSTR)ia, uPort);
        }
        else
        {
            VERIFY(bstrFmt.LoadString(IDS_INSTANCE_DEF_FMT));
            strName.Format(bstrFmt, dwID);
        }
    }

    return strName;
}



/* static */
void
CInstanceProps::CrackBinding(
    IN  CString strBinding,
    OUT CIPAddress & iaIpAddress,
    OUT UINT & nTCPPort,
    OUT CString & strDomainName
    )
/*++

Routine Description:

    Helper function to crack a binding string

Arguments:

    CString strBinding          : Binding string to be parsed
    CIPAddress & iaIpAddress    : IP Address output
    UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain (host) header name

Return Value:

    None

--*/
{
    //
    // Zero initialize
    //
    iaIpAddress.SetZeroValue();
    nTCPPort = 0;
    strDomainName.Empty();

    int iColonPos = strBinding.Find(_TCHAR(':'));

    if(iColonPos != -1)
    {
        //
        // Get the IP address
        //
        iaIpAddress = strBinding.Left(iColonPos);

        //
        // Look for the second colon
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos  = strBinding.Find(_TCHAR(':'));
    }

    if(iColonPos != -1)
    {
        //
        // Get the port number
        //
        nTCPPort = ::_ttol(strBinding.Left(iColonPos));

        //
        // Look for the NULL termination
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos = strBinding.Find(_TCHAR('\0'));
    }

    if(iColonPos != -1)
    {
        strDomainName = strBinding.Left(iColonPos);
    }
}



/* static */
void
CInstanceProps::CrackSecureBinding(
    IN  CString strBinding,
    OUT CIPAddress & iaIpAddress,
    OUT UINT & nSSLPort
    )
/*++

Routine Description:

    Helper function to crack a secure binding string

Arguments:

    CString strBinding          : Binding string to be parsed
    CIPAddress & iaIpAddress    : IP Address output
    UINT & nSSLPort             : SSL Port

Return Value:

    None

--*/
{
    //
    // Same as regular binding without domain name
    //
    CString strDomainName;

    CrackBinding(strBinding, iaIpAddress, nSSLPort, strDomainName);

    ASSERT(strDomainName.IsEmpty());
}




/* static */
int
CInstanceProps::FindMatchingSecurePort(
    IN  CStringList & strlSecureBindings,
    IN  CIPAddress & iaIPAddress,
    OUT UINT & nSSLPort
    )
/*++

Routine Description:

    Find the SSL port applicable to the given IP Address.

Arguments:

    CStringList & strlSecureBindings : Input stringlist of secure bindings
    CIPAddress & iaIPAddress         : IP Address to target
    UINT & nSSLPort                  : Returns the SSL Port

Return Value:

    The index of the binding string, or -1 if not found.

Notes:

    The SSL port will be set to 0, if the IP address does not exist.

    A 0.0.0.0 ip address translates to "All Unassigned".

--*/
{
    nSSLPort = 0;
	CIPAddress iaEmpty;

    int cItems = 0;
	UINT nPort = 0;
    POSITION pos = strlSecureBindings.GetHeadPosition();
    while(pos)
    {
        CString & strBinding = strlSecureBindings.GetNext(pos);
        CIPAddress ia;
		nPort = 0;

        CrackSecureBinding(strBinding, ia, nPort);

        if (ia == iaIPAddress)
        {
            //
            // Found it!
            //
            nSSLPort = nPort;
            return cItems;
        }

        ++cItems;
    }

	// we didn't find a match
	// check if there is an allassigned one
	cItems = 0;
    pos = strlSecureBindings.GetHeadPosition();
    while(pos)
    {
        CString & strBinding = strlSecureBindings.GetNext(pos);
        CIPAddress ia;
		nPort = 0;

        CrackSecureBinding(strBinding, ia, nPort);

        if (ia == iaEmpty)
        {
            //
            // Found it!
            //
            nSSLPort = nPort;
            return cItems;
        }

        ++cItems;
    }

    //
    // Not found
    //
    return -1;
}



/* static */
BOOL
CInstanceProps::IsPortInUse(
    IN CStringList & strlBindings,
    IN CIPAddress & iaIPAddress,
    IN UINT nPort
    )
/*++

Routine Description:

    Check to see if the give ip address/port combination is in use.

Arguments:

    CStringList & strlBindings    : Input stringlist of bindings
    CIPAddress & iaIpAddress      : IP Address target
    UINT nPort                    : Port

Return Value:

    TRUE if the given ip address/port combo is in use

Notes:

    Host header name is ignored


--*/
{
    POSITION pos = strlBindings.GetHeadPosition();

    while(pos)
    {
        CString & strBinding = strlBindings.GetNext(pos);

        CIPAddress ia;
        UINT n;
        CString str;
        CrackBinding(strBinding, ia, n, str);

        if (ia == iaIPAddress && n == nPort)
        {
            //
            // Found it!
            //
            return TRUE;
        }
    }

    //
    // Not found
    //
    return FALSE;

}



/* static */
void
CInstanceProps::BuildBinding(
    OUT CString & strBinding,
    IN  CIPAddress & iaIpAddress,
    IN  UINT & nTCPPort,
    IN  CString & strDomainName
    )
/*++

Routine Description:

    Build up a binding string from its component parts

Arguments:

    CString & strBinding        : Output binding string
    CIPAddress & iaIpAddress    : ip address (could be 0.0.0.0)
    UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain name (host header)

Return Value:

    None.

--*/
{
    if (!iaIpAddress.IsZeroValue())
    {
        strBinding.Format(
            _T("%s:%d:%s"),
            (LPCTSTR)iaIpAddress,
            nTCPPort,
            (LPCTSTR)strDomainName
            );
    }
    else
    {
        //
        // Leave the ip address field blank
        //
        strBinding.Format(_T(":%d:%s"), nTCPPort, (LPCTSTR)strDomainName);
    }
}



/* static */
void
CInstanceProps::BuildSecureBinding(
    OUT CString & strBinding,
    IN  CIPAddress & iaIpAddress,
    IN  UINT & nSSLPort
    )
/*++

Routine Description:

    Build up a binding string from its component parts

Arguments:

    CString & strBinding        : Output binding string
    CIPAddress & iaIpAddress    : ip address (could be 0.0.0.0)
    UINT & nSSLPort             : SSL Port

Return Value:

    None.

--*/
{
    CString strDomainName;

    BuildBinding(strBinding, iaIpAddress, nSSLPort, strDomainName);
}



CInstanceProps::CInstanceProps(
    IN CComAuthInfo * pAuthInfo     OPTIONAL,
    IN LPCTSTR lpszMDPath,
    IN UINT    nDefPort             OPTIONAL
    )
/*++

Routine Description:

    Constructor for instance properties

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer
    LPCTSTR lpszMDPath       : Metabase path
    UINT    nDefPort         : Default port

Return Value:

    N/A

--*/
    : CMetaProperties(pAuthInfo, lpszMDPath),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress(NULL_IP_ADDRESS),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED)
{
    //
    // Fetch just enough info for the enumeration
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwInstance = CMetabasePath::GetInstanceNumber(lpszMDPath);
}



CInstanceProps::CInstanceProps(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,
    IN UINT    nDefPort                     OPTIONAL
    )
/*++

Routine Description:

    Constructor that uses an existing interface

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    UINT    nDefPort            : Default port

Return Value:

    N/A

--*/
    : CMetaProperties(pInterface, lpszMDPath),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress((DWORD)0),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED)
{
    //
    // Fetch enough for enumeration only
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwInstance = CMetabasePath::GetInstanceNumber(lpszMDPath);
}



CInstanceProps::CInstanceProps(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,      OPTIONAL
    IN DWORD   dwInstance,
    IN UINT    nDefPort         OPTIONAL
    )
/*++

Routine Description:

    Read instance properties off an open parent key

Arguments:

    CMetaKey * pKey      : Open key (parent node)
    LPCTSTR lpszMDPath   : Relative instance path off the open key
    DWORD   dwInstance   : Instance number (0 for master instance)
    UINT    nDefPort     : Default port number

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, lpszMDPath),
      m_dwInstance(dwInstance),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress((DWORD)0),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED)
{
    //
    // Fetch enough for enumeration only
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
}



/* virtual */
void
CInstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_SERVER_BINDINGS, m_strlBindings)
      HANDLE_META_RECORD(MD_SERVER_COMMENT,  m_strComment)
      HANDLE_META_RECORD(MD_SERVER_STATE,    m_dwState)
      HANDLE_META_RECORD(MD_WIN32_ERROR,     m_dwWin32Error);
      HANDLE_META_RECORD(MD_CLUSTER_ENABLED, m_fCluster);
    END_PARSE_META_RECORDS

    //
    // Crack the primary binding
    //
    if (MP_V(m_strlBindings).GetCount() > 0)
    {
        CString & strBinding = MP_V(m_strlBindings).GetHead();
        CrackBinding(strBinding, m_iaIpAddress, m_nTCPPort, m_strDomainName);
    }
}



/* virtual */
HRESULT
CInstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_SERVER_BINDINGS, m_strlBindings)
      META_WRITE(MD_SERVER_COMMENT,  m_strComment)
      META_WRITE(MD_SERVER_STATE,    m_dwState)
    END_META_WRITE(err);

    return err;
}



HRESULT
CInstanceProps::ChangeState(
    IN DWORD dwCommand
    )
/*++

Routine Description:

    Change the state of the instance

Arguments:

    DWORD dwCommand     : Command

Return Value:

    HRESULT

--*/
{
    DWORD  dwTargetState;
    DWORD  dwPendingState;
    CError err;

    switch(dwCommand)
    {
    case MD_SERVER_COMMAND_STOP:
        dwTargetState = MD_SERVER_STATE_STOPPED;
        dwPendingState = MD_SERVER_STATE_STOPPING;
        break;

    case MD_SERVER_COMMAND_START:
        dwTargetState = MD_SERVER_STATE_STARTED;

        dwPendingState = (m_dwState == MD_SERVER_STATE_PAUSED)
            ? MD_SERVER_STATE_CONTINUING
            : MD_SERVER_STATE_STARTING;
        break;

    case MD_SERVER_COMMAND_CONTINUE:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_CONTINUING;
        break;

    case MD_SERVER_COMMAND_PAUSE:
        dwTargetState = MD_SERVER_STATE_PAUSED;
        dwPendingState = MD_SERVER_STATE_PAUSING;
        break;

    default:
        ASSERT_MSG("Invalid service state requested");
        err = ERROR_INVALID_PARAMETER;
    }

    err = OpenForWriting(FALSE);

    if (err.Succeeded())
    {
        SetValue(MD_WIN32_ERROR, m_dwWin32Error = 0);
        err = SetValue(MD_SERVER_COMMAND, dwCommand);
        Close();
    }

    if (err.Succeeded())
    {
        //
        // Wait for the service to attain desired state, timeout
        // after specified interval
        //
        DWORD dwSleepTotal = 0L;
        DWORD dwOldState = m_dwState;

        if (dwOldState == dwTargetState)
        {
            //
            // Current state matches desired
            // state already.  ISM must be behind
            // the times.
            //
            return err;
        }

        while (dwSleepTotal < MAX_SLEEP_INST)
        {
            err = LoadData();

            if (err.Failed())
            {
                break;
            }

            if ((m_dwState != dwPendingState && m_dwState != dwOldState)
              || m_dwWin32Error != ERROR_SUCCESS
               )
            {
                //
                // Done one way or another
                //
                if (m_dwState != dwTargetState)
                {
                    //
                    // Did not achieve desired result. Something went
                    // wrong.
                    //
                    if (m_dwWin32Error)
                    {
                        err = m_dwWin32Error;
                    }
                }

                break;
            }

            //
            // Still pending...
            //
            ::Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }

        if (dwSleepTotal >= MAX_SLEEP_INST)
        {
            //
            // Timed out.  If there is a real error in the metabase
            // use it, otherwise use a generic timeout error
            //
            err = m_dwWin32Error;

            if (err.Succeeded())
            {
                err = ERROR_SERVICE_REQUEST_TIMEOUT;
            }
        }
    }

    return err;
}

/* static */
HRESULT
CInstanceProps::Add(
    CMetaInterface * pInterface,
    LPCTSTR lpszService,
    LPCTSTR lpszHomePath,
    LPCTSTR lpszUserName,
    LPCTSTR lpszPassword,
    LPCTSTR lpszDescription,
    LPCTSTR lpszBinding,
    LPCTSTR lpszSecureBinding,
    DWORD * pdwPermissions,
    DWORD * pdwDirBrowsing,
    DWORD * pwdAuthFlags,
    DWORD * pdwInstance
    )
/*++

Routine Description:

    Create a new instance.  Find a free instance number, and attempt
    to create it. Optionally return the new instance number.

Arguments:

    const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService        : Service name
    LPCTSTR lpszHomePath       : physical path for the new home directory
    LPCTSTR lpszUserName       : User name
    LPCTSTR lpszPassword       : Password
    LPCTSTR lpszDescription    : Optional instance description.
    LPCTSTR lpszBinding        : Binding string
    LPCTSTR lpszSecureBinding  : Secure binding string
    DWORD * pdwPermission      : Permission bits
    DWORD * pdwDirBrowsing     : Directory browsing
    DWORD * pwdAuthFlags       : Authorization flags
    DWORD * pdwInstance        : Buffer to the new instance number

Return Value:

    HRESULT

--*/
{
    CError err;
    DWORD inst = 0;
    DWORD RequestedSiteInst = 0;
    TCHAR bind[MAX_PATH];
    BOOL bRegistryKeyExists =  FALSE;

    // this functionality is keyed off of a registry key
    // if it exists and is set to 1 then use the old way..
    DWORD rc, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr\\Parameters"), &hkey);
    if (err == ERROR_SUCCESS)
    {
        size = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,_T("IncrementalSiteIDCreation"),0,&type,(LPBYTE)&rc,&size))
        {
            if (type == REG_DWORD)
            {
                if (rc == 1)
                {
                    bRegistryKeyExists = TRUE;
                }
            }
        }
        RegCloseKey(hkey);
    }

    if (lpszBinding != NULL)
    {
        int len = lstrlen(lpszBinding);
        if (len < (MAX_PATH - 2))
        {
            StrCpyN(bind, lpszBinding, MAX_PATH - 2);
            bind[len+1] = 0;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (bRegistryKeyExists)
    {
        CMetaKey mk(
            pInterface, 
            CMetabasePath(lpszService),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
            );
        err = mk.QueryResult();

        //
        // Loop through until we find a free instance number.  This
        // is not ideal, but the only way to do this for now.
        //
        CString strPath;
        LPTSTR lp = strPath.GetBuffer(MAX_INSTANCE_LEN);

        for (DWORD dw = FIRST_INSTANCE; dw <= LAST_INSTANCE; ++dw)
        {
            ::_ultot(dw, lp, 10);
            err = mk.DoesPathExist(lp);
            if (err.Failed())
            {
                if (err.Win32Error() != ERROR_PATH_NOT_FOUND)
                {
                    //
                    // Unexpected error
                    //
                    return err;
                }

                strPath.ReleaseBuffer();

                // request to use this instance number
                RequestedSiteInst = dw;
                break;

                // we don't need to do the below
                // behavior since we will just be "requesting"
                // an ID and if the id is already taken
                // it will just give us a random one...
                /*
                err = mk.AddKey(strPath);
                if (err.Succeeded())
                {
                    err = mk.DeleteKey(strPath);
                    if (err.Succeeded())
                    {
                        //
                        // request to use this instance number
                        //
                        RequestedSiteInst = dw;
                        break;
                    }
                }
                */
            }
        }
        mk.Close();

        err = pInterface->CreateSite(lpszService, lpszDescription, bind, lpszHomePath, &inst, &RequestedSiteInst);
    }
    else
    {
        err = pInterface->CreateSite(lpszService, lpszDescription, bind, lpszHomePath, &inst);
    }

    
    if (err.Succeeded())
    {
        CMetaKey mk(pInterface, CMetabasePath(lpszService), METADATA_PERMISSION_WRITE);
        err = mk.QueryResult();
        if (err.Failed())
        {
            ASSERT(FALSE);
            return err;
        }
        if (pdwInstance)
        {
            *pdwInstance = inst;
        }
        CString inst_path, root_path;
        wnsprintf(inst_path.GetBuffer(MAX_PATH), MAX_PATH, _T("%d"), inst);
        inst_path.ReleaseBuffer();
        root_path = inst_path;
        root_path += SZ_MBN_SEP_STR;
        root_path += SZ_MBN_ROOT;
        //
        // The service binding
        //
        //if (err.Succeeded() && lpszBinding)
        //{
        //    CString strBinding(lpszBinding);
        //    CStringListEx strlBindings;
        //    strlBindings.AddTail(strBinding);
        //    err = mk.SetValue(MD_SERVER_BINDINGS, strlBindings,
        //                NULL, inst_path);
        //}
        //
        // The secure binding
        //
        if (err.Succeeded() && lpszSecureBinding && *lpszSecureBinding != 0)
        {
            CString strBinding(lpszSecureBinding);
            CStringListEx strlBindings;
            strlBindings.AddTail(strBinding);
            err = mk.SetValue(MD_SECURE_BINDINGS, strlBindings,
                        NULL, inst_path);
        }
        //
        // Now add the home directory for it
        //
        //if (err.Succeeded())
        //{
        //    CString strHomePath(lpszHomePath);
        //    err = mk.SetValue(MD_VR_PATH,  strHomePath, NULL, root_path);
        //}
        if (err.Succeeded() && pwdAuthFlags)
        {
            err = mk.SetValue(MD_AUTHORIZATION, *pwdAuthFlags, NULL, root_path);
        }
        if (err.Succeeded() && lpszUserName != NULL)
        {
            ASSERT_PTR(lpszPassword);
            CString strUserName(lpszUserName);
            err = mk.SetValue(MD_VR_USERNAME, strUserName, NULL, root_path);
        }
        if (err.Succeeded() && lpszPassword != NULL)
        {
            ASSERT_PTR(lpszUserName);
            CString strPassword(lpszPassword);
            err = mk.SetValue(MD_VR_PASSWORD, strPassword, NULL, root_path);
        }
        if (err.Succeeded() && pdwPermissions != NULL)
        {
            err = mk.SetValue(MD_ACCESS_PERM, *pdwPermissions, NULL, root_path);
        }
        if (err.Succeeded() && pdwDirBrowsing != NULL)
        {
            //
            // WWW only
            //
            err = mk.SetValue(MD_DIRECTORY_BROWSING, *pdwDirBrowsing, NULL, root_path);
        }
    }
    return err;
}



/* static */
HRESULT
CInstanceProps::Delete(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance
    )
/*++

Routine Description:

    Delete the given instance number

Arguments:

    LPCTSTR lpszServer     : Server name
    LPCTSTR lpszService    : Service name (e.g. W3SVC)
    DWORD   dwInstance     : Instance number to be deleted

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface,
        CMetabasePath(lpszService),
        NULL,
        METADATA_PERMISSION_WRITE
        );

    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    CString strPath;
    LPTSTR lp = strPath.GetBuffer(MAX_INSTANCE_LEN);
    ::_ltot(dwInstance, lp, 10);
    strPath.ReleaseBuffer();
    err = mk.DeleteKey(strPath);

    return err;
}



//
// Child node properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Redirect tags
//
const TCHAR   CChildNodeProps::_chTagSep            = _T(',');
const LPCTSTR CChildNodeProps::_cszExactDestination = _T("EXACT_DESTINATION");
const LPCTSTR CChildNodeProps::_cszChildOnly        = _T("CHILD_ONLY");
const LPCTSTR CChildNodeProps::_cszPermanent        = _T("PERMANENT");



CChildNodeProps::CChildNodeProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit,       OPTIONAL
    IN BOOL    fPathOnly       OPTIONAL
    )
/*++

Routine Description:

    Child node properties (Can be file, dir, or vdir)

Arguments:

    CComAuthInfo * pAuthInfo   : Authentication info
    LPCTSTR lpszMDPath         : Metabase path
    BOOL    fInherit           : TRUE to inherit values, FALSE otherwise
    BOOL    fPathOnly          : TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pAuthInfo,
        lpszMDPath
        ),
      m_strRedirectStatement(),
      m_strFullMetaPath(lpszMDPath),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        //
        // Fetch only the homeroot physical path
        //
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
    CMetabasePath::GetLastNodeName(lpszMDPath, m_strAlias);
}



CChildNodeProps::CChildNodeProps(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit,        OPTIONAL
    IN BOOL    fPathOnly        OPTIONAL
    )
/*++

Routine Description:

    Child node properties (Can be file, dir, or vdir)

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    BOOL    fInherit            : TRUE to inherit values, FALSE otherwise
    BOOL    fPathOnly           : TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pInterface,
        lpszMDPath
        ),
      m_strRedirectStatement(),
      m_strFullMetaPath(lpszMDPath),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        //
        // Fetch only the homeroot physical path
        //
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
    CMetabasePath::GetLastNodeName(lpszMDPath, m_strAlias);
}



CChildNodeProps::CChildNodeProps(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,        OPTIONAL
    IN BOOL    fInherit,        OPTIONAL
    IN BOOL    fPathOnly        OPTIONAL
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey    Open key
    LPCTSTR lpszMDPath       Path
    BOOL    fInherit         TRUE to inherit properties
    BOOL    fPathOnly        TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, lpszMDPath),
      m_strRedirectStatement(),
      m_strFullMetaPath(),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        ASSERT(FALSE);
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }
    else
    {
        //
        // Build full metabase path, because we need to compare it
        // against the app root path
        //
        CMetabasePath path(FALSE, pKey->QueryMetaPath(), lpszMDPath);
        m_strFullMetaPath = path.QueryMetaPath();
    }

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
    CMetabasePath::GetLastNodeName(m_strFullMetaPath, m_strAlias);
}



void
CChildNodeProps::ParseRedirectStatement()
/*++

Routine Description:

    Break down the redirect statement into its component parts (path
    plus directives)

Arguments:

    None

Return Value:

    None

--*/
{
    m_fExact     = FALSE;
    m_fChild     = FALSE;
    m_fPermanent = FALSE;

    m_strRedirectPath = m_strRedirectStatement;

    int nComma = m_strRedirectPath.Find(_chTagSep);

    if (nComma >= 0)
    {
        //
        // Check past the separator for these tags
        //
        LPCTSTR lpstr = m_strRedirectPath;
        lpstr += (nComma + 1);

        m_fExact     = _tcsstr(lpstr, _cszExactDestination) != NULL;
        m_fChild     = _tcsstr(lpstr, _cszChildOnly) != NULL;
        m_fPermanent = _tcsstr(lpstr, _cszPermanent) != NULL;
        m_strRedirectPath.ReleaseBuffer(nComma);
    }
}



void
CChildNodeProps::BuildRedirectStatement()
/*++

Routine Description:

    Assemble the redirect statement from its component parts (path
    plus directives)

Arguments:

    None

Return Value:

    None

--*/
{
    CString strStatement = m_strRedirectPath;

    ASSERT(strStatement.Find(_chTagSep) < 0);

    if (m_fExact)
    {
        strStatement += _chTagSep;
        strStatement += _T(' ');
        strStatement += _cszExactDestination;
    }

    if (m_fChild)
    {
        strStatement += _chTagSep;
        strStatement += _T(' ');
        strStatement += _cszChildOnly;
    }

    if (m_fPermanent)
    {
        strStatement += _chTagSep;
        strStatement += _T(' ');
        strStatement += _cszPermanent;
    }

    m_strRedirectStatement = strStatement;
}



/* virtual */
void
CChildNodeProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_INHERITED_META_RECORD(MD_VR_PATH,  m_strPath, m_fPathInherited)
      HANDLE_META_RECORD(MD_HTTP_REDIRECT,      m_strRedirectStatement)
      HANDLE_META_RECORD(MD_WIN32_ERROR,        m_dwWin32Error)
      HANDLE_META_RECORD(MD_ACCESS_PERM,        m_dwAccessPerms)
      HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing)
      HANDLE_META_RECORD(MD_APP_ROOT,           m_strAppRoot)
      HANDLE_META_RECORD(MD_APP_ISOLATED,       m_fAppIsolated)
    END_PARSE_META_RECORDS

    //
    // Check to see if this is an application root
    //
    if (!MP_V(m_strAppRoot).IsEmpty())
    {
        TRACEEOLID("App root: " << m_strAppRoot);

        m_fIsAppRoot = m_strFullMetaPath.CompareNoCase(m_strAppRoot) == 0;
//        m_fIsAppRoot = m_strMetaRoot.CompareNoCase(m_strAppRoot) == 0;
    }

    //
    // Break down redirect statement into component parts
    //
    ParseRedirectStatement();
}



/* virtual */
HRESULT
CChildNodeProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
        META_WRITE(MD_VR_PATH,            m_strPath)
        META_WRITE(MD_ACCESS_PERM,        m_dwAccessPerms)
        META_WRITE(MD_DIRECTORY_BROWSING, m_dwDirBrowsing)
        if (IsRedirected())
        {
            //
            // (Re-)Assemble the redirect statement from its component parts
            //
            BuildRedirectStatement();
            META_WRITE_INHERITANCE(MD_HTTP_REDIRECT, m_strRedirectStatement, m_fInheritRedirect)
        }
        else
        {
            // If m_strRedirectPath is empty, but redir statement is not empty,
            // then redirection was just removed, we should delete it dirty or not
            if (!((CString)m_strRedirectStatement).IsEmpty())
            {
                META_DELETE(MD_HTTP_REDIRECT)
            }
        }
    END_META_WRITE(err);

    return err;
}



/* static */
HRESULT
CChildNodeProps::Add(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR   lpszParentPath,
    IN  LPCTSTR   lpszAlias,
    OUT CString & strAliasCreated,
    IN  DWORD *   pdwPermissions,      OPTIONAL
    IN  DWORD *   pdwDirBrowsing,      OPTIONAL
    IN  LPCTSTR   lpszVrPath,          OPTIONAL
    IN  LPCTSTR   lpszUserName,        OPTIONAL
    IN  LPCTSTR   lpszPassword,        OPTIONAL
    IN  BOOL      fExactName
    )
/*++

Routine Description:

    Create new child node.  Optionally, this will append a number
    to the alias name to ensure uniqueness

Arguments:

    const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszParentPath     : Parent path
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszVrPath         : VrPath property
    LPCTSTR lpszUserName       : User name
    LPCTSTR lpszPassword       : Password
    BOOL    fExactName         : If TRUE, do not change the name
                                 to enforce uniqueness.

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(pInterface);
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        //
        // Hopeless...
        //
        return err;
    }

    BOOL fNewPath;

    do
    {
        fNewPath = FALSE;

        err = mk.Open(
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
            lpszParentPath
            /*
            lpszService,
            dwInstance,
            lpszParentPath
            */
            );

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // This could happen -- creating a virtual
            // server underneath a physical directory
            // which does not exist in the metabase.
            //
            CString strParent, strAlias;
            CMetabasePath::SplitMetaPathAtInstance(lpszParentPath, strParent, strAlias);
            err = mk.Open(
                METADATA_PERMISSION_WRITE,
                strParent
                //lpszParentPath
                //lpszService,
                //dwInstance
                );

            if (err.Failed())
            {
                //
                // This really should never fail, because we're opening
                // the path at the instance.
                //
                ASSERT_MSG("Instance path does not exist");
                break;
            }

            //err = mk.AddKey(lpszParentPath);
            err = mk.AddKey(strAlias);

            fNewPath = err.Succeeded();

            mk.Close();
        }
    }
    while(fNewPath);

    if (err.Failed())
    {
        return err;
    }

    strAliasCreated = lpszAlias;
    DWORD dw = 2;

    FOREVER
    {
        //
        // Append a number if the name is not unique.
        //
        err = mk.DoesPathExist(strAliasCreated);

        if (err.Failed())
        {
            if (err.Win32Error() != ERROR_PATH_NOT_FOUND)
            {
                //
                // Unexpected error
                //
                return err;
            }

            //
            // Ok, now create it
            //
            err = mk.AddKey(strAliasCreated);

            if (err.Succeeded())
            {
                CString strKeyName;
                CString buf, service;
                CMetabasePath::GetServicePath(lpszParentPath, buf);
                CMetabasePath::GetLastNodeName(buf, service);
                if (0 == service.CompareNoCase(SZ_MBN_WEB))
                {
                    strKeyName = IIS_CLASS_WEB_VDIR_W;
                }
                else if (0 == service.CompareNoCase(SZ_MBN_FTP))
                {
                    strKeyName = IIS_CLASS_FTP_VDIR_W;
                }
                else
                {
                    ASSERT_MSG("unrecognized service name");
                }

                err = mk.SetValue(
                    MD_KEY_TYPE,
                    strKeyName,
                    NULL,
                    strAliasCreated
                    );

                if (lpszVrPath != NULL)
                {
                    CString strVrPath(lpszVrPath);
                    err = mk.SetValue(
                        MD_VR_PATH,
                        strVrPath,
                        NULL,
                        strAliasCreated
                        );
                }

                if (lpszUserName != NULL)
                {
                    ASSERT_PTR(lpszPassword);

                    CString strUserName(lpszUserName);
                    err = mk.SetValue(
                        MD_VR_USERNAME,
                        strUserName,
                        NULL,
                        strAliasCreated
                        );
                }

                if (lpszPassword != NULL)
                {
                    ASSERT_PTR(lpszUserName);

                    CString strPassword(lpszPassword);
                    err = mk.SetValue(
                        MD_VR_PASSWORD,
                        strPassword,
                        NULL,
                        strAliasCreated
                        );
                }

                if (pdwPermissions != NULL)
                {
                    err = mk.SetValue(
                        MD_ACCESS_PERM,
                        *pdwPermissions,
                        NULL,
                        strAliasCreated
                        );
                }

                if (pdwDirBrowsing != NULL)
                {
                    //
                    // WWW only
                    //
                    err = mk.SetValue(
                        MD_DIRECTORY_BROWSING,
                        *pdwDirBrowsing,
                        NULL,
                        strAliasCreated
                        );
                }
            }

            return err;
        }

        //
        // Name is not unique, increase the number and try
        // again if permitted to so.  Otherwise return the
        // 'path exists' error.
        //
        if (fExactName)
        {
            err = ERROR_ALREADY_EXISTS;
            return err;
        }

        TCHAR szNumber[32];
        ::_ultot(dw++, szNumber, 10);
        strAliasCreated = lpszAlias;
        strAliasCreated += szNumber;

        //
        // Continue on...
        //
    }
}



/* static */
HRESULT
CChildNodeProps::Delete(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszParentPath,  OPTIONAL
    IN LPCTSTR lpszNode
    )
/*++

Routine Description:

    Delete child node off the given parent path

Arguments:

    const CMetaInterface * pInterface, Existing interface
    LPCTSTR lpszParentPath     : Parent path (could be NULL)
    LPCTSTR lpszNode           : Name of node to be deleted

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface,
        lpszParentPath,
        METADATA_PERMISSION_WRITE
        );
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    err = mk.DeleteKey(lpszNode);

    return err;
}



/* static */
HRESULT
CChildNodeProps::Rename(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszParentPath,      OPTIONAL
    IN LPCTSTR lpszOldName,
    IN LPCTSTR lpszNewName
    )
/*++

Routine Description:

    Rename a child node off the given path

Arguments:

    IN const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszParentPath     : Parent path (could be NULL)
    LPCTSTR lpszOldName        : Old node name
    LPCTSTR lpszNewName        : New node name

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface,
        lpszParentPath,
        METADATA_PERMISSION_WRITE
        );

    CError err(mk.QueryResult());
    if (err.Failed())
    {
        return err;
    }
    err = mk.RenameKey(lpszOldName, lpszNewName);
	mk.Close();

	if (err.Succeeded())
	{
		CString strNewPath;
		strNewPath = lpszParentPath;
		strNewPath += SZ_MBN_SEP_STR;
		strNewPath += lpszNewName;

		CMetaKey mk2(
			pInterface,
			strNewPath,
			METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
			);
		CError err2(mk2.QueryResult());
		if (err2.Succeeded())
		{
			// Check if this node has an AppRoot Setting....
			// if it does, then we have to rename that too.
			// AppRoot : [IF]    (STRING) "/LM/W3SVC/1/ROOT/MyVDir1"
			BOOL fInherit = FALSE;
			CString strAppRootOld;
			err2 = mk2.QueryValue(MD_APP_ROOT, strAppRootOld, &fInherit);
			if (err2.Succeeded())
			{
				// Write out new value
				err2 = mk2.SetValue(MD_APP_ROOT, strNewPath);
			}
			mk2.Close();
		}
	}

    return err;
}


//
// ISM Helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
DetermineIfAdministrator(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR lpszMetabasePath,
    OUT BOOL * pfAdministrator,
    IN OUT DWORD * pdwMetabaseSystemChangeNumber
    )
/*++

Routine Description:

    Attempt to actually resolve whether or not the current user
    has administrator or merely "operator" access.  Until this method
    is called by the derived class, the user is assumed to have
    full administrator access, and may therefore get "access denied"
    errors in inconvenient places.

    The method to determine admin access is rather lame at the moment.
    There's a dummy metabase property that only allows admins to write
    to it, so we try to write to it to see if we're an admin.

Arguments:

    CMetaInterface * pInterface     : Metabase interface
    LPCTSTR lpszMetabasePath        : Metabase path
    BOOL * pfAdministrator          : Returns TRUE/FALSE for administrator
                                      status

Return Value:

    Error return code.

Notes:

    This function used to be used on instance paths.  Now uses simple metabase
    paths.

--*/
{
    ASSERT_WRITE_PTR(pfAdministrator);
    ASSERT_PTR(pInterface);
    ASSERT_PTR(pdwMetabaseSystemChangeNumber);

    if (!pfAdministrator || !pInterface)
    {
        return E_POINTER;
    }

    *pfAdministrator = FALSE;

    //
    // Reuse existing interface we have lying around.
    //
    CMetaKey mk(pInterface);
    CError err(mk.QueryResult());

    if (err.Succeeded())
    {
       CString path(lpszMetabasePath);
       while (FAILED(mk.DoesPathExist(path)))
       {
          // Goto parent
          if (NULL == CMetabasePath::ConvertToParentPath(path))
		  {
			  break;
		  }
       }

       err = mk.Open(
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            path
            );

       if (err.Succeeded())
       {
            //
            // Write some nonsense
            //
            DWORD dwDummy = 0x1234;
            err = mk.SetValue(MD_ISM_ACCESS_CHECK, dwDummy);
            *pdwMetabaseSystemChangeNumber = *pdwMetabaseSystemChangeNumber + 1;

            //
            // And delete it again
            //
            if (err.Succeeded())
            {
                mk.DeleteValue(MD_ISM_ACCESS_CHECK);
                *pdwMetabaseSystemChangeNumber = *pdwMetabaseSystemChangeNumber + 1;
            }
            mk.Close();
        }
    }

    ASSERT(err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED);
    *pfAdministrator = (err.Succeeded());

#ifdef _DEBUG

    if (*pfAdministrator)
    {
        TRACEEOLID("You are a full admin.");
    }
    else
    {
        TRACEEOLID("You're just a lowly operator at best.  Error code is " << err);
    }

#endif // _DEBUG

    if (err.Win32Error() == ERROR_ACCESS_DENIED)
    {
        //
        // Expected result
        //
        err.Reset();
    }

    return err.Win32Error();
}



#if 0

//
// Dll Version Only
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDAPI
DllRegisterServer()
/*++

Routine Description:

    DllRegisterServer - Adds entries to the system registry

Arguments:

    None.

Return Value:

    HRESULT

Notes:

    This entry point doesn't do anything presently.  It's here to function as a
    placeholder, and because we don't want to fail being called by regsvr32.

--*/
{
    return S_OK;
}



STDAPI
DllUnregisterServer()
/*++

Routine Description:

    DllUnregisterServer - Removes entries from the system registry

Arguments:

    None.

Return Value:

    HRESULT

Notes:

    See notes on DllRegisterServer above.

--*/
{
    return S_OK;
}



static AFX_EXTENSION_MODULE extensionDLL = {NULL, NULL};



extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpReserved
    )
/*++

Routine Description:

    DLL Main entry point

Arguments:

    HINSTANCE hInstance : Instance handle
    DWORD dwReason      : DLL_PROCESS_ATTACH, etc
    LPVOID lpReserved   : Reserved value

Return Value:

    1 for succesful initialisation, 0 for failed initialisation

--*/
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        ASSERT(hInstance != NULL);
//        hDLLInstance = hInstance;

        if (!::AfxInitExtensionModule(extensionDLL, hInstance)
         || !InitErrorFunctionality()
         || !InitIntlSettings()
           )
        {
            return 0;
        }

#if defined(_DEBUG) || DBG
        //
        // Force tracing on.
        //
        afxTraceEnabled = TRUE;
#endif // _DEBUG
        break;

    case DLL_PROCESS_DETACH:
        //
        // termination
        //
        TerminateIntlSettings();
        TerminateErrorFunctionality();
        ::AfxTermExtensionModule(extensionDLL);
        break;
    }

    //
    // Succes loading the DLL
    //
    return 1;
}

#endif // IISUI_EXPORTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\ipdomdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipdomdlg.cpp

   Abstract:

        IP and domain security restrictions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "supdlgs.h"
#include "ipdomdlg.h"


//
// Needed for granted/denied icons
//
//#include "..\comprop\resource.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ILIST_DENY      0
#define ILIST_GRANT     1

#define ITYPE_DNS       0
#define ITYPE_IP        1



CIPDomainDlg::CIPDomainDlg(
    IN BOOL & fIpDirty,
    IN BOOL & fDefaultGranted,
    IN BOOL & fOldDefaultGranted,
    IN CObListPlus & oblAccessList,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    IP/Domain access restrictions dialog constructor

Argumentss:

    CWnd * pParent       : Parent window

Return Value:

    N/A

--*/
    : CEmphasizedDialog(CIPDomainDlg::IDD, pParent),
      m_ListBoxRes(
        IDB_ACCESS,
        m_list_IpAddresses.nBitmaps
        ),
      m_oblAccessListGranted(),
      m_oblAccessListDenied(),
	  m_oblReturnList(),
      m_list_IpAddresses(TRUE),
      m_fIpDirty(fIpDirty),
      m_fOldDefaultGranted(fOldDefaultGranted),
      m_fDefaultGranted(fDefaultGranted)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CIPDomainDlg)
    m_nGrantedDenied = 0;
    //}}AFX_DATA_INIT

#endif // 0

    //
    // Keep a temporary copy of these
    //
    m_oblAccessListGranted.SetOwnership(FALSE);
    m_oblAccessListDenied.SetOwnership(FALSE);
	m_oblReturnList.SetOwnership(FALSE);

    CObListIter obli(oblAccessList);
    const CIPAccessDescriptor * pAccess;
    while (NULL != (pAccess = (CIPAccessDescriptor *)obli.Next()))
    {
        if (pAccess->HasAccess())
        {
			m_oblAccessListGranted.AddTail((CObject *)pAccess);
		}
		else
		{
			m_oblAccessListDenied.AddTail((CObject *)pAccess);
		}
	}
    m_list_IpAddresses.AttachResources(&m_ListBoxRes);
    m_nGrantedDenied = m_fDefaultGranted ? DEFAULT_GRANTED : DEFAULT_DENIED;
	m_pCurrentList = m_fDefaultGranted ? &m_oblAccessListDenied : &m_oblAccessListGranted;
}



void 
CIPDomainDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CEmphasizedDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CIPDomainDlg)
    DDX_Control(pDX, IDC_RADIO_GRANTED, m_radio_Granted);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_ICON_GRANTED, m_icon_Granted);
    DDX_Control(pDX, IDC_ICON_DENIED, m_icon_Denied);
    DDX_Radio(pDX, IDC_RADIO_GRANTED, m_nGrantedDenied);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_RADIO_DENIED, m_radio_Denied);
    DDX_Control(pDX, IDC_LIST_IP_ADDRESSES, m_list_IpAddresses);
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CIPDomainDlg, CEmphasizedDialog)
    //{{AFX_MSG_MAP(CIPDomainDlg)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_LBN_DBLCLK(IDC_LIST_IP_ADDRESSES, OnDblclkListIpAddresses)
    ON_LBN_ERRSPACE(IDC_LIST_IP_ADDRESSES, OnErrspaceListIpAddresses)
    ON_BN_CLICKED(IDC_RADIO_GRANTED, OnRadioGranted)
    ON_BN_CLICKED(IDC_RADIO_DENIED, OnRadioDenied)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRESSES, OnSelchangeListIpAddresses)
    ON_WM_VKEYTOITEM()
    //}}AFX_MSG_MAP

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CIPDomainDlg::OnButtonAdd() 
/*++

Routine Description:

    'Add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        m_fIpDirty = TRUE;
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnButtonEdit() 
/*++

Routine Description:

    'Edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        m_fIpDirty = TRUE;
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnButtonRemove() 
/*++

Routine Description:

    'Remove' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = 0;
    int nCurSel = m_list_IpAddresses.GetCurSel();
    while (m_list_IpAddresses.GetNextSelectedItem(&nSel))
    {
		m_pCurrentList->RemoveIndex(nSel);
        m_list_IpAddresses.DeleteString(nSel);
    }

    m_fIpDirty = TRUE;

    if (nCurSel > 0)
    {
        --nCurSel;
    }

    m_list_IpAddresses.SetCurSel(nCurSel);

    if (!SetControlStates())
    {
        m_button_Add.SetFocus();
    }
}



BOOL
CIPDomainDlg::SetControlStates()
/*++

Routine Description:

    Set button states depending on content of the listbox and the controls
    
Arguments:

    None

Return Value:

    TRUE if at least one item is currently selected in the listbox.

--*/
{
    BOOL fSomeSelection = m_list_IpAddresses.GetSelCount() > 0;

    m_button_Edit.EnableWindow(m_list_IpAddresses.GetSelCount() == 1);
    m_button_Remove.EnableWindow(m_list_IpAddresses.GetSelCount() > 0);

    return fSomeSelection;
}



void
CIPDomainDlg::FillListBox(
    IN CIPAccessDescriptor * pSelection OPTIONAL
    )
/*++

Routine Description:

    Fill the ip address listbox from the oblist of access entries

Arguments:

    CIPAccessDescriptor * pSelection : Item to be selected or NULL.

Return Value:

    None

--*/
{
    CObListIter obli(*m_pCurrentList);
    const CIPAccessDescriptor * pAccess;

    m_list_IpAddresses.SetRedraw(FALSE);
    m_list_IpAddresses.ResetContent();

    int cItems = 0 ;
    int nSel = LB_ERR, nItem;
    for ( /**/; pAccess = (CIPAccessDescriptor *)obli.Next(); ++cItems)
    {
        //
        // We only list those not adhering to the default
        //
        if (pAccess->HasAccess() != m_fDefaultGranted)
        {
            nItem = m_list_IpAddresses.AddItem(pAccess);
            if (pAccess == pSelection)
            {
                //
                // Found item to be selected
                //
                nSel = nItem;
            }
        }
    }

    m_list_IpAddresses.SetCurSel(nSel);
    m_list_IpAddresses.SetRedraw(TRUE);
}



DWORD
CIPDomainDlg::SortAccessList()
/*++

Routine Description:

    Sorting the access list by grant denied and ip address
    FillListBox() should be called after this because
    the listbox will no longer reflect the true status
    of the list of directories.

Arguments:

    None

Return Value:

    Error Return code

--*/
{
    BeginWaitCursor();
    DWORD dw =  m_pCurrentList->Sort((CObjectPlus::PCOBJPLUS_ORDER_FUNC) 
        &CIPAccessDescriptor::OrderByAddress);
    EndWaitCursor();

    return dw;
}


INT_PTR
CIPDomainDlg::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit. Return the value returned 
    by the dialog

Arguments:

    BOOL fAdd : If TRUE, create new item.  Otherwise, edit existing item

Return Value:

    Dialog return code (IDOK/IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CIPAccessDescriptor * pAccess = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        //
        // Edit existing entry -- there better be only one...
        //
        pAccess = m_list_IpAddresses.GetSelectedItem();
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            //
            // Double click?
            //
            return IDCANCEL;
        }
    }

    CIPAccessDlg dlgAccess(
        m_fDefaultGranted, 
        pAccess, 
        m_pCurrentList, 
        this, 
        TRUE
        );

    INT_PTR nReturn = dlgAccess.DoModal();

    if (nReturn == IDOK)
    {
        CError err;
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            try
            {
                if (fAdd)
                {
                    m_pCurrentList->AddTail(pAccess);
                }

                SortAccessList();
                FillListBox(pAccess);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;    
                e->Delete();
            }
        }

        err.MessageBoxOnFailure(m_hWnd);
    }

    return nReturn;
}



void
CIPDomainDlg::OnDblclkListIpAddresses()
/*++

Routine Description:

    Double click handler for IP listbox

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CIPDomainDlg::OnErrspaceListIpAddresses()
/*++

Routine Description:

    Error -- out of memory error for IP listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CIPDomainDlg::OnSelchangeListIpAddresses()
/*++

Routine Description:

    ip address 'selection change' notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CIPDomainDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CEmphasizedDialog::OnInitDialog();

    m_icon_Granted.SetIcon(::AfxGetApp()->LoadIcon(IDI_GRANTED));
    m_icon_Denied.SetIcon(::AfxGetApp()->LoadIcon(IDI_DENIED));

    m_list_IpAddresses.Initialize();

    FillListBox();
    SetControlStates();
 
    return TRUE;  
}



void 
CIPDomainDlg::OnRadioGranted()
/*++

Routine Description:

    'Granted' radio button handler.

    Granted by default has been selected.  Refill the listbox with 
    items that have been explicitly denied.  Although we can
    only have a deny list or a grant list, we keep both of them 
    around until it comes time to saving the information.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fDefaultGranted)
    {
        m_fDefaultGranted = TRUE;
		m_pCurrentList = &m_oblAccessListDenied;
        FillListBox();
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnRadioDenied()
/*++

Routine Description:

    'Denied' radio button handler.  Same as above, with reverse granted 
    and denied.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fDefaultGranted)
    {
        m_fDefaultGranted = FALSE;
		m_pCurrentList = &m_oblAccessListGranted;
        FillListBox();
        SetControlStates();
    }
}



int 
CIPDomainDlg::OnVKeyToItem(
    IN UINT nKey, 
    IN CListBox * pListBox, 
    IN UINT nIndex
    ) 
/*++

Routine Description:

    Map virtual keys to commands for ip listbox

Arguments:

    UINT nKey           Specifies the virtual-key code of the key 
                        that the user pressed.
    CListBox * pListBox Specifies a pointer to the list box. The 
                        pointer may be temporary and should not be stored for later use.

    UINT nIndex         Specifies the current caret position.

Return Value:

    -2  : No further action necessary
    -1  : Perform default action for the keystroke
    >=0 : Indicates the default action should be performed on the index
          specified.   

--*/
{
    switch(nKey)
    {
    case VK_DELETE:
        OnButtonRemove();
        break;

    case VK_INSERT:
        OnButtonAdd();
        break;

    default:
        //
        // Not completely handled by this function, let
        // windows handle the remaining default action.
        //
        return -1;
    }

    //
    // No further action is neccesary.
    //
    return -2;
}

CObListPlus&
CIPDomainDlg::GetAccessList()
{
	m_oblReturnList.RemoveAll();
	m_oblReturnList.AddTail(&m_oblAccessListGranted);
	m_oblReturnList.AddTail(&m_oblAccessListDenied);
	return m_oblReturnList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\logui.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CLogUI wrapper class
#ifndef _LOGUI_H
#define _LOGUI_H

class CLogUI : public CWnd
{
protected:
    DECLARE_DYNCREATE(CLogUI)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba634603, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    CString GetCaption();
    void SetCaption(LPCTSTR);
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    short GetBorderStyle();
    void SetBorderStyle(short);

// Operations
public:
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
    void ApplyLogSelection();
    void SetComboBox(HWND hComboBox);
    void Terminate();
    void DoClick();
    void SetUserData(LPCTSTR szName, LPCTSTR szPassword);
};
#endif //_LOGUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\machsht.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        machsht.h

   Abstract:

        IIS Machine Property sheet definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


#ifndef __MACHSHT_H__
#define __MACHSHT_H__


#include "shts.h"



#define BEGIN_META_MACHINE_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryMachineResult()))                        \
        {                                                                \
            break;                                                       \
        }

#define FETCH_MACHINE_DATA_FROM_SHEET(value)\
    value = pSheet->GetMachineProperties().value;                        \
    TRACEEOLID(value);

#define END_META_MACHINE_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_MACHINE_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_MACHINE_DATA_ON_SHEET(value)\
        pSheet->GetMachineProperties().value = value;

#define STORE_MACHINE_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetMachineProperties().value = value;                   \
        dirty = MP_D(pSheet->GetMachineProperties().value);

#define END_META_MACHINE_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetMachineProperties().WriteDirtyProps();             \
}



class CIISMachineSheet : public CInetPropertySheet
/*++

Class Description:

    IIS Machine Property sheet

Public Interface:

    CFtpSheet     : Constructor

    Initialize    : Initialize config data

--*/
{
public:
    //
    // Constructor
    //
    CIISMachineSheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN CWnd * pParentWnd = NULL,
        IN LPARAM lParam = 0L,
        IN LPARAM lParamParent = 0L,
        IN UINT iSelectPage = 0
        );

    ~CIISMachineSheet();

public:
    HRESULT QueryMachineResult() const;
    CMachineProps & GetMachineProperties() { return *m_ppropMachine; }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

    //{{AFX_MSG(CIISMachineSheet)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CMachineProps * m_ppropMachine;
};



class CIISMachinePage : public CInetPropertyPage
/*++

Class Description:

    Machine properties page

--*/
{
    DECLARE_DYNCREATE(CIISMachinePage)

//
// Construction
//
public:
    CIISMachinePage(CIISMachineSheet * pSheet = NULL);
    ~CIISMachinePage();


//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISMachinePage)
    enum { IDD = IDD_IIS_MACHINE };
    BOOL m_fEnableMetabaseEdit;
    CButton m_EnableMetabaseEdit;
    BOOL m_fUTF8Web;
    CButton m_UTF8Web;
    CButton m_button_FileTypes;
    //}}AFX_DATA
	BOOL m_fUTF8Web_Init;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CIISMachinePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CIISMachinePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckEnableEdit();
    afx_msg void OnCheckUTF8();
    afx_msg void OnButtonFileTypes();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    CStringListEx m_strlMimeTypes;
    CMimeTypes * m_ppropMimeTypes;
};

inline HRESULT CIISMachineSheet::QueryMachineResult() const
{
    return m_ppropMachine ? m_ppropMachine->QueryResult() : E_POINTER;
}

#endif // __MACHSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\machsht.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        machsht.cpp

   Abstract:
        IIS Machine Property sheet classes

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "machsht.h"
#include "mime.h"
#include <iisver.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


//
// CIISMachineSheet class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CIISMachineSheet::CIISMachineSheet(
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMetaPath,
    CWnd * pParentWnd,
    LPARAM lParam,
    LPARAM lParamParent,
    UINT iSelectPage
    )
/*++

Routine Description:

    IIS Machine Property sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pAuthInfo,
        lpszMetaPath,
        pParentWnd,
        lParam,
        lParamParent,
        iSelectPage
        ),
      m_ppropMachine(NULL)
{
}

CIISMachineSheet::~CIISMachineSheet()
{
    FreeConfigurationParameters();
}

/* virtual */ 
HRESULT 
CIISMachineSheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Load base values
    //
    CError err(CInetPropertySheet::LoadConfigurationParameters());

    if (err.Failed())
    {
        return err;
    }

    ASSERT(m_ppropMachine == NULL);
    m_ppropMachine = new CMachineProps(QueryAuthInfo());
    if (!m_ppropMachine)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }
    err = m_ppropMachine->LoadData();
	if (err.Failed())
	{
		return err;
	}

    return err;
}



/* virtual */ 
void 
CIISMachineSheet::FreeConfigurationParameters()
{
    //
    // Free Base values
    //
    CInetPropertySheet::FreeConfigurationParameters();
    ASSERT_PTR(m_ppropMachine);
    SAFE_DELETE(m_ppropMachine);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISMachineSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



IMPLEMENT_DYNCREATE(CIISMachinePage, CInetPropertyPage)

CIISMachinePage::CIISMachinePage(
    CIISMachineSheet * pSheet
    )
    : CInetPropertyPage(CIISMachinePage::IDD, pSheet),
    m_ppropMimeTypes(NULL)
{
}

CIISMachinePage::~CIISMachinePage()
{
}


void
CIISMachinePage::DoDataExchange(
    CDataExchange * pDX
    )
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIISMachinePage)
    DDX_Control(pDX, IDC_ENABLE_MB_EDIT, m_EnableMetabaseEdit);
    DDX_Check(pDX, IDC_ENABLE_MB_EDIT, m_fEnableMetabaseEdit);
    DDX_Control(pDX, IDC_WEBLOG_UTF8, m_UTF8Web);
    DDX_Check(pDX, IDC_WEBLOG_UTF8, m_fUTF8Web);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISMachinePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CIISMachinePage)
    ON_BN_CLICKED(IDC_ENABLE_MB_EDIT, OnCheckEnableEdit)
    ON_BN_CLICKED(IDC_WEBLOG_UTF8, OnCheckUTF8)
    ON_BN_CLICKED(IDC_BUTTON_FILE_TYPES, OnButtonFileTypes)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* virtual */
HRESULT
CIISMachinePage::FetchLoadedValues()
/*++

Routine Description:

    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
   CError err;

   BEGIN_META_MACHINE_READ(CIISMachineSheet)
      FETCH_MACHINE_DATA_FROM_SHEET(m_fEnableMetabaseEdit)
      FETCH_MACHINE_DATA_FROM_SHEET(m_fUTF8Web)
   END_META_MACHINE_READ(err);

   m_fUTF8Web_Init = m_fUTF8Web;
   CMetabasePath mime_path(FALSE, QueryMetaPath(), SZ_MBN_MIMEMAP);

   m_ppropMimeTypes = new CMimeTypes(
        QueryAuthInfo(),
		mime_path
        );
   if (m_ppropMimeTypes)
   {
       err = m_ppropMimeTypes->LoadData();
       if (err.Succeeded())
       {
           m_strlMimeTypes = m_ppropMimeTypes->m_strlMimeTypes;
       }
   }
   else
   {
       err = ERROR_NOT_ENOUGH_MEMORY;
   }

   return err;
}



/* virtual */
HRESULT
CIISMachinePage::SaveInfo()
/*++

Routine Description:
    Save the information on this property page.

--*/
{
   ASSERT(IsDirty());

   CError err;
   BeginWaitCursor();

   BEGIN_META_MACHINE_WRITE(CIISMachineSheet)
      STORE_MACHINE_DATA_ON_SHEET(m_fEnableMetabaseEdit)
      STORE_MACHINE_DATA_ON_SHEET(m_fUTF8Web)
   END_META_MACHINE_WRITE(err);

   if (m_fUTF8Web_Init != m_fUTF8Web)
   {
	   GetSheet()->SetRestartRequired(TRUE, PROP_CHANGE_NO_UPDATE);
	   m_fUTF8Web_Init = m_fUTF8Web;
   }
   if (err.Succeeded() && m_ppropMimeTypes)
   {
       m_ppropMimeTypes->m_strlMimeTypes = m_strlMimeTypes;
       err = m_ppropMimeTypes->WriteDirtyProps();
   }
   EndWaitCursor();

   return err;
}

BOOL
CIISMachinePage::OnInitDialog()
{
    CInetPropertyPage::OnInitDialog();
    CError err;
    CIISMBNode * pMachine = (CIISMBNode *)GetSheet()->GetParameter();
    ASSERT(pMachine != NULL);
    if (pMachine)
    {
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,pMachine,TRUE);
        if (err.Succeeded())
        {
            if (  GetSheet()->QueryMajorVersion() < VER_IISMAJORVERSION
            || GetSheet()->QueryMinorVersion() < VER_IISMINORVERSION
            )
            {
            m_EnableMetabaseEdit.EnableWindow(FALSE);
            m_UTF8Web.EnableWindow(FALSE);
            }
            else
            {
                BOOL bWeb = FALSE;
                IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)pMachine->GetConsoleNameSpace();
                if (!pMachine->IsExpanded())
                {
                    err = pConsoleNameSpace->Expand(pMachine->QueryScopeItem());
                }
                HSCOPEITEM child = NULL;
                MMC_COOKIE cookie = 0;
                err = pConsoleNameSpace->GetChildItem(pMachine->QueryScopeItem(), (MMC_COOKIE *) &child, &cookie);
	            while (err.Succeeded())
	            {
                    CIISService * pService = (CIISService *)cookie;
                    ASSERT(pService != NULL);
	                if (0 == _tcsicmp(pService->GetNodeName(), SZ_MBN_WEB))
			        {
			            bWeb = TRUE;
			        }
                    err = pConsoleNameSpace->GetNextItem(child, &child, (MMC_COOKIE *) &cookie);
                }
                m_UTF8Web.EnableWindow(bWeb);
            }
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}

void
CIISMachinePage::OnCheckEnableEdit()
{
    SetModified(TRUE);
}

void
CIISMachinePage::OnCheckUTF8()
{
    SetModified(TRUE);
}

void
CIISMachinePage::OnButtonFileTypes()
/*++

Routine Description:

    'file types' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CMimeDlg dlg(m_strlMimeTypes, this);
    if (dlg.DoModal() == IDOK)
    {
        SetModified(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\metaback.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        metaback.cpp

   Abstract:
        Metabase backup and restore dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "mddefw.h"
#include "metaback.h"
#include "aclpage.h"
#include "savedata.h"
#include "remoteenv.h"
#include "svc.h"
#include "shutdown.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// CBackupsListBox : a listbox of CBackup objects
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Column width relative weights
//
#define WT_LOCATION      8
#define WT_VERSION       2
#define WT_DATE          6



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("MetaBack");

const TCHAR g_szIISAdminService[] = _T("IISADMIN");


IMPLEMENT_DYNAMIC(CBackupsListBox, CHeaderListBox);



const int CBackupsListBox::nBitmaps = 1;


#define HAS_BACKUP_PASSWORD(x) \
    ((x)->QueryMajorVersion() == 5 && (x)->QueryMinorVersion() == 1) || ((x)->QueryMajorVersion() >= 6)

#define HAS_BACKUP_HISTORY(x) \
    ((x)->QueryMajorVersion() >= 6)

CBackupsListBox::CBackupsListBox()
/*++

Routine Description:

    Backups listbox constructor

Arguments:

    None

Return Value:

    N/A

--*/
     : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
}



void
CBackupsListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CBackupFile * p = (CBackupFile *)ds.m_ItemData;
    ASSERT_READ_PTR(p);

    DrawBitmap(ds, 0, 0);

    CString strVersion;
	strVersion.Format(_T("%ld"), p->QueryVersion());

#define MAXLEN (128)

	//
	// Convert date and time to local format
	//
	CTime tm;
	p->GetTime(tm);

	SYSTEMTIME stm =
	{
		(WORD)tm.GetYear(),
		(WORD)tm.GetMonth(),
		(WORD)tm.GetDayOfWeek(),
		(WORD)tm.GetDay(),
		(WORD)tm.GetHour(),
		(WORD)tm.GetMinute(),
		(WORD)tm.GetSecond(),
		0   // Milliseconds
	};

	CString strDate, strTime;
	LPTSTR lp = strDate.GetBuffer(MAXLEN);
	::GetDateFormat(
		LOCALE_USER_DEFAULT,
		DATE_SHORTDATE,
		&stm,
		NULL,
		lp,
		MAXLEN
		);
	strDate.ReleaseBuffer();

	lp = strTime.GetBuffer(MAXLEN);
	GetTimeFormat(LOCALE_USER_DEFAULT, 0L, &stm, NULL, lp, MAXLEN);
	strTime.ReleaseBuffer();

	strDate += _T(" ");
	strDate += strTime;

	if (TRUE == p->m_bIsAutomaticBackupType)
	{
		// Do automatic backup handling...
        // Fix for bug 506444
        strVersion = _T("");
		ColumnText(ds, 0, TRUE, (LPCTSTR) p->m_csAuotmaticBackupText);
		ColumnText(ds, 1, FALSE, strVersion);
		ColumnText(ds, 2, FALSE, strDate);
	}
	else
	{
		ColumnText(ds, 0, TRUE, (LPCTSTR)p->QueryLocation());
		ColumnText(ds, 1, FALSE, strVersion);
		ColumnText(ds, 2, FALSE, strDate);
	}
}

/* virtual */
BOOL
CBackupsListBox::Initialize()
/*++

Routine Description:

    initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE if initialized successfully, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    HINSTANCE hInst = AfxGetResourceHandle();
    InsertColumn(0, WT_LOCATION, IDS_BACKUP_LOCATION, hInst);
    InsertColumn(1, WT_VERSION, IDS_BACKUP_VERSION, hInst);
    InsertColumn(2, WT_DATE, IDS_BACKUP_DATE, hInst);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}



//
// Backup file object properties dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CBkupPropDlg::CBkupPropDlg(
    IN CIISMachine * pMachine,    
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pMachine  : Machine object
    CWnd * pParent          : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CBkupPropDlg::IDD, pParent),
      m_pMachine(pMachine),
      m_strName(),
      m_strPassword()
{
    ASSERT_PTR(m_pMachine);
}



void 
CBkupPropDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CBkupPropDlg)
    DDX_Control(pDX, IDC_EDIT_BACKUP_NAME, m_edit_Name);
    DDX_Control(pDX, IDC_BACKUP_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_BACKUP_PASSWORD_CONFIRM, m_edit_PasswordConfirm);
    DDX_Control(pDX, IDC_USE_PASSWORD, m_button_Password);
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Text(pDX, IDC_EDIT_BACKUP_NAME, m_strName);
    DDV_MinMaxChars(pDX, m_strName, 1, MD_BACKUP_MAX_LEN - 1);
    //}}AFX_DATA_MAP
    CString buf = m_strName;
    buf.TrimLeft();
    buf.TrimRight();
	if (pDX->m_bSaveAndValidate && !PathIsValid(buf,FALSE))
	{
		DDV_ShowBalloonAndFail(pDX, IDS_ERR_BAD_BACKUP_NAME);
	}
    if (m_button_Password.GetCheck())
    {
        //DDX_Text(pDX, IDC_BACKUP_PASSWORD, m_strPassword);
        DDX_Text_SecuredString(pDX, IDC_BACKUP_PASSWORD, m_strPassword);
        //DDV_MinChars(pDX, m_strPassword, MIN_PASSWORD_LENGTH);
        DDV_MinChars_SecuredString(pDX, m_strPassword, MIN_PASSWORD_LENGTH);
        //DDX_Text(pDX, IDC_BACKUP_PASSWORD_CONFIRM, m_strPasswordConfirm);
        DDX_Text_SecuredString(pDX, IDC_BACKUP_PASSWORD_CONFIRM, m_strPasswordConfirm);
        //DDV_MinChars(pDX, m_strPasswordConfirm, MIN_PASSWORD_LENGTH);
        DDV_MinChars_SecuredString(pDX, m_strPasswordConfirm, MIN_PASSWORD_LENGTH);
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CBkupPropDlg, CDialog)
    //{{AFX_MSG_MAP(CBkupPropDlg)
    ON_EN_CHANGE(IDC_EDIT_BACKUP_NAME, OnChangeEditBackupName)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD, OnChangeEditPassword)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD_CONFIRM, OnChangeEditPassword)
    ON_BN_CLICKED(IDC_USE_PASSWORD, OnUsePassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CBkupPropDlg::OnChangeEditBackupName() 
/*++

Routine Description:

    Backup name edit change notification handler.

Arguments:

    None.

Return Value:

    None.

--*/
{
   BOOL bEnableOK = m_edit_Name.GetWindowTextLength() > 0;
   m_button_OK.EnableWindow(bEnableOK);
   if (bEnableOK && m_button_Password.GetCheck())
   {
      m_button_OK.EnableWindow(
         m_edit_Password.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
         && m_edit_PasswordConfirm.GetWindowTextLength() >= MIN_PASSWORD_LENGTH);
   }
}

BOOL 
CBkupPropDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();
    
    m_button_OK.EnableWindow(FALSE);
    m_button_Password.EnableWindow(HAS_BACKUP_PASSWORD(m_pMachine));
    m_button_Password.SetCheck(FALSE);
    m_edit_Password.EnableWindow(FALSE);
    m_edit_PasswordConfirm.EnableWindow(FALSE);
    
    return TRUE;  
}

void 
CBkupPropDlg::OnChangeEditPassword() 
{
    m_button_OK.EnableWindow(
       m_edit_Password.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
       && m_edit_PasswordConfirm.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
       && m_edit_Name.GetWindowTextLength() > 0);
}

void
CBkupPropDlg::OnUsePassword()
{
   BOOL bUseIt = m_button_Password.GetCheck();
   m_edit_Password.EnableWindow(bUseIt);
   m_edit_PasswordConfirm.EnableWindow(bUseIt);
   if (bUseIt)
   {
       OnChangeEditPassword();
   }
   else
   {
      OnChangeEditBackupName();
   }
}

void
CBkupPropDlg::OnOK()
/*++

Routine Description:

    'OK' button handler -- create the backup.

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        if (m_button_Password.GetCheck() && m_strPassword.Compare(m_strPasswordConfirm) != 0)
        {
			EditShowBalloon(m_edit_PasswordConfirm.m_hWnd, IDS_PASSWORD_NO_MATCH);
			return;
        }

        BeginWaitCursor();

        ASSERT_PTR(m_pMachine);

        //
        // CODEWORK: Verify impersonation settings
        //
        CMetaBack mb(m_pMachine->QueryAuthInfo());
        CError err(mb.QueryResult());
        CString buf = m_strName;
        buf.TrimLeft();
        buf.TrimRight();

        if (err.Succeeded())
        {
            if (HAS_BACKUP_PASSWORD(m_pMachine))
            {
                if (m_button_Password.GetCheck())
                {
                    CString csTempPassword;
                    m_strPassword.CopyTo(csTempPassword);
                    err = mb.BackupWithPassword(buf, csTempPassword);
                }
                else
                {
					if (m_pMachine->QueryMajorVersion() == 5 && m_pMachine->QueryMinorVersion() == 1)
					{
						// this was done for iis51 winxp, because otherwise it doesn't work
						err = mb.BackupWithPassword(buf, _T(""));
					}
					else
					{
						// don't call backupwithpassword if there is no password
						err = mb.Backup(buf);
					}
                }
            }
            else
            {
                err = mb.Backup(buf);
            }
        }

        EndWaitCursor();

        if (err.Failed())
        {
            m_edit_Name.SetSel(0, -1);
            //
            // Special error message if IISADMIN just didn't
            // like the name.
            //
            if (err.Win32Error() == ERROR_INVALID_PARAMETER)
            {
				EditShowBalloon(m_edit_Name.m_hWnd, IDS_BACKUP_BAD_NAME);
				m_edit_Name.SetSel(0, -1);
            }
            else
            {
                err.MessageBox(m_hWnd);
            }
          
            //
            // Don't dismiss the dialog
            //
            return;
        }

        EndDialog(IDOK);
    }
}



//
// Metabase/Restore dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CBackupDlg::CBackupDlg(
    IN CIISMachine * pMachine,
	IN LPCTSTR lpszMachineName,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pMachine      : Machine object
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : m_pMachine(pMachine),
      m_list_Backups(),
      m_ListBoxRes(IDB_BACKUPS, m_list_Backups.nBitmaps),
      m_oblBackups(),
      m_oblAutoBackups(),
      m_fChangedMetabase(FALSE),
      m_fServicesRestarted(FALSE),
	  m_csMachineName(lpszMachineName),
      CDialog(CBackupDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CBackupDlg)
    //}}AFX_DATA_INIT

    ASSERT_PTR(m_pMachine);

    m_list_Backups.AttachResources(&m_ListBoxRes);
}



void 
CBackupDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBackupDlg)
    DDX_Control(pDX, IDC_BUTTON_RESTORE, m_button_Restore);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_Delete);
    DDX_Control(pDX, IDOK, m_button_Close);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_BACKUPS, m_list_Backups);
}



void
CBackupDlg::SetControlStates()
/*++

Routine Description:

    Setting control states depending on the state of the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Restore.EnableWindow(m_list_Backups.GetSelCount() == 1);

    BOOL bEnableButton = FALSE;
    // if there is only 1 item selected, then check if it's an automatic backup
    // you are not allowed to delete automatic backups...
    if (m_list_Backups.GetSelCount() > 0)
    {
        CBackupFile * pItem = NULL;
        if (m_list_Backups.GetSelCount() == 1)
        {
            pItem = GetSelectedListItem();
            if (pItem != NULL)
            {
		        if (FALSE == pItem->m_bIsAutomaticBackupType)
                {
                    // check if it's a automatic backup
                    bEnableButton = TRUE;
                }
            }
        }
        else
        {
            // if it's a multi select
            // loop thru and find out if there is at least
            // one item in the list that is deletable..
            int nSel = 0;
            CBackupFile * pItem2 = m_list_Backups.GetNextSelectedItem(&nSel);
	        while (pItem2 != NULL && nSel != LB_ERR)
	        {
		        if (FALSE == pItem2->m_bIsAutomaticBackupType)
		        {
                    bEnableButton = TRUE;
                    break;
            	}
                nSel++;
                pItem2 = m_list_Backups.GetNextSelectedItem(&nSel);
            }
        }
    }
    m_button_Delete.EnableWindow(bEnableButton);

}



HRESULT
CBackupDlg::EnumerateBackups(
    LPCTSTR lpszSelect  OPTIONAL
    )
/*++

Routine Description:

    Enumerate all existing backups, and add them to the listbox

Arguments:

    LPCTSTR lpszSelect      : Optional item to select

Return Value:

    HRESULT

Notes:

    The highest version number of the given name (if any) will
    be selected.

--*/
{
    CWaitCursor wait;

    m_list_Backups.SetRedraw(FALSE);
    m_list_Backups.ResetContent();
    m_oblBackups.RemoveAll();
    m_oblAutoBackups.RemoveAll();

    int nSel = LB_ERR;
    int nItem = 0;

    TCHAR szSearchPath[_MAX_PATH];

    ASSERT_PTR(m_pMachine);

    //
    // CODEWORK: Verify impersonation settings
    //

    // ----------------------------------
	//
	// Enumerate all Normal Backups...
	//
    // ----------------------------------
    CMetaBack mb(m_pMachine->QueryAuthInfo());
    CError err(mb.QueryResult());
    if (err.Succeeded())
    {
        DWORD dwVersion;
        FILETIME ft;
        TCHAR szPath[MAX_PATH + 1] = _T("");

        FOREVER
        {
            *szPath = _T('\0');
            err = mb.Next(&dwVersion, szPath, &ft);

            if (err.Failed())
            {
                break;
            }

            TRACEEOLID(szPath << " v" << dwVersion);

            CBackupFile * pItem = new CBackupFile(szPath, dwVersion, &ft);
            if (!pItem)
            {
                TRACEEOLID("EnumerateBackups: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            m_oblBackups.AddTail(pItem);
        }

        if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
        {
            //
            // Finished enumeration successfully
            //
            err.Reset();
        }

        // Sort the in memory list, before sticking it into the listbox
        m_oblBackups.Sort((CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CBackupFile::OrderByDateTime);

        // Dump it into the list box
        POSITION pos = m_oblBackups.GetHeadPosition();
        CBackupFile * pMyEntry = NULL;
        nItem = 0;
        while(pos)
        {
            pMyEntry = (CBackupFile *) m_oblBackups.GetNext(pos);

            VERIFY(LB_ERR != m_list_Backups.AddItem(pMyEntry));

            if (lpszSelect != NULL && lstrcmpi(lpszSelect, pMyEntry->QueryLocation()) == 0)
            {
                //
                // Remember selection for later
                //
                nSel = nItem;
            }
            ++nItem;
        }
    }


    // ----------------------------------
	//
	// Enumerate all Automatic Backups...
	//
    // ----------------------------------
    if (err.Succeeded())
    {
        if (HAS_BACKUP_HISTORY(m_pMachine))
        {
            // This only applies to metabase version 6 and bigger.
            DWORD dwMajorVersion = 0;
            DWORD dwMinorVersion = 0;
            FILETIME ft;
            TCHAR szPath[MAX_PATH + 1] = _T("");

            // make sure counter starts at zero again.
            mb.Reset();

            FOREVER
            {
                *szPath = _T('\0');
                err = mb.NextHistory(&dwMajorVersion, &dwMinorVersion, szPath, &ft);

                if (err.Failed())
                {
                    // We could be denied access to this machine
                    if (err.Win32Error() == ERROR_ACCESS_DENIED)
                    {
                        if (err.Failed())
                        {
                            err.AddOverride(REGDB_E_CLASSNOTREG, IDS_ERR_NO_BACKUP_RESTORE);
                            m_pMachine->DisplayError(err, m_hWnd);
                        }
                        err.Reset();
                    }
                    break;
                }

                TRACEEOLID(szPath << " V:" << dwMajorVersion << "v:"<< dwMinorVersion);

                CBackupFile * pItem2 = new CBackupFile(szPath, dwMajorVersion, dwMinorVersion, &ft);
                if (!pItem2)
                {
                    TRACEEOLID("EnumerateHistory: OOM");
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                m_oblAutoBackups.AddTail(pItem2);
            }

            if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
            {
                //
                // Finished enumeration successfully
                //
                err.Reset();
            }

            // Sort the in memory list, before sticking it into the listbox
            m_oblAutoBackups.Sort((CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CBackupFile::OrderByDateTime);

            // Dump it into the list box
            POSITION pos = m_oblAutoBackups.GetHeadPosition();
            CBackupFile * pMyEntry = NULL;
            nItem = 0;
            while(pos)
            {
                pMyEntry = (CBackupFile *) m_oblAutoBackups.GetNext(pos);
                VERIFY(LB_ERR != m_list_Backups.AddItem(pMyEntry));
                if (lpszSelect != NULL && lstrcmpi(lpszSelect, pMyEntry->QueryLocation()) == 0)
                {
                    //
                    // Remember selection for later
                    //
                    nSel = nItem;
                }
                ++nItem;
            }
        }
    }

    //
    // Select item requested if any
    //
    m_list_Backups.SetCurSel(nSel);
    m_list_Backups.SetRedraw(TRUE);
    SetControlStates();

    return err;
}


//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CBackupDlg, CDialog)
    //{{AFX_MSG_MAP(CBackupDlg)
    ON_BN_CLICKED(IDC_BUTTON_CREATE, OnButtonCreate)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_BUTTON_RESTORE, OnButtonRestore)
    ON_LBN_DBLCLK(IDC_LIST_BACKUPS, OnDblclkListBackups)
    ON_LBN_SELCHANGE(IDC_LIST_BACKUPS, OnSelchangeListBackups)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CBackupDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler

Arguments:

    None

Return Value:

    TRUE if successfully initialized, FALSE otherwise.

--*/
{
    CDialog::OnInitDialog();

    m_list_Backups.Initialize();

    CError err(EnumerateBackups());

    if (err.Failed())
    {
        err.AddOverride(REGDB_E_CLASSNOTREG, IDS_ERR_NO_BACKUP_RESTORE);
        m_pMachine->DisplayError(err, m_hWnd);
        EndDialog(IDCANCEL);
    }

    return TRUE;
}



void
CBackupDlg::OnButtonCreate()
/*++

Routine Description:

    "Create" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CBkupPropDlg dlg(m_pMachine, this);

    if (dlg.DoModal() == IDOK)
    {
        //
        // We can only return OK if the creation worked
        // which is done in the properties dialog.
        //
        EnumerateBackups(dlg.QueryName());
    }
}



void
CBackupDlg::OnButtonDelete()
/*++

Routine Description:

    "Delete" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (!NoYesMessageBox(IDS_CONFIRM_DELETE_ITEMS))
    {
        //
        // Changed his/her mind
        //
        return;
    }

    m_list_Backups.SetRedraw(FALSE);
    CWaitCursor wait;

    ASSERT_PTR(m_pMachine);

    //
    // CODEWORK: Verify metabase settings
    //
    CMetaBack mb(m_pMachine->QueryAuthInfo());
    CError err(mb.QueryResult());

    if (err.Failed())
    {
        m_pMachine->DisplayError(err, m_hWnd);
        return;
    }

    int nSel = 0;
    CBackupFile * pItem;

    pItem = m_list_Backups.GetNextSelectedItem(&nSel);
	while (pItem != NULL && nSel != LB_ERR)
	{
		if (TRUE == pItem->m_bIsAutomaticBackupType)
		{
            // Don't let them delete Automatic backup types!!!
            //
            // Advance counter to next item (nSel++)
            //
            nSel++;
		}
		else
		{
			TRACEEOLID("Deleting backup " 
				<< pItem->QueryLocation() 
				<< " v" 
				<< pItem->QueryVersion()
				);

			err = mb.Delete(
				pItem->QueryLocation(),
				pItem->QueryVersion()
				);
			if (err.Failed())
			{
				m_pMachine->DisplayError(err, m_hWnd);
				break;
			}

            m_list_Backups.DeleteString(nSel);
            //
            // Don't advance counter to account for shift (nSel++)
            //
		}
        pItem = m_list_Backups.GetNextSelectedItem(&nSel);
	}

    m_list_Backups.SetRedraw(TRUE);
    SetControlStates();

    //
    // Ensure focus is not on a disabled button.
    //
    m_button_Close.SetFocus();
}

void 
CBackupDlg::OnButtonRestore() 
/*++

Routine Description:

    'Restore' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CBackupFile * pItem = GetSelectedListItem();
    ASSERT_READ_PTR(pItem);

    if (pItem != NULL)
    {
        if (NoYesMessageBox(IDS_RESTORE_CONFIRM))
        {
			if (TRUE == pItem->m_bIsAutomaticBackupType)
			{
				ASSERT_PTR(m_pMachine);

				//
				// CODEWORK: Verify impersonation settings
				//
				CMetaBack mb(m_pMachine->QueryAuthInfo());
				CError err(mb.QueryResult());

				if (err.Succeeded())
				{
					CWaitCursor wait;

                    // Set the dwMDFlags to 0 so that it uses the Major/Minor Version.  otherwise
                    // if it's set to 1 then it would grab the latest backup release.
                    err = mb.RestoreHistoryBackup(NULL, pItem->QueryMajorVersion(), pItem->QueryMinorVersion(), 0);
				}

                if (err.Succeeded())
				{
                    // Use our own Messagebox function, so we can pass hWnd.
                    // AfxMessageBox doesn't take hwnd, and will sometimes not work correctly for mb_applmodal
                    // like if the app doesn't have the focus anymore, the messagebox will not be modal to the dialog
                    //::AfxMessageBox(IDS_SUCCESS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION);
                    DoHelpMessageBox(m_hWnd,IDS_SUCCESS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
					m_button_Close.SetFocus();
					m_fChangedMetabase = TRUE;
                    m_fServicesRestarted = FALSE;
				}
				else
				{
				   err.MessageBox(m_hWnd);
				}
			}
			else
			{
				ASSERT_PTR(m_pMachine);

				//
				// CODEWORK: Verify impersonation settings
				//
				CMetaBack mb(m_pMachine->QueryAuthInfo());
				CError err(mb.QueryResult());

				if (err.Succeeded())
				{
					//
					// the WAM stuff takes a while
					//
					CWaitCursor wait;

					//
					// Restore method will take care of WAM save/recover
					//
					if (HAS_BACKUP_PASSWORD(m_pMachine))
					{
						// do this first, then try with blank password...
						err = mb.Restore(pItem->QueryLocation(), pItem->QueryVersion());
                        if (err.Failed())
						{
							err = mb.RestoreWithPassword(pItem->QueryLocation(), pItem->QueryVersion(), _T(""));
							// if this fails it will popup for entering a valid password...
						}
					}
					else
					{
						err = mb.Restore(pItem->QueryLocation(), pItem->QueryVersion());
					}
				}

				if (err.Win32Error() == ERROR_WRONG_PASSWORD)
				{
					CBackupPassword dlg(this);
					if (dlg.DoModal() == IDOK)
					{
					   CWaitCursor wait;
                       CString csTempPassword;
                       dlg.m_password.CopyTo(csTempPassword);
					   err = mb.RestoreWithPassword(pItem->QueryLocation(), pItem->QueryVersion(), csTempPassword);
					   if (err.Win32Error() == ERROR_WRONG_PASSWORD)
					   {
                          DoHelpMessageBox(m_hWnd,IDS_WRONG_PASSWORD, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION, 0);
						  return;
					   }
					   else if (err.Failed())
					   {
                          DoHelpMessageBox(m_hWnd,IDS_ERR_CANNOT_RESTORE, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION, 0);
						  return;
					   }
					   else
					   {
                          // Use our own Messagebox function, so we can pass hWnd.
                          // AfxMessageBox doesn't take hwnd, and will sometimes not work correctly for mb_applmodal
                           // like if the app doesn't have the focus anymore, the messagebox will not be modal to the dialog
                          //::AfxMessageBox(IDS_SUCCESS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION);
                          DoHelpMessageBox(m_hWnd,IDS_SUCCESS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
						  m_button_Close.SetFocus();
						  m_fChangedMetabase = TRUE;
                          m_fServicesRestarted = FALSE;
					   }
					}
					else
					{
					   return;
					}
				}
				else if (err.Succeeded())
				{
                    // Use our own Messagebox function, so we can pass hWnd.
                    // AfxMessageBox doesn't take hwnd, and will sometimes not work correctly for mb_applmodal
                    // like if the app doesn't have the focus anymore, the messagebox will not be modal to the dialog
                    //::AfxMessageBox(IDS_SUCCESS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION);
                    DoHelpMessageBox(m_hWnd,IDS_SUCCESS, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
					m_button_Close.SetFocus();
					m_fChangedMetabase = TRUE;
                    m_fServicesRestarted = FALSE;
				}
				else
				{
				   err.MessageBox(m_hWnd);
				}
			}

            // Refresh the list -- since Automatic Backup does some funky stuff
            EnumerateBackups();
        }
    }
}



void
CBackupDlg::OnDblclkListBackups()
/*++

Routine Description:

    Backup list "double click" notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Nothing presents itself as an obvious action here
    //
}



void
CBackupDlg::OnSelchangeListBackups()
/*++

Routine Description:

    Backup list "selection change" notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}


CBackupPassword::CBackupPassword(CWnd * pParent) :
   CDialog(CBackupPassword::IDD, pParent)
{
}


BEGIN_MESSAGE_MAP(CBackupPassword, CDialog)
    //{{AFX_MSG_MAP(CBackupPassword)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD, OnChangedPassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void 
CBackupPassword::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CBackupPassword)
    DDX_Control(pDX, IDC_BACKUP_PASSWORD, m_edit);
    DDX_Control(pDX, IDOK, m_button_OK);
    //DDX_Text(pDX, IDC_BACKUP_PASSWORD, m_password);
    DDX_Text_SecuredString(pDX, IDC_BACKUP_PASSWORD, m_password);
    //}}AFX_DATA_MAP
}

BOOL 
CBackupPassword::OnInitDialog() 
{
    CDialog::OnInitDialog();
   
    m_button_OK.EnableWindow(FALSE);
//    ::SetFocus(GetDlgItem(IDC_BACKUP_PASSWORD)->m_hWnd);
    
    return FALSE;  
}

void 
CBackupPassword::OnChangedPassword() 
{
    m_button_OK.EnableWindow(
       m_edit.GetWindowTextLength() > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\mmmdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mmmdlg.cpp

   Abstract:

        Multi-multi-multi dialog editor

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetmgrapp.h"
#include "mmmdlg.h"
#include "inetprop.h"
#include "w3sht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Registry key name for this dialog
//
const TCHAR g_szRegKeyIP[] = _T("MMMIpBindings");
const TCHAR g_szRegKeySSL[] = _T("MMMSSLBindings");

//
// IP Bindings Listbox Column Definitions
//
static const ODL_COLUMN_DEF g_aIPColumns[] =
{
// ===============================================
// Weight   Label
// ===============================================
    {  6,   IDS_MMM_IP_ADDRESS,         },
    {  3,   IDS_MMM_TCP_PORT,           },
    { 10,   IDS_MMM_DOMAIN_NAME,        },
};

//
// SSL Bindings Listbox Column Definitions
//
static const ODL_COLUMN_DEF g_aSSLColumns[] =
{
// ===============================================
// Weight   Label
// ===============================================
    {  2,   IDS_MMM_IP_ADDRESS,         },
    {  1,   IDS_MMM_SSL_PORT,           },
};

#define NUM_COLUMNS(cols) (sizeof(cols) / sizeof(cols[0]))

IMPLEMENT_DYNAMIC(CMMMListBox, CRMCListBox);

//
// Bitmap indices
//
enum
{
    BMPID_BINDING,

    //
    // Don't move this one
    //
    BMPID_TOTAL
};


const int CMMMListBox::nBitmaps = BMPID_TOTAL;


CMMMListBox::CMMMListBox(
    IN LPCTSTR lpszRegKey,
    IN int cColumns,
    IN const ODL_COLUMN_DEF * pColumns
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : CHeaderListBox(HLS_STRETCH, lpszRegKey),
      m_cColumns(cColumns),
      m_pColumns(pColumns)
{
    VERIFY(m_strDefaultIP.LoadString(IDS_DEFAULT));
    VERIFY(m_strNoPort.LoadString(IDS_MMM_NA));
}



void
CMMMListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds : Draw item structure

Return Value:

    None

--*/
{
    CString & strBinding = *(CString *)ds.m_ItemData;

    TRACEEOLID(strBinding);

    UINT nPort;
    LPCTSTR lp;
    CString strHostHeader;
    CString strPort;
    CString strIP;
    CIPAddress iaIpAddress;

    CInstanceProps::CrackBinding(
        strBinding, 
        iaIpAddress, 
        nPort, 
        strHostHeader
        );

    //
    // Display Granted/Denied with appropriate bitmap
    //
    DrawBitmap(ds, 0, BMPID_BINDING);

    if (iaIpAddress.IsZeroValue())
    {
        lp = m_strDefaultIP;
    }
    else
    {
        lp = iaIpAddress.QueryIPAddress(strIP);
    }

    ColumnText(ds, 0, TRUE, lp);

    if (nPort > 0)
    {
        strPort.Format(_T("%u"), nPort);
        lp = strPort;
    }
    else
    {
        lp = m_strNoPort;
    }

    ColumnText(ds, 1, FALSE, lp);
    ColumnText(ds, 2, FALSE, strHostHeader);
}



/* virtual */
BOOL
CMMMListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    HINSTANCE hInst = AfxGetResourceHandle();
    for (int nCol = 0; nCol < m_cColumns; ++nCol)
    {
        InsertColumn(nCol, m_pColumns[nCol].nWeight, m_pColumns[nCol].nLabelID, hInst);
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}



void AFXAPI
DDXV_UINT(
    IN CDataExchange * pDX,
    IN UINT nID,
    IN OUT UINT & uValue,
    IN UINT uMin,
    IN UINT uMax,
    IN UINT nEmptyErrorMsg  OPTIONAL
    )
/*++

Routine Description:

    DDX/DDV Function that uses a space to denote a 0 value

Arguments:

    CDataExchange * pDX     : Data exchange object
    UINT nID                : Resource ID
    OUT UINT & uValue       : Value
    UINT uMin               : Minimum value
    UINT uMax               : Maximum value
    UINT nEmptyErrorMsg     : Error message ID for empty unit, or 0 if empty OK

Return Value:

    None.

--*/
{
    ASSERT(uMin <= uMax);

    CWnd * pWnd = CWnd::FromHandle(pDX->PrepareEditCtrl(nID));
    ASSERT(pWnd != NULL);

    if (pDX->m_bSaveAndValidate)
    {
        if (pWnd->GetWindowTextLength() > 0)
        {
			// This Needs to come before DDX_Text which will try to put text big number into small number
			DDV_MinMaxBalloon(pDX, nID, uMin, uMax);
            DDX_TextBalloon(pDX, nID, uValue);
        }
        else
        {
            uValue = 0;
            if (nEmptyErrorMsg)
            {
                DDV_ShowBalloonAndFail(pDX, nEmptyErrorMsg);
            }
        }
    }
    else
    {
        if (uValue != 0)
        {
            DDX_TextBalloon(pDX, nID, uValue);
        }    
        else
        {
            pWnd->SetWindowText(_T(""));
        }
    }
}



BOOL
IsBindingUnique(
    IN CString & strBinding,
    IN CStringList & strlBindings,
    IN int iCurrent                 OPTIONAL
    )
/*++

Routine Description:

    Helper function to determine if a binding is unique.

Arguments:

    CString & strBinding            : Binding string
    CStringList & strlBindings      : List of bindings
    int iCurrent                    : Index of "current" item.  
                                      Not used for uniqueness checking.

Return Value:

    TRUE if the binding is unique, FALSE otherwise.

--*/
{
    int iItem = 0;
        
    for(POSITION pos = strlBindings.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlBindings.GetNext(pos);
        if (iItem != iCurrent && &str != &strBinding && str == strBinding)
        {
            //
            // Not unique!
            //
            return FALSE;
        }

        ++iItem;
    }

    //
    // Unique
    //
    return TRUE;
}


//
// Multi-multi-multi editing dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMMMEditDlg::CMMMEditDlg(
    IN CString & strServerName,
    IN CStringList & strlBindings,
    IN CStringList & strlOtherBindings,
    IN OUT CString & entry,
    IN BOOL fIPBinding,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName          : Server name
    CStringList & strlBindings       : bindings
    CStringList & strlOtherBindings  : "other" bindings list
    CString & entry                  : Entry being edited
    BOOL fIPBinding                  : TRUE for IP, FALSE for SSL
    CWnd * pParent                   : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CMMMEditDlg::IDD, pParent),
      m_strServerName(strServerName),
      m_strlBindings(strlBindings),
      m_strlOtherBindings(strlOtherBindings),
      m_entry(entry),
      m_fIPBinding(fIPBinding),
      m_nIpAddressSel(-1),
	  m_nHelpContext(CMMMEditDlg::IDD + 0x20000)
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CMMMEditDlg)
    m_nIpAddressSel = -1;
    //}}AFX_DATA_INIT

#endif // 0

    CInstanceProps::CrackBinding(
        m_entry, 
        m_iaIpAddress, 
        m_nPort, 
        m_strDomainName
        );
}

void 
CMMMEditDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMMMEditDlg)
    DDX_Text(pDX, IDC_EDIT_DOMAIN_NAME, m_strDomainName);
    DDV_MaxCharsBalloon(pDX, m_strDomainName, MAX_PATH);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
    DDX_Control(pDX, IDC_STATIC_PORT, m_static_Port);
    //}}AFX_DATA_MAP

    DDXV_UINT(pDX, IDC_EDIT_PORT, m_nPort, 1, 65535, IDS_NO_PORT);

    DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
            m_combo_IpAddresses, m_oblIpAddresses, m_iaIpAddress))
    {
        pDX->Fail();
    }

    // Currently IIS support in domain names only A-Z,a-z,0-9,.-
    if (pDX->m_bSaveAndValidate)
    {
        LPCTSTR p = m_strDomainName;
        while (p != NULL && *p != 0)
        {
            TCHAR c = towupper(*p);
            if (    (c >= _T('A') && c <= _T('Z')) 
                ||  (c >= _T('0') && c <= _T('9'))
                ||  (c == _T('.') || c == _T('-'))
                )
            {
                p++;
                continue;
            }
            else
            {
                pDX->PrepareEditCtrl(IDC_EDIT_DOMAIN_NAME);
                DDV_ShowBalloonAndFail(pDX, IDS_WARNING_DOMAIN_NAME);
            }
        }

		// Check if the host header is valid
		if (!m_strDomainName.IsEmpty())
		{
			if (FAILED(IsValidHostHeader(m_strDomainName)))
			{
                pDX->PrepareEditCtrl(IDC_EDIT_DOMAIN_NAME);
                if (FAILED(IsAllNumHostHeader(m_strDomainName)))
                {
                    DDV_ShowBalloonAndFail(pDX, IDS_ERR_DOMAIN_NAME_INVALID);
                }
                else
                {
                    // it's all numeric, show error msg, saying that it is now
                    // an invalid entry (in iis5,iis51) it used to be valid.
                    DDV_ShowBalloonAndFail(pDX, IDS_ERR_DOMAIN_NAME_ALL_NUMERIC);
                }
			}
		}
    }
}

void 
CMMMEditDlg::OnHelp()
{
    WinHelpDebug(m_nHelpContext);
    WinHelp(m_nHelpContext);
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CMMMEditDlg, CDialog)
    //{{AFX_MSG_MAP(CMMMEditDlg)
	ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CMMMEditDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();

    //
    // Configure dialog for either SSL or IP binding editing
    //
    CString str;
    VERIFY(str.LoadString(m_fIPBinding 
        ? IDS_EDIT_MMM_TITLE
        : IDS_EDIT_SSL_MMM_TITLE));
    SetWindowText(str);

    VERIFY(str.LoadString(m_fIPBinding 
        ? IDS_TCP_PORT
        : IDS_SSL_PORT));
    m_static_Port.SetWindowText(str);

    ActivateControl(*GetDlgItem(IDC_STATIC_HEADER_NAME), m_fIPBinding);
    ActivateControl(*GetDlgItem(IDC_EDIT_DOMAIN_NAME),   m_fIPBinding);
#if 0
    CHARFORMAT cf;
    ZeroMemory(&cf, sizeof(cf));
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_FACE;
    cf.bPitchAndFamily = FIXED_PITCH | FF_DONTCARE;
    lstrcpyn((LPTSTR)cf.szFaceName, _T("Courier"), LF_FACESIZE);

    SendDlgItemMessage(IDC_EDIT_DOMAIN_NAME, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
#endif
    DWORD event = (DWORD)SendDlgItemMessage(IDC_EDIT_DOMAIN_NAME, EM_GETEVENTMASK, 0, 0);
    event |= ENM_CHANGE;
    SendDlgItemMessage(IDC_EDIT_DOMAIN_NAME, EM_SETEVENTMASK, 0, (LPARAM)event);

	if (m_fIPBinding)
	{
		m_nHelpContext = (CMMMEditDlg::IDD + 0x20000);
	}
	else
	{
		m_nHelpContext = (CMMMEditDlg::IDD + 0x40000);
	}

    return TRUE;  
}



void 
CMMMEditDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Verify values are acceptable, and change

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    if (m_nPort == 0)
    {
        EditShowBalloon(GetDlgItem(IDC_EDIT_PORT)->m_hWnd, IDS_NO_PORT);
        return;
    }

    CString strOldBinding(m_entry);
    CInstanceProps::BuildBinding(m_entry, m_iaIpAddress, m_nPort, m_strDomainName);

    //
    // Ensure the ip/address doesn't exist in the "other" binding list
    //
    if (CInstanceProps::IsPortInUse(m_strlOtherBindings, m_iaIpAddress, m_nPort))
    {
        //
        // Restore the old binding
        //
        m_entry = strOldBinding;
        EditShowBalloon(GetDlgItem(IDC_EDIT_PORT)->m_hWnd, m_fIPBinding 
            ? IDS_ERR_PORT_IN_USE_SSL : IDS_ERR_PORT_IN_USE_TCP);
        return; 
    }
    
    if (!IsBindingUnique(m_entry, m_strlBindings))
    {
        //
        // Restore the old binding
        //
        m_entry = strOldBinding;
        EditShowBalloon(GetDlgItem(IDC_EDIT_PORT)->m_hWnd, IDS_ERR_BINDING);
        return; 
    }

    CDialog::OnOK();
}

//
// Multi-multi-multi list dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMMMDlg::CMMMDlg(
    IN LPCTSTR lpServerName,
    IN DWORD   dwInstance,
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpMetaPath,
    IN OUT CStringList & strlBindings,
    IN OUT CStringList & strlSecureBindings,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CStringList & strlBindings          : Service bindings
    CStringList & strlSecureBindings    : SSL port bindings
    CWnd * pParent                      : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CMMMDlg::IDD, pParent),
      m_ListBoxRes(
        IDB_BINDINGS,
        CMMMListBox::nBitmaps
        ),
      m_list_Bindings(g_szRegKeyIP, NUM_COLUMNS(g_aIPColumns), g_aIPColumns),
      m_list_SSLBindings(g_szRegKeySSL, NUM_COLUMNS(g_aSSLColumns), g_aSSLColumns),
      m_strlBindings(),
      m_strlSecureBindings(),
      m_strServerName(lpServerName),
      m_strMetaPath(lpMetaPath),
      m_pAuthInfo(pAuthInfo),
      m_fDirty(FALSE),
	  m_nHelpContext(CMMMDlg::IDD + 0x20000)
{
    //{{AFX_DATA_INIT(CMMMDlg)
    //}}AFX_DATA_INIT
    
    m_fCertInstalled = ::IsCertInstalledOnServer(m_pAuthInfo, lpMetaPath),
    m_strlBindings.AddTail(&strlBindings);
    m_strlSecureBindings.AddTail(&strlSecureBindings);
    m_list_Bindings.AttachResources(&m_ListBoxRes);
    m_list_SSLBindings.AttachResources(&m_ListBoxRes);
}


void 
CMMMDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMMMDlg)
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_ADD_SSL, m_button_AddSSL);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_SSL, m_button_RemoveSSL);
    DDX_Control(pDX, IDC_BUTTON_EDIT_SSL, m_button_EditSSL);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_MMM, m_list_Bindings);
    DDX_Control(pDX, IDC_LIST_SSL_MMM, m_list_SSLBindings);
}



BOOL
CMMMDlg::OnItemChanged()
/*++

Routine Description:

    Mark that the dialog as dirty

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    m_fDirty = TRUE;

    return SetControlStates();
}



BOOL
CMMMDlg::SetControlStates()
/*++

Routine Description:

    Set the enabled state of the controls depending on the current
    values in the dialog

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    BOOL fSel = m_list_Bindings.GetSelCount() > 0;

    m_button_Remove.EnableWindow(fSel);
    m_button_Edit.EnableWindow(m_list_Bindings.GetSelCount() == 1);
    m_button_RemoveSSL.EnableWindow(m_list_SSLBindings.GetSelCount() > 0);
    m_button_EditSSL.EnableWindow(m_list_SSLBindings.GetSelCount() == 1);

    m_button_OK.EnableWindow(m_fDirty && m_list_Bindings.GetCount() > 0);

    return fSel;
}

void
CMMMDlg::AddBindings(
    IN CMMMListBox & list, 
    IN CStringList & strlBindings
    )
/*++

Routine Description:

    Add bindings information to the specified listbox

Arguments:

    CMMMListBox & list              : MMM Listbox (SSL or IP)
    CStringList & strlBindings      : SSL or IP bindings

Return Value:

    None

--*/
{
    for (POSITION pos = strlBindings.GetHeadPosition(); pos != NULL; /**/)
    {
        CString & strBinding = strlBindings.GetNext(pos);
        list.AddItem(strBinding);
    }
}

void 
CMMMDlg::OnHelp()
{
    WinHelpDebug(m_nHelpContext);
    WinHelp(m_nHelpContext);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CMMMDlg, CDialog)
    //{{AFX_MSG_MAP(CMMMDlg)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_ADD_SSL, OnButtonAddSsl)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_SSL, OnButtonEditSsl)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_SSL, OnButtonRemoveSsl)
    ON_LBN_DBLCLK(IDC_LIST_MMM, OnDblclkListMmm)
    ON_LBN_DBLCLK(IDC_LIST_SSL_MMM, OnDblclkListSslMmm)
    ON_LBN_SELCHANGE(IDC_LIST_MMM, OnSelchangeListMmm)
    ON_LBN_SELCHANGE(IDC_LIST_SSL_MMM, OnSelchangeListSslMmm)
	ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void 
CMMMDlg::OnButtonAdd() 
/*++

Routine Description:

    Add button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Add entry
    //
    CString strEntry;

    CMMMEditDlg dlg(
        m_strServerName, 
        m_strlBindings,
        m_strlSecureBindings,
        strEntry, 
        TRUE, /* IP binding */
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        POSITION pos = m_strlBindings.AddTail(strEntry);
        int nSel = m_list_Bindings.AddItem(m_strlBindings.GetAt(pos));
        m_list_Bindings.SetCurSel(nSel);
        OnItemChanged();
    }
}

void 
CMMMDlg::OnButtonEdit() 
/*++

Routine Description:

    Edit button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Edit entry
    //
    int nCurSel = m_list_Bindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        CString & strEntry = m_list_Bindings.GetItem(nCurSel);
        CMMMEditDlg dlg(
            m_strServerName, 
            m_strlBindings,
            m_strlSecureBindings,
            strEntry, 
            TRUE, /* IP binding */
            this
            );

        if (dlg.DoModal() == IDOK)
        {
            m_list_Bindings.InvalidateSelection(nCurSel);
            OnItemChanged();
        }
    }
}

void 
CMMMDlg::OnButtonRemove() 
/*++

Routine Description:

    Remove button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Bindings.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_Bindings.GetCount())
    {
        //
        // Remove Selected entry
        //
        if (m_list_Bindings.GetSel(nSel))
        {
            m_strlBindings.RemoveAt(m_strlBindings.FindIndex(nSel));
            m_list_Bindings.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_Bindings.SetCurSel(nCurSel);
        if (!OnItemChanged())
        {
            m_button_Add.SetFocus();
        }
    }
/*
    //
    // Remove Selected entry
    //
    int nCurSel = m_list_Bindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        m_strlBindings.RemoveAt(m_strlBindings.FindIndex(nCurSel));
        m_list_Bindings.DeleteString(nCurSel);
        if (nCurSel >= m_list_Bindings.GetCount())
        {
            --nCurSel;
        }
        m_list_Bindings.SetCurSel(nCurSel);

        if (!OnItemChanged())
        {
            m_button_Add.SetFocus();
        }
    }
*/
}


void 
CMMMDlg::OnDblclkListMmm() 
/*++

Routine Description:

    Double click notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}


void 
CMMMDlg::OnSelchangeListMmm() 
/*++

Routine Description:

    selection change notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CMMMDlg::OnButtonAddSsl() 
/*++

Routine Description:

    'Add SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Add entry
    //
    CString strEntry;

    CMMMEditDlg dlg(
        m_strServerName, 
        m_strlSecureBindings,
        m_strlBindings,
        strEntry, 
        FALSE, /* SSL binding */
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        POSITION pos = m_strlSecureBindings.AddTail(strEntry);
        int nSel = m_list_SSLBindings.AddItem(m_strlSecureBindings.GetAt(pos));
        m_list_SSLBindings.SetCurSel(nSel);
        OnItemChanged();
    }
}



void 
CMMMDlg::OnButtonEditSsl() 
/*++

Routine Description:

    'Edit SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Edit entry
    //
    int nCurSel = m_list_SSLBindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        CString & strEntry = m_list_SSLBindings.GetItem(nCurSel);
        CMMMEditDlg dlg(
            m_strServerName, 
            m_strlSecureBindings,
            m_strlBindings,
            strEntry, 
            FALSE, /* SSL binding */
            this
            );

        if (dlg.DoModal() == IDOK)
        {
            m_list_SSLBindings.InvalidateSelection(nCurSel);
            OnItemChanged();
        }
    }
}



void 
CMMMDlg::OnButtonRemoveSsl() 
/*++

Routine Description:

    'Remove SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_SSLBindings.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_SSLBindings.GetCount())
    {
        //
        // Remove Selected entry
        //
        if (m_list_SSLBindings.GetSel(nSel))
        {
            m_strlSecureBindings.RemoveAt(m_strlSecureBindings.FindIndex(nSel));
            m_list_SSLBindings.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_SSLBindings.SetCurSel(nCurSel);
        OnItemChanged();
        if (m_list_SSLBindings.GetSelCount() == 0)
        {
            //
            // Remove will be disabled
            //
            m_button_AddSSL.SetFocus();
        }
    }

/*
    //
    // Remove Selected entry
    //
    int nCurSel = m_list_SSLBindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        m_strlSecureBindings.RemoveAt(m_strlSecureBindings.FindIndex(nCurSel));
        m_list_SSLBindings.DeleteString(nCurSel);
        if (nCurSel >= m_list_SSLBindings.GetCount())
        {
            --nCurSel;
        }
        m_list_SSLBindings.SetCurSel(nCurSel);

        OnItemChanged();
        if (m_list_SSLBindings.GetCurSel() == LB_ERR)
        {
            //
            // Remove will be disabled
            //
            m_button_AddSSL.SetFocus();
        }
    }
*/
}



void 
CMMMDlg::OnDblclkListSslMmm() 
/*++

Routine Description:

    SSL List 'double click' handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEditSsl();
}



void 
CMMMDlg::OnSelchangeListSslMmm() 
/*++

Routine Description:

    SSL List 'selection change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CMMMDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_list_Bindings.Initialize();
    m_list_SSLBindings.Initialize();

    AddBindings(m_list_Bindings, m_strlBindings);
    AddBindings(m_list_SSLBindings, m_strlSecureBindings);

    //
    // No certificates, no SSL
    //
    GetDlgItem(IDC_GROUP_SSL)->EnableWindow(m_fCertInstalled);
    m_list_SSLBindings.EnableWindow(m_fCertInstalled);
    m_button_AddSSL.EnableWindow(m_fCertInstalled);
    m_button_RemoveSSL.EnableWindow(m_fCertInstalled);
    m_button_EditSSL.EnableWindow(m_fCertInstalled);

    SetControlStates();
    
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\mime.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        mime.cpp

   Abstract:
        Mime mapping dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "resource.h"
#include "mime.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CMimeEditDlg::CMimeEditDlg(
    IN CWnd * pParent OPTIONAL
    )
    : m_strExt(),
      m_strMime(),
      CDialog(CMimeEditDlg::IDD, pParent)
{
}

CMimeEditDlg::CMimeEditDlg(
    IN LPCTSTR lpstrExt,
    IN LPCTSTR lpstrMime,
    IN CWnd * pParent OPTIONAL
    )
    : m_strExt(lpstrExt),
      m_strMime(lpstrMime),
      CDialog(CMimeEditDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMimeEditDlg)
    //}}AFX_DATA_INIT
}

void 
CMimeEditDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CMimeEditDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_MIME, m_edit_Mime);
    DDX_Control(pDX, IDC_EDIT_EXTENT, m_edit_Extent);
	DDX_Text(pDX, IDC_EDIT_MIME, m_strMime);
	DDV_MaxCharsBalloon(pDX, m_strMime, 100);
	DDX_Text(pDX, IDC_EDIT_EXTENT, m_strExt);
	DDV_MaxCharsBalloon(pDX, m_strExt, 100);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMimeEditDlg, CDialog)
    ON_EN_CHANGE(IDC_EDIT_MIME,  OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_EXTENT, OnItemChanged)
END_MESSAGE_MAP()

void 
CMimeEditDlg::SetControlStates()
{
    m_button_Ok.EnableWindow(
        m_edit_Extent.GetWindowTextLength() > 0
     && m_edit_Mime.GetWindowTextLength() > 0
        );
}

void 
CMimeEditDlg::OnItemChanged()
{
    SetControlStates();
}

BOOL 
CMimeEditDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    m_edit_Extent.SetWindowText(m_strExt);
    m_edit_Mime.SetWindowText(m_strMime);

    SetControlStates();
    
    return TRUE;
}

void 
CMimeEditDlg::OnOK()
{
    CDialog::OnOK();
    CleanExtension(m_strExt);
}

CMimeDlg::CMimeDlg(
    IN CStringListEx & strlMimeTypes,
    IN CWnd * pParent               OPTIONAL
    )
/*++

Routine Description:

    Constructor for the MIME listing dialog

Arguments:

    CStringListEx & strlMimeTypes : Listing of mime types to edit
    CWnd * pParent                : Optional parent window or NULL

Return Value:

    N/A

--*/
    : m_fDirty(FALSE),
      m_strlMimeTypes(strlMimeTypes),
      CDialog(CMimeDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMimeDlg)
    //}}AFX_DATA_INIT
}



void
CMimeDlg::DoDataExchange(
    IN OUT CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMimeDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_EXTENSION, m_edit_Extention);
    DDX_Control(pDX, IDC_EDIT_CONTENT_TYPE, m_edit_ContentType);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_MIME, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT_MIME, m_button_Edit);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_MIME_TYPES, m_list_MimeTypes);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CMimeDlg, CDialog)
    //{{AFX_MSG_MAP(CMimeDlg)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_MIME, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_NEW_TYPE, OnButtonNewType)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_MIME, OnButtonRemove)
    ON_LBN_DBLCLK(IDC_LIST_MIME_TYPES, OnDblclkListMimeTypes)
    ON_LBN_SELCHANGE(IDC_LIST_MIME_TYPES, OnSelchangeListMimeTypes)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_CONTENT_TYPE, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_EXTENSION, OnItemChanged)
    ON_COMMAND(ID_HELP, OnHelp)

END_MESSAGE_MAP()



void 
CMimeDlg::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on current dialog data

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Remove.EnableWindow(m_list_MimeTypes.GetSelCount() > 0);
    m_button_Edit.EnableWindow(m_list_MimeTypes.GetSelCount() == 1);
    m_button_Ok.EnableWindow(m_fDirty);
}



BOOL
CMimeDlg::BuildDisplayString(
    IN  CString & strIn,
    OUT CString & strOut
    )
/*++

Routine Description:

    Build a listbox-suitable display string for the mime type

Arguments:

    CString & strIn     : Input string in metabase format
    CString & strOut    : Output string in display format

Return Value:

    TRUE if successfull, FALSE otherwise

--*/
{
    BOOL fSuccess = FALSE;

    int nComma = strIn.Find(_T(','));
    if (nComma >= 0)
    {
        CString strExt = strIn.Left(nComma);
        CString strMime = strIn.Mid(nComma + 1);

        try
        {
            BuildDisplayString(strExt, strMime, strOut);
            ++fSuccess;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Mem exception in BuildDisplayString");
            e->ReportError();
            e->Delete();
        }
    }

    return fSuccess;
}



BOOL
CMimeDlg::CrackDisplayString(
    IN  CString & strIn,
    OUT CString & strExt,
    OUT CString & strMime
    )
/*++

Routine Description:

    Parse a display-formatted mime mapping string, and break into
    component parts

Arguments:

    CString & strIn     : Input string in display format
    CString & strExt    : Output extension string
    CString & strMime   : Output MIME string.


Return Value:

    TRUE if successfull, FALSE otherwise

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        int nTab = strIn.Find(_T('\t'));
        if (nTab >= 0)
        {
            strExt = strIn.Left(nTab);
            strMime = strIn.Mid(nTab + 1);

            ++fSuccess;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Mem exception in CrackDisplayString");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



int
CMimeDlg::FindMimeType(
    IN const CString & strTargetExt
    )
/*++

Routine Description:

    Find a mime type by its extention.  The return value
    is the listbox index where the item may be found, or
    -1 if the item doesn't exist

Arguments:

    const CString & strTargetExt : Target extension we're searching for

Return Value:

    The index of the MIME mapping for this extension if found, or -1
    otherwise.

--*/
{
    CString str;
    CString strExt;
    CString strMime;

    //
    // CODEWORK: Change to binsearch 
    //
    for (int n = 0; n < m_list_MimeTypes.GetCount(); ++n)
    {
        m_list_MimeTypes.GetText(n, str);    
        if (CrackDisplayString(str, strExt, strMime))
        {
            if (!strExt.CompareNoCase(strTargetExt))
            {
                //
                // Found it.
                //
                return n;
            }
        }        
    }

    //
    // Not found
    //
    return -1;
}



void 
CMimeDlg::FillListBox()
/*++

Routine Description:

    Move the mime mappings from the string list to
    the listbox

Arguments:

    None.

Return Value:

    None.

--*/
{
    BeginWaitCursor();

    POSITION pos = m_strlMimeTypes.GetHeadPosition();

    while(pos)
    {
        CString & str = m_strlMimeTypes.GetNext(pos);
        CString strOut;

        if (BuildDisplayString(str, strOut))
        {
            m_list_MimeTypes.AddString(strOut);
        }
    }

    EndWaitCursor();
}



void 
CMimeDlg::FillFromListBox()
/*++

Routine Description:

    Reverse the above; Move the contents of the listbox
    back to the stringlist

Arguments:

    None.

Return Value:

    None.

--*/

{
    CString str;
    CString strExt;
    CString strMime;

    BeginWaitCursor();

    m_strlMimeTypes.RemoveAll();

    for (int n = 0; n < m_list_MimeTypes.GetCount(); ++n)
    {
        m_list_MimeTypes.GetText(n, str);    
        if (CrackDisplayString(str, strExt, strMime))
        {
            BuildMetaString(strExt, strMime, str);
            m_strlMimeTypes.AddTail(str);
        }
    }

    EndWaitCursor();
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CMimeDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    m_list_MimeTypes.Initialize();

    FillListBox();
    SetControlStates(); 
    
	GetDlgItem(IDC_BUTTON_NEW_TYPE)->SetFocus();

    return FALSE;
}



void 
CMimeDlg::OnButtonEdit()
{
    int nCurSel = m_list_MimeTypes.GetCurSel();

    if (nCurSel >= 0)
    {
        CString str;
        CString strExt;
        CString strMime;

        m_list_MimeTypes.GetText(nCurSel, str);

        if (CrackDisplayString(str, strExt, strMime))
        {
            CMimeEditDlg dlg(strExt, strMime, this);

            if (dlg.DoModal() == IDOK)
            {
                strExt = dlg.m_strExt;
                strMime = dlg.m_strMime;

                BuildDisplayString(strExt, strMime, str);
                m_list_MimeTypes.DeleteString(nCurSel);
                nCurSel = m_list_MimeTypes.AddString(str);
                m_list_MimeTypes.SetCurSel(nCurSel);
                m_fDirty = TRUE;

                OnSelchangeListMimeTypes();        
            }
        }
    }
}



void 
CMimeDlg::OnButtonNewType() 
/*++

Routine Description:

    'New' button has been pressed.  Create new MIME mapping, and
    bring up configuration on it.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CMimeEditDlg dlg(this);

    if (dlg.DoModal() == IDOK)
    {
        CString str;
        CString strExt = dlg.m_strExt;
        CString strMime = dlg.m_strMime;

        //
        // Check to see if this extension already existed
        // in the list
        //
        int nOldSel = FindMimeType(strExt);
        if (nOldSel >= 0)
        {
            //
            // Yes, ask to have it replaced
            //
            if (::AfxMessageBox(IDS_REPLACE_MIME, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2
                ) == IDYES)
            {
                //
                // Kill the old one
                //
                m_list_MimeTypes.DeleteString(nOldSel);
            }
            else
            {
                //
                // Nope..
                //
                return;    
            }
        }

        BuildDisplayString(strExt, strMime, str);
        int nCurSel = m_list_MimeTypes.AddString(str);
        m_list_MimeTypes.SetCurSel(nCurSel);
        m_fDirty = TRUE;

        OnSelchangeListMimeTypes();
    }
}

void 
CMimeDlg::OnButtonRemove()
{
    if (::AfxMessageBox(IDS_REMOVE_MIME, 
        MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2
        ) != IDYES)
    {
        //
        // Changed his mind
        //
        return;
    }

    int nCurSel = m_list_MimeTypes.GetCurSel();

    int nSel = 0;
    while (nSel < m_list_MimeTypes.GetCount())
    {
        if (m_list_MimeTypes.GetSel(nSel))
        {
            m_list_MimeTypes.DeleteString(nSel);   
            m_fDirty = TRUE;
            continue;
        }

        ++nSel;
    }

    if (m_fDirty)
    {
        if (nCurSel > 0)
        {
            --nCurSel;
        }
        m_list_MimeTypes.SetCurSel(nCurSel);
        OnSelchangeListMimeTypes();
    }

    if (m_list_MimeTypes.GetCount() == 0)
    {
        GetDlgItem(IDC_BUTTON_NEW_TYPE)->SetFocus();
    }
}

void 
CMimeDlg::OnItemChanged()
{
    SetControlStates();
}

void 
CMimeDlg::OnDblclkListMimeTypes()
{
    OnButtonEdit();
}

void
CMimeDlg::OnSelchangeListMimeTypes() 
{
    //
    // Update the text in the description box
    //
    int nCurSel = m_list_MimeTypes.GetCurSel();
    
    if (nCurSel >= 0)
    {
        CString str;
        CString strExt;
        CString strMime;

        m_list_MimeTypes.GetText(nCurSel, str);

        if (CrackDisplayString(str, strExt, strMime))
        {
            m_edit_Extention.SetWindowText(strExt);
            m_edit_ContentType.SetWindowText(strMime);
        }
    }
    else
    {
        m_edit_Extention.SetWindowText(_T(""));
        m_edit_ContentType.SetWindowText(_T(""));
    }

    SetControlStates();
}

void 
CMimeDlg::OnOK()
{
    if (m_fDirty)
    {
        FillFromListBox();
    }

    CDialog::OnOK();
}

void
CMimeDlg::OnHelp()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\metaback.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        metaback.h

   Abstract:
        Metabase backup and restore dialog definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __METABACK_H__
#define __METABACK_H__


class CBackupFile : public CObjectPlus
/*++

Class Description:

    Backup location object

Public Interface:

    CBackupFile     : Constructor

    QueryVersion    : Get the version number
    QueryLocation   : Get the location name
    GetTime         : Get the time

--*/
{
//
// Constructor
//
public:
    CBackupFile(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion,
        IN FILETIME * pft
        );

    CBackupFile(
        IN LPCTSTR lpszLocation,
        IN DWORD dwMajorVersion,
        IN DWORD dwMinorVersion,
        IN FILETIME * pft
        );

public:
    DWORD QueryVersion() const { return m_dwVersion; }
    DWORD QueryMajorVersion() const { return m_dwMajorVersion; }
    DWORD QueryMinorVersion() const { return m_dwMinorVersion; }
    LPCTSTR QueryLocation() const { return m_strLocation; }
    void GetTime(OUT CTime & tim);

	BOOL m_bIsAutomaticBackupType; // FALSE = manual backup, TRUE = Automatic backup
    CString m_csAuotmaticBackupText;

    //
    // Sorting helper
    //
    int OrderByDateTime(
        IN const CObjectPlus * pobAccess
        ) const;


private:
    DWORD m_dwVersion;
    DWORD m_dwMajorVersion;
    DWORD m_dwMinorVersion;
    CString m_strLocation;
    FILETIME m_ft;
};




class CBackupsListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of CBackupFile objects

Public Interface:

    CBackupsListBox         : Constructor

    GetItem                 : Get backup object at index
    AddItem                 : Add item to listbox
    InsertItem              : Insert item into the listbox
    Initialize              : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CBackupsListBox);

public:
    static const nBitmaps;  // Number of bitmaps

public:
    CBackupsListBox();

public:
    CBackupFile * GetItem(UINT nIndex);
    CBackupFile * GetNextSelectedItem(int * pnStartingIndex);
    int AddItem(CBackupFile * pItem);
    int InsertItem(int nPos, CBackupFile * pItem);
    virtual BOOL Initialize();
    int CALLBACK CompareItems(LPARAM lp1, LPARAM lp2, LPARAM lpSortData);

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);
};



class CBkupPropDlg : public CDialog
/*++

Class Description:

    Backup file properties dialog

Public Interface:

    CBkupPropDlg        : Constructor

    QueryName           : Return the name of the backup file

--*/
{
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CBkupPropDlg(
        IN CIISMachine * pMachine,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    LPCTSTR QueryName() const { return m_strName; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CBkupPropDlg)
    enum { IDD = IDD_BACKUP };
    CEdit   m_edit_Name;
    CButton m_button_OK;
    CStrPassword m_strPassword;
	CEdit   m_edit_Password;
	CStrPassword m_strPasswordConfirm;
	CEdit   m_edit_PasswordConfirm;
	CButton m_button_Password;
    CString m_strName;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CBkupPropDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CBkupPropDlg)
    afx_msg void OnChangeEditBackupName();
    afx_msg void OnChangeEditPassword();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnUsePassword();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CIISMachine * m_pMachine;
};

#define MIN_PASSWORD_LENGTH	1

class CBackupPassword : public CDialog
{
public:
   CBackupPassword(CWnd * pParent);

    //{{AFX_DATA(CBackupPassword)
    enum { IDD = IDD_PASSWORD };
    CEdit m_edit;
    CButton m_button_OK;
    CStrPassword m_password;
    //}}AFX_DATA

    virtual void DoDataExchange(CDataExchange * pDX);

protected:
    //{{AFX_MSG(CBackupPassword)
    afx_msg void OnChangedPassword();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CString m_confirm_password;
};

class CBackupDlg : public CDialog
/*++

Class Description:

    Metabase backup/restore dialog

Public Interface:

    CBackupDlg              : Constructor

    HasChangedMetabase      : TRUE if the metabase was changed

--*/
{
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CBackupDlg(
        IN CIISMachine * pMachine,
		IN LPCTSTR szMachineName,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    BOOL HasChangedMetabase() const { return m_fChangedMetabase; }
    BOOL ServicesWereRestarted() const { return m_fServicesRestarted;}

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CBackupDlg)
    enum { IDD = IDD_METABACKREST };
    CButton m_button_Restore;
    CButton m_button_Delete;
    CButton m_button_Close;
    //}}AFX_DATA

    CBackupsListBox m_list_Backups;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CBackupDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CBackupDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonCreate();
    afx_msg void OnButtonDelete();
    afx_msg void OnButtonRestore();
    afx_msg void OnDblclkListBackups();
    afx_msg void OnSelchangeListBackups();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    HRESULT EnumerateBackups(IN LPCTSTR lpszSelect = NULL);
    CBackupFile * GetSelectedListItem(OUT int * pnSel = NULL);

private:
    BOOL                 m_fChangedMetabase;
    BOOL                 m_fServicesRestarted;
    CIISMachine *        m_pMachine;
    CObListPlus          m_oblBackups;
    CObListPlus          m_oblAutoBackups;
    CRMCListBoxResources m_ListBoxRes;
	CString              m_csMachineName;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBackupFile::CBackupFile(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion,
    IN FILETIME * pft
    )
{
    CopyMemory(&m_ft, pft, sizeof(m_ft));
    m_strLocation = lpszLocation;
    m_bIsAutomaticBackupType = FALSE;
    m_dwVersion = dwVersion;
    m_dwMajorVersion = 0;
    m_dwMinorVersion = 0;
}

inline CBackupFile::CBackupFile(
    IN LPCTSTR lpszLocation,
    IN DWORD dwMajorVersion,
    IN DWORD dwMinorVersion,
    IN FILETIME * pft
    )
{
    CopyMemory(&m_ft, pft, sizeof(m_ft));
    m_strLocation = lpszLocation;
    m_csAuotmaticBackupText.LoadString(IDS_AUTO_HISTORY_RESTORE_NAME);
    m_bIsAutomaticBackupType = TRUE;
    m_dwVersion = 0;
    m_dwMajorVersion = dwMajorVersion;
    m_dwMinorVersion = dwMinorVersion;
}

inline void CBackupFile::GetTime(CTime & tim)
{
    tim = m_ft;
}

inline CBackupFile * CBackupsListBox::GetItem(UINT nIndex)
{
    return (CBackupFile *)GetItemDataPtr(nIndex);
}

inline CBackupFile * CBackupsListBox::GetNextSelectedItem(int * pnStartingIndex)
{
    return (CBackupFile *)CHeaderListBox::GetNextSelectedItem(pnStartingIndex);
}

inline int CBackupsListBox::AddItem(CBackupFile * pItem)
{
    return AddString((LPCTSTR)pItem);
}

inline int CBackupsListBox::InsertItem(int nPos, CBackupFile * pItem)
{
    return InsertString(nPos, (LPCTSTR)pItem);
}

inline CBackupFile * CBackupDlg::GetSelectedListItem(int * pnSel)
{
    return (CBackupFile *)m_list_Backups.GetSelectedListItem(pnSel);
}

inline int CBackupFile::OrderByDateTime(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two ??? against each other, and sort

Arguments:

    const CObjectPlus * pobAccess : This really refers to another
                                    CBackupFile to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    CBackupFile * pob = (CBackupFile *) pobAccess;
	CTime tm1 = m_ft;
    SYSTEMTIME timeDest1;
    FILETIME fileTime1;
    ULARGE_INTEGER uliCurrentTime1;

    CTime tm2;
    SYSTEMTIME timeDest2;
    FILETIME fileTime2;
    ULARGE_INTEGER uliCurrentTime2;
    pob->GetTime(tm2);

    tm1.GetAsSystemTime(timeDest1);
    ::SystemTimeToFileTime(&timeDest1, &fileTime1);
    uliCurrentTime1.LowPart = fileTime1.dwLowDateTime;
    uliCurrentTime1.HighPart = fileTime1.dwHighDateTime;
    
    tm2.GetAsSystemTime(timeDest2);
    ::SystemTimeToFileTime(&timeDest2, &fileTime2);
    uliCurrentTime2.LowPart = fileTime2.dwLowDateTime;
    uliCurrentTime2.HighPart = fileTime2.dwHighDateTime;

    if (uliCurrentTime1.QuadPart > uliCurrentTime2.QuadPart)
    {
        return +1;
    }
    else
    {
        return -1;
    }
}

#endif // __METABACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\mime.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mime.h

   Abstract:

        Mime mapping dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _MIME_H_
#define _MIME_H_



class CMimeEditDlg : public CDialog
/*++

Class Description:

    MIME editor dialog.

Public Interface:

    CMimeEditDlg  : MIME editor dialog constructor

--*/
{
//
// Construction
//
public:
    //
    // Create new  mime mapping constructor
    //
    CMimeEditDlg(
        IN CWnd * pParent = NULL
        );   

    //
    // Constructor to edit existing MIME mapping
    //
    CMimeEditDlg(
        IN LPCTSTR lpstrExt,
        IN LPCTSTR lpstrMime,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
public:
    //{{AFX_DATA(CMimeEditDlg)
    enum { IDD = IDD_MIME_PROPERTY };
    CButton m_button_Ok;
    CEdit   m_edit_Mime;
    CEdit   m_edit_Extent;
    //}}AFX_DATA

    CString m_strMime;
    CString m_strExt;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CMimeEditDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //
    // Enable/disable controls depending on window status
    //
    void SetControlStates();

    //
    // Extentions must start with a dot, add it if it isn't there
    //
    void CleanExtension(
        IN OUT CString & strExtension
        );

    //{{AFX_MSG(CMimeEditDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
};



class CMimeDlg : public CDialog
/*++

Class Description:

    MIME listings dialog

Public Interface:

    CMimeDlg : Constructor for the dialog

--*/
{
//
// Construction
//
public:
    CMimeDlg(
        IN CStringListEx & strlMimeTypes,
        IN CWnd * pParent = NULL
        );  

//
// Dialog Data
//
protected:
    //
    // Build the MIME list from the listbox
    //
    void FillFromListBox();

    //
    // Fill the listbox from the list of MIME types
    //
    void FillListBox();

    //
    // Enable/disable control states depending on dialog data
    //
    void SetControlStates();

    //
    // Build a listbox-suitable display string for the mime type
    //
    void BuildDisplayString(
       IN  CString & strExt,
       IN  CString & strMime,
       OUT CString & strOut
       );

    //
    // As above, but use a metabase internal formatted string for input
    //
    BOOL BuildDisplayString(
        IN  CString & strIn,
        OUT CString & strOut
        );

    //
    // Build a string in the metabase internal format for this mime type
    //
    void BuildMetaString(
       IN  CString & strExt,
       IN  CString & strMime,
       OUT CString & strOut
       );

    //
    // Given the listbox suitable display string, break it in extension
    // and MIME type strings
    //
    BOOL CrackDisplayString(
        IN  CString & strIn,
        OUT CString & strExt,
        OUT CString & strMime
        );

    //
    // Find a MIME entry for the given extension, or return -1 if not found
    //
    int FindMimeType(
        IN const CString & strTargetExt
        );

    //{{AFX_DATA(CMimeDlg)
    enum { IDD = IDD_MIME_TYPES };
    CEdit    m_edit_Extention;
    CEdit    m_edit_ContentType;
    CButton  m_button_Remove;
    CButton  m_button_Edit;
    CButton  m_button_Ok;
    //}}AFX_DATA

    CStringListEx & m_strlMimeTypes;
    CRMCListBox   m_list_MimeTypes;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMimeDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMimeDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonNewType();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListMimeTypes();
    afx_msg void OnSelchangeListMimeTypes();
    afx_msg void OnHelp();
    virtual void OnOK();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()


private:
    BOOL m_fDirty;
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CMimeEditDlg::CleanExtension(
    IN OUT CString & strExtension
    )
{
    if (strExtension[0] != _T('.'))
    {
        strExtension = _T('.') + strExtension;
    }
}

inline void CMimeDlg::BuildDisplayString(
   IN  CString & strExt,
   IN  CString & strMime,
   OUT CString & strOut
   )
{
    strOut.Format(_T("%s\t%s"), (LPCTSTR)strExt, (LPCTSTR)strMime);
}

inline void CMimeDlg::BuildMetaString(
   IN  CString & strExt,
   IN  CString & strMime,
   OUT CString & strOut
   )
{
    strOut.Format(_T("%s,%s"), (LPCTSTR)strExt, (LPCTSTR)strMime);
}


#endif // _MIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\msgbox.cpp ===
#include "stdafx.h"
#include "common.h"
#include "resource.h"

#include "afxpriv.h"
#include "InetMgrApp.h"
#include "msgbox.h"

extern CComModule _Module;
extern CInetmgrApp theApp;

BOOL
WINAPI
UtilHelpCallback(
    IN HWND     hwnd,
    IN PVOID    pVoid
    )
/*++
Routine Description:
    This routine is the called back that is called when a
    message box is displayed with a help button and the user
    clicks on the help button.
Arguments:
    hwnd        - handle to windows that recieved the WM_HELP message.
    pVoid       - pointer to the user data passsed in the call to
                  MessageBoxHelper.  The client can store any value
                  in this paramter.
Return Value:
    TRUE callback was successful, FALSE some error occurred.
--*/
{
    //
    // Get a usable pointer to the help map entry.
    //
    MSG_HLPMAP *pHelpMapEntry = reinterpret_cast<MSG_HLPMAP *>( pVoid );
    if (pHelpMapEntry)
    {
        WinHelpDebug(pHelpMapEntry->uIdMessage);
        ::WinHelp(hwnd,theApp.m_pszHelpFilePath, HELP_CONTEXT, pHelpMapEntry->uIdMessage);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

int DoHelpMessageBox(HWND hWndIn, UINT iResourceID, UINT nType, UINT nIDPrompt)
{
    CString strMsg;
    strMsg.LoadString(iResourceID);
    return DoHelpMessageBox(hWndIn,strMsg,nType,nIDPrompt);
}

int DoHelpMessageBox(HWND hWndIn, LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt)
{
	HWND hWndTop;
    int nResult = 0;
	HWND hWnd = hWndIn;
    if (!hWnd)
    {
        hWnd = CWnd::GetSafeOwner_(NULL, &hWndTop);
    }

	// set help context if possible
	DWORD* pdwContext = NULL;
	HWND hWnd2 = AfxGetMainWnd()->GetSafeHwnd();
	if (hWnd2 != NULL)
	{
		// use app-level context or frame level context
		LRESULT lResult = ::SendMessage(hWnd2, WM_HELPPROMPTADDR, 0, 0); // Use "MainWnd" HWND
		if (lResult != 0)
            {pdwContext = (DWORD*)lResult;}
	}
	DWORD dwOldPromptContext = 0;
	if (pdwContext != NULL)
	{
		// save old prompt context for restoration later
		dwOldPromptContext = *pdwContext;
		if (nIDPrompt != 0)
            {*pdwContext = HID_BASE_PROMPT + nIDPrompt;}
	}

    TCHAR wszTitle[MAX_PATH] ;
    LoadString(_Module.GetResourceInstance(), IDS_APP_NAME, wszTitle, MAX_PATH);

    if (nIDPrompt != 0)
        {nType |= MB_HELP;}

    if (nType & MB_HELP)
    {
        MSG_HLPMAP HelpMapEntry;
        HelpMapEntry.uIdMessage = nIDPrompt;
        nResult = MessageBoxHelper(hWnd, lpszPrompt, wszTitle, nType | MB_TASKMODAL, UtilHelpCallback, &HelpMapEntry);
    }
    else
    {
        nResult = ::MessageBox(hWnd, lpszPrompt, wszTitle, nType | MB_TASKMODAL);
    }

	// restore prompt context if possible
    if (pdwContext != NULL)
        {*pdwContext = dwOldPromptContext;}

	// re-enable windows
	if (hWndTop != NULL)
        {::EnableWindow(hWndTop, TRUE);}

	return nResult;
}

/*++

Routine Name:

    MessageBoxHelper

Routine Description:

    This routine is very similar to the win32 MessageBox except it
    creates a hidden dialog when the user request that a help button
    be displayed.  The MessageBox api is some what broken
    with respect to the way the help button works.  When the help button is
    clicked the MessageBox api will send a help event to the parent window.
    It is the responsiblity of the parent window to respond corectly, i.e.
    start either WinHelp or HtmlHelp.  Unfortunatly not in all cases does the
    caller have a parent window or has ownership to the parent window code to
    add suport for the help event. In these case is why someone would use this
    function.

Arguments:

    hWnd            - handle of owner window
    lpText          - address of text in message box
    lpCaption       - address of title of message box
    uType 	        - style of message box
    pfHelpCallback  - pointer to function called when a WM_HELP message is received, this
                      parameter is can be NULL then api acts like MessageBox.
    pRefData        - user defined refrence data passed along to the callback routine,
                      this paremeter can be NULL.

Return Value:

    See windows sdk for return values from MessageBox

--*/

INT
MessageBoxHelper(
    IN HWND             hWnd,
    IN LPCTSTR          pszMsg,
    IN LPCTSTR          pszTitle,
    IN UINT             uFlags,
    IN pfHelpCallback   pCallback, OPTIONAL
    IN PVOID            pRefData   OPTIONAL
    )
{
    INT iRetval = 0;

    //
    // If the caller specifed the help flag and provided a callback then
    // use the message box dialog class to display the message box, otherwise
    // fall back to the original behavior of MessageBox.
    //
    if( ( uFlags & MB_HELP ) && pCallback )
    {
        TMessageBoxDialog MyHelpDialog( hWnd, uFlags, pszTitle, pszMsg, pCallback, pRefData );
        if(MyHelpDialog.bValid())
        {
            iRetval = MyHelpDialog.iMessageBox();
        }
    }
    else
    {
        //
        // Display the message box.
        //
        iRetval = ::MessageBox( hWnd, pszMsg, pszTitle, uFlags );
    }
    return iRetval;
}

/********************************************************************

 Message box helper class.

********************************************************************/
BOOL TMessageBoxDialog::bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ShowWindow( _hDlg, SW_HIDE );
        _iRetval = ::MessageBox( _hDlg, _pszMsg, _pszTitle, _uFlags );
        EndDialog( _hDlg, IDOK );
        break;

    case WM_HELP:
        bStatus = ( _pCallback ) ? _pCallback( _hDlg, _pRefData ) : FALSE;
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}

INT_PTR APIENTRY TMessageBoxDialog::SetupDlgProc(IN HWND hDlg,IN UINT uMsg,IN WPARAM wParam,IN LPARAM lParam)
/*++

Routine Description:

    Setup the wndproc and initialize GWL_USERDATA.

Arguments:

    Standard wndproc parms.

Return Value:

--*/
{
    BOOL bRet = FALSE;
    TMessageBoxDialog *pThis = NULL;

    if( WM_INITDIALOG == uMsg )
    {
        pThis = reinterpret_cast<TMessageBoxDialog*>(lParam);
        if( pThis )
        {
            pThis->_hDlg = hDlg;
            SetWindowLongPtr(hDlg, DWLP_USER, reinterpret_cast<LONG_PTR>(pThis));
            bRet = pThis->bHandleMessage(uMsg, wParam, lParam);
        }
    }
    else
    {
        pThis = reinterpret_cast<TMessageBoxDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));
        if( pThis )
        {
            bRet = pThis->bHandleMessage(uMsg, wParam, lParam);
            if( WM_DESTROY == uMsg )
            {
                // our window is about to go away, so we need to cleanup DWLP_USER here 
                SetWindowLongPtr(hDlg, DWLP_USER, 0);
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\msgbox.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998
All rights reserved.

Module Name:

    msgbox.hxx

Abstract:

    Message box function with help button.

Author:
    copied from nt\printscan\ui\printui code

Revision History:


--*/

#ifndef _MSGBOX_HXX_
#define _MSGBOX_HXX_

#include "resource.h"

typedef struct MSG_HLPMAP
{
    UINT    uIdMessage;         // Mapped message in resouce file
} *PMSG_HLPMAP;


int DoHelpMessageBox(HWND hWndIn, LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt);
int DoHelpMessageBox(HWND hWndIn, UINT iResourceID, UINT nType, UINT nIDPrompt);

//
// Callback function called when the help button is clicked.
//
typedef BOOL (WINAPI *pfHelpCallback)( HWND hwnd, PVOID pRefData );

//
// Message box function that can handle the help button with
// a windows that does not have a known parent.
//
INT
MessageBoxHelper(
    IN HWND             hWnd,
    IN LPCTSTR          pszMsg,
    IN LPCTSTR          pszTitle,
    IN UINT             uFlags,
    IN pfHelpCallback   pCallBack   = NULL, OPTIONAL
    IN PVOID            RefData     = NULL  OPTIONAL
    );

//
// Dialog box helper class to catch the WM_HELP
// message when there is a help button on
// a message box.
//
class TMessageBoxDialog
{
public:
    TMessageBoxDialog(
        IN HWND             hWnd,
        IN UINT             uFlags,
        IN LPCTSTR          pszTitle,
        IN LPCTSTR          pszMsg,
        IN pfHelpCallback   pCallback,
        IN PVOID            pRefData
        ) : _hWnd( hWnd ),
            _uFlags( uFlags ),
            _pszTitle( pszTitle ),
            _pszMsg( pszMsg ),
            _pCallback( pCallback ),
            _pRefData( pRefData ),
            _iRetval( 0 )
        {};

    ~TMessageBoxDialog(VOID){};

    inline HWND& hDlg(){return _hDlg;}
    inline HWND const & hDlg() const{return _hDlg;}
    BOOL bSetText(LPCTSTR pszTitle){return SetWindowText( _hDlg, pszTitle );};
    VOID vForceCleanup(VOID){SetWindowLongPtr( _hDlg, DWLP_USER, 0L );};
    BOOL bValid(VOID) const{return TRUE;};
    INT iMessageBox(VOID)
    {
        _iRetval = 0;
        DialogBoxParam(_Module.GetResourceInstance(),MAKEINTRESOURCE(IDD_MESSAGE_BOX_DLG),_hWnd,TMessageBoxDialog::SetupDlgProc,(LPARAM)this);
        return _iRetval;
    };
    static INT_PTR CALLBACK SetupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

protected:
    VOID vSetDlgMsgResult(LONG_PTR lResult){SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, (LPARAM)lResult);};
    VOID vSetParentDlgMsgResult(LRESULT lResult){SetWindowLongPtr( GetParent( _hDlg ), DWLP_MSGRESULT, (LPARAM)lResult );};

private:
    //
    // Copying and assignment are not defined.
    //
    TMessageBoxDialog(const TMessageBoxDialog &);
    TMessageBoxDialog & operator =(const TMessageBoxDialog &);
    BOOL bHandleMessage(IN UINT uMsg,IN WPARAM wParam,IN LPARAM lParam);

    HWND            _hDlg;
    HWND            _hWnd;
    UINT            _uFlags;
    LPCTSTR         _pszTitle;
    LPCTSTR         _pszMsg;
    INT             _iRetval;
    PVOID           _pRefData;
    pfHelpCallback  _pCallback;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\perform.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        perform.cpp

   Abstract:
        WWW Performance Property Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/29/2000      sergeia     Changed for IIS6. Removed excessive commenting

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "supdlgs.h"
#include "perform.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define CONNECTIONS_MIN         0
#define CONNECTIONS_MAX         2000000000

IMPLEMENT_DYNCREATE(CW3PerfPage, CInetPropertyPage)

/* static */
void
CW3PerfPage::ParseMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
    //
    // Special case: If dwMaxBandwidth is 0(an invalid value), the 
    // value likely could not be inherited from the root (the user
    // is an operator and can't see the properties there).  Adjust
    // the value to a possibly misleading value.
    //
    if (dwMaxBandwidth == 0L)
    {
        TRACEEOLID("Adjusting invalid bandwidth throttling value -- "
                   "are you an operator?");
        dwMaxBandwidth = INFINITE_BANDWIDTH;
    }

    fLimitBandwidth = (dwMaxBandwidth != INFINITE_BANDWIDTH);
    dwMaxBandwidthDisplay = fLimitBandwidth ?
      (dwMaxBandwidth / KILOBYTE) : (DEF_BANDWIDTH / KILOBYTE);
}



CW3PerfPage::CW3PerfPage(
    IN CInetPropertySheet * pSheet
    )
    : CInetPropertyPage(CW3PerfPage::IDD, pSheet)
{
#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
#endif // _DEBUG
    m_nUnlimited = RADIO_LIMITED;
    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
}

CW3PerfPage::~CW3PerfPage()
{
}

void
CW3PerfPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3PerfPage)
    DDX_Check(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_fLimitBandwidth);
    DDX_Control(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_LimitBandwidth);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH, m_MaxBandwidth);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH_SPIN, m_MaxBandwidthSpin);
    DDX_Control(pDX, IDC_STATIC_MAX_NETWORK_USE, m_MaxBandwidthTxt);
    DDX_Control(pDX, IDC_STATIC_PSHED_REQUIRED, m_static_PSHED_Required);

    DDX_Control(pDX, IDC_STATIC_CONN, m_WebServiceConnGrp);
    DDX_Control(pDX, IDC_RADIO_UNLIMITED, m_radio_Unlimited);
    DDX_Control(pDX, IDC_RADIO_LIMITED, m_radio_Limited);
    DDX_Radio(pDX, IDC_RADIO_UNLIMITED, m_nUnlimited);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxConnections);
    DDX_Control(pDX, IDC_SPIN_MAX_CONNECTIONS, m_MaxConnectionsSpin);
    //}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate && m_fLimitBandwidth)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
        DDV_MinMaxBalloon(pDX, IDC_MAX_BANDWIDTH, BANDWIDTH_MIN, BANDWIDTH_MAX);
    }
	DDX_TextBalloon(pDX, IDC_MAX_BANDWIDTH, m_dwMaxBandwidthDisplay);
    if (IsMasterInstance() || GetSheet()->QueryMajorVersion() >= 6)
    {
       if (m_nUnlimited != 0)
       {
		   // This Needs to come before DDX_Text which will try to put text big number into small number
           DDV_MinMaxBalloon(pDX, IDC_EDIT_MAX_CONNECTIONS, CONNECTIONS_MIN, CONNECTIONS_MAX);
       }
       if (!pDX->m_bSaveAndValidate || !m_fUnlimitedConnections )
       {
           DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nVisibleMaxConnections);
       }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3PerfPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3PerfPage)
    ON_BN_CLICKED(IDC_CHECK_LIMIT_NETWORK_USE, OnCheckLimitNetworkUse)
    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_MAX_BANDWIDTH, OnItemChanged)
END_MESSAGE_MAP()



BOOL
CW3PerfPage::SetControlStates()
/*++

Routine Description:

    Set control states depending on contents of the dialog

Arguments:

    None

Return Value:

    TRUE if the 'limit network use' is on.

--*/
{
    BOOL fLimitOn = FALSE;
    if (::IsWindow(m_LimitBandwidth.m_hWnd))
    {
        fLimitOn = m_LimitBandwidth.GetCheck() > 0
            && HasBwThrottling()
            && HasAdminAccess();

        m_static_PSHED_Required.ShowWindow(fLimitOn &&
                fLimitOn != m_fLimitBandwidthInitial ? SW_SHOW : SW_HIDE);

        m_MaxBandwidthTxt.EnableWindow(fLimitOn);
        m_MaxBandwidth.EnableWindow(fLimitOn);
        m_MaxBandwidthSpin.EnableWindow(fLimitOn);
		::EnableWindow(CONTROL_HWND(IDC_STATIC_KBS), fLimitOn);
    }
    if (::IsWindow(m_edit_MaxConnections.m_hWnd))
    {
        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
        m_MaxConnectionsSpin.EnableWindow(!m_fUnlimitedConnections);
    }
    return fLimitOn;
}



/* virtual */
HRESULT
CW3PerfPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CW3Sheet)
        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_dwMaxBandwidth);
        ParseMaxNetworkUse(
            m_dwMaxBandwidth, 
            m_dwMaxBandwidthDisplay, 
            m_fLimitBandwidth
            );

        m_fUnlimitedConnections =
            ((ULONG)(LONG)m_nMaxConnections >= UNLIMITED_CONNECTIONS);

        //
        // Set the visible max connections edit field, which
        // may start out with a default value
        //
        m_nVisibleMaxConnections = m_fUnlimitedConnections ? 
            INITIAL_MAX_CONNECTIONS : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;
    END_META_INST_READ(err)

    m_fLimitBandwidthInitial = m_fLimitBandwidth;

    return err;
}



/* virtual */
HRESULT
CW3PerfPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 performance page now...");

    CError err;

    BuildMaxNetworkUse(
        m_dwMaxBandwidth, 
        m_dwMaxBandwidthDisplay, 
        m_fLimitBandwidth
        );

    m_nMaxConnections = m_fUnlimitedConnections ? 
        UNLIMITED_CONNECTIONS : m_nVisibleMaxConnections;
    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        STORE_INST_DATA_ON_SHEET(m_dwMaxBandwidth);
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
    END_META_INST_WRITE(err)

    EndWaitCursor();

    m_fLimitBandwidthInitial = m_fLimitBandwidth;

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL 
CW3PerfPage::OnSetActive() 
{
    return CInetPropertyPage::OnSetActive();
}



void
CW3PerfPage::OnItemChanged()
{
    SetControlStates();
    SetModified(TRUE);
}

void
CW3PerfPage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0,-1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}


void
CW3PerfPage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}

void
CW3PerfPage::OnCheckLimitNetworkUse()
/*++

Routine Description:

    The "limit network use" checkbox has been clicked
    Enable/disable the "max bandwidth" controls.

Arguments:

    None

Return Value:

    None

--*/
{
    if (SetControlStates())
    {
        m_MaxBandwidth.SetSel(0, -1);
        m_MaxBandwidth.SetFocus();
    }
    OnItemChanged();
}

BOOL
CW3PerfPage::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   m_LimitBandwidth.EnableWindow(
     HasBwThrottling() && HasAdminAccess());
   m_static_PSHED_Required.ShowWindow(SW_HIDE);

   if (!IsMasterInstance() && GetSheet()->QueryMajorVersion() <= 5)
   {
      m_WebServiceConnGrp.ShowWindow(SW_HIDE);
      m_radio_Unlimited.ShowWindow(SW_HIDE);
      m_radio_Limited.ShowWindow(SW_HIDE);
      m_edit_MaxConnections.ShowWindow(SW_HIDE);
      m_MaxConnectionsSpin.ShowWindow(SW_HIDE);
   }
   else
   {
      SETUP_SPIN(m_MaxConnectionsSpin, 
          CONNECTIONS_MIN, CONNECTIONS_MAX, m_nMaxConnections);
	  if (IsMasterInstance())
	  {
           CString buf;
           buf.LoadString(IDS_PERF_MASTER_BANDWIDTH);
		   GetDlgItem(IDC_CHECK_LIMIT_NETWORK_USE)->SetWindowText(buf);
	  }
   }


   SETUP_EDIT_SPIN(m_fLimitBandwidth, m_MaxBandwidth, m_MaxBandwidthSpin, 
      BANDWIDTH_MIN, BANDWIDTH_MAX, m_dwMaxBandwidthDisplay);

   SetControlStates();

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\perform.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        perform.h

   Abstract:
        WWW Performance Property Page definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/29/2000      sergeia     Changed for IIS6. Removed excessive commenting

--*/
#ifndef __PERFORM_H__
#define __PERFORM_H__


class CW3PerfPage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CW3PerfPage)

    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };
//
// Construction
//
public:
    CW3PerfPage(CInetPropertySheet * pSheet = NULL);
    ~CW3PerfPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3PerfPage)
    enum { IDD = IDD_PERFORMANCE };
    BOOL m_fLimitBandwidth;
    CButton m_LimitBandwidth;
    CStatic m_MaxBandwidthTxt;
    CEdit m_MaxBandwidth;
    DWORD m_dwMaxBandwidthDisplay;
    CSpinButtonCtrl m_MaxBandwidthSpin;
    CStatic m_static_PSHED_Required;

    int     m_nUnlimited;
    CStatic m_WebServiceConnGrp;
    CEdit   m_edit_MaxConnections;
    CButton m_radio_Unlimited;
    CButton m_radio_Limited;
    CSpinButtonCtrl m_MaxConnectionsSpin;
    //}}AFX_DATA
    BOOL m_fLimitBandwidthInitial;
    DWORD m_dwMaxBandwidth;
    BOOL m_fUnlimitedConnections;
    CILong m_nMaxConnections;
    CILong m_nVisibleMaxConnections;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3PerfPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

protected:
   static void 
   ParseMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

   static void
   BuildMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3PerfPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckLimitNetworkUse();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


inline /* static */ void 
CW3PerfPage::BuildMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
   dwMaxBandwidth = fLimitBandwidth ?
      dwMaxBandwidthDisplay * KILOBYTE : INFINITE_BANDWIDTH;
}

#endif // __PERFORM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\rat.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "rat.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CRat

IMPLEMENT_DYNCREATE(CRat, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CRat properties

short CRat::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CRat::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

BOOL CRat::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CRat::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

COleFont CRat::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CRat::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

CString CRat::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CRat::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CRat operations

void CRat::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget);
}

void CRat::SetUserData(LPCTSTR szUserName, LPCTSTR szUserPassword)
{
    static BYTE parms[] = VTS_BSTR VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		szUserName, szUserPassword);
}

void CRat::SetUrl(LPCTSTR szURL)
{
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		szURL);
}

void CRat::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\pshed.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows 2000 (c) 1999
//
//  File:   install.cpp
//
//  Contents:   Net config code that installs the packet scheduler based
//              the domain policy
//
//  Author: Shreedhar Madhavapeddi (ShreeM)
//
//  Reworked by Sergei Antonov (sergeia) -- removed ugly notation and 
//  adapted to iis needs
//          
//  Usage Notes:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <netcfgx.h>
#include <devguid.h>

static const GUID * c_aguidClass[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT
};


HRESULT CallINetCfg(BOOL Install);

HRESULT
AddRemovePSCHED(INetCfg * pINetCfg, BOOL Install)
{
    HRESULT hr;
    INetCfgClassSetup * pSetup;
    INetCfgComponent * pIComp;
    OBO_TOKEN OboToken;
    
    pSetup = NULL;
    pIComp = NULL;

    if (!pINetCfg)
    {
        return E_POINTER;
    }

    hr = pINetCfg->QueryNetCfgClass (&GUID_DEVCLASS_NETSERVICE,
                IID_INetCfgClassSetup, (VOID**)&pSetup);

    if (S_OK == hr)
    {
        ZeroMemory (&OboToken, sizeof(OboToken));
        OboToken.Type = OBO_USER;

        if (Install) 
        {
            hr = pSetup->Install (
                                  L"ms_psched",
                                  &OboToken,
                                  0, 0, NULL, NULL,
                                  &pIComp);

            if (NETCFG_S_REBOOT == hr)
            {
                hr = S_OK;
            }
                
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
        }
        else
        {
            // first find the component.
            hr = pINetCfg->FindComponent (L"ms_psched", &pIComp);
            
            if (S_OK == hr)
            {
                hr = pSetup->DeInstall (
                                        pIComp,
                                        &OboToken,
                                        NULL);
                
                if (NETCFG_S_REBOOT == hr)
                {
                    hr = S_OK;
                }
                
                if (NETCFG_S_STILL_REFERENCED == hr)
                {
                    hr = S_OK;
                }

            }
        }

        if (pIComp && SUCCEEDED(hr))
        {
            pIComp->Release();
        }
        pSetup->Release();
    }
    HRESULT hrT = pINetCfg->Uninitialize ();

    return hr;
}


HRESULT 
CallINetCfg(BOOL Install)
{
    HRESULT hr = S_OK;

    // initialize COM
    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pncLock = NULL;
            
            // Get the locking interface
            hr = pnc->QueryInterface(IID_INetCfgLock,
                                     (LPVOID *)&pncLock);
            if (SUCCEEDED(hr))
            {
                // Attempt to lock the INetCfg for read/write
                static const ULONG c_cmsTimeout = 15000;
                static const WCHAR c_szSampleNetcfgApp[] =
                    L"Internet Information Services MMC Snapin";
                PWSTR szLockedBy;
                hr = pncLock->AcquireWriteLock(c_cmsTimeout,
                                               c_szSampleNetcfgApp,
                                               &szLockedBy);
                if (S_FALSE == hr)
                {
                    hr = NETCFG_E_NO_WRITE_LOCK;
//                    _tprintf(L"Could not lock INetcfg, it is already locked by '%s'", szLockedBy);
                    pncLock->Release();
                    pnc->Release();
                    CoUninitialize();
                    
                }

                if (SUCCEEDED(hr))
                {
                
                    // Initialize the INetCfg object.
                    //
                    hr = pnc->Initialize(NULL);
                    if (SUCCEEDED(hr))
                    {
                        pnc->AddRef();
                        AddRemovePSCHED(pnc, Install); 
                    }
                    else
                    {
                        // initialize failed, if obtained lock, release it
                        pncLock->ReleaseWriteLock();
                    }

                }
                pncLock->Release();
                pnc->Release();
            }
            else 
            {
                pnc->Release();
            }
        }
        
        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\rat.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CRat wrapper class

class CRat : public CWnd
{
protected:
    DECLARE_DYNCREATE(CRat)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba634607, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    short GetBorderStyle();
    void SetBorderStyle(short);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
	void SetUserData(LPCTSTR szUserName, LPCTSTR szUserPassword);
	void SetUrl(LPCTSTR szURL);
    void DoClick();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\mmmdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mmmdlg.h

   Abstract:

        Multi-multi-multi dialog editor definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __MMMDLG_H__
#define __MMMDLG_H__


//
// UINT DDX/DDV helper function that uses a blank string to denote 0
//
void AFXAPI DDXV_UINT(
    IN CDataExchange * pDX,
    IN UINT nID,
    IN OUT UINT & uValue,
    IN UINT uMin,
    IN UINT uMax,
    IN UINT nEmptyErrorMsg = 0
    );

//
// Helper function to check to see if binding is unique
//
BOOL
IsBindingUnique(
    IN CString & strBinding,
    IN CStringList & strlBindings,
    IN int iCurrent = -1
    );

/*
//
// Helper function to build and verify binding strings.
//
BOOL
VerifyBindingInfo(
    OUT CString & strBinding,
    OUT CString & strSecureBinding,
    IN  CStringList & strlBindings,
    IN  CStringList & strlSecureBindings,
    IN  int iBindings,
    IN  int iSSLBindings,
    IN  CIPAddress & iaIpAddress,
    IN  UINT nTCPPort,
    IN  UINT nSSLPort,
    IN  CString & strDomainName
    );
*/


class CMMMListBox : public CHeaderListBox
{
/*++

Class Description:

    Multi-multi-multi listbox.

Public Interface:

    CMMMListBox    : Constructor

    GetItem        : Get item at specified position
                     in the listbox
    AddItem        : Add new item to the listbox
    Initialize     : Initialize the listbox

--*/
    DECLARE_DYNAMIC(CMMMListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;

public:
    CMMMListBox(
        IN LPCTSTR lpszRegKey,
        IN int cColumns,
        IN const ODL_COLUMN_DEF * pColumns
        );

public:
    CString & GetItem(UINT nIndex);
    int AddItem(CString & item);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & ds);

protected:
    int m_cColumns;
    const ODL_COLUMN_DEF * m_pColumns;
    CString m_strDefaultIP;
    CString m_strNoPort;
};



class CMMMEditDlg : public CDialog
/*++

Class Description:

    Multi-Multi-Multi edit entry dialog

Public Interface:

    CMMMEditDlg     : Constructor

--*/
{
//
// Construction
//
public:
    CMMMEditDlg(
        IN CString & strServerName,
        IN OUT CStringList & strlBindings,
        IN CStringList & strlOtherBindings,
        IN OUT CString & strEntry,
        IN BOOL fIPBinding = TRUE,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CMMMEditDlg)
    enum { IDD = IDD_EDIT_MMM };
    int         m_nIpAddressSel;
    UINT        m_nPort;
    CString     m_strDomainName;
    CStatic     m_static_Port;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    CIPAddress m_iaIpAddress;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMMEditDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
	virtual void OnHelp();
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMMMEditDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fIPBinding;
    CString & m_strServerName;
    CString & m_entry;
    CObListPlus m_oblIpAddresses;
    CStringList & m_strlBindings;
    CStringList & m_strlOtherBindings;
	UINT m_nHelpContext;
};



class CMMMDlg : public CDialog
/*++

Class Description:

    Mutlti-multi-multi dialog

Public Interface:

    CMMMDlg     : Constructor

--*/
{
//
// Construction
//
public:
    CMMMDlg(
        IN LPCTSTR lpServerName,
        IN DWORD   dwInstance,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpMetaPath,
        IN CStringList & strlBindings,
        IN CStringList & strlSecureBindings,
        IN CWnd * pParent = NULL
        );

//
// Access
//
public:
    CStringList & GetBindings() { return m_strlBindings; }
    CStringList & GetSecureBindings() { return m_strlSecureBindings; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CMMMDlg)
    enum { IDD = IDD_MMM };
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    CButton m_button_AddSSL;
    CButton m_button_RemoveSSL;
    CButton m_button_EditSSL;
    CButton m_button_OK;
	    //}}AFX_DATA

    CMMMListBox m_list_Bindings;
    CMMMListBox m_list_SSLBindings;

    CStringList m_strlBindings;
    CStringList m_strlSecureBindings;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMMDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	virtual void OnHelp();
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMMMDlg)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonAddSsl();
    afx_msg void OnButtonEditSsl();
    afx_msg void OnButtonRemoveSsl();
    afx_msg void OnDblclkListMmm();
    afx_msg void OnDblclkListSslMmm();
    afx_msg void OnSelchangeListMmm();
    afx_msg void OnSelchangeListSslMmm();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL OnItemChanged();
    BOOL SetControlStates();
    void AddBindings(CMMMListBox & list, CStringList & strl);

private:
    BOOL m_fDirty;
    BOOL m_fCertInstalled;
    CString m_strServerName;
    CComAuthInfo * m_pAuthInfo;
    CString m_strMetaPath;
    CRMCListBoxResources m_ListBoxRes;
	UINT m_nHelpContext;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CString & CMMMListBox::GetItem(UINT nIndex)
{
    return *(CString *)GetItemDataPtr(nIndex);
}

inline int CMMMListBox::AddItem(CString & item)
{
    return AddString((LPCTSTR)&item);
}

#endif // __MMMDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\remoteenv.cpp ===
#include "stdafx.h"
#include "RemoteEnv.h"

typedef LONG NTSTATUS;

#define MAX_ENV_VALUE_LEN               1024

#define DEFAULT_ROOT_KEY                HKEY_LOCAL_MACHINE
#define REG_PATH_TO_SYSROOT             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define REG_PATH_TO_COMMON_FOLDERS      TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define REG_PATH_TO_ENV                 TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")

#define PATH_VARIABLE                   TEXT("Path")
#define LIBPATH_VARIABLE                TEXT("LibPath")
#define OS2LIBPATH_VARIABLE             TEXT("Os2LibPath")
#define AUTOEXECPATH_VARIABLE           TEXT("AutoexecPath")

#define ENV_KEYWORD_SYSTEMROOT          TEXT("SystemRoot")
#define ENV_KEYWORD_PROGRAMFILESDIR     TEXT("ProgramFilesDir")
#define ENV_KEYWORD_COMMONFILESDIR      TEXT("CommonFilesDir")
#define ENV_KEYWORD_PROGRAMFILESDIR_X86 TEXT("ProgramFilesDir (x86)")
#define ENV_KEYWORD_COMMONFILESDIR_X86  TEXT("CommonFilesDir (x86)")

#define PROGRAMFILES_VARIABLE           TEXT("ProgramFiles")
#define COMMONPROGRAMFILES_VARIABLE     TEXT("CommonProgramFiles")
#define PROGRAMFILESX86_VARIABLE        TEXT("ProgramFiles(x86)")
#define COMMONPROGRAMFILESX86_VARIABLE  TEXT("CommonProgramFiles(x86)")

CRemoteExpandEnvironmentStrings::CRemoteExpandEnvironmentStrings()
{
    m_pEnvironment = NULL;
    m_lpszUncServerName = NULL;
    return;
}

CRemoteExpandEnvironmentStrings::~CRemoteExpandEnvironmentStrings()
{
    DeleteRemoteEnvironment();
    
    if (m_lpszUncServerName)
    {
        LocalFree(m_lpszUncServerName);
        m_lpszUncServerName = NULL;
    }
    return;
}

BOOL
CRemoteExpandEnvironmentStrings::NewRemoteEnvironment()
{
    BOOL bReturn = FALSE;

    // already have a cached one, use that...
    if (m_pEnvironment)
    {
        bReturn = TRUE;
    }
    else
    {
        //
        // Create a temporary environment, which we'll fill in and let RTL
        // routines do the expansion for us.
        //
        if ( !NT_SUCCESS(RtlCreateEnvironment((BOOLEAN) FALSE,&m_pEnvironment)) ) 
        {
            bReturn = FALSE;
            goto NewRemoteEnvironment_Exit;
        }
    
        SetOtherEnvironmentValues(&m_pEnvironment);
        SetEnvironmentVariables(&m_pEnvironment);
        bReturn = TRUE;
    }

NewRemoteEnvironment_Exit:
    return bReturn;
}

void
CRemoteExpandEnvironmentStrings::DeleteRemoteEnvironment()
{
    if (m_pEnvironment != NULL)
    {
        RtlDestroyEnvironment(m_pEnvironment);
        m_pEnvironment = NULL;
    }
    return;
}


BOOL CRemoteExpandEnvironmentStrings::IsLocalMachine(LPCTSTR psz)
{
    CString szLocal;
    DWORD   cch = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bAnswer;

    if (_tcsicmp(psz,_T("")) == 0)
    {
        // it's empty,
        // yeah it's local machine
        return TRUE;
    }

    // get the actual name of the local machine
    bAnswer = GetComputerName(szLocal.GetBuffer(cch), &cch);
    szLocal.ReleaseBuffer();
    if ( !bAnswer )
        return FALSE;

    // compare and return
    bAnswer = (szLocal.CompareNoCase( psz ) == 0);
    return bAnswer;
}


BOOL
CRemoteExpandEnvironmentStrings::SetMachineName(IN LPCTSTR szMachineName)
{
    BOOL bReturn = FALSE;
    DWORD dwSize = 0;
    LPTSTR lpszUncServerNameOriginal =  NULL;

    // free any previous thing we had...
    if (m_lpszUncServerName)
    {
        // Make a copy of it before we delete it
        dwSize = (_tcslen(m_lpszUncServerName) + 1) * sizeof(TCHAR);
        lpszUncServerNameOriginal = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
        if (lpszUncServerNameOriginal)
        {
            _tcscpy(lpszUncServerNameOriginal, m_lpszUncServerName);
        }

        // free up anything we had before
        LocalFree(m_lpszUncServerName);
        m_lpszUncServerName = NULL;
    }

    if (_tcsicmp(szMachineName,_T("")) == 0)
    {
        bReturn = TRUE;
        goto CRemoteExpandEnvironmentStrings_Exit;
    }

    // if it's the localmachine name
    // then set it to NULL
    // so that it will be treated as localmachine.
    if (IsLocalMachine(szMachineName))
    {
        m_lpszUncServerName = NULL;
        bReturn = TRUE;
        goto CRemoteExpandEnvironmentStrings_Exit;
    }

    dwSize = (_tcslen(szMachineName) + 1 + 2) * sizeof(TCHAR);
    m_lpszUncServerName = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
    if (m_lpszUncServerName)
    {
        // check if szMachineName already starts with "\\"
        if (szMachineName[0] == _T('\\') && szMachineName[1] == _T('\\'))
        {
            _tcscpy(m_lpszUncServerName, szMachineName);
        }
        else
        {
            _tcscpy(m_lpszUncServerName, _T("\\\\"));
            _tcscat(m_lpszUncServerName, szMachineName);
        }
        bReturn = TRUE;
    }

    // if the machine name is different from what it was before
    // then delete the current environment if any...
    if (m_lpszUncServerName && lpszUncServerNameOriginal)
    {
        if (0 != _tcsicmp(lpszUncServerNameOriginal,m_lpszUncServerName))
        {
            DeleteRemoteEnvironment();
        }
    }
    else
    {
        DeleteRemoteEnvironment();
    }

CRemoteExpandEnvironmentStrings_Exit:
    if (lpszUncServerNameOriginal)
        {LocalFree(lpszUncServerNameOriginal);lpszUncServerNameOriginal=NULL;}
    return bReturn;
}

DWORD
CRemoteExpandEnvironmentStrings::GetRegKeyMaxSizes(
    IN  HKEY    WinRegHandle,
    OUT LPDWORD MaxKeywordSize OPTIONAL,
    OUT LPDWORD MaxValueSize OPTIONAL
    )
{
    LONG Error;
    DWORD MaxValueNameLength;
    DWORD MaxValueDataLength;

    Error = RegQueryInfoKey(
            WinRegHandle,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &MaxValueNameLength,
            &MaxValueDataLength,
            NULL,
            NULL
            );
    if (ERROR_SUCCESS == Error) 
    {
        //
        // MaxValueNameLength is a count of TCHARs.
        // MaxValueDataLength is a count of bytes already.
        //
        MaxValueNameLength = (MaxValueNameLength + 1) * sizeof(TCHAR);

        if (MaxKeywordSize)
        {
            *MaxKeywordSize = MaxValueNameLength;
        }
        if (MaxValueSize)
        {
            *MaxValueSize = MaxValueDataLength;
        }
    }

    return (Error);
}

NET_API_STATUS
CRemoteExpandEnvironmentStrings::RemoteExpandEnvironmentStrings(
    IN  LPCTSTR  UnexpandedString,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by LocalFree().
    )
/*++

Routine Description:

    This function expands a value string (which may include references to
    environment variables).  For instance, an unexpanded string might be:

        %SystemRoot%\System32\Repl\Export

    This could be expanded to:

        c:\nt\System32\Repl\Export

    The expansion makes use of environment variables on m_lpszUncServerName,
    if given.  This allows remote administration of the directory
    replicator.

Arguments:

    m_lpszUncServerName - assumed to NOT BE EXPLICIT LOCAL SERVER NAME.

    UnexpandedString - points to source string to be expanded.

    ValueBufferPtr - indicates a pointer which will be set by this routine.
        This routine will allocate memory for a null-terminated string.
        The caller must free this with LocalFree() or equivalent.


Return Value:

    NET_API_STATUS

--*/
{
    NET_API_STATUS ApiStatus = NO_ERROR;
    LPTSTR         ExpandedString = NULL;
    DWORD          LastAllocationSize = 0;
    NTSTATUS       NtStatus;

    //
    // Check for caller errors.
    //
    if (ValueBufferPtr == NULL) {
        // Can't goto Cleanup here, as it assumes this pointer is valid
        return (ERROR_INVALID_PARAMETER);
    }
    *ValueBufferPtr = NULL;     // assume error until proven otherwise.
    if (UnexpandedString == NULL)
    {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // This is probably just a constant string.
    //
    if (wcschr( UnexpandedString, _T('%') ) == NULL) 
    {
        // Just need to allocate a copy of the input string.
        DWORD dwSize = (_tcslen(UnexpandedString) + 1) * sizeof(TCHAR);
        ExpandedString = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
        if (ExpandedString == NULL)
        {
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        else
        {
            RtlCopyMemory(ExpandedString, UnexpandedString, dwSize);
        }

        // That's all, folks!
        ApiStatus = NO_ERROR;
    //
    // Otherwise, is this local?  Maybe we can
    // handle local expansion the easy (fast) way: using win32 API.
    //
    }
    else if (m_lpszUncServerName == NULL) 
    {

        DWORD CharsRequired = wcslen(UnexpandedString)+1;
        do {

            // Clean up from previous pass.
            if (ExpandedString){LocalFree(ExpandedString);ExpandedString = NULL;}

            // Allocate the memory.
            ExpandedString = (LPTSTR) LocalAlloc(LMEM_FIXED, CharsRequired * sizeof(TCHAR));
            if (ExpandedString == NULL) 
            {
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            LastAllocationSize = CharsRequired * sizeof(TCHAR);

            // Expand string using local env vars.
            CharsRequired = ExpandEnvironmentStrings(UnexpandedString,ExpandedString,LastAllocationSize / sizeof(TCHAR));
            if (CharsRequired == 0) 
            {
                ApiStatus = (NET_API_STATUS) GetLastError();
                goto Cleanup;
            }

        } while ((CharsRequired*sizeof(TCHAR)) > LastAllocationSize);

        ApiStatus = NO_ERROR;

    //
    // Oh well, remote expansion required.
    //
    }
    else 
    {
        DWORD          DataType;
        LONG           Error;
        UNICODE_STRING ExpandedUnicode;
        DWORD          SizeRequired;
        UNICODE_STRING UnexpandedUnicode;

        //
        // Create a temporary environment, which we'll fill in and let RTL
        // routines do the expansion for us.
        //
        if (FALSE == NewRemoteEnvironment())
        {
            ApiStatus = E_FAIL;
            goto Cleanup;
        }
        
        //
        // Loop until we have enough storage.
        // Expand the string.
        //
        SizeRequired = (_tcslen(UnexpandedString) + 1) * sizeof(TCHAR); // First pass, try same size
        RtlInitUnicodeString(&UnexpandedUnicode,(PCWSTR) UnexpandedString);
        do {

            // Clean up from previous pass.
            if (ExpandedString){LocalFree(ExpandedString);ExpandedString = NULL;}

            // Allocate the memory.
            ExpandedString = (LPTSTR) LocalAlloc(LMEM_FIXED, SizeRequired);
            if (ExpandedString == NULL) 
            {
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            LastAllocationSize = SizeRequired;

            ExpandedUnicode.MaximumLength = (USHORT)SizeRequired;
            ExpandedUnicode.Buffer = ExpandedString;

            NtStatus = RtlExpandEnvironmentStrings_U(
                    m_pEnvironment,             // env to use
                    &UnexpandedUnicode,         // source
                    &ExpandedUnicode,           // dest
                    (PULONG) &SizeRequired );   // dest size needed next time.

            if ( NtStatus == STATUS_BUFFER_TOO_SMALL ) 
            {
                continue;  // try again with larger buffer.
            }
            else if ( !NT_SUCCESS( NtStatus ) ) 
            {
                ApiStatus = E_FAIL;;
                goto Cleanup;
            }
            else 
            {
                break;  // All done.
            }

        } while (SizeRequired > LastAllocationSize);

        ApiStatus = NO_ERROR;
    }


Cleanup:
    if (ApiStatus == NO_ERROR) 
    {
        *ValueBufferPtr = ExpandedString;
    }
    else 
    {
        *ValueBufferPtr = NULL;
        if (ExpandedString){LocalFree(ExpandedString);ExpandedString = NULL;}
    }

    return (ApiStatus);
}

BOOL CRemoteExpandEnvironmentStrings::BuildEnvironmentPath(void **pEnv, LPTSTR lpPathVariable, LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR lpTemp[1025];
    DWORD cb;

    if (!*pEnv) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpPathVariable);
    cb = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(WCHAR) * cb);
    Value.MaximumLength = (USHORT)(sizeof(WCHAR) * cb);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        Value.Length = 0;
        *lpTemp = 0;
    }
    if (Value.Length) {
        lstrcpy(lpTemp, Value.Buffer);
        if ( *( lpTemp + lstrlen(lpTemp) - 1) != TEXT(';') ) {
            lstrcat(lpTemp, TEXT(";"));
        }
        LocalFree(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(lpTemp) + lstrlen(lpPathValue) + 1) < (INT)cb)) {
        lstrcat(lpTemp, lpPathValue);

        RtlInitUnicodeString(&Value, lpTemp);

        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

DWORD CRemoteExpandEnvironmentStrings::ExpandUserEnvironmentStrings(void *pEnv, LPTSTR lpSrc, LPTSTR lpDst, DWORD nSize)
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;
    
    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(nSize* sizeof(WCHAR));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U(pEnv,
        (PUNICODE_STRING)&Source,
        (PUNICODE_STRING)&Destination,
        &Length
        );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length );
    }
    else {
        return( 0 );
    }
}

BOOL CRemoteExpandEnvironmentStrings::SetUserEnvironmentVariable(void **pEnv, LPTSTR lpVariable, LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    DWORD cb;
    TCHAR szValue[1024];

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpVariable);
    cb = 1024;
    Value.Buffer = (PTCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (Value.Buffer) {
        Value.Length = (USHORT)cb;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
        LocalFree(Value.Buffer);
        if (NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }
    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!_tcsicmp(lpVariable, TEXT("TEMP"))) ||
            (!_tcsicmp(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable( pEnv, &Name, NULL);
    }
    return NT_SUCCESS(Status);
}

// Reads the system environment variables from the registry
// and adds them to the environment block at pEnv.
BOOL CRemoteExpandEnvironmentStrings::SetEnvironmentVariables(void **pEnv)
{
    WCHAR lpValueName[MAX_PATH];
    LPBYTE  lpDataBuffer;
    DWORD cbDataBuffer;
    LPBYTE  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;
    HKEY RootKey = DEFAULT_ROOT_KEY;

    if (ERROR_SUCCESS != RegConnectRegistry((LPTSTR) m_lpszUncServerName,DEFAULT_ROOT_KEY,& RootKey ))
    {
        return(FALSE);
    }

    if (RegOpenKeyExW(RootKey,REG_PATH_TO_ENV,REG_OPTION_NON_VOLATILE,KEY_READ,& hkey))
    {
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cbDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = cbDataBuffer;
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_ENV_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {
                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !_tcsicmp(lpValueName, PATH_VARIABLE) ||
                     !_tcsicmp(lpValueName, LIBPATH_VARIABLE) ||
                     !_tcsicmp(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //
                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_ENV_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cb, cbNeeded;

                cb = 1024;
                lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                if (lpExpandedValue) {
                    cbNeeded = ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                    if (cbNeeded > cb) {
                        LocalFree(lpExpandedValue);
                        cb = cbNeeded;
                        lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !_tcsicmp(lpValueName, PATH_VARIABLE) ||
                     !_tcsicmp(lpValueName, LIBPATH_VARIABLE) ||
                     !_tcsicmp(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpExpandedValue, TRUE);
                }

                LocalFree(lpExpandedValue);

            }

        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }



    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

//*************************************************************
//
//  SetEnvironmentVariableInBlock()
//
//  Purpose:    Sets the environment variable in the given block
//
//  Parameters: pEnv        -   Environment block
//              lpVariable  -   Variables
//              lpValue     -   Value
//              bOverwrite  -   Overwrite
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************
BOOL CRemoteExpandEnvironmentStrings::SetEnvironmentVariableInBlock(PVOID *pEnv, LPTSTR lpVariable,LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;
    LPTSTR szValue = NULL;

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpVariable);

    cb = 1025 * sizeof(WCHAR);
    Value.Buffer = (PWSTR) LocalAlloc(LPTR, cb);
    if (Value.Buffer) {
        Value.Length = 0;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

        LocalFree(Value.Buffer);

        if ( NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }

    szValue = (LPTSTR)LocalAlloc(LPTR, 1024*sizeof(TCHAR));
    if (!szValue) 
    {
        return FALSE;
    }

    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!_tcsicmp(lpVariable, TEXT("TEMP"))) ||
            (!_tcsicmp(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    }

    LocalFree(szValue);
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

// Just set the environmental variables that we can
// if we can't set them because of no access, no biggie
DWORD CRemoteExpandEnvironmentStrings::SetOtherEnvironmentValues(void **pEnv)
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY  hKey = NULL;
    HKEY  RootKey = DEFAULT_ROOT_KEY;
    DWORD dwType, dwSize;
    TCHAR szValue[MAX_ENV_VALUE_LEN + 1];
    TCHAR szExpValue[MAX_ENV_VALUE_LEN + 1];
    DWORD RandomValueSize = 0;
    LPTSTR RandomValueW = NULL;

    // try to connect to remote registry (or local registry if Null)
    dwResult = RegConnectRegistry((LPTSTR) m_lpszUncServerName,DEFAULT_ROOT_KEY,& RootKey);
    if (ERROR_SUCCESS != dwResult)
    {
        goto SetOtherEnvironmentValues_Exit;
    }

    dwResult = RegOpenKeyEx(RootKey,REG_PATH_TO_SYSROOT,REG_OPTION_NON_VOLATILE,KEY_READ,&hKey);
    if (ERROR_SUCCESS == dwResult)
    {
        dwResult = GetRegKeyMaxSizes(
               hKey,
               NULL,                    // don't need keyword size
               &RandomValueSize );      // set max value size.
        if (ERROR_SUCCESS != dwResult)
        {
            goto SetOtherEnvironmentValues_Exit;
        }

        RandomValueW = (LPTSTR) LocalAlloc(LMEM_FIXED, RandomValueSize);
        if (RandomValueW == NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if (RegQueryValueEx(hKey,(LPTSTR)ENV_KEYWORD_SYSTEMROOT,REG_OPTION_NON_VOLATILE,&dwType,(LPBYTE) RandomValueW,&RandomValueSize) == ERROR_SUCCESS)
            {
                SetEnvironmentVariableInBlock(pEnv, ENV_KEYWORD_SYSTEMROOT, RandomValueW, TRUE);
            }
        }

        if (hKey) {RegCloseKey(hKey);}
    }

    dwResult = RegOpenKeyEx (RootKey, REG_PATH_TO_COMMON_FOLDERS, REG_OPTION_NON_VOLATILE, KEY_READ, &hKey);
    if (ERROR_SUCCESS == dwResult)
    {
        dwSize = (MAX_ENV_VALUE_LEN+1) * sizeof(TCHAR);

        if (RegQueryValueEx (hKey, ENV_KEYWORD_PROGRAMFILESDIR, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, PROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_ENV_VALUE_LEN+1) * sizeof(TCHAR);
        if (RegQueryValueEx (hKey, ENV_KEYWORD_COMMONFILESDIR, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_ENV_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, ENV_KEYWORD_PROGRAMFILESDIR_X86, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, PROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_ENV_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, ENV_KEYWORD_COMMONFILESDIR_X86, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }
    }

SetOtherEnvironmentValues_Exit:
    if (RootKey != DEFAULT_ROOT_KEY) 
        {RegCloseKey(RootKey);}
    if (hKey) {RegCloseKey(hKey);}
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\remoteenv.h ===
#if !defined(AFX_REMOTEENV_H__1B164072_460A_432a_99C0_26941B44FC53__INCLUDED_)
#define AFX_REMOTEENV_H__1B164072_460A_432a_99C0_26941B44FC53__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////

class CRemoteExpandEnvironmentStrings
{
public:
    CRemoteExpandEnvironmentStrings();
    ~CRemoteExpandEnvironmentStrings();
    BOOL SetMachineName(IN LPCTSTR szMachineName);
    BOOL NewRemoteEnvironment();
    void DeleteRemoteEnvironment();
    NET_API_STATUS RemoteExpandEnvironmentStrings(IN LPCTSTR UnexpandedString,OUT LPTSTR * ExpandedString);

protected:
    PVOID m_pEnvironment;
    LPTSTR m_lpszUncServerName;

private:
    DWORD SetOtherEnvironmentValues(void **pEnv);
    BOOL  SetEnvironmentVariables(void **pEnv);
    BOOL  IsLocalMachine(LPCTSTR psz);

    BOOL  SetEnvironmentVariableInBlock(void **pEnv, LPTSTR lpVariable,LPTSTR lpValue, BOOL bOverwrite);
    BOOL  SetUserEnvironmentVariable(void **pEnv, LPTSTR lpVariable, LPTSTR lpValue, BOOL bOverwrite);
    BOOL  BuildEnvironmentPath(void **pEnv, LPTSTR lpPathVariable, LPTSTR lpPathValue);
    DWORD ExpandUserEnvironmentStrings(void *pEnv, LPTSTR lpSrc, LPTSTR lpDst, DWORD nSize);
    DWORD GetRegKeyMaxSizes(IN HKEY WinRegHandle,OUT LPDWORD MaxKeywordSize OPTIONAL,OUT LPDWORD MaxValueSize OPTIONAL);
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_REMOTEENV_H__1B164072_460A_432a_99C0_26941B44FC53__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\savedata.h ===
#ifndef __SAVEDATA_H__
#define __SAVEDATA_H__

#include "resource.h"

HRESULT DoOnSaveData(
    HWND hWnd,
    LPCTSTR szMachineName,
    CMetaInterface * pInterface,
    BOOL bShowMsgBox,
    DWORD dwLastSystemChangeNumber);

#endif // __SAVEDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\restrictlist.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        restrictlist.h

   Abstract:
        IIS Object definitions

   Author:
        Aaron Lee (aaronl)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef __RESTRICT_LIST_H__
#define __RESTRICT_LIST_H__

extern INT g_iDebugOutputLevel;

#define METABASE_PATH_FOR_RESTRICT_LIST  _T("LM/W3SVC")
#define EMPTY_GROUPID_KEY _T("$e$m$p$t$y$:")
#define DEFAULTS_ISAPI "0,*.dll"
#define DEFAULTS_CGI   "0,*.exe"
#define RESTRICTION_LIST_SEPARATOR _T(',')
#define APPLICATION_DEPENDENCY_NAME_SEPARATOR _T(";")
#define APPLICATION_DEPENDENCY_LIST_SEPARATOR _T(",")

#define RESTRICTION_ENTRY_IS_ALLOW    _T("1")
#define RESTRICTION_ENTRY_IS_PROHIBIT _T("0")

enum
{
    WEBSVCEXT_TYPE_REGULAR,
    WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI,
    WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI,
	WEBSVCEXT_TYPE_FILENAME_EXTENSIONS_FILTER,
    /**/
    WEBSVCEXT_TYPE_TOTAL
};

enum
{
    WEBSVCEXT_STATUS_ALLOWED,
    WEBSVCEXT_STATUS_PROHIBITED,
    WEBSVCEXT_STATUS_CUSTOM,
	WEBSVCEXT_STATUS_NOTINUSE,
    WEBSVCEXT_STATUS_INUSE,
    /**/
    WEBSVCEXT_STATUS_TOTAL
};

typedef struct _CApplicationDependEntry {
    CString strApplicationName;
    CStringListEx strlistGroupID;
} CApplicationDependEntry, * pCApplicationDependEntry;
typedef CMap<CString,LPCTSTR,CApplicationDependEntry*,CApplicationDependEntry*&> CApplicationDependList;
typedef CMap<CString,LPCTSTR,CString,LPCTSTR> CMyMapStringToString;

// CRestrictionUIList has many CRestrictionUIEntry
// CRestrictionUIEntry has one CRestrictionList
// CRestrictionList has many CRestrictionEntry
// CRestrictionUIList->CRestrictionUIEntry->CRestrictionList->CRestrictionEntry

typedef struct _CRestrictionEntry {
    CString strFileName;
    int     iStatus;
    int     iDeletable;
    CString strGroupID;
    CString strGroupDescription;
    int     iType;
} CRestrictionEntry, *pCRestrictionEntry;
typedef CMap<CString,LPCTSTR,CRestrictionEntry*,CRestrictionEntry*&> CRestrictionList;
typedef CList<CRestrictionEntry *, CRestrictionEntry *&> CRestrictionEntryList;

typedef struct _CRestrictionUIEntry {
    int iType;
    CString strGroupID;
    CString strGroupDescription;
    CRestrictionList strlstRestrictionEntries;
} CRestrictionUIEntry, * pCRestrictionUIEntry;
typedef CMap<CString,LPCTSTR,CRestrictionUIEntry*,CRestrictionUIEntry*&> CRestrictionUIList;
typedef CList<CRestrictionUIEntry *, CRestrictionUIEntry *&> CRestrictionUIEntryList;


class CRestrictionListBox : public CListCtrl
{
    DECLARE_DYNAMIC(CRestrictionListBox);

public:
    CRestrictionListBox();

public:
    BOOL Initialize(int iColumns);
    CRestrictionEntry * GetItem(UINT nIndex);
	int InsertItem(int idx, CRestrictionEntry * p);
    int AddItem(CRestrictionEntry * pItem);
    int SetListItem(int idx, CRestrictionEntry * pItem);
    void SelectItem(int idx, BOOL bSelect = TRUE);
//	void MoveSelectedItem(int direction);

private:
    int m_iColsToDisplay;
    CString m_strAllowed;
    CString m_strProhibited;
};

void DumpRestrictionList(CRestrictionList * pMyList);
void DumpRestrictionUIEntry(CRestrictionUIEntry * pMyEntry);

// Restriction List stuff
CRestrictionEntry * CreateRestrictionEntry(CString NewstrFileName,int NewiStatus,int NewiDeletable,CString NewstrGroupID,CString NewstrGroupDescription,int NewiType);
HRESULT WriteSettingsRestrictionList(CMetaInterface * pInterface,CStringListEx * pstrlstWrite);
BOOL AddRestrictEntryToRestrictList(CRestrictionList* pRestrictList, CRestrictionEntry * pAddEntry);
HRESULT PrepRestictionListForWrite(CRestrictionList * pMyList,CStringListEx * pstrlstReturned);
HRESULT LoadMasterRestrictListWithoutOldEntry(CMetaInterface * pInterface,CRestrictionList * pMasterRestrictionList,CRestrictionUIEntry * pOldEntry);
BOOL AddRestrictListToRestrictList(CRestrictionList* pBigRestrictList, CRestrictionList * pAddEntry);
BOOL RestrictionListCopy(CRestrictionList * pRestrictionListCopyTo, CRestrictionList * pRestrictionListCopyFrom);
void CleanRestrictionList(CRestrictionList * pListToDelete);

// UI Restriction list stuff
HRESULT PrepRestictionUIListForWrite(CRestrictionUIList * pMyList,CStringListEx * pstrlstReturned);
CRestrictionUIEntry * RestrictionUIEntryMakeCopy(CRestrictionUIEntry * pRestrictionUIEntry);
HRESULT LoadMasterUIWithoutOldEntry(CMetaInterface * pInterface,CRestrictionUIList * pMasterRestrictionList,CRestrictionUIEntry * pOldEntry);
BOOL AddRestrictUIEntryToRestrictUIList(CRestrictionUIList* pRestrictUIList, CRestrictionUIEntry * pAddEntry);
void RestrictionUIEntryCopy(CRestrictionUIEntry * pRestrictionUIEntryCopyTo,CRestrictionUIEntry * pRestrictionUIEntryCopyFrom);
void DeleteRestrictionUIEntry(CRestrictionUIEntry * pEntryToDelete);
HRESULT RemoveRestrictionUIEntry(CMetaInterface * pInterface,CRestrictionUIEntry * pRestrictionUIEntry);
HRESULT ChangeStateOfEntry(CMetaInterface * pInterface,INT iDesiredState,CRestrictionUIEntry * pRestrictionUIEntry);
void CleanRestrictionUIEntry(CRestrictionUIEntry * pEntryToDelete);
void CleanRestrictionUIList(CRestrictionUIList * pListToDelete);
INT  GetRestrictUIState(CRestrictionUIEntry * pRestrictionUIEntry);
int UpdateItemFromItemInList(CRestrictionUIEntry * pMyItem,CRestrictionUIList * pMyList);
void DeleteItemFromList(CRestrictionUIEntry * pMyItem,CRestrictionUIList * pMyList);

// Application list stuff
HRESULT LoadApplicationDependList(CMetaInterface * pInterface,CApplicationDependList * pMasterList,BOOL bAddOnlyIfFriendlyNameExists);
HRESULT LoadApplicationFriendlyNames(CMetaInterface * pInterface,CMyMapStringToString * pMyList);
BOOL ReturnDependentAppsList(CMetaInterface * pInterface,CString strGroupID,CStringListEx * pstrlstReturned,BOOL bAddOnlyIfFriendlyNameExists);

// other
BOOL IsFileUsedBySomeoneElse(CMetaInterface * pInterface,LPCTSTR lpName,LPCTSTR strGroupID,CString * strUser);
BOOL IsGroupIDUsedBySomeoneElse(CMetaInterface * pInterface,LPCTSTR lpName);

HBITMAP GetBitmapFromStrip(HBITMAP hbmStrip, int nPos, int cSize);

#if defined(_DEBUG) || DBG
	#define DEBUG_PREPEND_STRING_RESTRICT _T("---")

class CDebug_RestrictList
{
public:
    CDebug_RestrictList()
	{
		m_strClassName = _T("CDebug_RestrictList");
	};
	~CDebug_RestrictList(){};

public:
	CString m_strClassName;
	void Init()
	{
		DebugList_RestrictionEntryList.RemoveAll();
		DebugList_RestrictionUIEntryList.RemoveAll();
	}

	void Add(CRestrictionEntry * pItem)
	{
		if (g_iDebugOutputLevel & DEBUG_FLAG_CRESTRICTLIST)
		{
			DebugTrace(_T("%s%s>:Add:[%3d] %p\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,DebugList_RestrictionEntryList.GetCount(),pItem);
		}
		DebugList_RestrictionEntryList.AddTail(pItem);
	}
	void Add(CRestrictionUIEntry * pItem)
	{
		if (g_iDebugOutputLevel & DEBUG_FLAG_CRESTRICTLIST)
		{
			DebugTrace(_T("%s%s>:Add:[%3d] %p\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,DebugList_RestrictionUIEntryList.GetCount(),pItem);
		}
		DebugList_RestrictionUIEntryList.AddTail(pItem);
	}

	void Del(CRestrictionEntry * pItem)
	{
		INT_PTR iCount = DebugList_RestrictionEntryList.GetCount();
		iCount--;
		POSITION pos = DebugList_RestrictionEntryList.Find(pItem);
		if (pos)
		{
			DebugList_RestrictionEntryList.RemoveAt(pos);
			if (g_iDebugOutputLevel & DEBUG_FLAG_CRESTRICTLIST)
			{
				DebugTrace(_T("%s<%s:Del:[%3d] %p\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,iCount,pItem);
			}
		}
		else
		{
			if (g_iDebugOutputLevel & DEBUG_FLAG_CRESTRICTLIST)
			{
				DebugTrace(_T("%s<%s:Del:[%3d] %p (not found)\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,iCount,pItem);
			}
		}
	}
	void Del(CRestrictionUIEntry * pItem)
	{
		INT_PTR iCount = DebugList_RestrictionUIEntryList.GetCount();
		iCount--;
		POSITION pos = DebugList_RestrictionUIEntryList.Find(pItem);
		if (pos)
		{
			DebugList_RestrictionUIEntryList.RemoveAt(pos);
			if (g_iDebugOutputLevel & DEBUG_FLAG_CRESTRICTLIST)
			{
				DebugTrace(_T("%s<%s:Del:[%3d] %p\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,iCount,pItem);
			}
		}
		else
		{
			if (g_iDebugOutputLevel & DEBUG_FLAG_CRESTRICTLIST)
			{
				DebugTrace(_T("%s<%s:Del:[%3d] %p (not found)\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,iCount,pItem);
			}
		}
	}

	void Dump(BOOL bShouldBeEmpty)
	{
		int iCount = 0;
		CString strName;
		BOOL bDisplayDump = FALSE;

		if (!(g_iDebugOutputLevel & DEBUG_FLAG_CRESTRICTLIST))
		{
			return;
		}

		if (bShouldBeEmpty)
		{
			if (DebugList_RestrictionEntryList.GetCount() || DebugList_RestrictionUIEntryList.GetCount())
			{
				DebugTrace(_T("%s%s:Dump:SHOULD BE EMPTY, BUT IT'S NOT! [%d/%d]\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,DebugList_RestrictionEntryList.GetCount(),DebugList_RestrictionUIEntryList.GetCount());
				bDisplayDump = TRUE;
			}
		}
		else
		{
			bDisplayDump = TRUE;
		}

		if (bDisplayDump)
		{
			DebugTrace(_T("%s%s:Dump:start\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT);

			CRestrictionEntry * pItemFromList1 = NULL;
			POSITION pos = DebugList_RestrictionEntryList.GetHeadPosition();
			while (pos)
			{
				pItemFromList1 = DebugList_RestrictionEntryList.GetNext(pos);
				if (pItemFromList1)
				{
					iCount++;
					DebugTrace(_T("%s%s:Dump:[%3d] %p (%s)\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,iCount,pItemFromList1,pItemFromList1->strFileName);
				}
			}

			DebugTrace(_T("%s%s:Dump:--------------\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT);

			iCount = 0;
			CRestrictionUIEntry * pItemFromList2 = NULL;
			pos = DebugList_RestrictionUIEntryList.GetHeadPosition();
			while (pos)
			{
				pItemFromList2 = DebugList_RestrictionUIEntryList.GetNext(pos);
				if (pItemFromList2)
				{
					iCount++;
					DebugTrace(_T("%s%s:Dump:[%3d] %p (%s)\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT,iCount,pItemFromList2,pItemFromList2->strGroupID);
				}
			}

			DebugTrace(_T("%s%s:Dump:end\r\n"),m_strClassName,DEBUG_PREPEND_STRING_RESTRICT);
		}
	}

private:
	CRestrictionEntryList DebugList_RestrictionEntryList;
	CRestrictionUIEntryList DebugList_RestrictionUIEntryList;
};
#endif //DEBUG

#endif // __RESTRICT_LIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by inetmgr.rc
//
#define IDI_INETMGR                     1
#define IDI_SHUTDOWN                    2
#define IDB_RDATA_TB                    5
#define IDB_RDATA_MB                    6
#define IDB_RDATA_WB                    7
#define IDB_INETMGR16                   10
#define IDB_INETMGR32                   11
#define IDB_ACCESS                      12
#define IDB_BACKUPS                     22
#define IDR_INETMGR                     30
#define IDB_TOOLBAR                     46
#define IDI_IP_SECURITY                 47
#define IDI_SECURE                      48
#define IDB_BUTTONDND                   49
#define IDB_BUTTONDNF                   50
#define IDB_BUTTONDNU                   51
#define IDB_BUTTONDNX                   52
#define IDB_BUTTONUPD                   53
#define IDB_BUTTONUPF                   54
#define IDB_BUTTONUPU                   55
#define IDB_BUTTONUPX                   56
#define IDD_APP_POOL_GENERAL            58
#define IDD_APP_POOL_RECYCLE            59
#define IDB_WIZ_WEB_LEFT                60
#define IDB_WIZ_WEB_HEAD                61
#define IDB_SMALL_ROOT                  62
#define IDB_LARGE_ROOT                  63
#define IDD_WEBSVCEXT_REQUIREDFILES     66
#define IDD_WEBSVCEXT_GENERAL           67
#define IDD_ADD_FILE                    68
#define IDD_WEBSVCEXT_ADDNEW            69
#define IDD_WEBSVCEXT_ADDBYAPP          70
#define IDD_CONFIRM_DEPENDENT_APPS      71
#define IDS_PROJNAME                    100
#define IDS_INETMGR_DESC                101
#define IDS_INETMGR_PROVIDER            102
#define IDS_EXECUTABLE_PATH             103
#define IDS_ROOT_NODE                   104
#define IDS_LOCAL_COMPUTER              105
#define IDS_SVC_WEB                     106
#define IDS_SVC_FTP                     107
#define IDS_UNKNOWN                     108
#define IDS_APP_NAME                    109
#define IDS_AUTO_HISTORY_RESTORE_NAME   110
#define IDS_MENU_NEWFTPSITE_FROMFILE    111
#define IDS_MENU_NEWFTPVDIR_FROMFILE    112
#define IDS_MENU_NEWWEBSITE_FROMFILE    113
#define IDS_MENU_NEWWEBVDIR_FROMFILE    114
#define IDS_MENU_TT_NEWFTPSITE_FROMFILE 115
#define IDS_MENU_TT_NEWFTPVDIR_FROMFILE 116
#define IDS_FAT_DRIVE_WARNING           117
#define IDS_SAVE_DATA_NO_NEED           118
#define IDS_VERBS                       119
#define IDS_ALL                         120
#define IDS_WEB_SVC_EXT_CONTAINER       121
#define IDS_WEBSVCEXT_CONTAINER         121
#define IDS_RESULT_SERVICE_ICON         122
#define IDS_RESULT_SERVICE_WEBSVCEXT    123
#define IDS_ALLOWED                     124
#define IDS_PROHIBITED                  125
#define IDS_CUSTOM                      126
#define IDS_INUSE                       127
#define IDS_NOTINUSE                    128
#define IDI_FILE_TYPES                  129
#define IDS_MENU_WEBEXT_ALLOW           129
#define IDI_DEFAULT_PROPERTIES          130
#define IDS_CONNECTION_LIMIT            130
#define IDS_WRN_CONNECTION_LIMIT        131
#define IDS_APPLICATION_POOL            132
#define IDS_NO_MACHINE_PROPS            133
#define IDS_CONFIRM_DELETE_ITEMS        134
#define IDS_SUCCESS                     135
#define IDS_RECONNECT_WARNING           136
#define IDS_CONFIRM_DISCONNECT          137
#define IDS_YES                         138
#define IDS_NO                          139
#define IDS_IIS_START                   140
#define IDS_IIS_STOP                    141
#define IDS_IIS_SHUTDOWN                142
#define IDS_IIS_RESTART                 143
#define IDS_IIS_START_DETAILS           144
#define IDS_IIS_STOP_DETAILS            145
#define IDS_IIS_SHUTDOWN_DETAILS        146
#define IDS_IIS_RESTART_DETAILS         147
#define IDS_TCPIP                       148
#define IDS_SAVE_DATA_CONFIG_FILE       148
#define IDS_NETBIOS                     149
#define IDS_MENU_TT_NEWWEBSITE_FROMFILE 149
#define IDS_BACKUP_LOCATION             150
#define IDS_BACKUP_VERSION              151
#define IDS_BACKUP_DATE                 152
#define IDS_RESTORE_CONFIRM             153
#define IDS_BACKUP_BAD_NAME             154
#define IDS_STARTED                     155
#define IDS_STOPPED                     156
#define IDS_PAUSED                      157
#define IDS_IP_ALL_UNASSIGNED           158
#define IDS_ENTER_PASSWORD              159
#define IDS_SHUTDOWN_PROGRESS           160
#define IDS_RESOLVE_PASSWORD            161
#define IDS_IMPERSONATION_PROMPT        162
#define IDS_IMPERSONATION               163
#define IDS_MENU_REM_IMPERS             164
#define IDS_MENU_TT_REM_IMPERS          165
#define IDS_REMOVE_IMPERSONATION        166
#define IDS_VERSION_FMT                 167
#define IDS_MENU_SAVE_DATA              168
#define IDS_MENU_TT_NEWWEBVDIR_FROMFILE 169
#define IDS_MENU_WEBEXT_PROHIBIT        170
#define IDS_MENU_WEBEXT_REMOVE          171
#define IDS_APP_DEPEND_WARN1            171
#define IDS_FILENAME                    172
#define IDS_MENU_WEBEXT_ALLOW_FORMAT    173
#define IDS_MENU_WEBEXT_PROHIBIT_FORMAT 174
#define IDS_STRING175                   175
#define IDS_MENU_WEBEXT_PROPERTIES_FORMAT 175
#define IDS_MENU_WEBEXT_ALLOW_DISABLED_FORMAT 176
#define IDS_MENU_WEBEXT_PROHIBIT_DISABLED_FORMAT 177
#define IDS_MENU_WEBEXT_ADD1_FORMAT     178
#define IDS_MENU_WEBEXT_ADD2_FORMAT     179
#define IDS_USERS_TOTAL                 180
#define IDS_CONNECTED_USERS             181
#define IDS_FROM                        182
#define IDS_TIME                        183
#define IDS_DISCONNECT_ERR              184
#define IDS_CONFIRM_DISCONNECT_USER     185
#define IDS_CONFIRM_DISCONNECT_ALL      186
#define IDS_FTP_SERVICE_NOT_STARTED     187
#define IDS_WRN_PWSYNC                  188
#define IDS_ERR_COMPRESS_DIRECTORY      189
#define IDS_NO_ACL_WARNING              190
#define IDS_COMPRESS_WARNING            191
#define IDS_MENU_PERMISSION             192
#define IDS_MENU_WEBEXT_PROHIBIT_ALL_FORMAT 193
#define IDS_MENU_WEBEXT_HELP_FORMAT     194
#define IDS_ALLOW_UNSAFE_CGI_MSG        195
#define IDS_ALLOW_UNSAFE_ISAPI_MSG      196
#define IDS_PROHIBIT_DEPENDENCY_WARN    197
#define IDS_ITEM_NOT_REMOVABLE          198
#define IDS_MENU_WEBEXT_GIF_FORMAT      199
#define IDS_MENU_WEBEXT_ICON_FORMAT     199
#define IDS_MENU_WEBEXT_PROPERTIES_DISABLED_FORMAT 200
#define IDD_TIME_PICKER                 201
#define IDC_DISK_UNLIM_EDIT             201
#define IDS_MENU_WEBEXT_TASKS           201
#define IDC_INMEM_UNLIM_SPIN            202
#define IDC_DISK_UNLIM_SPIN             202
#define IDS_WEBSVCEXT_PROP_PRENAME      202
#define IDC_CACHE_SIZE_SPIN             203
#define IDS_APP_DEPEND_WARN2            203
#define IDC_ENG_CACHED_SPIN             204
#define IDS_WEBSVCEXT_NOT_UNIQUE        204
#define IDS_WEBSVCEXT_INVALID_FILENAME_CHARS 205
#define IDS_WEBSVCEXT_INVALID_FILENAME_FORMAT 206
#define IDC_TIMEOUT_SPIN                207
#define IDS_WEBSVCEXT_INVALID_CHARS     207
#define IDS_WEBSVCEXT_INVALID_CHARS_FILENAME 207
#define IDS_WEBSVCEXT_INVALID_CHARSET   207
#define IDC_TIMESPAN_SPIN               208
#define IDS_WEBSVCEXT_PROP_CAPTION      208
#define IDC_REQUESTS_SPIN               209
#define IDS_PERF_MASTER_BANDWIDTH       209
#define IDS_CLOSE_PROPERTY_SHEET        210
#define IDC_ASPTIMEOUT_SPIN             211
#define IDS_SERVICE_DISABLED            211
#define IDC_TIME_PICKER                 212
#define IDS_SERVICE_RUNNING             212
#define IDS_SERVICE_STOPPED             213
#define IDC_INSERT                      214
#define IDS_SERVICE_PAUSED              214
#define IDC_EDIT_EXE                    215
#define IDS_SERVICE_STOP_PENDING        215
#define IDC_REMOVE_EXE                  216
#define IDS_SERVICE_PAUSE_PENDING       216
#define IDC_MOVE_UP                     217
#define IDS_SERVICE_CONT_PENDING        217
#define IDC_MOVE_DOWN                   218
#define IDS_SERVICE_START_PENDING       218
#define IDC_LIST_EXE                    219
#define IDS_MENU_SERVICE_START          219
#define IDS_MENU_SERVICE_STOP           220
#define IDS_MENU_SERVICE_ENABLE         221
#define IDS_MENU_TT_SERVICE_START       222
#define IDS_MENU_TT_SERVICE_STOP        223
#define IDS_MENU_TT_SERVICE_ENABLE      224
#define IDS_NO_START_SERVICE_DISABLED   225
#define IDS_NO_START_SERVICE_MANUAL     226
#define IDS_CLOSE_PROPERTY_SHEET_WEBSVCEXT 227
#define IDS_MENU_WEBEXT_ALLOW_JAVA_SAFE 228
#define IDS_MENU_WEBEXT_PROHIBIT_JAVA_SAFE 229
#define IDS_ERR_PORT_USED               230
#define IDS_ERR_PATH_HAS_SPACES_REQUIRE_QUOTES 231
#define IDS_ERR_DOMAIN_NAME_INVALID     232
#define IDS_ERR_DOMAIN_NAME_ALL_NUMERIC 233
#define IDS_CLOSE_ALL_PROPERTY_SHEET_DISCONNECT 234
#define IDS_MUST_SELECT_APP_POOL        235
#define IDS_DISABLED_SERVICE_FMT        236
#define IDS_EXECUTABLE_EXE_DLL_MASK     237
#define IDS_CLOSE_PROPERTY_SHEET_WEBSVCEXT2 238
#define IDB_RDATA_TBT                   256
#define IDS_MENU_CONNECT                300
#define IDS_MENU_DISCOVER               301
#define IDS_MENU_PROPERTIES             302
#define IDS_MENU_START                  303
#define IDS_MENU_STOP                   304
#define IDS_MENU_PAUSE                  305
#define IDS_MENU_IMPERSONATE            306
#define IDS_MENU_EXPLORE                307
#define IDS_MENU_OPEN                   308
#define IDS_MENU_BROWSE                 309
#define IDS_MENU_NEWINSTANCE            310
#define IDS_MENU_NEWVROOT               311
#define IDS_MENU_EX_NEWINSTANCE         312
#define IDS_MENU_TT_IMPERSONATE         313
#define IDS_MENU_TASKPAD                314
#define IDS_MENU_DISCONNECT             315
#define IDS_MENU_PROPERTIES_JAVA_SAFE   316
#define IDS_MENU_BACKUP                 317
#define IDS_MENU_SHUTDOWN_IIS           318
#define IDS_MENU_SECURE                 319
#define IDS_MENU_TT_CONNECT             320
#define IDS_MENU_TT_DISCOVER            321
#define IDS_MENU_TT_PROPERTIES          322
#define IDS_MENU_TT_START               323
#define IDS_MENU_TT_STOP                324
#define IDS_MENU_TT_PAUSE               325
#define IDS_MENU_TT_SECURE              326
#define IDS_MENU_TT_EXPLORE             327
#define IDS_MENU_TT_OPEN                328
#define IDS_MENU_TT_BROWSE              329
#define IDS_MENU_TT_NEWINSTANCE         330
#define IDS_MENU_TT_NEWVROOT            331
#define IDS_MENU_TT_EX_NEWINSTANCE      332
#define IDS_MENU_TT_DISCONNECT          333
#define IDS_PERM_SUCCESS                334
#define IDS_MENU_TT_BACKUP              335
#define IDS_MENU_TT_TASKPAD             336
#define IDS_MENU_TT_SHUTDOWN_IIS        338
#define IDS_MENU_DS_NEWINSTANCE         339
#define IDS_MENU_DS_NEWVROOT            340
#define IDS_MENU_TT_PERMISSION          341
#define IDS_MENU_TT_SAVE_DATA           342
#define IDS_MENU_IMPORT_CONFIG_WIZARD   343
#define IDS_MENU_NEWAPPPOOL_FROMFILE    343
#define IDS_MENU_EXPORT_CONFIG_WIZARD   344
#define IDS_SUMMARY_GRANTED             345
#define IDS_SUMMARY_DENIED              346
#define IDS_MENU_TT_IMPORT_CONFIG_WIZARD 347
#define IDS_MENU_TT_NEWAPPPOOL_FROMFILE 347
#define IDS_MENU_TT_EXPORT_CONFIG_WIZARD 348
#define IDS_SPECIFIC_GRANTED            349
#define IDS_SPECIFIC_DENIED             350
#define IDS_PERMWIZ                     351
#define IDS_NO_TEMPLATES                352
#define IDS_RESULT_COMPUTER_NAME        370
#define IDS_RESULT_COMPUTER_LOCAL       371
#define IDS_RESULT_SERVICE_DESCRIPTION  373
#define IDS_RESULT_SERVICE_DOMAIN_NAME  374
#define IDS_RESULT_SERVICE_IP_ADDRESS   375
#define IDS_RESULT_SERVICE_TCP_PORT     376
#define IDS_RESULT_SERVICE_STATE        377
#define IDS_RESULT_NAME                 378
#define IDS_RESULT_PATH                 379
#define IDS_RESULT_ATTRIBUTES           380
#define IDS_RESULT_STATUS               381
#define IDS_RESULT_COMPUTER_VERSION     382
#define IDS_REPLACE_MIME                383
#define IDS_REMOVE_MIME                 384
#define IDS_TAB_HOME_DIRECTORY          385
#define IDS_TAB_VIRTUAL_DIRECTORY       386
#define IDS_PATH                        387
#define IDS_SHARE                       388
#define IDS_DIRECTORY_MASK              392
#define IDS_UNC_MASK                    393
#define IDS_ACCESS                      394
#define IDS_IP_ADDRESS_SUBNET_MASK      395
#define IDS_DENY                        396
#define IDS_GRANT                       397
#define IDS_PROMPT_NETWORK_ID           398
#define IDS_PROMPT_IP_ADDRESS           399
#define IDS_PROMPT_DOMAIN               400
#define IDS_DOMAIN_PERF                 401
#define IDS_IP_INVALID                  402
#define IDS_INVALID_DOMAIN_NAME         403
#define IDS_DUPLICATE_ENTRY             404
#define IDS_PENDING                     405
#define IDS_ILLEGAL_ALIAS_CHARS         406
#define IDS_DENIED                      407
#define IDS_GRANTED                     408
#define IDS_SUMMARY_NONE                409
#define IDS_PERMISSIONS                 410
#define IDS_PERMS_READ                  411
#define IDS_PERMS_WRITE                 412
#define IDS_PERMS_SCRIPT                413
#define IDS_PERMS_EXECUTE               414
#define IDS_NEW_FTP_VDIR_WIZARD         415
#define IDS_ERR_COMMA_IN_REDIRECT       415
#define IDS_NEW_FTP_SITE_WIZARD         416
#define IDS_SITE_FTP_PERMS_TITLE        417
#define IDS_SITE_FTP_PERMS_SUBTITLE     418
#define IDS_SITE_FTP_SECURITY_TITLE     419
#define IDS_SITE_FTP_SECURITY_SUBTITLE  420
#define IDS_SITE_FTP_WELCOME            421
#define IDS_SITE_FTP_BODY               422
#define IDS_SITE_FTP_SUCCESS            423
#define IDS_TCP_SSL_PART                424
#define IDS_ERR_BINDING                 425
#define IDS_MMM_IP_ADDRESS              426
#define IDS_MMM_TCP_PORT                427
#define IDS_MMM_DOMAIN_NAME             428
#define IDS_MMM_SSL_PORT                429
#define IDS_MMM_NA                      430
#define IDS_DEFAULT                     431
#define IDS_EDIT_MMM_TITLE              432
#define IDS_EDIT_SSL_MMM_TITLE          433
#define IDS_TCP_PORT                    434
#define IDS_SSL_PORT                    435
#define IDS_NO_PORT                     436
#define IDS_ERR_PORT_IN_USE_TCP         437
#define IDS_ERR_PORT_IN_USE_SSL         438
#define IDS_WEB_MASTER                  439
#define IDS_APPROOT_FMT                 440
#define IDS_BUTTON_DISABLE              441
#define IDS_BUTTON_ENABLE               442
#define IDS_BUTTON_CREATE               443
#define IDS_BUTTON_REMOVE               444
#define IDS_TAB_DIR                     445
#define IDS_TAB_FILE                    446
#define IDS_PROMPT_DIR                  447
#define IDS_PROMPT_UNC                  448
#define IDS_PROMPT_REDIRECT             449
#define IDS_ERR_APP                     451
#define IDS_APPROOT_UNKNOWN             452
#define IDS_REDIRECT_MASK               453
#define IDS_DEF_APP                     454
#define IDS_WRN_WRITE_EXEC              455
#define IDS_WRN_UNLOAD_POOP             456
#define IDS_COMBO_INPROC                457
#define IDS_COMBO_POOLEDPROC            458
#define IDS_COMBO_OUTPROC               459
#define IDS_PERMISSIONS_NONE            460
#define IDS_PERMISSIONS_SCRIPT          461
#define IDS_PERMISSIONS_EXECUTE         462
#define IDS_RADIO_FILE                  463
#define IDS_RADIO_VDIR                  464
#define IDS_RADIO_DIR                   465
#define IDS_TAB_FILE_SECURITY           466
#define IDS_TAB_DIR_SECURITY            467
#define IDS_WRN_DIGEST                  468
#define IDS_WRN_NO_AUTH                 469
#define IDS_OCX_CERTMAP                 470
#define IDS_CTL_LOCAL_ONLY              471
#define IDS_CTL_NEW                     472
#define IDS_CTL_DESCRIPTION             473
#define IDS_CTL_UNNAMED                 474
#define IDS_STATUS                      475
#define IDS_FILTER_NAME                 476
#define IDS_FILTER_EXECUTABLE           477
#define IDS_PRIORITY                    478
#define IDS_HIGH                        479
#define IDS_MEDIUM                      480
#define IDS_LOW                         481
#define IDS_UNKNOWN_PRIORITY            482
#define IDS_DISABLED                    483
#define IDS_LOADED                      484
#define IDS_UNLOADED                    485
#define IDS_NOT_COMMITTED               486
#define IDS_ENABLE                      487
#define IDS_MASTER_FILTERS              488
#define IDS_INSTANCE_FILTERS            489
#define IDS_EXECUTABLE_MASK             490
#define IDS_ISAPI_CGI_MASK              491
#define IDS_FILTER_MASK                 492
#define IDS_ERR_DUP_FILTER              493
#define IDS_FILE_PROMPT                 494
#define IDS_URL_PROMPT                  495
#define IDS_NOT_REL_URL                 496
#define IDS_DEFAULT_ERROR               497
#define IDS_FILE                        498
#define IDS_URL                         499
#define IDS_HTTP_ERROR                  500
#define IDS_OUTPUT_TYPE                 501
#define IDS_CONTENTS                    502
#define IDS_BAD_ERROR                   503
#define IDS_NO_DEF_ERRORS               504
#define IDS_ERR_EXPIRE_RANGE            505
#define IDS_ERR_DUP_HEADER              506
#define IDS_MINUTES                     507
#define IDS_DAYS                        508
#define IDS_INSTANCE_DEF_FMT            509
#define IDS_INSTANCE_PORT_FMT           510
#define IDS_APP_POOLS                   511
#define IDS_MENU_NEWFTPSITE             512
#define IDS_MENU_NEWWEBSITE             513
#define IDS_MENU_NEWAPPPOOL             514
#define IDS_MENU_TT_NEWFTPSITE          515
#define IDS_MENU_TT_NEWWEBSITE          516
#define IDS_MENU_TT_NEWAPPPOOL          517
#define IDS_MENU_DS_NEWFTPSITE          518
#define IDS_MENU_DS_NEWWEBSITE          519
#define IDS_MENU_DS_NEWAPPPOOL          520
#define IDS_CONFIRM_DELETE              521
#define IDS_FTP_NEW_SITE_WIZARD         522
#define IDS_FTP_NEW_VDIR_WIZARD         523
#define IDS_FTP_NEW_SITE_WELCOME        524
#define IDS_FTP_NEW_SITE_BODY           525
#define IDS_FTP_NEW_SITE_SUCCESS        526
#define IDS_FTP_NEW_SITE_FAILURE        527
#define IDS_FTP_NEW_SITE_PERMS_TITLE    528
#define IDS_FTP_NEW_SITE_PERMS_SUBTITLE 529
#define IDS_FTP_NEW_SITE_SECURITY_TITLE 530
#define IDS_FTP_NEW_SITE_SECURITY_SUBTITLE 531
#define IDS_MENU_RECYCLE                532
#define IDS_MENU_TT_RECYCLE             533
#define IDS_ASK_TO_RESTART              534
#define IDS_LOCALSYSTEM                 535
#define IDS_LOCALSERVICE                536
#define IDS_NETSERVICE                  537
#define IDS_WEB_NEW_SITE_WIZARD         538
#define IDS_WEB_NEW_VDIR_WIZARD         539
#define IDS_WEB_NEW_SITE_SECURITY_SUBTITLE 540
#define IDS_WEB_NEW_SITE_SECURITY_TITLE 541
#define IDS_WEB_NEW_SITE_PERMS_TITLE    542
#define IDS_WEB_NEW_SITE_PERMS_SUBTITLE 543
#define IDS_EXECUTE_AND_WRITE_WARNING   544
#define IDS_ERR_ALIAS_NOT_UNIQUE        545
#define IDS_WEB_NEW_SITE_WELCOME        546
#define IDS_WEB_NEW_SITE_BODY           547
#define IDS_WEB_NEW_SITE_SUCCESS        548
#define IDS_WEB_NEW_SITE_FAILURE        549
#define IDS_WEB_NEW_VDIR_WELCOME        550
#define IDS_WEB_NEW_VDIR_BODY           551
#define IDS_MENU_NEWFTPVDIR             552
#define IDS_MENU_TT_NEWFTPVDIR          553
#define IDS_MENU_DS_NEWFTPVDIR          554
#define IDS_FTP_NEW_VDIR_WELCOME        555
#define IDS_FTP_NEW_VDIR_BODY           556
#define IDS_FTP_NEW_VDIR_SUCCESS        557
#define IDS_FTP_NEW_VDIR_FAILURE        558
#define IDS_MENU_NEWWEBVDIR             559
#define IDS_MENU_TT_NEWWEBVDIR          560
#define IDS_MENU_DS_NEWWEBVDIR          561
#define IDS_WEB_NEW_VDIR_SUCCESS        562
#define IDS_WEB_NEW_VDIR_FAILURE        563
#define IDS_PWIZ_WELCOME                564
#define IDS_CLOSE_ALL_PROPERTY_SHEET_REFRESH 564
#define IDS_PWIZ_BODY                   565
#define IDS_PWIZ_SUCCESS                566
#define IDS_PWIZ_FAILURE                567
#define IDS_AUTHENTICATION_METHODS      568
#define IDS_AUTHENTICATION_ANONYMOUS    569
#define IDS_AUTHENTICATION_NO_ANONYMOUS 570
#define IDS_REQUIREDFILES_TITLE         570
#define IDS_AUTHENTICATION_ANONYMOUS_ONLY 571
#define IDS_AUTHENTICATION_BASIC        572
#define IDS_AUTHENTICATION_NT           573
#define IDS_AUTHENTICATION_DIGEST       574
#define IDS_ADDRESS_RESTRICTIONS        575
#define IDS_ACL_ADMINS                  576
#define IDS_ACL_EV_READ                 577
#define IDS_ACL_EV_WRITE                578
#define IDS_ACL_EV_EXEC                 579
#define IDS_ACL_SUMMARY                 580
#define IDS_ACL_NONE                    581
#define IDS_ACL_REPLACEMENT             582
#define IDS_ACL_ADDED                   583
#define IDS_ACL_ADMIN                   584
#define IDS_ACL_EVR                     585
#define IDS_ACL_READ                    586
#define IDS_ACL_READ_CONTROL            587
#define IDS_ACL_READ_ATTRIB             588
#define IDS_ACL_READ_PROP               589
#define IDS_ACL_WRITE                   590
#define IDS_ACL_APPEND                  591
#define IDS_ACL_DELETE                  592
#define IDS_ACL_WRITE_ATTRIB            593
#define IDS_ACL_WRITE_PROP              594
#define IDS_ACL_EXECUTE                 595
#define IDS_ACL_LIST_OBJECT             596
#define IDS_HOURS                       597
#define IDS_WSAHOST_NOT_FOUND           598
#define IDS_DIR_BROWSE_ON               599
#define IDS_DIR_BROWSE_OFF              600
#define IDS_LOAD_DEFAULT_ON             601
#define IDS_LOAD_DEFAULT_OFF            602
#define IDS_DIRECTORY_BROWSE            603
#define IDS_REDIRECT_FORMAT             604
#define IDS_WARNING_DOMAIN_NAME         605
#define IDS_STOPPED_SITE_FMT            606
#define IDS_PAUSED_SITE_FMT             607
#define IDS_HELPFILE                    608
#define IDS_ERR_NONEMPTY_APPPOOL        609
#define IDS_UPGRADE_TO_IIS6             610
#define IDS_TOTAL_SITE_CONNECTIONS      611
#define IDS_DEFAULT_APP_POOL            612
#define IDS_DEFAULT_APP_POOL_NAME       613
#define IDS_ERR_INVALID_PATH_CHARS      614
#define IDS_ERR_INVALID_FILTER_NAME     615
#define IDS_APPSHEET_TITLE              616
#define IDS_CONFIRM_REMOVE_MAP          617
#define IDS_ERR_NOUNC                   618
#define IDS_ERR_NOREMOTE                619
#define IDS_ERR_FILENOTEXISTS           620
#define IDS_ERR_USEDEXT                 621
#define IDS_EXTENSION                   622
#define IDS_ERR_DUP_POOLID              623
#define IDS_ERR_INVALID_POOLID_CHARS    624
#define IDS_BAD_ERROR_URL               625
#define IDS_ERR_BADEXT                  626
#define IDS_ERR_PATH_NO_CLOSING_QUOTE   627
#define IDS_ERR_INVALID_DOCNAME_CHARS   628
#define IDS_RESULT_SERVICE_USEDBY       629
#define IDS_RESULT_SERVICE_ID           630
#define IDS_SYSIDENT_CONFIRM            631
#define IDS_ERR_USEDPATH                632
#define IDS_INVALID_POOL_ID             633
#define IDS_MENU_WEBEXT_CONTAINER_ADD1  634
#define IDS_MENU_WEBEXT_CONTAINER_ADD2  635
#define IDS_MENU_WEBEXT_CONTAINER_PROHIBIT_ALL 636
#define IDS_MENU_TT_WEBEXT_CONTAINER_ADD1 637
#define IDS_MENU_TT_WEBEXT_CONTAINER_ADD2 638
#define IDS_MENU_TT_WEBEXT_CONTAINER_PROHIBIT_ALL 639
#define IDS_PROHIBIT_ALL_EXTENSIONS_MSG 640
#define IDS_PROHIBIT_QUESTION           641
#define IDS_WEBSVCEXT_UNKNOWN_ISAPI     642
#define IDS_WEBSVCEXT_UNKNOWN_CGI       643
#define IDS_WEBSVCEXT_ID_NOT_UNIQUE     644
#define IDS_WEBSVCEXT_INVALID_NAME_CHARS 645
#define IDS_RESULT_SERVICE_SSL_PORT     646
#define IDS_EXECUTABLE_DLL_MASK         647
#define IDS_MENU_WEBEXT_CONTAINER_ADD1_JAVA_SAFE 648
#define IDS_MENU_WEBEXT_CONTAINER_ADD2_JAVA_SAFE 649
#define IDS_MENU_WEBEXT_CONTAINER_PROHIBIT_ALL_JAVA_SAFE 650
#define IDS_MENU_WEBEXT_CONTAINER_HELP_JAVA_SAFE 651
#define IDC_EDIT_DESCRIPTION            1001
#define IDC_STATIC_PASSWORD2            1002
#define IDC_EDIT_PASSWORD2              1003
#define IDC_STATIC_PROMPT2              1004
#define IDC_EDIT_MAX_NETWORK_USE        1009
#define IDC_MAX_BANDWIDTH               1009
#define IDC_CHECK_LIMIT_NETWORK_USE     1015
#define IDC_EDIT_PATH                   1015
#define IDC_STATIC_MAX_NETWORK_USE      1016
#define IDC_EDIT_REDIRECT               1016
#define IDC_STATIC_KBS                  1017
#define IDC_BUTTON_ADD_SSL              1018
#define IDC_LIST_ERRORS                 1019
#define IDC_BUTTON_SET_TO_DEFAULT       1020
#define IDS_HTML_MASK                   1022
#define IDS_NO_ACTION                   1023
#define IDS_THROTTLE_BACK               1024
#define IDS_TURN_ON_TRACING             1025
#define IDS_SHUTDOWN                    1026
#define IDS_STRING1027                  1027
#define IDS_MENU_TT_WEBEXT_CONTAINER_HELP 1027
#define IDS_MENU_WEBEXT_CONTAINER_HELP  1027
#define IDS_WEBSVCEXT_INVALID_PERCENT_WARNING 1028
#define IDS_INVALID_MANIFEST_NAME       1029
#define IDC_BUTTON_FILE_TYPES           1031
#define IDC_STATIC_THROTTLE_PROMPT      1038
#define IDS_ERR_DOCUMENTS               1039
#define IDC_STATIC_TAB1                 1046
#define IDS_ERR_COMPLETE_PATH           1047
#define IDC_STATIC_TAB2                 1047
#define IDS_ERR_NO_COMPLETE_PATH        1053
#define IDC_LIST_BACKUPS                1057
#define IDC_BUTTON_CREATE               1058
#define IDC_BUTTON_RESTORE              1059
#define IDC_BUTTON_DELETE               1060
#define IDC_EDIT_BACKUP_NAME            1061
#define IDC_COMBO_RESTART               1062
#define IDC_STATIC_DETAILS              1063
#define IDC_PROGRESS_SHUTDOWN           1064
#define IDC_STATIC_PROGRESS             1065
#define IDS_DUPLICATE_DOC               1066
#define IDC_SERVERNAME                  1066
#define IDS_NOT_LOCAL_FOOTER            1067
#define IDC_RADIO_INHERIT               1067
#define IDC_RADIO_TEMPLATE              1068
#define IDC_BUTTON_EDIT_ANONYMOUS       1068
#define IDC_LIST_TEMPLATES              1069
#define IDC_BUTTON_REMOVE_SSL           1069
#define IDC_RADIO_ACL_MAXIMUM           1070
#define IDC_RADIO_ACL_MINIMUM           1071
#define IDC_RADIO_NO_ACL                1072
#define IDC_LIST_SUMMARY                1073
#define IDC_CHECK_CONNECT_AS            1074
#define IDC_STATIC_USER_NAME            1075
#define IDC_EDIT_USER_NAME              1076
#define IDC_BUTTON_BROWSE               1077
#define IDC_LIST_MIME_TYPES             1078
#define IDC_EDIT_EXTENSION              1079
#define IDC_EDIT_ALIAS                  1079
#define IDC_BUTTON_NEW_TYPE             1080
#define IDC_STATIC_EXTENSION            1081
#define IDC_BASDOM_COMBO                1081
#define IDC_EDIT_CONTENT_TYPE           1082
#define IDC_STATIC_CONTENT_TYPE         1083
#define IDC_BASDOM                      1083
#define IDC_BUTTON_EDIT_MIME            1084
#define IDC_BASDOM_SELECT               1084
#define IDC_BUTTON_REMOVE_MIME          1085
#define IDC_COMPAT_MODE                 1085
#define IDC_REALM                       1085
#define IDC_EDIT_EXTENT                 1086
#define IDC_ENABLE_MB_EDIT              1086
#define IDC_REALM_SELECT                1086
#define IDC_EDIT_MIME                   1087
#define IDC_FRIENDLY_NAME               1087
#define IDC_STATIC_GROUP_MIME_DETAILS   1088
#define IDC_USE_TEMPLATE                1088
#define IDC_USE_MASTER                  1088
#define IDC_TEMPLATE_LIST               1089
#define IDC_USE_CUSTOM                  1090
#define IDC_VMEMORY_LIMIT               1091
#define IDC_VMEMORY_SPIN                1092
#define IDC_TEMPLATE_NAME               1093
#define IDC_UMEMORY_LIMIT               1093
#define IDC_UMEMORY_SPIN                1094
#define IDC_PERF_IDLE_TIMEOUT           1095
#define IDC_IDLETIME_SPIN               1096
#define IDC_IDLETIME                    1097
#define IDC_LIMIT_QUEUE                 1098
#define IDC_QUEUESIZE                   1099
#define IDC_QUEUESIZE_SPIN              1100
#define IDC_ENABLE_CPU_ACCOUNTING       1101
#define IDC_CPU_USE                     1102
#define IDC_CPU_USE_SPIN                1103
#define IDC_REFRESHTIME                 1104
#define IDC_REFRESHTIME_SPIN            1105
#define IDC_EXCEED_ACTION               1106
#define IDC_MAXPROCESSES                1107
#define IDC_MAXPROCESSES_SPIN           1108
#define IDC_ENABLE_PING                 1109
#define IDC_PINGINTERVAL                1110
#define IDC_PINGINTERVAL_SPIN           1111
#define IDC_ENABLE_RAPID_FAIL           1112
#define IDC_CRASHES_COUNT               1113
#define IDC_CRASHES_COUNT_SPIN          1114
#define IDC_CHECK_TIME                  1115
#define IDC_CHECK_TIME_SPIN             1116
#define IDC_STARTUP_LIMIT               1117
#define IDC_CHECK_READ                  1118
#define IDC_STARTUP_LIMIT_SPIN          1118
#define IDC_CHECK_WRITE                 1119
#define IDC_SHUTDOWN_LIMIT              1119
#define IDC_CHECK_LOG_ACCESS            1120
#define IDC_SHUTDOWN_LIMIT_SPIN         1120
#define IDC_CHECK_DIRECTORY_BROWSING_ALLOWED 1121
#define IDC_ENABLE_DEBUG                1121
#define IDC_CHECK_INDEX                 1122
#define IDC_FILE_NAME                   1122
#define IDC_CHECK_AUTHOR                1123
#define IDC_BROWSE                      1123
#define IDC_PREDEFINED                  1124
#define IDC_SYSTEM_ACCOUNTS             1125
#define IDC_CONFIGURABLE                1126
#define IDC_USER_NAME                   1127
#define IDC_USER_PASS                   1128
#define IDC_UNINSTALL_PSHED             1129
#define IDC_UNLIMITED_CONN              1130
#define IDC_LIMITED_CONN                1131
#define IDC_CONNECTIONS_COUNT           1132
#define IDC_STATIC_CONN                 1133
#define IDC_CONNECTIONS_COUNT_SPIN      1135
#define IDC_SPIN_MAX_CONNECTIONS        1135
#define IDC_MAX_BANDWIDTH_SPIN          1136
#define IDC_STATIC_CONN_TXT             1137
#define IDC_LOG_UTF8                    1138
#define IDC_EDIT_POOL_NAME              1140
#define IDC_EDIT_POOL_ID                1142
#define IDC_TEMPLATES                   1143
#define IDC_USE_POOL                    1144
#define IDC_POOLS                       1145
#define IDC_STATIC_PSHED_REQUIRED       1146
#define IDC_PARAMETERS                  1150
#define IDC_PASSPORT                    1152
#define IDC_PASSPORT_CONFIGURE          1153
#define IDC_STATIC_DOMAIN               1154
#define IDC_STATIC_REALM                1155
#define IDC_WEBLOG_UTF8                 1156
#define IDC_FTPLOG_UTF8                 1157
#define IDC_NO_ISOLATION                1157
#define IDC_ISOLATE                     1158
#define IDC_ISOLATE_AD                  1159
#define IDC_TRACKER                     1159
#define NEW_IDC_BUTTON_BROWSE_USERS     1160
#define NEW_IDC_BUTTON_BROWSE_DOMAINS   1161
#define IDC_BUTTON_BROWSE_DOMAINS       1161
#define IDC_STATIC_BANNER               1161
#define IDC_STATIC_WELCOME              1162
#define IDC_DELEGATION                  1163
#define IDC_STATIC_MEM_USAGE            1164
#define IDC_CACHE_LIMITED_DISK          1166
#define IDC_CACHE_UNLIMITED_DISK        1167
#define IDC_BUTTON1                     1168
#define IDC_BTN_ADD                     1168
#define IDC_EXTENSION_NAME              1169
#define IDC_EXTENSION_USEDBY            1171
#define IDC_LIST_FILES                  1173
#define IDC_BTN_REMOVE                  1174
#define IDC_BTN_ENABLE                  1175
#define IDC_BTN_DISABLE                 1176
#define IDC_LIST1                       1178
#define IDC_DEPENDENT_APPS_LIST         1178
#define IDC_EDIT_FILENAME               1179
#define IDC_RADIO_UNLIMITED             1182
#define IDC_RADIO_LIMITED               1183
#define IDC_EDIT_EXTENSION_NAME         1183
#define IDC_EDIT_TCP_PORT               1184
#define IDC_CHECK1                      1184
#define IDC_CHECK_ALLOW                 1184
#define IDC_EDIT_CONNECTION_TIMEOUT     1185
#define IDC_EDIT_MAX_CONNECTIONS        1186
#define IDC_BUTTON_HELP                 1186
#define IDC_EDIT_WELCOME                1187
#define IDC_LIST2                       1187
#define IDC_EDIT_EXIT                   1188
#define IDC_COMBO1                      1188
#define IDC_COMBO_APPLICATION           1188
#define IDC_PARTITION                   1188
#define IDC_EDIT_COMMENT                1189
#define IDC_EDIT_BANNER                 1189
#define IDC_CHECK_ALLOW_ANONYMOUS       1190
#define IDC_FILE_ICON                   1190
#define IDC_CHECK_ONLY_ANYMOUS          1191
#define IDC_STATIC_PW                   1192
#define IDC_REQUIREDFILES_STATIC_TITLE  1192
#define IDC_RADIO_UNIX                  1193
#define IDC_EDIT1                       1193
#define IDC_DEPENDENT_APPS_TXT          1193
#define IDC_EDIT_WARN1                  1193
#define IDC_RADIO_MSDOS                 1194
#define IDC_DEPENDENCIES_TXT            1194
#define IDC_BUTTON_CURRENT_SESSIONS     1195
#define IDC_STATIC_WARN1                1195
#define IDC_BUTTON_REFRESH              1196
#define IDC_STATIC_WARN2                1196
#define IDC_LIST_USERS                  1197
#define IDC_EDIT2                       1197
#define IDC_EDIT_WARN2                  1197
#define IDC_BUTTON_DISCONNECT           1198
#define IDC_MT_APARTMENT                1198
#define IDC_BUTTON_DISCONNECT_ALL       1199
#define IDC_MANIFEST                    1199
#define IDC_MANIFEST_NAME               1199
#define IDC_STATIC_NUM_CONNECTED        1200
#define IDC_MANIFEST_STATIC             1200
#define IDC_BUTTON_BROWSE_USER          1201
#define IDC_ENABLE_SXS                  1201
#define IDC_CHECK_ENABLE_LOGGING        1202
#define IDC_PARTITION_STATIC            1202
#define IDC_COMBO_LOG_FORMATS           1203
#define IDC_BUTTON_PROPERTIES           1204
#define IDC_CHECK_ENABLE_PW_SYNCHRONIZATION 1205
#define IDC_STATIC_PATH                 1206
#define IDC_RADIO_DIR                   1207
#define IDC_RADIO_UNC                   1208
#define IDC_STATIC_DESCRIPTION          1209
#define IDC_STATIC_IPADDRESS            1210
#define IDC_STATIC_TCP_PORT             1211
#define IDC_STATIC_ID                   1212
#define IDC_STATIC_DIRLISTING           1213
#define IDC_STATIC_PATH_TYPE            1214
#define IDC_STATIC_OPERATOR_PROMPT1     1215
#define IDC_STATIC_OPERATOR_PROMPT2     1216
#define IDC_STATIC_ACCOUNT_PROMPT       1217
#define IDC_LIST_ADMINISTRATORS         1218
#define IDC_COMBO_IP_ADDRESS            1219
#define IDC_STATIC_CONNECTIONS          1220
#define IDC_BUTTON_EDIT_PATH_TYPE       1221
#define IDC_LOGUICTRL                   1223
#define IDC_STATIC_LOG_PROMPT           1224
#define IDC_COMBO_FTPSITES              1225
#define IDC_APPSCTRL                    1226
#define IDC_EDIT_BASIC_DOMAIN           1227
#define IDC_EDIT_IP_ADDRESS             1228
#define IDD_FTP_SERVICE                 2000
#define IDD_METABACKREST                2001
#define IDD_BACKUP                      2002
#define IDD_SHUTDOWN                    2003
#define IDB_USERS                       2005
#define IDD_FTP_DIRECTORY_SECURITY      2005
#define IDB_ERRORS                      2006
#define IDD_FTP_MESSAGES                2007
#define IDD_DIRECTORY_ERRORS            2008
#define IDD_IIS_MACHINE                 2010
#define IDD_FTP_DIRECTORY_PROPERTIES    2011
#define IDD_SD_PROGRESS                 2014
#define IDD_MIME_PROPERTY               2015
#define IDB_WIZ_FTP_LEFT                2019
#define IDD_MIME_TYPES                  2020
#define IDB_WIZ_FTP_HEAD                2020
#define IDD_CONNECT_SERVER              2021
#define IDB_WIZ_FTP_LEFT_DIR            2021
#define IDD_USER_SESSIONS               2022
#define IDB_WIZ_FTP_HEAD_DIR            2022
#define IDD_LOGIN                       2023
#define IDD_FTP_DEFAULT_SITE            2024
#define IDB_WIZ_FTP_LEFT_SEC            2024
#define IDD_FTP_ACCOUNTS                2025
#define IDB_WIZ_FTP_HEAD_SEC            2025
#define IDD_SITE_SECURITY               2026
#define IDD_IP_ACCESS                   2027
#define IDD_DNS                         2028
#define IDD_CLEARTEXTWARNING            2029
#define IDD_USER_ACCOUNT                2030
#define IDD_PERFORMANCE                 2031
#define IDD_DIRECTORY_DOCUMENTS         2032
#define IDD_DEFAULT_DOCUMENT            2033
#define IDD_MMM                         2037
#define IDD_BASIC_DOMAIN                2038
#define IDD_EDIT_MMM                    2040
#define IDB_BINDINGS                    2040
#define IDD_NEW_FTP_INST_HOME           2043
#define IDD_FTP_NEW_INST_HOME           2043
#define IDD_NEW_FTP_DIR_PATH            2045
#define IDD_FTP_NEW_DIR_PATH            2045
#define IDD_NEW_FTP_USER_PASSWORD       2047
#define IDD_NEW_FTP_USER_PASSWORD2      2047
#define IDD_NEW_FTP_USER_ISOLATION      2047
#define IDD_FTP_NEW_USER_ISOLATION      2047
#define IDD_WEB_SERVICE                 2048
#define IDD_WEB_DIRECTORY_PROPERTIES    2050
#define IDD_DIRECTORY_SECURITY          2051
#define IDD_AUTHENTICATION              2052
#define IDD_IP_SECURITY                 2053
#define IDD_SECURE_COMMUNICATIONS       2054
#define IDD_ANONYMOUS                   2055
#define IDD_FILTERS                     2056
#define IDD_FILTER                      2057
#define IDB_FILTERS                     2058
#define IDD_ERROR_MAPPING               2059
#define IDD_CUSTOM_HEADER               2060
#define IDD_DIRECTORY_HTTP              2061
#define IDD_FTP_NEW_INST_DESCRIPTION    2070
#define IDD_FTP_NEW_INST_BINDINGS       2071
#define IDD_FTP_NEW_DIR_ALIAS           2072
#define IDD_FTP_NEW_USER_PASSWORD       2073
#define IDD_FTP_NEW_PERMS               2074
#define IDD_DEFAULT_SITE                2075
#define IDD_APP_POOL_PERF               2076
#define IDD_APP_POOL_HEALTH             2077
#define IDD_APP_POOL_DEBUG              2078
#define IDD_APP_POOL_IDENT              2079
#define IDD_WEB_NEW_INST_DESCRIPTION    2100
#define IDD_WEB_NEW_DIR_ALIAS           2101
#define IDD_WEB_NEW_PERMS               2102
#define IDD_WEB_NEW_DIR_PATH            2103
#define IDD_WEB_NEW_INST_HOME           2104
#define IDD_WEB_NEW_INST_BINDINGS       2105
#define IDD_WEB_NEW_USER_PASSWORD       2106
#define IDD_PASSWORD                    2200
#define IDC_BACKUP_PASSWORD             2201
#define IDD_ADD_APP_POOL                2201
#define IDC_BACKUP_PASSWORD_CONFIRM     2202
#define IDD_WEB_FILE_PROPERTIES         2202
#define IDC_USE_PASSWORD                2203
#define IDD_FTP_NEW_USER_ISOLATION_AD   2203
#define IDS_PASSWORDS_DOESNT_MATCH      2204
#define IDS_WRONG_PASSWORD              2205
#define IDS_DEBUG_EXEC_MASK             2206
#define IDS_PARENT_PATH_MISSING_PERMISSIONS 2207
#define IDS_MENU_TT_WEBEXT_ALLOW        2208
#define IDS_MENU_TT_WEBEXT_PROHIBIT     2209
#define IDS_MENU_TT_WEBEXT_REMOVE       2210
#define IDC_CHECK_ENABLE_DEFAULT_DOCUMENT 3031
#define IDC_EDIT_DEFAULT_DOCUMENT       3032
#define IDC_CHECK_ENABLE_DOCUMENT_FOOTER 3033
#define IDC_EDIT_DOCUMENT_FOOTER        3035
#define IDC_EDIT_SSL_PORT               3036
#define IDC_CHECK_CLEAR_TEXT            3051
#define IDC_CHECK_NT_CHALLENGE_RESPONSE 3053
#define IDC_CHECK_UUENCODED             3054
#define IDC_CHECK_ANONYMOUS             3054
#define IDC_STATIC_ANONYMOUS_LOGON      3056
#define IDC_BUTTON_EDIT_SSL             3058
#define IDC_EDIT_DOMAIN_NAME            3074
#define IDC_CHECK_USE_KEEPALIVE         3085
#define IDC_STATIC_ERROR_CODE           3102
#define IDC_COMBO_MESSAGE_TYPE          3103
#define IDC_STATIC_TEXT_FILE_PROMT      3104
#define IDC_EDIT_TEXT_FILE              3105
#define IDC_STATIC_SSL_PORT             3112
#define IDC_BUTTON_ADVANCED             3116
#define IDC_BUTTON_AUTHENTICATION       3121
#define IDC_BUTTON_COMMUNICATIONS       3122
#define IDC_BUTTON_IP_SECURITY          3123
#define IDC_STATIC_AUTHENTICATION       3129
#define IDC_CHECK_SSL_ACCOUNT_MAPPING   3143
#define IDC_CHECK_REQUIRE_SSL           3148
#define IDC_CHECK_REQUIRE_128BIT        3150
#define IDC_SLIDER_PERFORMANCE_TUNING   3156
#define IDC_BUTTON_CONNECT_AS           3171
#define IDC_CERTMAPCTRL1                3174
#define IDC_STATIC_PATH_PROMPT          3182
#define IDC_STATIC_THROTTLING           3184
#define IDC_EDIT_DEF_DOCUMENT           3192
#define IDC_LIST_DEFAULT_DOCUMENT       3203
#define IDC_LIST_MMM                    3206
#define IDC_STATIC_WEB_SITE             3207
#define IDC_LIST_SSL_MMM                3207
#define IDC_BUTTON_DEFAULT              3210
#define IDC_STATIC_SUB_PROMPT           3212
#define IDC_COMBO_IP_ADDRESSES          3213
#define IDC_STATIC_SUB_ERROR_CODE       3214
#define IDC_STATIC_DEF_TEXT             3215
#define IDC_RADIO_REDIRECT              3229
#define IDC_STATIC_DIRFLAGS_LARGE       3320
#define IDC_STATIC_DIRFLAGS_SMALL       3321
#define IDC_CHECK_EXACT                 3400
#define IDC_CHECK_CHILD                 3401
#define IDC_CHECK_PERMANENT             3402
#define IDC_STATIC_REDIRECT_PROMPT      3403
#define IDC_STATIC_REDIRFLAGS           3404
#define IDC_STATIC_APPLICATIONS         3503
#define IDC_STATIC_APP_PROMPT           3504
#define IDC_EDIT_APPLICATION            3505
#define IDC_STATIC_STARTING_POINT       3506
#define IDC_STATIC_SP_PROMPT            3507
#define IDC_COMBO_PROCESS               3508
#define IDC_STATIC_PERMISSIONS          3509
#define IDC_BUTTON_CREATE_REMOVE_APP    3510
#define IDC_BUTTON_UNLOAD_APP           3511
#define IDC_APP_CONFIGURATION           3512
#define IDC_STATIC_APPLICATION_SETTINGS 3513
#define IDC_COMBO_PERMISSIONS           3514
#define IDC_STATIC_PROTECTION           3515
#define IDC_EDIT_PORT                   3809
#define IDC_STATIC_PORT                 3810
#define IDC_STATIC_HEADER_NAME          3811
#define IDC_GROUP_IP                    3813
#define IDC_STATIC_IP                   3814
#define IDC_ICON_IP                     3816
#define IDC_STATIC_SSL_PROMPT           3820
#define IDC_RADIO_NO_CERT               3821
#define IDC_RADIO_ACCEPT_CERT           3822
#define IDC_RADIO_REQUIRE_CERT          3823
#define IDC_GROUP_SSL                   3824
#define IDC_CHECK_ENABLE_CPU_ACCOUNTING 3829
#define IDC_STATIC_CPU_PROMPT           3830
#define IDC_EDIT_CPU                    3831
#define IDC_STATIC_PERCENT              3832
#define IDC_CHECK_LOG_EVENT_ONLY        3833
#define IDC_CHECK_ENFORCE_LIMITS        3833
#define IDC_BUTTON_GET_CERTIFICATES     3848
#define IDC_CHECK_DIGEST                3849
#define IDC_BUTTON_NEW_CTL              3850
#define IDC_CHECK_ENABLE_DS             3851
#define IDC_CHECK_ENABLE_CTL            3853
#define IDC_BUTTON_EDIT_CTL             3855
#define IDC_STATIC_CURRENT_CTL          3857
#define IDC_COMBO_CTL                   3858
#define IDC_CTL_SEPERATOR               3868
#define IDC_GROUP_SECURE                3869
#define IDC_ICON_SECURE                 3873
#define IDC_VIEW_CERTIFICATE            3874
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDC_ED_BOLD1                    4011
#define IDC_ED_BOLD2                    4012
#define IDC_ED_BOLD3                    4013
#define IDC_ED_BOLD4                    4014
#define IDC_ED_BOLD5                    4015
#define IDC_STATIC_COMPRESS_GROUP       5000
#define IDC_CHECK_DYNAMIC_COMPRESSION   5001
#define IDC_CHECK_STATIC_COMPRESSION    5002
#define IDC_STATIC_COMPRESS_DIRECTORY   5003
#define IDC_EDIT_COMPRESS_DIRECTORY     5004
#define IDC_STATIC_MAX_COMPRESS_SIZE    5005
#define IDC_RADIO_COMPRESS_UNLIMITED    5006
#define IDC_RADIO_COMPRESS_LIMITED      5007
#define IDC_EDIT_COMPRESS_DIRECTORY_SIZE 5008
#define IDB_ACLUSERS                    10021
#define IDI_AUTHENTICATION              10050
#define IDI_GRANTED                     10051
#define IDI_DENIED                      10052
#define IDI_RATINGS                     10053
#define IDD_ASPMAIN                     10214
#define IDD_ASPDEBUG                    10215
#define IDD_APPMAP                      10216
#define IDD_EDITMAP                     10218
#define IDD_CACHE_OPT                   10220
#define IDD_CACHE_OPT_IIS5              10222
#define IDD_APPMAP_IIS5                 10223
#define IDD_EDIT_STARMAP                10224
#define IDC_RECYCLE_TIMER               10235
#define IDC_SCRIPT_ENGINE               10235
#define IDC_ENABLE_BUFFERING            10236
#define IDC_FILE_EXISTS                 10236
#define IDC_DEBUG_EXCEPTION             10236
#define IDC_ENABLE_PARENTS              10237
#define IDC_HTML_FALLBACK               10237
#define IDC_LOG_FAILS                   10238
#define IDC_TIMESPAN                    10240
#define IDC_SESSION_TIMEOUT             10240
#define IDC_EXECUTABLE                  10240
#define IDC_REQUEST_LIMIT               10241
#define IDC_EXTENSION                   10241
#define IDC_ENGINES                     10241
#define IDC_SCRIPT_TIMEOUT              10243
#define IDC_VERBS                       10243
#define IDC_CACHE_PATH                  10243
#define IDC_ALL_VERBS                   10244
#define IDC_LIMIT_VERBS                 10245
#define IDC_LIST                        10247
#define IDC_ADD_TIME                    10248
#define IDC_ADD                         10248
#define IDC_NO_CACHE                    10248
#define IDC_DELETE_TIME                 10249
#define IDC_REMOVE                      10249
#define IDC_UNLIMITED_CACHE             10249
#define IDC_CHANGE_TIME                 10250
#define IDC_EDIT                        10250
#define IDC_LIMITED_CACHE               10250
#define IDC_HELPBTN                     10251
#define IDC_CACHE_SIZE_EDIT             10251
#define IDC_SERVER_DEBUG                10251
#define IDC_CLIENT_DEBUG                10252
#define IDC_SEND_DETAILED_ERROR         10253
#define IDC_SEND_DEF_ERROR              10254
#define IDC_DEFAULT_ERROR               10255
#define IDC_CGI_TIMEOUT                 10258
#define IDC_ENABLE_SESSION              10263
#define IDC_SESSION_TITLE               10264
#define IDC_SESSION_UNITS               10265
#define IDC_LANG_TITLE                  10267
#define IDC_CACHE_ISAPI                 10268
#define IDC_LANGUAGES                   10270
#define IDC_RECYCLE_TIMESPAN            10271
#define IDC_RECYCLE_REQUESTS            10272
#define IDC_TIMES_LIST                  10273
#define IDC_RECYCLE_MEMORY              10274
#define IDC_RECYCLE_VIRT_MEMORY         10274
#define IDC_RECYCLE_VMEMORY             10274
#define IDC_RECYCLE_UMEMORY             10275
#define IDC_BUTTON_ADD                  11008
#define IDC_IPA_SUBNET_MASK             11010
#define IDC_STATIC_PASSWORD             11011
#define IDC_BUTTON_EDIT                 11012
#define IDC_BUTTON_REMOVE               11013
#define IDC_LIST_IP_ADDRESSES           11014
#define IDC_RADIO_GRANTED               11018
#define IDC_RADIO_DENIED                11019
#define IDC_RADIO_SINGLE                11020
#define IDC_RADIO_MULTIPLE              11021
#define IDC_STATIC_SUBNET_MASK          11022
#define IDC_STATIC_IP_ADDRESS           11023
#define IDC_IPA_IPADDRESS               11024
#define IDC_BUTTON_DNS                  11025
#define IDC_EDIT_DNS_NAME               11026
#define IDC_STATIC_BY_DEFAULT           11027
#define IDC_STATIC_EXCEPT               11028
#define IDC_ICON_GRANTED                11029
#define IDC_ICON_DENIED                 11030
#define IDC_RADIO_DOMAIN                11033
#define IDC_EDIT_DOMAIN                 11034
#define IDC_EDIT_USERNAME               11052
#define IDC_EDIT_PASSWORD               11053
#define IDC_STATIC_USERNAME             11054
#define IDC_BUTTON_CHECK_PASSWORD       11055
#define IDC_STATIC_USERNAME2            11055
#define IDC_BUTTON_BROWSE_USERS         11056
#define IDC_STATIC_FILTERS              11057
#define IDC_LIST_FILTERS                11058
#define IDC_BUTTON_UP                   11059
#define IDC_BUTTONUP                    11059
#define IDC_BUTTON_DOWN                 11060
#define IDC_BUTTONDN                    11060
#define IDC_BUTTON_DN                   11060
#define IDC_BUTTON_DISABLE              11061
#define IDC_STATIC_FILTER_NAME_PROMPT   11062
#define IDC_STATIC_FILTER_NAME          11063
#define IDC_STATIC_STATUS_PROMPT        11064
#define IDC_STATIC_STATUS               11065
#define IDC_STATIC_EXECUTABLE_PROMPT    11066
#define IDC_STATIC_EXECUTABLE           11067
#define IDC_STATIC_PRIORITY_PROMPT      11068
#define IDC_STATIC_PRIORITY             11069
#define IDC_EDIT_FILTERNAME             11070
#define IDC_EDIT_EXECUTABLE             11071
#define IDC_STATIC_PRIORITY_VALUE       11072
#define IDC_EDIT_HEADER                 11073
#define IDC_EDIT_VALUE                  11074
#define IDC_CHECK_EXPIRATION            11075
#define IDC_STATIC_CONTENT_SHOULD       11076
#define IDC_RADIO_IMMEDIATELY           11077
#define IDC_RADIO_TIME                  11078
#define IDC_RADIO_ABS_TIME              11079
#define IDC_EDIT_EXPIRE                 11080
#define IDC_COMBO_TIME                  11081
#define IDC_DTP_ABS_DATE                11082
#define IDC_DTP_ABS_TIME                11083
#define IDC_LIST_HEADERS                11084
#define IDC_BUTTON_RATINGS_TEMPLATE     11085
#define IDC_BUTTON_RATINGS              11086
#define IDC_CHECK_SCRIPT                11087
#define IDC_CHECK_EXECUTE               11088
#define IDC_CHECK_DIRBROWS              11089
#define IDD_MESSAGE_BOX_DLG             11090

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        72
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1203
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\restrictlist.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        websvcext.cpp

   Abstract:
        IIS Application Pools nodes

   Author:
        Aaron Lee (aaronl)

   Project:
        Internet Services Manager

   Revision History:
        03/19/2002      aaronl     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "resource.h"
#include "restrictlist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

CComBSTR g_strUnknownISAPI;
CComBSTR g_strUnknownCGI;
int g_iGlobalsInited = FALSE;

#if defined(_DEBUG) || DBG
	extern CDebug_RestrictList g_Debug_RestrictList;
#endif


// ==========================================
#define WIDTH_STATUS       80

IMPLEMENT_DYNAMIC(CRestrictionListBox, CListCtrl);

CRestrictionListBox::CRestrictionListBox()
{
    VERIFY(m_strAllowed.LoadString(IDS_ALLOWED));
    VERIFY(m_strProhibited.LoadString(IDS_PROHIBITED));
}

CRestrictionEntry * 
CRestrictionListBox::GetItem(UINT nIndex)
{
    return (CRestrictionEntry *)GetItemData(nIndex);
}

void
CRestrictionListBox::SelectItem(int idx, BOOL bSelect)
{
    UINT state = bSelect ? LVIS_SELECTED | LVIS_FOCUSED : 0;
    SetItemState(idx, state, LVIS_SELECTED | LVIS_FOCUSED);
}

int
CRestrictionListBox::InsertItem(int idx, CRestrictionEntry * p)
{
    int iColumn = 1;

    int i = CListCtrl::InsertItem(LVIF_PARAM | TVIF_TEXT,idx,p->strFileName,0, 0, 0,(LPARAM) p);
    if (i != -1)
    {
        BOOL res;
        int  nColumnCount = m_iColsToDisplay;
        // we must use i here and NOT idx
        // since after we inserted the item the
        // listbox could have sorted, and will then
        // give us back something different than idx
        CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
        if (pHeaderCtrl != NULL){nColumnCount= pHeaderCtrl->GetItemCount();}
        if (nColumnCount >= 2)
        {
            if (WEBSVCEXT_STATUS_ALLOWED ==  p->iStatus)
            {
                res = SetItemText(i, iColumn, m_strAllowed);
            }
            else
            {
                res = SetItemText(i, iColumn, m_strProhibited);
            }
        }
    }
    return i;
}

int 
CRestrictionListBox::AddItem(CRestrictionEntry * p)
{
    int count = GetItemCount();
    return InsertItem(count, p);
}
int 
CRestrictionListBox::SetListItem(int idx, CRestrictionEntry * p)
{
    int iColumn = 0;
    int count = GetItemCount();
    BOOL i = SetItem(idx, iColumn, LVIF_PARAM | TVIF_TEXT, p->strFileName, 0, 0, 0, (LPARAM)p);
    if (TRUE == i)
    {
        iColumn = 1;
        BOOL res;
        int  nColumnCount = m_iColsToDisplay;
        // we must use idx here
        // since we are setting the item.
        // set item doesn't return back the index
        // but rather TRUE/FALSE
        CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
        if (pHeaderCtrl != NULL){nColumnCount= pHeaderCtrl->GetItemCount();}
        if (nColumnCount >= 2)
        {
            if (WEBSVCEXT_STATUS_ALLOWED ==  p->iStatus)
            {
                res = SetItemText(idx, iColumn, m_strAllowed);
            }
            else
            {
                res = SetItemText(idx, iColumn, m_strProhibited);
            }
        }
    }
    return idx;
}

BOOL 
CRestrictionListBox::Initialize(int iColumns)
{
    CString buf;
    CRect rc;
    GetClientRect(&rc);

    m_iColsToDisplay = iColumns;

    buf.LoadString(IDS_FILENAME);
    if (m_iColsToDisplay <= 1)
    {
        // there is only one column
        // so make it as wide as you can
        InsertColumn(0, buf, LVCFMT_LEFT, rc.Width());
    }
    else
    {
        InsertColumn(0, buf, LVCFMT_LEFT, rc.Width() - WIDTH_STATUS);
    }

    if (m_iColsToDisplay >= 2)
    {
        buf.LoadString(IDS_STATUS);
        InsertColumn(1, buf, LVCFMT_LEFT, WIDTH_STATUS);
    }

    SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

    return TRUE;
}

// ==========================================

void DumpRestrictionList(CRestrictionList * pMyList)
{
    if (pMyList)
    {
        POSITION pos;
        CString TheKey;
        CRestrictionEntry * pOneEntry = NULL;

        // Loop thru the restrctionlist
        for(pos = pMyList->GetStartPosition();pos != NULL;)
        {
            pMyList->GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);

            if (pOneEntry)
            {
                // dump out one Restriction Entry
                TRACEEOL("  strlstRestrictionEntries---");
                TRACEEOL("    strFileName =" << pOneEntry->strFileName);
                TRACEEOL("    iStatus     =" << pOneEntry->iStatus);
                TRACEEOL("    iDeletable  =" << pOneEntry->iDeletable);
                TRACEEOL("    strGroupID  =" << pOneEntry->strGroupID);
                TRACEEOL("    strGroupDesc=" << pOneEntry->strGroupDescription);
                TRACEEOL("    iType       =" << pOneEntry->iType);
            }
        }
    }
    return;
}

void DumpRestrictionUIEntry(CRestrictionUIEntry * pMyEntry)
{
    if (pMyEntry)
    {
        POSITION pos;
        CString TheKey;
        CRestrictionEntry * pOneEntry = NULL;
        TRACEEOL("==========================");
        TRACEEOL("  strGroupID=" << pMyEntry->strGroupID);
        TRACEEOL("  strGroupDesc=" << pMyEntry->strGroupDescription);

        DumpRestrictionList(&pMyEntry->strlstRestrictionEntries);
    }
    return;
}

BOOL AddRestrictEntryToRestrictList(CRestrictionList* pRestrictList, CRestrictionEntry * pAddEntry)
{
    if (!pAddEntry || !pRestrictList)
        {return FALSE;}

	// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
	CString strKey;strKey = pAddEntry->strFileName;strKey.MakeUpper();
    pRestrictList->SetAt(strKey,pAddEntry);

    return TRUE;
}

BOOL AddRestrictUIEntryToRestrictUIList(CRestrictionUIList* pRestrictUIList, CRestrictionUIEntry * pAddEntry)
{
    if (!pAddEntry || !pRestrictUIList)
        {return FALSE;}

	// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
	CString strKey;strKey = pAddEntry->strGroupID;strKey.MakeUpper();
    pRestrictUIList->SetAt(strKey,pAddEntry);

    return TRUE;
}

void SyncGroupInfoFromParent(CRestrictionList * pEntryToUpdate,CRestrictionUIEntry * pParentInfo)
{
    if (pParentInfo)
    {
        CString TheKey;
        POSITION pos = NULL;
        CRestrictionEntry * pOneEntry = NULL;
        for(pos = pEntryToUpdate->GetStartPosition();pos != NULL;)
        {
            pEntryToUpdate->GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
                pOneEntry->strGroupID = pParentInfo->strGroupID;
                pOneEntry->strGroupDescription = pParentInfo->strGroupDescription;
            }
        }
    }
    return;
}

BOOL AddRestrictListToRestrictList(CRestrictionList* pBigRestrictList, CRestrictionList * pAddEntry)
{
    CString TheKey;
    POSITION pos = NULL;
    CRestrictionEntry * pOneEntry = NULL;
    BOOL bRet = FALSE;

    if (!pAddEntry || !pBigRestrictList)
        {return FALSE;}

    // Loop thru the list of stuff to add
    for(pos = pAddEntry->GetStartPosition();pos != NULL;)
    {
        pAddEntry->GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            if (TRUE == AddRestrictEntryToRestrictList(pBigRestrictList,pOneEntry))
            {
                bRet = TRUE;
            }
        }
    }
    
    return bRet;
}

HRESULT PrepRestictionListForWrite(CRestrictionList * pMyList,CStringListEx * pstrlstReturned)
{
    HRESULT hrRet = E_FAIL;
    
    CString TheKey;
    POSITION pos = NULL;

    // goal is to return a cstringlistex of all the restrctionlist values to write out
    // 1. Loop through the RestrictionList
    // 2. get all the RestrictionEntries from this list and put it into the stringlistex
    // 3. return back the stringlistex.
    if (pMyList)
    {
        pstrlstReturned->RemoveAll();

        // loop thru the restrictionlist
        // and dump it into the cstringlistex
        CRestrictionEntry * pOneEntry = NULL;
        CString strFinalEntry;
        for(pos = pMyList->GetStartPosition();pos != NULL;)
        {
            pMyList->GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // Add it to our CStringListEx
                CString strCleanedGroupID;
                CString strCleanedGroupDesc;

                // Get the RestrictionList for this UI entry...
                // and to the grandaddy list
                //"0,*.dll"
                //"0,c:\\temp\\asp.dll,0,ASP,Asp Descrtiption"
                strCleanedGroupID = pOneEntry->strGroupID;
                strCleanedGroupDesc = pOneEntry->strGroupDescription;

                // Check if this is one of the "special entries....
                switch(pOneEntry->iType)
                {
                case WEBSVCEXT_TYPE_REGULAR:
                    if (-1 == pOneEntry->strGroupID.Find(EMPTY_GROUPID_KEY))
                    {
                        // special keys not found
                        // so the groupid is okay...
                        strFinalEntry.Format(_T("%s,%s,%d,%s,%s"),
                            WEBSVCEXT_STATUS_ALLOWED == pOneEntry->iStatus ? RESTRICTION_ENTRY_IS_ALLOW : RESTRICTION_ENTRY_IS_PROHIBIT,
                            pOneEntry->strFileName,
                            0 == pOneEntry->iDeletable ? 0 : 1,
                            strCleanedGroupID,
                            strCleanedGroupDesc
                            );
                    }
                    else
                    {
                        // This was an entry that didn't have a groupid
                        strFinalEntry.Format(_T("%s,%s,%d,%s,%s"),
                            WEBSVCEXT_STATUS_ALLOWED == pOneEntry->iStatus ? RESTRICTION_ENTRY_IS_ALLOW : RESTRICTION_ENTRY_IS_PROHIBIT,
                            pOneEntry->strFileName,
                            0 == pOneEntry->iDeletable ? 0 : 1,
                            _T(""),
                            strCleanedGroupDesc
                            );
                    }
                    break;

                case WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI:
                    strFinalEntry.Format(_T("%s,*.dll"),
                        WEBSVCEXT_STATUS_ALLOWED == pOneEntry->iStatus ? RESTRICTION_ENTRY_IS_ALLOW : RESTRICTION_ENTRY_IS_PROHIBIT
                        );
                    break;

                case WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI:
                    strFinalEntry.Format(_T("%s,*.exe"),
                        WEBSVCEXT_STATUS_ALLOWED == pOneEntry->iStatus ? RESTRICTION_ENTRY_IS_ALLOW : RESTRICTION_ENTRY_IS_PROHIBIT
                        );
                    break;

                case WEBSVCEXT_TYPE_FILENAME_EXTENSIONS_FILTER:
                    strFinalEntry.Format(_T("%s,???"),
                        WEBSVCEXT_STATUS_ALLOWED == pOneEntry->iStatus ? RESTRICTION_ENTRY_IS_ALLOW : RESTRICTION_ENTRY_IS_PROHIBIT
                        );
                    break;

                default:
                    ASSERT_MSG("Invalid restriction state requested");
                    return E_FAIL;
                }


                pstrlstReturned->AddTail(strFinalEntry);

                hrRet = S_OK;
            }
        }
    }
    
    return hrRet;
}

HRESULT PrepRestictionUIListForWrite(CRestrictionUIList * pMyList,CStringListEx * pstrlstReturned)
{
    HRESULT hrRet = E_FAIL;
    CRestrictionList GranDaddyList;

    // goal is to return a cstringlistex of all the restrctionlist values to write out
    // 1. Loop through the RestrictionUIList
    // 2. get all the RestrictionEntries from this list and put it into the stringlistex
    // 3. return back the stringlistex.
    if (pMyList)
    {
        CString TheKey;
        POSITION pos = NULL;
        CRestrictionUIEntry * pOneEntry = NULL;
        for(pos = pMyList->GetStartPosition();pos != NULL;)
        {
            pMyList->GetNextAssoc(pos, TheKey, (CRestrictionUIEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // Get the RestrictionList for this UI entry...
                // and to the grandaddy list
                SyncGroupInfoFromParent(&pOneEntry->strlstRestrictionEntries,pOneEntry);
                AddRestrictListToRestrictList(&GranDaddyList,&pOneEntry->strlstRestrictionEntries);
            }
        }

        pstrlstReturned->RemoveAll();
        hrRet = PrepRestictionListForWrite(&GranDaddyList,pstrlstReturned);
    }
    
    return hrRet;
}

BOOL
RestrictionListCopy(CRestrictionList * pRestrictionListCopyTo, CRestrictionList * pRestrictionListCopyFrom)
{
    POSITION pos;
    CString TheKey;
    CRestrictionEntry * pOneEntry = NULL;
    CRestrictionEntry * pNewEntry = NULL;

    if (!pRestrictionListCopyTo || !pRestrictionListCopyFrom)
    {
        return FALSE;
    }

    pRestrictionListCopyTo->RemoveAll();

    // Loop thru the restriction list that we want to copy
    for(pos = pRestrictionListCopyFrom->GetStartPosition();pos != NULL;)
    {
        pRestrictionListCopyFrom->GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            pNewEntry = CreateRestrictionEntry(
                pOneEntry->strFileName,
                pOneEntry->iStatus,
                pOneEntry->iDeletable,
                pOneEntry->strGroupID,
                pOneEntry->strGroupDescription,
                pOneEntry->iType);
            if (pNewEntry)
            {

                // add item to the list of entries...
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey = pNewEntry->strFileName;strKey.MakeUpper();
                pRestrictionListCopyTo->SetAt(strKey,pNewEntry);
            }
        }
    }

    return TRUE;
}

void CleanRestrictionList(CRestrictionList * pListToDelete)
{
    if (pListToDelete)
    {
        CRestrictionEntry * pOneEntry = NULL;
        POSITION pos;
        CString TheKey;
        for(pos = pListToDelete->GetStartPosition();pos != NULL;)
        {
            pListToDelete->GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
                
#if defined(_DEBUG) || DBG
	g_Debug_RestrictList.Del(pOneEntry);
#endif

                // Delete what we are pointing too...
                delete pOneEntry;
                pOneEntry = NULL;
            }
        }

        // remove all entries from the list
        pListToDelete->RemoveAll();
    }
    return;
}
void CleanRestrictionUIEntry(CRestrictionUIEntry * pEntryToDelete)
{
    if (pEntryToDelete)
    {
        pEntryToDelete->iType = 0;
        pEntryToDelete->strGroupID = _T("");
        pEntryToDelete->strGroupDescription = _T("");

        CleanRestrictionList(&pEntryToDelete->strlstRestrictionEntries);
    }
    return;
}

void CleanRestrictionUIList(CRestrictionUIList * pListToDelete)
{
    if (pListToDelete)
    {
        CRestrictionUIEntry * pOneEntry = NULL;
        POSITION pos;
        CString TheKey;
        for(pos = pListToDelete->GetStartPosition();pos != NULL;)
        {
            pListToDelete->GetNextAssoc(pos, TheKey, (CRestrictionUIEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // Delete all the RestrictionList Entries inside of this entry...
                CleanRestrictionUIEntry(pOneEntry);

#if defined(_DEBUG) || DBG
	g_Debug_RestrictList.Del(pOneEntry);
#endif

                // Delete what we are pointing too...
                delete pOneEntry;
                pOneEntry = NULL;
            }
        }


        // remove all entries from the list
        pListToDelete->RemoveAll();
    }
    return;
}

void RestrictionUIEntryCopy(CRestrictionUIEntry * pRestrictionUIEntryCopyTo,CRestrictionUIEntry * pRestrictionUIEntryCopyFrom)
{
    // erase the old stuff from the place where we are going to copy tooo...
    CleanRestrictionUIEntry(pRestrictionUIEntryCopyTo);

    pRestrictionUIEntryCopyTo->iType = pRestrictionUIEntryCopyFrom->iType;
    pRestrictionUIEntryCopyTo->strGroupID = pRestrictionUIEntryCopyFrom->strGroupID;
    pRestrictionUIEntryCopyTo->strGroupDescription = pRestrictionUIEntryCopyFrom->strGroupDescription;

    CRestrictionEntry * pOneEntry = NULL;
    CRestrictionEntry * pNewEntry = NULL;
    POSITION pos;
    CString TheKey;
    for(pos = pRestrictionUIEntryCopyFrom->strlstRestrictionEntries.GetStartPosition();pos != NULL;)
    {
        pRestrictionUIEntryCopyFrom->strlstRestrictionEntries.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            pNewEntry = CreateRestrictionEntry(
                pOneEntry->strFileName,
                pOneEntry->iStatus,
                pOneEntry->iDeletable,
                pOneEntry->strGroupID,
                pOneEntry->strGroupDescription,
                pOneEntry->iType);
            if (pNewEntry)
            {
                // add item to the list of entries...
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey = pNewEntry->strFileName;strKey.MakeUpper();
                pRestrictionUIEntryCopyTo->strlstRestrictionEntries.SetAt(strKey,pNewEntry);
            }
        }
    }
}

CRestrictionUIEntry * RestrictionUIEntryMakeCopy(CRestrictionUIEntry * pRestrictionUIEntry)
{
    CRestrictionUIEntry * pNewEntry = NULL;

    if (!pRestrictionUIEntry)
    {
        return NULL;
    }

    pNewEntry = new CRestrictionUIEntry;
    if (!pNewEntry)
    {
        return NULL;
    }

    RestrictionUIEntryCopy(pNewEntry,pRestrictionUIEntry);

#if defined(_DEBUG) || DBG
	g_Debug_RestrictList.Add(pNewEntry);
#endif

    return pNewEntry;
}

HRESULT WriteSettingsRestrictionList(CMetaInterface * pInterface,CStringListEx * pstrlstWrite)
{
    CString str = METABASE_PATH_FOR_RESTRICT_LIST;
    CMetaKey key(pInterface, str, METADATA_PERMISSION_WRITE);
    CError err(key.QueryResult());
 	if (err.Succeeded())
	{
        err = key.SetValue(MD_WEB_SVC_EXT_RESTRICTION_LIST, *pstrlstWrite);
	}
    return err;
}

HRESULT LoadMasterRestrictListWithoutOldEntry(CMetaInterface * pInterface,CRestrictionList * pMasterRestrictionList,CRestrictionUIEntry * pOldEntry)
{
    HRESULT hResult = E_FAIL;
    CStringListEx strlstRawData;
    BOOL bOverride = TRUE;
    DWORD dwAttr = 0;
    BOOL bExcludeThisEntry = FALSE;

    if (pMasterRestrictionList == NULL)
    {
        return E_POINTER;
    }

    CMetaKey key(pInterface, METABASE_PATH_FOR_RESTRICT_LIST, METADATA_PERMISSION_READ);
	if (FAILED(hResult = key.QueryResult()))
	{
        goto LoadMasterRestrictListWithoutOldEntry_Exit;
    }

    if (!g_iGlobalsInited)
    {
        g_iGlobalsInited = TRUE;
        if (!g_strUnknownISAPI.LoadString(IDS_WEBSVCEXT_UNKNOWN_ISAPI))
        {
            g_strUnknownISAPI = _T("All Unknown ISAPI");
            g_iGlobalsInited = FALSE;
        }

        if (!g_strUnknownCGI.LoadString(IDS_WEBSVCEXT_UNKNOWN_CGI))
        {
            g_strUnknownCGI = _T("All Unknown CGI");
            g_iGlobalsInited = FALSE;
        }
    }


    // this stuff should look like...
    // -----------------------------
    //0,*.dll
    //0,*.exe
    //0,c:\windows\system32\inetsrv\asp.dll,0,ASP,Active Server Pages
    //0,c:\windows\system32\inetsrv\httpodbc.dll,0,HTTPODBC,Internet Data Connector
    //
    // and should be formated as a return list to look like
    // -----------------------------
    // All Unknown ISAPI Extensions
    // All Unknown CGI Extensions
    // Active Server Pages (all grouped together here)
    // Internet Data Connector (all grouped together here)
    hResult = key.QueryValue(MD_WEB_SVC_EXT_RESTRICTION_LIST, strlstRawData, &bOverride, NULL, &dwAttr);
    if (FAILED(hResult))
    {
        if (hResult == CError::HResult(ERROR_PATH_NOT_FOUND) ||  hResult == MD_ERROR_DATA_NOT_FOUND)
        {
            //
            // Harmless
            //
            hResult = S_OK;
        }
        else
        {
            // if the value doesn't exist, then let's create it
            goto LoadMasterRestrictListWithoutOldEntry_Exit;
        }
    }

    if (strlstRawData.IsEmpty())
    {
        // Add some default entries then.
        strlstRawData.AddTail(DEFAULTS_ISAPI);
        strlstRawData.AddTail(DEFAULTS_CGI);
    }

    // Parse through and fill our list the right way...
    // loop thru the stringlist and create a stringmap
    
    POSITION pos = strlstRawData.GetHeadPosition();
    while (pos)
    {
        int bInvalidEntry = FALSE;
        int ipos1,ipos2 = 0;

        int iStatus = 0;
        CString strFilePath;
        int iDeletable = 0;
        CString strGroupID;
        CString strGroupDescription;
        int iType = WEBSVCEXT_TYPE_REGULAR;
        LPTSTR pCursor = NULL;
        LPTSTR pDelimiter = NULL;

        CString strCommaDelimitedEntry;
        strCommaDelimitedEntry = strlstRawData.GetNext(pos);
        pCursor = strCommaDelimitedEntry.GetBuffer(0);

        do
        {
            // The 1st entry:0 or 1 (0=prohibited or 1=allowed)
            // The 2nd entry:FilePath
            // The 3nd entry:0 or 1 (0=not deleteable, 1=Delete-able)
            // The 4rd entry:GroupID
            // The 5th entry:Description
            while (isspace(*pCursor) || *pCursor == (TCHAR) RESTRICTION_LIST_SEPARATOR){pCursor++;}

            pDelimiter = _tcschr(pCursor, RESTRICTION_LIST_SEPARATOR);
            if ( !pDelimiter )
            {
                // Invalid entry in restriction list and will be ignored
                bInvalidEntry = TRUE;
                break;
            }

            // OverWrite the seperator
            *pDelimiter = L'\0';

            // get the status
            //WEBSVCEXT_STATUS_ALLOWED,
            //WEBSVCEXT_STATUS_PROHIBITED,
            iStatus = WEBSVCEXT_STATUS_PROHIBITED;
            if ( _tcscmp( pCursor, RESTRICTION_ENTRY_IS_ALLOW ) == 0 )
            {
                iStatus = WEBSVCEXT_STATUS_ALLOWED;
            }
            else if ( _tcscmp( pCursor, RESTRICTION_ENTRY_IS_PROHIBIT ) == 0 )
            {
                iStatus = WEBSVCEXT_STATUS_PROHIBITED;
            }
            else
            {
                // Invalid value.  Server Assumes it's a deny entry
            }

            // Get the filepath
            // skip over the delimiter entry
            pCursor = pDelimiter + 1;
            pDelimiter = _tcschr( pCursor, RESTRICTION_LIST_SEPARATOR );
            if (pDelimiter)
            {
                // overwrite delimiter
                *pDelimiter = L'\0';
            }
            // set the filepath
            strFilePath = pCursor;

            // Check for special cased filepaths...
            iType = WEBSVCEXT_TYPE_REGULAR;
            if (0 == strFilePath.CompareNoCase(_T("*.dll")))
            {
                iType = WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI;
                iDeletable = 0;
                strGroupID = _T("HardcodeISAPI");
                strGroupDescription = g_strUnknownISAPI;
                break;
            }
            if (0 == strFilePath.CompareNoCase(_T("*.exe")))
            {
                iType = WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI;
                iDeletable = 0;
                strGroupID = _T("HardcodeCGI");
                strGroupDescription = g_strUnknownCGI;
                break;
            }

            // default some values in case we can't read them
            iDeletable = 1;
            strGroupID = EMPTY_GROUPID_KEY + strFilePath;
            strGroupDescription = strFilePath;

            // Check if we are able to process this entry at all
            if (!pDelimiter)
            {
                break;
            }

            // try to get the next delimiter
            pCursor = pDelimiter + 1;
            pDelimiter = _tcschr( pCursor, RESTRICTION_LIST_SEPARATOR );
            if (pDelimiter)
            {
                // overwrite delimiter
                *pDelimiter = L'\0';
            }

            // Get the Delete-able flag
            if (0 == _ttoi(pCursor))
            {
                // set to not delete-able only if flag is there and found
                iDeletable = 0;
            }

            // Check if we are able to process this entry at all
            if (!pDelimiter)
            {
                break;
            }

            pCursor = pDelimiter + 1;
            pDelimiter = _tcschr( pCursor, RESTRICTION_LIST_SEPARATOR );
            if (pDelimiter)
            {
                // overwrite delimiter
                *pDelimiter = L'\0';
            }

            strGroupID = pCursor;

            if (pDelimiter)
            {
                pCursor = pDelimiter + 1;
                pDelimiter = _tcschr( pCursor, RESTRICTION_LIST_SEPARATOR );
                if (pDelimiter)
                {
                    // overwrite delimiter
                    *pDelimiter = L'\0';
                }
                // Get the Description
                strGroupDescription = pCursor;
            }

            // check if the description is empty
            if (strGroupDescription.IsEmpty())
            {
                if (strGroupID.IsEmpty())
                {
                    strGroupDescription = strFilePath;
                }
                else
                {
                    strGroupDescription = strGroupID;
                }
            }
            else
            {
                // description has something
                if (strGroupID.IsEmpty())
                {
                    strGroupID = EMPTY_GROUPID_KEY + strGroupDescription;
                }
            }
        } while (FALSE);

        
        if (!bInvalidEntry)
        {
            bExcludeThisEntry = FALSE;
            if (pOldEntry)
            {
                // check if we should exclude this entry...
                if (pOldEntry->strGroupID == strGroupID)
                {
                    bExcludeThisEntry = TRUE;
                }
            }

            if (!bExcludeThisEntry)
            {
                CRestrictionEntry * pItem = CreateRestrictionEntry(
                    strFilePath,
                    iStatus,
                    iDeletable,
                    strGroupID,
                    strGroupDescription,
                    iType);
                if (!pItem)
                {
                    hResult = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
				    // THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				    CString strKey;strKey = pItem->strFileName;strKey.MakeUpper();
					// Check if it exists..
					CRestrictionEntry * pOneEntrySpecial = NULL;
					pMasterRestrictionList->Lookup(strKey,(CRestrictionEntry *&) pOneEntrySpecial);
					if (pOneEntrySpecial)
					{
						// one already exists...
						// check if the existing one is safer.
						if (WEBSVCEXT_STATUS_PROHIBITED == pOneEntrySpecial->iStatus)
						{
							// the one that is there is already safe
							// leave it alone.
						}
						else
						{
							// the one that is already there is unsafe.
							// hopefully this one is safer
							if (WEBSVCEXT_STATUS_PROHIBITED == pItem->iStatus)
							{
								// if this one is safe, then overwrite
								pMasterRestrictionList->SetAt(strKey,pItem);
							}
						}
					}
					else
					{
						pMasterRestrictionList->SetAt(strKey,pItem);
					}
                }
            }
        }
    }

    if (pMasterRestrictionList)
    {
        // check if the "special" entries were added.
        CRestrictionEntry * pOneEntry = NULL;
	    // THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
        CString strGroupDescription = g_strUnknownISAPI;
	    CString strKey;strKey=_T("*.dll");strKey.MakeUpper();
        pMasterRestrictionList->Lookup(strKey,(CRestrictionEntry *&) pOneEntry);
        if (!pOneEntry)
        {
                CRestrictionEntry * pItem = CreateRestrictionEntry(
                    _T("*.dll"),
                    WEBSVCEXT_STATUS_PROHIBITED,
                    0,
                    _T("HardcodeISAPI"),
                    strGroupDescription,
                    WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI);
                if (pItem)
                {
				    strKey = pItem->strFileName;strKey.MakeUpper();
                    pMasterRestrictionList->SetAt(strKey,pItem);
                }
        }

        strGroupDescription = g_strUnknownCGI;
	    // THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
	    strKey;strKey=_T("*.exe");strKey.MakeUpper();
        pOneEntry = NULL;
        pMasterRestrictionList->Lookup(strKey,(CRestrictionEntry *&) pOneEntry);
        if (!pOneEntry)
        {
                CRestrictionEntry * pItem = CreateRestrictionEntry(
                    _T("*.exe"),
                    WEBSVCEXT_STATUS_PROHIBITED,
                    0,
                    _T("HardcodeCGI"),
                    strGroupDescription,
                    WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI);
                if (pItem)
                {
				    strKey = pItem->strFileName;strKey.MakeUpper();
                    pMasterRestrictionList->SetAt(strKey,pItem);
                }
        }
    }

LoadMasterRestrictListWithoutOldEntry_Exit:
    return hResult;
}

HRESULT LoadMasterUIWithoutOldEntry(CMetaInterface * pInterface,CRestrictionUIList * pMasterRestrictionUIList,CRestrictionUIEntry * pOldEntry)
{
    CRestrictionList MyRestrictionList;
    CError err;

    if (NULL == pMasterRestrictionUIList)
    {
        return E_POINTER;
    }
        
    POSITION pos = NULL;
    CString TheKey;

    err = LoadMasterRestrictListWithoutOldEntry(pInterface,&MyRestrictionList,pOldEntry);
    if (err.Succeeded())
    {
        // Put into a UI usable form...
        CRestrictionEntry * pOneEntry = NULL;
        CRestrictionUIEntry * pOneUIEntry = NULL;
        for(pos = MyRestrictionList.GetStartPosition();pos != NULL;)
        {
            MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // see if any entry already exists for our entry...
                pOneUIEntry = NULL;
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey = pOneEntry->strGroupID;strKey.MakeUpper();
                pMasterRestrictionUIList->Lookup(strKey,(CRestrictionUIEntry *&) pOneUIEntry);
                if (pOneUIEntry)
                {
                    pOneUIEntry->iType = pOneEntry->iType;
                    // aaronl used to be commneted out...
                    pOneUIEntry->strGroupID = pOneEntry->strGroupID;
                    if (pOneUIEntry->strGroupDescription.IsEmpty())
                    {
                        pOneUIEntry->strGroupDescription = pOneEntry->strGroupDescription;
                    }
					// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
					CString strKey;strKey = pOneEntry->strFileName;strKey.MakeUpper();
                    pOneUIEntry->strlstRestrictionEntries.SetAt(strKey,pOneEntry);
                }
                else
                {
                    if (!pOneEntry->strFileName.IsEmpty())
                    {
                        pOneUIEntry = new CRestrictionUIEntry;

                        pOneUIEntry->iType = pOneEntry->iType;
                        pOneUIEntry->strGroupID = pOneEntry->strGroupID;
                        pOneUIEntry->strGroupDescription = pOneEntry->strGroupDescription;
						// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
						CString strKey;strKey = pOneEntry->strFileName;strKey.MakeUpper();
                        pOneUIEntry->strlstRestrictionEntries.SetAt(strKey,pOneEntry);
                       
                        if (pOneUIEntry)
                        {
							// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
							strKey = pOneEntry->strGroupID;strKey.MakeUpper();
                            pMasterRestrictionUIList->SetAt(strKey,pOneUIEntry);

#if defined(_DEBUG) || DBG
	g_Debug_RestrictList.Add(pOneUIEntry);
#endif

                        }
                    }
                }
            }
        }
    }

    return err;
}

HRESULT RemoveRestrictionUIEntry(CMetaInterface * pInterface,CRestrictionUIEntry * pRestrictionUIEntry)
{
    CError err;
    BOOL bUpdated = FALSE;
    CRestrictionUIList MyContainerRestrictionUIList;

    if (!pRestrictionUIEntry)
    {
        return E_POINTER;
    }

    // Open the metabase
    // And load everything except for the node we want to delete!
    // then write the whole thing out again.
    err = LoadMasterUIWithoutOldEntry(pInterface,&MyContainerRestrictionUIList,pRestrictionUIEntry);
    if (err.Succeeded())
    {
        // try to update the metabase with the new changes...
        CStringListEx strlstReturned;
        if (SUCCEEDED(PrepRestictionUIListForWrite(&MyContainerRestrictionUIList,&strlstReturned)))
        {
            err = WriteSettingsRestrictionList(pInterface,&strlstReturned);
        }
    }
    MyContainerRestrictionUIList.RemoveAll();
    return err;
}

HRESULT ChangeStateOfEntry(CMetaInterface * pInterface,INT iDesiredState,CRestrictionUIEntry * pRestrictionUIEntry)
{
    CError err;
    BOOL bUpdated = FALSE;
	BOOL bFoundOurEntry = FALSE;

    CRestrictionList OldRestrictionListEntries;

    if (pRestrictionUIEntry)
    {
        // save the old one somewhere
        RestrictionListCopy(&OldRestrictionListEntries,&pRestrictionUIEntry->strlstRestrictionEntries);
    }

    // IF NULL == pRestrictionUIEntry
    // that means we want to do it for ALL ENTRIES!!!!!

    // Open the metabase
    // and get the value for our node.
    // if it needs to be changed to the state we want...
    // then change the value and write out the whole thing again...
    CRestrictionUIList MyContainerRestrictionUIList;
    err = LoadMasterUIWithoutOldEntry(pInterface,&MyContainerRestrictionUIList,NULL);
    if (err.Succeeded())
    {
        POSITION pos,pos2 = NULL;
        CString TheKey,TheKey2;

        // Loop thru the ui list and display those...
        CRestrictionUIEntry * pOneEntry = NULL;
        for(pos = MyContainerRestrictionUIList.GetStartPosition();pos != NULL;)
        {
            MyContainerRestrictionUIList.GetNextAssoc(pos, TheKey, (CRestrictionUIEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // check if this is our entry first!!!!
                if (pRestrictionUIEntry)
                {
                    if (0 != pRestrictionUIEntry->strGroupID.CompareNoCase(pOneEntry->strGroupID))
                    {
                        continue;
                    }
					else
					{
						// we found it!
						bFoundOurEntry = TRUE;
					}
                }

                // loop thru all the RestrictionList entries
                // and find if we can set the state to the new state
                CRestrictionEntry * pOneMoreEntry = NULL;
                for(pos2 = pOneEntry->strlstRestrictionEntries.GetStartPosition();pos2 != NULL;)
                {
                    pOneEntry->strlstRestrictionEntries.GetNextAssoc(pos2, TheKey2, (CRestrictionEntry *&) pOneMoreEntry);
                    if (pOneMoreEntry)
                    {
                        // you can only change to the desired state
                        // if you are in the opposite state.
                        switch(iDesiredState)
                            {
                            case WEBSVCEXT_STATUS_ALLOWED:
                                if (WEBSVCEXT_STATUS_PROHIBITED == pOneMoreEntry->iStatus)
                                {
                                    pOneMoreEntry->iStatus = iDesiredState;
                                    bUpdated = TRUE;
                                }
                                break;
                            case WEBSVCEXT_STATUS_PROHIBITED:
                                if (WEBSVCEXT_STATUS_ALLOWED == pOneMoreEntry->iStatus)
                                {
                                    pOneMoreEntry->iStatus = iDesiredState;
                                    bUpdated = TRUE;
                                }
                                break;
                            case WEBSVCEXT_STATUS_INUSE:
                                if (WEBSVCEXT_STATUS_NOTINUSE == pOneMoreEntry->iStatus)
                                {
                                    pOneMoreEntry->iStatus = iDesiredState;
                                    bUpdated = TRUE;
                                }
                                break;
                            case WEBSVCEXT_STATUS_NOTINUSE:
                                if (WEBSVCEXT_STATUS_INUSE == pOneMoreEntry->iStatus)
                                {
                                    pOneMoreEntry->iStatus = iDesiredState;
                                    bUpdated = TRUE;
                                }
                                break;
		                    default:
                                {
                                    // do nothing
                                    break;
                                }
                            }
                    }
                }

                if (bUpdated)
                {
                    if (pRestrictionUIEntry)
                    {
                        // update the one entry we changed...
                        pRestrictionUIEntry->strlstRestrictionEntries.RemoveAll();
                        // update the existing entries..
                        RestrictionListCopy(&pRestrictionUIEntry->strlstRestrictionEntries,&pOneEntry->strlstRestrictionEntries);
                    }
                }

            }
        }
    }

    if (bUpdated)
    {
        // try to update the metabase with the new changes...
        CStringListEx strlstReturned;
        if (SUCCEEDED(PrepRestictionUIListForWrite(&MyContainerRestrictionUIList,&strlstReturned)))
        {
            err = WriteSettingsRestrictionList(pInterface,&strlstReturned);
        }
        else
        {
            // revert to the old one
            if (pRestrictionUIEntry)
            {
                RestrictionListCopy(&pRestrictionUIEntry->strlstRestrictionEntries,&OldRestrictionListEntries);
            }
        }
    }

    CleanRestrictionList(&OldRestrictionListEntries);
    MyContainerRestrictionUIList.RemoveAll();

	if (!bFoundOurEntry)
	{
		// if we didn't find our entry
		// then return back an error code
		// that will reflect this.
		err = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

    return err;
}

HBITMAP GetBitmapFromStrip(HBITMAP hbmStrip, int nPos, int cSize)
{
    HBITMAP hbmNew = NULL;

    // Create src & dest DC
    HDC hdc = GetDC(NULL);
    HDC hdcSrc = CreateCompatibleDC(hdc);
    HDC hdcDst = CreateCompatibleDC(hdc);

    if( hdcSrc && hdcDst )
    {
        hbmNew= CreateCompatibleBitmap (hdc, cSize, cSize);
        if( hbmNew )
        {
            // Select src & dest bitmaps into DCs
            HBITMAP hbmSrcOld = (HBITMAP)SelectObject(hdcSrc, (HGDIOBJ)hbmStrip);
            HBITMAP hbmDstOld = (HBITMAP)SelectObject(hdcDst, (HGDIOBJ)hbmNew);

            // Copy selected image from source
            BitBlt(hdcDst, 0, 0, cSize, cSize, hdcSrc, cSize * nPos, 0, SRCCOPY);

            // Restore selections
            SelectObject(hdcSrc, (HGDIOBJ)hbmSrcOld);
            SelectObject(hdcDst, (HGDIOBJ)hbmDstOld);
        }

        DeleteDC(hdcSrc);
        DeleteDC(hdcDst);
    }

    ReleaseDC(NULL, hdc);

    return hbmNew;
}

HRESULT LoadApplicationDependList(CMetaInterface * pInterface,CApplicationDependList * pMasterList,BOOL bAddOnlyIfFriendlyNameExists)
{
    HRESULT hResult = E_FAIL;
    CStringListEx strlstRawData;
    BOOL bOverride = TRUE;
    DWORD dwAttr = 0;
    CMyMapStringToString MyGroupIDtoGroupFriendList;
    BOOL bGroupIDMissingFriendlyName = FALSE;

    if (pMasterList == NULL)
    {
        return E_POINTER;
        goto LoadApplicationDependList_Exit;
    }

    // Load Mapping for GroupID to friendlyName
    if (bAddOnlyIfFriendlyNameExists)
    {
        LoadApplicationFriendlyNames(pInterface,&MyGroupIDtoGroupFriendList);
    }

    // clean the list that was passed in..
    pMasterList->RemoveAll();

    CMetaKey key(pInterface, METABASE_PATH_FOR_RESTRICT_LIST, METADATA_PERMISSION_READ);
	if (FAILED(hResult = key.QueryResult()))
	{
        goto LoadApplicationDependList_Exit;
    }

    // this stuff should look like...
    // -----------------------------
    //ApplicationName;DependencyGroupID,DependencyGroupID,etc..
    //Commerce Server;ASP60,INDEX99
    //Exchange;ASP60,OWASVR4
    //MyApp;ASP60
    hResult = key.QueryValue(MD_APP_DEPENDENCIES,strlstRawData, &bOverride, NULL, &dwAttr);
    if (FAILED(hResult))
    {
        if (hResult == CError::HResult(ERROR_PATH_NOT_FOUND) ||  hResult == MD_ERROR_DATA_NOT_FOUND)
        {
            //
            // Harmless
            //
            hResult = S_OK;
        }
        else
        {
            goto LoadApplicationDependList_Exit;
        }
    }

    // Parse through and fill our list the right way...
    // loop thru the stringlist and create a stringmap
    CApplicationDependEntry * pItem = NULL;
    POSITION pos = strlstRawData.GetHeadPosition();
    while (pos)
    {
        LPTSTR lp = NULL;
        CString strApplicationName;
        CString strGroupIDEntry;
        CString strCommaDelimitedEntry;

        strCommaDelimitedEntry = strlstRawData.GetNext(pos);
        lp = strCommaDelimitedEntry.GetBuffer(0);

        // The 1st entry up until the ";" -- "the application friendlyname"
        // The 2nd entry:"a GroupID string"
        // The ... entry:"a GroupID string"

        // Get the 1st entry...
        while (isspace(*lp) || *lp == (TCHAR) APPLICATION_DEPENDENCY_NAME_SEPARATOR){lp++;}
        // okay to use _tcstok here.
        lp = _tcstok(lp, APPLICATION_DEPENDENCY_NAME_SEPARATOR);
        if (lp)
        {
            CString strFriendlyGroupName;
            bGroupIDMissingFriendlyName = FALSE;
            pItem = NULL;

            // Get the application name.
            strApplicationName = lp;

            while (lp)
            {
                strFriendlyGroupName = _T("");

                // Get the 1st GroupIDEntry (seperated by commas)
                // note, it is okay to use _tcstok here since if there is an entry like
                // "app;ID1,,ID2,,,ID3" -- empty entries will be skipped!!!
                lp = _tcstok(NULL, APPLICATION_DEPENDENCY_LIST_SEPARATOR);if (!lp){break;}
                strGroupIDEntry = lp;

                // since we have an app name and at least one groupid
                // let's create the structure
                if (NULL == pItem)
                {
                    pItem = new CApplicationDependEntry;
                    if (pItem)
                    {
                        pItem->strApplicationName = strApplicationName;
                        pItem->strlistGroupID.AddTail(strGroupIDEntry);
                    }
                }
                else
                {
                    // add to existing structure
                    pItem->strlistGroupID.AddTail(strGroupIDEntry);
                }

                if (bAddOnlyIfFriendlyNameExists)
                {
                    // Check if the GroupID has a corresponding Friendlyname.
					// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
					CString strKey;strKey = strGroupIDEntry;strKey.MakeUpper();
                    MyGroupIDtoGroupFriendList.Lookup(strKey,strFriendlyGroupName);
                    if (strFriendlyGroupName.IsEmpty())
                    {
                        // if there isn't an entry
                        // then set the flag
                        bGroupIDMissingFriendlyName = TRUE;
                        break;
                    }
                }
            }

            if (bGroupIDMissingFriendlyName)
            {
                // one of the friendlynames was not found
                // we can't add this entry then...
                if (pItem)
                {
                    pItem->strlistGroupID.RemoveAll();
                    delete pItem;
                    pItem = NULL;
                }
            }
            else
            {
                // add the filled structure to the list of structures
                // that was passed in...
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey = strApplicationName;strKey.MakeUpper();
                pMasterList->SetAt(strKey,pItem);
            }
        }
    }

LoadApplicationDependList_Exit:
    if (ERROR_NOT_ENOUGH_MEMORY == hResult)
    {
        // cleanup if we need to
        if (pMasterList)
        {
            POSITION pos;
            CString TheKey;
            CApplicationDependEntry * pOneEntry = NULL;

            for(pos = pMasterList->GetStartPosition();pos != NULL;)
            {
                pMasterList->GetNextAssoc(pos, TheKey, (CApplicationDependEntry *&) pOneEntry);
                if (pOneEntry)
                {
                    delete pOneEntry;
                    pOneEntry = NULL;
                }
            }
        }
    }
    return hResult;
}

HRESULT LoadApplicationFriendlyNames(CMetaInterface * pInterface,CMyMapStringToString * pMyList)
{
    CRestrictionList MyRestrictionList;
    HRESULT hResult;

    if (NULL == pMyList)
    {
        return E_POINTER;
    }
        
    POSITION pos = NULL;
    CString TheKey;
    hResult = LoadMasterRestrictListWithoutOldEntry(pInterface,&MyRestrictionList,NULL);
    if (SUCCEEDED(hResult))
    {
        CRestrictionEntry * pOneEntry = NULL;
        for(pos = MyRestrictionList.GetStartPosition();pos != NULL;)
        {
            MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // if there is a GroupID & GroupDescription for this entry
                // then add it to our list
                if (!pOneEntry->strGroupID.IsEmpty() && !pOneEntry->strGroupDescription.IsEmpty())
                {
					// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
					CString strKey;strKey = pOneEntry->strGroupID;strKey.MakeUpper();
                    pMyList->SetAt(strKey,pOneEntry->strGroupDescription);
                }
            }
        }
    }

    CleanRestrictionList(&MyRestrictionList);
    return hResult;
}

BOOL ReturnDependentAppsList(CMetaInterface * pInterface,CString strGroupID,CStringListEx * pstrlstReturned,BOOL bAddOnlyIfFriendlyNameExists)
{
    BOOL bReturn = FALSE;
    CApplicationDependList MyMasterList;

    if (SUCCEEDED(LoadApplicationDependList(pInterface,&MyMasterList,bAddOnlyIfFriendlyNameExists)))
    {
        // loop thru the returned back list
        POSITION pos;
        CString TheKey;
        CString strOneGroupID;
        CString strOneApplicationName;
        CApplicationDependEntry * pOneEntry = NULL;
        for(pos = MyMasterList.GetStartPosition();pos != NULL;)
        {
            MyMasterList.GetNextAssoc(pos, TheKey, (CApplicationDependEntry *&) pOneEntry);
            if (pOneEntry)
            {
                strOneApplicationName = pOneEntry->strApplicationName;

                // loop thru the application's dependencies
                // check if one of it is our GroupID
                // if it is then add the applicationName to our list!!!
                POSITION pos2 = pOneEntry->strlistGroupID.GetHeadPosition();
                while (pos2)
                {
                    strOneGroupID = pOneEntry->strlistGroupID.GetNext(pos2);
                    if (0 == strGroupID.CompareNoCase(strOneGroupID))
                    {
                        bReturn = TRUE;
                        pstrlstReturned->AddTail(strOneApplicationName);
                    }
                }
            }
        }
    }

    return bReturn;
}

// return false if there was nothing to update
// true if we updated something...
BOOL UpdateRestrictionUIEntry(CRestrictionUIEntry * pMyItem1,CRestrictionUIEntry * pMyItem2)
{
    BOOL bRet = FALSE;

    if (!pMyItem1 && !pMyItem2)
    {
        return bRet;
    }

    // Update MyItem1 from MyItem2's data
    if (pMyItem1->iType != pMyItem2->iType)
    {
        pMyItem1->iType = pMyItem2->iType;
        bRet = TRUE;
    }

    if (0 != pMyItem1->strGroupID.CompareNoCase(pMyItem2->strGroupID))
    {
        pMyItem1->strGroupID = pMyItem2->strGroupID;
        bRet = TRUE;
    }

    if (0 != pMyItem1->strGroupDescription.Compare(pMyItem2->strGroupDescription))
    {
        pMyItem1->strGroupDescription = pMyItem2->strGroupDescription;
        bRet = TRUE;
    }

    // loop thru the list for item1
    // check if the entry is in item2
    // if it's in there, then see if we need to update it
    // if it's not in there, then well we need to delete it from ourself!
    POSITION pos;
    CString TheKey;
    CRestrictionEntry * pOneRestrictEntry1 = NULL;
    CRestrictionEntry * pOneRestrictEntry2 = NULL;
    for(pos = pMyItem1->strlstRestrictionEntries.GetStartPosition();pos != NULL;)
    {
        pMyItem1->strlstRestrictionEntries.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneRestrictEntry1);
        if (pOneRestrictEntry1)
        {
            //
            // see if the other entry has this entry in it's list...
            // 
			TheKey.MakeUpper();
            pMyItem2->strlstRestrictionEntries.Lookup(TheKey,(CRestrictionEntry *&) pOneRestrictEntry2);
            if (pOneRestrictEntry2)
            {
                if (0 != pOneRestrictEntry1->strFileName.CompareNoCase(pOneRestrictEntry2->strFileName))
                {
                    pOneRestrictEntry1->strFileName = pOneRestrictEntry2->strFileName;
                    bRet = TRUE;
                }
                if (0 != pOneRestrictEntry1->strGroupID.CompareNoCase(pOneRestrictEntry2->strGroupID))
                {
                    pOneRestrictEntry1->strGroupID = pOneRestrictEntry2->strGroupID;
                    bRet = TRUE;
                }
                if (0 != pOneRestrictEntry1->strGroupDescription.Compare(pOneRestrictEntry2->strGroupDescription))
                {
                    pOneRestrictEntry1->strGroupDescription = pOneRestrictEntry2->strGroupDescription;
                    bRet = TRUE;
                }
                if (pOneRestrictEntry1->iStatus != pOneRestrictEntry2->iStatus)
                {
                    pOneRestrictEntry1->iStatus = pOneRestrictEntry2->iStatus;
                    bRet = TRUE;
                }
                if (pOneRestrictEntry1->iDeletable != pOneRestrictEntry2->iDeletable)
                {
                    pOneRestrictEntry1->iDeletable = pOneRestrictEntry2->iDeletable;
                    bRet = TRUE;
                }
                if (pOneRestrictEntry1->iType != pOneRestrictEntry2->iType)
                {
                    pOneRestrictEntry1->iType = pOneRestrictEntry2->iType;
                    bRet = TRUE;
                }

                // do not do this
                // the user only thinks we will modify they're entry
                // and not the entry in the list!
                //delete pOneRestrictEntry2;pOneRestrictEntry1 = NULL;
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
                //pMyItem2->strlstRestrictionEntries.RemoveKey(TheKey.MakeUpper());
            }
            else
            {
                // remove it from ourselfs
#if defined(_DEBUG) || DBG
	g_Debug_RestrictList.Del(pOneRestrictEntry1);
#endif

                delete pOneRestrictEntry1;
                pOneRestrictEntry1 = NULL;

				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				TheKey.MakeUpper();
                pMyItem1->strlstRestrictionEntries.RemoveKey(TheKey);
                bRet = TRUE;
            }
        }
    }

    // loop thru the list for item2
    // check if the entry is in item1
    // if it's in there, then see if we need to update it
    // if it's not in there, then we need to add it to item1!
    pos = NULL;
    for(pos = pMyItem2->strlstRestrictionEntries.GetStartPosition();pos != NULL;)
    {
        pOneRestrictEntry1 = NULL;
        pMyItem2->strlstRestrictionEntries.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneRestrictEntry1);
        if (pOneRestrictEntry1)
        {
            CRestrictionEntry * pNewEntry = NULL;
            //
            // see if the other entry has this entry in it's list...
            // 
            pOneRestrictEntry2 = NULL;
			// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
			TheKey.MakeUpper();
            pMyItem1->strlstRestrictionEntries.Lookup(TheKey,(CRestrictionEntry *&) pOneRestrictEntry2);
            if (!pOneRestrictEntry2)
            {
                // if it's not there then lets create it and add it to the list
                pNewEntry = CreateRestrictionEntry(
                    pOneRestrictEntry1->strFileName,
                    pOneRestrictEntry1->iStatus,
                    pOneRestrictEntry1->iDeletable,
                    pOneRestrictEntry1->strGroupID,
                    pOneRestrictEntry1->strGroupDescription,
                    pOneRestrictEntry1->iType);
                if (pNewEntry)
                {
                    // add item to the list of entries...
					// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
					CString strKey;strKey = pNewEntry->strFileName;strKey.MakeUpper();
                    pMyItem1->strlstRestrictionEntries.SetAt(strKey,pNewEntry);
                    bRet = TRUE;
                }
            }
        }
    }

    return bRet;
}

//
// return 0 = no changes to item from item in list
// return 1 = item was updated from info in matching item from list
// return 2 = matching item was not found in list
// return 9 = error
int UpdateItemFromItemInList(CRestrictionUIEntry * pMyItem,CRestrictionUIList * pMyList)
{
    int iRet = 9;
    CString strKey;
    CRestrictionUIEntry * pMyItemFromList = NULL;

    if (!pMyItem && !pMyList)
    {
        return iRet;
    }

    strKey = pMyItem->strGroupID;
	strKey.MakeUpper();

    // default to not found
    iRet = 2;
	// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
    if (pMyList->Lookup(strKey,pMyItemFromList))
    {
        if (pMyItemFromList)
        {
            // no changes
            iRet = 0;
            if (TRUE == UpdateRestrictionUIEntry(pMyItem, pMyItemFromList))
            {
                // changed
                iRet = 1;
            }
        }
        else
        {
            // flows down to not found
            iRet = 2;
        }
    }

    return iRet;
}

void DeleteItemFromList(CRestrictionUIEntry * pMyItem,CRestrictionUIList * pMyList)
{
    // Find the corresponding pMyItem in the pMyList 
    // and remove it from the list
    if (!pMyItem && !pMyList)
    {
        return;
    }

    if (pMyList)
    {
        CString TheKey;
        POSITION pos = NULL;
        CRestrictionUIEntry * pOneEntry = NULL;
        for(pos = pMyList->GetStartPosition();pos != NULL;)
        {
            pMyList->GetNextAssoc(pos, TheKey, (CRestrictionUIEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // Compare this entry to the one that was passed in...
                if (0 == pMyItem->strGroupID.CompareNoCase(pOneEntry->strGroupID))
                {
                    // found it, let's delete it and get out
                    CleanRestrictionUIEntry(pOneEntry);
                    pOneEntry = NULL;

                    // remove the item from the list
					// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
					TheKey.MakeUpper();
                    pMyList->RemoveKey(TheKey);
                    break;
                }
            }
        }
    }

    return;
}

CRestrictionEntry * CreateRestrictionEntry(
    CString NewstrFileName,
    int     NewiStatus,
    int     NewiDeletable,
    CString NewstrGroupID,
    CString NewstrGroupDescription,
    int     NewiType)
{
    CRestrictionEntry * pNewEntry = new CRestrictionEntry;
    if (pNewEntry)
    {
        pNewEntry->strFileName = NewstrFileName;
        pNewEntry->iStatus = NewiStatus;
        pNewEntry->iDeletable = NewiDeletable;
        pNewEntry->strGroupID = NewstrGroupID;
        pNewEntry->strGroupDescription = NewstrGroupDescription;
        pNewEntry->iType = NewiType;

#if defined(_DEBUG) || DBG
	g_Debug_RestrictList.Add(pNewEntry);
#endif

    }

    return pNewEntry;
}

BOOL IsFileUsedBySomeoneElse(CMetaInterface * pInterface,LPCTSTR lpName,LPCTSTR strGroupID,CString * strUser)
{
    // open the metabase
    // and check if this filepath is getting used by an entry
    // that is not the strGroupID passed in...
    BOOL bReturn = TRUE;
    CRestrictionList MyRestrictionList;
    strUser->LoadString(IDS_UNKNOWN);

    if (NULL == pInterface)
    {
        return TRUE;
    }

    if (SUCCEEDED(LoadMasterRestrictListWithoutOldEntry(pInterface,&MyRestrictionList,NULL)))
    {
        CRestrictionEntry * pOneEntry = NULL;
		// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
		CString strKey;strKey=lpName;strKey.MakeUpper();
        MyRestrictionList.Lookup(strKey,(CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            *strUser = pOneEntry->strGroupDescription;
            if ( 0 == _tcscmp(strGroupID,_T("")))
            {
                // an entry already exists. 
                return TRUE;
            }
            else
            {
                // Entry exists in metabase
                // but we want to see if it matches our GroupID
                if (!pOneEntry->strGroupID.IsEmpty())
                {
                    if (0 == pOneEntry->strGroupID.CompareNoCase(strGroupID))
                    {
                        bReturn = FALSE;
                    }
                }
            }   
        }
        else
        {
            bReturn = FALSE;
        }
    }

    CleanRestrictionList(&MyRestrictionList);
    return bReturn;
}

BOOL IsGroupIDUsedBySomeoneElse(CMetaInterface * pInterface,LPCTSTR lpName)
{
    // open the metabase
    // and check if this filepath is getting used by an entry
    // that is not the strGroupID passed in...
    BOOL bReturn = TRUE;
    CRestrictionList MyRestrictionList;

    if (NULL == pInterface)
    {
        return TRUE;
    }

    if (SUCCEEDED(LoadMasterRestrictListWithoutOldEntry(pInterface,&MyRestrictionList,NULL)))
    {
        POSITION pos;
        CString TheKey;
        CRestrictionEntry * pOneEntry = NULL;
        bReturn = FALSE;
        for(pos = MyRestrictionList.GetStartPosition();pos != NULL;)
        {
            MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
                // check if any description matches
                if (!bReturn)
                {
                    if (!pOneEntry->strGroupDescription.IsEmpty())
                    {
                        if (0 == pOneEntry->strGroupDescription.CompareNoCase(lpName))
                        {
                            bReturn = TRUE;
                            break;
                        }
                    }
                }
            }
        }
    }

    CleanRestrictionList(&MyRestrictionList);
    return bReturn;
}

INT GetRestrictUIState(CRestrictionUIEntry * pRestrictionUIEntry)
{
    INT bRet = 9999;

    // Loop thru the apps to see if any of them is not conforming
    CString TheKey;
    POSITION pos = NULL;
    CRestrictionEntry * pOneEntry = NULL;
    int iPrevStatus = -1;
    BOOL bHosed = FALSE;

    if (!pRestrictionUIEntry)
    {
        goto GetRestrictUIState_Exit;
    }

    for(pos = pRestrictionUIEntry->strlstRestrictionEntries.GetStartPosition();pos != NULL;)
    {
        pRestrictionUIEntry->strlstRestrictionEntries.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            if (-1 == iPrevStatus)
            {
                iPrevStatus = pOneEntry->iStatus;
            }
            else
            {
                // Check if it matches other's we found
                if (pOneEntry->iStatus != iPrevStatus)
                {
                    bHosed = TRUE;
                    break;
                }
            }
        }
        else
        {
            bRet = WEBSVCEXT_STATUS_ALLOWED;
            goto GetRestrictUIState_Exit;
        }
    }

    if (pOneEntry)
    {
        if (bHosed)
        {
            bRet = WEBSVCEXT_STATUS_CUSTOM;
        }
        else
        {
            bRet = pOneEntry->iStatus;
        }
    }

GetRestrictUIState_Exit:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\savedata.cpp ===
#include "stdafx.h"
#include "common.h"
#include "savedata.h"
#include "aclpage.h"
#include "remoteenv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HRESULT DoOnSaveData(
    HWND hWnd,
    LPCTSTR szMachineName,
    CMetaInterface * pInterface,
    BOOL bShowMsgBox,
    DWORD dwLastSystemChangeNumber
    )
{
    HRESULT hRes = E_FAIL;

    // Connect to the metabase
    // and call it's SaveAllData() function
    if (pInterface)
    {
        // Flush the metabase
        hRes = pInterface->SaveData();
        if (TRUE == bShowMsgBox)
        {
            if (SUCCEEDED(hRes))
            {
                DWORD dwChangeNum = 0;
                CComBSTR strMsg;
                CComBSTR strCaption;
                pInterface->GetSystemChangeNumber(&dwChangeNum);
                if (dwLastSystemChangeNumber == dwChangeNum)
                {
                    strMsg.LoadString(IDS_SAVE_DATA_NO_NEED);
                }
                else
                {
                    strMsg.LoadString(IDS_SAVE_DATA_CONFIG_FILE);
                }
                strCaption.LoadString(IDS_APP_NAME);
                MessageBox(hWnd, strMsg, strCaption, MB_ICONINFORMATION | MB_OK | MB_APPLMODAL);
            }
        }
    }
    else
    {
        hRes = ERROR_INVALID_PARAMETER;
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\scache.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        scache.cpp

   Abstract:

        IIS Server cache

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/



#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "scache.h"




#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW




//
// CIISServerCache implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CIISServerCache::Add(
    IN CIISMachine * pMachine
    ) 
/*++

Routine Description:

    Add server to server cache.

Arguments:

    CIISMachine * pMachine      : Pointer to machine

Return Value:

    TRUE if the machine was added.
    FALSE if it was not (already existed)

Notes:

    The CIISMachine pointer is not owned by the cache.  

--*/
{ 
    BOOL fTossed = FALSE;

    int nSwitch;
    CIISMachine * pCurrent;
    POSITION pos = GetHeadPosition();

    //
    // Find proper insertion point.  Fairly lame linear search,
    // but cache is not expected to contain above a dozen items or so
    // and routine is not called often.
    //
    while(pos)
    {
        pCurrent = (CIISMachine *)GetAt(pos);

        nSwitch = pMachine->CompareScopeItem(pCurrent);

        if (nSwitch < 0)
        {
            InsertBefore(pos, pMachine);
            break;
        }

        if (nSwitch == 0)
        {
            ++fTossed;
            break;
        }

        CPtrList::GetNext(pos);
    }

    if (!pos)
    {
        AddTail(pMachine);
    }

    //
    // Remember to save changes
    //
    if (!fTossed)
    {
        SetDirty();
    }

#ifdef _DEBUG

    //
    // Do a quick sanity check of the cache
    //
    int cLocals = 0;

    CIISMachine * pPrev    = NULL;
    pCurrent = GetFirst();

    while(pCurrent)
    {
        if (pPrev)
        {
            //
            // Make sure the list is sorted
            //
            ASSERT(pCurrent->CompareScopeItem(pPrev) > 0);
        }

        pPrev = pCurrent;
        pCurrent = GetNext();
    }

    //
    // Only one local computer
    //
    ASSERT(cLocals <= 1);

#endif // _DEBUG

    return !fTossed;
}



BOOL 
CIISServerCache::Remove(
    IN CIISMachine * pMachine
    ) 
/*++

Routine Description:

    Remove server from the cache. 

Arguments:

    CIISMachine * pMachine  : Server to be removed

Return Value:

    TRUE for success, FALSE for failure

--*/
{ 
    BOOL fRemoved = FALSE;

    int nSwitch;
    CIISMachine * pCurrent;
    POSITION pos = GetHeadPosition();

    //
    // Look for machine object to be deleted
    //
    // ISSUE: We can currently rely on the actual CIISMachine ptr
    //        to be matched, though we don't take advantage of that
    //        with improved search.
    //
    while(pos)
    {
        pCurrent = (CIISMachine *)GetAt(pos);

        nSwitch = pMachine->CompareScopeItem(pCurrent);

        if (nSwitch < 0)
        {
            //
            // Not in the list -- won't find it either
            //
            ASSERT_MSG("Attempting to remove non-existing machine");
            break;
        }

        if (nSwitch == 0)
        {
            //
            // Found it.  If the ASSERT fires, check the "ISSUE" above
            //
            ASSERT(pCurrent == pMachine);
            RemoveAt(pos);
            ++fRemoved;
            break;
        }

        CPtrList::GetNext(pos);
    }

    //
    // Remember to save changes
    //
    if (fRemoved)
    {
        SetDirty();
    }

    return fRemoved;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\scache.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        scache.h

   Abstract:

        IIS Server cache definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SCACHE_H__
#define __SCACHE_H__



class CIISMachine;



class CIISServerCache : public CPtrList
/*++

Class Description:

    Server cache.  Server cache will be maintained in sorted order.

Public Interface:

    CIISServerCache     : Constructor
    ~CIISServerCache    : Destructor

    IsDirty             : TRUE if the cache is dirty
    SetDirty            : Set the dirty bit
    Add                 : Add machine object to cache
    Remove              : Remove machine object from cache
    GetFirst            : Get first machine object in cache
    GetNext             : Get next machine object in cache.
                          GetFirst must have been called first.
    GetLast             : Get last machine object in cache
    GetPrev             : Get previous machine object in cache
                          GetLast must have been called first.

--*/
{
public:
    CIISServerCache() : m_pos(NULL), m_fDirty(FALSE) {};
    ~CIISServerCache() {};

public:
    BOOL IsDirty() const { return m_fDirty; }
    void SetDirty(BOOL fDirty = TRUE) { m_fDirty = fDirty; }
    BOOL Add(CIISMachine * pMachine);
    BOOL Remove(CIISMachine * pMachine);
    CIISMachine * GetNext() { return m_pos ? (CIISMachine *)CPtrList::GetNext(m_pos) : NULL; }
    CIISMachine * GetFirst() { m_pos = GetHeadPosition(); return GetNext(); }
    CIISMachine * GetPrev() { return m_pos ? (CIISMachine *)CPtrList::GetPrev(m_pos) : NULL; }
    CIISMachine * GetLast() { m_pos = GetTailPosition(); return GetPrev(); }

private:
    POSITION m_pos;
    BOOL     m_fDirty;
};



#endif // __SCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\seccom.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        authent.cpp

   Abstract:
        WWW Authentication Dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
//#include "supdlgs.h"
#include "w3sht.h"
#include "wincrypt.h"
#include "cryptui.h"
#include "certmap.h"
//#include "basdom.h"
#include "anondlg.h"
#include "seccom.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const   LPCTSTR     SZ_CTL_DEFAULT_STORE_NAME = _T("CA");
const   LPCSTR      szOID_IIS_VIRTUAL_SERVER =  "1.3.6.1.4.1.311.30.1";



//
// Needed for GetModuleFileName() below:
//
extern HINSTANCE hInstance;


   
CSecCommDlg::CSecCommDlg(
    IN LPCTSTR lpstrServerName, 
    IN LPCTSTR lpstrMetaPath,
    IN CString & strBasicDomain,
    IN DWORD & dwAuthFlags,
    IN CComAuthInfo * pAuthInfo,
    IN DWORD & dwAccessPermissions,
    IN BOOL    fIsMasterInstance,
    IN BOOL    fSSLSupported,
    IN BOOL    fSSL128Supported,
    IN BOOL    fU2Installed,
    IN CString & strCTLIdentifier,
    IN CString & strCTLStoreName,
    IN BOOL    fEditCTLs,
    IN BOOL    fIsLocal,
    IN CWnd *  pParent                       OPTIONAL
    )
/*++

Routine Description:

    Authentication dialog constructor

Arguments:

    LPCTSTR lpstrServerName             : Server name
    LPCTSTR lpstrMetaPath               : Metabase path
    CString & strBasicDomain            : Basic domain name
    DWORD & dwAuthFlags                 : Authorization flags
    DWORD & dwAccessPermissions         : Access permissions
    BOOL    fIsMasterInstance           : Master instance
    BOOL    fSSLSupported               : TRUE if SSL is supported
    BOOL    fSSL128Supported            : TRUE if 128 bit SSL is supported
    CString & strCTLIdentifier
    CString & strCTLStoreName
    BOOL    fEditCTLs
    BOOL    fIsLocal
    CWnd *  pParent                     : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CSecCommDlg::IDD, pParent),
      m_strServerName(lpstrServerName),
      m_strMetaPath(lpstrMetaPath),
      m_dwAuthFlags(dwAuthFlags),
      m_pAuthInfo(pAuthInfo),
      m_dwAccessPermissions(dwAccessPermissions),
      m_fIsMasterInstance(fIsMasterInstance),
      m_fSSLEnabledOnServer(FALSE),
      m_fSSLInstalledOnServer(FALSE),
      m_fSSL128Supported(fSSL128Supported),
      m_fU2Installed(fU2Installed),
      m_hCTLStore(NULL),
      m_bCTLDirty(FALSE),
      m_iLastUsedCert(-1),
      m_fIsLocal(fIsLocal),
      m_fEditCTLs(fEditCTLs)
{
#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CSecCommDlg)
    m_nRadioNoCert = -1;
    m_fAccountMapping = FALSE;
    //m_fEnableDS = FALSE;
    m_fRequireSSL = FALSE;
    m_fEnableCtl = FALSE;
    m_strCtl = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    if (fSSLSupported)
    {
        ::IsSSLEnabledOnServer(
            m_pAuthInfo, 
            m_fSSLInstalledOnServer, 
            m_fSSLEnabledOnServer
            );
    }
    else
    {
        m_fSSLInstalledOnServer = m_fSSLEnabledOnServer = FALSE;
    }

    if (IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_REQUIRE_CERT))
    {
        m_nRadioNoCert = RADIO_REQ_CERT;
    }
    else if (IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_NEGO_CERT))
    {
        m_nRadioNoCert = RADIO_ACCEPT_CERT;
    }
    else
    {
        m_nRadioNoCert = RADIO_NO_CERT;
    }

    m_fRequireSSL = m_fSSLInstalledOnServer
         && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_SSL);

    m_fRequire128BitSSL = m_fSSLInstalledOnServer
        && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_SSL128);

    m_fAccountMapping = m_fSSLInstalledOnServer
        && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_MAP_CERT);

    //
    // CTL information.
    //
    if (fEditCTLs)
    {
        m_strCTLIdentifier = strCTLIdentifier;
        m_strCTLStoreName = strCTLStoreName;

        if (m_strCTLStoreName.IsEmpty())
        {
            m_strCTLStoreName = SZ_CTL_DEFAULT_STORE_NAME;
        }

        m_strCtl.Empty();
        m_fEnableCtl = !m_strCTLIdentifier.IsEmpty()
            && !strCTLStoreName.IsEmpty();

        //
        // For now, we only allow enabling when editing the local machine
        //
        m_fEnableCtl &= m_fIsLocal;
    }
    else
    {
        m_fEnableCtl = FALSE;
        m_check_EnableCtl.EnableWindow(FALSE);
    }
}



CSecCommDlg::~CSecCommDlg()
/*++

Routine Description:

    custom destructor for CSecCommDlg

Arguments:

    None
Return Value:

    None

--*/
{
    // dereference the CTL context pointers in the combo box
    //CleanUpCTLList();
}



void 
CSecCommDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecCommDlg)
    
    DDX_Radio(pDX, IDC_RADIO_NO_CERT, m_nRadioNoCert);
    DDX_Check(pDX, IDC_CHECK_SSL_ACCOUNT_MAPPING, m_fAccountMapping);
    DDX_Check(pDX, IDC_CHECK_REQUIRE_SSL, m_fRequireSSL);
    DDX_Check(pDX, IDC_CHECK_REQUIRE_128BIT, m_fRequire128BitSSL);
    DDX_Check(pDX, IDC_CHECK_ENABLE_CTL, m_fEnableCtl);
    DDX_CBString(pDX, IDC_COMBO_CTL, m_strCtl);
    DDX_Control(pDX, IDC_CTL_SEPERATOR, m_static_CTLSeparator);
    DDX_Control(pDX, IDC_STATIC_CURRENT_CTL, m_static_CTLPrompt);
    DDX_Control(pDX, IDC_CHECK_SSL_ACCOUNT_MAPPING, m_check_AccountMapping);
    DDX_Control(pDX, IDC_CHECK_REQUIRE_SSL, m_check_RequireSSL);
    DDX_Control(pDX, IDC_CHECK_REQUIRE_128BIT, m_check_Require128BitSSL);
    DDX_Control(pDX, IDC_CHECK_ENABLE_CTL, m_check_EnableCtl);
    DDX_Control(pDX, IDC_BUTTON_EDIT_CTL, m_button_EditCtl);
    DDX_Control(pDX, IDC_BUTTON_NEW_CTL, m_button_NewCtl);
    DDX_Control(pDX, IDC_CERTMAPCTRL1, m_ocx_ClientMappings);
    DDX_Control(pDX, IDC_COMBO_CTL, m_combo_ctl);
    //}}AFX_DATA_MAP

    //
    // Private DDX Controls
    //
    DDX_Control(pDX, IDC_RADIO_REQUIRE_CERT, m_radio_RequireCert);
    DDX_Control(pDX, IDC_RADIO_ACCEPT_CERT, m_radio_AcceptCert);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CSecCommDlg, CDialog)
    //{{AFX_MSG_MAP(CSecCommDlg)
    ON_BN_CLICKED(IDC_CHECK_SSL_ACCOUNT_MAPPING, OnCheckSslAccountMapping)
    ON_BN_CLICKED(IDC_CHECK_REQUIRE_SSL, OnCheckRequireSsl)
    ON_BN_CLICKED(IDC_RADIO_ACCEPT_CERT, OnRadioAcceptCert)
    ON_BN_CLICKED(IDC_RADIO_NO_CERT, OnRadioNoCert)
    ON_BN_CLICKED(IDC_RADIO_REQUIRE_CERT, OnRadioRequireCert)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_CTL, OnButtonEditCtl)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_CTL, OnCheckEnableCtl)
    ON_BN_CLICKED(IDC_BUTTON_NEW_CTL, OnButtonNewCtl)
    ON_CBN_SELCHANGE(IDC_COMBO_CTL, OnSelchangeComboCtl)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CSecCommDlg::SetControlStates()
/*++

Routine Description:

    Set control states depending on current data in the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_check_RequireSSL.EnableWindow(m_fSSLEnabledOnServer);
    m_check_Require128BitSSL.EnableWindow(
        m_fSSLEnabledOnServer 
     && m_fSSL128Supported 
     && m_fRequireSSL
        );

    m_ocx_ClientMappings.EnableWindow(
        m_fAccountMapping 
     && !m_fU2Installed
     && !m_fIsMasterInstance
        );

    m_radio_RequireCert.EnableWindow(m_fRequireSSL);

    //
    // Special case: if "require SSL" is off, but "require 
    // client certificates" is on, change the latter to "accept 
    // client certificates"
    //
    if (m_radio_RequireCert.GetCheck() > 0 && !m_fRequireSSL)
    {
        m_radio_RequireCert.SetCheck(0);
        m_radio_AcceptCert.SetCheck(1);
        m_nRadioNoCert = RADIO_ACCEPT_CERT;
    }

    if (m_fEditCTLs)
    {
        m_static_CTLPrompt.EnableWindow(m_fEnableCtl);
        m_combo_ctl.EnableWindow(m_fEnableCtl);
        m_button_EditCtl.EnableWindow(m_fEnableCtl);
        m_button_NewCtl.EnableWindow(m_fEnableCtl);
        m_ocx_CertificateAuthorities.EnableWindow(m_fEnableCtl);

        //
        // If enable Ctl is on, but nothing is selected, disable Edit
        //
        if (m_fEnableCtl)
        {
            if (m_combo_ctl.GetCurSel() == CB_ERR)
            {
                m_button_EditCtl.EnableWindow(FALSE);
            }
        }
    }
    else
    {
        m_fEnableCtl = FALSE;

        //
        // Hide the controls
        //
        DeActivateControl(m_static_CTLPrompt);
        DeActivateControl(m_combo_ctl);
        DeActivateControl(m_button_EditCtl);
        DeActivateControl(m_button_NewCtl);
        DeActivateControl(m_ocx_CertificateAuthorities);
        DeActivateControl(m_check_EnableCtl);
        DeActivateControl(m_static_CTLSeparator);
    }

}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CSecCommDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Initialize certificate authorities ocx
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_CertificateAuthorities.Create(
        _T("CertWiz"),
        WS_BORDER,
        rc,
        this,
        IDC_APPSCTRL
        );

    CString strCaption;
    VERIFY(strCaption.LoadString(IDS_OCX_CERTMAP));

    m_ocx_ClientMappings.SetCaption(strCaption);
    m_ocx_ClientMappings.SetServerInstance(m_strMetaPath);
    m_ocx_ClientMappings.SetMachineName(m_strServerName);

    //
    // Initialize the CTL list data
    //
    InitializeCTLList();

    SetControlStates();

    return TRUE;  
}



void 
CSecCommDlg::OnCheckSslAccountMapping()
/*++

Routine Description:

    SSL Account mapping checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fAccountMapping = !m_fAccountMapping;
    SetControlStates();
}



void 
CSecCommDlg::OnOK()
/*++

Routine Description:

    OK button handler, save information

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        SET_FLAG_IF(m_fAccountMapping, m_dwAccessPermissions, MD_ACCESS_MAP_CERT);
        SET_FLAG_IF(m_fRequireSSL, m_dwAccessPermissions, MD_ACCESS_SSL);
        SET_FLAG_IF(m_fRequire128BitSSL, m_dwAccessPermissions, MD_ACCESS_SSL128);
        RESET_FLAG(m_dwAccessPermissions, 
            (MD_ACCESS_REQUIRE_CERT | MD_ACCESS_NEGO_CERT));

        switch(m_nRadioNoCert)
        {
        case RADIO_REQ_CERT:
            SET_FLAG(m_dwAccessPermissions, 
                (MD_ACCESS_REQUIRE_CERT | MD_ACCESS_NEGO_CERT));
            break;

        case RADIO_ACCEPT_CERT:
            SET_FLAG(m_dwAccessPermissions, MD_ACCESS_NEGO_CERT);
            break;
        }

        //
        // Provide warning if no authentication is selected
        //
        if (!m_dwAuthFlags && !m_dwAccessPermissions 
         && !NoYesMessageBox(IDS_WRN_NO_AUTH))
        {
            //
            // Don't dismiss the dialog
            //
            return;
        }

        //
        // If CTL stuff has changed, update the strings
        //
        if (m_bCTLDirty)
        {
            //
            // Get the index of the selected item
            //
            INT iSel = m_combo_ctl.GetCurSel();

            //
            // If nothing is selected, then clear out the strings
            //
            if (!m_fEnableCtl || (iSel == CB_ERR))
            {
                m_strCTLIdentifier.Empty();
                m_strCTLStoreName.Empty();
            }
            else
            {
                //
                // There is one selected. Update the Identifier string
                // first get the context itself
                //
                PCCTL_CONTEXT pCTL =
                    (PCCTL_CONTEXT)m_combo_ctl.GetItemData(iSel);

                if (pCTL != NULL)
                {
                    //
                    // Now get the list identifier for it and put it in
                    // the string the list identifier is a inherint value
                    // of the context and doesn't need to be read in seperately.
                    // We can just reference it.
                    //
                    m_strCTLIdentifier.Empty();

                    if (pCTL->pCtlInfo
                     && pCTL->pCtlInfo->ListIdentifier.cbData >= 2
                     && pCTL->pCtlInfo->ListIdentifier.cbData)
                    {
                        //
                        // If the identifiers are the same, then this is
                        // our default CTL
                        //
//                      m_strCTLIdentifier =
//                          (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData;

                        wcsncpy(m_strCTLIdentifier.GetBuffer(
                                pCTL->pCtlInfo->ListIdentifier.cbData + 2),
                                (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData,
                                pCTL->pCtlInfo->ListIdentifier.cbData
                                );

                        m_strCTLIdentifier.ReleaseBuffer();
                    }
                }
                else
                {
                    m_strCTLIdentifier.Empty();
                    m_strCTLStoreName.Empty();
                }
            }
        }

        CDialog::OnOK();
    }
}



void 
CSecCommDlg::OnCheckRequireSsl() 
/*++

Routine Description:

    'require ssl' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fRequireSSL = !m_fRequireSSL;
    if (!m_fRequireSSL)
    {
        if (BST_CHECKED == m_check_Require128BitSSL.GetCheck())
        {
            m_check_Require128BitSSL.SetCheck(BST_UNCHECKED);
        }
    }
    SetControlStates();
}



void 
CSecCommDlg::OnRadioNoCert() 
/*++

Routine Description:

    'Do not accept certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_NO_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnRadioAcceptCert() 
/*++

Routine Description:

    'accept certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_ACCEPT_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnRadioRequireCert() 
/*++

Routine Description:

    'require certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_REQ_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnCheckEnableCtl() 
/*++

Routine Description:

    'Enable CTL' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Since this is local only, if we are remote and the user checks the
    // box, then we should alert them to the situation and then do nothing.
    //
    if (!m_fIsLocal)
    {
        DoHelpMessageBox(m_hWnd,IDS_CTL_LOCAL_ONLY, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
        return;
    }


    m_fEnableCtl = !m_fEnableCtl;

    //
    // If we are now disabling, record the current cert and then blank it
    //
    if (!m_fEnableCtl)
    {
        m_iLastUsedCert = m_combo_ctl.GetCurSel();
        m_combo_ctl.SetCurSel(-1);
    }
    else
    {
        //
        // We are enabling, use the last recorded cert
        //
        m_combo_ctl.SetCurSel(m_iLastUsedCert);
    }

    m_bCTLDirty = TRUE;
    SetControlStates();
}



void 
CSecCommDlg::OnButtonEditCtl() 
/*++

Routine Description:

    "Edit CTL" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Get the index of the selected item
    //
    INT iSel = m_combo_ctl.GetCurSel();
    ASSERT( iSel != CB_ERR );

    //
    // Get the selected CTL context
    //
    PCCTL_CONTEXT   pCTL = (PCCTL_CONTEXT)m_combo_ctl.GetItemData(iSel);

    //
    // Pass in the selected CTL context to edit it
    //
    PCCTL_CONTEXT pCTLNew = CallCTLWizard( pCTL );

    //
    // If the CTL on the item has changed, then update the private data item
    //
    if (pCTLNew && pCTLNew != pCTL)
    {
        //
        // start be deleting the current item from the list
        //
        m_combo_ctl.DeleteString(iSel);

        //
        // free the old context
        //
        CertFreeCTLContext(pCTL);

        //
        // now add the new one and select it.
        //
        AddCTLToList(pCTLNew, TRUE);
        SetControlStates();

        //
        // set the dirty flag
        //
        m_bCTLDirty = TRUE;
    }
}



void
CSecCommDlg::OnButtonNewCtl() 
/*++

Routine Description:

    "New CTL" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Pass in NULL to create a new CTL
    //
    PCCTL_CONTEXT   pCTL = CallCTLWizard(NULL);

    //
    // If a CTL was created, add it to the list and select it.
    //
    if (pCTL != NULL)
    {
        AddCTLToList(pCTL, TRUE);
        SetControlStates();
        m_bCTLDirty = TRUE;
    }
}



PCCTL_CONTEXT
CSecCommDlg::CallCTLWizard( 
    IN PCCTL_CONTEXT pCTLSrc 
    )
/*++

Routine Description:

    Adds a CTL to the drop down CTL list. Note that the context pointers are
    set as the private data on the list items. This means that they will need
    to be de-referenced when this object is destroyed. See the 
    routine CleanUpCTLList.

Arguments:

    PCCTL_CONTEXT pctl ctl context pointer of the ctl being added
    BOOL fSelect       flag specifying if this ctl should be selected after it
                       is added

Return Value:

    returns TRUE if successful

--*/
{
    PCCTL_CONTEXT       pCTLOut = NULL;

    CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO   newInfo;
    CTL_USAGE           useInfo;
    CString             szFriendly;
    CString             szDescription;
    CString             szListIdentifier;
    LPOLESTR            pszListIdentifier = NULL;
    LPCSTR              rgbpszUsageArray[2];

    //
    // Prepare the main src structure
    //
    CRYPTUI_WIZ_BUILDCTL_SRC_INFO   srcInfo;
    ZeroMemory( &srcInfo, sizeof(srcInfo) );
    srcInfo.dwSize = sizeof(srcInfo);

    //
    // If we are editing an existing CTL then we do one thing
    //
    if ( pCTLSrc )
    {
        srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL;
        srcInfo.pCTLContext = pCTLSrc;
    }
    else
    {
        //
        // Prepare the usage arrays
        //
        ZeroMemory( &rgbpszUsageArray, sizeof(rgbpszUsageArray) );
        rgbpszUsageArray[0] = szOID_IIS_VIRTUAL_SERVER;

        //
        // Must also have client auth - or else no certs show up in the list!
        //
        rgbpszUsageArray[1] = szOID_PKIX_KP_CLIENT_AUTH;
        ZeroMemory( &useInfo, sizeof(useInfo) );
        useInfo.cUsageIdentifier = 2;
        useInfo.rgpszUsageIdentifier = (PCHAR*)&rgbpszUsageArray;

        //
        // Prep the new ctl structure, which may or may not get used
        //
        ZeroMemory( &newInfo, sizeof(newInfo) );

        //
        // We making a new CTL, fill in the rest of the stuff
        //
        srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL;
        srcInfo.pNewCTLInfo = &newInfo;

        //
        // Load the friendly name and the description
        //
        szFriendly.LoadString(IDS_CTL_NEW);
        szDescription.LoadString(IDS_CTL_DESCRIPTION);

        //
        // Create a guid string for the identifier
        //
        GUID id;
        HRESULT hres = CoCreateGuid(&id);
        hres = StringFromGUID2(id, szListIdentifier.GetBuffer(1000), 1000);
        szListIdentifier.ReleaseBuffer();

        //
        // Fill in the newInfo structure
        //
        newInfo.dwSize = sizeof(newInfo);

        //
        // For now - don't set the usage
        //
        newInfo.pSubjectUsage = &useInfo;

        //
        // Put the generated list identifier into place
        //
        newInfo.pwszListIdentifier = (LPTSTR)(LPCTSTR)szListIdentifier;

        //
        // Fill in the friendly strings that were loaded from the resources
        //
        newInfo.pwszFriendlyName = (LPTSTR)(LPCTSTR)szFriendly;
        newInfo.pwszDescription = (LPTSTR)(LPCTSTR)szDescription;
    }

    //
    // Make the call to the CTL wizard
    //
    if (!CryptUIWizBuildCTL(
            CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING |
            CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE |
            CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION,
            m_hWnd,         
            NULL,    
            &srcInfo,
            NULL,     
            &pCTLOut
            ))
    {
        //
        // The user canceled the CTL wizard or it failed in general.
        // the CTL wizard puts up its own error dialogs
        //
        return NULL;
    }
   
    //
    // Add the certificate context to the store
    //
    if (pCTLOut != NULL)
    {
        PCCTL_CONTEXT pCTLAdded = NULL;

        if (CertAddCTLContextToStore(
            m_hCTLStore,
            pCTLOut,
            CERT_STORE_ADD_REPLACE_EXISTING,
            &pCTLAdded
            ))
        {
            CertFreeCTLContext( pCTLOut );
            pCTLOut = pCTLAdded;
        }
        else
        {
            CertFreeCTLContext( pCTLOut );
            pCTLOut = NULL;
        }
    }

    return pCTLOut;
}



BOOL
CSecCommDlg::AddCTLToList(
    IN PCCTL_CONTEXT pCTL,
    IN BOOL fSelect
    )
/*++

Routine Description:

    Adds a CTL to the drop down CTL list. Note that the context pointers are
    set as the private data on the list items. This means that they will need
    to be de-referenced when this object is destroyed. See the 
    routine CleanUpCTLList.

    This routine by boydm

Arguments:

    PCCTL_CONTEXT pctl ctl context pointer of the ctl being added
    BOOL fSelect -     flag specifying if this ctl should be selected after it 
                       is added

Return Value:

    returns TRUE if successful

--*/
{
    BOOL fSuccess;

    ASSERT(pCTL != NULL);

    if (!pCTL)
    {
        return FALSE;
    }

    //
    // First, we extract the friendly name from the CTL.
    //
    CString     szFriendlyName;     // the friendly name
    DWORD       cbName = 0;         // count of BYTES for the name, not chars

    //
    // Find out how much space we need
    //
    fSuccess = CertGetCTLContextProperty(
        pCTL,
        CERT_FRIENDLY_NAME_PROP_ID,
        NULL,
        &cbName
        );

    //
    // Increase buffer just to cover any nulls just to be safe
    //
    cbName += 2;

    //
    // Get the friendly name
    //
    fSuccess = CertGetCTLContextProperty(
        pCTL,
        CERT_FRIENDLY_NAME_PROP_ID,
        szFriendlyName.GetBuffer(cbName),
        &cbName
        );

    szFriendlyName.ReleaseBuffer();

    //
    // If we did not get the name, then load the default name.
    // The friendly name is an optional parameter in the CTL so it
    // is OK if it is not there.
    //
    if (!fSuccess)
    {
        szFriendlyName.LoadString(IDS_CTL_UNNAMED);
    }

    //
    // Add the friendly name string to the drop down CTL list and record
    // the index of the newly created item
    //
    INT iCTLPosition = m_combo_ctl.AddString(szFriendlyName);

    //
    // If it worked, then add the context pointer to the item as private data
    //
    if (iCTLPosition >=0)
    {
        m_combo_ctl.SetItemData(iCTLPosition, (ULONG_PTR)pCTL);

        //
        // if we have been told to select the CTL, do so at this point
        //
        if (fSelect)
        {
            m_combo_ctl.SetCurSel(iCTLPosition);
        }
    }
    
    //
    // Return TRUE if we successfully added the CTL
    //
    return (iCTLPosition >=0);
}



void
CSecCommDlg::InitializeCTLList() 
/*++

Routine Description:

    Initializes the CTL drop down box by opening the CTL store pointer
    to the target store and filling in the CTL list box with the enumerated
    values.

    This routine by boydm

Arguments:

    None

Return Value:
    None

--*/
{
    //
    // For now this is Local ONLY
    //
    if (!m_fIsLocal)
    {
        return;
    }

    //
    // Build the remote name for the store.
    // It takes the form of "\\MACHINE_NAME\STORENAME"
    // The store name is always "MY" and is define above. The machine
    // name is the name of the machine being edited. The leading \\ in the
    // machine name is optional so we will skip it in this case
    //
    CString szStore;
    
    //
    // Start by adding the machine name that we are targeting
    //
    szStore = m_strServerName;

    //
    // Add the specific store name
    //
    szStore += _T('\\');
    szStore += m_strCTLStoreName;

    //
    // BUGBUG just use MY for now
    //
    szStore = m_strCTLStoreName;

    //
    // Open the store
    //
    m_hCTLStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
        0,
        NULL,
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        szStore 
        );

    //
    // If we failed to open the store, then we will be unable to do anything
    // with CTLs on this machine at all. Disable everything having to do
    // with the CTL controls.
    //
    if (!m_hCTLStore)
    {
        m_fEnableCtl = FALSE;

        //
        // Return early as we have no need to enumerate the CTLs
        //
        return;
    }

    //
    // Enumerate all the CTLs in the store and add them to the drop-down list
    //
    PCCTL_CONTEXT   pCTLEnum = NULL;

    //
    // Enumerate undil NULL is returned. Note that CertEnumCTLsInStore
    // free the context passed into pCTLEnum if it is non NULL. Thus we
    // need to create a duplicate of it to add to the drop-list
    //
    while (pCTLEnum = CertEnumCTLsInStore(m_hCTLStore, pCTLEnum))
    {
        //
        // Make a duplicate of the CTL context for storing in thte list
        //
        PCCTL_CONTEXT pCTL = CertDuplicateCTLContext(pCTLEnum);

        if (!pCTL)
        {
            //
            // Duplication Failed
            //
            continue;
        }

        //
        // The list identifier is a inherint value of the context and doesn't
        // need to be read in separately. We can just referenece it
        //
        BOOL fIsCurrentCTL = FALSE;

        if (pCTL->pCtlInfo
         && pCTL->pCtlInfo->ListIdentifier.cbData >= 2 
         && pCTL->pCtlInfo->ListIdentifier.cbData)
        {
            //
            // If the identifiers are the same, then this is our default CTL
            //
            fIsCurrentCTL = (wcsncmp( 
                (LPCTSTR)m_strCTLIdentifier,
                (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData,
                pCTL->pCtlInfo->ListIdentifier.cbData 
                ) == 0);
                
            // fIsCurrentCTL = ( m_strCTLIdentifier == (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData );
        }

        //
        // Add the CTL to the list
        //
        AddCTLToList(pCTL, fIsCurrentCTL);
    }
}



void
CSecCommDlg::CleanUpCTLList() 
/*++

Routine Description:

    Dereferences all the CTL context pointers in the private data of
    the items in the CTL combo box.
    Then it closes the CTL store handle

    This routine by boydm

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD cItems = m_combo_ctl.GetCount();

    //
    // Loop through each item and free its reference to the CTL pointer
    //
    for (DWORD i = 0; i < cItems; ++i)
    {
        //
        // Get the CTL context pointer from the item's private data
        //
        PCCTL_CONTEXT pCTL = (PCCTL_CONTEXT)m_combo_ctl.GetItemData(i);

        if (pCTL)
        {
            CertFreeCTLContext(pCTL);
        }
    }

    //
    // Close the handle to the store that contains the CTLs
    //
    if (m_hCTLStore)
    {
        CertCloseStore( m_hCTLStore, CERT_CLOSE_STORE_FORCE_FLAG );
        m_hCTLStore = NULL;
    }
}



void
CSecCommDlg::OnSelchangeComboCtl() 
/*++

Routine Description:

    The selection in the drop-down list changed

    This routine by boydm

  Arguments:

    None

Return Value:
    None

--*/
{
    SetControlStates();
    m_bCTLDirty = TRUE;
}



void 
CSecCommDlg::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CDialog::OnDestroy();
    
    CleanUpCTLList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\seccom.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SECCOM_H__
#define __SECCOM_H__


//{{AFX_INCLUDES()
#include "certmap.h"
#include "certauth.h"
#include "certwiz.h"
//}}AFX_INCLUDES



class CSecCommDlg : public CDialog
/*++

Class Description:

    Authantication dialog

Public Interface:

    CSecCommDlg  : Constructor

--*/
{
//
// Construction
//
public:
    CSecCommDlg(
        IN LPCTSTR lpstrServerName,         // For API name only
        IN LPCTSTR lpstrMetaPath,           // For use in ocx only
        IN CString & strBasicDomain,
        IN DWORD & dwAuthFlags,
        IN CComAuthInfo * pAuthInfo,
        IN DWORD & dwAccessPermissions,
        IN BOOL    fIsMasterInstance,
        IN BOOL    fSSLSupported,
        IN BOOL    fSSL128Supported,
        IN BOOL    fU2Installed,
        IN CString & strCTLIdentifier,
        IN CString & strCTLStoreName,
        IN BOOL    fEditCTLs,
        IN BOOL    fIsLocal,
        IN CWnd *  pParent = NULL            OPTIONAL
        );

    ~CSecCommDlg();

//
// Dialog Data
//
public:
    CString m_strCTLIdentifier;
    CString m_strCTLStoreName;
    BOOL    m_bCTLDirty;

protected:
    //
    // Radio button values
    //
    enum
    {
        RADIO_NO_CERT,
        RADIO_ACCEPT_CERT,
        RADIO_REQ_CERT,
    };

    //{{AFX_DATA(CSecCommDlg)
    enum { IDD = IDD_SECURE_COMMUNICATIONS };
    int         m_nRadioNoCert;
    BOOL        m_fAccountMapping;
    BOOL        m_fRequireSSL;
    BOOL        m_fRequire128BitSSL;
    BOOL        m_fEnableCtl;
    CString     m_strCtl;
    CStatic     m_static_CTLPrompt;
    CStatic     m_static_CTLSeparator;
    CButton     m_check_AccountMapping;
    CButton     m_check_RequireSSL;
    CButton     m_check_Require128BitSSL;
    CButton     m_check_EnableDS;
    CButton     m_check_EnableCtl;
    CButton     m_button_EditCtl;
    CButton     m_button_NewCtl;
    CCertmap    m_ocx_ClientMappings;
    CComboBox   m_combo_ctl;
    //}}AFX_DATA

    CButton     m_radio_RequireCert;
    CButton     m_radio_AcceptCert;
    CCertWiz    m_ocx_CertificateAuthorities;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CSecCommDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CSecCommDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnCheckSslAccountMapping();
    afx_msg void OnCheckRequireSsl();
    afx_msg void OnRadioAcceptCert();
    afx_msg void OnRadioNoCert();
    afx_msg void OnRadioRequireCert();
    afx_msg void OnButtonEditCtl();
    afx_msg void OnCheckEnableCtl();
    afx_msg void OnButtonNewCtl();
    afx_msg void OnSelchangeComboCtl();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    BOOL AddCTLToList(PCCTL_CONTEXT pCTL, BOOL fSelect);
    PCCTL_CONTEXT CallCTLWizard(PCCTL_CONTEXT pCTLSrc);

    void InitializeCTLList();
    void CleanUpCTLList();

    HCERTSTORE  m_hCTLStore;

    INT m_iLastUsedCert;
    DWORD & m_dwAuthFlags;
    CComAuthInfo * m_pAuthInfo;
    DWORD & m_dwAccessPermissions;
    DWORD m_dwInstance;
    BOOL m_fEditCTLs;
    BOOL m_fSSLEnabledOnServer;
    BOOL m_fSSLInstalledOnServer;
    BOOL m_fSSL128Supported;
    BOOL m_fU2Installed;
    BOOL m_fIsLocal;
    BOOL m_fIsMasterInstance;
    CString m_strServerName;
    CString m_strMetaPath;
};


#endif // __SECCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\shts.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        shts.cpp

   Abstract:

        IIS Property sheet classes

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "mime.h"
#include "iisobj.h"
#include "shutdown.h"
#include "util.h"
#include "tracker.h"

extern CPropertySheetTracker g_OpenPropertySheetTracker;

#if defined(_DEBUG) || DBG
	extern CDebug_IISObject g_Debug_IISObject;
#endif


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



//
// CInetPropertySheet class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNAMIC(CInetPropertySheet, CPropertySheet)



CInetPropertySheet::CInetPropertySheet(
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMetaPath,
    CWnd * pParentWnd,
    LPARAM lParam,             
    LPARAM lParamParentObject,      
    UINT iSelectPage         
    )
/*++

Routine Description:

    IIS Property Sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CPropertySheet(_T(""), pParentWnd, iSelectPage),
      m_auth(pAuthInfo),
      m_strMetaPath(lpszMetaPath),
      m_dwInstance(0L),
      m_bModeless(FALSE),
      m_lParam(lParam),
      m_lParamParentObject(lParamParentObject),
      m_fHasAdminAccess(TRUE),      // Assumed by default
      m_pCap(NULL),
      m_refcount(0),
	  m_prop_change_flag(PROP_CHANGE_NO_UPDATE),
      m_fRestartRequired(FALSE),
	  m_fChanged(FALSE)
{
    m_fIsMasterPath = CMetabasePath::IsMasterInstance(lpszMetaPath);
	CIISObject * pNode = (CIISObject *)m_lParam;
    CIISObject * pNode2 = (CIISObject *)m_lParamParentObject;
	ASSERT(pNode != NULL);

    if (pNode)
    {
        // Tell the object that there is a property page open on it
        pNode->SetMyPropertySheetOpen(::GetForegroundWindow());
    }
    // Addref the object, so that it doesn't get unloaded
    // while we have the property sheet open
	pNode->AddRef();
    pNode->CreateTag();
    TRACEEOLID("Tag=" << pNode->m_strTag);
    // Add it to the global open property sheet tracker...
    g_OpenPropertySheetTracker.Add(pNode);

    // And also.... Addref the objects parent, so that it doesn't get unloaded as well
    if (pNode2)
    {
        pNode2->AddRef();
    }

#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Dump(2);
#endif

}


void
CInetPropertySheet::NotifyMMC()
/*++
    Notify MMC that changes have been made, so that the changes are
    reflected.
--*/
{
	ASSERT(m_lParam != 0L);
	CIISObject * pNode = (CIISObject *)m_lParam;

	if (pNode != NULL)
	{
		if (pNode->m_ppHandle != NULL)
		{
			if (	0 != (m_prop_change_flag & PROP_CHANGE_DISPLAY_ONLY)
				||	0 != (m_prop_change_flag & PROP_CHANGE_REENUM_VDIR)
				||	0 != (m_prop_change_flag & PROP_CHANGE_REENUM_FILES)
				)
			{
				pNode->m_UpdateFlag = m_prop_change_flag;

                // there is something bad about sending this pNode handle
                // as part of the notification...
                //
                // the scenario is when 
                // 1. the property page is opened
                // 2. the user refreshs a node that s a parent to the object
                //    which has the property page open.  this will delete the
                //    scope object associated with this object, and will
                //    orphan the object.
                //    at this time, the cleaning of the scope object, will
                //    call release on the object once, but of course since
                //    we addref/release in the createproperty sheet stuff
                //    we are still protected from the object getting deleted
                //    from under us, thus we are at Refcount=1 or something like
                //    but with no scope/result object in MMC
                // 3. now when the user clicks OK and saves changes to this
                //    orphaned property sheet and passes IT's handle allong
                //    with the change notification....
                // 4. What happens next is -- since there is no MMC scope/result 
                //    item -- thus there is only 1 refcount on the object.
                //    so when the user clicks OK -- really the object will
                //    Get DELETED... And this pNode that we are sending below
                //    will try to get dereferenced by the MMC.
                // 5. the MMC will get the notification and get the pointer
                //    and try to call some refresh or something within the object
                //    itself.
                //
                // THUS THIS IS THE PROBLEM WITH SENDING pNode.
                //
                // To remedy this, what we'll do is:
                // 1. when a property sheet is about to get orphaned
                //    we will set it's m_hScopeItem = 0 (gee since it won't have
                //    a scope/result item anywas).
                // 2. thus if we see that here... that means the object
                //    doesn't have a mmc type scope/result object and we
                //    should not send the notification
                // 
                if (pNode->QueryScopeItem() || pNode->QueryResultItem())
                {
                    if (pNode->UseCount() > 0)
                    {
				        MMCPropertyChangeNotify(pNode->m_ppHandle, (LPARAM) pNode);
				        m_prop_change_flag = PROP_CHANGE_NO_UPDATE;
                    }
                }
                else
                {
                    TRACEEOLID("MMCPropertyChangeNotify:Looks like this is an orphaned property sheet, don't send notification...");
                }
			}
		}
	}
}

void
CInetPropertySheet::NotifyMMC_Node(CIISObject * pNode)
/*++
    Notify MMC that changes have been made, so that the changes are
    reflected.
--*/
{
	if (pNode != NULL)
	{
		if (pNode->m_ppHandle != NULL)
		{
			pNode->m_UpdateFlag = m_prop_change_flag;
            if (pNode->QueryScopeItem() || pNode->QueryResultItem())
            {
                if (pNode->UseCount() > 0)
                {
			        MMCPropertyChangeNotify(pNode->m_ppHandle, (LPARAM)pNode);
                }
            }
            else
            {
                TRACEEOLID("MMCPropertyChangeNotify:Looks like this is an orphaned property sheet, don't send notification...");
            }
		}
	}
}

CInetPropertySheet::~CInetPropertySheet()
{
   CIISObject * pNode = (CIISObject *)m_lParam;
   CIISObject * pNode2 = (CIISObject *)m_lParamParentObject;
   
   ASSERT(pNode != NULL);

   // At this moment we should have in m_pages only pages that were not activated
   // in this session.
   while (!m_pages.IsEmpty())
   {
      CInetPropertyPage * pPage = m_pages.RemoveHead();
      delete pPage;
   }
//   if (m_fChanged)
//   {
//	  NotifyMMC();
//   }

#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Dump(2);
#endif

    if (pNode)
    {
        // Tell the object that there is No property page open on it
        pNode->SetMyPropertySheetOpen(NULL);

        // Free the MMC notify handle
        if (pNode->m_ppHandle)
        {
            // Verify that is isn't a hosed handle...
            if (IsValidAddress( (const void*) pNode->m_ppHandle,sizeof(void*)))
            {
                MMCFreeNotifyHandle(pNode->m_ppHandle);
			    pNode->m_ppHandle = 0;
            }
        }
        pNode->Release();
        // Remove it from the global open property sheet tracker...
        g_OpenPropertySheetTracker.Del(pNode);
    }

    if (pNode2)
    {
        pNode2->Release();
    }

#if defined(_DEBUG) || DBG	
	g_Debug_IISObject.Dump(2);
#endif

}

void
CInetPropertySheet::AttachPage(CInetPropertyPage * pPage)
{
   m_pages.AddTail(pPage);
}


void
CInetPropertySheet::DetachPage(CInetPropertyPage * pPage)
{
   POSITION pos = m_pages.Find(pPage);
   ASSERT(pos != NULL);
   if (pos != NULL)
   {
	  m_fChanged |= pPage->IsDirty();
      m_pages.RemoveAt(pos);
   }
}

WORD 
CInetPropertySheet::QueryMajorVersion() const
{
   CIISMBNode * pNode = (CIISMBNode *)m_lParam;
   ASSERT(pNode != NULL);
   if (pNode)
   {
       return pNode->QueryMajorVersion();
   }
   return 0;
}

WORD 
CInetPropertySheet::QueryMinorVersion() const
{
   CIISMBNode * pNode = (CIISMBNode *)m_lParam;
   ASSERT(pNode != NULL);
   if (pNode)
   {
       return pNode->QueryMinorVersion();
   }
   return 0;
}

/* virtual */ 
void
CInetPropertySheet::SetObjectsHwnd()
{
    CIISMBNode * pNode = (CIISMBNode *)m_lParam;
    // Set the hwnd for the CIISObject...
    if (pNode)
    {
        // Tell the object that there is a property page open on it
        pNode->SetMyPropertySheetOpen(::GetForegroundWindow());
    }
}

/* virtual */ 
HRESULT 
CInetPropertySheet::LoadConfigurationParameters()
{
    //
    // Load base values
    //
    CError err;

    if (m_pCap == NULL)
    {
        //
        // Capability info stored off the service path ("lm/w3svc").
        //
        ASSERT(m_strInfoPath.IsEmpty());
        //
        // Building path components
        //
        CMetabasePath::GetServiceInfoPath(m_strMetaPath, m_strInfoPath);
        //
        // Split into instance and directory paths
        //
        if (IsMasterInstance())
        {
            m_strServicePath = m_strInstancePath = QueryMetaPath();
        }
        else 
        {
            VERIFY(CMetabasePath::GetInstancePath(
                QueryMetaPath(), 
                m_strInstancePath,
                &m_strDirectoryPath
                ));

            VERIFY(CMetabasePath::GetServicePath(
                QueryMetaPath(),
                m_strServicePath
                ));
        }

        if (m_strDirectoryPath.IsEmpty() && !IsMasterInstance())
        {
            m_strDirectoryPath = CMetabasePath(FALSE, QueryMetaPath(), g_cszRoot);
        }
        else
        {
            m_strDirectoryPath = QueryMetaPath();
        }
        m_dwInstance = CMetabasePath::GetInstanceNumber(m_strMetaPath);
        m_pCap = new CServerCapabilities(QueryAuthInfo(), m_strInfoPath);
        if (!m_pCap)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_pCap->LoadData();
        if (err.Succeeded())
        {
            CIISMBNode * pNode = (CIISMBNode *)GetParameter();
            CIISMachine * pMachine = pNode->GetOwner();
            err = DetermineAdminAccess(&pMachine->m_dwMetabaseSystemChangeNumber);
        }
    }
    return err;
}



/* virtual */ 
void 
CInetPropertySheet::FreeConfigurationParameters()
{
//    ASSERT_PTR(m_pCap);
    SAFE_DELETE(m_pCap);
}




void
CInetPropertySheet::WinHelp(DWORD dwData, UINT nCmd)
/*++

Routine Description:
    WinHelp override.  We can't use the base class, because our
    'sheet' doesn't usually have a window handle

Arguments:
    DWORD dwData        : Help data
    UINT nCmd           : Help command

--*/
{

    WinHelpDebug(dwData);

    if (m_hWnd == NULL)
    {
        /*
        //
        // Special case
        //
        ::WinHelp(
            HWND hWndMain,
            LPCWSTR lpszHelp,
            UINT uCommand,
            DWORD dwData
            );
        */

        CWnd * pWnd = ::AfxGetMainWnd();

        if (pWnd != NULL)
        {
            pWnd->WinHelp(dwData, nCmd);
        }

        return;
    }

    CPropertySheet::WinHelp(dwData, nCmd);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//
// CInetPropertyPage class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// CInetPropertyPage property page
//
IMPLEMENT_DYNAMIC(CInetPropertyPage, CPropertyPage)




#ifdef _DEBUG

/* virtual */
void
CInetPropertyPage::AssertValid() const
{
}



/* virtual */
void
CInetPropertyPage::Dump(CDumpContext& dc) const
{
}

#endif // _DEBUG



CInetPropertyPage::CInetPropertyPage(
    IN UINT nIDTemplate,
    IN CInetPropertySheet * pSheet,
    IN UINT nIDCaption,
    IN BOOL fEnableEnhancedFonts            OPTIONAL
    )
/*++

Routine Description:

    IIS Property Page Constructor

Arguments:

    UINT nIDTemplate            : Resource template
    CInetPropertySheet * pSheet : Associated property sheet
    UINT nIDCaption             : Caption ID
    BOOL fEnableEnhancedFonts   : Enable enhanced fonts

Return Value:

    N/A

--*/
    : CPropertyPage(nIDTemplate, nIDCaption),
      m_nHelpContext(nIDTemplate + 0x20000),
      m_fEnableEnhancedFonts(fEnableEnhancedFonts),
      m_bChanged(FALSE),
      m_pSheet(pSheet)
{
    //{{AFX_DATA_INIT(CInetPropertyPage)
    //}}AFX_DATA_INIT

    m_psp.dwFlags |= PSP_HASHELP;

    ASSERT(m_pSheet != NULL);
    if (m_pSheet)
    {
        m_pSheet->AttachPage(this);
    }
}



CInetPropertyPage::~CInetPropertyPage()
{
}



void
CInetPropertyPage::DoDataExchange(CDataExchange * pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInetPropertyPage)
    //}}AFX_DATA_MAP
}



/* virtual */
void 
CInetPropertyPage::PostNcDestroy()
/*++

Routine Description:

    handle destruction of the window by freeing the this
    pointer (as this modeless dialog must have been created
    on the heap)

Arguments:

    None.

Return Value:

    None

--*/
{
    m_pSheet->Release(this);
    delete this;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CInetPropertyPage)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* virtual */
BOOL
CInetPropertyPage::OnInitDialog()
/*++

Routine Description:
    WM_INITDIALOG handler.  Initialize the dialog.  Reset changed
    status (sometimes gets set by e.g. spinboxes when the dialog is
    constructed), so make sure the dialog is considered clean.

--*/
{
    m_bChanged = FALSE;

    //
    // Tell derived class to load its configuration parameters
    //
    CError err(LoadConfigurationParameters());

    // Tell the object which Hwnd it will have.
    if (m_pSheet)
    {
        m_pSheet->SetObjectsHwnd();
    }

    if (err.Succeeded())
    {
        err = FetchLoadedValues();
    }
	else
	{
//		EndDialog(IDCANCEL);
		DestroyWindow();
		return TRUE;
	}

    BOOL bResult = CPropertyPage::OnInitDialog();

    err.MessageBoxOnFailure(m_hWnd);

    if (m_fEnableEnhancedFonts)
    {
        CFont * pFont = &m_fontBold;

        if (CreateSpecialDialogFont(this, pFont))
        {
            ApplyFontToControls(this, pFont, IDC_ED_BOLD1, IDC_ED_BOLD5);
        }
    }

    // We should call AddRef here, not in page constructor, because PostNCDestroy()
    // is getting called only for pages that were activated, not for all created pages.
    // OnInitDialog is also called for activated pages only -- so we will get parity
    // and delete property sheet.
    //
    ASSERT(m_pSheet != NULL);
    if (m_pSheet)
    {
        m_pSheet->AddRef();
    }
    return bResult;
}



void
CInetPropertyPage::OnHelp()
{
    ASSERT_PTR(m_pSheet);

    WinHelpDebug(m_nHelpContext);

    m_pSheet->WinHelp(m_nHelpContext);
}



BOOL
CInetPropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
    OnHelp();
    return TRUE;
}

void
CInetPropertyPage::OnCancel()
{
	return CPropertyPage::OnCancel();
}


BOOL
CInetPropertyPage::OnApply()
{
    BOOL bSuccess = TRUE;

    if (IsDirty())
    {
        CError err(SaveInfo());

        if (err.MessageBoxOnFailure(m_hWnd))
        {
            //
            // Failed, sheet will not be dismissed.
            //
            // CODEWORK: This page should be activated.
            //
            bSuccess = FALSE;
        }

        SetModified(!bSuccess);
        if (bSuccess && GetSheet()->RestartRequired())
        {
           // ask user about immediate restart
		   CIISMBNode * pNode = (CIISMBNode *)m_pSheet->GetParameter();
		   CIISMachine * pMachine = pNode->GetOwner();
           if (IDYES == ::AfxMessageBox(IDS_ASK_TO_RESTART, MB_YESNO | MB_ICONQUESTION))
           {
              // restart IIS
              if (pMachine != NULL)
              {
			     pMachine->AddRef();
                 CIISShutdownDlg dlg(pMachine, this);
                 dlg.PerformCommand(ISC_RESTART, FALSE);
                 bSuccess = dlg.ServicesWereRestarted();
                 pMachine->Release();
				 err = pMachine->CreateInterface(TRUE);
				 bSuccess = err.Succeeded();
              }
           }
           else
           {
               // user didn't want to restart iis services
               // at least let's update the UI
               pMachine->RefreshData();
           }
           // mark restart required false to suppress it on other pages
		   m_pSheet->NotifyMMC_Node(pMachine);
           m_pSheet->SetRestartRequired(FALSE, PROP_CHANGE_NO_UPDATE);
		   m_pSheet->ResetNotifyFlag();
        }
		// This call will do nothing if we were in restart code path, at the end of this
		// notify flag was reset
		m_pSheet->NotifyMMC();
    }

    return bSuccess;
}



void
CInetPropertyPage::SetModified(BOOL bChanged)
{
    CPropertyPage::SetModified(bChanged);
    m_bChanged = bChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\shutdown.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        shutdown.cpp

   Abstract:
        IIS Shutdown/restart dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "shutdown.h"



//
// Shutdown in milliseconds
//
#define IIS_SHUTDOWN_TIMEOUT        300000L



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CRITICAL_SECTION gcs;



UINT
__cdecl
StopIISServices(
    IN LPVOID pParam
    )
/*++

Routine Description:

    Worker thread to perform IIS Service Control Command

Arguments:

    LPVOID * pParam     : Casts to IISCOMMAND (see above)

Return Value:

    UINT

--*/
{
    IISCOMMAND * pCmd = (IISCOMMAND *)pParam;

    // 
    // This thread needs its own CoInitialize
    //
    CError err(CoInitialize(NULL));             

    ASSERT_PTR(pCmd->pMachine);
    CIISSvcControl isc(pCmd->pMachine->QueryAuthInfo());
    err = isc.QueryResult();

    //
    // Block access to pCmd since the main thread will try to
    // delete it.
    //
    EnterCriticalSection(&gcs);

    if (err.Succeeded())
    {
        err = isc.Stop(IIS_SHUTDOWN_TIMEOUT, TRUE);
    }

    //
    // Clean Up, returning the error code
    //
    EnterCriticalSection(&pCmd->cs);
    pCmd->fFinished = TRUE;
    pCmd->hReturn   = err;
    LeaveCriticalSection(&pCmd->cs);
    LeaveCriticalSection(&gcs);

    return 0;
}



//
// Shutdown progress dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Timer ID and values
//
#define ID_TIMER (1)
#define A_SECOND (1000L)    



CShutProgressDlg::CShutProgressDlg(IISCOMMAND * pCommand, BOOL bShowCancel)
/*++

Routine Description:

    Constructor for shutdown progress dialog

Arguments:

    IISCOMMAND * pCommand       : Command structure

Return Value:

    N/A

--*/
    : CDialog(CShutProgressDlg::IDD, pCommand->pParent),
      m_pCommand(pCommand),
      m_bShowCancel(bShowCancel),
      m_uTimeoutSec(pCommand->dwMilliseconds / A_SECOND)
{
    //{{AFX_DATA_INIT(CShutProgressDlg)
    //}}AFX_DATA_INIT
}



void 
CShutProgressDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CShutProgressDlg)
    DDX_Control(pDX, IDC_STATIC_PROGRESS, m_static_ProgressMsg);
    DDX_Control(pDX, IDC_PROGRESS_SHUTDOWN, m_prgShutdown);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CShutProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CShutProgressDlg)
    ON_WM_TIMER()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CShutProgressDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    VERIFY(m_strProgress.LoadString(IDS_SHUTDOWN_PROGRESS));

    m_nProgress = 0;
    m_prgShutdown.SetRange32(0, m_uTimeoutSec);
    m_prgShutdown.SetPos(m_nProgress);
    m_prgShutdown.SetStep(1);

    if (!m_bShowCancel)
    {
        GetDlgItem(IDOK)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATIC_STATUS)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_STATUS)->ShowWindow(SW_HIDE);
    }
    //
    // Start the progress bar ticking, once per second.
    //
    UINT_PTR nID = SetTimer(ID_TIMER, A_SECOND, NULL);

    if (nID != ID_TIMER)
    {
        //
        // Failed to create the timer.  Pop up an error, and 
        // cancel the dialog.  
        // 
        CError err(ERROR_NO_SYSTEM_RESOURCES);
        err.MessageBox(m_hWnd);
        EndDialog(IDCANCEL);
    }
    
    return TRUE; 
}



void 
CShutProgressDlg::OnTimer(
    IN UINT nIDEvent
    ) 
/*++

Routine Description:

    Timer handler.  Upgrade the progressbar with another second on the clock

Arguments:

    UINT nIDEvent       : Timer id

Return Value:

    None

--*/
{
    ASSERT(nIDEvent == ID_TIMER);

    m_prgShutdown.SetPos(++m_nProgress);

    //
    // Display progress on the tick marker
    //
    CString str;
    str.Format(m_strProgress, m_uTimeoutSec - (UINT)m_nProgress  + 1);
    m_static_ProgressMsg.SetWindowText(str);

    //
    // Check to see if the stop thread has finished its action already
    //
    BOOL fFinished;

    EnterCriticalSection(&m_pCommand->cs);
    fFinished = m_pCommand->fFinished;
    LeaveCriticalSection(&m_pCommand->cs);

    if (fFinished)
    {
        //
        // The worker thread has finished, so there's no reason to
        // keep the user in suspense -- dismiss the dialog
        //
        EndDialog(IDCANCEL); 
    }

    if ((UINT)m_nProgress > m_uTimeoutSec)
    {
        //
        // We've timed out -- tell the main thread to Kill!()
        //
        OnOK();
    }

    //
    // I doubt there's any default processing here, but anyway...
    //
    CDialog::OnTimer(nIDEvent);
}



void 
CShutProgressDlg::OnDestroy() 
/*++

Routine Description:

    Handle dialog destruction, kill the timer.

Arguments:

    None

Return Value:
    
    None

--*/
{
    CDialog::OnDestroy();

    ::KillTimer(m_hWnd, (UINT_PTR)ID_TIMER);
}



void 
CShutProgressDlg::OnOK()
/*++

Routine Description:

    OK handler -- ok button maps to "Kill Now!"

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Kill!
    //
    EndDialog(IDOK);
}



void 
CShutProgressDlg::OnCancel() 
/*++

Routine Description:

    Cancel button handler.  This dialog cannot be cancelled, so the cancel
    notification is eaten.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Eat cancel command (user pressed escape)
    //
}



//
// Shutdown dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISShutdownDlg::CIISShutdownDlg(
    IN CIISMachine * pMachine,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pMachine  : Machine object
    CWnd * pParent          : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CIISShutdownDlg::IDD, pParent),
      m_fServicesRestarted(FALSE),
      m_pMachine(pMachine)
{
    //{{AFX_DATA_INIT(CIISShutdownDlg)
    //}}AFX_DATA_INIT

    ASSERT_PTR(m_pMachine);
}



void 
CIISShutdownDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIISShutdownDlg)
    DDX_Control(pDX, IDC_COMBO_RESTART,  m_combo_Restart);
    DDX_Control(pDX, IDC_STATIC_DETAILS, m_static_Details);
    //}}AFX_DATA_MAP
}



void
CIISShutdownDlg::SetDetailsText()
/*++

Routine Description:

    Set the details text to correspond to what's in the combo box

Arguments:

    None

Return Value:

    None

--*/
{
    UINT nSel = m_combo_Restart.GetCurSel();

//    ASSERT(nSel >= 0 && nSel < NUM_ISC_ITEMS);

    m_static_Details.SetWindowText(m_strDetails[nSel]);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISShutdownDlg, CDialog)
    //{{AFX_MSG_MAP(CIISShutdownDlg)
    ON_CBN_SELCHANGE(IDC_COMBO_RESTART, OnSelchangeComboRestart)
    ON_CBN_DBLCLK(IDC_COMBO_RESTART, OnDblclkComboRestart)
    ON_BN_CLICKED(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



HRESULT
CIISShutdownDlg::PerformCommand(int iCmd, BOOL bShowCancel)
/*++

Routine Description:

    Perform restart command

Arguments:

    int iCmd - One of the following commands:

        ISC_START
        ISC_STOP
        ISC_SHUTDOWN
        ISC_RESTART

Return Value:

    HRESULT

--*/
{
    //
    // Make sure the service is supported
    //
    ASSERT_PTR(m_pMachine);

    BeginWaitCursor();
    CIISSvcControl isc(m_pMachine->QueryAuthInfo());
    EndWaitCursor();

    CError err(isc.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    //
    // Create command structure to hand off to 
    // worker thread
    //
    IISCOMMAND * pCommand = new IISCOMMAND;

    if (!pCommand)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    ::ZeroMemory(pCommand, sizeof(IISCOMMAND));
    pCommand->pMachine = m_pMachine;
    pCommand->dwMilliseconds = IIS_SHUTDOWN_TIMEOUT;
    pCommand->pParent = this;

    InitializeCriticalSection(&pCommand->cs);
    InitializeCriticalSection(&gcs);

    CShutProgressDlg dlg(pCommand, bShowCancel);
    CWinThread * pStopThread = NULL;
    BOOL fStartServices      = FALSE;
    INT_PTR nReturn          = IDCANCEL;

    //
    // Fire off the thread that does the actual work, while we
    // put up the progress UI
    //
    switch(iCmd)
    {
    case ISC_RESTART:
        ++fStartServices;
        //
        // Fall through...
        //
    case ISC_STOP:
        //
        // Stop the services in the workerthread
        //
        pStopThread = AfxBeginThread(&StopIISServices, pCommand);
        nReturn = dlg.DoModal();
        break;

    case ISC_START:
        ++fStartServices;
        break;

    case ISC_SHUTDOWN:
        BeginWaitCursor();
        err = isc.Reboot(IIS_SHUTDOWN_TIMEOUT, m_pMachine->IsLocal());
        EndWaitCursor();
        break;

    default:
        //
        // Internal error!
        //
        ASSERT_MSG("Invalid command code!");
        err = ERROR_INVALID_FUNCTION;
    }

    //
    // Determine if a kill is necessary (timed-out or user
    // pressed 'Kill')
    //
    BeginWaitCursor();

    if (nReturn == IDOK)
    {
        TRACEEOLID("Killing now!");
        err = isc.Kill();
        Sleep(1000L);
    }
    else
    {
        //
        // Waiting for the thread to finish
        //
        if (pStopThread != NULL)
        {
            BOOL fDone = FALSE;

            while(!fDone)
            {
                TRACEEOLID("Checking to see if thread has finished");

                EnterCriticalSection(&pCommand->cs);

                if (pCommand->fFinished)
                {
                    err = pCommand->hReturn;
                    ++fDone;
                }

                LeaveCriticalSection(&pCommand->cs);

                //
                // Pause a bit to catch our breath.
                //
                if (!fDone)
                {
                    Sleep(500);
                }
            }
        }
    }

    //
    // Everything should be stopped, start it up again
    // if necessary.
    //
    if (err.Succeeded() && fStartServices)
    {
        err = isc.Start(IIS_SHUTDOWN_TIMEOUT);
        m_fServicesRestarted = err.Succeeded();
    }

    EndWaitCursor();

    //
    // Clean up when the worker thread says we can.
    //
    EnterCriticalSection(&gcs);
    DeleteCriticalSection(&pCommand->cs);
    delete pCommand;
    LeaveCriticalSection(&gcs);

    DeleteCriticalSection(&gcs);

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CIISShutdownDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Load combobox text and details
    //
    CString strFmt, str;

    //
    // This may take a second or two...
    //
    BeginWaitCursor();
    CIISSvcControl isc(m_pMachine->QueryAuthInfo());
    EndWaitCursor();

    CError err(isc.QueryResult());

    if (err.Failed())
    {
        //
        // Failed to obtain interface -- quit now.
        //
        if (err.HResult() == REGDB_E_CLASSNOTREG
         || err.HResult() == CS_E_PACKAGE_NOTFOUND
           )
        {
            //
            // Friendly message about the interface not being supported.
            //
            DoHelpMessageBox(m_hWnd,IDS_ERR_NO_SHUTDOWN, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
        }
        else
        {
            m_pMachine->DisplayError(err, m_hWnd);
        }

        EndDialog(IDCANCEL);
    }

    UINT nOption = IDS_IIS_START;
    UINT nDetails = IDS_IIS_START_DETAILS;

    for (int i = ISC_START; i <= ISC_RESTART; ++i)
    {
        VERIFY(strFmt.LoadString(nOption++));
        str.Format(strFmt, m_pMachine->QueryServerName());
        VERIFY(m_strDetails[i].LoadString(nDetails++));

        m_combo_Restart.AddString(str);
    }
    
    m_combo_Restart.SetCurSel(ISC_RESTART);
    m_combo_Restart.SetFocus();

    SetDetailsText();
    
    return FALSE;  
}



void 
CIISShutdownDlg::OnSelchangeComboRestart() 
/*++

Routine Description:

    Selection change notification handler.  Change the text in the details
    static text to reflect the new selection in the combo box

Arguments:

    None

Return Value:

    None

--*/
{
    SetDetailsText();
}



void 
CIISShutdownDlg::OnDblclkComboRestart() 
/*++

Routine Description:

    Double-click notification handler.  Maps to OK

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Go with the current selection
    //
    OnOK();
}



void 
CIISShutdownDlg::OnOK() 
/*++

Routine Description:

    "OK" button has been pressed, and perform the selected action.

Arguments:

    None

Return Value:

    None

--*/
{
    int iCmd = m_combo_Restart.GetCurSel();

    CError err = PerformCommand(iCmd);

    if (err.Failed())
    {
        m_pMachine->DisplayError(err, m_hWnd);

        //
        // Failed -- do not dismiss the dialog
        //
        return;
    }

    //
    // No error, dismiss the dialog
    //
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\stdafx.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        stdafx.h

   Abstract:

        Precompiled header file

   Author:

        Just about totally auto-generated.

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __STDAFX_H__
#define __STDAFX_H__

#define VC_EXTRALEAN

#include <ctype.h>

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

// for remoteenv.h
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxtempl.h>
#include <afxcmn.h>
#include <afxdtctl.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
//#include <atlsnap.h>

#include <iiscnfg.h>
#include <inetreg.h>
#include <lmcons.h>
#include <tchar.h>

#include <aclapi.h>
#include <shlwapi.h>

#define _COMIMPORT
#include "common.h"
#include "atlsnap.h"
#include "debugdefs.h"
#include "msgbox.h"


#include "iishelp.h"

//{{AFX_INSERT_LOCATION}}


#endif // __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\shts.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        shts.h

   Abstract:
        IIS Property sheet definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __SHTS_H__
#define __SHTS_H__

#include "iisobj.h"

//
// Sheet Definitions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Sheet -> page crackers
//
#define BEGIN_META_INST_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryInstanceResult()))                       \
        {                                                                \
            break;                                                       \
        }

#define FETCH_INST_DATA_FROM_SHEET(value)\
    value = pSheet->GetInstanceProperties().value;                       \
    TRACEEOLID(value);

#define END_META_INST_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_DIR_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryDirectoryResult()))                      \
        {                                                                \
            break;                                                       \
        }

#define FETCH_DIR_DATA_FROM_SHEET(value)\
    value = pSheet->GetDirectoryProperties().value;                      \
    TRACEEOLID(value);

#define END_META_DIR_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_INST_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_INST_DATA_ON_SHEET(value)\
        pSheet->GetInstanceProperties().value = value;

#define STORE_INST_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetInstanceProperties().value = value;    \
        dirty = MP_D(((sheet *)GetSheet())->GetInstanceProperties().value);

#define FLAG_INST_DATA_FOR_DELETION(id)\
        pSheet->GetInstanceProperties().FlagPropertyForDeletion(id);

#define END_META_INST_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetInstanceProperties().WriteDirtyProps();            \
}


#define BEGIN_META_DIR_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_DIR_DATA_ON_SHEET(value)\
        pSheet->GetDirectoryProperties().value = value;

#define STORE_DIR_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetDirectoryProperties().value = value;      \
        dirty = MP_D(pSheet->GetDirectoryProperties().value);

#define INIT_DIR_DATA_MASK(value, mask)\
        MP_V(pSheet->GetDirectoryProperties().value).SetMask(mask);

#define FLAG_DIR_DATA_FOR_DELETION(id)\
        pSheet->GetDirectoryProperties().FlagPropertyForDeletion(id);

#define END_META_DIR_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetDirectoryProperties().WriteDirtyProps();           \
}

class CInetPropertyPage;

class CInetPropertySheet : public CPropertySheet
/*++

Class Description:

    IIS Object configuration property sheet.

Public Interface:

    CInetPropertySheet          : Constructor
    ~CInetPropertySheet         : Destructor

    cap                         : Get capabilities

--*/
{
    DECLARE_DYNAMIC(CInetPropertySheet)

//
// Construction/destruction
//
public:
    CInetPropertySheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN CWnd * pParentWnd        = NULL,
        IN LPARAM lParam            = 0L,
        IN LPARAM lParamParentObject = 0L,
        IN UINT iSelectPage         = 0
        );

    virtual ~CInetPropertySheet();

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CInetPropertySheet)
    //}}AFX_VIRTUAL

//
// Access
//
public:
    BOOL IsLocal()            const { return m_auth.IsLocal(); }
    BOOL IsMasterInstance()   const { return m_fIsMasterPath; }
    BOOL HasAdminAccess()     const { return m_fHasAdminAccess; }
    BOOL RestartRequired()    const { return m_fRestartRequired; }
    DWORD QueryInstance()     const { return m_dwInstance; }
    LPCTSTR QueryServerName() const { return m_auth.QueryServerName(); }
    LPCTSTR QueryMetaPath()   const { return m_strMetaPath; }

    LPCTSTR QueryServicePath() const { return m_strServicePath; }
    LPCTSTR QueryInstancePath() const { return m_strInstancePath; }
    LPCTSTR QueryDirectoryPath() const { return m_strDirectoryPath; }
    LPCTSTR QueryInfoPath() const { return m_strInfoPath; }

    CComAuthInfo * QueryAuthInfo()  { return &m_auth; }
    CServerCapabilities & cap()     { return *m_pCap; }
    LPARAM GetParameter() {return m_lParam;}
    LPARAM GetParameterParent() {return m_lParamParentObject;}

public:
    void AddRef() 
    { 
       ++m_refcount; 
    }
    void Release(CInetPropertyPage * pPage) 
    { 
       DetachPage(pPage);
       if (--m_refcount <= 0) 
          delete this; 
    }
    void AttachPage(CInetPropertyPage * pPage);
    void NotifyMMC();
	void NotifyMMC_Node(CIISObject * pNode);
	void SetNotifyFlag(DWORD flag)
	{
		m_prop_change_flag |= flag;
	}
	void ResetNotifyFlag()
	{
		m_prop_change_flag = 0;
	}
    void SetModeless();
    BOOL IsModeless() const { return m_bModeless; }

public:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    //
    // Override in derived class to load delayed values
    //
    virtual HRESULT LoadConfigurationParameters();
    virtual void SetObjectsHwnd();
    virtual void FreeConfigurationParameters();

    void SetRestartRequired(BOOL flag, 
		DWORD update_flag = PROP_CHANGE_REENUM_VDIR | PROP_CHANGE_REENUM_FILES);
    WORD QueryMajorVersion() const;
    WORD QueryMinorVersion() const;

//
// Generated message map functions
//
protected:
   //{{AFX_MSG(CInetPropertySheet)
   //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void Initialize();
    void DetachPage(CInetPropertyPage * pPage);

    //
    // Attempt to resolve admin/operator access for the given
    // metbase path (instance path)
    //
    HRESULT DetermineAdminAccess(DWORD * pdwMetabaseSystemChangeNum);

    void SetIsMasterInstance(BOOL flag) {m_fIsMasterPath = flag;}

protected:
    int     m_refcount;
	DWORD	m_prop_change_flag;
	BOOL	m_fChanged;
    DWORD   m_dwInstance;
    CString m_strMetaPath;
    CString m_strServicePath;
    CString m_strInstancePath;
    CString m_strDirectoryPath;
    CString m_strInfoPath;
    CComAuthInfo m_auth;

private:
    BOOL    m_bModeless;
    BOOL    m_fHasAdminAccess;
    BOOL    m_fIsMasterPath;
    BOOL    m_fRestartRequired;
    LPARAM  m_lParam;
    LPARAM  m_lParamParentObject;
    CServerCapabilities *  m_pCap;
    CList<CInetPropertyPage *, CInetPropertyPage *&> m_pages;
};



//
// Page Definitions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CInetPropertyPage : public CPropertyPage
/*++

Class Description:

    IIS Configuration property page class

Public Interface:

    CInetPropertyPage           : Constructor
    ~CInetPropertyPage          : Destructor

    SaveInfo                    : Save info on this page if dirty

--*/
{
    DECLARE_DYNAMIC(CInetPropertyPage)

//
// Construction/Destruction
//
public:
    CInetPropertyPage(
        IN UINT nIDTemplate,
        IN CInetPropertySheet * pSheet,
        IN UINT nIDCaption              = USE_DEFAULT_CAPTION,
        IN BOOL fEnableEnhancedFonts    = FALSE
        );

    ~CInetPropertyPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CInetPropertyPage)
    //enum { IDD = _UNKNOWN_RESOURCE_ID_ };
    //}}AFX_DATA

//
// Overrides
//
public:
    //
    // Derived classes must provide their own equivalents
    //
    /* PURE */ virtual HRESULT FetchLoadedValues() = 0;
    /* PURE */ virtual HRESULT SaveInfo() = 0;

    //
    // Is the data on this page dirty?
    //
    BOOL IsDirty() const { return m_bChanged; }

    //{{AFX_VIRTUAL(CInetPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext & dc) const;
#endif

protected:
    //
    // Generated message map functions
    //
    //{{AFX_MSG(CInetPropertyPage)
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
	virtual void OnCancel();

//
// Helper function
//
protected:
    BOOL GetIUsrAccount(CString & str);

//
// Access Functions
//
protected:
    //
    // Get associated property sheet object
    //
    CInetPropertySheet * GetSheet()     { return m_pSheet; }
    BOOL IsLocal()            const     { return m_pSheet->IsLocal(); }
    BOOL IsMasterInstance()   const     { return m_pSheet->IsMasterInstance(); }
    BOOL HasAdminAccess()     const     { return m_pSheet->HasAdminAccess(); }
    DWORD QueryInstance()     const     { return m_pSheet->QueryInstance(); }
    LPCTSTR QueryServerName() const     { return m_pSheet->QueryServerName(); }
    LPCTSTR QueryMetaPath() const       { return m_pSheet->QueryMetaPath(); }
    LPCTSTR QueryServicePath() const    { return m_pSheet->QueryServicePath(); }
    LPCTSTR QueryInstancePath() const   { return m_pSheet->QueryInstancePath(); }
    LPCTSTR QueryDirectoryPath() const  { return m_pSheet->QueryDirectoryPath(); }
    LPCTSTR QueryInfoPath() const       { return m_pSheet->QueryInfoPath(); }
    CComAuthInfo * QueryAuthInfo()      { return m_pSheet->QueryAuthInfo(); }
    HRESULT LoadConfigurationParameters() { return m_pSheet->LoadConfigurationParameters(); }

    //
    // Update MMC with new changes
    //
    void NotifyMMC(DWORD param = PROP_CHANGE_NOT_VISIBLE);

public:
    //
    // Keep private information on page dirty state, necessary for
    // SaveInfo() later.
    //
    void SetModified(BOOL bChanged = TRUE);

//
// Capability bits
//
protected:
    BOOL IsSSLSupported()       const { return m_pSheet->cap().IsSSLSupported(); }
    BOOL IsSSL128Supported()    const { return m_pSheet->cap().IsSSL128Supported(); }
    BOOL HasMultipleSites()     const { return m_pSheet->cap().HasMultipleSites(); }
    BOOL HasBwThrottling()      const { return m_pSheet->cap().HasBwThrottling(); }
    BOOL Has10ConnectionLimit() const { return m_pSheet->cap().Has10ConnectionLimit(); }
    BOOL HasIPAccessCheck()     const { return m_pSheet->cap().HasIPAccessCheck(); }
    BOOL HasOperatorList()      const { return m_pSheet->cap().HasOperatorList(); } 
    BOOL HasFrontPage()         const { return m_pSheet->cap().HasFrontPage(); }
    BOOL HasCompression()       const { return m_pSheet->cap().HasCompression(); }
    BOOL HasCPUThrottling()     const { return m_pSheet->cap().HasCPUThrottling(); }
    BOOL HasDigest()            const { return m_pSheet->cap().HasDigest(); }
    BOOL HasNTCertMapper()      const { return m_pSheet->cap().HasNTCertMapper(); }

	BOOL IsCompressionConfigurable()  const { return m_pSheet->cap().IsCompressionConfigurable(); }
	BOOL IsPerformanceConfigurable()  const { return m_pSheet->cap().IsPerformanceConfigurable(); }
	BOOL IsServiceLevelConfigurable() const { return m_pSheet->cap().IsServiceLevelConfigurable(); }
	BOOL IsWorkstation()              const { return m_pSheet->cap().IsWorkstation(); }

protected:
    BOOL m_bChanged;
    CInetPropertySheet * m_pSheet;

protected:
    BOOL      m_fEnableEnhancedFonts;
    CFont     m_fontBold;
    UINT      m_nHelpContext;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CInetPropertySheet::SetModeless()
{
    m_bModeless = TRUE;
}

inline void CInetPropertySheet::SetRestartRequired(BOOL flag, DWORD update_flag)
{
   m_fRestartRequired = flag;
   m_prop_change_flag = update_flag;
}

inline HRESULT CInetPropertySheet::DetermineAdminAccess(DWORD * pdwMetabaseSystemChangeNum)
{
    //
    // Make sure this is called after parms are loaded.
    //
    return m_pCap ? ::DetermineIfAdministrator(
        m_pCap,                      // Reuse existing interface
        m_strMetaPath,
        &m_fHasAdminAccess,
        pdwMetabaseSystemChangeNum
        ) : E_FAIL;
}

inline BOOL CInetPropertyPage::GetIUsrAccount(CString & str)
{
    return ::GetIUsrAccount(QueryServerName(), this, str);
}

inline void CInetPropertyPage::NotifyMMC(DWORD param)
{
    m_pSheet->SetNotifyFlag(param);
}

#endif // __SHTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\shutdown.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        shutdown.h

   Abstract:
        IIS Shutdown/restart dialog definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __SHUTDOWN_H__
#define __SHUTDOWN_H__

//
// IIS Service Command
//
typedef struct tagIISCOMMAND
{
    //TCHAR   szServer[MAX_PATH + 1];
    BOOL    fFinished;
    HRESULT hReturn;
    DWORD   dwMilliseconds;
    CWnd  * pParent;
    CIISMachine * pMachine;
    CRITICAL_SECTION cs;
}   
IISCOMMAND;


//
// Shutdown progress dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CShutProgressDlg : public CDialog
/*++

Class Description:

    Shutdown progress indicator dialog.  Displays a progress bar, and gives
    the opportunity to kill immediately.

Public Interface:

    CShutProgressDlg        Constructor

Notes:

    This dialog displays a progress bar with the number of seconds for shutdown.

    The return value is IDOK if Kill() should be executed, or if no further action
    is required.

--*/
{
//
// Construction
//
public:
    CShutProgressDlg(IISCOMMAND * pCommand, BOOL bShowCancel = TRUE);   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CShutProgressDlg)
    enum { IDD = IDD_SD_PROGRESS };
    CStatic       m_static_ProgressMsg;
    CProgressCtrl m_prgShutdown;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CShutProgressDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX); 
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CShutProgressDlg)
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnDestroy();
    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    int m_nProgress;
    UINT m_uTimeoutSec;
    IISCOMMAND * m_pCommand;
    CString m_strProgress;
    BOOL m_bShowCancel;
};



//
// Shutdown dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



enum
{
    //
    // Note: make sure that associated resource IDs remain
    //       sequential.
    //
    ISC_START,
    ISC_STOP,
    ISC_SHUTDOWN,
    ISC_RESTART,
    /**/
    NUM_ISC_ITEMS
};



class CIISShutdownDlg : public CDialog
/*++

Class Description:

    IIS Shutdown/Restart dialog

Public Interface:

    CIISShutdownDlg         - Constructor

    ServicesWereRestarted   Returns true if the services were restarted

--*/
{
//
// Construction
//
public:
    CIISShutdownDlg(
        IN CIISMachine * pMachine,
        IN CWnd * pParent       = NULL
        );

//
// Access
//
public:
    BOOL ServicesWereRestarted() const { return m_fServicesRestarted; }
    HRESULT PerformCommand(int iCmd, BOOL bShowCancel = TRUE);

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISShutdownDlg)
    enum { IDD = IDD_SHUTDOWN };
    CStatic     m_static_Details;
    CComboBox   m_combo_Restart;
    //}}AFX_DATA

    CString m_strDetails[NUM_ISC_ITEMS];

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIISShutdownDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CIISShutdownDlg)
    afx_msg void OnSelchangeComboRestart();
    afx_msg void OnDblclkComboRestart();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetDetailsText();

private:
    CIISMachine * m_pMachine;
    BOOL m_fServicesRestarted;
};



#endif // __SHUTDOWN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\supdlgs.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        supdlgs.h

   Abstract:
        Supporting dialogs definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

UINT IisMessageBox(HWND hWnd, LPCTSTR szText, UINT nType, UINT nIDHelp);
UINT IisMessageBox(HWND hWnd, UINT nIDText, UINT nType, UINT nIDHelp);


class CUserAccountDlg : public CDialog
/*++

Class Description:

    User account dialog.  Present a user account/password and allow
    changing, browsing and checking the password

Public Interface:

    CUserAccountDlg : Constructor

--*/
{
//
// Construction
//
public:
    CUserAccountDlg(
        IN LPCTSTR lpstrServer,
        IN LPCTSTR lpstrUserName,
        IN LPCTSTR lpstrPassword,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
public:
    //{{AFX_DATA(CUserAccountDlg)
    enum { IDD = IDD_USER_ACCOUNT };
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CButton m_chk_Delegation;
    CString m_strUserName;
    //}}AFX_DATA
    BOOL m_fDelegation;

    CStrPassword m_strPassword;
//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CUserAccountDlg)
	protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	//}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CUserAccountDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnChangeEditUsername();
    afx_msg void OnCheckDelegation();
    afx_msg void OnOK();
	afx_msg void OnHelp();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CString m_strServer;
};



class CClearTxtDlg : public CDialog
/*++

Class Description:

    Dialog which displays the clear text warning

Public Interface:

    CClearTxtDlg : Constructor
    
--*/
{
public:
    //
    // Constructor
    //
    CClearTxtDlg(CWnd * pParent = NULL);

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CClearTxtDlg)
    enum { IDD = IDD_CLEARTEXTWARNING };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CClearTxtDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CClearTxtDlg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};



class CIPAccessDescriptorListBox : public CHeaderListBox
/*++

Class Description:

    Listbox of CIPAccessDescriptor objects

Public Interface:

    CIPAccessDescriptorListBox : Constructor

    GetItem                  : Get CIPAccessDescriptor item at specified position
                               in the listbox
    AddItem                  : Add new CIPAccessDescriptor item to the listbox
    Initialize               : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CIPAccessDescriptorListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;

//
// Constructor/Destructor
//
public:
    CIPAccessDescriptorListBox(
        IN BOOL fDomainsAllowed = FALSE
        );

//
// Interface
//
public:
    CIPAccessDescriptor * GetItem(
        IN UINT nIndex
        );

    int AddItem(
        IN const CIPAccessDescriptor * pItem
        );

    //
    // Return the singly selected item, or NULL
    // if 0, or more than one item is selected
    //
    CIPAccessDescriptor * GetSelectedItem(
        OUT int * pnSel = NULL
        );

    //
    // Return next selected listbox item (doesn't matter
    // if the listbox is single select or multi-select)
    //
    CIPAccessDescriptor * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & ds
        );

protected:
    BOOL m_fDomainsAllowed;
    CString m_strGranted;
    CString m_strDenied;
    CString m_strFormat;
};



class CAccessEntryListBox : public CRMCListBox
/*++

Class Description:

    Listbox of access entry objects.  Listbox may be
    single or multiselect.

Public Interface:

    CAccessEntryListBox     : Constructor

    AddToAccessList         : Add to list
    FillAccessListBox       : Fill listbox
    ResolveAccessList       : Resolve all SIDS in the container
    AddUserPermissions      : Add user permissions
    GetSelectedItem         : Get item if it's the only one selected,
                              or NULL.

--*/
{
    DECLARE_DYNAMIC(CAccessEntryListBox);

public:
    static const nBitmaps;  // Number of bitmaps

//
// Constructor
//
public:
    CAccessEntryListBox(
        IN int nTab = 0
        );

//
// Interface
//
public:
    //
    // Return the singly selected item, or NULL
    // if 0, or more than one item is selected
    //
    CAccessEntry * GetSelectedItem(
        OUT int * pnSel = NULL
        );

    //
    // Return next selected listbox item (doesn't matter
    // if the listbox is single select or multi-select)
    //
    CAccessEntry * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    //
    // Get item at selection or NULL
    //
    CAccessEntry * GetItem(UINT nIndex);

//
// Interface to container
//
public:
    BOOL AddToAccessList(
        IN CWnd * pWnd,
        IN LPCTSTR lpstrServer,
        IN CObListPlus & obl
        );

    void FillAccessListBox(
        IN CObListPlus & obl
        );

protected:
    void ResolveAccessList(
        IN CObListPlus &obl
        );

    BOOL AddUserPermissions(
        IN LPCTSTR lpstrServer,
        IN CObListPlus &oblSID,
        IN CAccessEntry * newUser,
        IN ACCESS_MASK accPermissions
        );

//
// Interface to listbox
//
protected:
    int AddItem(CAccessEntry * pItem);
    void SetTabs(int nTab);

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    int m_nTab;
};


class CDnsNameDlg : public CDialog
{
/*++

Class Description:

    DNS Name resolution dialog.  Enter a DNS name, and this will be
    resolved to an IP address.  Optionally set the value in associated
    ip control.

Public Interface:

    CDnsNameDlg   : Construct the dialog

    QueryIPValue  : Find out the resolved IP address (only set when OK
                    is pressed).

--*/
//
// Construction
//
public:
    //
    // Construct with associated IP address control
    //
    CDnsNameDlg(
        IN CIPAddressCtrl * pIpControl = NULL,
        IN CWnd * pParent = NULL
        );

    //
    // Construct with IP value
    //
    CDnsNameDlg(
        IN DWORD dwIPValue,
        IN CWnd * pParent = NULL
        );

    DWORD QueryIPValue() const;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CDnsNameDlg)
    enum { IDD = IDD_DNS };
    CEdit   m_edit_DNSName;
    CButton m_button_OK;
    //}}AFX_DATA


//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CDnsNameDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CDnsNameDlg)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditDnsName();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    DWORD FillIpControlFromName();
    DWORD FillNameFromIpValue();

private:
    CIPAddressCtrl * m_pIpControl;
    DWORD m_dwIPValue;
};



class CIPAccessDlg : public CDialog
/*++

Class Description:

    Access description editor dialog.  If constructed with a NULL access
    descriptor pointer, the access descriptor object will be allocated.
    Otherwise, the dialog will work with the given access descriptor

Public Interface:

    CIPAccessDlg : Constructor

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CIPAccessDlg(
        IN BOOL fDenyAccessMode,
        IN OUT CIPAccessDescriptor *& pAccess,
        IN CObListPlus * poblAccessList = NULL,
        IN CWnd * pParent = NULL,
        IN BOOL fAllowDomains = FALSE
        );

//
// Dialog Data
//
protected:
    //
    // Must match type order
    //
    enum
    {
        RADIO_SINGLE,
        RADIO_MULTIPLE,
        RADIO_DOMAIN,
    };

    //{{AFX_DATA(CIPAccessDlg)
    enum { IDD = IDD_IP_ACCESS };
    int     m_nStyle;
    CEdit   m_edit_Domain;
    CStatic m_static_IpAddress;
    CStatic m_static_SubnetMask;
    CButton m_button_DNS;
    CButton m_button_OK;
    //}}AFX_DATA

    CButton       m_radio_Domain;
    CIPAddressCtrl m_ipa_IPAddress;
    CIPAddressCtrl m_ipa_SubnetMask;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIPAccessDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CIPAccessDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnRadioMultiple();
    afx_msg void OnRadioSingle();
    afx_msg void OnRadioDomain();
    afx_msg void OnButtonDns();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void SetControlStates(
        IN int nStyle
        );

private:
    BOOL m_fNew;
    BOOL m_fDenyAccessMode;
    BOOL m_fAllowDomains;
    CComBSTR m_bstrIPAddress;
    CComBSTR m_bstrNetworkID;
    CComBSTR m_bstrDomainName;
    CIPAccessDescriptor *& m_pAccess;
    CObListPlus * m_poblAccessList;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CAccessEntryListBox::CAccessEntryListBox (
    IN int nTab
    )
{
    SetTabs(nTab);
}

inline void CAccessEntryListBox::SetTabs(
    IN int nTab
    )
{
    m_nTab = nTab;
}

inline CAccessEntry * CAccessEntryListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CAccessEntry *)GetItemDataPtr(nIndex);
}

inline int CAccessEntryListBox::AddItem(
    IN CAccessEntry * pItem
    )
{
    return AddString ((LPCTSTR)pItem);
}

inline CAccessEntry * CAccessEntryListBox::GetSelectedItem(
    OUT int * pnSel
    )
{
    return (CAccessEntry *)CRMCListBox::GetSelectedListItem(pnSel);
}

inline CAccessEntry * CAccessEntryListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CAccessEntry *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CIPAccessDescriptor *)GetItemDataPtr(nIndex);
}

inline int CIPAccessDescriptorListBox::AddItem(
    IN const CIPAccessDescriptor * pItem
    )
{
    return AddString((LPCTSTR)pItem);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetSelectedItem(
    OUT int * pnSel
    )
{
    return (CIPAccessDescriptor *)CRMCListBox::GetSelectedListItem(pnSel);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CIPAccessDescriptor *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}

inline DWORD CDnsNameDlg::QueryIPValue() const
{
    return m_dwIPValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\supdlgs.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        supdlgs.cpp

   Abstract:
        Supporting dialogs

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include <iiscnfgp.h>
#include <winsock2.h>
#include "common.h"
#include "InetMgrApp.h"
#include "supdlgs.h"

extern CInetmgrApp theApp;

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Advanced");



//
// Site Security Listbox Column Definitions
//
// Note: IDS_IP_ADDRESS_SUBNET_MASK is overridden
//       in w3scfg
//
static const ODL_COLUMN_DEF g_aColumns[] =
{
// ===============================================
// Weight   Label                 
// ===============================================
    {  4,   IDS_ACCESS,                 },
    { 15,   IDS_IP_ADDRESS_SUBNET_MASK, },
};



#define NUM_COLUMNS (sizeof(g_aColumns) / sizeof(g_aColumns[0]))

//
// CUserAccountDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CUserAccountDlg::CUserAccountDlg(
    IN LPCTSTR lpstrServer,
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for bringing up the user account dialog

Arguments:

    LPCTSTR lpstrServer     : Server
    LPCTSTR lpstrUserName   : Starting Username
    LPCTSTR lpstrPassword   : Starting Password
    CWnd * pParent          : Parent window handle

Return Value:

    N/A

--*/
    : m_strUserName(lpstrUserName),
      m_strServer(lpstrServer),
      m_fDelegation(FALSE),
      CDialog(CUserAccountDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CUserAccountDlg)
    m_strPassword = lpstrPassword;
    //}}AFX_DATA_INIT
}



void 
CUserAccountDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CUserAccountDlg)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_DELEGATION, m_chk_Delegation);
    DDX_Check(pDX, IDC_DELEGATION, m_fDelegation);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    if (!m_fDelegation)
    {
		if (pDX->m_bSaveAndValidate)
		{
			DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);
		}
		//DDX_Password(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
        DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
		if (pDX->m_bSaveAndValidate)
		{
			//DDV_MaxCharsBalloon(pDX, m_strPassword, PWLEN);
            DDV_MaxCharsBalloon_SecuredString(pDX, m_strPassword, PWLEN);
		}
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CUserAccountDlg, CDialog)
    //{{AFX_MSG_MAP(CUserAccountDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_DELEGATION, OnCheckDelegation)
    ON_BN_CLICKED(IDOK, OnOK)
    ON_BN_CLICKED(ID_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
CUserAccountDlg::OnInitDialog()
{
    m_fDelegation = m_strUserName.IsEmpty();
    BOOL bRes = CDialog::OnInitDialog();
    OnCheckDelegation();
    return bRes;
}

void
CUserAccountDlg::OnOK()
{
    CDialog::OnOK();
    if (m_fDelegation)
    {
        m_strUserName.Empty();
        m_strPassword.Empty();
    }
}

void
CUserAccountDlg::OnButtonBrowseUsers()
{
    CString str;

    if (GetIUsrAccount(m_strServer, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}

void
CUserAccountDlg::OnCheckDelegation()
{
    BOOL bEnable = BST_CHECKED != m_chk_Delegation.GetCheck();
    m_edit_UserName.EnableWindow(bEnable);
    m_edit_Password.EnableWindow(bEnable);
    GetDlgItem(IDC_BUTTON_BROWSE_USERS)->EnableWindow(bEnable);
}


void 
CUserAccountDlg::OnChangeEditUsername() 
{
    m_edit_Password.SetWindowText(_T(""));
}



void
CUserAccountDlg::OnButtonCheckPassword()
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CString csTempPassword;
    m_strPassword.CopyTo(csTempPassword);
    CError err(CComAuthInfo::VerifyUserPassword(m_strUserName, csTempPassword));

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        DoHelpMessageBox(m_hWnd,IDS_PASSWORD_OK, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
    }
}


void
CUserAccountDlg::OnHelp()
{
    WinHelpDebug(0x20000 + CUserAccountDlg::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CUserAccountDlg::IDD);
}

//
// Text dialog that warns of clear text violation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CClearTxtDlg::CClearTxtDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Clear text dialog constructor

Arguments:

    CWnd * pParent : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CClearTxtDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CClearTxtDlg)
    //}}AFX_DATA_INIT
}



void
CClearTxtDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CClearTxtDlg)
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CClearTxtDlg, CDialog)
    //{{AFX_MSG_MAP(CClearTxtDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CClearTxtDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    (GetDlgItem(IDCANCEL))->SetFocus();
    CenterWindow();
    MessageBeep(MB_ICONEXCLAMATION);

    return FALSE;
}


IMPLEMENT_DYNAMIC(CIPAccessDescriptorListBox, CHeaderListBox);




//
// Bitmap indices
//
enum
{
    BMPID_GRANTED = 0,
    BMPID_DENIED,
    BMPID_SINGLE,
    BMPID_MULTIPLE,

    //
    // Don't move this one
    //
    BMPID_TOTAL
};




const int CIPAccessDescriptorListBox::nBitmaps = BMPID_TOTAL;




CIPAccessDescriptorListBox::CIPAccessDescriptorListBox(
    IN BOOL fDomainsAllowed
    )
/*++

Routine Description:

    Constructor

Arguments:

    fDomainsAllowed : TRUE if domain names are legal.

Return Value:

    N/A

--*/
    : m_fDomainsAllowed(fDomainsAllowed),
      CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    m_strGranted.LoadString(IDS_GRANTED);
    m_strDenied.LoadString(IDS_DENIED);
    m_strFormat.LoadString(IDS_FMT_SECURITY);
}




void
CIPAccessDescriptorListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds : Draw item structure

Return Value:

    None

--*/
{
    CIPAccessDescriptor * p = (CIPAccessDescriptor *)ds.m_ItemData;
    ASSERT_READ_PTR(p);

    //
    // Display Granted/Denied with appropriate bitmap
    //
    DrawBitmap(ds, 0, p->HasAccess() ? BMPID_GRANTED : BMPID_DENIED);
    ColumnText(ds, 0, TRUE, p->HasAccess() ? m_strGranted : m_strDenied);

    //
    // Display IP Address with multiple/single bitmap
    //
    DrawBitmap(ds, 1, p->IsSingle() ? BMPID_SINGLE : BMPID_MULTIPLE);

    if (p->IsDomainName())
    {
        ColumnText(ds, 1, TRUE, p->QueryDomainName());
    }
    else if (p->IsSingle())
    {
        //
        // Display only ip address
        //
        ColumnText(ds, 1, TRUE, p->QueryIPAddress());
    }
    else
    {
        //
        // Display ip address/subnet mask
        //
        CString str, strIP, strMask;

        str.Format(
            m_strFormat, 
            (LPCTSTR)p->QueryIPAddress().QueryIPAddress(strIP), 
            (LPCTSTR)p->QuerySubnetMask().QueryIPAddress(strMask)
            );
        ColumnText(ds, 1, TRUE, str);
    }
}




/* virtual */
BOOL 
CIPAccessDescriptorListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay 
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    HINSTANCE hInst = AfxGetResourceHandle();
    for (int nCol = 0; nCol < NUM_COLUMNS; ++nCol)
    {
        InsertColumn(nCol, g_aColumns[nCol].nWeight, g_aColumns[nCol].nLabelID, hInst);
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}




//
// CAccessEntryListBox - a listbox of user SIDs
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNAMIC(CAccessEntryListBox, CRMCListBox);



const int CAccessEntryListBox::nBitmaps = 8;



void
CAccessEntryListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CAccessEntry * pEntry = (CAccessEntry *)ds.m_ItemData;
    ASSERT_READ_PTR(pEntry);
    ASSERT(pEntry->IsSIDResolved());

    DrawBitmap(ds, 0, pEntry->QueryPictureID());
    ColumnText(ds, 0, TRUE, pEntry->QueryUserName());
}



void
CAccessEntryListBox::FillAccessListBox(
    IN CObListPlus & obl
    )
/*++

Routine Description:

    Fill a listbox with entries from the oblist.

    Entries will not be shown if the deleted flag is set, or if
    their access mask does not fit with the requested access mask.

Arguments:

    CObListPlus & obl       : List of access entries

Return Value:

    None.

--*/
{
    CObListIter obli(obl);
    CAccessEntry * pAccessEntry;

    //
    // Remember the selection.
    //
    CAccessEntry * pSelEntry = GetSelectedItem();

    SetRedraw(FALSE);
    ResetContent();
    int cItems = 0;

    for ( /**/ ; pAccessEntry = (CAccessEntry *)obli.Next(); ++cItems)
    {
        if (pAccessEntry->IsVisible() && !pAccessEntry->IsDeleted())
        {
            AddItem(pAccessEntry);
        }
    }

    SetRedraw(TRUE);
    SelectItem(pSelEntry);
}



void 
CAccessEntryListBox::ResolveAccessList(
    IN CObListPlus &obl
    )
/*++

Routine Description:

    For each member of the list, resolve the SID into a username.

Arguments:

    CObListPlus & obl       : List of access entries

Return Value:

    None.

--*/
{
    CObListIter obli(obl);
    CAccessEntry * pAccessEntry;

    while (pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (!pAccessEntry->IsSIDResolved())
        {
            pAccessEntry->ResolveSID();
        }
    }
}



BOOL
CAccessEntryListBox::AddUserPermissions(
    IN LPCTSTR lpstrServer,
    IN CObListPlus &oblSID,
    IN CAccessEntry * newUser,
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Add a user to the service list.  The return value is
    what would be its listbox index.

Arguments:

    LPCTSTR lpstrServer             : Server name
    CObListPlus &oblSID             : List of SIDs
    CAccessEntry * newUser          : User details from user browser
    ACCESS_MASK accPermissions      : Access permissions

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CAccessEntry * pAccessEntry;

    //
    // Look it up in the list to see if it exists already
    //
    CObListIter obli(oblSID);

    while(pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (*pAccessEntry == newUser->GetSid())
        {
            TRACEEOLID("Found existing account -- adding permissions");

            if (pAccessEntry->IsDeleted())
            {
                //
                // Back again..
                //
                pAccessEntry->FlagForDeletion(FALSE);
            }
            break;
        }
    }

    if (pAccessEntry == NULL)
    {
        //
        // I am creating new entry here to be sure that I could delete 
        // it from the input array. The SID is copied to new entry.
        //
        pAccessEntry = new CAccessEntry(*newUser);
        if (pAccessEntry)
        {
	        pAccessEntry->MarkEntryAsNew();
   	     oblSID.AddTail(pAccessEntry);
   	  }
   	  else
   	  {
		     return FALSE;
		  }
    }

    pAccessEntry->AddPermissions(accPermissions);

    return TRUE;
}


/*

BOOL
CAccessEntryListBox::AddUserPermissions(
    IN LPCTSTR lpstrServer,
    IN CObListPlus &oblSID,
    IN LPUSERDETAILS pusdtNewUser,
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Add a user to the service list.  The return value is
    the what would be its listbox index.

Arguments:

    LPCTSTR lpstrServer             : Server name
    CObListPlus &oblSID             : List of SIDs
    LPUSERDETAILS pusdtNewUser      : User details from user browser
    ACCESS_MASK accPermissions      : Access permissions

Return Value:

    TRUE for success, FALSE for failure.

--/
{
    //
    // Look it up in the list to see if it exists already
    //
    CObListIter obli(oblSID);
    CAccessEntry * pAccessEntry;

    while(pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (*pAccessEntry == pusdtNewUser->psidUser)
        {
            TRACEEOLID("Found existing account -- adding permissions");

            if (pAccessEntry->IsDeleted())
            {
                //
                // Back again..
                //
                pAccessEntry->FlagForDeletion(FALSE);
            }
            break;
        }
    }

    if (pAccessEntry == NULL)
    {
        TRACEEOLID("This account did not yet exist -- adding new one");

        pAccessEntry = new CAccessEntry(accPermissions,
            pusdtNewUser->psidUser,
            lpstrServer,
            TRUE
            );

        if (!pAccessEntry)
        {
            TRACEEOLID("AddUserPermissions: OOM");
            return FALSE;
        }

        pAccessEntry->MarkEntryAsNew();
        oblSID.AddTail(pAccessEntry);
    }
    else
    {
        pAccessEntry->AddPermissions(accPermissions);
    }

    return TRUE;
}


*/



BOOL
CAccessEntryListBox::AddToAccessList(
    IN  CWnd * pWnd,
    IN  LPCTSTR lpstrServer,
    OUT CObListPlus & obl
    )
/*++

Routine Description:

    Bring up the Add Users and Groups dialogs from netui.

Arguments:

    CWnd * pWnd             : Parent window
    LPCTSTR lpstrServer     : Server that owns the accounts
    CObListPlus & obl       : Returns the list of selected users.

Return Value:

    TRUE if anything was added, FALSE otherwise.

--*/
{
    CGetUsers usrBrowser(lpstrServer, TRUE);
    BOOL bRes = usrBrowser.GetUsers(pWnd->GetSafeHwnd());
    UINT cItems = 0;

    if (bRes)
    {
        //
        // Specify access mask for an operator
        //
        ACCESS_MASK accPermissions =
            (MD_ACR_READ | MD_ACR_WRITE | MD_ACR_ENUM_KEYS);

        for (int i = 0; i < usrBrowser.GetSize(); i++)
        {
            if (!AddUserPermissions(lpstrServer, obl, usrBrowser[i], accPermissions))
            {
                bRes = FALSE;
                break;
            }

            cItems++;
        }
    }
    if (cItems > 0)
    {
        FillAccessListBox(obl);
    }
    return bRes;
}



CDnsNameDlg::CDnsNameDlg(
    IN CIPAddressCtrl * pIpControl OPTIONAL,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Construct with optional associated IP address control

Arguments:

    CWndIpAddress * pIpControl : Associated IP control
    CWnd * pParent             : Pointer to parent window

Return Value:

    N/A

--*/
    : m_pIpControl(pIpControl),
      m_dwIPValue(0L),
      CDialog(CDnsNameDlg::IDD, pParent)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CDnsNameDlg)
    //}}AFX_DATA_INIT

#endif // 0

    if (m_pIpControl)
    {
        m_pIpControl->GetAddress(m_dwIPValue);
    }
}



CDnsNameDlg::CDnsNameDlg(
    IN DWORD dwIPValue,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Construct with associated IP value

Arguments:

    DWORD dwIPValue : IP Value
    CWnd * pParent  : Pointer to parent window

Return Value:

    N/A

--*/
    : m_pIpControl(NULL),
      m_dwIPValue(dwIPValue),
      CDialog(CDnsNameDlg::IDD, pParent)
{
}



void
CDnsNameDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDnsNameDlg)
    DDX_Control(pDX, IDC_EDIT_DNS_NAME, m_edit_DNSName);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDnsNameDlg, CDialog)
    //{{AFX_MSG_MAP(CDnsNameDlg)
    ON_EN_CHANGE(IDC_EDIT_DNS_NAME, OnChangeEditDnsName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



DWORD 
CDnsNameDlg::FillIpControlFromName()
/*++

Routine Description:

    Do a DNS lookup from the hostname in the edit control, and place
    the ip value in the ip control if we have one.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CString str;
    DWORD err = 0;
    HOSTENT * pHostent = NULL;

    m_edit_DNSName.GetWindowText(str);

    BeginWaitCursor();

#ifdef _UNICODE

    CHAR * pAnsi = AllocAnsiString(str);

    if (pAnsi == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    pHostent = ::gethostbyname(pAnsi);

#else

    pHostent = ::gethostbyname((LPCTSTR)str);

#endif // _UNICODE;

    if (pHostent != NULL)
    {
        //
        // Got a valid lookup.  Convert the value to host order,
        // optionally set the value in the associated ip control
        //
        m_dwIPValue = ::ntohl(*((u_long *)pHostent->h_addr_list[0]));
        if (m_pIpControl)
        {
            m_pIpControl->SetAddress(m_dwIPValue);
        }
    }
    else
    {
        err = ::WSAGetLastError();
		if (err == WSANO_DATA)
			err = WSAHOST_NOT_FOUND;
    }

    EndWaitCursor();

#ifdef _UNICODE

    FreeMem(pAnsi);

#endif // _UNICODE

    return err;
}



DWORD
CDnsNameDlg::FillNameFromIpValue()
/*++

Routine Description:

    Given the ip value, fill, do a reverse lookup, and fill the name in
    the edit control.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (m_dwIPValue == 0L)
    {
        //
        // Don't bother filling this
        // one in -- not an error, though
        //
        return err;
    }

    //
    // Call the Winsock API to get host name and alias information.
    //
    u_long ulAddrInNetOrder = ::htonl((u_long)m_dwIPValue);

    BeginWaitCursor();
    HOSTENT * pHostInfo = ::gethostbyaddr(
        (CHAR *)&ulAddrInNetOrder,
        sizeof ulAddrInNetOrder, 
        PF_INET 
        );
    EndWaitCursor();

    if (pHostInfo == NULL)
    {
        return ::WSAGetLastError();
    }

    try
    {
        CString str(pHostInfo->h_name);
        m_edit_DNSName.SetWindowText(str);
    }
    catch(CException * e)
    {
        err = ::GetLastError();
        e->Delete();
    }

    return err;
}

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void
CDnsNameDlg::OnOK()
/*++

Routine Description:

    Attempt to resolve the the IP address in response to the OK button
    being pressed.  Don't dismiss the dialog if the name is not
    resolvable.

Arguments:

    None

Return Value:

    None

--*/
{
    CError err(FillIpControlFromName());
    if (err.Failed())
    {
		UINT errId = 0;

		if (err.Win32Error() == WSAHOST_NOT_FOUND)
		{
			errId = IDS_WSAHOST_NOT_FOUND;
		}
		if (errId == 0)
		{
			err.MessageBoxOnFailure(m_hWnd);
		}
		else
		{
            DoHelpMessageBox(m_hWnd,errId, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
		}
        //
        // Failed, don't dismiss the dialog
        //
        return;
    }

    //
    // Dismiss the dialog
    //
    CDialog::OnOK();
}



void
CDnsNameDlg::OnChangeEditDnsName()
/*++

Routine Description:

    Enable/disable the ok button depending on the contents of the edit control.

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_OK.EnableWindow(m_edit_DNSName.GetWindowTextLength() > 0);
}



BOOL 
CDnsNameDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // If an address has been pre-set do a reverse lookup
    //
    if (m_dwIPValue)
    {
        CError err(FillNameFromIpValue());
        err.MessageBoxOnFailure(m_hWnd);
    }

    OnChangeEditDnsName();

    return TRUE;
}



//
// IP Access Dialog
//



CIPAccessDlg::CIPAccessDlg(
    IN BOOL fDenyAccessMode,
    IN OUT CIPAccessDescriptor *& pAccess,
    IN CObListPlus * poblAccessList         OPTIONAL,
    IN CWnd * pParent                       OPTIONAL,
    IN BOOL fAllowDomains
    )
/*++

Routine Description:

    Constructor for the access descriptor editor dialog.  If constructed
    with a NULL access descriptor pointer, the access descriptor will
    be allocated, otherwise the dialog will edit the existing one in
    place.

Arguments:

    BOOL fDenyAccessMode         : If TRUE, we're denying access, if FALSE,
                                   we're granting access.
    CIPAccessDescriptor *& pAccess : Object being edited, or NULL to allocate 
                                   a new access descriptor
    CObListPlus * poblAccessList : List of already existing entries to check
                                   for duplicates, or NULL
    CWnd * pParent,              : Pointer to parent window or NULL
    BOOL fAllowDomains           : If TRUE, domain names are valid, otherwise
                                   they will not be available

Return Value:

    N/A

--*/
    : CDialog(CIPAccessDlg::IDD, pParent),
      m_pAccess(pAccess),
      m_poblAccessList(poblAccessList),
      m_fNew(pAccess == NULL),
      m_fDenyAccessMode(fDenyAccessMode),
      m_fAllowDomains(fAllowDomains)
{
#if 0   // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CIPAccessDlg)
    m_nStyle = RADIO_SINGLE;
    //}}AFX_DATA_INIT

#endif // 0

    if (m_pAccess == NULL)
    {
        //
        // Allocate new one
        //
        m_pAccess = new CIPAccessDescriptor;

        if (m_pAccess)
        {
            m_pAccess->GrantAccess(!m_fDenyAccessMode);
        }
    }

    if (m_pAccess == NULL)
    {
        TRACEEOLID("Invalid access object -- possible memory failure");
        return;
    }
    
    if (m_pAccess->IsDomainName())
    {
        m_nStyle = RADIO_DOMAIN;
    }
    else
    {
        m_nStyle = m_pAccess->IsSingle() ? RADIO_SINGLE : RADIO_MULTIPLE;
    }

    //
    // We can only look at granted items when
    // deny by default is on and vice versa
    //
    ASSERT(m_pAccess->HasAccess() == !m_fDenyAccessMode);

    //
    // Load static strings
    //
    VERIFY(m_bstrIPAddress.LoadString(IDS_PROMPT_IP_ADDRESS));
    VERIFY(m_bstrNetworkID.LoadString(IDS_PROMPT_NETWORK_ID));
    VERIFY(m_bstrDomainName.LoadString(IDS_PROMPT_DOMAIN));
}



void
CIPAccessDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIPAccessDlg)
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Control(pDX, IDC_EDIT_DOMAIN, m_edit_Domain);
    DDX_Control(pDX, IDC_STATIC_IP_ADDRESS, m_static_IpAddress);
    DDX_Control(pDX, IDC_STATIC_SUBNET_MASK, m_static_SubnetMask);
    DDX_Control(pDX, IDC_BUTTON_DNS, m_button_DNS);
    DDX_Radio(pDX, IDC_RADIO_SINGLE, m_nStyle);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_RADIO_DOMAIN, m_radio_Domain);
    DDX_Control(pDX, IDC_IPA_IPADDRESS, m_ipa_IPAddress);
    DDX_Control(pDX, IDC_IPA_SUBNET_MASK, m_ipa_SubnetMask);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIPAccessDlg, CDialog)
    //{{AFX_MSG_MAP(CIPAccessDlg)
    ON_BN_CLICKED(IDC_RADIO_MULTIPLE, OnRadioMultiple)
    ON_BN_CLICKED(IDC_RADIO_SINGLE, OnRadioSingle)
    ON_BN_CLICKED(IDC_RADIO_DOMAIN, OnRadioDomain)
    ON_BN_CLICKED(IDC_BUTTON_DNS, OnButtonDns)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPA_IPADDRESS, OnItemChanged)
    ON_EN_CHANGE(IDC_IPA_SUBNET_MASK, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN, OnItemChanged)

END_MESSAGE_MAP()



void
CIPAccessDlg::SetControlStates(
    IN int nStyle
    )
/*++

Routine Description:

    Show/hide controls depending on the type of access descriptor we're
    editing.

Arguments:

    int nStyle : Radio button style

Return Value:

    None

--*/
{
    m_nStyle = nStyle;

    ActivateControl(m_ipa_IPAddress,     m_nStyle != RADIO_DOMAIN);
    ActivateControl(m_static_SubnetMask, m_nStyle == RADIO_MULTIPLE);
    ActivateControl(m_ipa_SubnetMask,    m_nStyle == RADIO_MULTIPLE);
    ActivateControl(m_button_DNS,        m_nStyle == RADIO_SINGLE);
    ActivateControl(m_edit_Domain,       m_nStyle == RADIO_DOMAIN);

    //
    // Change the prompt over the editbox/ip address box to explain
    // what's supposed to be edited.
    //
    switch(m_nStyle)
    {
    case RADIO_SINGLE:
        m_static_IpAddress.SetWindowText(m_bstrIPAddress);
        break;

    case RADIO_MULTIPLE:
        m_static_IpAddress.SetWindowText(m_bstrNetworkID);
        break;

    case RADIO_DOMAIN:
        ASSERT(m_fAllowDomains);
        m_static_IpAddress.SetWindowText(m_bstrDomainName);
        break;
    }
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CIPAccessDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    ASSERT_READ_PTR(m_pAccess);

    if (m_pAccess == NULL)
    {
        CError err(ERROR_NOT_ENOUGH_MEMORY);
        TRACEEOLID("access descriptor is NULL -- aborting dialog");
        err.MessageBox(m_hWnd);
        EndDialog(IDCANCEL);

        return FALSE;
    }

    //
    // Domain selection not always available
    //
    ASSERT(!(!m_fAllowDomains && m_pAccess->IsDomainName()));
    ActivateControl(m_radio_Domain, m_fAllowDomains);

    //
    // Use an appropriate title for the dialog depending on
    // whether we're editing a 'grant' item or a 'deny' item
    //
    CComBSTR bstrTitle;
    
    VERIFY(bstrTitle.LoadString(m_fDenyAccessMode ? IDS_DENY : IDS_GRANT));
    SetWindowText(bstrTitle);

    //
    // Set fields to be edited
    //
    if (m_pAccess->IsDomainName())
    {
        m_edit_Domain.SetWindowText(m_pAccess->QueryDomainName());    
    }
    else
    {
        DWORD dwIP = m_pAccess->QueryIPAddress();

        if (dwIP != 0L)
        {
            m_ipa_IPAddress.SetAddress(m_pAccess->QueryIPAddress());
        }

        if (!m_pAccess->IsSingle())
        {
            m_ipa_SubnetMask.SetAddress(m_pAccess->QuerySubnetMask());
        }
    }

    //
    // Configure the dialog appropriately
    //
    SetControlStates(m_nStyle);

    //
    // No changes made yet
    //
    m_button_OK.EnableWindow(FALSE);

    return TRUE;
}



void
CIPAccessDlg::OnRadioSingle()
/*++

Routine Description:

    'Single' radio button has been pressed. Change dialog style 
    appropriately.

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates(RADIO_SINGLE);
    OnItemChanged();
}



void
CIPAccessDlg::OnRadioMultiple()
/*++

Routine Description:

    'Multiple' radio button has been pressed. Change dialog style 
    appropriately.

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates(RADIO_MULTIPLE);
    OnItemChanged();
}



void 
CIPAccessDlg::OnRadioDomain() 
/*++

Routine Description:

    'Domain' radio button has been pressed. Change dialog style 
    appropriately.  If this the first time domain has been pressed,
    put up a warning about the performance implications of using
    domain filtering.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_fAllowDomains);

    static BOOL fShownWarning = FALSE;

    if (!fShownWarning)
    {
        fShownWarning = TRUE;
        DoHelpMessageBox(m_hWnd,IDS_DOMAIN_PERF, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
    }

    SetControlStates(RADIO_DOMAIN);
    OnItemChanged();
}



void 
CIPAccessDlg::OnItemChanged()
/*++

Routine Description:

    Control data has changed.  Check to see if sufficient data have been
    entered given the type of access descriptor being edited, and enable
    or disable the OK button based on that result.

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwIP;
    DWORD dwMask;
    BOOL fOK = FALSE;
    CString strDomain;

    switch(m_nStyle)
    {
    case RADIO_DOMAIN:
        m_edit_Domain.GetWindowText(strDomain);
        fOK = !strDomain.IsEmpty();
        break;

    case RADIO_SINGLE:
        m_ipa_IPAddress.GetAddress(dwIP);
        fOK = (dwIP != 0L);
        break;

    case RADIO_MULTIPLE:
        m_ipa_IPAddress.GetAddress(dwIP);
        m_ipa_SubnetMask.GetAddress(dwMask);
        fOK = (dwIP != 0L && dwMask != 0L);
        break;
    }
    
    m_button_OK.EnableWindow(fOK);
}



void 
CIPAccessDlg::OnButtonDns() 
/*++

Routine Description:

    'DNS' Button was pressed.  Bring up the DNS name resolver dialog
    which will set the value in the associated IP address control.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for a DNS name to resolve to an IP address.  The ip address
    // control is passed along to the dns name dialog which will manage
    // the ip addresses in it automatically.
    //
    CDnsNameDlg dlg(&m_ipa_IPAddress);
    dlg.DoModal();
}



void
CIPAccessDlg::OnCancel()
/*++

Routine Description:

    IDCANCEL handler.  If we had allocated the access descriptor, throw it
    away now.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fNew && m_pAccess != NULL)
    {
        delete m_pAccess;
        m_pAccess = NULL;
    }

    CDialog::OnCancel();
}



void
CIPAccessDlg::OnOK()
/*++

Routine Description:

    Handler for IDOK.  Save control data to the access descriptor object
    being edited.  If we have a list of access descriptors, check for
    duplicates.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must have been allocated by now.
    //
    ASSERT_READ_PTR(m_pAccess);

    UpdateData(TRUE);

    if (m_nStyle == RADIO_DOMAIN)
    {
        CString strDomain;
        m_edit_Domain.GetWindowText(strDomain);

        //
        // Ensure that wildcards are used only in the first char
        // of the name, or not at all.
        //
        int nWildCard;
        if ((nWildCard = strDomain.ReverseFind(_T('*'))) != -1)
        {
            if (nWildCard != 0 
                || strDomain.GetLength() < 3 
                || strDomain[1] != _T('.'))
            {
                //
                // Don't dismiss
                //
                m_edit_Domain.SetFocus();
                m_edit_Domain.SetSel(0,-1);
                EditShowBalloon(m_edit_Domain.m_hWnd, IDS_INVALID_DOMAIN_NAME);
                return;
            }
        }

        m_pAccess->SetValues(!m_fDenyAccessMode, strDomain);
    }
    else 
    {
        DWORD dwIP;
        m_ipa_IPAddress.GetAddress(dwIP);

        //
        // Filter out bogus ip addresses
        //
        if (dwIP == 0L || dwIP == (DWORD)-1L)
        {
            //
            // Don't dismiss the dialog
            //
            m_ipa_IPAddress.SetFocus();
//            EditShowBalloon(m_ipa_IPAddress.m_hWnd, IDS_IP_INVALID);
            DoHelpMessageBox(m_hWnd,IDS_IP_INVALID, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
            return;
        }

        if (m_nStyle == RADIO_SINGLE)
        {
            m_pAccess->SetValues(!m_fDenyAccessMode, dwIP);
        }
        else // Multiple
        {
            DWORD dwMask;
            m_ipa_SubnetMask.GetAddress(dwMask);

            m_pAccess->SetValues(!m_fDenyAccessMode, dwIP, dwMask);
        }
    }

    //
    // Check for duplicates in the list
    //
    if (m_poblAccessList)
    {
        if (m_pAccess->DuplicateInList(*m_poblAccessList))
        {
            //
            // Found duplicate; don't dismiss the dialog
            //
//            EditShowBalloon(m_ipa_IPAddress.m_hWnd, IDS_DUPLICATE_ENTRY);
            DoHelpMessageBox(m_hWnd,IDS_DUPLICATE_ENTRY, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
            return;
        }
    }

    //
    // Everything ok -- dismiss the dialog.
    //
    EndDialog(IDOK);
}

void CALLBACK MsgBoxCallback(LPHELPINFO lpHelpInfo)
{
    WinHelpDebug(lpHelpInfo->dwContextId);

	AfxGetApp()->WinHelp(lpHelpInfo->dwContextId);
} 

// this version accepts a text string
UINT IisMessageBox(HWND hWnd, LPCTSTR szText, UINT nType, UINT nIDHelp = 0)
{
	MSGBOXPARAMS mbp;

	memset(&mbp, 0, sizeof mbp);

	mbp.cbSize = sizeof MSGBOXPARAMS; 
	mbp.hwndOwner = hWnd; 
	mbp.hInstance = AfxGetInstanceHandle(); 
	mbp.lpszText = szText; 

	// if you wanted to specify a different caption, here is where you do it
	CString cap;
	cap.LoadString(IDS_APP_NAME);
	mbp.lpszCaption = cap; 

	// if Help ID is not 0, then add a help button
	if (nIDHelp != 0)
	{
		mbp.dwStyle = nType | MB_HELP; 
	}
	else
	{
		mbp.dwStyle = nType; 
	}

	//  mbp.lpszIcon = ; // note, you could provide your own custom ICON here!

	mbp.dwContextHelpId = nIDHelp; 
	mbp.lpfnMsgBoxCallback = &MsgBoxCallback; 
//	mbp.dwLanguageId = 0x0409;
	
	return ::MessageBoxIndirect(&mbp); 
}

// this version accepts a resource string identifier
UINT IisMessageBox(HWND hWnd, UINT nIDText, UINT nType, UINT nIDHelp = 0)
{
	CString s;
	s.LoadString(nIDText);
	return IisMessageBox(hWnd, s, nType, nIDHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\svc.cpp ===
#include "stdafx.h"
#include "common.h"
#include "svc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//----------------------------------------------------------------------------------------
//Routine Description:
//    This routine allocates a buffer for the specified service's configuration parameters,
//    and retrieves those parameters into the buffer.  The caller is responsible for freeing
//    the buffer.
//Remarks:
//    The pointer whose address is contained in ServiceConfig is guaranteed to be NULL upon
//    return if any error occurred.
//-----------------------------------------------------------------------------------------
DWORD RetrieveServiceConfig(IN SC_HANDLE ServiceHandle,OUT LPQUERY_SERVICE_CONFIG *ServiceConfig)
{
    DWORD ServiceConfigSize = 0, Err;
    if (NULL == ServiceConfig)
    {
        return ERROR_INVALID_PARAMETER; 
    }
    *ServiceConfig = NULL;
    while(TRUE) {
        if(QueryServiceConfig(ServiceHandle, *ServiceConfig, ServiceConfigSize, &ServiceConfigSize)) 
			{
            //assert(*ServiceConfig);
            return NO_ERROR;
			}
		else 
			{
            Err = GetLastError();
            if(*ServiceConfig) {free(*ServiceConfig);*ServiceConfig=NULL;}
            if(Err == ERROR_INSUFFICIENT_BUFFER) 
				{
                // Allocate a larger buffer, and try again.
                if(!(*ServiceConfig = (LPQUERY_SERVICE_CONFIG) malloc(ServiceConfigSize)))
                    {
                    return ERROR_NOT_ENOUGH_MEMORY;
                    }
				} 
			else 
				{
                if (ServiceConfig)
                {
                    *ServiceConfig = NULL;
                }
                return Err;
				}
			}
    }
}


//  returns SVC_NOTEXIST if the service does not exist
//  returns SVC_DISABLED if the service is disabled
//  returns SVC_AUTO_START if the the service is auto start
//  returns SVC_MANUAL_START if the the service is not auto start
int GetServiceStartupMode(LPCTSTR lpMachineName, LPCTSTR lpServiceName)
{
    int iReturn = SVC_NOTEXIST;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    // check if lpMachineName starts with \\
    // if it doesn't then make sure it does, or it's null (for local machine)
    LPTSTR lpNewMachineName = NULL;
    if (_tcsicmp(lpMachineName, _T("")) != 0)
    {
        DWORD dwSize = 0;
        // Check if it starts with "\\"
        if (_tcsncmp(lpMachineName, _T("\\\\"), 2) == 0)
        {
            dwSize = (_tcslen(lpMachineName) * sizeof(TCHAR)) + (1 * sizeof(TCHAR));
            lpNewMachineName = (LPTSTR) LocalAlloc(LPTR, dwSize);
            if(lpNewMachineName != NULL)
            {
                _tcscpy(lpNewMachineName, lpMachineName);
            }
        }
        else
        {
            dwSize = ((_tcslen(lpMachineName) * sizeof(TCHAR)) + (3 * sizeof(TCHAR)));
            lpNewMachineName = (LPTSTR) LocalAlloc(LPTR, dwSize);
            if(lpNewMachineName != NULL)
            {
                _tcscpy(lpNewMachineName, _T("\\\\"));
                _tcscat(lpNewMachineName, lpMachineName);
            }
        }
    }

    if ((hScManager = OpenSCManager(lpNewMachineName, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
    {
        // Failed, or more likely the service doesn't exist
        iReturn = SVC_NOTEXIST;
        goto IsThisServiceAutoStart_Exit;
    }

    if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
    {
        iReturn = SVC_NOTEXIST;
        goto IsThisServiceAutoStart_Exit;
    }

    if(!ServiceConfig)
    {
        iReturn = SVC_NOTEXIST;
        goto IsThisServiceAutoStart_Exit;
    }

    // SERVICE_AUTO_START Specifies a device driver or service started by the service control manager automatically during system startup. 
    // SERVICE_BOOT_START Specifies a device driver started by the system loader. This value is valid only if the service type is SERVICE_KERNEL_DRIVER or SERVICE_FILE_SYSTEM_DRIVER. 
    // SERVICE_DEMAND_START Specifies a device driver or service started by the service control manager when a process calls the StartService function. 
    // SERVICE_DISABLED Specifies a device driver or service that can no longer be started. 
    // SERVICE_SYSTEM_START Specifies a device driver started by the IoInitSystem function. This value is valid only if the service type is SERVICE_KERNEL_DRIVER or SERVICE_FILE_SYSTEM_DRIVER. 
    if (SERVICE_DISABLED == ServiceConfig->dwStartType)
    {
        iReturn = SVC_DISABLED;
    }
    else if (SERVICE_DEMAND_START == ServiceConfig->dwStartType)
    {
        iReturn = SVC_MANUAL_START;
    }
    else
    {
        iReturn = SVC_AUTO_START;
    }

IsThisServiceAutoStart_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    if (lpNewMachineName) {LocalFree(lpNewMachineName);}
    return iReturn;
}

// SERVICE_DISABLED
// SERVICE_AUTO_START
// SERVICE_DEMAND_START
INT ConfigServiceStartupType(LPCTSTR lpMachineName, LPCTSTR lpServiceName, int iNewType)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
    DWORD dwNewServiceStartupType = 0;
    BOOL bDoStuff =  FALSE;

    // check if lpMachineName starts with \\
    // if it doesn't then make sure it does, or it's null (for local machine)
    LPTSTR lpNewMachineName = NULL;
    if (_tcsicmp(lpMachineName, _T("")) != 0)
    {
        DWORD dwSize = 0;
        // Check if it starts with "\\"
        if (_tcsncmp(lpMachineName, _T("\\\\"), 2) == 0)
        {
            dwSize = (_tcslen(lpMachineName) * sizeof(TCHAR)) + (1 * sizeof(TCHAR));
            lpNewMachineName = (LPTSTR) LocalAlloc(LPTR, dwSize);
            if(lpNewMachineName != NULL)
            {
                _tcscpy(lpNewMachineName, lpMachineName);
            }
        }
        else
        {
            dwSize = ((_tcslen(lpMachineName) * sizeof(TCHAR)) + (3 * sizeof(TCHAR)));
            lpNewMachineName = (LPTSTR) LocalAlloc(LPTR, dwSize);
            if(lpNewMachineName != NULL)
            {
                _tcscpy(lpNewMachineName, _T("\\\\"));
                _tcscat(lpNewMachineName, lpMachineName);
            }
        }
    }

    do {
        if ((hScManager = ::OpenSCManager( lpMachineName, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            if (ERROR_SERVICE_DOES_NOT_EXIST  != err)
            {
            }
            break;
        }

            if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
	        {
                err = GetLastError();
                break;
		}

            if(!ServiceConfig)
	        {
                err = GetLastError();
                break;
		}

	    // only set this on non-kernel drivers
	    if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
	    {
            // default it incase someone changes code below and logic gets messed up
            dwNewServiceStartupType = ServiceConfig->dwStartType;

            // if this service is disabled,
            // they don't do anything, just leave it alone.
            if (!(dwNewServiceStartupType == SERVICE_DISABLED))
            {
                if (iNewType == SERVICE_DISABLED)
                {
                    dwNewServiceStartupType = SERVICE_DISABLED;
                    bDoStuff = TRUE;
                }
                else if (iNewType == SERVICE_AUTO_START)
                {
                    // if the service is already the type we want then don't do jack
                    // SERVICE_AUTO_START
                    // SERVICE_BOOT_START
                    // SERVICE_DEMAND_START
                    // SERVICE_DISABLED
                    // SERVICE_SYSTEM_START
                    if (SERVICE_AUTO_START == dwNewServiceStartupType   || 
                        SERVICE_BOOT_START == dwNewServiceStartupType   ||
                        SERVICE_SYSTEM_START == dwNewServiceStartupType
                        )
                    {
                        // it's already auto start
                        // we don't have to do anything
                    }
                    else
                    {
                        dwNewServiceStartupType = SERVICE_AUTO_START;
                        bDoStuff = TRUE;
                    }
                }
                else
                {
                    // we want to make it manual start
                    // check if it's already that way
                    if (!(SERVICE_DEMAND_START == dwNewServiceStartupType))
                    {
                        dwNewServiceStartupType = SERVICE_DEMAND_START;
                        bDoStuff = TRUE;
                    }
                }
            }
            else
            {
                if (iNewType == SERVICE_AUTO_START)
                {
                    dwNewServiceStartupType = SERVICE_AUTO_START;
                    bDoStuff = TRUE;
                }
                else
                {
                    dwNewServiceStartupType = SERVICE_DEMAND_START;
                    bDoStuff = TRUE;
                }
            }

            if (TRUE == bDoStuff)
            {
                if ( !::ChangeServiceConfig(hService, SERVICE_NO_CHANGE, dwNewServiceStartupType, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL) )
                {
                    err = GetLastError();
                    break;
                }
            }
            else
            {
                break;
            }

        }
        else
        {
            break;
        }

    } while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    if (lpNewMachineName) {LocalFree(lpNewMachineName);}
    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\toolbar.h ===
#ifndef __TOOLBAR_H__
#define __TOOLBAR_H__

#include "resource.h"

//
// Icon background colour
//
#define RGB_BK_IMAGES (RGB(255,0,255))      // purple

void ToolBar_Init(void);
void ToolBar_Destroy(void);
HRESULT ToolBar_Create(LPCONTROLBAR lpControlBar,LPEXTENDCONTROLBAR lpExtendControlBar,IToolbar ** lpToolBar);

#endif // __TOOLBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\svc.h ===
#ifndef __SVC_H__
#define __SVC_H__

#define SVC_NOTEXIST        0
#define SVC_DISABLED        1
#define SVC_AUTO_START      2
#define SVC_MANUAL_START    3

int GetServiceStartupMode(LPCTSTR lpMachineName, LPCTSTR lpServiceName);
INT ConfigServiceStartupType(LPCTSTR lpMachineName, LPCTSTR lpServiceName, int iNewType);

#endif // __SVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\toolbar.cpp ===
#include "stdafx.h"
#include "common.h"
#include "iisobj.h"
#include "toolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


enum
{
    IDM_INVALID,            /* invalid command ID */
    IDM_CONNECT,
    IDM_DISCOVER,
    IDM_START,
    IDM_STOP,
    IDM_PAUSE,
    /**/
    IDM_TOOLBAR             /* Toolbar commands start here */
};

//
// Toolbar Definition.  String IDs for menu and tooltip 
// text will be resolved at initialization.  The InetmgrGlobalSnapinButtons
// button text and tooltips text will be loaded from the InetmgrGlobalSnapinButtons
// below, and should be kept in sync
//
MMCBUTTON InetmgrGlobalSnapinButtons[] =
{
    { IDM_CONNECT    - 1, IDM_CONNECT,    TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
 // { IDM_DISCOVER   - 1, IDM_DISCOVER,   TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { 0,                  0,              TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),  _T("") },

    { IDM_START      - 1, IDM_START,      TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { IDM_STOP       - 1, IDM_STOP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { IDM_PAUSE      - 1, IDM_PAUSE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
//    { IDM_RECYCLE    - 1, IDM_RECYCLE,    TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { 0,                  0,              TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),  _T("") },

    //
    // Add-on tools come here
    //
};

UINT InetmgrGlobalSnapinButtonIDs[] =
{
    /* IDM_CONNECT   */ IDS_MENU_CONNECT,   IDS_MENU_TT_CONNECT,
 // /* IDM_DISCOVER  */ IDS_MENU_DISCOVER,  IDS_MENU_TT_CONNECT,
    /* IDM_START     */ IDS_MENU_START,     IDS_MENU_TT_START,
    /* IDM_STOP      */ IDS_MENU_STOP,      IDS_MENU_TT_STOP,
    /* IDM_PAUSE     */ IDS_MENU_PAUSE,     IDS_MENU_TT_PAUSE,
//    /* IDM_RECYCLE   */ IDS_MENU_RECYCLE,   IDS_MENU_TT_RECYCLE
};

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
#define NUM_BUTTONS2 (ARRAYLEN(InetmgrGlobalSnapinButtons))
#define NUM_BITMAPS (5)
#define TB_COLORMASK        RGB(192,192,192)    // Lt. Gray


void ToolBar_Init(void)
{
	CComBSTR bstr;
	CString  str;
	int j = 0;
	for (int i = 0; i < NUM_BUTTONS2; ++i)
	{
		if (InetmgrGlobalSnapinButtons[i].idCommand != 0)
		{
			VERIFY(bstr.LoadString(InetmgrGlobalSnapinButtonIDs[j++]));
			VERIFY(bstr.LoadString(InetmgrGlobalSnapinButtonIDs[j++]));

			InetmgrGlobalSnapinButtons[i].lpButtonText = AllocString(bstr);
			InetmgrGlobalSnapinButtons[i].lpTooltipText = AllocString(bstr);
		}
	}

	return;
}

void ToolBar_Destroy(void)
{
	for (int i = 0; i < NUM_BUTTONS2; ++i)
	{
		if (InetmgrGlobalSnapinButtons[i].idCommand != 0)
		{
			SAFE_FREEMEM(InetmgrGlobalSnapinButtons[i].lpButtonText);
			SAFE_FREEMEM(InetmgrGlobalSnapinButtons[i].lpTooltipText);
		}
	}
}


HRESULT ToolBar_Create(LPCONTROLBAR lpControlBar,LPEXTENDCONTROLBAR lpExtendControlBar,IToolbar ** lpToolBar)
{
    //
    // Cache the control bar
    //
    HRESULT hr = S_OK;

    if (lpControlBar)
    {
        do
        {
            //
            // Create our toolbar
            //
            hr = lpControlBar->Create(TOOLBAR, lpExtendControlBar, (LPUNKNOWN *) lpToolBar);
            if (FAILED(hr))
            {
                break;
            }

            //
            // Add 16x16 bitmaps
            //
    		HBITMAP hToolBar = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR));
			if (NULL != hToolBar)
			{
            	hr = (*lpToolBar)->AddBitmap(NUM_BITMAPS, hToolBar, 16, 16, TB_COLORMASK);
				DeleteObject(hToolBar);
	            if (FAILED(hr))
	            {
	                break;
	            }
			}
			else
			{
				hr = E_UNEXPECTED;
				break;
			}

            //
            // Add the buttons to the toolbar
            //
            hr = (*lpToolBar)->AddButtons(NUM_BUTTONS2, InetmgrGlobalSnapinButtons);
        }
        while(FALSE);
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\tracker.h ===
#ifndef __TRACKER_H__
#define __TRACKER_H__

#include "resource.h"

class CPropertySheetTracker
{
public:
    CPropertySheetTracker(){};
	~CPropertySheetTracker(){};

public:
	void Init()
	{
		IISObjectOpenPropertySheets.RemoveAll();
	}

    void Add(CIISObject * pItem)
	{
		IISObjectOpenPropertySheets.AddTail(pItem);
	}

	void Del(CIISObject * pItem)
	{
        POSITION pos = IISObjectOpenPropertySheets.Find(pItem);
		if (pos)
		    {IISObjectOpenPropertySheets.RemoveAt(pos);}
	}

	void Clear()
	{
        IISObjectOpenPropertySheets.RemoveAll();
	}

    void Dump();

    BOOL IsPropertySheetOpenBelowMe(CComPtr<IConsoleNameSpace> pConsoleNameSpace,CIISObject * pItem,CIISObject ** ppItemReturned);
    BOOL IsPropertySheetOpenComputer(CIISObject * pItem,BOOL bIncludeComputerNode, CIISObject ** ppItemReturned);
    BOOL FindAlreadyOpenPropertySheet(CIISObject * pItem,CIISObject ** ppItemReturned);
    INT  OrphanPropertySheetsBelowMe(CComPtr<IConsoleNameSpace> pConsoleNameSpace,CIISObject * pItem,BOOL bOrphan);

private:
	CIISObjectList IISObjectOpenPropertySheets;
};

#endif // __TRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\tracker.cpp ===
#include "stdafx.h"
#include "common.h"
#include "iisobj.h"
#include "tracker.h"

extern INT g_iDebugOutputLevel;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void 
CPropertySheetTracker::Dump()
{
#if defined(_DEBUG) || DBG
    int iCount = 0;
    CString strGUIDName;
    GUID * pItemFromListGUID = NULL;
    CIISObject * pItemFromList = NULL;

	if (!(g_iDebugOutputLevel & DEBUG_FLAG_CIISOBJECT))
	{
		return;
	}

    DebugTrace(_T("Dump OpenPropertySheetList -------------- start (count=%d)\r\n"),IISObjectOpenPropertySheets.GetCount());

    POSITION pos = IISObjectOpenPropertySheets.GetHeadPosition();
    while (pos)
    {
	    pItemFromList = IISObjectOpenPropertySheets.GetNext(pos);
        if (pItemFromList)
        {
		    iCount++;

            // Get GUID Name
			pItemFromListGUID = (GUID*) pItemFromList->GetNodeType();
			if (pItemFromListGUID)
			{
				GetFriendlyGuidName(*pItemFromListGUID,strGUIDName);
			}

            // Get FriendlyName
            LPOLESTR pTempFriendly = pItemFromList->QueryDisplayName();

            DebugTrace(_T("Dump:[%3d] %p (%s) '%s'\r\n"),iCount,pItemFromList,strGUIDName,pTempFriendly ? pTempFriendly : _T(""));
        }
    }

    DebugTrace(_T("Dump OpenPropertySheetList -------------- end\r\n"));
#endif // _DEBUG

    return;
}

INT
CPropertySheetTracker::OrphanPropertySheetsBelowMe(CComPtr<IConsoleNameSpace> pConsoleNameSpace,CIISObject * pItem,BOOL bOrphan)
{
    BOOL bFound = FALSE;
    POSITION pos;
    INT iOrphanedCount = 0;

    // Loop thru all the open property sheets 
    // and see if there is a property sheet that is below me.
    GUID * pItemFromListGUID = NULL;
    CIISObject * pItemFromList = NULL;
    CIISMBNode * pItemFromListAsNode = NULL;
    CIISMachine * pItemFromListOwner = NULL;

    GUID * pItemGUID = NULL;
    CIISMBNode * pItemAsNode = NULL;
    CIISMachine * pItemOwner = NULL;

    pItemGUID = (GUID*) pItem->GetNodeType();

    // check if it's a leaf node...
    if (pItem->IsLeafNode())
    {
        //cWebServiceExtensionContainer
        //cWebServiceExtension
        //cApplicationNode
        //cFileNode
        return FALSE;
    }

    pItemAsNode = (CIISMBNode *) pItem;
    pItemOwner = pItemAsNode->GetOwner();

    pos = IISObjectOpenPropertySheets.GetHeadPosition();
    while (pos)
	{
		pItemFromList = IISObjectOpenPropertySheets.GetNext(pos);
        if (pItemFromList)
        {
            // Get Owner, if the owner Pointer
            // matches our passed in CIISObject
            // then this must be open for this computer...
            pItemFromListAsNode = (CIISMBNode *) pItemFromList;

            if (!pItemFromListAsNode)
            {
                // got a bad pointer to an object.
                // skip it...
                continue;
            }
        
            if (pItemFromListAsNode == pItem)
            {
                // we found ourself...
                // skip it
                continue;
            }

			pItemFromListOwner =  pItemFromListAsNode->GetOwner();
			if (!pItemFromListOwner)
			{
                // object doesn't have an owner...
                // skip it
                continue;
            }

            if (pItemFromListOwner != pItemOwner)
            {
                // they have different owners
                // they must be from different machines..
                // skip it
                continue;
            }

            pItemFromListGUID = (GUID*) pItemFromListAsNode->GetNodeType();
			if (!pItemFromListGUID)
			{
                // object doesn't have a guid who knows what type it is!!!
                ASSERT("Error:Item Missing GUID!");
                //continue;
            }

            //
            // Determine what type of object
            // we are checking, and cater to that object
            //
            bFound = FALSE;
            if (IsEqualGUID(*pItemGUID,cWebServiceExtensionContainer))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (IsEqualGUID(*pItemFromListGUID,cWebServiceExtension))
                {
                    if (pItemFromList->IsMyPropertySheetOpen())
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                continue;
            } else if (IsEqualGUID(*pItemGUID,cAppPoolNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (IsEqualGUID(*pItemFromListGUID,cApplicationNode))
                {
                    if (pItemFromList->IsMyPropertySheetOpen())
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                continue;
            } else if (IsEqualGUID(*pItemGUID,cAppPoolsNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (IsEqualGUID(*pItemFromListGUID,cAppPoolNode) ||
                    IsEqualGUID(*pItemFromListGUID,cApplicationNode)
                    )
                {
                    if (pItemFromList->IsMyPropertySheetOpen())
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                continue;
            } else if (IsEqualGUID(*pItemGUID,cInstanceNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (!IsEqualGUID(*pItemFromListGUID,cChildNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cFileNode)
                    )
                {
                    continue;
                }
            } else if (IsEqualGUID(*pItemGUID,cInstanceCollectorNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (!IsEqualGUID(*pItemFromListGUID,cInstanceNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cChildNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cFileNode)
                    )
                {
                    continue;
                }
            } else if (IsEqualGUID(*pItemGUID,cServiceCollectorNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                // could have these type below it
                if (!IsEqualGUID(*pItemFromListGUID,cInstanceCollectorNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cInstanceNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cChildNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cFileNode)
                    )
                {
                    continue;
                }
            } else if (IsEqualGUID(*pItemGUID,cCompMgmtService))
            {
                // who knows...
            }

            // check if this item is below the parent item's chain
            // of command...

            // Get that items parent and check if it's cookie
            // points to our object.

            // Check if the parent node points to us!
            BOOL bMatchedParent = FALSE;
			SCOPEDATAITEM si;
			::ZeroMemory(&si, sizeof(SCOPEDATAITEM));
			si.mask = SDI_PARAM;
			si.ID = pItemFromListAsNode->QueryScopeItem();;
			if (SUCCEEDED(pConsoleNameSpace->GetItem(&si)))
			{
                    // walk up the item's parentpath and see if our object is one of them...
                    INT ICount = 0;
                    HSCOPEITEM hSI = si.ID;
                    LONG_PTR lCookie = 0;
                    HRESULT hr = S_OK;
                    while (hSI)
                    {
                        HSCOPEITEM hSITemp = 0;
                        ICount++;
                        if (ICount > 30)
                        {
                            // possible infinite loop
                            break;
                        }

                        hr = pConsoleNameSpace->GetParentItem(hSI, &hSITemp, &lCookie);
                        if (FAILED(hr))
                        {
                            break;
                        }

                        if ( (LONG_PTR) pItem == lCookie)
                        {
                            bMatchedParent = TRUE;
                            break;
                        }
                        
                        hSI = hSITemp;
                    }
			}

            if (bMatchedParent)
            {
                bFound = TRUE;
                iOrphanedCount++;
                // Mark it as orphaned by
                // Erasing it's ScopeItem or ResultItem
                if (bOrphan)
                {
                    pItemFromList->ResetScopeItem();
                    pItemFromList->ResetResultItem();
                }
                // continue on to the next one...
            }
        }
    }

    if (iOrphanedCount > 0)
    {
        DebugTrace(_T("Orphaned PropertySheets=%d\r\n"),iOrphanedCount);
    }

    return iOrphanedCount;
}


//
// WARNING: this function will not really be helpfull
// if the objects have already been removed...
//
BOOL 
CPropertySheetTracker::IsPropertySheetOpenBelowMe(CComPtr<IConsoleNameSpace> pConsoleNameSpace,CIISObject * pItem,CIISObject ** ppItemReturned)
{
    BOOL bFound = FALSE;
    POSITION pos;

    // Loop thru all the open property sheets 
    // and see if there is a property sheet that is below me.
    GUID * pItemFromListGUID = NULL;
    CIISObject * pItemFromList = NULL;
    CIISMBNode * pItemFromListAsNode = NULL;
    CIISMachine * pItemFromListOwner = NULL;

    GUID * pItemGUID = NULL;
    CIISMBNode * pItemAsNode = NULL;
    CIISMachine * pItemOwner = NULL;

    if (!ppItemReturned)
    {
        return FALSE;
    }
    
    pItemGUID = (GUID*) pItem->GetNodeType();
    if (IsEqualGUID(*pItemGUID,cInternetRootNode) || IsEqualGUID(*pItemGUID,cMachineNode))
    {
        // they should be using a different funciton...
        return IsPropertySheetOpenComputer(pItem,FALSE,ppItemReturned);
    }

    // check if it's a leaf node...
    if (pItem->IsLeafNode())
    {
        //cWebServiceExtensionContainer
        //cWebServiceExtension
        //cApplicationNode
        //cFileNode
        return FALSE;
    }

    pItemAsNode = (CIISMBNode *) pItem;
    pItemOwner = pItemAsNode->GetOwner();

    pos = IISObjectOpenPropertySheets.GetHeadPosition();
    while (pos)
	{
		pItemFromList = IISObjectOpenPropertySheets.GetNext(pos);
        if (pItemFromList)
        {
            // Get Owner, if the owner Pointer
            // matches our passed in CIISObject
            // then this must be open for this computer...
            pItemFromListAsNode = (CIISMBNode *) pItemFromList;

            if (!pItemFromListAsNode)
            {
                // got a bad pointer to an object.
                // skip it...
                continue;
            }
        
            if (pItemFromListAsNode == pItem)
            {
                // we found ourself...
                // skip it
                continue;
            }

			pItemFromListOwner =  pItemFromListAsNode->GetOwner();
			if (!pItemFromListOwner)
			{
                // object doesn't have an owner...
                // skip it
                continue;
            }

            if (pItemFromListOwner != pItemOwner)
            {
                // they have different owners
                // they must be from different machines..
                // skip it
                continue;
            }

            pItemFromListGUID = (GUID*) pItemFromListAsNode->GetNodeType();
			if (!pItemFromListGUID)
			{
                // object doesn't have a guid who knows what type it is!!!
                ASSERT("Error:Item Missing GUID!");
                //continue;
            }

            //
            // Determine what type of object
            // we are checking, and cater to that object
            //
            if (IsEqualGUID(*pItemGUID,cWebServiceExtensionContainer))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (IsEqualGUID(*pItemFromListGUID,cWebServiceExtension))
                {
                    if (pItemFromList->IsMyPropertySheetOpen())
                    {
                        bFound = TRUE;
                        *ppItemReturned = pItemFromList;
                        break;
                    }
                }
                continue;
            } else if (IsEqualGUID(*pItemGUID,cAppPoolNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (IsEqualGUID(*pItemFromListGUID,cApplicationNode))
                {
                    if (pItemFromList->IsMyPropertySheetOpen())
                    {
                        bFound = TRUE;
                        *ppItemReturned = pItemFromList;
                        break;
                    }
                }
                continue;
            } else if (IsEqualGUID(*pItemGUID,cAppPoolsNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (IsEqualGUID(*pItemFromListGUID,cAppPoolNode) ||
                    IsEqualGUID(*pItemFromListGUID,cApplicationNode)
                    )
                {
                    if (pItemFromList->IsMyPropertySheetOpen())
                    {
                        bFound = TRUE;
                        *ppItemReturned = pItemFromList;
                        break;
                    }
                }
                continue;
            } else if (IsEqualGUID(*pItemGUID,cInstanceNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (!IsEqualGUID(*pItemFromListGUID,cChildNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cFileNode)
                    )
                {
                    continue;
                }
            } else if (IsEqualGUID(*pItemGUID,cInstanceCollectorNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                if (!IsEqualGUID(*pItemFromListGUID,cInstanceNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cChildNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cFileNode)
                    )
                {
                    continue;
                }
            } else if (IsEqualGUID(*pItemGUID,cServiceCollectorNode))
            {
                if (IsEqualGUID(*pItemGUID,*pItemFromListGUID))
                {
                    // if we found our own type...
                    continue;
                }

                // could have these type below it
                if (!IsEqualGUID(*pItemFromListGUID,cInstanceCollectorNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cInstanceNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cChildNode) &&
                    !IsEqualGUID(*pItemFromListGUID,cFileNode)
                    )
                {
                    continue;
                }
            } else if (IsEqualGUID(*pItemGUID,cCompMgmtService))
            {
                // who knows...
            }

            // check if this item is below the parent item's chain
            // of command...

            // Get that items parent and check if it's cookie
            // points to our object.

            // Check if the parent node points to us!
            BOOL bMatchedParent = FALSE;
			SCOPEDATAITEM si;
			::ZeroMemory(&si, sizeof(SCOPEDATAITEM));
			si.mask = SDI_PARAM;
			si.ID = pItemFromListAsNode->QueryScopeItem();;
			if (SUCCEEDED(pConsoleNameSpace->GetItem(&si)))
			{
                    // walk up the item's parentpath and see if our object is one of them...
                    INT ICount = 0;
                    HSCOPEITEM hSI = si.ID;
                    LONG_PTR lCookie = 0;
                    HRESULT hr = S_OK;
                    while (hSI)
                    {
                        HSCOPEITEM hSITemp = 0;
                        ICount++;
                        if (ICount > 30)
                        {
                            // possible infinite loop
                            ASSERT("ERROR:possible infinite loop");
                            break;
                        }

                        hr = pConsoleNameSpace->GetParentItem(hSI, &hSITemp, &lCookie);
                        if (FAILED(hr))
                        {
                            break;
                        }

                        if ( (LONG_PTR) pItem == lCookie)
                        {
                            bMatchedParent = TRUE;
                            break;
                        }
                        
                        hSI = hSITemp;
                    }
			}

            if (bMatchedParent)
            {
                if (pItemFromList->IsMyPropertySheetOpen())
                {
                    if (ppItemReturned)
                    {
                        bFound = TRUE;
                        *ppItemReturned = pItemFromList;
                        break;
                    }
                }
            }
        }
    }

    if (bFound)
    {
        DebugTrace(_T("Found item (%p) with propertypage below parent(%p)\r\n"),*ppItemReturned,pItem);
    }

    return bFound;
}

BOOL 
CPropertySheetTracker::IsPropertySheetOpenComputer(CIISObject * pItem,BOOL bIncludeComputerNode,CIISObject ** ppItemReturned)
{
    BOOL bFound = FALSE;
    BOOL bGuidIsMachine = FALSE;

    // Loop thru all the open property sheets 
    // and see if there is a property sheet that is under the computer node.
    GUID * pItemFromListGUID = NULL;
    CIISObject * pItemFromList = NULL;
    CIISMBNode * pItemFromListAsNode = NULL;
    CIISMachine * pOwner = NULL;
    POSITION pos = IISObjectOpenPropertySheets.GetHeadPosition();
    while (pos)
	{
		pItemFromList = IISObjectOpenPropertySheets.GetNext(pos);
        if (pItemFromList)
        {
            // Get Owner, if the owner Pointer
            // matches our passed in CIISObject
            // then this must be open for this computer...
            pItemFromListAsNode = (CIISMBNode *) pItemFromList;
            if (pItemFromListAsNode)
            {
			    pOwner =  pItemFromListAsNode->GetOwner();
			    if (pOwner)
			    {
                    if (pOwner == pItem)
                    {
                        // Get GUID Name and make sure it's not
                        // a CIISRoot or CIISMachine node.
                        bGuidIsMachine = FALSE;
				        pItemFromListGUID = (GUID*) pItemFromListAsNode->GetNodeType();
				        if (pItemFromListGUID)
				        {
                            if (IsEqualGUID(*pItemFromListGUID,cInternetRootNode) || IsEqualGUID(*pItemFromListGUID,cMachineNode))
                            {
                                // oh well, we don't want these...
                                bGuidIsMachine = TRUE;
                            }
                        }

                        // But if we want to check if the
                        // computer node is also open
                        // then they would have set this parameter
                        if (bIncludeComputerNode)
                        {
                            bGuidIsMachine = FALSE;
                        }

                        if (!bGuidIsMachine)
                        {
                            if (pItemFromList->IsMyPropertySheetOpen())
                            {
                                if (ppItemReturned)
                                {
                                    bFound = TRUE;
                                    *ppItemReturned = pItemFromList;
                                    break;
                                }
                            }
                        }
                    }
    		    }
            }
        }
    }

    return bFound;
}

BOOL 
CPropertySheetTracker::FindAlreadyOpenPropertySheet(CIISObject * pItem,CIISObject ** ppItemReturned)
{
    BOOL bFound = FALSE;
    POSITION pos;

    // Loop thru all the open property sheets 
    // and see if there is a property sheet that is US
    GUID * pItemFromListGUID = NULL;
    CIISObject * pItemFromList = NULL;
    CIISMBNode * pItemFromListAsNode = NULL;
    CIISMachine * pItemFromListOwner = NULL;
    CComBSTR bstrItemFromListPath;

    GUID * pItemGUID = NULL;
    CIISMBNode * pItemAsNode = NULL;
    CIISMachine * pItemOwner = NULL;
    CComBSTR bstrItemPath;

    if (!ppItemReturned)
    {
        ASSERT("Error:FindAlreadyOpenPropertySheet:Bad Param");
        return FALSE;
    }
    if (!pItem->IsConfigurable())
    {
        return FALSE;
    }

    // make sure the item we are checking has a tag set
    pItem->CreateTag();
   
    pItemGUID = (GUID*) pItem->GetNodeType();
    pItemAsNode = (CIISMBNode *) pItem;
    pItemOwner = pItemAsNode->GetOwner();

    pos = IISObjectOpenPropertySheets.GetHeadPosition();
    while (pos)
	{
		pItemFromList = IISObjectOpenPropertySheets.GetNext(pos);
        if (pItemFromList)
        {
            // Get Owner, if the owner Pointer
            // matches our passed in CIISObject
            // then this must be open for this computer...
            pItemFromListAsNode = (CIISMBNode *) pItemFromList;

            if (!pItemFromListAsNode)
            {
                // got a bad pointer to an object.
                // skip it...
                continue;
            }
        
            if (pItemFromListAsNode == pItem)
            {
                // we found ourself!!!!
                // that's what we're looking for!
                bFound = TRUE;
                *ppItemReturned = pItem;
                break;
            }

			pItemFromListOwner =  pItemFromListAsNode->GetOwner();
			if (!pItemFromListOwner)
			{
                // object doesn't have an owner...
                // skip it
                continue;
            }

            if (pItemFromListOwner != pItemOwner)
            {
                // they have different owners
                // they must be from different machines..
                // skip it
                continue;
            }

            pItemFromListGUID = (GUID*) pItemFromListAsNode->GetNodeType();
			if (!pItemFromListGUID)
			{
                // object doesn't have a guid who knows what type it is!!!
                ASSERT("Error:Item Missing GUID");
                //continue;
            }

            if (!IsEqualGUID(*pItemGUID,*pItemFromListGUID))
            {
                // if we found our own type...
                // that's what we're sort of looking for
                continue;
            }

            if (!pItemFromList->IsConfigurable())
            {
                // can't bring up property sheets on these anyways...
                continue;
            }

            // Check if the tag matches
            // THIS SHOULD TAKE CARE OF EVERYTHING
            if (0 == _tcsicmp(pItem->m_strTag,pItemFromList->m_strTag))
            {
                DebugTrace(_T("Found matching tag:%s\r\n"),pItem->m_strTag);
                if (pItemFromList->IsMyPropertySheetOpen())
                {
                    // that's what we're looking for!
                    bFound = TRUE;
                    *ppItemReturned = pItemFromList;
                    break;
                }
            }
        }
    }

    if (TRUE == bFound)
    {
        DebugTrace(_T("FindAlreadyOpenPropertySheet:Found, object=%p, existing obj=%p\r\n"),pItem,pItemFromList);
    }

    return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\usersess.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        usersess.cpp

   Abstract:
        FTP User Sessions Dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "ftpsht.h"
#include "fservic.h"
#include "usersess.h"

#include <lmerr.h>

HRESULT ImpersonateUser(LPCTSTR  pszUserName,
                        LPCTSTR  pszDomain,
                        LPCTSTR  pszPassword,
                        HANDLE  *pCurImpToken,
                        HANDLE  *pLoggedOnUserToken);
HRESULT UnImpersonateUser(HANDLE    hSavedImpToken,
                          HANDLE    hLoggedOnUser);


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("User Sessions");

//
// User Sessions Listbox Column Definitions
//
static const ODL_COLUMN_DEF_EX BASED_CODE g_aColumns[] =
{
// ==================================================================================================
// Weight      Label          Sort Helper Function
// ==================================================================================================
    { 2, IDS_CONNECTED_USERS, (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByName        },
    { 1, IDS_FROM,            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByHostAddress },
    { 1, IDS_TIME,            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByTime        },
};


#define NUM_COLUMNS (sizeof(g_aColumns) / sizeof(g_aColumns[0]))



CFtpUserInfo::CFtpUserInfo(LPIIS_USER_INFO_1 lpUserInfo)
/*++

Routine Description:

    Constructor

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    N/A

--*/
    : m_idUser(lpUserInfo->idUser),
      m_strUser(lpUserInfo->pszUser),
      m_fAnonymous(lpUserInfo->fAnonymous),
      //                    Network Byte Order
      //                              ||
      //                              \/
      m_iaHost(lpUserInfo->inetHost, TRUE),
      m_tConnect(lpUserInfo->tConnect)
{
}



int
CFtpUserInfo::OrderByName(
    const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by user name.  The CObjectPlus pointer 
    really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return ::lstrcmpi(QueryUserName(), pob->QueryUserName());
}



int
CFtpUserInfo::OrderByTime(
    const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by user connect time.  The CObjectPlus 
    pointer really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return QueryConnectTime() > pob->QueryConnectTime()
        ? +1
        : QueryConnectTime() == pob->QueryConnectTime()
            ? 0
            : -1;
}



int
CFtpUserInfo::OrderByHostAddress(
    const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by host address.  The CObjectPlus 
    pointer really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return QueryHostAddress().CompareItem(pob->QueryHostAddress());
}



IMPLEMENT_DYNAMIC(CFtpUsersListBox, CHeaderListBox);



//
// User listbox bitmaps
//
enum
{
    BMP_USER = 0,
    BMP_ANONYMOUS,

    //
    // Don't move this one
    //
    BMP_TOTAL
};

const int CFtpUsersListBox::nBitmaps = BMP_TOTAL;



CFtpUsersListBox::CFtpUsersListBox()
    : m_strTimeSep(_T(":")),
      CHeaderListBox(HLS_DEFAULT, g_szRegKey)
{
    //
    // Get intl time seperator
    //
    VERIFY(::GetLocaleInfo(
        ::GetUserDefaultLCID(), LOCALE_STIME, 
        m_strTimeSep.GetBuffer(10), 10));
}



void
CFtpUsersListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item.  This is called from the CRMCListBox base class

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure

Return Value:

    None

--*/
{
    CFtpUserInfo * pFTPUser = (CFtpUserInfo *)ds.m_ItemData;
    ASSERT(pFTPUser != NULL);

    //
    // Display a user bitmap
    //
    DrawBitmap(ds, 0, pFTPUser->QueryAnonymous() ? BMP_ANONYMOUS : BMP_USER);
    ColumnText(ds, 0, TRUE, pFTPUser->QueryUserName());
    ColumnText(ds, 1, FALSE, pFTPUser->QueryHostAddress());

    DWORD dwTime = pFTPUser->QueryConnectTime();
    DWORD dwHours = dwTime / (60L * 60L);
    DWORD dwMinutes = (dwTime / 60L) % 60L;
    DWORD dwSeconds = dwTime % 60L;

    CString strTime;

    strTime.Format(
        _T("%d%s%02d%s%02d"),
        dwHours, (LPCTSTR)m_strTimeSep,
        dwMinutes, (LPCTSTR)m_strTimeSep,
        dwSeconds);

    ColumnText(ds, 2, FALSE, strTime);
}



/* virtual */
BOOL 
CFtpUsersListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay 
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    HINSTANCE hInst = AfxGetResourceHandle();
    for (int nCol = 0; nCol < NUM_COLUMNS; ++nCol)
    {
        InsertColumn(
            nCol, 
            g_aColumns[nCol].cd.nWeight, 
            g_aColumns[nCol].cd.nLabelID,
            hInst
            );
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}



CUserSessionsDlg::CUserSessionsDlg(
    LPCTSTR lpstrServerName,
    DWORD dwInstance,
    LPCTSTR pAdminName,
    LPCTSTR pAdminPassword,
    CWnd * pParent,
	BOOL fLocal
    )
/*++

Routine Description:

    Constructor for FTP user sessions dialog

Arguments:

    LPCTSTR lpstrServerName : Server name to connect to
    CWnd * pParent          : Pointer to parent window

Return Value:

    N/A

--*/
    : m_list_Users(),
      m_ListBoxRes(IDB_USERS, m_list_Users.nBitmaps),
      m_oblFtpUsers(),
      m_strServerName(lpstrServerName),
      m_strAdminName(pAdminName),
      m_strAdminPassword(pAdminPassword),
      m_nSortColumn(0),
      m_dwInstance(dwInstance),
      m_hImpToken(INVALID_HANDLE_VALUE),
      m_hLogToken(INVALID_HANDLE_VALUE),
	  m_NetUseSessionCreated(FALSE),
	  m_fLocal(fLocal),
      CDialog(CUserSessionsDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CUserSessionsDlg)
    //}}AFX_DATA_INIT

    m_list_Users.AttachResources(&m_ListBoxRes);
    VERIFY(m_strTotalConnected.LoadString(IDS_USERS_TOTAL));
}



void 
CUserSessionsDlg::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserSessionsDlg)
    DDX_Control(pDX, IDC_STATIC_NUM_CONNECTED, m_static_Total);
    DDX_Control(pDX, IDC_BUTTON_DISCONNECT_ALL, m_button_DisconnectAll);
    DDX_Control(pDX, IDC_BUTTON_DISCONNECT, m_button_Disconnect);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_USERS, m_list_Users);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CUserSessionsDlg, CDialog)
    //{{AFX_MSG_MAP(CUserSessionsDlg)
    ON_BN_CLICKED(IDC_BUTTON_DISCONNECT, OnButtonDisconnect)
    ON_BN_CLICKED(IDC_BUTTON_DISCONNECT_ALL, OnButtonDisconnectAll)
    ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
    ON_LBN_SELCHANGE(IDC_LIST_USERS, OnSelchangeListUsers)
    //}}AFX_MSG_MAP

    ON_NOTIFY_RANGE(HDN_ITEMCLICK, 0, 0xFFFF, OnHeaderItemClick)

END_MESSAGE_MAP()



DWORD
CUserSessionsDlg::SortUsersList()
/*++

Routine Description:

    Sort the list of ftp users on the current sorting key

Arguments:

    None

Return Value:

    ERROR return code

--*/
{
    ASSERT(m_nSortColumn >= 0 && m_nSortColumn < NUM_COLUMNS);

    BeginWaitCursor();              
    DWORD err = m_oblFtpUsers.Sort(
        (CObjectPlus::PCOBJPLUS_ORDER_FUNC)g_aColumns[m_nSortColumn].pSortFn);
    EndWaitCursor();

    return err;
}


HRESULT
CUserSessionsDlg::ConnectToComputer()
{
	CError err;
	DWORD rc;
	BOOL already_connected = FALSE;
    CString server, user, password;
	server = m_strServerName;

    // check if lpMachineName starts with \\
    // if it doesn't then make sure it does, or it's null (for local machine)
	server = _T("\\\\");
	server += PURE_COMPUTER_NAME((LPCTSTR) m_strServerName);

    user = m_strAdminName;
    password = m_strAdminPassword;

    //
    // As it turned out in some cases we cannot get access to file system
    // even if we are connected to metabase. We will add connection in this
    // case also.
    //
    if (!m_fLocal)
    {
        BOOL bEmptyPassword = FALSE;

        // Add use for this resource
        NETRESOURCE nr;
        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = NULL;
        nr.lpRemoteName = (LPTSTR)(LPCTSTR)server;
        nr.lpProvider = NULL;

        // We need to close connections that we may have to this resource
        rc = WNetCancelConnection2((LPTSTR)(LPCTSTR)server, 0, TRUE);
        if (rc == ERROR_OPEN_FILES)
        {
            already_connected = TRUE;
        }

        // Empty strings below mean no password, which is wrong. NULLs mean
        // default user and default password -- this could work better for local case.
        LPCTSTR p1 = password, p2 = user;
        // In case when password is really was set empty, passing NULL will fail.
        if (password.IsEmpty() && !bEmptyPassword)
        {
            p1 = NULL;
        }
        if (user.IsEmpty())
        {
            p2 = NULL;
        }
        if (!already_connected)
        {
            rc = WNetAddConnection2(&nr, p1, p2, 0);
            if (NO_ERROR != rc)
            {
                err = rc;
				return err;
            }
            m_NetUseSessionCreated = TRUE;
        }
    }
	return err;
}

HRESULT
CUserSessionsDlg::BuildUserList()
/*++

Routine Description:

    Call the FtpEnum api and build the list of currently connected users.

Arguments:

    None

Return Value:

    ERROR return code

--*/
{
    CError err;
    LPIIS_USER_INFO_1 lpUserInfo = NULL;
    DWORD dwCount = 0L;

    m_oblFtpUsers.RemoveAll();

    BeginWaitCursor();

    err = ::IISEnumerateUsers(
        (LPTSTR)(LPCTSTR)m_strServerName,
        1,
        INET_FTP_SVC_ID,
        m_dwInstance,
        &dwCount,
        (LPBYTE *)&lpUserInfo
        );

    EndWaitCursor();

    TRACEEOLID("IISEnumerateUsers returned " << err);

    if (err.Failed())
    {
		// try to net use to the machine if this failed...
		if (ERROR_ACCESS_DENIED == err.Win32Error())
		{
			err = ConnectToComputer();

			// try again.
			BeginWaitCursor();
			err = ::IISEnumerateUsers(
				(LPTSTR)(LPCTSTR)m_strServerName,
				1,
				INET_FTP_SVC_ID,
				m_dwInstance,
				&dwCount,
				(LPBYTE *)&lpUserInfo
				);
			EndWaitCursor();

			if (err.Failed())
			{
				return err;
			}
		}
		else
		{
			return err;
		}
    }

    try
    {
        for (DWORD i = 0; i < dwCount; ++i)
        {
            m_oblFtpUsers.AddTail(new CFtpUserInfo(lpUserInfo++));
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    SortUsersList();

    return err;
}



HRESULT
CUserSessionsDlg::DisconnectUser(CFtpUserInfo * pUserInfo)
/*++

Routine Description:

    Disconnect a single user

Arguments:

    CFtpUserInfo * pUserInfo : User to disconnect

Return Value:

    ERROR return code

--*/
{
    CError err(::IISDisconnectUser(
        (LPTSTR)(LPCTSTR)m_strServerName,
        INET_FTP_SVC_ID, 
        m_dwInstance, 
        pUserInfo->QueryUserID()
        ));

    if (err.Win32Error() == NERR_UserNotFound)
    {
        //
        // As long as he's gone now, that's alright
        //
        err.Reset();
    }

    return err;
}



void 
CUserSessionsDlg::UpdateTotalCount()
/*++

Routine Description:

    Update the count of total users

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;
    str.Format(m_strTotalConnected, m_oblFtpUsers.GetCount() );

    m_static_Total.SetWindowText(str);     
}



void
CUserSessionsDlg::FillListBox(CFtpUserInfo * pSelection)
/*++

Routine Description:

    Show the users in the listbox

Arguments:

    CFtpUserInfo * pSelection : Item to be selected or NULL

Return Value:

    None

--*/
{
    CObListIter obli(m_oblFtpUsers);
    const CFtpUserInfo * pUserEntry = NULL;

    m_list_Users.SetRedraw(FALSE);
    m_list_Users.ResetContent();
    int cItems = 0;

    for ( /**/ ; pUserEntry = (CFtpUserInfo *)obli.Next(); ++cItems)
    {
        m_list_Users.AddItem(pUserEntry);
    }

    if (pSelection)
    {
        //
        // Select the desired entry
        //
        m_list_Users.SelectItem(pSelection);
    }

    m_list_Users.SetRedraw(TRUE);

    //
    // Update the count text on the dialog
    //
    UpdateTotalCount();
}



HRESULT
CUserSessionsDlg::RefreshUsersList()
/*++

Routine Description:

    Rebuild the user list

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    //
    // Add some friendly error message overrides
    //
    err.AddOverride(EPT_S_NOT_REGISTERED,       IDS_ERR_RPC_NA);
    err.AddOverride(RPC_S_SERVER_UNAVAILABLE,   IDS_FTP_SERVICE_NOT_STARTED);
    err.AddOverride(RPC_S_UNKNOWN_IF,           IDS_FTP_SERVICE_NOT_STARTED);
    err.AddOverride(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);

	err = BuildUserList();

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        FillListBox();
        SetControlStates();
    }

    return err;
}



void
CUserSessionsDlg::SetControlStates()
/*++

Routine Description:

    Set the connect/disconnect buttons depending on the selection state
    in the listbox.

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Disconnect.EnableWindow(m_list_Users.GetSelCount() > 0);
    m_button_DisconnectAll.EnableWindow(m_list_Users.GetCount() > 0);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CUserSessionsDlg::OnButtonDisconnect() 
/*++

Routine Description:

    'Disconnect User' button has been pressed.  Disconnect the currently
    selected user.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for confirmation
    //
    if (!NoYesMessageBox(IDS_CONFIRM_DISCONNECT_USER))
    {
        //
        // Changed his mind
        //
        return;
    }

    CError err;
    m_list_Users.SetRedraw(FALSE);
    CWaitCursor wait;
    
    CFtpUserInfo * pUserEntry;
    int nSel = 0;
    BOOL fProblems = FALSE;

    while((pUserEntry = GetNextSelectedItem(&nSel)) != NULL)
    {
        err = DisconnectUser(pUserEntry);
        if (err.Failed())
        {
            ++fProblems;

            if (err.MessageBoxFormat(
                m_hWnd,
                IDS_DISCONNECT_ERR,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2,
                NO_HELP_CONTEXT,
                (LPCTSTR)pUserEntry->QueryUserName()
                ) == IDYES)
            {
                //
                // Continue trying to delete
                //
                ++nSel;
                continue;
            }    
            else
            {
                break;
            }
        }
    
        m_oblFtpUsers.RemoveIndex(nSel);
        m_list_Users.DeleteString(nSel);

        //
        // Don't advance counter to account for offset
        //
    }

    m_list_Users.SetRedraw(TRUE);
    UpdateTotalCount();
    SetControlStates();

    if (!fProblems)
    {
        //
        // Ensure button not disabled
        //
        GetDlgItem(IDC_BUTTON_REFRESH)->SetFocus();
    }
}



void
CUserSessionsDlg::OnButtonDisconnectAll() 
/*++

Routine Description:

    'Disconnect All Users' button has been pressed.  Disconnect all users

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for confirmation
    //
    if (!NoYesMessageBox(IDS_CONFIRM_DISCONNECT_ALL))
    {
        //
        // Changed his mind
        //
        return;
    }
    
    CObListIter obli(m_oblFtpUsers);
    CFtpUserInfo * pUserEntry;

    m_list_Users.SetRedraw(FALSE);
    CWaitCursor wait;
    int cItems = 0;

    CError err;
    int nSel = 0;
    BOOL fProblems = FALSE;

    for ( /**/; pUserEntry = (CFtpUserInfo *)obli.Next(); ++cItems)
    {
        err = DisconnectUser(pUserEntry);
        if (err.Failed())
        {
            ++fProblems;

            if (err.MessageBoxFormat(
                m_hWnd,
                IDS_DISCONNECT_ERR,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2,
                NO_HELP_CONTEXT,
                (LPCTSTR)pUserEntry->QueryUserName()
                ) == IDYES)
            {
                //
                // Continue trying to delete
                //
                ++nSel;
                continue;
            }    
            else
            {
                break;
            }
        }

        m_oblFtpUsers.RemoveIndex(nSel);
        m_list_Users.DeleteString(nSel);
    }

    m_list_Users.SetRedraw(TRUE);
    UpdateTotalCount();
    SetControlStates();

    if (!fProblems)
    {
        //
        // Ensure button not disabled
        //
        GetDlgItem(IDC_BUTTON_REFRESH)->SetFocus();
    }
}



void
CUserSessionsDlg::OnButtonRefresh() 
/*++

Routine Description:

    'Refresh' Button has been pressed.  Refresh the user list

Arguments:

    None

Return Value:

    None

--*/
{
    RefreshUsersList();
}



void 
CUserSessionsDlg::OnSelchangeListUsers() 
/*++

Routine Description:

    Respond to a change in selection in the user listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CUserSessionsDlg::OnHeaderItemClick(
    IN  UINT nID,
    IN  NMHDR * pNMHDR,
    OUT LRESULT * plResult
    )
/*++

Routine Description:

    Header item has been clicked in the listbox.  Change the sort key
    as appropriate.

Arguments:

    None

Return Value:

    None

--*/
{
    HD_NOTIFY * pNotify = (HD_NOTIFY *)pNMHDR;
    TRACEEOLID("Header Button clicked.");

    //
    // Can't press a button out of range, surely...
    //
    ASSERT(pNotify->iItem < m_list_Users.QueryNumColumns());
    int nOldSortColumn = m_nSortColumn;
    m_nSortColumn = pNotify->iItem;

    if(m_nSortColumn != nOldSortColumn)
    {
        //
        // Rebuild the list
        //
        SortUsersList();
        CFtpUserInfo * pSelector = GetSelectedListItem();
        FillListBox(pSelector);
        SetControlStates();
    }

    //
    // Message Fully Handled
    //
    *plResult = 0;
}



BOOL 
CUserSessionsDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    if (!m_strAdminName.IsEmpty())
    {
        CError err = ImpersonateUser(m_strAdminName, _T(""), m_strAdminPassword, &m_hImpToken, &m_hLogToken);
    }

    m_list_Users.Initialize();

    if (RefreshUsersList() != ERROR_SUCCESS)
    {
        EndDialog(IDCANCEL);
        return FALSE;
    }

    return TRUE;
}

void
CUserSessionsDlg::OnDestroy() 
{
    if (m_hImpToken != INVALID_HANDLE_VALUE || m_hLogToken != INVALID_HANDLE_VALUE)
    {
        UnImpersonateUser(m_hImpToken, m_hLogToken);
    }
}

CUserSessionsDlg::~CUserSessionsDlg()
{
	if (m_NetUseSessionCreated)
	{
		CString server;
		server = m_strServerName;
		// check if lpMachineName starts with \\
		// if it doesn't then make sure it does, or it's null (for local machine)
		server = _T("\\\\");
		server += PURE_COMPUTER_NAME((LPCTSTR) m_strServerName);

		WNetCancelConnection2((LPTSTR)(LPCTSTR)server, 0, TRUE);
		m_NetUseSessionCreated = FALSE;
	}
}

HRESULT ImpersonateUser(LPCTSTR  pszUserName,
                        LPCTSTR  pszDomain,
                        LPCTSTR  pszPassword,
                        HANDLE  *pCurImpToken,
                        HANDLE  *pLoggedOnUserToken)
{
    HRESULT hr = S_OK;

    ASSERT(pCurImpToken);
    ASSERT(pLoggedOnUserToken);

    *pCurImpToken       = INVALID_HANDLE_VALUE;
    *pLoggedOnUserToken = INVALID_HANDLE_VALUE;

    // logon the user.  This creates an primary impersonation
    // token.  If this fails, an error will be returned.

    if (!LogonUser((LPTSTR)pszUserName,
                   (LPTSTR)pszDomain,
                   (LPTSTR)pszPassword,
                   LOGON32_LOGON_BATCH,
                   LOGON32_PROVIDER_DEFAULT,
                   pLoggedOnUserToken)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    // get the current impersonation token.  If an error occurs,
    // that is OK.  This just means that no impersonation on the
    // thread is occurring, so there is no need to do the RevertToSelf.

    else if (OpenThreadToken( GetCurrentThread(),
                              TOKEN_READ | TOKEN_IMPERSONATE,
                              TRUE,           
                              pCurImpToken)) {

           RevertToSelf();
    }

    // if everything's been successful so far, than call 
    // ImpersonateLoggedOnUser with the token created above.

    if (SUCCEEDED(hr)) {

        if (!ImpersonateLoggedOnUser(*pLoggedOnUserToken)) {

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    // if there were failures, clean up any tokens that we created
    // or hold.

    if (FAILED(hr)) {

        // cleanup the LogonUser token

        if (*pLoggedOnUserToken != INVALID_HANDLE_VALUE) {
            CloseHandle(*pLoggedOnUserToken);
            *pLoggedOnUserToken = INVALID_HANDLE_VALUE;
        }

        // cleanup the token from the OpenThreadToken call

        if (*pCurImpToken != INVALID_HANDLE_VALUE) {
            HANDLE  hThread = GetCurrentThread();
            SetThreadToken(&hThread,
                           *pCurImpToken);
            CloseHandle(*pCurImpToken);
            *pCurImpToken = INVALID_HANDLE_VALUE;
        }
    }

    return hr;
}

HRESULT UnImpersonateUser(HANDLE hSavedImpToken, HANDLE hLoggedOnUser)
{
    // if there is an hSavedImpToken, then call SetThreadToken to
    // restore it.

    if (hSavedImpToken != INVALID_HANDLE_VALUE) 
    {
        HANDLE  hThread = GetCurrentThread();
        SetThreadToken(&hThread, hSavedImpToken);
        CloseHandle(hSavedImpToken);
    }

    // cleanup the LogonUser token

    if (hLoggedOnUser != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(hLoggedOnUser);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\tracknet.h ===
#ifndef __TRACKNET_H__
#define __TRACKNET_H__

#include "resource.h"

class CWNetConnectionTrackerGlobal
{
public:
    CWNetConnectionTrackerGlobal(){};
	~CWNetConnectionTrackerGlobal(){};

public:

	void Add(LPCTSTR pItem)
	{
		// add to our list,so we can delete it.
		IISOpenedNetConnections.AddTail(pItem);
		return;
	}

	void Del(LPCTSTR pItem)
	{
		POSITION pos = IISOpenedNetConnections.Find(pItem);
		if (pos)
		{
			IISOpenedNetConnections.RemoveAt(pos);
		}
		return;
	}

	void Clear()
	{
		// loop thru everything and disconnect all
		CString strOneItem;
		POSITION pos = IISOpenedNetConnections.GetTailPosition();
		while (pos)
		{
			strOneItem = IISOpenedNetConnections.GetPrev(pos);
			if (!strOneItem.IsEmpty())
			{
				WNetCancelConnection2((LPCTSTR) strOneItem, 0, TRUE);
			}
		}
		IISOpenedNetConnections.RemoveAll();
	}

    void Dump()
	{
#if defined(_DEBUG) || DBG
    int iCount = 0;
	CString strOneItem;

	if (!(g_iDebugOutputLevel & DEBUG_FLAG_CIISOBJECT))
	{
		return;
	}

    DebugTrace(_T("Dump Global NetConnections -------------- start (count=%d)\r\n"),IISOpenedNetConnections.GetCount());

    POSITION pos = IISOpenedNetConnections.GetHeadPosition();
    while (pos)
    {
	    strOneItem = IISOpenedNetConnections.GetNext(pos);
        if (!strOneItem.IsEmpty())
        {
		    iCount++;
            DebugTrace(_T("Dump:[%3d] %s\r\n"),iCount,strOneItem);
        }
    }

    DebugTrace(_T("Dump Global NetConnections -------------- end\r\n"));
#endif // _DEBUG
	}

private:
	CStringList IISOpenedNetConnections;
};

class CWNetConnectionTracker
{
public:
	CWNetConnectionTracker(CWNetConnectionTrackerGlobal * pGlobalList) : m_GlobalList(pGlobalList) {};
	~CWNetConnectionTracker(){};

public:

	DWORD Connect(
		LPNETRESOURCE lpNetResource,  // connection details
		LPCTSTR lpPassword,           // password
		LPCTSTR lpUsername,           // user name
		DWORD dwFlags
		)
	{
		DWORD rc = NO_ERROR;

		// see if we already have a connection to this resource from this machine...
		POSITION posFound = IISOpenedNetConnections.Find(lpNetResource->lpRemoteName);
		if (posFound)
		{
			// a connection already exists to it
			// just return NO_ERROR
#if defined(_DEBUG) || DBG
			DebugTrace(_T("WNetAddConnection2:%s,Connection already exists...\r\n"),lpNetResource->lpRemoteName);
#endif
		}
		else
		{
			rc = WNetAddConnection2(lpNetResource, lpPassword, lpUsername, dwFlags);
#if defined(_DEBUG) || DBG
			DebugTrace(_T("WNetAddConnection2:%s (user=%s), err=%d\r\n"),lpNetResource->lpRemoteName,lpUsername,rc);
#endif
			if (NO_ERROR == rc)
			{
				// add to our list,so we can delete it.
				IISOpenedNetConnections.AddTail(lpNetResource->lpRemoteName);
				if (m_GlobalList)
				{
					m_GlobalList->Add(lpNetResource->lpRemoteName);
				}
			}
		}
		return rc;
	}

	DWORD Disconnect(LPCTSTR pItem)
	{
		DWORD rc = WNetCancelConnection2(pItem, 0, TRUE);
		if (NO_ERROR == rc)
		{
#if defined(_DEBUG) || DBG
			DebugTrace(_T("WNetCancelConnection2:%s\r\n"),pItem);
#endif
			POSITION pos = IISOpenedNetConnections.Find(pItem);
			if (pos)
				{
					IISOpenedNetConnections.RemoveAt(pos);
					if (m_GlobalList)
					{
						m_GlobalList->Del(pItem);
					}
				}
		}
		return rc;
	}

	void Clear()
	{
		// loop thru everything and disconnect all
		CString strOneItem;
		POSITION pos = IISOpenedNetConnections.GetTailPosition();
		while (pos)
		{
			strOneItem = IISOpenedNetConnections.GetPrev(pos);
			if (!strOneItem.IsEmpty())
			{
				Disconnect(strOneItem);
			}
		}
	}

    void Dump()
	{
#if defined(_DEBUG) || DBG
    int iCount = 0;
	CString strOneItem;

	if (!(g_iDebugOutputLevel & DEBUG_FLAG_CIISOBJECT))
	{
		return;
	}

    DebugTrace(_T("Dump Machine NetConnections -------------- start (count=%d)\r\n"),IISOpenedNetConnections.GetCount());

    POSITION pos = IISOpenedNetConnections.GetHeadPosition();
    while (pos)
    {
	    strOneItem = IISOpenedNetConnections.GetNext(pos);
        if (!strOneItem.IsEmpty())
        {
		    iCount++;
            DebugTrace(_T("Dump:[%3d] %s\r\n"),iCount,strOneItem);
        }
    }

    DebugTrace(_T("Dump Machine NetConnections -------------- end\r\n"));
#endif // _DEBUG
	}

private:
	CWNetConnectionTrackerGlobal * m_GlobalList;
	CStringList IISOpenedNetConnections;
};

#endif // __TRACKNET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\usersess.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        usersess.h

   Abstract:

        FTP User Sessions Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __USERSESS_H__
#define __USERSESS_H__


class CFtpUserInfo : public CObjectPlus
/*++

Class Description:

    Connected FTP User object

Public Interface:

    CFtpUserInfo     : Constructor

    QueryUserID      : Get the user's ID code
    QueryAnonymous   : Return TRUE if the user logged on anonymously
    QueryHostAddress : Get the user's IP Address
    QueryConnectTime : Get the user's connect time
    QueryUserName    : Get the user's name
    OrderByName      : Sort helper
    OrderByTime      : Sort helper
    OrderByMachine   : Sort helper

--*/
{
//
// Construction
//
public:
    CFtpUserInfo(
        IN LPIIS_USER_INFO_1 lpUserInfo
        );

//
// Access Functions
//
public:
    DWORD QueryUserID() const { return m_idUser; }
    BOOL QueryAnonymous() const { return m_fAnonymous; }
    CIPAddress QueryHostAddress() const { return m_iaHost; }
    DWORD QueryConnectTime() const { return m_tConnect; }
    LPCTSTR QueryUserName() const { return m_strUser; }

//
// Sorting Helper Functions
//
public:
    int OrderByName(
        IN const CObjectPlus * pobFtpUser
        ) const;

    int OrderByTime(
        IN const CObjectPlus * pobFtpUser
        ) const;

    int OrderByHostAddress(
        IN const CObjectPlus * pobFtpUser
        ) const;

//
// Private Data
//
private:
    BOOL    m_fAnonymous;
    DWORD   m_idUser;
    DWORD   m_tConnect;
    CString m_strUser;
    CIPAddress m_iaHost;
};



class CFtpUsersListBox : public CHeaderListBox
{
/*++

Class Description:

    Listbox of CFtpUserInfo objects

Public Interface:

    CFtpUsersListBox : Constructor

    GetItem          : Get FtpUserInfo object
    AddItem          : Add FtpUserInfo object
    Initialize       : Initialize the listbox

--*/
    DECLARE_DYNAMIC(CFtpUsersListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;  

//
// Constructor/Destructor
//
public:
    CFtpUsersListBox();

//
// Access
//
public:
    CFtpUserInfo * GetItem(
        IN UINT nIndex
        );

    int AddItem(
        IN const CFtpUserInfo * pItem
        );

    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & ds
        );

protected:
    CString m_strTimeSep;
};



class CUserSessionsDlg : public CDialog
{
/*++

Class Description:

    FTP User sessions dialog

Public Interface:

    CUserSessionsDlg : Constructor

--*/
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CUserSessionsDlg(
        LPCTSTR lpServerName,
        DWORD dwInstance,
        LPCTSTR pAdminName,
        LPCTSTR pAdminPassword,
        CWnd * pParent = NULL,
		BOOL fLocal = TRUE
        );
	~CUserSessionsDlg();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CUserSessionsDlg)
    enum { IDD = IDD_USER_SESSIONS };
    CStatic m_static_Total;
    CButton m_button_DisconnectAll;
    CButton m_button_Disconnect;
    //}}AFX_DATA

    CFtpUsersListBox m_list_Users;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CUserSessionsDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CUserSessionsDlg)
    afx_msg void OnButtonDisconnect();
    afx_msg void OnButtonDisconnectAll();
    afx_msg void OnButtonRefresh();
    afx_msg void OnSelchangeListUsers();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnHeaderItemClick(UINT nID, NMHDR *pNMHDR, LRESULT *lResult);

    DECLARE_MESSAGE_MAP()

    int QuerySortColumn() const { return m_nSortColumn; }

    DWORD SortUsersList();
    HRESULT RefreshUsersList();
    HRESULT DisconnectUser(CFtpUserInfo * pUserInfo);
    HRESULT BuildUserList();
    CFtpUserInfo * GetSelectedListItem(int * pnSel = NULL);
    CFtpUserInfo * GetNextSelectedItem(int * pnStartingIndex);
    void FillListBox(CFtpUserInfo * pSelection = NULL);

    void SetControlStates();
    void UpdateTotalCount();
	HRESULT ConnectToComputer();

private:
    int m_nSortColumn;
    DWORD m_dwInstance;
    CString m_strServerName;
    CString m_strAdminName;
    CString m_strAdminPassword;
    HANDLE m_hImpToken, m_hLogToken;
    CString m_strTotalConnected;
    CObListPlus m_oblFtpUsers;
    CRMCListBoxResources m_ListBoxRes;
	BOOL    m_fLocal;
	BOOL    m_NetUseSessionCreated;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CFtpUserInfo * CFtpUsersListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CFtpUserInfo *)GetItemDataPtr(nIndex);
}

inline int CFtpUsersListBox::AddItem(
    IN const CFtpUserInfo * pItem
    )
{
    return AddString((LPCTSTR)pItem);
}

inline CFtpUserInfo * CUserSessionsDlg::GetSelectedListItem(
    OUT int * pnSel
    )
{
    return (CFtpUserInfo *)m_list_Users.GetSelectedListItem(pnSel);
}

inline CFtpUserInfo * CUserSessionsDlg::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CFtpUserInfo *)m_list_Users.GetNextSelectedItem(pnStartingIndex);
}



#endif // __USERSESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\w3sht.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        w3sht.cpp

   Abstract:

        WWW Property Sheet

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "w3sht.h"
#include "iisfilt.h"
#include "fltdlg.h"
#include "iisobj.h"

// from pshed.cpp
HRESULT CallINetCfg(BOOL Install);

//
// Help IDs
//
#define HIDD_DIRECTORY_PROPERTIES       (IDD_WEB_DIRECTORY_PROPERTIES + 0x20000)
#define HIDD_HOME_DIRECTORY_PROPERTIES  (HIDD_DIRECTORY_PROPERTIES + 0x20000)
#define HIDD_FS_DIRECTORY_PROPERTIES    (HIDD_DIRECTORY_PROPERTIES + 0x20001)
#define HIDD_FS_FILE_PROPERTIES         (HIDD_DIRECTORY_PROPERTIES + 0x20002)


//
// Metabase node ID
//
const LPCTSTR g_cszSvc =            _T("W3SVC");
const LPCTSTR g_cszFilters =        _T("Filters");
const LPCTSTR g_cszSSLKeys =        _T("SSLKeys");



//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
IsCertInstalledOnServer(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Check to see if a certificate is installed on this virtual server.
    This routine only checks that the cert metabase key was read in.

    by boydm

Arguments:

    None

Return Value:

    TRUE if a certificate are installed, FALSE otherwise

--*/
{
    CError err;
    BOOL fCertInstalled = FALSE;
    CW3InstanceProps * ppropInst;
    CString strNewPath;

    //
    // Get the instance properties
    //
    CMetabasePath::GetInstancePath(lpszMDPath,strNewPath);
    ppropInst = new CW3InstanceProps(pAuthInfo, strNewPath);

    //
    // If it succeeded, load the data, then check the answer
    //
    if (ppropInst)
    {
        err = ppropInst->LoadData();

        if (err.Succeeded())
        {
            fCertInstalled = !(MP_V(ppropInst->m_CertHash).IsEmpty());
        }
    }

    //
    // Clean up since we don't really need the ppropInst after this.
    //
    if (ppropInst)
    {
        delete ppropInst;
        ppropInst = NULL;
    }

    //
    // if that test failed. we want to check the metabase key itself
    // since the above check is all cached information and won't reflect
    // any certificates which are removed/added via scripts, while mmc is open
    // 
    if (!fCertInstalled)
    {
	    CMetaKey key(pAuthInfo,strNewPath,METADATA_PERMISSION_READ);
	    if (key.Succeeded())
        {
		    CBlob hash;
		    if (SUCCEEDED(key.QueryValue(MD_SSL_CERT_HASH, hash)))
            {
                fCertInstalled = TRUE;
            }
        }
    }

    //
    // If that test failed, we may be admining a downlevel IIS4 machine.
    // Unfortunately  we can't tell by examining the capability bits, 
    // so look to see if the old certs are there.
    // 
    if (!fCertInstalled)
    {
        CString         strKey;
        CMetaEnumerator me(pAuthInfo, CMetabasePath(SZ_MBN_WEB));
        HRESULT err = me.Next(strKey, g_cszSSLKeys);
        fCertInstalled = SUCCEEDED(err);
    }

    return fCertInstalled;
}



//
// CW3InstanceProps implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CW3InstanceProps::CW3InstanceProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor for WWW instance properties

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    None.

--*/
    : CInstanceProps(pAuthInfo, lpszMDPath, 80U),
      /**/
      m_nMaxConnections(INITIAL_MAX_CONNECTIONS),
      m_nConnectionTimeOut((LONG)900L),
      m_strlSecureBindings(),
      m_dwLogType(MD_LOG_TYPE_DISABLED),
      /**/
      m_fUseKeepAlives(TRUE),
      m_nServerSize(MD_SERVER_SIZE_MEDIUM),
      m_dwMaxBandwidth(INFINITE_BANDWIDTH),
	  /**/
      m_acl(),
      /**/
      m_dwDownlevelInstance(1),
      m_CertHash()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}

CW3InstanceProps::~CW3InstanceProps()
{
}

/* virtual */
void
CW3InstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CInstanceProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      HANDLE_META_RECORD(MD_SECURE_BINDINGS,     m_strlSecureBindings)
      HANDLE_META_RECORD(MD_LOG_TYPE,            m_dwLogType)
      HANDLE_META_RECORD(MD_SERVER_SIZE,         m_nServerSize)
      HANDLE_META_RECORD(MD_ALLOW_KEEPALIVES,    m_fUseKeepAlives)
      HANDLE_META_RECORD(MD_MAX_BANDWIDTH,       m_dwMaxBandwidth)
      HANDLE_META_RECORD(MD_MAX_GLOBAL_BANDWIDTH,m_dwMaxGlobalBandwidth)
      HANDLE_META_RECORD(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      HANDLE_META_RECORD(MD_ADMIN_ACL,           m_acl)
      HANDLE_META_RECORD(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance);
      HANDLE_META_RECORD(MD_SSL_CERT_HASH,       m_CertHash)
      HANDLE_META_RECORD(MD_SSL_CERT_STORE_NAME, m_strCertStoreName)
      HANDLE_META_RECORD(MD_SSL_CTL_IDENTIFIER,  m_strCTLIdentifier)
      HANDLE_META_RECORD(MD_SSL_CTL_STORE_NAME,  m_strCTLStoreName)
    END_PARSE_META_RECORDS
    if (CMetabasePath::IsMasterInstance(QueryMetaRoot()))
	{
		m_dwMaxBandwidth = m_dwMaxGlobalBandwidth;
	}
}



/* virtual */
HRESULT
CW3InstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CInstanceProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }
    if (m_dwMaxBandwidth != INFINITE_BANDWIDTH)
    {
        err = CallINetCfg(TRUE);
    }

    BEGIN_META_WRITE()
      META_WRITE(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      META_WRITE(MD_SECURE_BINDINGS,     m_strlSecureBindings)
      META_WRITE(MD_LOG_TYPE,            m_dwLogType)
      META_WRITE(MD_SERVER_SIZE,         m_nServerSize)
      META_WRITE(MD_ALLOW_KEEPALIVES,    m_fUseKeepAlives)
	  if (CMetabasePath::IsMasterInstance(QueryMetaRoot()))
	  {
		 META_WRITE(MD_MAX_GLOBAL_BANDWIDTH, m_dwMaxBandwidth)
	  }
	  else
	  {
		 META_WRITE(MD_MAX_BANDWIDTH,    m_dwMaxBandwidth)
	  }
      META_WRITE(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      META_WRITE(MD_ADMIN_ACL,           m_acl)
      META_WRITE(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance);
      META_WRITE(MD_SSL_CTL_IDENTIFIER,  m_strCTLIdentifier)
      META_WRITE(MD_SSL_CTL_STORE_NAME,  m_strCTLStoreName)
    END_META_WRITE(err);

    return err;
}



//
// CW3DirProps Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CW3DirProps::CW3DirProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    WWW Directory Properties Constructor

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    N/A

--*/
    : CChildNodeProps(
        pAuthInfo,
        lpszMDPath,
        WITH_INHERITANCE,
        FALSE               // Complete information
        ),
      /**/
      m_strUserName(),
      m_strPassword(),
      m_strDefaultDocument(),
      m_strFooter(),
      m_dwDirBrowsing(0L),
      m_fEnableFooter(FALSE),
      m_fDontLog(FALSE),
      m_fIndexed(FALSE),
      /**/
      m_strExpiration(),
      m_strlCustomHeaders(),
      /**/
      m_strlCustomErrors(),
      /**/
      m_strAnonUserName(),
      m_strAnonPassword(),
      m_fPasswordSync(TRUE),
      m_fU2Installed(FALSE),
      m_fUseNTMapper(FALSE),
      m_dwAuthFlags(MD_AUTH_ANONYMOUS),
      m_dwSSLAccessPermissions(0L),
      m_strBasicDomain(),
      m_strRealm(),
      m_ipl()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CW3DirProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CChildNodeProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,  m_pbMDData)
      //
      // VDir Page
      //
      HANDLE_META_RECORD(MD_VR_USERNAME,        m_strUserName)
      HANDLE_META_RECORD(MD_VR_PASSWORD,        m_strPassword)
      HANDLE_META_RECORD(MD_DEFAULT_LOAD_FILE,  m_strDefaultDocument);
      HANDLE_META_RECORD(MD_FOOTER_ENABLED,     m_fEnableFooter);
      HANDLE_META_RECORD(MD_FOOTER_DOCUMENT,    m_strFooter);
      HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing);
      HANDLE_META_RECORD(MD_DONT_LOG,           m_fDontLog);
      HANDLE_META_RECORD(MD_IS_CONTENT_INDEXED, m_fIndexed);
      //
      // HTTP Page
      //
      HANDLE_META_RECORD(MD_HTTP_EXPIRES,       m_strExpiration);
      HANDLE_META_RECORD(MD_HTTP_CUSTOM,        m_strlCustomHeaders);
      //
      // Custom Errors
      //
      HANDLE_META_RECORD(MD_CUSTOM_ERROR,       m_strlCustomErrors);
      //
      // Security page
      //
      HANDLE_META_RECORD(MD_AUTHORIZATION,        m_dwAuthFlags);
      HANDLE_META_RECORD(MD_SSL_ACCESS_PERM,      m_dwSSLAccessPermissions);
      HANDLE_META_RECORD(MD_DEFAULT_LOGON_DOMAIN, m_strBasicDomain);
      HANDLE_META_RECORD(MD_REALM,                m_strRealm);
      HANDLE_META_RECORD(MD_ANONYMOUS_USER_NAME,  m_strAnonUserName)
      HANDLE_META_RECORD(MD_ANONYMOUS_PWD,        m_strAnonPassword)
//	  if (QueryMajorVersion() < 6)
	  {
		  HANDLE_META_RECORD(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
	  }
      HANDLE_META_RECORD(MD_U2_AUTH,              m_fU2Installed)
      HANDLE_META_RECORD(MD_SSL_USE_DS_MAPPER,    m_fUseNTMapper);
      HANDLE_META_RECORD(MD_IP_SEC,               m_ipl);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CW3DirProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CChildNodeProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    DWORD dwAuth = m_dwAuthFlags;
    DWORD dwBuf = m_dwAuthFlags;
    if (IS_FLAG_SET(dwBuf, MD_AUTH_PASSPORT))
    {
        // Clear Windows authentication flags, if passport set
        //
        dwBuf &= ~(MD_AUTH_MD5 | MD_AUTH_BASIC | MD_AUTH_NT);
        m_dwAuthFlags = dwBuf;
    }

    //
    // CODEWORK: Consider DDX/DDV like methods which do both
    // ParseFields and WriteDirtyProps in a single method.  Must
    // take care not to write data which should only be read, not
    // written
    //
    BEGIN_META_WRITE()
      //
      // VDir Page
      //
      META_WRITE(MD_VR_USERNAME,           m_strUserName)
      // If some bozo wants to have empty password, we should force to write it here
      if (!MP_V(m_strUserName).IsEmpty() && MP_V(m_strPassword).IsEmpty())
      {
          MP_V(m_strPassword) = _T("");
      }
      MP_D(m_strPassword) = TRUE;
      META_WRITE(MD_VR_PASSWORD,           m_strPassword)
      META_WRITE(MD_DEFAULT_LOAD_FILE,     m_strDefaultDocument)
      META_WRITE(MD_FOOTER_ENABLED,        m_fEnableFooter)
      META_WRITE(MD_FOOTER_DOCUMENT,       m_strFooter)
      META_WRITE(MD_DIRECTORY_BROWSING,    m_dwDirBrowsing)
      META_WRITE(MD_DONT_LOG,              m_fDontLog)
      META_WRITE(MD_IS_CONTENT_INDEXED,    m_fIndexed)
      //
      // HTTP Page
      //
      META_WRITE(MD_HTTP_EXPIRES,          m_strExpiration)
      META_WRITE(MD_HTTP_CUSTOM,           m_strlCustomHeaders)
      //
      // Custom Errors
      //
      META_WRITE(MD_CUSTOM_ERROR,          m_strlCustomErrors)
      //
      // Security page
      //
      META_WRITE(MD_AUTHORIZATION,         m_dwAuthFlags)
      META_WRITE(MD_SSL_ACCESS_PERM,       m_dwSSLAccessPermissions)
      META_WRITE(MD_REALM,                 m_strRealm)
      META_WRITE(MD_DEFAULT_LOGON_DOMAIN,  m_strBasicDomain)
      META_WRITE(MD_ANONYMOUS_USER_NAME,   m_strAnonUserName)
      META_WRITE(MD_ANONYMOUS_PWD,         m_strAnonPassword)
//	  if (QueryMajorVersion() < 6)
	  {
		  META_WRITE(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
	  }
      META_WRITE(MD_SSL_USE_DS_MAPPER,     m_fUseNTMapper)
      META_WRITE(MD_IP_SEC,                m_ipl)
    END_META_WRITE(err);

    m_dwAuthFlags = dwAuth;

    return err;
}



//
// CIISFilter Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISFilter::CIISFilter()
/*++

Routine Description:

    Filter contructor for a new filter

Arguments:

    None

Return Value:

    N/A

--*/
    : CObjectPlus(),
      m_strName(),

      //
      // Default Values
      //
      m_strExecutable(),
      m_nPriority(FLTR_PR_INVALID),
      m_nOrder(-1),
      m_dwState(MD_FILTER_STATE_UNDEFINED),
      m_dwFlags(0L),
      m_hrResult(S_OK),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fEnabled(TRUE),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
}



CIISFilter::CIISFilter(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Fully defined constructor

Arguments:

    CMetaKey * pKey         : Open key to read from
    LPCTSTR lpszName        : Name of the filter

Return Value:

    N/A

--*/
    : m_strName(lpszName),
      //
      // Default Values
      //
      m_strExecutable(),
      m_nPriority(FLTR_PR_INVALID),
      m_nOrder(-1),
      m_dwState(MD_FILTER_STATE_UNDEFINED),
      m_dwFlags(0L),
      m_hrResult(S_OK),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fEnabled(TRUE),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
    ASSERT(pKey != NULL);

    m_hrResult = pKey->QueryValue(
        MD_FILTER_IMAGE_PATH, 
        m_strExecutable,
        NULL,
        m_strName
        );

    pKey->QueryValue(MD_FILTER_ENABLED, m_fEnabled, NULL, m_strName);
    pKey->QueryValue(MD_FILTER_STATE,   m_dwState,  NULL, m_strName);
    pKey->QueryValue(MD_FILTER_FLAGS,   m_dwFlags,  NULL, m_strName);
    
    if (m_dwFlags & SF_NOTIFY_ORDER_HIGH)
    {
        m_nPriority = FLTR_PR_HIGH;
    }
    else if (m_dwFlags & SF_NOTIFY_ORDER_MEDIUM)
    {
        m_nPriority = FLTR_PR_MEDIUM;
    }
    else if (m_dwFlags & SF_NOTIFY_ORDER_LOW)
    {
        m_nPriority = FLTR_PR_LOW;
    }
    else
    {
        m_nPriority = FLTR_PR_INVALID;
    }
}



CIISFilter::CIISFilter(
    IN const CIISFilter & flt
    )
/*++

Routine Description:

    Copy Constructor

Arguments:

    const CIISFilter & flt : Source filter object

Return Value:

    N/A

--*/
    : m_strName(flt.m_strName),
      m_strExecutable(flt.m_strExecutable),
      m_nPriority(flt.m_nPriority),
      m_nOrder(flt.m_nOrder),
      m_hrResult(flt.m_hrResult),
      m_dwState(flt.m_dwState),
      m_dwFlags(flt.m_dwFlags),
      m_dwWin32Error(flt.m_dwWin32Error),
      m_fEnabled(flt.m_fEnabled),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
}



HRESULT
CIISFilter::Write(
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Write the current value to the metabase

Arguments:

    CMetaKey * pKey      : Open key

Return Value:

    HRESULT

--*/
{
    ASSERT(pKey != NULL);

    CError err;

    CString strKey(_T("IIsFilter"));
    err = pKey->SetValue(MD_KEY_TYPE, strKey, NULL, QueryName());

    if (err.Succeeded())
    {
        err = pKey->SetValue(
            MD_FILTER_IMAGE_PATH, 
            m_strExecutable, 
            NULL, 
            QueryName()
            );
    }

    return err;    
}



int
CIISFilter::OrderByPriority(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two filters against each other, and sort on priority first, and
    order secondarily.

Arguments:

    const CObjectPlus * pobAccess : This really refers to another
                                    CIISFilter to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    const CIISFilter * pob = (CIISFilter *)pobAccess;

    if (pob->m_nPriority != m_nPriority)
    {
        return pob->m_nPriority - m_nPriority;
    }

    //
    // Sort by order in reverse order
    //
    return m_nOrder - pob->m_nOrder;
}



//
// Static initialization
//
const LPCTSTR CIISFilterList::s_lpszSep = _T(",");



//
// CIISFilterList implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISFilterList::CIISFilterList(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Constructor for filter list

Arguments:

    LPCTSTR lpszServerName     : Server name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)

Return Value:

    N/A

--*/
    : CMetaKey(
        pAuthInfo,
        CMetabasePath(FALSE, lpszMetaPath, g_cszFilters),
        METADATA_PERMISSION_READ
        ),
      m_hrResult(S_OK),
      m_strFilterOrder(),
      m_fFiltersLoaded(FALSE)
{
    m_hrResult = CMetaKey::QueryResult();

    if (SUCCEEDED(m_hrResult))
    {
        m_hrResult = QueryValue(MD_FILTER_LOAD_ORDER, m_strFilterOrder);
    }
    
    if (    m_hrResult == CError::HResult(ERROR_PATH_NOT_FOUND)
        ||  m_hrResult == MD_ERROR_DATA_NOT_FOUND
        )
    {
        //
        // Harmless
        //
        m_hrResult = S_OK;
    }    

    if (IsOpen())
    {
        Close();
    }
}



HRESULT
CIISFilterList::LoadAllFilters()
/*++

Routine Description:

    Loop through the filter order string, and load information
    about each filter in turn.

Arguments:

    None.

Return Value:

    HRESULT.  The first error stops filter loading.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    if (m_fFiltersLoaded)
    {
        //
        // Already done
        //
        return S_OK;
    }

    int cItems = 0;
    CError err(ReOpen(METADATA_PERMISSION_READ));

    if (err.Failed())
    {
        return err;
    }

    try
    {
        CString strSrc(m_strFilterOrder);
        LPTSTR lp = strSrc.GetBuffer(0);
        while (isspace(*lp) || *lp == (TCHAR)s_lpszSep)
            lp++;
        lp = _tcstok(lp, s_lpszSep);

        int nOrder = 0;

        while (lp)
        {
            CString str(lp);
            str.TrimLeft();
            str.TrimRight();

            TRACEEOLID("Adding filter: " << str);

            CIISFilter * pFilter = new CIISFilter(this, str);
            err = pFilter->QueryResult();

            if (err.Failed())
            {
                break;
            }

            pFilter->m_nOrder = nOrder++;
            m_oblFilters.AddTail(pFilter);

            lp = _tcstok(NULL, s_lpszSep);
            ++cItems;
        }

        //
        // Sort filters list
        //
        m_oblFilters.Sort(
            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)
            &CIISFilter::OrderByPriority
            );
    }
    catch(CMemoryException * e)
    {
        e->Delete();
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    m_fFiltersLoaded = err.Succeeded();

    if (IsOpen())
    {
        Close();
    }

    return err;    
}



HRESULT
CIISFilterList::WriteIfDirty()
/*++

Routine Description:

    Write all the changes in the filters list to the metabase

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    CError err;

    CString strNewOrder;
    VERIFY(BuildFilterOrderString(strNewOrder));

    //
    // Check to see if this new list is different
    //
    if (!strNewOrder.CompareNoCase(m_strFilterOrder) && !HasDirtyFilter())
    {
        //
        // The priority list hasn't changed, and no filter is marked
        // as dirty, so all done.
        //
        return err;
    }

    //
    // It's dirty -- save it
    //
    do
    {
        err = ReOpen(METADATA_PERMISSION_WRITE);

        if (err.Failed())
        {
            if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
            {
                //
                // Path didn't exist yet, create it and reopen
                // it.
                //
                err = CreatePathFromFailedOpen();

                if (err.Succeeded())
                {
                    err = ReOpen(METADATA_PERMISSION_WRITE);
                }
            }

            if (err.Failed())
            {
                break;
            }
        }

        //
        // Delete deleted filters
        //
        POSITION pos1, pos2;

        for (pos1 = m_oblFilters.GetHeadPosition(); (pos2 = pos1) != NULL; )
        {
            CIISFilter * pFilter = (CIISFilter *)m_oblFilters.GetNext(pos1);
            ASSERT(pFilter != NULL);

            if (pFilter->IsFlaggedForDeletion())
            {
                TRACEEOLID("Deleting filter " << pFilter->QueryName());
				if (S_OK == DoesPathExist(pFilter->QueryName()))
				{
					err = DeleteKey(pFilter->QueryName());
				}

                if (err.Failed())
                {
                    break;
                }

                m_oblFilters.RemoveAt(pos2);
            }
        }

        if (err.Failed())
        {
            break;
        }

        //
        // Two passes are necessary, because the filter may
        // have been re-added after it was deleted from the
        // list as new entry.  This could be somewhat improved
        //
        ResetEnumerator();

        while(MoreFilters())
        {
            CIISFilter * pFilter = GetNextFilter();
            ASSERT(pFilter != NULL);

            if (pFilter->IsDirty())
            {
                TRACEEOLID("Writing filter " << pFilter->QueryName());
                err = pFilter->Write(this);

                if (err.Failed())
                {
                    break;
                }

                pFilter->Dirty(FALSE);
            }
        }

        if (err.Failed())
        {
            break;
        }

        //
        // Write the new filter load order
        //
        err = SetValue(MD_FILTER_LOAD_ORDER, strNewOrder);

        if (err.Failed())
        {
            break;
        }

        CString strKey(_T("IIsFilters"));
        err = SetValue(MD_KEY_TYPE, strKey);
        err = SetValue(MD_FILTER_LOAD_ORDER, strNewOrder);

        m_strFilterOrder = strNewOrder;
    }
    while(FALSE);

    if (IsOpen())
    {
        Close();
    }

    return err;
}



POSITION
CIISFilterList::GetFilterPositionByIndex(
    IN  int nSel
    )
/*++

Routine Description:

    Return the position of a filter object by index, skipping filters
    marked for deletion.

Arguments:

    int nSel        - 0 based index into the list

Return Value:

    The POSITION into the filters ObList of the filter at the index
    specified, or NULL if the filter is not found.

--*/
{
    int nIndex = -1;
    CIISFilter * pFilter;
    POSITION pos, 
             posReturn = NULL;

    pos = m_oblFilters.GetHeadPosition();

    while(pos && nIndex < nSel)
    {
        posReturn = pos;
        pFilter = (CIISFilter *)m_oblFilters.GetNext(pos);

        //
        // Skipping deleted filters
        //
        if (!pFilter->IsFlaggedForDeletion())
        {
            ++nIndex;
        }
    }
    
    return posReturn;
}



BOOL
CIISFilterList::ExchangePositions(
    IN  int nSel1,
    IN  int nSel2,
    OUT CIISFilter *& p1,
    OUT CIISFilter *& p2
    )
/*++

Routine Description:

    Exchange the positions of two filters in the list

Arguments:

    int nSel1           : Item 1
    int nSel2           : Item 2
    CIISFilter *& p1    : Returns the item moved to position 1
    CIISFilter *& p2    : Returns the item moved to position 2

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    //
    // Fetch filters at the two positions (deleted filters are
    // skipped in the index count)
    //
    POSITION pos1 = GetFilterPositionByIndex(nSel1);
    POSITION pos2 = GetFilterPositionByIndex(nSel2);
    p1 = pos2 ? (CIISFilter *)m_oblFilters.GetAt(pos2) : NULL;
    p2 = pos1 ? (CIISFilter *)m_oblFilters.GetAt(pos1) : NULL;

    if (!p1 || !p2)
    {
        TRACEEOLID("Invalid internal state -- filter exchange impossible");        
        ASSERT(FALSE);

        return FALSE;
    }

    TRACEEOLID("Filter (1) name is " << p1->m_strName);
    TRACEEOLID("Filter (2) name is " << p2->m_strName);

    //
    // Exchange
    //
    m_oblFilters.SetAt(pos1, p1);
    m_oblFilters.SetAt(pos2, p2);

    //
    // Success
    //
    return TRUE;
}



LPCTSTR
CIISFilterList::BuildFilterOrderString(
    OUT CString & strFilterOrder
    )
/*++

Routine Description:

    Convert the oblist of filters to a single filter order string
    fit to be stuffed into the metabase

Arguments:

    CString & strFilterOrder        : Output to receive the order string

Return Value:

    A pointer to the new filter order string.

--*/
{
    BOOL fFirst = TRUE;
    POSITION pos = m_oblFilters.GetHeadPosition();

    strFilterOrder.Empty();

    while(pos)
    {
        CIISFilter * pFlt = (CIISFilter *)m_oblFilters.GetNext(pos);

        if (!pFlt->IsFlaggedForDeletion())
        {
            if (!fFirst)
            {
                strFilterOrder += s_lpszSep;
            }
            else
            {
                fFirst = FALSE;
            }

            strFilterOrder += pFlt->m_strName;
        }
    }

    return (LPCTSTR)strFilterOrder;
}



BOOL
CIISFilterList::HasDirtyFilter() const
/*++

Routine Description:

    Go through the list of filters, and return TRUE if any filter
    in the list is dirty or flagged for deletion

Arguments:

    None

Return Value:

    TRUE if any filter is dirty or flagged for deletion.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    POSITION pos = m_oblFilters.GetHeadPosition();

    while(pos)
    {
        CIISFilter * pFilter = (CIISFilter *)m_oblFilters.GetNext(pos);

        if (pFilter->IsFlaggedForDeletion() || pFilter->IsDirty())
        {
            return TRUE;
        }
    }

    return FALSE;
}



//
// CW3Sheet implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CW3Sheet::CW3Sheet(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMetaPath,
    IN DWORD   dwAttributes,
    IN CWnd *  pParentWnd,          OPTIONAL
    IN LPARAM  lParam,              OPTIONAL
    IN LPARAM  lParamParent,        OPTIONAL
    IN UINT    iSelectPage          
    )
/*++

Routine Description:

    WWW Property sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    DWORD   dwAttributes      : File attributes
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pAuthInfo,
        lpszMetaPath,
        pParentWnd,
        lParam,
        lParamParent,
        iSelectPage
        ),
      m_ppropInst(NULL),
      m_ppropDir(NULL),
      m_fNew(FALSE),
      m_dwAttributes(dwAttributes),
	  m_fCompatMode(FALSE)
{
}



CW3Sheet::~CW3Sheet()
/*++

Routine Description:

    Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    FreeConfigurationParameters();
}


HRESULT
CW3Sheet::SetKeyType()
{
	CError err;

	CIISObject * pNode = (CIISObject *)GetParameter();
	ASSERT(pNode != NULL);
	if (pNode == NULL)
	{
		return E_FAIL;
	}
	CMetaKey mk(QueryAuthInfo(), m_ppropDir->QueryMetaRoot(), METADATA_PERMISSION_WRITE);
	err = mk.QueryResult();
	if (err.Succeeded())
	{
		err = mk.SetValue(MD_KEY_TYPE, CString(pNode->GetKeyType(m_ppropDir->QueryMetaRoot())));
	}
	else if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
	{
		err.Reset();
	}
	return err;
}


HRESULT
CW3Sheet::SetSheetType(int fSheetType)
{
    m_fSheetType = fSheetType;
	return S_OK;
}


void
CW3Sheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    WWW Property sheet help handler

Arguments:

    DWORD dwData            : WinHelp data (dialog ID)
    UINT nCmd               : WinHelp command

Return Value:

    None

Notes:

    Replace the dialog ID if this is the directory tab.  We have
    different help depending on virtual directory, home, file, directory.

--*/
{
    if (dwData == HIDD_DIRECTORY_PROPERTIES)
    {
        if (m_fSheetType == SHEET_TYPE_FILE)
        {
            dwData = HIDD_FS_FILE_PROPERTIES;
        }
        else if (m_fSheetType == SHEET_TYPE_DIR)
        {
            dwData = HIDD_FS_DIRECTORY_PROPERTIES;
        }
        else if (m_fSheetType == SHEET_TYPE_VDIR)
        {
            dwData = HIDD_DIRECTORY_PROPERTIES;
        }
        else if (m_fSheetType == SHEET_TYPE_SERVER)
        {
            dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
        }
        else if  (m_fSheetType == SHEET_TYPE_SITE)
        {
            dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
		}
        else
        {
            ASSERT(m_ppropDir != NULL);
            if (!::lstrcmpi(m_ppropDir->m_strAlias, g_cszRoot))
            {
                //
                // It's a home virtual directory -- change the ID
                //
                dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
            }
        }

    }

    WinHelpDebug(dwData);
    CInetPropertySheet::WinHelp(dwData, nCmd);
}



/* virtual */ 
HRESULT 
CW3Sheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Load base properties
    //
    CError err(CInetPropertySheet::LoadConfigurationParameters());

    if (err.Failed())
    {
        return err;
    }

    if (m_ppropInst == NULL)
    {
        //
        // First call -- load values
        //
        ASSERT(m_ppropDir == NULL);

        m_ppropInst = new CW3InstanceProps(QueryAuthInfo(), QueryInstancePath());
        m_ppropDir  = new CW3DirProps(QueryAuthInfo(), QueryDirectoryPath());

        if (!m_ppropInst || !m_ppropDir)
        {
            TRACEEOLID("LoadConfigurationParameters: OOM");
            SAFE_DELETE(m_ppropDir);
            SAFE_DELETE(m_ppropInst);

            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_ppropInst->LoadData();

        if (err.Succeeded())
        {
           err = m_ppropDir->LoadData();
		   if (err.Succeeded() && QueryMajorVersion() >= 6)
		   {
			   CMetaKey mk(QueryAuthInfo(), QueryServicePath(), METADATA_PERMISSION_READ);
			   err = mk.QueryResult();
			   if (err.Succeeded())
			   {
				   err = mk.QueryValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, m_fCompatMode);
				   if (err.Failed())
				   {
					   // Reset the error here, so at least
					   // we will not return error.
					   // (if we return error, then we will AV elsewhere)
					   err.MessageBoxOnFailure();
					   err.Reset();
				   }
			   }
		   }
		   else if (err.Succeeded())
		   {
			   // We will enable this for IIS5.1 and lower
			   m_fCompatMode = TRUE;
		   }

        }
    }

    return err;
}



/* virtual */ 
void 
CW3Sheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Base class
    //
    CInetPropertySheet::FreeConfigurationParameters();

    ASSERT(m_ppropInst != NULL);
    ASSERT(m_ppropDir  != NULL);

    SAFE_DELETE(m_ppropInst);
    SAFE_DELETE(m_ppropDir);
}



DWORD
IsSSLEnabledOnServer(
    IN CComAuthInfo * pAuthInfo,
    OUT BOOL & fInstalled,
    OUT BOOL & fEnabled
    )
/*++

Routine Description:

   Determine if SSL is installed on the server.

Arguments:

    LPCTSTR lpszServer      : Server name
    BOOL & fInstalled       : Returns TRUE if SSL is installed
    BOOL & fEnabled         : Returns TRUE if SSL is enabled

Return Value:

    Error return code.


--*/
{
/*
    LPW3_CONFIG_INFO lp = NULL;
    CString str;
    DWORD err = ::W3GetAdminInformation((LPTSTR)lpszServer, &lp);
    if (err != ERROR_SUCCESS)
    {
        TRACEEOLID("Failed to determine if SSL is installed");

        return err;
    }

    fInstalled = (lp->dwEncCaps & ENC_CAPS_NOT_INSTALLED) == 0;
    fEnabled = (lp->dwEncCaps & ENC_CAPS_DISABLED) == 0;

    NETAPIBUFFERFREE(lp);

*/

    //
    // Above doesn't work for Beta I -- hack to assume true.
    //
    fInstalled = fEnabled = TRUE;

    return ERROR_SUCCESS;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3Sheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


HRESULT
CW3Sheet::EnumAppPools(CStringListEx& pools)
{
	CError err;
    CIISMBNode * p = (CIISMBNode *)GetParameter();
    ASSERT(p != NULL);
    CIISMachine * pMachine = p->GetOwner();
    ASSERT(pMachine != NULL);
	CString machine = pMachine->QueryMachineName();
	do
	{
		CMetabasePath pools_path(TRUE, SZ_MBN_WEB, SZ_MBN_APP_POOLS);
		CMetaEnumerator en(pMachine->QueryAuthInfo(), pools_path);
		CString id, key_type;
		err = en.QueryResult();
		BREAK_ON_ERR_FAILURE(err);
		while (err.Succeeded())
		{
			err = en.Next(id);
            BREAK_ON_ERR_FAILURE(err);
			err = en.QueryValue(MD_KEY_TYPE, key_type, NULL, id);
            BREAK_ON_ERR_FAILURE(err);
			if (0 == key_type.CompareNoCase(_T("IIsApplicationPool")))
			{
				pools.AddTail(id);
            }
		}
	} while (FALSE);

	err.Reset();

	return err;
}

HRESULT
CW3Sheet::QueryDefaultPoolId(CString& id)
{
	CError err;
    CIISMBNode * p = (CIISMBNode *)GetParameter();
    ASSERT(p != NULL);
    CIISMachine * pMachine = p->GetOwner();
    ASSERT(pMachine != NULL);
    do
    {
		CMetabasePath service(TRUE, SZ_MBN_WEB);
        CMetaKey mk(pMachine->QueryAuthInfo(), service, METADATA_PERMISSION_READ);
        err = mk.QueryResult();
        BREAK_ON_ERR_FAILURE(err);
        err = mk.QueryValue(MD_APP_APPPOOL_ID, id);
    } while (FALSE);
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\util.cpp ===
#include "stdafx.h"
#include "common.h"
#include "iisobj.h"
#include "util.h"
#include <activeds.h>
#include <lmerr.h>
#include <Winsock2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void DumpFriendlyName(CIISObject * pObj)
{
	if (pObj)
	{
		CString strGUIDName;
		GUID * MyGUID = (GUID*) pObj->GetNodeType();
		GetFriendlyGuidName(*MyGUID,strGUIDName);
		TRACEEOL("CIISObject=" << strGUIDName);
	}
}

HRESULT DumpAllScopeItems(CComPtr<IConsoleNameSpace> pConsoleNameSpace, IN HSCOPEITEM hParent, IN int iTreeLevel)
{
    HSCOPEITEM hChildItem = NULL;
    CIISObject * pItem = NULL;
    LONG_PTR   cookie = NULL;

	if (0 == iTreeLevel)
	{
		TRACEEOL("==============");
		TRACEEOL("[\\]" << hParent);
	}
	iTreeLevel++;

    HRESULT hr = pConsoleNameSpace->GetChildItem(hParent, &hChildItem, &cookie);
    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        if (pItem)
        {
            //
            // Recursively dump every object
            //
			CString strGUIDName;GUID * MyGUID = (GUID*) pItem->GetNodeType();GetFriendlyGuidName(*MyGUID,strGUIDName);
			for (int i = 0; i < iTreeLevel; ++i)
			{
				TRACEOUT("-");
			}
			TRACEEOL("[" << strGUIDName << "] (parent=" << hParent << " )(" << hChildItem << ")");

			// dump all it's children
			DumpAllScopeItems(pConsoleNameSpace,hChildItem,iTreeLevel + 1);
        }

        //
        // Advance to next child of same parent
        //
        hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    return S_OK;
}


HRESULT DumpAllResultItems(IResultData * pResultData)
{
	HRESULT hr = S_OK;
	RESULTDATAITEM rdi;
	CIISObject * pItem = NULL;
	ZeroMemory(&rdi, sizeof(rdi));

	rdi.mask = RDI_PARAM | RDI_STATE;
	rdi.nIndex = -1; // -1 to start at first item
    do
    {
        rdi.lParam = 0;

        // this could AV right here if pResultData is invalid
        hr = pResultData->GetNextItem(&rdi);
        if (hr != S_OK)
        {
            break;
        }
                                
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)rdi.lParam;
        ASSERT_PTR(pItem);

		DumpFriendlyName(pItem);

        //
        // Advance to next child of same parent
        //
    } while (SUCCEEDED(hr) && -1 != rdi.nIndex);

	return hr;
}

//
//  IsValidDomainUser
//      Check if a domain user like redmond\jonsmith specified in szDomainUser
//  is valid or not. returns S_FALSE if it is invalid, S_OK for valid user.
//
//  szFullName      ----    To return the user's full name
//  cch             ----    count of characters pointed to by szFullName
//
//  if szFullName is NULL or cch is zero, no full name is returned
//
const TCHAR gszUserDNFmt[] = _T("WinNT://%s/%s,user");

HRESULT 
IsValidDomainUser(
    LPCTSTR szDomainUser, 
    LPTSTR  szFullName, 
    DWORD   cch)
{
    HRESULT hr = S_OK;
    TCHAR szDN[256];
    TCHAR szDomain[256];
    LPTSTR szSep;
    LPCTSTR szUser;
    DWORD dw;

    IADsUser * pUser = NULL;
    BSTR bstrFullName = NULL;

    //  Sanity check
    if (szDomainUser == NULL || szDomainUser[0] == 0)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    //
    //  Construct the user DN as <WINNT://domain/user,user>
    //
    szSep = _tcschr (szDomainUser, TEXT('\\'));
    if (szSep == NULL)
    {
        //  No '\' is given, assume a local user ,domain is local computer
        szUser = szDomainUser;
        dw = sizeof(szDomain)/sizeof(TCHAR);
        if (GetComputerName (szDomain, &dw) == 0)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }
    }
    else
    {
        //  assume invalid domain name if longer than 255
        if (szSep - szDomainUser >= sizeof(szDomain)/sizeof(TCHAR))
        {
            hr = S_FALSE;
            goto ExitHere;
        }
        _tcsncpy (szDomain, szDomainUser, szSep - szDomainUser);
        szDomain[szSep - szDomainUser] = 0;
        szUser = szSep + 1;
    }
    if (_tcslen (gszUserDNFmt) + _tcslen (szDomain) + _tcslen (szUser) > 
        sizeof(szDN) / sizeof(TCHAR))
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    wsprintf (szDN, gszUserDNFmt, szDomain, szUser);

    //
    //  Try to bind to the user object
    //
    hr = ADsGetObject (szDN, IID_IADsUser, (void **)&pUser);
    if (FAILED(hr))
    {
        if (hr == E_ADS_INVALID_USER_OBJECT ||
            hr == E_ADS_UNKNOWN_OBJECT ||
            hr == E_ADS_BAD_PATHNAME ||
            HRESULT_CODE(hr) == NERR_UserNotFound)
        {
            hr = S_FALSE;   // The user does not exist
        }
        goto ExitHere;
    }

    //
    //  If the user exists, get its full name
    //
    if (cch > 0)
    {
        hr = pUser->get_FullName (&bstrFullName);
        szFullName[0] = 0;
        if (hr == S_OK)
        {
            _tcsncpy (szFullName, bstrFullName, cch);
            szFullName[cch - 1] = 0;
        }
    }

ExitHere:
    if (pUser)
    {
        pUser->Release();
    }
    if (bstrFullName)
    {
        SysFreeString (bstrFullName);
    }
    return hr;
}
#if 0
DWORD  VerifyPassword(WCHAR  * sUserName, WCHAR * sPassword, WCHAR * sDomain)
{
   CWaitCursor			wait;
   DWORD				retVal = 0;
   CString				strDomainUserName;
   CString				localIPC;
   WCHAR				localMachine[MAX_PATH];
   WCHAR			  * computer = NULL;
   DWORD				len = DIM(localMachine);
   NETRESOURCE			nr;
   CString				error=L"no error";
   USER_INFO_3        * pInfo = NULL;
   NET_API_STATUS		rc;

   memset(&nr,0,(sizeof nr));

   if ( ! gbNeedToVerify )
      return 0;

   /* see if this domain exists and get a DC name */
      //get the domain controller name
   if (!GetDomainDCName(sDomain,&computer))
      return ERROR_LOGON_FAILURE;

   /* see if this user is a member of the given domain */
   rc = NetUserGetInfo(computer, sUserName, 3, (LPBYTE *)&pInfo);
   NetApiBufferFree(computer);
   if (rc != NERR_Success)
      return ERROR_LOGON_FAILURE;

   NetApiBufferFree(pInfo);

   /* see if the password allows us to connect to a local resource */
   strDomainUserName.Format(L"%s\\%s",sDomain,sUserName);
   // get the name of the local machine
   if (  GetComputerName(localMachine,&len) )
   {

	   localIPC.Format(L"\\\\%s",localMachine);
      nr.dwType = RESOURCETYPE_ANY;
      nr.lpRemoteName = localIPC.GetBuffer(0);
      retVal = WNetAddConnection2(&nr,sPassword,strDomainUserName,0);
error.Format(L"WNetAddConnection returned%u",retVal);	
	  if ( ! retVal )
      {
		error.Format(L"WNetAddConnection2 succeeded");

         retVal = WNetCancelConnection2(localIPC.GetBuffer(0),0,TRUE);
         if ( retVal )
            retVal = 0;
      }
      else if ( retVal == ERROR_SESSION_CREDENTIAL_CONFLICT )
      {

         // skip the password check in this case
         retVal = 0;
      }
	}
   else
   {
	   retVal = GetLastError();
	
   }
   return retVal;
}
#endif

//
// IsConnectingToOwnAddress
// return true if this is an attempt to reconnect to our
// own address.
//
BOOL IsConnectingToOwnAddress(u_long connectAddr)
{
    //32-bit form of 127.0.0.1 addr
    #define LOOPBACK_ADDR ((u_long)0x0100007f)
    
    //
    // First the quick check for localhost/127.0.0.1
    //
    if( LOOPBACK_ADDR == connectAddr)
    {
        TRACEEOLID("Connecting to loopback address...");
        return TRUE;
    }

    //
    // More extensive check, i.e resolve the local hostname
    //
    char hostname[(512+1)*sizeof(TCHAR)];
    int err;
    int j;
    struct hostent* phostent;

    err=gethostname(hostname, sizeof(hostname));
    if (err == 0)
    {
        if ((phostent = gethostbyname(hostname)) !=NULL)
        {
            switch (phostent->h_addrtype)
            {
                case AF_INET:
                    j=0;
                    while (phostent->h_addr_list[j] != NULL)
                    {
                        if(!memcmp(&connectAddr,
                                   phostent->h_addr_list[j],
                                   sizeof(u_long)))
                        {
                            TRACEEOLID("Connecting to same IP as the local machine...");
                            return TRUE;
                        }
                        j++;
                    }
                default:
                    break;
            }
        }
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
// IsLocalHost
//
// Arguments : szHostName (name of computer to check)
//             pbIsHost (set to TRUE if host name matches local computer name)
//
// Returns   : FALSE on windows socket error
//
// Purpose   : check if host name matches this (local) computer name
//-----------------------------------------------------------------------------
#define WS_VERSION_REQD  0x0101
BOOL IsLocalHost(LPCTSTR szHostName,BOOL* pbIsHost)
{
    const char * lpszAnsiHostName = NULL;

	*pbIsHost = FALSE;
	BOOL bSuccess = TRUE;
	hostent* phostent = NULL;

	// init winsock (reference counted - can init any number of times)
	//
	WSADATA wsaData;
	int err = WSAStartup(WS_VERSION_REQD, &wsaData);
	if (err)
	{
		return FALSE;
	}

    //
    // convert to ansi
    //
#ifdef UNICODE
    CHAR szAnsi[MAX_PATH];
    if (::WideCharToMultiByte(CP_ACP, 0L, szHostName, -1,  szAnsi, sizeof(szAnsi), NULL, NULL) > 0)
    {
        lpszAnsiHostName = szAnsi;
    }
#else
    lpszAnsiHostName = szHostName;
#endif // UNICODE

    if (NULL == lpszAnsiHostName)
    {
        return FALSE;
    }

	// get dns name for the given hostname
	//
	unsigned long addr = inet_addr(lpszAnsiHostName);

	if (addr == INADDR_NONE) 
		phostent = gethostbyname(lpszAnsiHostName);
	else
		phostent = gethostbyaddr((char*)&addr,4, AF_INET);

	if (phostent == NULL)
	{
		bSuccess = FALSE;
		goto cleanup;
	}
    else
    {
        IN_ADDR hostaddr;
        memcpy(&hostaddr,phostent->h_addr,sizeof(hostaddr));
        *pbIsHost = IsConnectingToOwnAddress(hostaddr.s_addr);
        bSuccess = TRUE;
		goto cleanup;
    }

cleanup:
	err = WSACleanup();
	if (err != 0)
	{
		bSuccess = FALSE;
	}
	return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\util.h ===
#ifndef __UTIL_H__
#define __UTIL_H__

#include "resource.h"

extern INT g_iDebugOutputLevel;

void DumpFriendlyName(CIISObject * pObj);
HRESULT DumpAllScopeItems(CComPtr<IConsoleNameSpace> pConsoleNameSpace, IN HSCOPEITEM hParent, IN int iTreeLevel);
HRESULT DumpAllResultItems(IResultData * pResultData);
HRESULT IsValidDomainUser(LPCTSTR szDomainUser,LPTSTR  szFullName,DWORD cch);
BOOL IsLocalHost(LPCTSTR szHostName,BOOL* pbIsHost);

#if defined(_DEBUG) || DBG

#define DEBUG_PREPEND_STRING _T("---")
typedef CMap< DWORD_PTR, DWORD_PTR, CString, LPCTSTR> CMyMapPointerToString;

class CDebug_IISObject
{
public:
    CDebug_IISObject()
	{
		m_strClassName = _T("CDebug_IISObject");
	};
	~CDebug_IISObject(){};

public:
	CString m_strClassName;
	void Init()
	{
		DebugList_IISObject.RemoveAll();
        DebugList_PointersToFriendly.RemoveAll();
	}

	void Add(CIISObject * pItem)
	{
		if (g_iDebugOutputLevel & DEBUG_FLAG_CIISOBJECT)
		{
			DebugTrace(_T("%s%s>:Add:[%3d] %p\r\n"),m_strClassName,DEBUG_PREPEND_STRING,DebugList_IISObject.GetCount(),pItem);
		}
		DebugList_IISObject.AddTail(pItem);
	}

	void Del(CIISObject * pItem)
	{
		INT_PTR iCount = DebugList_IISObject.GetCount();
		iCount--;
        CString strDescription;

        // See if we can find this pointer in our list of pointers to friendlynames..
        DWORD_PTR dwPtr = (DWORD_PTR) pItem;
		DebugList_PointersToFriendly.Lookup(dwPtr,strDescription);

        POSITION pos = DebugList_IISObject.Find(pItem);
		if (pos)
		{
			DebugList_IISObject.RemoveAt(pos);
			if (g_iDebugOutputLevel & DEBUG_FLAG_CIISOBJECT)
			{
				DebugTrace(_T("%s<%s:Del:[%3d] %p (%s)\r\n"),m_strClassName,DEBUG_PREPEND_STRING,iCount,pItem,strDescription);
			}
		}
		else
		{
			if (g_iDebugOutputLevel & DEBUG_FLAG_CIISOBJECT)
			{
				DebugTrace(_T("%s<%s:Del:[%3d] %p (%s) (not found)\r\n"),m_strClassName,DEBUG_PREPEND_STRING,iCount,pItem,strDescription);
			}
		}
	}

	void Dump(INT iVerboseLevel)
	{
		int iCount = 0;
        int iUseCount = 0;
        BOOL bPropertySheetOpen = FALSE;
		CString strGUIDName;
        CString strBigString;
		GUID * MyGUID = NULL;
		CIISObject * pItemFromList = NULL;

		if (!(g_iDebugOutputLevel & DEBUG_FLAG_CIISOBJECT))
		{
			return;
		}

        if (iVerboseLevel)
        {
		    DebugTrace(_T("%s%s:Dump: -------------- start (count=%d)\r\n"),m_strClassName,DEBUG_PREPEND_STRING,DebugList_IISObject.GetCount());
        }

        POSITION pos = DebugList_IISObject.GetHeadPosition();
	    while (pos)
	    {
		    pItemFromList = DebugList_IISObject.GetNext(pos);
            if (pItemFromList)
            {
				iCount++;

                // Get GUID Name
				MyGUID = (GUID*) pItemFromList->GetNodeType();
				if (MyGUID)
				{
					GetFriendlyGuidName(*MyGUID,strGUIDName);
				}

                // Get ref count
                iUseCount = pItemFromList->UseCount();

                // Get Propertysheet open flag
                bPropertySheetOpen = FALSE;
                if (pItemFromList->IsMyPropertySheetOpen())
                {
                    bPropertySheetOpen = TRUE;
                }

                // Get FriendlyName
                LPOLESTR pTempFriendly = pItemFromList->QueryDisplayName();
                if (0 == iVerboseLevel)
                {
                    // Just update the display info
                } else if (1 == iVerboseLevel)
                {
                    DebugTrace(_T("%s%s:Dump:[%3d][%3d]%s %p (%s)\r\n"),m_strClassName,DEBUG_PREPEND_STRING,iCount,iUseCount,bPropertySheetOpen ? _T("P") : _T("."),pItemFromList,
                        strGUIDName);
                }
                else if (2 >= iVerboseLevel)
                {
                    DebugTrace(_T("%s%s:Dump:[%3d][%3d]%s %p (%s) '%s'\r\n"),m_strClassName,DEBUG_PREPEND_STRING,iCount,iUseCount,bPropertySheetOpen ? _T("P") : _T("."),pItemFromList,
                        strGUIDName,
                        pTempFriendly);
                }
                else
                {
                    DebugTrace(_T("%s%s:Dump:[%3d][%3d]%s %p\r\n"),m_strClassName,DEBUG_PREPEND_STRING,iCount,iUseCount,bPropertySheetOpen ? _T("P") : _T("."),pItemFromList);
                }

                DWORD_PTR dwPtr = (DWORD_PTR) pItemFromList;
                strBigString = strGUIDName;
                if (pTempFriendly)
                {
                    strBigString += _T(" '");
                    strBigString += pTempFriendly;
                    strBigString += _T("'");
                }

                DebugList_PointersToFriendly.SetAt(dwPtr,strGUIDName);
            }
        }
        if (iVerboseLevel)
        {
		    DebugTrace(_T("%s%s:Dump: -------------- end\r\n"),m_strClassName,DEBUG_PREPEND_STRING);
        }
	}

	void Dump()
	{
		Dump(2);
	}

private:
	CIISObjectList DebugList_IISObject;
    CMyMapPointerToString DebugList_PointersToFriendly;
};

#endif // DEBUG
#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\w3sht.h ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        w3sht.h

   Abstract:
        WWW Property Sheet Definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __W3SHT_H__
#define __W3SHT_H__

#include "shts.h"

extern const LPCTSTR g_cszSvc;

//
// Helper function to determine if SSL is installed
// and enabled on the given server
//
DWORD
IsSSLEnabledOnServer(
    IN  CComAuthInfo * pAuthInfo,
    OUT BOOL & fInstalled,
    OUT BOOL & fEnabled
    );

//
// Helper function to see if a certificate is installed
//
BOOL
IsCertInstalledOnServer(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    );

#ifndef LOGGING_ENABLED
#define LOGGING_ENABLED
inline BOOL LoggingEnabled(
    IN DWORD dwLogType
    )
{
    return (dwLogType == MD_LOG_TYPE_ENABLED);
}
#endif

#ifndef ENABLE_LOGGING
#define ENABLE_LOGGING
inline void EnableLogging(
    OUT DWORD & dwLogType, 
    IN  BOOL fEnabled = TRUE
    )
{
    dwLogType = fEnabled ? MD_LOG_TYPE_ENABLED : MD_LOG_TYPE_DISABLED;
}
#endif


//
// Bandwidth definitions
//
#define INFINITE_BANDWIDTH      (0xffffffff)
#define INFINITE_CPU_RAW        (0xffffffff)
#define KILOBYTE                (1024L)
#define MEGABYTE                (1024L * KILOBYTE)
#define DEF_BANDWIDTH           (1 * MEGABYTE)
#define CPU_THROTTLING_FACTOR   (1000)
#define DEFAULT_CPU_PERCENTAGE  (10L)

//
// Some sanity values on max connections
//
#define INITIAL_MAX_CONNECTIONS  (      1000L)
// TODO: Check these limits
//#define UNLIMITED_CONNECTIONS    (2000000000L)
#define UNLIMITED_CONNECTIONS    (0xFFFFFFFF)
#define MAX_MAX_CONNECTIONS      (UNLIMITED_CONNECTIONS - 1L)

#define MAX_TIMEOUT              (0x7FFFFFFF)



class CW3InstanceProps : public CInstanceProps
/*++

Class Description:
    
    WWW Instance properties class

Public Interface:

    CW3InstanceProps        : Constructor

--*/
{
public:
    CW3InstanceProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

	~CW3InstanceProps();

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Service Page
    //
    MP_DWORD         m_dwLogType;
    MP_CILong        m_nConnectionTimeOut;
    MP_CStringListEx m_strlSecureBindings;

    //
    // Performance Page
    //
    MP_int           m_nServerSize;
    MP_BOOL          m_fUseKeepAlives;
    MP_CILong        m_dwMaxBandwidth;
    MP_CILong        m_dwMaxGlobalBandwidth;
    MP_CILong        m_nMaxConnections;

    //
    // Operators Page
    //
    MP_CBlob         m_acl;

    //
    // Root dir page
    //
    //MP_BOOL          m_fFrontPage;

    //
    // Default Site page
    //
    MP_DWORD         m_dwDownlevelInstance;

    //
    // Certificate and CTL information
    //
    MP_CBlob         m_CertHash;
    MP_CString       m_strCertStoreName;
    MP_CString       m_strCTLIdentifier;
    MP_CString       m_strCTLStoreName;
};



class CW3DirProps : public CChildNodeProps
/*++

Class Description:

    WWW Directory Properties

Public Interface:

    CW3DirProps     : Constructor

--*/
{
public:
    //
    // Constructor
    //
    CW3DirProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Directory properties page
    //
    MP_CString       m_strUserName;
    MP_CStrPassword  m_strPassword;
    MP_CString       m_strDefaultDocument;
    MP_CString       m_strFooter;
    MP_CMaskedDWORD  m_dwDirBrowsing;
    MP_BOOL          m_fDontLog;
    MP_BOOL          m_fEnableFooter;
    MP_BOOL          m_fIndexed;

    //
    // HTTP Page
    //
    MP_CString       m_strExpiration;
    MP_CStringListEx m_strlCustomHeaders;

    //
    // Custom Errors
    //
    MP_CStringListEx m_strlCustomErrors;

    //
    // Security page
    //
    MP_DWORD         m_dwAuthFlags;
    MP_DWORD         m_dwSSLAccessPermissions;
    MP_CString       m_strBasicDomain;
    MP_CString       m_strRealm;
    MP_CString       m_strAnonUserName;
    MP_CStrPassword  m_strAnonPassword;
    MP_BOOL          m_fPasswordSync;
    MP_BOOL          m_fU2Installed;
    MP_BOOL          m_fUseNTMapper;
    MP_CBlob         m_ipl;
};

#define MD_FILTER_STATE_UNDEFINED   0

class CIISFilter : public CObjectPlus
/*++

Class Description:

    A single filter description

Public Interface:

    CIISFilter      : Constructors
    IsInitialized   : Check to see if the name is set.
    Write           : Write to the metabase.
    QueryResult     : Query result from metabase read
    QueryError      : Returns error as stored in metabase
    QueryName       : Returns filter name
    IsLoaded        : TRUE if filter is loaded
    IsUnloaded      : TRUE if filter is unloaded
    IsEnabled       : TRUE if filter is enabled
    Enable          : Enable filter
    IsDirty         : TRUE if filter values have changed
    IsFlaggedForDeletion : TRUE if filter should be deleted
  
--*/
{
//
// Constructors/Destructors
//
public:
    //
    // Null Constructor
    //
    CIISFilter();

    //
    // Read filter values using provided key
    //
    CIISFilter(
        IN CMetaKey * pKey,
        IN LPCTSTR lpszName
        );

    //
    // Copy constructor
    //
    CIISFilter(
        IN const CIISFilter & flt
        );

public:
    //
    // Sorting helper
    //
    int OrderByPriority(
        IN const CObjectPlus * pobAccess
        ) const;

    BOOL IsInitialized() const { return !m_strName.IsEmpty(); }

    //
    // Write using provided key
    //
    HRESULT Write(CMetaKey * pKey);

public:
    BOOL IsLoaded() const;
    BOOL IsUnloaded() const;
    BOOL IsEnabled() const { return m_fEnabled; }
    void Enable(BOOL fEnabled = TRUE);
    DWORD QueryError() const { return m_dwWin32Error; }
    HRESULT QueryResult() const { return m_hrResult; }

    //
    // Check to see if this item is marked as dirty
    //
    BOOL IsDirty() const { return m_fDirty; }

    //
    // Check to see if this item is flagged for deletion
    //
    BOOL IsFlaggedForDeletion() const { return m_fFlaggedForDeletion; }

    //
    // Set/reset the dirty flag
    //
    void Dirty(BOOL fDirty = TRUE);

    //
    // Flag this item for deletion
    //
    void FlagForDeletion();

    //
    // Get the name of this filter
    //
    LPCTSTR QueryName() const { return m_strName; }

//
// Meta Values
//
public:
    int         m_nPriority;
    int         m_nOrder;
    BOOL        m_fEnabled;
    DWORD       m_dwState;
    DWORD       m_dwWin32Error;
    HRESULT     m_hrResult;
    CString     m_strName;
    CString     m_strExecutable;

//
// State Values
//
private:
    BOOL        m_fDirty;
    BOOL        m_fFlaggedForDeletion;
    DWORD       m_dwFlags;
};



class CIISFilterList : public CMetaKey
/*++

Class Description:

    A list of filters

Public Interface:

    CIISFilterList      : Constructor

    BeginSearch         : Reset the iterator
    MoreFilters         : More items available in the list?
    GetNextFilter       : Get the next item in the list

--*/
{
public:
    CIISFilterList(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath
        /*
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance       = MASTER_INSTANCE
        */
        );

public:
    //
    // Write out the filter list
    //
    HRESULT WriteIfDirty();

//
// Acccess Functions
//
public:
    //DWORD QueryInstance() const { return m_dwInstance; }
    BOOL FiltersLoaded()  const { return m_fFiltersLoaded; }

    //
    // Load each filter in turn
    //
    HRESULT LoadAllFilters();

//
// Filter Access Functions
//
public:
    //
    // Reset the filter list iterator
    //
    void ResetEnumerator();

    int GetCount() const { return (int)m_oblFilters.GetCount(); }

    //
    // More filters available in the list? 
    //
    BOOL MoreFilters() const { return m_pos != NULL; }

    //
    // Return position of filter by index
    //
    POSITION GetFilterPositionByIndex(int nSel);

    //
    // Iterate to the next filter in the list
    //
    CIISFilter * GetNextFilter();

    //
    // Remove filter
    //
    void RemoveFilter(int nItem);

    //
    // Add new filter
    //
    void AddFilter(CIISFilter * pFilter);

    //
    // Exchange two filters in the list
    //
    BOOL ExchangePositions(
        IN  int nSel1, 
        IN  int nSel2, 
        OUT CIISFilter *& p1,
        OUT CIISFilter *& p2
        );

    //
    // See if at least one filter is dirty
    //
    BOOL HasDirtyFilter() const;

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrResult); }
    virtual HRESULT QueryResult() const { return m_hrResult; }

protected:
    //
    // Build up order string from component list
    //
    LPCTSTR BuildFilterOrderString(
        OUT CString & strFilterOrder
        );

protected:
    //
    // Seperator string (one character)
    //
    static const LPCTSTR s_lpszSep;

private:
    BOOL     m_fFiltersLoaded;
    //DWORD    m_dwInstance;
    POSITION m_pos;
    HRESULT  m_hrResult;
    CString  m_strFilterOrder;
    CObListPlus m_oblFilters;
};


//
// W3 Property sheet
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CW3Sheet : public CInetPropertySheet
{
public:
    CW3Sheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN DWORD   dwAttributes,
        IN CWnd *  pParentWnd  = NULL,
        IN LPARAM  lParam      = 0L,
        IN LPARAM  lParamParent= 0L,
        IN UINT    iSelectPage = 0
        );

    virtual ~CW3Sheet();

public:
    HRESULT QueryInstanceResult() const;
    HRESULT QueryDirectoryResult() const;
    CW3InstanceProps & GetInstanceProperties() { return *m_ppropInst; }
    CW3DirProps & GetDirectoryProperties() { return *m_ppropDir; }
    BOOL InCompatibilityMode() const { return m_fCompatMode; }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

	HRESULT EnumAppPools(CStringListEx& pools);
	HRESULT SetKeyType();
	HRESULT QueryDefaultPoolId(CString& id);
	enum
	{
        SHEET_TYPE_SERVER,
		SHEET_TYPE_SITE,
        SHEET_TYPE_VDIR,
        SHEET_TYPE_DIR,
		SHEET_TYPE_FILE
	};
    HRESULT SetSheetType(int fSheetType);

protected:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    //{{AFX_MSG(CW3Sheet)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    DWORD            m_fNew;
    DWORD            m_dwAttributes;
    BOOL             m_fCompatMode;
    CW3InstanceProps * m_ppropInst;
    CW3DirProps      * m_ppropDir;
    int              m_fSheetType;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CIISFilter::IsLoaded() const
{
    return m_dwState == MD_FILTER_STATE_LOADED;
}

inline BOOL CIISFilter::IsUnloaded() const
{
    return m_dwState == MD_FILTER_STATE_UNLOADED;
}

inline void CIISFilter::Enable(
    IN BOOL fEnabled
    )
{
    m_fEnabled = fEnabled;
}

inline void CIISFilter::Dirty(
    IN BOOL fDirty
    )
{
    m_fDirty = fDirty;
}

inline void CIISFilter::FlagForDeletion()
{
    m_fFlaggedForDeletion = TRUE;
}

inline void CIISFilterList::ResetEnumerator()
{
    m_pos = m_oblFilters.GetHeadPosition();
}

inline CIISFilter * CIISFilterList::GetNextFilter()
{
    return (CIISFilter *)m_oblFilters.GetNext(m_pos);
}

inline void CIISFilterList::RemoveFilter(int nItem)
{
    m_oblFilters.RemoveIndex(nItem);
}

inline void CIISFilterList::AddFilter(CIISFilter * pFilter)
{
    m_oblFilters.AddTail(pFilter);
}

//
// BUGBUG: Returns S_OK if object not present
//
inline HRESULT CW3Sheet::QueryInstanceResult() const 
{ 
    return m_ppropInst ? m_ppropInst->QueryResult() : S_OK;
}

inline HRESULT CW3Sheet::QueryDirectoryResult() const 
{ 
    return m_ppropDir ? m_ppropDir->QueryResult() : S_OK;
}


#endif // __W3SHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wdir.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wdir.h

   Abstract:
        WWW Directory (non-virtual) Properties Page Definitions

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __WDIR_H__
#define __WDIR__H_ 


class CW3DirPage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CW3DirPage)

//
// Constructor/Destructor
//
public:
    CW3DirPage(CInetPropertySheet * pSheet = NULL);
    ~CW3DirPage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_DIRECTORY,
        RADIO_REDIRECT,
    };

    enum
    {
        COMBO_NONE,
        COMBO_SCRIPT,
        COMBO_EXECUTE,
    };

    //{{AFX_DATA(CW3DirectoryPage)
    enum { IDD = IDD_WEB_DIRECTORY_PROPERTIES };
	// Path type
    int     m_nPathType;
    CButton m_radio_Dir;
    CButton m_radio_Redirect;
	// Local path
    CEdit   m_edit_Path;
	// permissions flags
    BOOL    m_fAuthor;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fBrowsingAllowed;
    BOOL    m_fLogAccess;
    BOOL    m_fIndexed;
	// permission buttons
    CButton m_check_Author;
    CButton m_check_Read;
    CButton m_check_Write;
    CButton m_check_DirBrowse;
	CButton m_check_LogAccess;
    CButton m_check_Index;
	// Redirection
    CEdit   m_edit_Redirect;
    CString m_strRedirectPath;
	// permissions
    BOOL    m_fChild;
    BOOL    m_fExact;
    BOOL    m_fPermanent;
	// permission buttons
    CButton m_check_Child;

//    CStatic m_static_Path;
    CStatic m_static_PathPrompt;

	// Application config controls
    CButton m_button_Unload;
    CButton m_button_CreateRemove;
    CButton m_button_Configuration;
    CString m_strAppFriendlyName;
    CEdit m_edit_AppFriendlyName;
    CString m_strAppRoot;
    CString m_strAlias;

    int m_nPermissions;
    CComboBox m_combo_Permissions;
    CComboBox m_combo_Process;

    CStatic m_static_ProtectionPrompt;
    //}}AFX_DATA

    
//    DWORD m_dwAccessPermissions;
    DWORD m_dwBitRangePermissions;
    DWORD m_dwBitRangeDirBrowsing;
    DWORD m_dwAccessPerms;
    DWORD m_dwDirBrowsing;
    DWORD m_dwAppProtection;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3DirPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3DirPage)
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckRead();
    afx_msg void OnCheckWrite();
    afx_msg void OnCheckAuthor();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioRedirect();
    afx_msg void OnButtonCreateRemoveApp();
    afx_msg void OnButtonUnloadApp();
    afx_msg void OnButtonConfiguration();
    afx_msg void OnSelchangeComboPermissions();
    afx_msg void OnSelchangeComboProcess();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void ShowControl(CWnd * pWnd, BOOL fShow);
    void ShowControl(UINT nID, BOOL fShow);
    void SetStateByType();
    void SetPathType();
    void SetAuthoringState(BOOL fAlterReadAndWrite = TRUE);
    void RefreshAppState();
    void ChangeTypeTo(int nNewType);
    int AddStringToComboBox(CComboBox & combo, UINT nID);
    BOOL CheckWriteAndExecWarning();
    DWORD GetAppStateFromComboSelection()  const;

protected:
    //
    // Remember/restore settings.
    //
    void SaveAuthoringState();
    void RestoreAuthoringState();
	void SetApplicationState();
    CString& FriendlyAppRoot(LPCTSTR lpAppRoot, CString& strStartingPoint);

private:
    BOOL  m_fCompatibilityMode;
    BOOL  m_fOriginalRead;
    BOOL  m_fOriginalWrite;
    BOOL  m_fRecordChanges;  
    BOOL  m_fAppEnabled;
    BOOL  m_fIsAppRoot;
    DWORD m_dwAppState;
    CString m_strRemove;
    CString m_strCreate;
    CString m_strEnable;
    CString m_strDisable;
    CString m_strWebFmt;
    CString m_strFullMetaPath;
    CString m_strPrompt[2];
    CString m_strUserName;
    CStrPassword m_strPassword;
    CIISApplication * m_pApplication;
    int m_nSelInProc;
    int m_nSelPooledProc;
    int m_nSelOutOfProc;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void 
CW3DirPage::ShowControl(UINT nID, BOOL fShow)
{
    ASSERT(nID > 0);
    ShowControl(GetDlgItem(nID), fShow);
}

inline int
CW3DirPage::AddStringToComboBox(CComboBox & combo, UINT nID)
{
    CString str;
    VERIFY(str.LoadString(nID));
    return combo.AddString(str);
}

#endif // __WFILE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\webaddnew.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        WebAddNew.cpp

   Abstract:
        Implementation for classes used in creation of new Web site and virtual directory

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/12/2000       sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "wizard.h"
#include "w3sht.h"
#include "WebAddNew.h"
#include <shlobjp.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define DEF_PORT        (80)
#define DEF_SSL_PORT   (443)
#define MAX_ALIAS_NAME (240)        // Ref Bug 241148

extern CInetmgrApp theApp;

HRESULT
RebindInterface(OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue, IN  DWORD dwCancelError);


static TCHAR g_InvalidCharsHostHeader[] = _T(" ~`!@#$%^&*()_+={}[]|/\\?*:;\"\'<>,");
static TCHAR g_InvalidCharsAlias[] = _T("/\\?*");
static TCHAR g_InvalidCharsPath[] = _T("|<>/*?\"");

HRESULT
CIISMBNode::AddWebSite(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    DWORD * inst,
	DWORD verMajor,
	DWORD verMinor
    )
{
   CWebWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName()
      );
   ws.m_fNewSite = TRUE;
   ws.m_dwVersionMajor = verMajor;
   ws.m_dwVersionMinor = verMinor;
   CIISWizardSheet sheet(
      IDB_WIZ_WEB_LEFT, IDB_WIZ_WEB_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_WEB_NEW_SITE_WELCOME, 
        IDS_WEB_NEW_SITE_WIZARD, 
        IDS_WEB_NEW_SITE_BODY
        );
   CWebWizDescription  pgDescr(&ws);
   CWebWizBindings     pgBindings(&ws);
   CWebWizPath         pgHome(&ws, FALSE);
   CWebWizUserName     pgUserName(&ws, FALSE);
   CWebWizPermissions  pgPerms(&ws, FALSE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_WEB_NEW_SITE_SUCCESS,
        IDS_WEB_NEW_SITE_FAILURE,
        IDS_WEB_NEW_SITE_WIZARD
        );
   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgDescr);
   sheet.AddPage(&pgBindings);
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   CThemeContextActivator activator(theApp.GetFusionInitHandle());

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
   if (inst != NULL /*&& SUCCEEDED(ws.m_hrResult)*/)
   {
      *inst = ws.m_dwInstance;
   }

   return ws.m_hrResult;
}

HRESULT
CIISMBNode::AddWebVDir(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    CString& alias,
	DWORD verMajor,
	DWORD verMinor
    )
{
   CWebWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName()
      );
   CComBSTR path;
   BuildMetaPath(path);
   ws.m_strParent = path;
   ws.m_fNewSite = FALSE;
   ws.m_dwVersionMajor = verMajor;
   ws.m_dwVersionMinor = verMinor;
   CIISWizardSheet sheet(
      IDB_WIZ_WEB_LEFT, IDB_WIZ_WEB_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_WEB_NEW_VDIR_WELCOME, 
        IDS_WEB_NEW_VDIR_WIZARD, 
        IDS_WEB_NEW_VDIR_BODY
        );
   CWebWizAlias        pgAlias(&ws);
   CWebWizPath         pgHome(&ws, TRUE);
   CWebWizUserName     pgUserName(&ws, TRUE);
   CWebWizPermissions  pgPerms(&ws, TRUE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_WEB_NEW_VDIR_SUCCESS,
        IDS_WEB_NEW_VDIR_FAILURE,
        IDS_WEB_NEW_VDIR_WIZARD
        );
   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgAlias);
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   CThemeContextActivator activator(theApp.GetFusionInitHandle());

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
//   if (SUCCEEDED(ws.m_hrResult))
//   {
       alias = ws.m_strAlias;
//   }

   return ws.m_hrResult;
}

CWebWizSettings::CWebWizSettings(
        IN CMetaKey * pMetaKey,
        IN LPCTSTR lpszServerName,     
        IN DWORD   dwInstance,
        IN LPCTSTR lpszParent
        )
/*++

Routine Description:

    Web Wizard Constructor

Arguments:

    HANDLE  hServer      : Server handle
    LPCTSTR lpszService  : Service name
    DWORD   dwInstance   : Instance number
    LPCTSTR lpszParent   : Parent path

Return Value:

    N/A

--*/
    : m_hrResult(S_OK),
      m_pKey(pMetaKey),
      m_fUNC(FALSE),
      m_fRead(FALSE),
      m_fWrite(FALSE),
      m_fAllowAnonymous(TRUE),
      m_fDirBrowsing(FALSE),
      m_fScript(FALSE),
      m_fExecute(FALSE),
	  m_fDelegation(TRUE),  // on by default
      m_dwInstance(dwInstance)
{
    ASSERT(lpszServerName != NULL);

    m_strServerName = lpszServerName;
    m_fLocal = IsServerLocal(m_strServerName);
    m_strService = SZ_MBN_WEB;

    if (lpszParent)
    {
        m_strParent = lpszParent;
    }
}




//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizDescription, CIISWizardPage)



CWebWizDescription::CWebWizDescription(
    IN OUT CWebWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizDescription::IDD,
        IDS_WEB_NEW_SITE_WIZARD,
        HEADER_PAGE
        ),
    m_pSettings(pwsSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CWebWizDescription)
    m_strDescription = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}



CWebWizDescription::~CWebWizDescription()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizDescription::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizDescription)
    DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
    //}}AFX_DATA_MAP
}



void
CWebWizDescription::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

	if (m_edit_Description.GetWindowTextLength() > 0)
	{
		dwFlags |= PSWIZB_NEXT;
	}

	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags); 
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);
}



LRESULT
CWebWizDescription::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(
        m_edit_Description, 
        m_pSettings->m_strDescription, 
        1, 
        MAX_PATH
        ))
    {
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizDescription, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizDescription)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CWebWizDescription::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void 
CWebWizDescription::OnChangeEditDescription() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizBindings, CIISWizardPage)



CWebWizBindings::CWebWizBindings(
    IN OUT CWebWizSettings * pwsSettings,
    IN DWORD   dwInstance
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizBindings::IDD, IDS_WEB_NEW_SITE_WIZARD, HEADER_PAGE
        ),
      m_pSettings(pwsSettings),
      m_iaIpAddress(),
      m_oblIpAddresses(),
      m_dwInstance(dwInstance),
	  m_bNextPage(FALSE)
{
    //{{AFX_DATA_INIT(CWebWizBindings)
    m_nIpAddressSel = -1;
    m_nTCPPort = DEF_PORT;
    m_nSSLPort = DEF_SSL_PORT;
    m_strDomainName = _T("");
    //}}AFX_DATA_INIT
    BeginWaitCursor();
    m_fCertInstalled = ::IsCertInstalledOnServer(
        m_pSettings->m_pKey->QueryAuthInfo(), 
        CMetabasePath(
            m_pSettings->m_strService,
            m_pSettings->m_dwInstance,
            m_pSettings->m_strParent,
            m_pSettings->m_strAlias
            )
        );
    EndWaitCursor();
}



CWebWizBindings::~CWebWizBindings()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizBindings::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizBindings)
	// This Needs to come before DDX_Text which will try to put text big number into small number
	DDV_MinMaxBalloon(pDX, IDC_EDIT_TCP_PORT, 1, 65535);
    DDX_TextBalloon(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
    DDX_Text(pDX, IDC_EDIT_DOMAIN_NAME, m_strDomainName);
    DDV_MaxCharsBalloon(pDX, m_strDomainName, MAX_PATH);
	if (pDX->m_bSaveAndValidate && m_bNextPage)
	{
        //
        // This code should be the same as in CMMMEditDlg::DoDataExchange
        //
        LPCTSTR p = m_strDomainName;
        while (p != NULL && *p != 0)
        {
            TCHAR c = towupper(*p);
            if (    (c >= _T('A') && c <= _T('Z')) 
                ||  (c >= _T('0') && c <= _T('9'))
                ||  (c == _T('.') || c == _T('-'))
                )
            {
                p++;
                continue;
            }
            else
            {
                pDX->PrepareEditCtrl(IDC_EDIT_DOMAIN_NAME);
                DDV_ShowBalloonAndFail(pDX, IDS_WARNING_DOMAIN_NAME);
            }
        }
//		if (m_strDomainName.FindOneOf(g_InvalidCharsHostHeader) >= 0)
//		{
//			DDV_ShowBalloonAndFail(pDX, IDS_ERR_INVALID_HOSTHEADER_CHARS);
//		}

		// Check if the host header is valid
		if (!m_strDomainName.IsEmpty())
		{
			if (FAILED(IsValidHostHeader(m_strDomainName)))
			{
				pDX->PrepareEditCtrl(IDC_EDIT_DOMAIN_NAME);
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_DOMAIN_NAME_INVALID);
			}
		}
	}
    //}}AFX_DATA_MAP

    if (m_fCertInstalled)
    {
		// This Needs to come before DDX_Text which will try to put text big number into small number
		DDV_MinMaxBalloon(pDX, IDC_EDIT_SSL_PORT, 1, 65535);
        DDX_TextBalloon(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort);
    }
    if (pDX->m_bSaveAndValidate && m_nTCPPort == m_nSSLPort)
    {
		DDV_ShowBalloonAndFail(pDX, IDS_TCP_SSL_PART);
    }

    DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

    if (pDX->m_bSaveAndValidate)
    {
        if (!FetchIpAddressFromCombo(m_combo_IpAddresses, m_oblIpAddresses, m_iaIpAddress))
        {
            pDX->Fail();
        }

        //
        // Build with empty host header
        //
        CInstanceProps::BuildBinding(
            m_pSettings->m_strBinding, 
            m_iaIpAddress, 
            m_nTCPPort, 
            m_strDomainName
            );

        if (m_fCertInstalled)
        {
            CInstanceProps::BuildSecureBinding(
                m_pSettings->m_strSecureBinding, 
                m_iaIpAddress, 
                m_nSSLPort
                );
        }
        else
        {
            m_pSettings->m_strSecureBinding.Empty();
        }
    }
}




void
CWebWizBindings::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT | PSWIZB_BACK);
    
    BeginWaitCursor();
    m_fCertInstalled = ::IsCertInstalledOnServer(
        m_pSettings->m_pKey->QueryAuthInfo(), 
        CMetabasePath(
            m_pSettings->m_strService,
            m_pSettings->m_dwInstance,
            m_pSettings->m_strParent,
            m_pSettings->m_strAlias
            )
        );
    EndWaitCursor();

    if (m_fCertInstalled)
    {
        GetDlgItem(IDC_STATIC_SSL_PORT)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_EDIT_SSL_PORT)->ShowWindow(SW_SHOW);
    }
    else
    {
        GetDlgItem(IDC_STATIC_SSL_PORT)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_EDIT_SSL_PORT)->ShowWindow(SW_HIDE);
    }
    GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(m_fCertInstalled);
    GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(m_fCertInstalled);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizBindings, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizBindings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizBindings::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_pSettings->m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();

    LimitInputDomainName(CONTROL_HWND(IDC_EDIT_DOMAIN_NAME ));

	return TRUE;
}



BOOL 
CWebWizBindings::OnSetActive() 
{
	m_bNextPage = FALSE;
    SetControlStates();
    return CIISWizardPage::OnSetActive();
}

LRESULT
CWebWizBindings::OnWizardNext() 
{
	m_bNextPage = TRUE;
    return CIISWizardPage::OnWizardNext();
}


//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizAlias, CIISWizardPage)



CWebWizAlias::CWebWizAlias(
    IN OUT CWebWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizAlias::IDD,
        IDS_WEB_NEW_VDIR_WIZARD,
        HEADER_PAGE
        ),
      m_pSettings(pwsSettings)
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CWebWizAlias)
    //}}AFX_DATA_INIT

#endif // 0
}



CWebWizAlias::~CWebWizAlias()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizAlias::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizAlias)
    DDX_Control(pDX, IDC_EDIT_ALIAS, m_edit_Alias);
    //}}AFX_DATA_MAP
}



LRESULT
CWebWizAlias::OnWizardNext() 
/*++

Routine Description:

    prevent the / and \ characters from being in the alias name

Arguments:

    None

Return Value:

    None

--*/
{
    if (!ValidateString(
        m_edit_Alias, 
        m_pSettings->m_strAlias, 
        1, 
        MAX_ALIAS_NAME
        ))
    {
        return -1;
    }

    //
    // Find the illegal characters. If they exist tell 
    // the user and don't go on.
    //
    if (m_pSettings->m_strAlias.FindOneOf(_T("/\\?*")) >= 0)
    {
		EditShowBalloon(m_edit_Alias.m_hWnd, IDS_ILLEGAL_ALIAS_CHARS);
        //
        // prevent the wizard page from changing
        //
        return -1;
    }

    //
    // Allow the wizard to continue
    //
    return CIISWizardPage::OnWizardNext();
}



void
CWebWizAlias::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Alias.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags);
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizAlias, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizAlias)
    ON_EN_CHANGE(IDC_EDIT_ALIAS, OnChangeEditAlias)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizAlias::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void 
CWebWizAlias::OnChangeEditAlias() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// New Virtual Directory Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizPath, CIISWizardPage)



CWebWizPath::CWebWizPath(
    IN OUT CWebWizSettings * pwsSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE for a VDIR, FALSE for an instance

Return Value:

    None

--*/
    : CIISWizardPage(
        (bVDir ? IDD_WEB_NEW_DIR_PATH : IDD_WEB_NEW_INST_HOME),
        (bVDir ? IDS_WEB_NEW_VDIR_WIZARD : IDS_WEB_NEW_SITE_WIZARD),
        HEADER_PAGE
        ),
      m_pSettings(pwsSettings)
{
#if 0 // Keep ClassWizard happy

    //{{AFX_DATA_INIT(CWebWizPath)
    //}}AFX_DATA_INIT

#endif // 0
}



CWebWizPath::~CWebWizPath()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizPath::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizPath)
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Check(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_pSettings->m_fAllowAnonymous);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_PATH, m_pSettings->m_strPath);
    DDV_MaxCharsBalloon(pDX, m_pSettings->m_strPath, MAX_PATH);
}



void 
CWebWizPath::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Path.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags);
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizPath, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizPath)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnChangeEditPath)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizPath::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



LRESULT 
CWebWizPath::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    CString csPathMunged = m_pSettings->m_strPath;

    if (!ValidateString(m_edit_Path, m_pSettings->m_strPath, 1, MAX_PATH))
    {
        return -1;
    }
    if (!PathIsValid(m_pSettings->m_strPath,TRUE))
    {
        m_edit_Path.SetSel(0,-1);
        m_edit_Path.SetFocus();
		EditShowBalloon(m_edit_Path.m_hWnd, IDS_ERR_BAD_PATH);
		return -1;
    }

    // -------------------------------------------------------------
    // Before we do anything we need to see if it's a "special" path
    //
    // Everything after this function must validate against csPathMunged...
    // this is because IsSpecialPath could have munged it...
    // -------------------------------------------------------------
    csPathMunged = m_pSettings->m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,m_pSettings->m_strPath,csPathMunged);
#endif
    
    m_pSettings->m_fUNC = IsUNCName(csPathMunged);

    DWORD dwAllowed = CHKPATH_ALLOW_DEVICE_PATH;
    dwAllowed |= CHKPATH_ALLOW_UNC_PATH; // allow UNC type dir paths
    dwAllowed |= CHKPATH_ALLOW_UNC_SERVERSHARE_ONLY;
    // don't allow these type of paths commented out below:
    //dwAllowed |= CHKPATH_ALLOW_RELATIVE_PATH;
    //dwAllowed |= CHKPATH_ALLOW_UNC_SERVERNAME_ONLY;
    DWORD dwCharSet = CHKPATH_CHARSET_GENERAL;
    FILERESULT dwValidRet = MyValidatePath(csPathMunged,m_pSettings->m_fLocal,CHKPATH_WANT_DIR,dwAllowed,dwCharSet);
    if (FAILED(dwValidRet))
    {
        int ids = IDS_ERR_BAD_PATH;
        if (dwValidRet == CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST)
        {
            ids = IDS_ERR_PATH_NOT_FOUND;
        }
        m_edit_Path.SetSel(0,-1);
        m_edit_Path.SetFocus();
		EditShowBalloon(m_edit_Path.m_hWnd, IDS_ERR_PATH_NOT_FOUND);
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}

void 
CWebWizPath::OnChangeEditPath() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CWebWizPath * pThis = (CWebWizPath *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CWebWizPath::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void 
CWebWizPath::OnButtonBrowse() 
/*++

Routine Description:

    Handle 'browsing' for directory path -- local system only

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(m_pSettings->m_fLocal);

   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(m_pSettings->m_fNewSite ? 
            IDS_WEB_NEW_SITE_WIZARD : IDS_WEB_NEW_VDIR_WIZARD);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Path.SetWindowText(str);
       SetControlStates();
   }
}




BOOL 
CWebWizPath::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    m_button_Browse.EnableWindow(m_pSettings->m_fLocal);
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),FALSE);
#endif

    return TRUE;  
}



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizUserName, CIISWizardPage)



CWebWizUserName::CWebWizUserName(
    IN OUT CWebWizSettings * pwsSettings,    
    IN BOOL bVDir
    ) 
    : CIISWizardPage(
        CWebWizUserName::IDD,
        (bVDir ? IDS_WEB_NEW_VDIR_WIZARD : IDS_WEB_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_SECURITY_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_SECURITY_SUBTITLE)
        ),
      m_pSettings(pwsSettings)
{
}



CWebWizUserName::~CWebWizUserName()
{
}



void
CWebWizUserName::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizUserName)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_DELEGATION, m_chk_Delegation);
    DDX_Check(pDX, IDC_DELEGATION, m_pSettings->m_fDelegation);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_pSettings->m_strUserName);
    if (pDX->m_bSaveAndValidate && !m_pSettings->m_fDelegation)
    {
        DDV_MaxCharsBalloon(pDX, m_pSettings->m_strUserName, UNLEN);
    }

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_pSettings->m_strUserName.TrimLeft();
    while (*m_pSettings->m_strUserName == '\\')
    {
        m_pSettings->m_strUserName = m_pSettings->m_strUserName.Mid(2);
    }
    if (!m_pSettings->m_fDelegation && !m_fMovingBack)
    {
		DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_pSettings->m_strPassword, g_lpszDummyPassword);
		if (pDX->m_bSaveAndValidate)
		{
			//DDV_MaxCharsBalloon(pDX, m_pSettings->m_strPassword, PWLEN);
            DDV_MaxCharsBalloon_SecuredString(pDX, m_pSettings->m_strPassword, PWLEN);
		}
    }
}



void 
CWebWizUserName::SetControlStates()
{
    DWORD dwFlags = PSWIZB_BACK;
    BOOL bEnable = BST_CHECKED != m_chk_Delegation.GetCheck();
    if (m_edit_UserName.GetWindowTextLength() > 0 || !bEnable)
    {
        dwFlags |= PSWIZB_NEXT;
    }

	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(dwFlags);
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, dwFlags);

    m_edit_UserName.EnableWindow(bEnable);
    m_edit_Password.EnableWindow(bEnable);
    GetDlgItem(IDC_BUTTON_BROWSE_USERS)->EnableWindow(bEnable);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizUserName, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizUserName)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_DELEGATION, OnCheckDelegation)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL 
CWebWizUserName::OnSetActive() 
{
    if (!m_pSettings->m_fUNC)
    {
        return 0;
    }
    BOOL bRes = CIISWizardPage::OnSetActive();
    SetControlStates();
    return bRes;
}



BOOL
CWebWizUserName::OnInitDialog() 
{
    CIISWizardPage::OnInitDialog();

    return TRUE;  
}



LRESULT
CWebWizUserName::OnWizardNext() 
{
	m_fMovingBack = FALSE;
    if (BST_CHECKED != m_chk_Delegation.GetCheck())
    {
        if (!ValidateString(m_edit_UserName, m_pSettings->m_strUserName, 1, UNLEN))
        {
            return -1;
        }
    }    
    return CIISWizardPage::OnWizardNext();
}

LRESULT
CWebWizUserName::OnWizardBack() 
{
	m_fMovingBack = TRUE;
    return CIISWizardPage::OnWizardNext();
}

void
CWebWizUserName::OnButtonBrowseUsers() 
{
    CString str;

    if (GetIUsrAccount(m_pSettings->m_strServerName, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}



void
CWebWizUserName::OnChangeEditUsername() 
{
    m_edit_Password.SetWindowText(_T(""));
    SetControlStates();
}

void
CWebWizUserName::OnCheckDelegation()
{
    SetControlStates();
}

void 
CWebWizUserName::OnButtonCheckPassword() 
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CString csTempPassword = m_pSettings->m_strPassword;
    CError err(CComAuthInfo::VerifyUserPassword(
        m_pSettings->m_strUserName, 
        csTempPassword
        ));

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        DoHelpMessageBox(m_hWnd,IDS_PASSWORD_OK, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
    }
}




//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizPermissions, CIISWizardPage)



CWebWizPermissions::CWebWizPermissions(
    IN OUT CWebWizSettings * pwsSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is a vdir page, 
                                  FALSE for instance

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizPermissions::IDD,
        (bVDir ? IDS_WEB_NEW_VDIR_WIZARD : IDS_WEB_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_PERMS_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_PERMS_SUBTITLE)
        ),
      m_bVDir(bVDir),
      m_pSettings(pwsSettings)
{
    //{{AFX_DATA_INIT(CWebWizPermissions)
    //}}AFX_DATA_INIT

    m_pSettings->m_fDirBrowsing = FALSE;
    m_pSettings->m_fRead = TRUE;
    m_pSettings->m_fScript = TRUE;
    m_pSettings->m_fWrite = FALSE;
    m_pSettings->m_fExecute = FALSE;
}



CWebWizPermissions::~CWebWizPermissions()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



void 
CWebWizPermissions::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizPermissions)
    //}}AFX_DATA_MAP

    DDX_Check(pDX, IDC_CHECK_DIRBROWS, m_pSettings->m_fDirBrowsing);
    DDX_Check(pDX, IDC_CHECK_READ, m_pSettings->m_fRead);
    DDX_Check(pDX, IDC_CHECK_SCRIPT, m_pSettings->m_fScript);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_pSettings->m_fWrite);
    DDX_Check(pDX, IDC_CHECK_EXECUTE, m_pSettings->m_fExecute);
}



void
CWebWizPermissions::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
	// for some reason, bug:206328 happens when we use SetWizardButtons, use SendMessage instead.
	//SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	::SendMessage(::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizPermissions, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizPermissions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizPermissions::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();

    return CIISWizardPage::OnSetActive();
}



LRESULT
CWebWizPermissions::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Complete the wizard

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!UpdateData(TRUE))
    {
        return -1;
    }

    ASSERT(m_pSettings != NULL);

    CWaitCursor wait;

    //
    // Build permissions DWORD
    //
    DWORD dwPermissions = 0L;
    DWORD dwAuthFlags = MD_AUTH_NT;
    DWORD dwDirBrowsing =
        MD_DIRBROW_SHOW_DATE |
        MD_DIRBROW_SHOW_TIME |
        MD_DIRBROW_SHOW_SIZE |
        MD_DIRBROW_SHOW_EXTENSION |
        MD_DIRBROW_LONG_DATE |
        MD_DIRBROW_LOADDEFAULT;

	if (m_pSettings->m_fWrite && m_pSettings->m_fExecute)
	{
		if (IDNO == ::AfxMessageBox(IDS_EXECUTE_AND_WRITE_WARNING, MB_YESNO))
			return -1;
	}
    SET_FLAG_IF(m_pSettings->m_fRead, dwPermissions, MD_ACCESS_READ);
    SET_FLAG_IF(m_pSettings->m_fWrite, dwPermissions, MD_ACCESS_WRITE);
    SET_FLAG_IF(m_pSettings->m_fScript || m_pSettings->m_fExecute,
        dwPermissions, MD_ACCESS_SCRIPT);
    SET_FLAG_IF(m_pSettings->m_fExecute, dwPermissions, MD_ACCESS_EXECUTE);
    SET_FLAG_IF(m_pSettings->m_fDirBrowsing, dwDirBrowsing, MD_DIRBROW_ENABLED);
    SET_FLAG_IF(m_pSettings->m_fAllowAnonymous, dwAuthFlags, MD_AUTH_ANONYMOUS);

    if (m_bVDir)
    {
        //
        // First see if by any chance this name already exists
        //
        CError err;
        BOOL fRepeat;
        CMetabasePath target(FALSE, 
            m_pSettings->m_strParent, m_pSettings->m_strAlias);
        CChildNodeProps node(
            m_pSettings->m_pKey->QueryAuthInfo(),
            target);

        do
        {
            fRepeat = FALSE;

            err = node.LoadData();
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);

        if (err.Succeeded())
        {
            BOOL fNotUnique = TRUE;
            //
            // If the item existed without a VrPath, we'll just blow it
            // away, as a vdir takes presedence over a directory/file.
            //
            if (node.GetPath().IsEmpty())
            {
                err = CChildNodeProps::Delete(
                    m_pSettings->m_pKey,
                    m_pSettings->m_strParent,
                    m_pSettings->m_strAlias
                    );
                fNotUnique = !err.Succeeded();
            }
            //
            // This one already exists and exists as a virtual
            // directory, so away with it.
            //
            if (fNotUnique)
            {
                DoHelpMessageBox(m_hWnd,IDS_ERR_ALIAS_NOT_UNIQUE, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION, 0);
                return IDD_WEB_NEW_DIR_ALIAS;
            }
        }

        //
        // Create new vdir
        //
        do
        {
            fRepeat = FALSE;
            CString csTempPassword;
            m_pSettings->m_strPassword.CopyTo(csTempPassword);
            err = CChildNodeProps::Add(
                m_pSettings->m_pKey,
                m_pSettings->m_strParent,
                m_pSettings->m_strAlias,      // Desired alias name
                m_pSettings->m_strAlias,      // Name returned here (may differ)
                &dwPermissions,                 // Permissions
                &dwDirBrowsing,                 // dir browsing
                m_pSettings->m_strPath,       // Physical path of this directory
                (m_pSettings->m_fUNC && !m_pSettings->m_fDelegation ? 
                    (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC && !m_pSettings->m_fDelegation ? 
                    (LPCTSTR)csTempPassword : NULL),
                TRUE                            // Name must be unique
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(m_pSettings->m_pKey, &fRepeat, ERROR_CANCELLED);
            }
        } while (fRepeat);

        m_pSettings->m_hrResult = err;

        //
        // Create an (in-proc) application on the new directory if
        // script or execute was requested.
        //
        if (SUCCEEDED(m_pSettings->m_hrResult))
        {
            if (m_pSettings->m_fExecute || m_pSettings->m_fScript)
            {
                CMetabasePath app_path(FALSE, 
                    m_pSettings->m_strParent, m_pSettings->m_strAlias);
                CIISApplication app(
                    m_pSettings->m_pKey->QueryAuthInfo(), app_path);
                m_pSettings->m_hrResult = app.QueryResult();

                //
                // This would make no sense...
                //
//                ASSERT(!app.IsEnabledApplication());
        
                if (SUCCEEDED(m_pSettings->m_hrResult))
                {
                    //
                    // Attempt to create a pooled-proc by default;  failing
                    // that if it's not supported, create it in proc
                    //
                    DWORD dwAppProtState = app.SupportsPooledProc()
                        ? CWamInterface::APP_POOLEDPROC
                        : CWamInterface::APP_INPROC;

                    m_pSettings->m_hrResult = app.Create(
                        m_pSettings->m_strAlias, 
                        dwAppProtState
                        );
                }
            }
			if (SUCCEEDED(m_pSettings->m_hrResult))
			{
				if (m_pSettings->m_dwVersionMajor >= 6)
				{
					CMetabasePath path(FALSE, 
						m_pSettings->m_strParent, m_pSettings->m_strAlias);
					CMetaKey mk(m_pSettings->m_pKey, path.QueryMetaPath(), METADATA_PERMISSION_WRITE);
					err = mk.QueryResult();
					m_pSettings->m_hrResult = err;
				}
			}
		}
    }
    else
    {
        //
        // Create new instance
        //
        CError err;
        BOOL fRepeat;

        do
        {
            fRepeat = FALSE;
            CString csTempPassword;
            m_pSettings->m_strPassword.CopyTo(csTempPassword);

            err = CInstanceProps::Add(
                m_pSettings->m_pKey,
                m_pSettings->m_strService,    // Service name
                m_pSettings->m_strPath,       // Physical path of this directory
                (m_pSettings->m_fUNC && !m_pSettings->m_fDelegation ? 
                    (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC && !m_pSettings->m_fDelegation ? 
                    (LPCTSTR)csTempPassword : NULL),
                m_pSettings->m_strDescription,
                m_pSettings->m_strBinding,
                m_pSettings->m_strSecureBinding,
                &dwPermissions,
                &dwDirBrowsing,                 // dir browsing
                &dwAuthFlags,                   // Auth flags
                &m_pSettings->m_dwInstance
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(m_pSettings->m_pKey, &fRepeat, ERROR_CANCELLED);
            }
        } while (fRepeat);

        m_pSettings->m_hrResult = err;

        if (SUCCEEDED(m_pSettings->m_hrResult))
        {
            //
            // Create an (in-proc) application on the new instance's home root
            //
            CMetabasePath app_path(SZ_MBN_WEB, 
                m_pSettings->m_dwInstance,
                SZ_MBN_ROOT);
            CIISApplication app(
                m_pSettings->m_pKey->QueryAuthInfo(), 
                app_path
                );

            m_pSettings->m_hrResult = app.QueryResult();

            //
            // This would make no sense...
            //
//            ASSERT(!app.IsEnabledApplication());
        
            if (SUCCEEDED(m_pSettings->m_hrResult))
            {
                //
                // Create in-proc
                //
                CString strAppName;
                VERIFY(strAppName.LoadString(IDS_DEF_APP));

                //
                // Attempt to create a pooled-proc by default;  failing
                // that if it's not supported, create it in proc
                //
                DWORD dwAppProtState = app.SupportsPooledProc()
                    ? CWamInterface::APP_POOLEDPROC
                    : CWamInterface::APP_INPROC;

                m_pSettings->m_hrResult = app.Create(
                    strAppName, 
                    dwAppProtState
                    );
            }

			if (SUCCEEDED(m_pSettings->m_hrResult))
			{
				// should start it up for iis5 remote admin case
				if (m_pSettings->m_dwVersionMajor >= 5)
				{
					CMetabasePath path(m_pSettings->m_strService, m_pSettings->m_dwInstance);
					// Start new site
					CInstanceProps ip(m_pSettings->m_pKey->QueryAuthInfo(), path);
					err = ip.LoadData();
					if (err.Succeeded())
					{
						if (ip.m_dwState != MD_SERVER_STATE_STARTED)
						{
							m_pSettings->m_hrResult = ip.ChangeState(MD_SERVER_COMMAND_START);
						}
					}
					else
					{
						m_pSettings->m_hrResult = err;
					}
				}
			}
        }
    }
    
    return CIISWizardPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\webaddnew.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        WebAddNew.cpp

   Abstract:
        Classes for new Web site and virtual directory creation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/12/2000       sergeia     Initial creation

--*/

#ifndef _WEB_NEW_WIZARD_H
#define _WEB_NEW_WIZARD_H


class CWebWizSettings : public CObjectPlus
/*++

Class Description:

    Web Wizard settings intended to pass along from page
    to page

--*/
{
//
// Constructor/Destructor
//
public:
    CWebWizSettings(
        IN CMetaKey * pMetaKey,
        IN LPCTSTR lpszServerName,     
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN LPCTSTR lpszParent   = NULL
        );

//
// Public Properties
//
public:
    BOOL    m_fLocal;
    BOOL    m_fUNC;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAllowAnonymous;
    BOOL    m_fDirBrowsing;
    BOOL    m_fScript;
    BOOL    m_fExecute;
    BOOL    m_fNewSite;
    BOOL    m_fDelegation;
    DWORD   m_dwInstance;
	DWORD   m_dwVersionMajor;
	DWORD	m_dwVersionMinor;
    CString m_strService;
    CString m_strParent;
    CString m_strServerName;
    CString m_strDescription;
    CString m_strBinding;
    CString m_strSecureBinding;
    CString m_strAlias;
    CString m_strPath;
    CString m_strUserName;
    CStrPassword m_strPassword;
    HRESULT m_hrResult;
    CMetaKey * m_pKey;
};



//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CWebWizDescription : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizDescription)

//
// Construction
//
public:
    CWebWizDescription(CWebWizSettings * pwsSettings = NULL);
    ~CWebWizDescription();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizDescription)
    enum { IDD = IDD_WEB_NEW_INST_DESCRIPTION };
    CEdit   m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizDescription)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizDescription)
    afx_msg void OnChangeEditDescription();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
};


//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizBindings : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizBindings)

//
// Construction
//
public:
    CWebWizBindings(
        IN CWebWizSettings * pwsSettings = NULL,
        IN DWORD dwInstance = MASTER_INSTANCE
        );

    ~CWebWizBindings();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizBindings)
    enum { IDD = IDD_WEB_NEW_INST_BINDINGS };
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    UINT        m_nSSLPort;
    CString     m_strDomainName;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    BOOL        m_fCertInstalled;
    CIPAddress  m_iaIpAddress;
    CObListPlus m_oblIpAddresses;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizBindings)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizBindings)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
	BOOL m_bNextPage;
    DWORD m_dwInstance;
    CWebWizSettings * m_pSettings;
};



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizAlias : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizAlias)

//
// Construction
//
public:
    CWebWizAlias(CWebWizSettings * pwsSettings = NULL);
    ~CWebWizAlias();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizAlias)
    enum { IDD = IDD_WEB_NEW_DIR_ALIAS };
    CEdit   m_edit_Alias;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizAlias)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizAlias)
    afx_msg void OnChangeEditAlias();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
};



//
// Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizPath : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizPath)

//
// Construction
//
public:
    CWebWizPath(
        IN CWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CWebWizPath();

    int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizPath)
    enum { IDD = -1 };
    CButton m_button_Browse;
    CEdit   m_edit_Path;
    //}}AFX_DATA


//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizPath)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizPath)
    afx_msg void OnChangeEditPath();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
    LPTSTR m_pPathTemp;
    CString m_strBrowseTitle;
};



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CWebWizUserName : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizUserName)

//
// Construction
//
public:
    CWebWizUserName(
        IN CWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CWebWizUserName();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizUserName)
    enum { IDD = IDD_WEB_NEW_USER_PASSWORD };
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    CButton m_chk_Delegation;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizUserName)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    virtual LRESULT OnWizardBack();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizUserName)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnChangeEditUsername();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnCheckDelegation();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
	BOOL m_fMovingBack;
};



//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizPermissions : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizPermissions)

//
// Construction
//
public:
    CWebWizPermissions(
        IN CWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir           = TRUE
        );

    ~CWebWizPermissions();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizPermissions)
    enum { IDD = IDD_WEB_NEW_PERMS };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizPermissions)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizPermissions)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    BOOL m_bVDir;
    CWebWizSettings * m_pSettings;
};

#endif   //_WEB_NEW_WIZARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wdir.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wdir.cpp

   Abstract:
        WWW Directory (non-virtual) Properties Page

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        10/03/2001      sergeia     Created from wvdir.cpp / wfile.cpp
--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wdir.h"
#include "dirbrows.h"
#include "iisobj.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCTSTR CvtPathToDosStyle(CString & strPath);

IMPLEMENT_DYNCREATE(CW3DirPage, CInetPropertyPage)

CW3DirPage::CW3DirPage(CInetPropertySheet * pSheet) 
    : CInetPropertyPage(CW3DirPage::IDD, pSheet, IDS_TAB_DIR),
      //
      // Assign the range of bits in m_dwAccessPermissions that
      // we manage.  This is important, because another page
      // manages other bits, and we don't want to screw up
      // the master value bits when our changes collide (it
      // will mark the original bits as dirty, because we're not
      // notified when the change is made...
      //
      m_dwBitRangePermissions(MD_ACCESS_EXECUTE | 
            MD_ACCESS_SCRIPT | 
            MD_ACCESS_WRITE  | 
            MD_ACCESS_SOURCE |
            MD_ACCESS_READ),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_ENABLED),
      m_pApplication(NULL),
      m_fRecordChanges(TRUE),
      m_fCompatibilityMode(FALSE)
{
	VERIFY(m_strPrompt[RADIO_DIRECTORY].LoadString(IDS_PROMPT_DIR));
	VERIFY(m_strPrompt[RADIO_REDIRECT].LoadString(IDS_PROMPT_REDIRECT));
	VERIFY(m_strRemove.LoadString(IDS_BUTTON_REMOVE));
	VERIFY(m_strCreate.LoadString(IDS_BUTTON_CREATE));
	VERIFY(m_strEnable.LoadString(IDS_BUTTON_ENABLE));
	VERIFY(m_strDisable.LoadString(IDS_BUTTON_DISABLE));
	VERIFY(m_strWebFmt.LoadString(IDS_APPROOT_FMT));
}

CW3DirPage::~CW3DirPage()
{
	SAFE_DELETE(m_pApplication);
}

void 
CW3DirPage::DoDataExchange(CDataExchange * pDX)
{
	CInetPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CW3DirPage)
	//    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
	DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
	DDX_Control(pDX, IDC_RADIO_REDIRECT, m_radio_Redirect);

	DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Check(pDX, IDC_CHECK_AUTHOR, m_fAuthor);
    DDX_Control(pDX, IDC_CHECK_AUTHOR, m_check_Author);
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);    
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Check(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_fBrowsingAllowed);
    DDX_Control(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_check_DirBrowse);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
    DDX_Control(pDX, IDC_CHECK_LOG_ACCESS, m_check_LogAccess);
    DDX_Check(pDX, IDC_CHECK_INDEX, m_fIndexed);
    DDX_Control(pDX, IDC_CHECK_INDEX, m_check_Index);

	DDX_Control(pDX, IDC_EDIT_REDIRECT, m_edit_Redirect);
	DDX_Check(pDX, IDC_CHECK_CHILD, m_fChild);
	DDX_Check(pDX, IDC_CHECK_EXACT, m_fExact);
	DDX_Check(pDX, IDC_CHECK_PERMANENT, m_fPermanent);
	DDX_Control(pDX, IDC_CHECK_CHILD, m_check_Child);

	DDX_Control(pDX, IDC_STATIC_PATH_PROMPT, m_static_PathPrompt);

	DDX_Control(pDX, IDC_BUTTON_UNLOAD_APP, m_button_Unload);
	DDX_Control(pDX, IDC_BUTTON_CREATE_REMOVE_APP, m_button_CreateRemove);
	DDX_Control(pDX, IDC_APP_CONFIGURATION, m_button_Configuration);
	DDX_CBIndex(pDX, IDC_COMBO_PERMISSIONS, m_nPermissions);
	DDX_Control(pDX, IDC_COMBO_PERMISSIONS, m_combo_Permissions);
	DDX_Control(pDX, IDC_STATIC_PROTECTION, m_static_ProtectionPrompt);
	DDX_Control(pDX, IDC_COMBO_PROCESS, m_combo_Process);

	DDX_Control(pDX, IDC_EDIT_APPLICATION, m_edit_AppFriendlyName);
	DDX_Text(pDX, IDC_EDIT_APPLICATION, m_strAppFriendlyName);
	DDV_MinMaxChars(pDX, m_strAppFriendlyName, 0, MAX_PATH); /// ?
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (m_nPathType == RADIO_REDIRECT)
		{
			DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
            DDV_Url(pDX, m_strRedirectPath);
            // We could have only absolute URLs here
			// Nope, we allow relative URL's...
			if (IsRelURLPath(m_strRedirectPath))
			{
			}
			else
			{
				if (!PathIsURL(m_strRedirectPath) || m_strRedirectPath.GetLength() <= lstrlen(_T("http://")))
				{
					DDV_ShowBalloonAndFail(pDX, IDS_BAD_URL_PATH);
				}
			}
			if (m_strRedirectPath.Find(_T(",")) > 0)
			{
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_COMMA_IN_REDIRECT);
			}
		}
		else // Local directory
		{
			m_strRedirectPath.Empty();
		}
		if (!m_fCompatibilityMode)
		{
			// Check what AppPoolID is assigned
			CString str, strSel;
			str.LoadString(IDS_INVALID_POOL_ID);
			int idx = m_combo_Process.GetCurSel();
			ASSERT(idx != CB_ERR);
			m_combo_Process.GetLBText(idx, strSel);
			if (strSel.Compare(str) == 0)
			{
				HWND hWndCtrl = pDX->PrepareCtrl(IDC_COMBO_PROCESS);
                // Force user to input a valid app pool
                // even if the control is diabled!!!
                DDV_ShowBalloonAndFail(pDX, IDS_MUST_SELECT_APP_POOL);
			}
		}
	}
	else
	{
		DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
	}
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DirPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DirPage)
    ON_BN_CLICKED(IDC_CHECK_AUTHOR, OnCheckAuthor)
    ON_BN_CLICKED(IDC_CHECK_READ, OnCheckRead)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnCheckWrite)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_REDIRECT, OnRadioRedirect)

    ON_EN_CHANGE(IDC_EDIT_REDIRECT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_INDEX, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_CHILD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_EXACT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_PERMANENT, OnItemChanged)

    ON_BN_CLICKED(IDC_BUTTON_CREATE_REMOVE_APP, OnButtonCreateRemoveApp)
    ON_BN_CLICKED(IDC_BUTTON_UNLOAD_APP, OnButtonUnloadApp)
    ON_BN_CLICKED(IDC_APP_CONFIGURATION, OnButtonConfiguration)
    ON_CBN_SELCHANGE(IDC_COMBO_PERMISSIONS, OnSelchangeComboPermissions)
    ON_CBN_SELCHANGE(IDC_COMBO_PROCESS, OnSelchangeComboProcess)
    ON_EN_CHANGE(IDC_EDIT_APPLICATION, OnItemChanged)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CW3DirPage::ChangeTypeTo(int nNewType)
{
	int nOldType = m_nPathType;
	m_nPathType = nNewType;

	if (nOldType == m_nPathType)
	{
		return;
	}

	OnItemChanged();
	SetStateByType();

	int nID = -1;
	CEdit * pPath = NULL;
	LPCTSTR lpKeepPath = NULL;

	switch(m_nPathType)
	{
	case RADIO_DIRECTORY:
		break;
	case RADIO_REDIRECT:
		if (!m_strRedirectPath.IsEmpty())
		{
			//
			// The old path info is acceptable, propose it
			// as a default
			//
			lpKeepPath =  m_strRedirectPath;
		}

		nID = IDS_REDIRECT_MASK;
		pPath = &m_edit_Redirect;
		break;
	default:
		ASSERT(FALSE);
		return;
	}

	//
	// Load mask resource, and display
	// this in the directory
	//
	if (pPath != NULL)
	{
		if (lpKeepPath != NULL)
		{
			pPath->SetWindowText(lpKeepPath);
		}
		else
		{
			CString str;
			VERIFY(str.LoadString(nID));
			pPath->SetWindowText(str);
		}
		pPath->SetSel(0,-1);
		pPath->SetFocus();
	}
    SetAuthoringState(FALSE);
}



void 
CW3DirPage::ShowControl(CWnd * pWnd, BOOL fShow)
{
	ASSERT(pWnd != NULL);
	pWnd->EnableWindow(fShow);
	pWnd->ShowWindow(fShow ? SW_SHOW : SW_HIDE);
}

void
CW3DirPage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
	BOOL fShowDirFlags;
	BOOL fShowRedirectFlags;
	BOOL fShowScript;

	switch(m_nPathType)
	{
	case RADIO_DIRECTORY:
		ShowControl(&m_edit_Path, fShowDirFlags = TRUE);
		m_edit_Path.EnableWindow(FALSE);
		ShowControl(&m_edit_Redirect, fShowRedirectFlags = FALSE);
		fShowScript = TRUE;
		break;
    case RADIO_REDIRECT:
        ShowControl(&m_edit_Path, fShowDirFlags = FALSE);
		ShowControl(&m_edit_Redirect, fShowRedirectFlags = TRUE);
        fShowScript = FALSE;
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
        return;
    }

    ShowControl(IDC_CHECK_READ, fShowDirFlags);
    ShowControl(IDC_CHECK_WRITE, fShowDirFlags);
    ShowControl(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, fShowDirFlags);
    ShowControl(IDC_CHECK_INDEX, fShowDirFlags);
    ShowControl(IDC_CHECK_LOG_ACCESS, fShowDirFlags);
    ShowControl(IDC_CHECK_AUTHOR, fShowDirFlags);
    ShowControl(IDC_STATIC_DIRFLAGS_LARGE, fShowDirFlags);
	ShowControl(IDC_STATIC_APPLICATION_SETTINGS, fShowDirFlags);
	ShowControl(IDC_STATIC_APP_PROMPT, fShowDirFlags);
	ShowControl(&m_edit_AppFriendlyName, fShowDirFlags);
	ShowControl(IDC_STATIC_SP_PROMPT, fShowDirFlags);
	ShowControl(IDC_STATIC_PERMISSIONS, fShowDirFlags);
	ShowControl(IDC_COMBO_PERMISSIONS, fShowDirFlags);
	ShowControl(IDC_STATIC_PROTECTION, fShowDirFlags);
	ShowControl(IDC_COMBO_PROCESS, fShowDirFlags);
	ShowControl(IDC_BUTTON_CREATE_REMOVE_APP, fShowDirFlags);
	ShowControl(IDC_APP_CONFIGURATION, fShowDirFlags);
	ShowControl(IDC_BUTTON_UNLOAD_APP, fShowDirFlags);
	ShowControl(IDC_STATIC_STARTING_POINT, fShowDirFlags);
	ShowControl(IDC_STATIC_APPLICATIONS, fShowDirFlags);

	ShowControl(IDC_CHECK_EXACT, fShowRedirectFlags);
	ShowControl(IDC_CHECK_CHILD, fShowRedirectFlags);
	ShowControl(IDC_CHECK_PERMANENT, fShowRedirectFlags);
	ShowControl(IDC_STATIC_REDIRECT_PROMPT, fShowRedirectFlags);
	ShowControl(IDC_STATIC_REDIRFLAGS, fShowRedirectFlags);
	ShowControl(&m_check_Author, fShowScript);

	//
	// Enable/Disable must come after the showcontrols
	//
	m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);

	SetApplicationState();
}



void
CW3DirPage::SaveAuthoringState()
{
	if (m_check_Write.m_hWnd)
	{
		//
		// Controls initialized -- store live data
		//
		m_fOriginalWrite = m_check_Write.GetCheck() > 0;
		m_fOriginalRead = m_check_Read.GetCheck() > 0;
	}
	else
	{
		//
		// Controls not yet initialized, store original data
		//
		m_fOriginalWrite = m_fWrite;
		m_fOriginalRead = m_fRead;
	}
}

void
CW3DirPage::RestoreAuthoringState()
{
	m_fWrite = m_fOriginalWrite;
	m_fRead = m_fOriginalRead;
}

void 
CW3DirPage::SetAuthoringState(BOOL fAlterReadAndWrite)
{
	if (fAlterReadAndWrite)
	{
		if (m_fAuthor)
		{
			//
			// Remember previous setting to undo
			// this thing.
			//
			SaveAuthoringState();
			m_fRead = m_fWrite = TRUE;
		}
		else
		{
			//
			// Restore previous defaults
			//
			RestoreAuthoringState();
		}

		m_check_Read.SetCheck(m_fRead);
		m_check_Write.SetCheck(m_fWrite);
	}

	m_check_Author.EnableWindow((m_fRead || m_fWrite) 
		&& HasAdminAccess() 
		);

	//    m_check_Read.EnableWindow(!m_fAuthor && HasAdminAccess());
	//    m_check_Write.EnableWindow(!m_fAuthor && HasAdminAccess());
}

void 
CW3DirPage::SetPathType()
{
	if (!m_strRedirectPath.IsEmpty())
	{
		m_nPathType = RADIO_REDIRECT;
		m_radio_Dir.SetCheck(0);
		m_radio_Redirect.SetCheck(1);
	}
	else
	{
		m_nPathType = RADIO_DIRECTORY;
		m_radio_Redirect.SetCheck(0);
		m_radio_Dir.SetCheck(1);
	}

	m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DirPage::OnItemChanged()
{
	if (m_fRecordChanges)
	{
		SetModified(TRUE);
	}
}

BOOL 
CW3DirPage::OnInitDialog() 
{
	CInetPropertyPage::OnInitDialog();

	m_fCompatibilityMode = ((CW3Sheet *)GetSheet())->InCompatibilityMode();
	// Disable/hide irrelevant items
	GetDlgItem(IDC_RADIO_UNC)->EnableWindow(FALSE);
	ShowControl(GetDlgItem(IDC_BUTTON_CONNECT_AS), FALSE);
	ShowControl(GetDlgItem(IDC_BUTTON_BROWSE), FALSE);
	ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_SMALL), FALSE);

	// Set appropriate prompt
	CString str;
	VERIFY(str.LoadString(IDS_RADIO_DIR));
	m_radio_Dir.SetWindowText(str);
	//
	// Fill permissions combo box.
	//
	AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_NONE);
	AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_SCRIPT);
	AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_EXECUTE);
	m_combo_Permissions.SetCurSel(m_nPermissions);

	ASSERT(m_pApplication != NULL);

	if (m_fCompatibilityMode)
	{
		m_nSelInProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_INPROC);
		if (m_pApplication->SupportsPooledProc())
		{
			m_nSelPooledProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_POOLEDPROC); 
		}
		else
		{
			m_nSelPooledProc = -1; // N/A
		}
		m_nSelOutOfProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_OUTPROC);
	}
	else
	{
		CString buf;
		buf.LoadString(IDS_APPLICATION_POOL);
		m_static_ProtectionPrompt.SetWindowText(buf);

		CStringListEx pools;
		CError err = ((CW3Sheet *)GetSheet())->EnumAppPools(pools);
		int idx_sel = CB_ERR;
		int idx_def = CB_ERR;
		if (err.Succeeded())
		{
			ASSERT(pools.GetCount() > 0);
			POSITION pos = pools.GetHeadPosition();
			CString pool_id;
			while (pos != NULL)
			{
				pool_id = pools.GetNext(pos);
				int idx = m_combo_Process.AddString(pool_id);
				if (0 == m_pApplication->m_strAppPoolId.CompareNoCase(pool_id))
				{
					idx_sel = idx;
				}
				if (0 == buf.CompareNoCase(pool_id))
				{
					idx_def = idx;
				}
			}
		}
		// select the app pool which has an id the same as in current application
		// It could be new app created in compatibility mode, no app pool is default app pool
		if (CB_ERR == idx_sel)
		{
	       if (m_pApplication->m_strAppPoolId.IsEmpty())
		   {
			   idx_sel = idx_def;
		   }
		   else
		   {
			   CString str;
			   str.LoadString(IDS_INVALID_POOL_ID);
			   m_combo_Process.InsertString(0, str);
			   idx_sel = 0;
		   }
		}
		m_combo_Process.SetCurSel(idx_sel);
	}
	// It is enough to set file alias once -- we cannot change it here
	CString buf1, buf2, strAlias;
	CMetabasePath::GetRootPath(m_strFullMetaPath, buf1, &buf2);
	strAlias = _T("\\");
	strAlias += buf2;
	CvtPathToDosStyle(strAlias);
	m_edit_Path.SetWindowText(strAlias);

	SetPathType();
	SetStateByType();
	SetAuthoringState(FALSE);
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),FALSE);
#endif

	return TRUE;  
}

void
CW3DirPage::OnDestroy()
{
	//int count = m_combo_Process.GetCount();
	//if (count != CB_ERR)
	//{
	//	for (int i = 0; i < count; i++)
	//	{
	//		void * p = m_combo_Process.GetItemDataPtr(i);
	//		LocalFree(p);
	//		m_combo_Process.SetItemDataPtr(i, NULL);
	//	}
	//}
}

/* virtual */
HRESULT
CW3DirPage::FetchLoadedValues()
{
	CError err;

	BEGIN_META_DIR_READ(CW3Sheet)
	//
		// Use m_ notation because the message crackers require it
		//
		BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strFullMetaPath);
        FETCH_DIR_DATA_FROM_SHEET(m_strRedirectPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);
        FETCH_DIR_DATA_FROM_SHEET(m_fIndexed);
        FETCH_DIR_DATA_FROM_SHEET(m_fExact);
        FETCH_DIR_DATA_FROM_SHEET(m_fChild);
        FETCH_DIR_DATA_FROM_SHEET(m_fPermanent);

	m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
	m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
	m_fAuthor = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SOURCE);
	m_fBrowsingAllowed = IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_ENABLED);
	m_fLogAccess = !m_fDontLog;

	SaveAuthoringState();

	if (!m_fIsAppRoot)
	{
		m_dwAppState = APPSTATUS_NOTDEFINED;
	}
	FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
	FETCH_DIR_DATA_FROM_SHEET_PASSWORD(m_strPassword);
	FETCH_DIR_DATA_FROM_SHEET(m_strAlias);

	END_META_DIR_READ(err)

	m_nPermissions = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_EXECUTE)
	? COMBO_EXECUTE : IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SCRIPT)
	? COMBO_SCRIPT : COMBO_NONE;

	BeginWaitCursor();
	m_pApplication = new CIISApplication(QueryAuthInfo(), QueryMetaPath());
	err = m_pApplication != NULL
		? m_pApplication->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

	if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
	{
		//
		// No app information; that's ok in cases of file system directories
		// that don't exist in the metabase yet.
		//
		err.Reset();
	}

	if (err.Succeeded())
	{
		//
		// CODEWORK: RefreshAppState should be split up into two
		// different methods: one that fetches the data, and one
		// that moves the data to the UI controls on this page.
		//
		RefreshAppState();
	}

	EndWaitCursor();

	return err;
}


DWORD 
CW3DirPage::GetAppStateFromComboSelection() const
/*++

Routine Description:

    Get the app state DWORD that coresponds to the current combo
    box list selection

Arguments:

    None

Return Value:

    App state DWORD or 0xffffffff;

--*/
{
	int nSel = m_combo_Process.GetCurSel();

	if (nSel == m_nSelOutOfProc)
	{
		return CWamInterface::APP_OUTOFPROC;
	}

	if (nSel == m_nSelPooledProc)
	{
		ASSERT(m_pApplication->SupportsPooledProc());
		return CWamInterface::APP_POOLEDPROC;
	}

	if (nSel == m_nSelInProc)
	{
		return CWamInterface::APP_INPROC;
	}

	ASSERT(FALSE && "Invalid application state");

	return 0xffffffff;
}


/* virtual */
HRESULT
CW3DirPage::SaveInfo()
{
	ASSERT(IsDirty());

	CError err;

	SET_FLAG_IF(m_fBrowsingAllowed, m_dwDirBrowsing, MD_DIRBROW_ENABLED);
	SET_FLAG_IF(m_fRead, m_dwAccessPerms,   MD_ACCESS_READ);
	SET_FLAG_IF(m_fWrite, m_dwAccessPerms,  MD_ACCESS_WRITE);
	SET_FLAG_IF(m_fAuthor, m_dwAccessPerms, MD_ACCESS_SOURCE);
    SET_FLAG_IF((m_nPermissions == COMBO_EXECUTE), m_dwAccessPerms, MD_ACCESS_EXECUTE);
    //
    // script is set on EXECUTE as well "Execute (including script)"
    //
    SET_FLAG_IF(((m_nPermissions == COMBO_SCRIPT) || (m_nPermissions == COMBO_EXECUTE)), 
        m_dwAccessPerms, MD_ACCESS_SCRIPT);

	BOOL m_fDontLog = !m_fLogAccess;
    BOOL bRedirectDirty = FALSE;

	BeginWaitCursor();

	if (m_fCompatibilityMode)
	{
		DWORD dwAppProtection = GetAppStateFromComboSelection();
		if (dwAppProtection != m_dwAppProtection && m_fAppEnabled)
		{
			//
			// Isolation state has changed; recreate the application
			//
			CError err2(m_pApplication->RefreshAppState());
			if (err2.Succeeded())
			{
				err2 = m_pApplication->Create(m_strAppFriendlyName, dwAppProtection);
				//
				// Remember the new state, so we don't do this again
				// the next time the guy hits "apply"
				//
				if (err2.Succeeded())
				{
					m_dwAppProtection = dwAppProtection;
				}
			}

			err2.MessageBoxOnFailure(m_hWnd);
		}
	}

	BEGIN_META_DIR_WRITE(CW3Sheet)
	INIT_DIR_DATA_MASK(m_dwAccessPerms, m_dwBitRangePermissions)
	INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)

        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_fIndexed)
        STORE_DIR_DATA_ON_SHEET(m_fChild);
        STORE_DIR_DATA_ON_SHEET(m_fExact);
        STORE_DIR_DATA_ON_SHEET(m_fPermanent);
        //
        // CODEWORK: Not an elegant solution
        //
        if (m_nPathType == RADIO_REDIRECT)
        {
			bRedirectDirty = 
				pSheet->GetDirectoryProperties().m_strRedirectPath.CompareNoCase(m_strRedirectPath) != 0;
            pSheet->GetDirectoryProperties().MarkRedirAsInherit(!m_fChild);
            STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
        }
        else
        {
            CString buf = m_strRedirectPath;
            m_strRedirectPath.Empty();
			bRedirectDirty = pSheet->GetDirectoryProperties().m_strRedirectPath.CompareNoCase(m_strRedirectPath) != 0;
            STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
            m_strRedirectPath = buf;
        }

        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
        STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
	END_META_DIR_WRITE(err)

	if (err.Succeeded() && m_pApplication->IsEnabledApplication())
	{
        CString OldFriendlyName;
        OldFriendlyName = m_pApplication->m_strFriendlyName;

		err = m_pApplication->WriteFriendlyName(m_strAppFriendlyName);
		if (!m_fCompatibilityMode)
		{
            INT iRefreshMMCObjects = 0;

			// get app pool id from the combo, 
			// check if it was changed and reassign to application
			// get app pool id from the combo, 
			// check if it was changed and reassign to application
			CString id, idOld;
			int idx = m_combo_Process.GetCurSel();
			ASSERT(idx != CB_ERR);
			m_combo_Process.GetLBText(idx, id);
            idOld = m_pApplication->m_strAppPoolId;
			m_pApplication->WritePoolId(id);

            if (0 != idOld.CompareNoCase(id))
            {
                iRefreshMMCObjects = 1;
            } else if (0 != OldFriendlyName.Compare(m_strAppFriendlyName))
            {
                iRefreshMMCObjects = 2;
            }

            // Refresh the applications node in the MMC...
            if (iRefreshMMCObjects)
            {
                CIISMBNode * pNode = (CIISMBNode *) GetSheet()->GetParameter();
                if (pNode)
                {
                    // this CAppPoolsContainer will only be here if it's iis6
                    CIISMachine * pOwner = pNode->GetOwner();
                    if (pOwner)
                    {
                        CAppPoolsContainer * pPools = pOwner->QueryAppPoolsContainer();
                        if (pPools)
                        {
                            if (pPools->IsExpanded())
                            {
                                pPools->RefreshData();
                                if (1 == iRefreshMMCObjects)
                                {
                                    // refresh the old AppID, because this one needs to be removed
                                    pPools->RefreshDataChildren(idOld,FALSE);
                                    // fresh the new AppID, this one needs to be added
                                    pPools->RefreshDataChildren(id,FALSE);
                                }
                                else
                                {
                                    // friendly name changed
                                    pPools->RefreshDataChildren(id,FALSE);
                                }
                            }
                        }
                    }
                }
            }
		}
	}

	if (err.Succeeded())
	{
		SaveAuthoringState();
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
        NotifyMMC( bRedirectDirty ? PROP_CHANGE_REENUM_FILES //|PROP_CHANGE_REENUM_VDIR
            : PROP_CHANGE_DISPLAY_ONLY);
	}

	EndWaitCursor();

	return err;
}

void
CW3DirPage::RefreshAppState()
{
	ASSERT(m_pApplication != NULL);

	CError err(m_pApplication->RefreshAppState());

	if (err.Failed())
	{
		m_dwAppState = APPSTATUS_NOTDEFINED;    

		if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
		{
			//
			// Ignore this error, it really just means the path 
			// doesn't exist in the metabase, which is true for most
			// file and directory properties, and not an error
			// condition.
			//
			err.Reset();
		}
	}
	else
	{
		m_dwAppState = m_pApplication->QueryAppState();
	}

	if (err.Succeeded())
	{
		//
		// Get metabase information
		//
		m_strAppRoot = m_pApplication->m_strAppRoot;
		m_dwAppProtection = m_pApplication->m_dwProcessProtection;
		m_strAppFriendlyName = m_pApplication->m_strFriendlyName;
		m_fIsAppRoot 
			= (m_strFullMetaPath.CompareNoCase(m_strAppRoot) == 0);
	}
	else
	{
		//
		// Display error information
		//
		err.MessageBoxFormat(m_hWnd, IDS_ERR_APP, MB_OK, NO_HELP_CONTEXT);
	}
}

CString&
CW3DirPage::FriendlyAppRoot(LPCTSTR lpAppRoot, CString& strFriendly)
{
	if (lpAppRoot != NULL && *lpAppRoot != 0)
	{
		strFriendly.Empty();

		CInstanceProps prop(QueryAuthInfo(), lpAppRoot);
		HRESULT hr = prop.LoadData();

		if (SUCCEEDED(hr))
		{
			CString root, tail;
			strFriendly.Format(m_strWebFmt, prop.GetDisplayText(root));
			CMetabasePath::GetRootPath(lpAppRoot, root, &tail);
			if (!tail.IsEmpty())
			{
				//
				// Add rest of dir path
				//
				strFriendly += _T("/");
				strFriendly += tail;
			}

			//
			// Now change forward slashes in the path to backward slashes
			//
			CvtPathToDosStyle(strFriendly);

			return strFriendly;
		}
	}    
	//
	// Bogus
	//    
	VERIFY(strFriendly.LoadString(IDS_APPROOT_UNKNOWN));

	return strFriendly;
}

void
CW3DirPage::SetApplicationState()
{
	//
	// SetWindowText causes a dirty marker
	//
	BOOL fOld = m_fRecordChanges;
	m_fRecordChanges = FALSE;
	m_fAppEnabled = FALSE;
	if (m_pApplication != NULL)
	{
		m_pApplication->RefreshAppState();
		m_fAppEnabled = m_fIsAppRoot && m_pApplication->IsEnabledApplication();
	}
	BOOL fVisible = m_nPathType == RADIO_DIRECTORY;

	m_button_CreateRemove.EnableWindow(fVisible && HasAdminAccess());
	m_button_CreateRemove.SetWindowText(m_fAppEnabled ? m_strRemove : m_strCreate);
	m_static_ProtectionPrompt.EnableWindow(fVisible && m_fAppEnabled && HasAdminAccess());

	if (m_fCompatibilityMode)
	{
		//
		// Set selection in combo box to match current app state
		//
		int nSel = -1;

		switch(m_dwAppProtection)
		{
		case CWamInterface::APP_INPROC:
			nSel = m_nSelInProc;
			break;
		case CWamInterface::APP_POOLEDPROC:
			ASSERT(m_pApplication->SupportsPooledProc());
			nSel = m_nSelPooledProc;
			break;
		case CWamInterface::APP_OUTOFPROC:
			nSel = m_nSelOutOfProc;
			break;
		default:
			ASSERT("Bogus app protection level");
		}

		ASSERT(nSel >= 0);
		m_combo_Process.SetCurSel(nSel);
	}
	else
	{
        // Set selection in combo box to match current app
        CString strOurEntry = m_pApplication->m_strAppPoolId;
        CString strCurrentSelection;
        int idx = m_combo_Process.GetCurSel();
        ASSERT(idx != CB_ERR);
        m_combo_Process.GetLBText(idx, strCurrentSelection);
        if (0 != strOurEntry.CompareNoCase(strCurrentSelection))
        {
            // it's not pointing to our AppPoolID
            // loop thru the combo box to make sure it points to our AppPoolID.
            if ((idx = m_combo_Process.FindString(-1, strOurEntry)) == LB_ERR)
            {
                CString strBadPoolID;
                strBadPoolID.LoadString(IDS_INVALID_POOL_ID);
                if ((idx = m_combo_Process.FindString(-1, strBadPoolID)) == LB_ERR)
                {
                    // could not find this "invalid pool" entry
                    // let's add it and select it.
                    m_combo_Process.InsertString(0, strBadPoolID);
                    idx = 0;
                }
            }
        }
        m_combo_Process.SetCurSel(idx);
	}

	m_combo_Process.EnableWindow(fVisible && m_fAppEnabled && HasAdminAccess());
	GetDlgItem(IDC_STATIC_PERMISSIONS)->EnableWindow(fVisible && HasAdminAccess());
	m_combo_Permissions.EnableWindow(fVisible && HasAdminAccess());
	GetDlgItem(IDC_STATIC_APP_PROMPT)->EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
	m_edit_AppFriendlyName.EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
	m_button_Configuration.EnableWindow(fVisible && m_fAppEnabled);

	//
	// Write out the verbose starting point.  
	//
	CString str;
	FriendlyAppRoot(m_strAppRoot, str);
	CWnd * pWnd = CWnd::FromHandle(GetDlgItem(IDC_STATIC_STARTING_POINT)->m_hWnd);
	FitPathToControl(*pWnd, str, FALSE);

	m_edit_AppFriendlyName.SetWindowText(m_strAppFriendlyName);
	m_button_Unload.EnableWindow(fVisible && m_dwAppState == APPSTATUS_RUNNING);

	//
	// Restore (see note on top)
	//
	m_fRecordChanges = fOld;
}

void
CW3DirPage::OnCheckRead() 
{
	m_fRead = !m_fRead;
	SetAuthoringState(FALSE);
	OnItemChanged();
}

void
CW3DirPage::OnCheckWrite() 
{
	m_fWrite = !m_fWrite;
	if (!CheckWriteAndExecWarning())
	{
		//
		// Undo
		//
		m_fWrite = FALSE;
		m_check_Write.SetCheck(m_fWrite);
	}
	else
	{
		SetAuthoringState(FALSE);
		OnItemChanged();
	}
}

void 
CW3DirPage::OnCheckAuthor() 
{
	m_fAuthor = !m_fAuthor;
	SetAuthoringState(FALSE);
	if (!CheckWriteAndExecWarning())
	{
		//
		// Undo -- set script instead
		//
		m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
	}
	OnItemChanged();
}

void 
CW3DirPage::OnRadioDir() 
{
	ChangeTypeTo(RADIO_DIRECTORY);
}

void 
CW3DirPage::OnRadioRedirect() 
{
	ChangeTypeTo(RADIO_REDIRECT);
}

void 
CW3DirPage::OnButtonCreateRemoveApp() 
{
	BeginWaitCursor();

	CError err(m_pApplication->RefreshAppState());

	if (m_fAppEnabled)
	{
		//
		// App currently exists -- delete it
		//
		err = m_pApplication->Delete();
	}
	else
	{
		CString strAppName = m_strAlias;
		DWORD dwAppProtState = 
			m_pApplication->SupportsPooledProc() ? 
			CWamInterface::APP_POOLEDPROC : CWamInterface::APP_INPROC;

		if (m_fCompatibilityMode)
		{
			//
			// Attempt to create a pooled-proc by default;  failing
			// that if it's not supported, create it in proc
			//
			err = m_pApplication->Create(strAppName, dwAppProtState);
		}
		else
		{
			CString pool;
			err = ((CW3Sheet *)GetSheet())->QueryDefaultPoolId(pool);
			if (err.Succeeded())
			{
				err = m_pApplication->CreatePooled(strAppName, dwAppProtState, pool, FALSE);
			}
		}
	}

	if (err.Succeeded())
	{
		RefreshAppState();
		NotifyMMC(PROP_CHANGE_DISPLAY_ONLY);  
		GetSheet()->NotifyMMC();
	}

	//
	// Move app data to the controls
	//
	UpdateData(FALSE);

	EndWaitCursor();    

	ASSERT(err.Succeeded());
	err.MessageBoxOnFailure(m_hWnd);    
	if (err.Succeeded())
	{
		SetApplicationState();
		// Don't set this because Creating/Removing App
		// already committed the changes...

		// we need to write the KeyType out
		((CW3Sheet *)GetSheet())->SetKeyType();

		// nope, we need this to write the KeyType out
		//OnItemChanged();
	}

    // SetApplicationState will enable/disable
    // a lot of controls, make sure we are on a control
    // that is enabled.  if we are on a control which is not enabled
    // then user will lose ability to use hotkeys.
    if (!::GetFocus())
    {
        m_button_CreateRemove.SetFocus();
    }
}

extern HRESULT
AppConfigSheet(CIISMBNode * pNode, CIISMBNode * pNodeParent, LPCTSTR metapath, CWnd * pParent);

void 
CW3DirPage::OnButtonConfiguration() 
/*++

Routine Description:

    Pass on "configuration" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    CIISMBNode * pTheObject = (CIISMBNode *) GetSheet()->GetParameter();
    if (pTheObject)
    {
        CError err = AppConfigSheet(
            pTheObject,
            pTheObject->GetParentNode(),
            QueryMetaPath(),
            this
            );
    }
}

void 
CW3DirPage::OnSelchangeComboProcess() 
{
	OnItemChanged();
}

void 
CW3DirPage::OnSelchangeComboPermissions() 
{
	m_nPermissions = m_combo_Permissions.GetCurSel();
	ASSERT(m_nPermissions >= COMBO_NONE && m_nPermissions <= COMBO_EXECUTE);

	if (!CheckWriteAndExecWarning())
	{
		//
		// Undo -- set script instead
		//
		m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
	}

	OnItemChanged();
}

void 
CW3DirPage::OnButtonUnloadApp() 
{
}

BOOL
CW3DirPage::CheckWriteAndExecWarning()
{
	if (m_nPermissions == COMBO_EXECUTE && m_fWrite)
	{
		if (::AfxMessageBox(IDS_WRN_WRITE_EXEC, MB_YESNO | MB_DEFBUTTON2 ) != IDYES)
		{
			return FALSE;
		}
	}

	OnItemChanged();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\websvcext.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        websvcext.cpp

   Abstract:
        IIS RestrictionList

   Author:
        Aaron Lee (aaronl)

   Project:
        Internet Services Manager

   Revision History:
        03/19/2002      aaronl     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "util.h"
#include "shts.h"
#include "websvcext_sheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

extern CInetmgrApp theApp;
extern int g_IISMMCInstanceCount;
#if defined(_DEBUG) || DBG
	extern CDebug_IISObject g_Debug_IISObject;
	CDebug_RestrictList g_Debug_RestrictList;
#endif

#define HIDD_WEBSVCEXT_PROHIBIT_ALL   0x101
#define HIDD_WEBSVCEXT_UNKNOWN_ISAPI  0x102
#define HIDD_WEBSVCEXT_UNKNOWN_CGI    0x103

#define WEBSVCEXT_RESULTS_COL_WIDTH_0    20 // icon
#define WEBSVCEXT_RESULTS_COL_WIDTH_1   180 // description
#define WEBSVCEXT_RESULTS_COL_WIDTH_2    70 // status

#define BAD_CHARS_FOR_HTML_PANE     _T("&")

#define WEBSVCEXT_HELP_PATH     _T("::/htm/ca_enabledynamiccontent.htm")

CWebServiceExtensionContainer * g_pCurrentlyDisplayedContainer = NULL;


// ==========================================
CWebServiceExtensionContainer::CWebServiceExtensionContainer(
      CIISMachine * pOwner,
      CIISService * pService
      )
    : CIISMBNode(pOwner, SZ_MBN_WEB),
    m_pWebService(pService),
    m_pResultData(NULL),
    m_dwResultDataCachedSignature(0)
{
   VERIFY(m_bstrDisplayName.LoadString(IDS_WEBSVCEXT_CONTAINER));
   m_strLastResultSelectionID = _T("");
   m_iResultPaneCount = 0;
#if defined(_DEBUG) || DBG
   g_Debug_RestrictList.Init();
#endif
}

CWebServiceExtensionContainer::~CWebServiceExtensionContainer()
{
	m_strLastResultSelectionID = _T("");
	m_iResultPaneCount = 0;

	// Erase all of the extensions that are under us...
	if (!m_WebSvcExtensionList.IsEmpty())
	{
		CWebServiceExtension * pItem = NULL;
		POSITION pos = m_WebSvcExtensionList.GetHeadPosition();
		while (pos)
		{
			pItem = m_WebSvcExtensionList.GetNext(pos);
			if (pItem)
			{
				delete pItem;pItem = NULL;
			}
		}
		m_WebSvcExtensionList.RemoveAll();
	}

#if defined(_DEBUG) || DBG
	// see if we leaked anything
	g_Debug_RestrictList.Dump(TRUE);
#endif
}

HRESULT
CWebServiceExtensionContainer::GetContextHelp(CString& strHtmlPage)
{
    strHtmlPage = WEBSVCEXT_HELP_PATH;
    return S_OK;
}

/* virtual */
void 
CWebServiceExtensionContainer::InitializeChildHeaders(LPHEADERCTRL lpHeader)
{
    CWebServiceExtension::InitializeHeaders(lpHeader);
}

/* virtual */
HRESULT CWebServiceExtensionContainer::ForceReportMode(IResultData * pResult) const
{
    LONG lViewMode = 0;

    if (SUCCEEDED(pResult->GetViewMode(&lViewMode)))
    {
        if (MMCLV_VIEWSTYLE_REPORT != lViewMode)
        {
            // whoops, bad mode.
            // user can only see icon with no description.
            // set it to a better one.
            pResult->SetViewMode(MMCLV_VIEWSTYLE_REPORT);
        }
    }
    return S_OK;
}

/* virtual */
HRESULT
CWebServiceExtensionContainer::GetResultViewType(
    LPOLESTR * lplpViewType,
    long * lpViewOptions
    )
{
	*lplpViewType  = NULL;
	*lpViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    // S_FALSE to use default view type, S_OK indicates the
    // view type is returned in *ppViewType
    return S_OK;
}

HRESULT 
CWebServiceExtensionContainer::SelectResultPaneSelectionID(IResultData * pResultData,CString strSelectionID)
{
    HRESULT hr;
    CIISObject * pItem = NULL;
    CWebServiceExtension * pItemFromMMC = NULL;

    if (!pResultData)
    {
        return E_POINTER;
    }
    
    if (strSelectionID.IsEmpty())
    {
        return S_OK;
    }

    //
    // loop thru all the result items and clean then out.
    //
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_PARAM | RDI_STATE;
    rdi.nIndex = -1; // -1 to start at first item
    do
    {
        rdi.lParam = 0;
        hr = pResultData->GetNextItem(&rdi);
        if (hr != S_OK){break;}
        
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)rdi.lParam;
        ASSERT_PTR(pItem);

        if (IsEqualGUID(* (GUID *) pItem->GetNodeType(),cWebServiceExtension))
        {
            pItemFromMMC = (CWebServiceExtension *)rdi.lParam;

			// Get the ID
            if (pItemFromMMC->QueryContainer() == this)
            {
                if (0 == strSelectionID.CompareNoCase(pItemFromMMC->m_RestrictionUIEntry.strGroupID))
                {
                    pItemFromMMC->UpdateResultItem(pResultData,TRUE);
                }
            }
        }

    } while (SUCCEEDED(hr) && -1 != rdi.nIndex);

	return S_OK;
}

HRESULT 
CWebServiceExtensionContainer::QueryResultPaneSelectionID(IResultData * pResultData,CString &strLastResultSelectionID)
{
    HRESULT hr;
    CIISObject * pItem = NULL;
    CWebServiceExtension * pItemFromMMC = NULL;

    if (!pResultData)
    {
        return E_POINTER;
    }

    //
    // loop thru all the result items and clean then out.
    //
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_PARAM | RDI_STATE;
    rdi.nIndex = -1; // -1 to start at first item
	rdi.nState = LVIS_SELECTED | LVIS_FOCUSED; // only interested in selected items

    do
    {
        rdi.lParam = 0;
        hr = pResultData->GetNextItem(&rdi);
        if (hr != S_OK){break;}
        
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)rdi.lParam;
        ASSERT_PTR(pItem);

        if (IsEqualGUID(* (GUID *) pItem->GetNodeType(),cWebServiceExtension))
        {
            pItemFromMMC = (CWebServiceExtension *)rdi.lParam;

			// Get the ID
			// and return that back.
            if (pItemFromMMC->QueryContainer() == this)
            {
			    strLastResultSelectionID = pItemFromMMC->m_RestrictionUIEntry.strGroupID;
            }
        }

    } while (SUCCEEDED(hr) && -1 != rdi.nIndex);

	return S_OK;
}

/* virtual */ 
HRESULT 
CWebServiceExtensionContainer::EnumerateResultPane(BOOL fExpand, IHeaderCtrl * lpHeader, IResultData * lpResultData, BOOL fForRefresh)
{
    if (lpResultData)
    {
        m_pResultData = lpResultData;

        DWORD * pdwOneDword = (DWORD*) lpResultData;
        m_dwResultDataCachedSignature = *pdwOneDword;
    }
	m_iResultPaneCount = 0;
    BOOL bUseCached = FALSE;

	CError err = CIISObject::EnumerateResultPane(fExpand, lpHeader, lpResultData, fForRefresh);
    if (err.Succeeded())
    {
        if (m_WebSvcExtensionList.IsEmpty())
        {

#if defined(_DEBUG) || DBG
	// see if we leaked anything
	g_Debug_RestrictList.Dump(TRUE);
#endif

            err = EnumerateWebServiceExtensions(&m_WebSvcExtensionList);
        }
        else
        {
            bUseCached = TRUE;
        }
	    if (err.Succeeded())
	    {
            if (fExpand)
            {
				if (bUseCached)
				{
					TRACEEOL(_T("Read from Cache..."));
				}
				else
				{
					TRACEEOL(_T("Read from Metabase (not cache)..."));
				}

                CWebServiceExtension * pItem = NULL;
		        POSITION pos = m_WebSvcExtensionList.GetHeadPosition();
				int iSelectItem = TRUE;
                BOOL bSomethingWasSelected = FALSE;
                void ** ppParam = NULL;
		        while (pos)
		        {
			        pItem = m_WebSvcExtensionList.GetNext(pos);
                    ppParam = (void **) pItem;
                    if (IsValidAddress( (const void*) *ppParam,sizeof(void*),FALSE))
                    {
					    // Select the 1st item in the list...
                        if (!bSomethingWasSelected)
                        {
					        if (!m_strLastResultSelectionID.IsEmpty())
					        {
						        if (0 == pItem->m_RestrictionUIEntry.strGroupID.CompareNoCase(m_strLastResultSelectionID))
						        {
							        iSelectItem = TRUE;
                                    bSomethingWasSelected = TRUE;
						        }
					        }
                        }

					    if (bUseCached)
					    {
						    // then don't addref, since we already did it once...
						    err = pItem->AddToResultPaneSorted(lpResultData,iSelectItem,FALSE);
					    }
					    else
					    {
						    err = pItem->AddToResultPaneSorted(lpResultData,iSelectItem,TRUE);
					    }
                    }

					m_iResultPaneCount++;

					// make sure no other entires are selected.
					iSelectItem = FALSE;
				}

				if (lpResultData)
				{
					lpResultData->ModifyViewStyle(MMC_SHOWSELALWAYS, (MMC_RESULT_VIEW_STYLE)0);
				}

                // if we used the stuff from the Cache,
                // then reload from metabase.  since we'll only have
                // really one entry in this list....(Whatever entry that the user had a property page open on)
                if (bUseCached)
                {
                    this->RefreshData();
                }

                g_pCurrentlyDisplayedContainer = this;
            }
            else
            {
                // user clicked away from this container node...
				// Save whatever the user had selected...
				QueryResultPaneSelectionID(lpResultData,m_strLastResultSelectionID);
				
                if (lpResultData)
                {
                    // Clean everything and cache stuff that's not cleaned.
                    // Cache any entries that were not cleaned.
                    err = CacheResult(lpResultData);
                }

                // User is not selected on this one anymore
                g_pCurrentlyDisplayedContainer = NULL;
            }
	    }

        DisplayError(err);
	    return err;
	}

	return err;
}

HRESULT
CWebServiceExtensionContainer::EnumerateWebServiceExtensions(CExtensionList * pList)
{
	ASSERT(pList != NULL);
    CError err;

	err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST);
    if (err.Succeeded())
    {
        CRestrictionUIList MyMetabaseRestrictionUIList;
        err = LoadMasterUIWithoutOldEntry(QueryInterface(),&MyMetabaseRestrictionUIList,NULL);
	    if (err.Succeeded())
	    {
	        POSITION pos = NULL;
	        CString TheKey;

	        // Loop thru the ui list and display those...
	        CRestrictionUIEntry * pOneEntry = NULL;
	        for(pos = MyMetabaseRestrictionUIList.GetStartPosition();pos != NULL;)
	        {
	            MyMetabaseRestrictionUIList.GetNextAssoc(pos, TheKey, (CRestrictionUIEntry *&) pOneEntry);
	            if (pOneEntry)
	            {
				    CWebServiceExtension * pItem = NULL;

	                // creating this CWebServiceExtension makes a copy
	                // of the data in pOneEntry. so after we're done
	                // make sure to delete the MyMetabaseRestrictionUIList list
	                // and all it's objects...
	                if (NULL == (pItem = new CWebServiceExtension(m_pOwner, pOneEntry, m_pWebService)))
				    {
					    err = ERROR_NOT_ENOUGH_MEMORY;
					    break;
				    }
				    pList->AddTail(pItem);
	            }
	        }
   		    // delete the list and delete all it's objects too.
   		    CleanRestrictionUIList(&MyMetabaseRestrictionUIList);
		}
    }
	return err;
}

/* virtual */
HRESULT
CWebServiceExtensionContainer::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr))
    {
        ASSERT(pInsertionAllowed != NULL);
        if (IsAdministrator())
        {
            if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
            {
                AddMenuSeparator(lpContextMenuCallback);
                AddMenuItemByCommand(lpContextMenuCallback, IDM_WEBEXT_CONTAINER_ADD1);
                AddMenuItemByCommand(lpContextMenuCallback, IDM_WEBEXT_CONTAINER_ADD2);
                AddMenuSeparator(lpContextMenuCallback);
                AddMenuItemByCommand(lpContextMenuCallback, IDM_WEBEXT_CONTAINER_PROHIBIT_ALL);
            }
        }
    }

    return hr;
}

/* virtual */
LPOLESTR 
CWebServiceExtensionContainer::GetResultPaneColInfo(int nCol)
{
    if (nCol == 0)
    {
        return QueryDisplayName();
    }
    return OLESTR("");
}

HRESULT
CWebServiceExtensionContainer::Command(
    long lCommandID,
    CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type
    )
{
    HRESULT hr = S_OK;
    IConsole * pConsole = (IConsole *)GetConsole();

    switch (lCommandID)
    {
    case IDM_WEBEXT_CONTAINER_ADD1:
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());
			CError err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST);
			if (err.Succeeded())
			{
				CRestrictionUIEntry * pNewEntry = NULL;

				// ensure the dialog gets themed
				CThemeContextActivator activator(theApp.GetFusionInitHandle());
				if (TRUE == StartAddNewDialog(GetMainWindow(pConsole),QueryInterface(),IsLocal(),&pNewEntry))
				{
					// Update the UI
					if (pNewEntry)
					{
						InsertNewExtension(pNewEntry);
						// InsertNewExtension will call RefreshData()
						// so we don't have to do it out here...
						// refresh after insertion...
						//if (SUCCEEDED(RefreshData())){RefreshDisplay();}
					}
				}
			}
        }
        break;
    case IDM_WEBEXT_CONTAINER_ADD2:
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());
			CError err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST);
			if (err.Succeeded())
			{
				// ensure the dialog gets themed
				CThemeContextActivator activator(theApp.GetFusionInitHandle());
				if (TRUE == StartAddNewByAppDialog(GetMainWindow(pConsole),QueryInterface(),IsLocal()))
				{
					// refresh all of the UI..
					if (SUCCEEDED(RefreshData()))
					{
						RefreshDisplay();
					}
				}
			}
        }
        break;
    case IDM_WEBEXT_CONTAINER_PROHIBIT_ALL:
        {
			CError err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST);
			if (err.Succeeded())
			{
				CComBSTR strMsg;
				strMsg.LoadString(IDS_PROHIBIT_ALL_EXTENSIONS_MSG);

				UINT iHelpID = HIDD_WEBSVCEXT_PROHIBIT_ALL;
				if (IDYES == DoHelpMessageBox(NULL,strMsg,MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 | MB_HELP, iHelpID))
				{
					hr = ChangeStateOfEntry(QueryInterface(),WEBSVCEXT_STATUS_PROHIBITED,NULL);
					if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
					{
						if (SUCCEEDED(hr = RefreshData()))
						{
							RefreshDisplay();
						}
					}
				}
			}
        }
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}

HRESULT
CWebServiceExtensionContainer::CacheResult(IResultData * pResultData)
{
    HRESULT hr;
    CIISObject * pItem = NULL;
    CWebServiceExtension * pItemFromMMC = NULL;
    CExtensionList MyDeleteList;

    if (!pResultData)
    {
        return E_POINTER;
    }

    m_WebSvcExtensionList.RemoveAll();
    m_iResultPaneCount=0;

    // Loop thru all the result items and add it to our
    // List of extensions....

    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_PARAM | RDI_STATE;
    rdi.nIndex = -1; // -1 to start at first item
    do
    {
        rdi.lParam = 0;
        hr = pResultData->GetNextItem(&rdi);
        if (hr != S_OK){break;}
        
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)rdi.lParam;
        ASSERT_PTR(pItem);

        if (pItem)
        {
            if (IsEqualGUID(* (GUID *) pItem->GetNodeType(),cWebServiceExtension))
            {
                pItemFromMMC = (CWebServiceExtension *)rdi.lParam;

                // Check if it points to this container!
                if (pItemFromMMC->QueryContainer() == this)
                {
					// add it to our "cache" list if it has a property window open
					m_WebSvcExtensionList.AddTail(pItemFromMMC);
					m_iResultPaneCount++;
                }
            }
        }

    } while (SUCCEEDED(hr) && -1 != rdi.nIndex);

    // loop thru the list of objects
    // that we need to delete
    if (!MyDeleteList.IsEmpty())
    {
        POSITION pos = MyDeleteList.GetHeadPosition();
	    while (pos)
	    {
		    pItemFromMMC = MyDeleteList.GetNext(pos);
            if (pItemFromMMC)
            {
                // remove it from the UI
				if (FAILED(pItemFromMMC->FindMyResultItem(pResultData,TRUE)))
				{
					pResultData->DeleteItem(pItemFromMMC->QueryResultItem(), 0);
				}
               
                // clean data
                CleanRestrictionUIEntry(&pItemFromMMC->m_RestrictionUIEntry);

				// mark it for deletion.
				pItemFromMMC->m_fFlaggedForDeletion = TRUE;
				
                // delete the object
				// Don't delete the result item if another window has it open!
				// (if there are other console's open
				// then they are also displaying these result objects
				// don't delete these objects if there are other consoles open...)
				if (g_IISMMCInstanceCount <= 1)
				{
					pItemFromMMC->Release();
				}
            }
        }
    }

	return S_OK;
}

/*virtual*/
HRESULT
CWebServiceExtensionContainer::CleanResult(IResultData * pResultData)
{
    HRESULT hr;
    CIISObject * pItem = NULL;
    CWebServiceExtension * pItemFromMMC = NULL;
    CExtensionList MyDeleteList;

    if (!pResultData)
    {
        return E_POINTER;
    }

	// only cleanresults if 
	// there is only 1 instance of the console
	//if (g_IISMMCInstanceCount > 1){return S_OK;}

    // Clean our Cached list of objects...
    m_WebSvcExtensionList.RemoveAll();
	m_iResultPaneCount=0;

    //
    // loop thru all the result items and clean them out.
    //
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_PARAM | RDI_STATE;
    rdi.nIndex = -1; // -1 to start at first item
    do
    {
        rdi.lParam = 0;
        hr = pResultData->GetNextItem(&rdi);
        if (hr != S_OK){break;}
        
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)rdi.lParam;
        ASSERT_PTR(pItem);

        if (IsEqualGUID(* (GUID *) pItem->GetNodeType(),cWebServiceExtension))
        {
            pItemFromMMC = (CWebServiceExtension *)rdi.lParam;

            // delete the object by adding it to the delete list
            // so that we can delete them later
            //
            // we can't delete items from the result pane while we enum thru the result pane
            // things will be messed up in the result pane list....
            // and you will end up only deleteing half of what you wanted to delete!

            // Only delete an item if there is no property page open on it!
            if (pItemFromMMC->QueryContainer() == this)
            {
                if (pItemFromMMC->IsMyPropertySheetOpen())
                {
					// add it to our "cache" list if it has a property window open
					m_WebSvcExtensionList.AddTail(pItemFromMMC);
					m_iResultPaneCount++;
                }
				else
				{
					MyDeleteList.AddTail(pItemFromMMC);
				}
            }
        }

    } while (SUCCEEDED(hr) && -1 != rdi.nIndex);

    // loop thru the list of objects
    // that we need to delete
    POSITION pos = MyDeleteList.GetHeadPosition();
	while (pos)
	{
		pItemFromMMC = MyDeleteList.GetNext(pos);
        if (pItemFromMMC)
        {
            // remove it from the UI
			if (FAILED(pItemFromMMC->FindMyResultItem(pResultData,TRUE)))
			{
				pResultData->DeleteItem(pItemFromMMC->QueryResultItem(), 0);
			}

            // clean data
            CleanRestrictionUIEntry(&pItemFromMMC->m_RestrictionUIEntry);

			// mark it for deletion.
			pItemFromMMC->m_fFlaggedForDeletion = TRUE;

            // delete the object
			// Don't delete the result item if another window has it open!
			// (if there are other console's open
			// then they are also displaying these result objects
			// don't delete these objects if there are other consoles open...)
			if (g_IISMMCInstanceCount <= 1)
			{
				pItemFromMMC->Release();
			}
        }
    }

    // don't do this since we could be cleaning out
    // other result items which we don't own
    //pResultData->DeleteAllRsltItems();

	return S_OK;
}

HRESULT
CWebServiceExtensionContainer::InsertNewExtension(CRestrictionUIEntry * pNewEntry)
{
    CError err;

    IConsole * pConsole = (IConsole *)GetConsole();

	CString strNewEntryID;
	if (-1 == pNewEntry->strGroupID.Find(EMPTY_GROUPID_KEY))
	{
		m_strLastResultSelectionID = EMPTY_GROUPID_KEY + pNewEntry->strGroupID;
		strNewEntryID = EMPTY_GROUPID_KEY + pNewEntry->strGroupID;
	}
	else
	{
		m_strLastResultSelectionID = pNewEntry->strGroupID;
		strNewEntryID = pNewEntry->strGroupID;
	}

    if (!IsExpanded() || NULL == g_pCurrentlyDisplayedContainer)
    {
        // make sure we are select first.
        if (NULL != QueryScopeItem())
        {
            pConsole->SelectScopeItem(QueryScopeItem());
        }

        // the above code will read the newly created item from the metabase
        // we just need to find it now, and highlight it
        SelectResultPaneSelectionID(m_pResultData,strNewEntryID);

		if (SUCCEEDED(RefreshData())){RefreshDisplay();}
    }
    else
    {
        // insertion code can only be used 
        // for the currently selected container
        // warning: you might be able to add remote computer items
        // into the local result view, if you don't check this
        if (this == g_pCurrentlyDisplayedContainer)
        {
			if (SUCCEEDED(RefreshData())){RefreshDisplay();}
			// Select the new entry...
			SelectResultPaneSelectionID(m_pResultData,strNewEntryID);

			// don't do all of this code below...
			// since it will add a new entry to the results pane...
			// however if we refresh, it could have a possibility to have duplicates...
/*
			// Insert and select this new entry
	        CWebServiceExtension * pItem = new CWebServiceExtension(m_pOwner, this, pNewEntry, m_pWebService);
	        if (pItem != NULL)
	        {
                // don't call RefreshData, uless you want 2 of these new entries in the list...
		        //err = pItem->RefreshData();
		        if (err.Succeeded())
		        {
                    // Get the pointer to ResultData from when we did the Enum
                    err = pItem->AddToResultPaneSorted(m_pResultData,TRUE);
		        }
	        }
	        else
	        {
		        err = ERROR_NOT_ENOUGH_MEMORY;
	        }
*/
        }
    }
    return err;
}

/*virtual*/
HRESULT
CWebServiceExtensionContainer::RefreshData()
{
    CError err;
    IResultData *pResultData = NULL;
    pResultData = m_pResultData;

    if (!pResultData)
    {
        return S_OK;
    }

    // Check validity of the IResultData Pointer!
    if (m_dwResultDataCachedSignature)
    {
        DWORD * pdwOneDword = (DWORD*) pResultData;
        if (pdwOneDword)
        {
            if (m_dwResultDataCachedSignature != *pdwOneDword)
            {
                TRACEEOLID("Bad Signature:" << m_dwResultDataCachedSignature << " != " << *pdwOneDword);
                // This is an invalid signature!
                return S_OK;
            }
        }
    }

	err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST);
    if (err.Succeeded())
    {
        HRESULT hr = E_FAIL;
		POSITION pos = NULL;
        CIISObject * pItem = NULL;
        CWebServiceExtension * pItemFromMMC = NULL;
            
        CRestrictionUIList MyMetabaseRestrictionUIList;
        CRestrictionUIList MyPrunedList;
        CExtensionList MyDeleteList;

        BOOL bProceed = FALSE;
        BOOL bAddToRunningList = FALSE;

        // Sync the stuff in our results list
        // with the items that are in the metabase
        // ----------------------------------------------------------
        // 1st pass -- loop thru all the stuff in our list
        //             and make sure they have all the most
        //             updated info.  removing same entry from metabase list.
        //             if entry is in UI but not in metabase, then
        //             remove the metabase entry.
        // 2nd pass -- loop thru the left over metabase list entries.
        //             these are metabase items which are not in the UI.
        // ----------------------------------------------------------

        // Get the stuff from the metabase
        err = LoadMasterUIWithoutOldEntry(QueryInterface(),&MyMetabaseRestrictionUIList,NULL);
        if (err.Failed())
        {
            goto CWebServiceExtensionContainer_RefreshData_Exit;
        }

        // ==============================
        // 1st pass
        // Loop through the result list
        // ==============================
        bProceed = FALSE;

        RESULTDATAITEM rdi;
        ZeroMemory(&rdi, sizeof(rdi));

        rdi.mask = RDI_PARAM | RDI_STATE;
        rdi.nIndex = -1; // -1 to start at first item
        //rdi.nState = LVIS_SELECTED; // only interested in selected items
        
        do
        {
            bAddToRunningList = FALSE;
            rdi.lParam = 0;

            // this could AV right here if pResultData is invalid
            hr = pResultData->GetNextItem(&rdi);
            if (hr != S_OK)
            {
                break;
            }

            //
            // The cookie is really the IISObject, which is what we stuff 
            // in the lparam.
            //
            pItem = (CIISObject *)rdi.lParam;
            ASSERT_PTR(pItem);

            if (IsEqualGUID(* (GUID *) pItem->GetNodeType(),cWebServiceExtension))
            {
                pItemFromMMC = (CWebServiceExtension *)rdi.lParam;

                // check if it's for this container!
                if (pItemFromMMC->QueryContainer() == this)
                {
                    // check if our item is in the metabase list
                    // if it is then update it, if not then delete it
                    int iRet = UpdateItemFromItemInList(&pItemFromMMC->m_RestrictionUIEntry,&MyMetabaseRestrictionUIList);
                    if (0 == iRet)
                    {
                        // no change
                        bAddToRunningList = TRUE;
                    }
                    else if (2 == iRet)
                    {
                        // This means that the item was not in the list
                        // so let's delete it, or mark it for deletion
                        // seem like we can't delete this item from within this loop
                        // so let's add it to a list of items to be deleted
                        MyDeleteList.AddTail(pItemFromMMC);
                        bAddToRunningList = FALSE;
                    }
                    else
                    {
                        // the item was updated...
                        // so let's delete it from the Metabase List
                        DeleteItemFromList(&pItemFromMMC->m_RestrictionUIEntry,&MyMetabaseRestrictionUIList);
                        bAddToRunningList = TRUE;
                    }

                    bProceed = TRUE;
                }
            }

            if (bAddToRunningList)
            {
                // add this RestrictionUI item to our running
                // list of UI items that are in the UI
				AddRestrictUIEntryToRestrictUIList(&MyPrunedList,&pItemFromMMC->m_RestrictionUIEntry);

                // update the result panes icon,description,status...
				pItemFromMMC->UpdateResultItem(pResultData,FALSE);
            }

            //
            // Advance to next child of same parent
            //
        } while (SUCCEEDED(hr) && -1 != rdi.nIndex);


        // ==============================
        // 2nd pass
        // Loop through the metabase list
        // ==============================
        if (bProceed)
        {
			CRestrictionUIEntry * pOneEntry = NULL;
			CString strKey;
			CString strKey2;

            for(pos = MyMetabaseRestrictionUIList.GetStartPosition();pos != NULL;)
            {
                MyMetabaseRestrictionUIList.GetNextAssoc(pos, strKey2, (CRestrictionUIEntry *&) pOneEntry);
                if (pOneEntry)
                {
                    // see if this entry exists in the UI list
                    CRestrictionUIEntry * pItemExists = NULL;
					// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
					strKey=pOneEntry->strGroupID;strKey.MakeUpper();

                    MyPrunedList.Lookup(strKey,pItemExists);
                    if (!pItemExists)
                    {
                        // we expected that it would not be in the UI list
                        // so let's create a new entry and add it.
			            CWebServiceExtension * pNewExtension = NULL;
                        if (NULL == (pNewExtension = new CWebServiceExtension(m_pOwner, pOneEntry, m_pWebService)))
			            {
				            err = ERROR_NOT_ENOUGH_MEMORY;
				            break;
			            }
                        else
                        {
                            //add to results pane
                            err = pNewExtension->AddToResultPaneSorted(pResultData,TRUE);
                        }
                    }
                }
            }

            // this one just points to entries that are still existing
            // so just erase this list
            MyPrunedList.RemoveAll();
        }

        // this one needs to be erased -- the list and all of it's data items...
        CleanRestrictionUIList(&MyMetabaseRestrictionUIList);

        // Loop thru the saved list of mmc entries
        // we are supposed to delete, and remove them
        pItemFromMMC = NULL;
        pos = MyDeleteList.GetHeadPosition();
		BOOL bDeletedSomethingThatWasSelected = FALSE;
		while (pos)
		{
			pItemFromMMC = MyDeleteList.GetNext(pos);
            if (pItemFromMMC)
            {
				// check if this item is currently selected!
				ZeroMemory(&rdi, sizeof(rdi));
				rdi.mask = RDI_STATE;
				rdi.itemID = pItemFromMMC->QueryResultItem();
				if (SUCCEEDED(pResultData->GetItem(&rdi)))
				{
					if (rdi.nState & LVIS_SELECTED)
					{
						bDeletedSomethingThatWasSelected = TRUE;
					}
				}

				// mark it as going to be deleted
				pItemFromMMC->m_fFlaggedForDeletion = TRUE;
				// remove from results pane!
				if (FAILED(pItemFromMMC->FindMyResultItem(pResultData,TRUE)))
				{
					pResultData->DeleteItem(pItemFromMMC->QueryResultItem(), 0);
				}
            }
        }

		if (bDeletedSomethingThatWasSelected)
		{
			// select something else (i guess we'll select the 1st item)
			pResultData->ModifyItemState(0,0,LVIS_SELECTED | LVIS_FOCUSED,0);
		}
    }

CWebServiceExtensionContainer_RefreshData_Exit:
    return err;
}

////////////////////////////////////////////////////////////////////////////////
// CWebServiceExtension implementation
//
// Result View definition
//
/* static */ 
int 
CWebServiceExtension::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_ICON,
    IDS_RESULT_SERVICE_WEBSVCEXT,
    IDS_RESULT_STATUS
};
    

/* static */ 
int 
CWebServiceExtension::_rgnWidths[COL_TOTAL] =
{
    WEBSVCEXT_RESULTS_COL_WIDTH_0,
    WEBSVCEXT_RESULTS_COL_WIDTH_1,
    WEBSVCEXT_RESULTS_COL_WIDTH_2
};

/* static */ CComBSTR CWebServiceExtension::_bstrStatusAllowed;
/* static */ CComBSTR CWebServiceExtension::_bstrStatusProhibited;
/* static */ CComBSTR CWebServiceExtension::_bstrStatusCustom;
/* static */ CComBSTR CWebServiceExtension::_bstrStatusInUse;
/* static */ CComBSTR CWebServiceExtension::_bstrStatusNotInUse;
/* static */ CString CWebServiceExtension::_bstrMenuAllowOn;
/* static */ CString CWebServiceExtension::_bstrMenuAllowOff;
/* static */ CString CWebServiceExtension::_bstrMenuProhibitOn;
/* static */ CString CWebServiceExtension::_bstrMenuProhibitOff;
/* static */ CString CWebServiceExtension::_bstrMenuPropertiesOn;
/* static */ CString CWebServiceExtension::_bstrMenuPropertiesOff;
/* static */ CString CWebServiceExtension::_bstrMenuTasks;
/* static */ CString CWebServiceExtension::_bstrMenuTask1;
/* static */ CString CWebServiceExtension::_bstrMenuTask2;
/* static */ CString CWebServiceExtension::_bstrMenuTask3;
/* static */ CString CWebServiceExtension::_bstrMenuTask4;
/* static */ CString CWebServiceExtension::_bstrMenuIconBullet;
/* static */ CString CWebServiceExtension::_bstrMenuIconHelp;
/* static */ BOOL     CWebServiceExtension::_fStaticsLoaded = FALSE;
/* static */ BOOL     CWebServiceExtension::_fStaticsLoaded2 = FALSE;

CWebServiceExtension::CWebServiceExtension(
      CIISMachine * pOwner,
      CRestrictionUIEntry * pRestrictionUIEntry,
      CIISService * pService
      )
    : CIISMBNode(pOwner, SZ_MBN_WEB),
    m_pWebService(pService)
{
      m_hwnd = 0;
	  m_fFlaggedForDeletion = FALSE;
      RestrictionUIEntryCopy(&m_RestrictionUIEntry,pRestrictionUIEntry);
}

CWebServiceExtension::~CWebServiceExtension()
{
    // Delete all objects associated with this object..
    CleanRestrictionUIEntry(&m_RestrictionUIEntry);
}

HRESULT
CWebServiceExtension::GetContextHelp(CString& strHtmlPage)
{
    strHtmlPage = WEBSVCEXT_HELP_PATH;
    return S_OK;
}


/* static */
void
CWebServiceExtension::InitializeHeaders(LPHEADERCTRL lpHeader)
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
    if (!_fStaticsLoaded)
    {
        _fStaticsLoaded =
            _bstrStatusAllowed.LoadString(IDS_ALLOWED)  &&
            _bstrStatusProhibited.LoadString(IDS_PROHIBITED)  &&
            _bstrStatusCustom.LoadString(IDS_CUSTOM)  &&
            _bstrStatusInUse.LoadString(IDS_INUSE) &&
            _bstrStatusNotInUse.LoadString(IDS_NOTINUSE);
    }
}

/* virtual */
void 
CWebServiceExtension::InitializeChildHeaders(LPHEADERCTRL lpHeader)
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
}

/* virtual */
HRESULT
CWebServiceExtension::GetResultViewType(
    LPOLESTR * lplpViewType,
    long * lpViewOptions
    )
{
	*lplpViewType  = NULL;
	*lpViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    // S_FALSE to use default view type, S_OK indicates the
    // view type is returned in *ppViewType
    return S_OK;
}

/* virtual */
HRESULT
CWebServiceExtension::BuildMetaPath(CComBSTR & bstrPath) const
{
    HRESULT hr = S_OK;
    ASSERT(m_pWebService != NULL);
    hr = m_pWebService->BuildMetaPath(bstrPath);
    return hr;
}

/*virtual*/
BOOL CWebServiceExtension::IsConfigurable() const
{
    // is not configurable if it's one of the "special ones...
    if (WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI == m_RestrictionUIEntry.iType || WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI == m_RestrictionUIEntry.iType)
    {
        return FALSE;
    }
    else
    {
        // WEBSVCEXT_TYPE_REGULAR
        // WEBSVCEXT_TYPE_FILENAME_EXTENSIONS_FILTER
        return TRUE;
    }
}

/*virtual*/
BOOL
CWebServiceExtension::IsDeletable() const
{
    BOOL bRet = FALSE;

    // if there is a property dialog
    // open on this item, then don't let them
    // delete the item.

    // Don't hide the option to delete
    // this confuses users and
    // also it won't always be hidden.
    // kind of wacky, so just show it always
    // and pop an error if they try to delete it.
    //if (IsMyPropertySheetOpen()){return FALSE;}

    // loop thru the list to see if anyone of the entries
    // is not deleteable -- if it's not deletable...
    // then the whole thing is not deletable
    CString TheKey;
    POSITION pos = NULL;
    CRestrictionEntry * pOneEntry = NULL;
    for(pos = m_RestrictionUIEntry.strlstRestrictionEntries.GetStartPosition();pos != NULL;)
    {
        m_RestrictionUIEntry.strlstRestrictionEntries.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            if (WEBSVCEXT_TYPE_REGULAR == pOneEntry->iType)
            {
                if (0 != pOneEntry->iDeletable)
                {
                    bRet = TRUE;
                    goto CWebServiceExtension_IsDeletable_Exit;
                }
            }
        }
    }

CWebServiceExtension_IsDeletable_Exit:
    return bRet;
}

/* virtual */
LPOLESTR 
CWebServiceExtension::GetResultPaneColInfo(
    IN int nCol
    )
{
    switch(nCol)
    {
    case COL_ICON:
        return _T("");

    case COL_WEBSVCEXT:
        return QueryDisplayName();

    case COL_STATUS:
        {
            switch(GetState())
                {
                case WEBSVCEXT_STATUS_ALLOWED:
                    return _bstrStatusAllowed;
                case WEBSVCEXT_STATUS_PROHIBITED:
                    return _bstrStatusProhibited;
                case WEBSVCEXT_STATUS_CUSTOM:
                    return _bstrStatusCustom;
                case WEBSVCEXT_STATUS_INUSE:
                    return _bstrStatusInUse;
                case WEBSVCEXT_STATUS_NOTINUSE:
                    return _bstrStatusNotInUse;
		        default:
			        return OLESTR("");
                }
        }
    }
    ASSERT_MSG("Bad column number");
    return OLESTR("");
}

/* virtual */
LPOLESTR 
CWebServiceExtension::QueryDisplayName()
{
    if (m_RestrictionUIEntry.strGroupDescription.IsEmpty())
    {
        // no need to call refresh for this.
		//RefreshData();

        m_RestrictionUIEntry.strGroupDescription = QueryNodeName();
    }        

    return (LPTSTR)(LPCTSTR)m_RestrictionUIEntry.strGroupDescription;
}

/* virtual */
int
CWebServiceExtension::QueryImage() const
{
    // Check if it's one of our "special ones"
    switch(GetState())
    {
        case WEBSVCEXT_STATUS_ALLOWED:
            if (WEBSVCEXT_TYPE_REGULAR != m_RestrictionUIEntry.iType)
            {
				// should be an icon that is emphasized for
				// the "allowed" mode -- since that is dangerous
                return iWebSvcFilterPlus;
            }
            else
            {
                return iWebSvcGearPlus;
            }
        case WEBSVCEXT_STATUS_PROHIBITED:
            if (WEBSVCEXT_TYPE_REGULAR != m_RestrictionUIEntry.iType)
            {
                return iWebSvcFilter;
            }
            else
            {
                return iWebSvcGear;
            }
        case WEBSVCEXT_STATUS_CUSTOM:
            if (WEBSVCEXT_TYPE_REGULAR != m_RestrictionUIEntry.iType)
            {
                return iWebSvcFilterPlus;
            }
            else
            {
                return iWebSvcGearPlus;
            }
        case WEBSVCEXT_STATUS_INUSE:
            return iWebSvcGear;
        case WEBSVCEXT_STATUS_NOTINUSE:
            return iWebSvcGear;
		default:
			return iWebSvcGear;
    }

    return iWebSvcGear;
}

int
CWebServiceExtension::QueryImageForPropertyPage() const
{
    switch(GetState())
    {
        case WEBSVCEXT_STATUS_ALLOWED:
        case WEBSVCEXT_STATUS_PROHIBITED:
        case WEBSVCEXT_STATUS_CUSTOM:
            if (WEBSVCEXT_TYPE_REGULAR != m_RestrictionUIEntry.iType)
            {
                return iWebSvcFilter;
            }
            else
            {
                return iWebSvcGear;
            }
        case WEBSVCEXT_STATUS_INUSE:
        case WEBSVCEXT_STATUS_NOTINUSE:
            return iWebSvcGear;
		default:
			return iWebSvcGear;
    }

    return iApplication;
}

/* virtual */
HRESULT
CWebServiceExtension::RefreshData()
{
	// the user clicked on the refresh menu bar or something
	// so let's make sure the item gets reselected
	return RefreshData(TRUE);
}

HRESULT
CWebServiceExtension::RefreshData(BOOL bReselect)
{
    // since refreshing just one of these items
    // means that we must read the metabase value
    // which contains all of the items, we might as
    // well update them all.
    //
    // just call the RefreshData for our container...
    IConsole * pConsole = (IConsole *)GetConsole();
    CWebServiceExtensionContainer * pContainer = m_pOwner->QueryWebSvcExtContainer();
    if (pContainer)
    {
		if (bReselect)
		{
			if (SUCCEEDED(CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST)))
			{
				// If we are selected, then
				// make sure we are select first.
				// this so that we get the StandardVerbs!
				if (pContainer == g_pCurrentlyDisplayedContainer)
				{
					if (NULL != QueryScopeItem())
					{
						pConsole->SelectScopeItem(QueryScopeItem());
					}
				}
			}
		}

		return pContainer->RefreshData();
    }
    else
    {
        return S_OK;
    }
}

/* virtual */
int 
CWebServiceExtension::CompareResultPaneItem(
    CIISObject * pObject, 
    int nCol
    )
/*++

Routine Description:

    Compare two CIISObjects on sort item criteria

Arguments:

    CIISObject * pObject : Object to compare against
    int nCol             : Column number to sort on

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Both are CWebServiceExtension objects
    //
    CWebServiceExtension * pMyObject = (CWebServiceExtension *)pObject;
    int MyType = 0;
    int YourType = 0;

    switch(nCol)
    {
    case COL_ICON:
        // Sort on the type of icon.
        MyType = m_RestrictionUIEntry.iType;;
        YourType = pMyObject->m_RestrictionUIEntry.iType;

        // 1st sort criteria -- type
        if (MyType == YourType)
        {
            // secondary sort criteria -- name
            //return ::lstrcmpi(GetResultPaneColInfo(COL_WEBSVCEXT), pObject->GetResultPaneColInfo(COL_WEBSVCEXT));

            // this should be faster, GetResultPaneColInfo just calls this anyways.
            return ::lstrcmpi(QueryDisplayName(), pObject->QueryDisplayName());
        }

        // 1st sort criteria -- type
        if (MyType == WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI || MyType == WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI)
        {
            return -1;
        }
        else
        {
            // WEBSVCEXT_TYPE_FILENAME_EXTENSIONS_FILTER
            // WEBSVCEXT_TYPE_REGULAR

            return 1;
        }
        break;
    case COL_WEBSVCEXT:
    case COL_STATUS:
    default:
        //
        // Lexical sort
        //
        return ::lstrcmpi(
            GetResultPaneColInfo(nCol), 
            pObject->GetResultPaneColInfo(nCol)
            );
    }
}

/* virtual */
HRESULT
CWebServiceExtension::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CError  err;
        IConsole * pConsole = (IConsole *)GetConsole();

	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }

	err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST);
	if (err.Succeeded())
	{
		//
		// If there's already a property sheet open on this item
		// then make it the foreground window and bail.
        HWND MyPropWindow = IsMyPropertySheetOpen();
        if (MyPropWindow && (MyPropWindow != (HWND) 1))
        {
            if (SetForegroundWindow(MyPropWindow))
            {
				if (handle)
				{
					MMCFreeNotifyHandle(handle);
					handle = 0;
				}
                return S_FALSE;
            }
            else
            {
                // wasn't able to bring this property sheet to
                // the foreground, the propertysheet must not
                // exist anymore.  let's just clean the hwnd
                // so that the user will be able to open propertysheet
                SetMyPropertySheetOpen(0);
            }
        }

        // if the entry doesn't have any files
        // then don't let them open it.
        if (!m_RestrictionUIEntry.strlstRestrictionEntries.IsEmpty())
        {
			// we need to refresh ourself from the metabase
			// before grabbing this data.
			// need to get the most up to date info...
			RefreshData(FALSE);
			if (TRUE == m_fFlaggedForDeletion)
			{
				// this item was marked for deletion during the RefreshData
				// so don't display it's property page.
				// instead popup an error.
				err = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
			}
			else
			{
				// Create a copy of the particular entry we want to modify....
				CRestrictionUIEntry * pCopyOfRestrictionUIEntry = RestrictionUIEntryMakeCopy(&m_RestrictionUIEntry);
				if (pCopyOfRestrictionUIEntry)
				{
    				CWebServiceExtensionSheet * pSheet = new CWebServiceExtensionSheet(
						QueryAuthInfo(), 
						METABASE_PATH_FOR_RESTRICT_LIST, 
						GetMainWindow(pConsole), 
						(LPARAM) this, 
                        (LPARAM) GetParentNode(), 
						(LPARAM) pCopyOfRestrictionUIEntry
						);
  					if (pSheet != NULL)
					{
                        // cache handle for user in MMCPropertyChangeNotify
                        m_ppHandle = handle;

						pSheet->SetModeless();

						err = AddMMCPage(lpProvider, new CWebServiceExtensionGeneral(pSheet,QueryImageForPropertyPage(),pCopyOfRestrictionUIEntry));
						err = AddMMCPage(lpProvider, new CWebServiceExtensionRequiredFiles(pSheet,QueryAuthInfo(),pCopyOfRestrictionUIEntry));
		                                    
						// send a notify to MMC to
						// let it refresh the HTML GetProperty buttons
						// don't do this, since it will send the property page to the background!
						//MMCPropertyChangeNotify(handle, (LPARAM) this);
					}
				}
			}
        }

        err.MessageBoxOnFailure();
	}
    else
    {
        return S_FALSE;
    }
	
	return err;
}

/* virtual */
HRESULT
CWebServiceExtension::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    ASSERT(pInsertionAllowed != NULL);
    if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0)
	{
		AddMenuSeparator(lpContextMenuCallback);

		/*
        // if there is a property dialog
        // open on this item, then don't let them
        // Do stuff with it.
        if (IsMyPropertySheetOpen())
        {
            AddMenuItemByCommand(lpContextMenuCallback, IDM_WEBEXT_ALLOW, MF_GRAYED);
            AddMenuItemByCommand(lpContextMenuCallback, IDM_WEBEXT_PROHIBIT, MF_GRAYED);
        }
        else
		*/
        {
            INT iState = GetState();
            if (WEBSVCEXT_STATUS_ALLOWED == iState || WEBSVCEXT_STATUS_PROHIBITED == iState || WEBSVCEXT_STATUS_CUSTOM == iState)
            {
                AddMenuItemByCommand(lpContextMenuCallback, IDM_WEBEXT_ALLOW, iState != WEBSVCEXT_STATUS_ALLOWED ? 0 : MF_GRAYED);
                AddMenuItemByCommand(lpContextMenuCallback, IDM_WEBEXT_PROHIBIT, iState != WEBSVCEXT_STATUS_PROHIBITED ? 0 : MF_GRAYED);
            }
        }
    }

    return hr;
}

/* virtual */
HRESULT
CWebServiceExtension::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
{
    HRESULT hr = S_OK;
    CString name;
    INT iCommand = 9999;

    switch (lCommandID)
    {

    case IDM_WEBEXT_ALLOW:
        iCommand = WEBSVCEXT_STATUS_ALLOWED;
        break;
    case IDM_WEBEXT_PROHIBIT:
        iCommand = WEBSVCEXT_STATUS_PROHIBITED;
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    if (iCommand != 9999)
    {
        hr = ChangeState(iCommand);
    }

    return hr;
}

/*virtual*/
HRESULT
CWebServiceExtension::DeleteNode(IResultData * pResult)
{
    CError err;

    // check if they have the property sheet open on it.
    if (IsMyPropertySheetOpen())
    {
        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET_WEBSVCEXT);
        return S_OK;
    }
    
    // Check if it's even deletable...
    if (!IsDeletable())
    {
        ::AfxMessageBox(IDS_ITEM_NOT_REMOVABLE);
    }
    else
    {
        if (!NoYesMessageBox(IDS_CONFIRM_DELETE))
        {
            return err;
        }

        err == RemoveRestrictionUIEntry(QueryInterface(),&m_RestrictionUIEntry);
        if (err.Succeeded())
        {
            // remove result item
			if (FAILED(err = FindMyResultItem(pResult,TRUE)))
			{
				err = pResult->DeleteItem(m_hResultItem, 0);
			}
           
            if (err.Succeeded())
            {
                RefreshData(FALSE);
            }
        }
        err.MessageBoxOnFailure();
    }
    return err;
}

/* virtual */
HRESULT
CWebServiceExtension::OnDblClick(IComponentData * pcd, IComponent * pc)
{
    CComQIPtr<IPropertySheetProvider, &IID_IPropertySheetProvider> spProvider(GetConsole());
    IDataObject * pdo = NULL;
    GetDataObject(&pdo, CCT_RESULT);
    CError err = spProvider->FindPropertySheet(reinterpret_cast<MMC_COOKIE>(this), 0, pdo);
    if (err != S_OK)
    {
        err = spProvider->CreatePropertySheet(_T(""), TRUE, (MMC_COOKIE)this, pdo, MMC_PSO_HASHELP);
        if (err.Succeeded())
        {
            err = spProvider->AddPrimaryPages(
                pc,
                TRUE,   // we may want to get property change notifications
                NULL,   // according to docs
                FALSE   // for result item only
                );
            if (err.Succeeded())
            {
                err = spProvider->AddExtensionPages();
            }
        }
        if (err.Succeeded())
        {
            HWND hWnd = NULL;
            VERIFY(SUCCEEDED(GetConsole()->GetMainWindow(&hWnd)));
            VERIFY(SUCCEEDED(spProvider->Show((LONG_PTR)hWnd, 0)));
        }
        else
        {
            spProvider->Show(-1, 0);
        }
    }
	return err;
}


//
//  Procedure removes all characters in the second string from the first one.
//
INT RemoveChars(LPTSTR pszStr,LPTSTR pszRemoved)
{
    BOOL bRemovedSomething = FALSE;
    INT iCharsRemovedCount = 0;
    INT iOrgStringLength = _tcslen(pszStr);
    INT cbRemoved = _tcslen(pszRemoved);
    INT iSrc, iDest;
    
    for (iSrc = iDest = 0; pszStr[iSrc]; iSrc++, iDest++)
    {
        // Check if this char is the in the list of stuf
        // we are supposed to remove.
        // if it is then just set iSrc to iSrc +1
#ifdef UNICODE
        while (wmemchr(pszRemoved, pszStr[iSrc], cbRemoved))
#else
        while (memchr(pszRemoved, pszStr[iSrc], cbRemoved))
#endif
        {
            iCharsRemovedCount++;
            iSrc++;
        }

        // copy the character to itself
        pszStr[iDest] = pszStr[iSrc];
    }

    // Cut off the left over strings
    // which we didn't erase.  but need to.
    if (iCharsRemovedCount >= 0){pszStr[iOrgStringLength - iCharsRemovedCount]= '\0';}

    return iDest - 1;
}

/* virtual */
HRESULT 
CWebServiceExtension::GetProperty(
    LPDATAOBJECT pDataObject,
    BSTR szPropertyName,
    BSTR* pbstrProperty)
{
    CString strProperty;

    if (!_wcsicmp(L"CCF_HTML_DETAILS",szPropertyName))
    {
        if (!_fStaticsLoaded2)
        {
            CComBSTR strTempFormat;
            CComBSTR strTempString1,strTempString2,strTempString3;
            CString csTempPath1;
            CString csTempPath2;

	        // point this to a hard coded file, if the file exists...
	        if (_MAX_PATH >= GetSystemDirectory(csTempPath1.GetBuffer(_MAX_PATH), _MAX_PATH))
	        {
                csTempPath1.ReleaseBuffer( );
                csTempPath2 = csTempPath1;
                csTempPath1 += _T("\\oobe\\images\\btn2.gif");
                csTempPath2 += _T("\\oobe\\images\\qmark.gif");

                strTempFormat.LoadString(IDS_MENU_WEBEXT_ICON_FORMAT);

                DWORD dwAttr = GetFileAttributes(csTempPath1);
                _bstrMenuIconBullet = _T("<BR>");
                if (!(dwAttr == 0xffffffff || (dwAttr & FILE_ATTRIBUTE_DIRECTORY)))
                {
                    // point to the  hard coded file
                    _bstrMenuIconBullet.Format(strTempFormat,csTempPath1);
                }

                dwAttr = GetFileAttributes(csTempPath2);
                _bstrMenuIconHelp = _T("<BR>");
                if (!(dwAttr == 0xffffffff || (dwAttr & FILE_ATTRIBUTE_DIRECTORY)))
                {
                    // point to the  hard coded file
                    _bstrMenuIconHelp.Format(strTempFormat,csTempPath2);
                }
	        }
           
			//
			// NOTE ON RemoveChars()
			// This was used to erase the & from a string like "&Allow"
			// Because Javascript can't handle that, so it had to be stripped.
			// this worked for english type languages but broke for languages
			// like Japanese because in order to show a hotkey they would
			// use "SomeHiraganaCharacters (&A)".  and the "(" isn't able
			// to be handled by Javascript either, so it broke.
			// instead of just fixing RemoveChars() to remove ( and ) as well
			// we just created new strings, that way localizers don't get confused
			// when the string the created shows up in the UI as
			// "SomeHiraganaCharacters" rather than "SomeHiraganaCharacters (A)"
			//
            strTempString1.LoadString(IDS_MENU_WEBEXT_ALLOW_JAVA_SAFE);
            //RemoveChars(strTempString1, BAD_CHARS_FOR_HTML_PANE);
            strTempString2.LoadString(IDS_MENU_WEBEXT_ALLOW_FORMAT);
            _bstrMenuAllowOn.Format(strTempString2,strTempString1,_T("IDS_MENU_WEBEXT_ALLOW"));
            strTempString2.LoadString(IDS_MENU_WEBEXT_ALLOW_DISABLED_FORMAT);
            _bstrMenuAllowOff.Format(strTempString2,strTempString1);

            strTempString1.LoadString(IDS_MENU_WEBEXT_PROHIBIT_JAVA_SAFE);
            //RemoveChars(strTempString1, BAD_CHARS_FOR_HTML_PANE);
            strTempString2.LoadString(IDS_MENU_WEBEXT_PROHIBIT_FORMAT);
            _bstrMenuProhibitOn.Format(strTempString2,strTempString1,_T("IDS_MENU_WEBEXT_PROHIBIT"));
            strTempString2.LoadString(IDS_MENU_WEBEXT_PROHIBIT_DISABLED_FORMAT);
            _bstrMenuProhibitOff.Format(strTempString2,strTempString1);

            strTempString1.LoadString(IDS_MENU_PROPERTIES_JAVA_SAFE);
            //RemoveChars(strTempString1, BAD_CHARS_FOR_HTML_PANE);
            strTempString2.LoadString(IDS_MENU_WEBEXT_PROPERTIES_FORMAT);
            _bstrMenuPropertiesOn.Format(strTempString2,strTempString1,strTempString1);
            strTempString2.LoadString(IDS_MENU_WEBEXT_PROPERTIES_DISABLED_FORMAT);
            _bstrMenuPropertiesOff.Format(strTempString2,strTempString1,strTempString1);
            
            strTempString1.LoadString(IDS_MENU_WEBEXT_CONTAINER_ADD1_JAVA_SAFE);
            //RemoveChars(strTempString1, BAD_CHARS_FOR_HTML_PANE);
            strTempString2.LoadString(IDS_MENU_WEBEXT_ADD1_FORMAT);
            _bstrMenuTask1.Format(strTempString2,_T("IDS_MENU_WEBEXT_CONTAINER_ADD1"),strTempString1);

            strTempString1.LoadString(IDS_MENU_WEBEXT_CONTAINER_ADD2_JAVA_SAFE);
            //RemoveChars(strTempString1, BAD_CHARS_FOR_HTML_PANE);
            strTempString2.LoadString(IDS_MENU_WEBEXT_ADD2_FORMAT);
            _bstrMenuTask2.Format(strTempString2,_T("IDS_MENU_WEBEXT_CONTAINER_ADD2"),strTempString1);

            strTempString1.LoadString(IDS_MENU_WEBEXT_CONTAINER_PROHIBIT_ALL_JAVA_SAFE);
            //RemoveChars(strTempString1, BAD_CHARS_FOR_HTML_PANE);
            strTempString2.LoadString(IDS_MENU_WEBEXT_PROHIBIT_ALL_FORMAT);
            _bstrMenuTask3.Format(strTempString2,_T("IDS_MENU_WEBEXT_CONTAINER_PROHIBIT_ALL"),strTempString1);

            strTempString1.LoadString(IDS_MENU_WEBEXT_CONTAINER_HELP);
			strTempString3.LoadString(IDS_MENU_WEBEXT_CONTAINER_HELP_JAVA_SAFE);
            //RemoveChars(strTempString1, BAD_CHARS_FOR_HTML_PANE);
            strTempString2.LoadString(IDS_MENU_WEBEXT_HELP_FORMAT);
            _bstrMenuTask4.Format(strTempString2,strTempString3,strTempString1);

            strTempString2.LoadString(IDS_MENU_WEBEXT_TASKS);
            //RemoveChars(strTempString2, BAD_CHARS_FOR_HTML_PANE);
            _bstrMenuTasks = strTempString2;

            _fStaticsLoaded2 = TRUE;
        }

		/*
		// commented out: if we disable this, then there is no notification to
		// re-enable it if the user hit cancel, thus the buttons will stay "grayed"...

        // if there is a property dialog
        // open on this item, then don't
        // let them access these buttons...
        if (IsMyPropertySheetOpen())
        {
            strProperty += _bstrMenuAllowOff;
            strProperty += _bstrMenuProhibitOff;
        }
        else
		*/
        {
            // [Allowed] Button
            // [Prohibited] Button
            switch(GetState())
                {
                case WEBSVCEXT_STATUS_ALLOWED:
                    strProperty += _bstrMenuAllowOff;
                    strProperty += _bstrMenuProhibitOn;
                    break;
                case WEBSVCEXT_STATUS_PROHIBITED:
                    strProperty += _bstrMenuAllowOn;
                    strProperty += _bstrMenuProhibitOff;
                    break;
                case WEBSVCEXT_STATUS_CUSTOM:
                    strProperty += _bstrMenuAllowOn;
                    strProperty += _bstrMenuProhibitOn;
                    break;
		        default:
                    break;
                }
        }

        // [Properties] Button
        if (IsConfigurable())
        {
            strProperty += _bstrMenuPropertiesOn;
        }
        else
        {
            strProperty += _bstrMenuPropertiesOff;
        }

        // Tasks
        // -------------------------
        strProperty += _bstrMenuTasks;

        // Task 1
        strProperty += _bstrMenuIconBullet;
        strProperty += _bstrMenuTask1;

        // Task 2
        strProperty += _bstrMenuIconBullet;
        strProperty += _bstrMenuTask2;

        // Task 3
        strProperty += _bstrMenuIconBullet;
        strProperty += _bstrMenuTask3;

        // Help
        strProperty += _bstrMenuIconHelp;
        strProperty += _bstrMenuTask4;
	}
    else if (!_wcsicmp(L"CCF_DESCRIPTION",szPropertyName))
    {
        // Display data in Description field...
    }
    else
    {
        return S_FALSE; // unknown strPropertyName
    }

    *pbstrProperty = ::SysAllocString(strProperty);
    return S_OK;
}


HRESULT
CWebServiceExtension::UpdateResultItem(IResultData *pResultData,BOOL bSelect)
{
    HRESULT hr = S_OK;

    if (!pResultData)
    {
        return E_POINTER;
    }

    RESULTDATAITEM ri;
    ::ZeroMemory(&ri, sizeof(ri));
    ri.itemID = this->QueryResultItem();
    ri.mask = RDI_STR | RDI_IMAGE;
    if (bSelect)
    {
        ri.mask = ri.mask | RDI_STATE;
		ri.nState = LVIS_SELECTED | LVIS_FOCUSED;
    }
    ri.str = MMC_CALLBACK;
    ri.nImage = this->QueryImage();

    hr = pResultData->SetItem(&ri);
    pResultData->UpdateItem(ri.itemID);

    return hr;
}

HRESULT
CWebServiceExtension::FindMyResultItem(IResultData *pResultData,BOOL bDeleteIfFound)
{
	HRESULT hr,hr0 = S_FALSE;
	LPARAM lParam = (LPARAM) this;
	HRESULTITEM hresultItem = NULL;
	int i = 0;

	hr0 = hr = pResultData->FindItemByLParam(lParam,&hresultItem);
	while (S_OK == hr)
	{
		if (i++ >= 10)
		{
			break;
		}
		if (bDeleteIfFound)
		{
			hr = pResultData->DeleteItem(hresultItem,0);
		}
		hr = pResultData->FindItemByLParam(lParam,&hresultItem);
	}

	return hr0;
}

HRESULT
CWebServiceExtension::AddToResultPane(IResultData *pResultData, BOOL bSelect,BOOL bPleaseAddRef)
{
    HRESULT hr = S_OK;
	HRESULTITEM hresultItem = NULL;

    if (!pResultData)
    {
        return E_POINTER;
    }

    RESULTDATAITEM ri;
    ::ZeroMemory(&ri, sizeof(ri));
    ri.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    if (bSelect)
    {
        ri.mask = ri.mask | RDI_STATE;
		ri.nState = LVIS_SELECTED | LVIS_FOCUSED;
    }
    ri.str = MMC_CALLBACK;
    ri.nImage = this->QueryImage();
    ri.lParam = (LPARAM) this;

	// check if we're already in the list
	if (S_OK == pResultData->FindItemByLParam((LPARAM) this,&hresultItem))
	{
		// this needs to be set before calling UpdateResultItem...
		ri.itemID = hresultItem;
		this->SetResultItem(ri.itemID);
		this->SetScopeItem(this->QueryContainer()->QueryScopeItem());

		hr = pResultData->SetItem(&ri);
		if (bSelect)
		{
			//pResultData->UpdateItem(ri.itemID);
		}
		return S_OK;
	}

	//if (this->QueryContainer()->IsExpanded())
	{
        // a very important step here.
        // if we don't have this AddRef, we will Access violate..
		if (bPleaseAddRef)
		{
			this->AddRef();
		}

        hr = pResultData->InsertItem(&ri);
        if (SUCCEEDED(hr))
        {
            this->SetScopeItem(this->QueryContainer()->QueryScopeItem());
            this->SetResultItem(ri.itemID);
        }
        else
        {
			if (bPleaseAddRef)
			{
				this->Release();
			}
        }
    }

    return hr;
}

HRESULT
CWebServiceExtension::AddToResultPaneSorted(IResultData *pResultData,BOOL bSelect,BOOL bPleaseAddRef)
{
    HRESULT hr = S_OK;
    if (!pResultData)
    {
        return E_POINTER;
    }
    hr = AddToResultPane(pResultData,bSelect,bPleaseAddRef);

    // sort on Column0,Ascending,nodata
    pResultData->Sort(0,0,0);
    return hr;
}

INT
CWebServiceExtension::GetState() const
{
    INT iDisplayedState = GetRestrictUIState((CRestrictionUIEntry *) &m_RestrictionUIEntry);
    return iDisplayedState;
}

HRESULT 
CWebServiceExtension::ChangeState(INT iDesiredState)
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    CError err;
    CWaitCursor wait;
    BOOL bProceed = TRUE;
    BOOL bShowedPopup = FALSE;
    IConsole * pConsole = (IConsole *)GetConsole();

	// don't allow them to change the state if
	// it's property sheet is already open...
    // check if they have the property sheet open on it.
    if (IsMyPropertySheetOpen())
    {
        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET_WEBSVCEXT2);
        return S_OK;
    }

	err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,METABASE_PATH_FOR_RESTRICT_LIST);
    if (err.Succeeded())
    {
        // if it's the special entries
        // check if they are sure if they want to do this...
        if (WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI == m_RestrictionUIEntry.iType || WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI == m_RestrictionUIEntry.iType)
        {
            // check if they're tryinging to allow it.
            if (WEBSVCEXT_STATUS_ALLOWED == iDesiredState)
            {
                CString strMsg;
                CString strMsgFormat;
                bProceed = FALSE;
                UINT iHelpID = 0;
                if (WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI == m_RestrictionUIEntry.iType)
                {
                    iHelpID = HIDD_WEBSVCEXT_UNKNOWN_ISAPI;
                    strMsgFormat.LoadString(IDS_ALLOW_UNSAFE_ISAPI_MSG);
                }
                else
                {
                    iHelpID = HIDD_WEBSVCEXT_UNKNOWN_CGI;
                    strMsgFormat.LoadString(IDS_ALLOW_UNSAFE_CGI_MSG);
                }
                strMsg.Format(strMsgFormat,m_RestrictionUIEntry.strGroupDescription,m_RestrictionUIEntry.strGroupDescription);

			    // ensure the dialog gets themed
			    CThemeContextActivator activator(theApp.GetFusionInitHandle());

                if (IDYES == DoHelpMessageBox(NULL,strMsg,MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 | MB_HELP, iHelpID))
                {
                    bProceed = TRUE;
                    bShowedPopup = TRUE;
                }
            }
        }
        else
        {
            // check if it's a normal entry
            // and if other applications have dependencies upon it
            // if there are dependencies, then ask if they're sure
            // they want to disable it?
            if (WEBSVCEXT_TYPE_REGULAR == m_RestrictionUIEntry.iType)
            {
                // Check if they want to disable it
                if (WEBSVCEXT_STATUS_PROHIBITED == iDesiredState)
                {
                    // Check if this item has apps that
                    // are dependent upon it.
                    CStringListEx strlstDependApps;
                    if (TRUE == ReturnDependentAppsList(QueryInterface(),m_RestrictionUIEntry.strGroupID,&strlstDependApps,FALSE))
                    {
                        bProceed = FALSE;

					    // ensure the dialog gets themed
					    CThemeContextActivator activator(theApp.GetFusionInitHandle());

                        // check if they really want to do this.
                        CDepedentAppsDlg dlg(&strlstDependApps,m_RestrictionUIEntry.strGroupDescription,GetMainWindow(pConsole));
                        if (dlg.DoModal() == IDOK)
                        {
                            bProceed = TRUE;
                            bShowedPopup = TRUE;
                        }
                    }
                }
            }
        }

        if (bProceed)
        {
            if (&m_RestrictionUIEntry)
            {
                err = ChangeStateOfEntry(QueryInterface(),iDesiredState,&m_RestrictionUIEntry);
                if (err.Succeeded() || err.Win32Error() == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                {
				    // just in case they are trying to set the allow/prohibit
				    // for an item which has already been removed from the metabase
				    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == err.Win32Error())
				    {
					    err.MessageBoxOnFailure();
				    }
                    err = RefreshData(FALSE);
                    if (err.Succeeded())
                    {
                        RefreshDisplay();
                        if (bShowedPopup)
                        {
                            // if we wanted to make the container node
                            // redisplay everything... we would uncomment this line.
                            // seems like we have to do this after displaying confirmation msg.
                            // dunno why.
                            CWebServiceExtensionContainer * pContainer = m_pOwner->QueryWebSvcExtContainer();
                            if (pContainer)
                            {
                                err = pContainer->RefreshDisplay(FALSE);
                            }
                        }
                    }
                }
			    err.MessageBoxOnFailure();
            }
        }
    }
    else
    {
        return S_FALSE;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\websvcext_sheet.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        websvcext_sheet.cpp

   Abstract:
        Property Sheet and Pages

   Author:
        Aaron Lee (AaronL)

   Project:
        Internet Services Manager

   Revision History:
        4/1/2002         aaronl           Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "strvalid.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "iisobj.h"
#include "shlobjp.h"
#include "websvcext_sheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

extern CInetmgrApp theApp;

static CComBSTR g_InvalidWebSvcExtCharsPath;
static CComBSTR g_InvalidWebSvcExtCharsName;
static BOOL  g_fStaticsLoaded = FALSE;


void LoadStatics(void)
{
    if (!g_fStaticsLoaded)
    {
        g_InvalidWebSvcExtCharsName = _T(",");
        g_fStaticsLoaded = g_InvalidWebSvcExtCharsPath.LoadString(IDS_WEBSVCEXT_INVALID_CHARSET);
    }
}

IMPLEMENT_DYNAMIC(CWebServiceExtensionSheet, CInetPropertySheet)

CWebServiceExtensionSheet::CWebServiceExtensionSheet(
      CComAuthInfo * pComAuthInfo,
      LPCTSTR lpszMetaPath,
      CWnd * pParentWnd,
      LPARAM lParam,
      LPARAM lParamParent,
      LPARAM lParam2,
      UINT iSelectPage
      )
      : CInetPropertySheet(pComAuthInfo, lpszMetaPath, pParentWnd, lParam, lParamParent, iSelectPage),
      m_pprops(NULL)
{
   m_pWebServiceExtension = (CWebServiceExtension *) lParam;
   m_pRestrictionUIEntry = (CRestrictionUIEntry *) lParam2;
}

CWebServiceExtensionSheet::~CWebServiceExtensionSheet()
{
	FreeConfigurationParameters();
}

HRESULT
CWebServiceExtensionSheet::LoadConfigurationParameters()
{
   //
   // Load base properties
   //
   CError err;

   if (m_pprops == NULL)
   {
      //
      // First call -- load values
      //
      m_pprops = new CWebServiceExtensionProps(m_pWebServiceExtension->QueryInterface(), QueryMetaPath(),m_pRestrictionUIEntry,m_pWebServiceExtension);
      if (!m_pprops)
      {
         TRACEEOL("LoadConfigurationParameters: OOM");
         err = ERROR_NOT_ENOUGH_MEMORY;
         return err;
      }
      err = m_pprops->LoadData();
   }

   return err;
}

void
CWebServiceExtensionSheet::FreeConfigurationParameters()
{
   CInetPropertySheet::FreeConfigurationParameters();
   if (m_pprops)
   {
        delete m_pprops;m_pprops=NULL;
   }
}

BEGIN_MESSAGE_MAP(CWebServiceExtensionSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CWebServiceExtensionSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CWebServiceExtensionGeneral, CInetPropertyPage)

CWebServiceExtensionGeneral::CWebServiceExtensionGeneral(CWebServiceExtensionSheet * pSheet,int iImageIndex, CRestrictionUIEntry * pRestrictionUIEntry)
    : CInetPropertyPage(CWebServiceExtensionGeneral::IDD, pSheet),m_hGeneralImage(NULL)
{
    m_pRestrictionUIEntry = pRestrictionUIEntry;

    HBITMAP hImageStrip = (HBITMAP) LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_INETMGR32), IMAGE_BITMAP, 0, 0, 
		LR_LOADTRANSPARENT 
		| LR_LOADMAP3DCOLORS
		| LR_SHARED);
    if (hImageStrip)
    {
        if (0 != iImageIndex)
        {
            m_hGeneralImage = GetBitmapFromStrip(hImageStrip, iImageIndex, 32);
        }
    }

    if (hImageStrip != NULL)
    {
        FreeResource(hImageStrip);
        hImageStrip=NULL;
    }
}

CWebServiceExtensionGeneral::~CWebServiceExtensionGeneral()
{
    if (m_hGeneralImage != NULL)
    {
        FreeResource(m_hGeneralImage);
        m_hGeneralImage = NULL;
    }
}

/* virtual */
HRESULT
CWebServiceExtensionGeneral::FetchLoadedValues()
{
    CError err;

    BEGIN_META_INST_READ(CWebServiceExtensionSheet)
        FETCH_INST_DATA_FROM_SHEET(m_strExtensionName);
        FETCH_INST_DATA_FROM_SHEET(m_strExtensionUsedBy);
        FETCH_INST_DATA_FROM_SHEET(m_iExtensionUsedByCount);
    END_META_INST_READ(err)

    if (m_iExtensionUsedByCount > 15)
    {
        ::ShowScrollBar(CONTROL_HWND(IDC_EXTENSION_USEDBY), SB_VERT, TRUE);
    }

    return err;
}

/* virtual */
HRESULT
CWebServiceExtensionGeneral::SaveInfo()
{
    ASSERT(IsDirty());
    CError err;

    try
    {
		CWebServiceExtensionSheet * pSheet = (CWebServiceExtensionSheet *)GetSheet();
		if (pSheet)
		{
			pSheet->GetInstanceProperties().m_strExtensionName = m_strExtensionName;
			pSheet->GetInstanceProperties().m_strExtensionUsedBy = m_strExtensionUsedBy;
            err = pSheet->GetInstanceProperties().WriteDirtyProps();
		}
    }
    catch(CMemoryException * e)
    {
        e->Delete();
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}

void
CWebServiceExtensionGeneral::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CWebServiceExtensionGeneral)
   DDX_Control(pDX, IDC_EXTENSION_NAME, m_ExtensionName);
   DDX_Control(pDX, IDC_EXTENSION_USEDBY, m_ExtensionUsedBy);
   //DDX_Text(pDX, IDC_EXTENSION_NAME, m_strExtensionName);
   //DDX_Text(pDX, IDC_EXTENSION_NAME, m_strExtensionUsedBy);
   //DDV_MinMaxChars(pDX, m_strExtensionName, 1, MAX_PATH);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWebServiceExtensionGeneral, CInetPropertyPage)
    //{{AFX_MSG_MAP(CWebServiceExtensionGeneral)
    ON_WM_COMPAREITEM()
    ON_WM_MEASUREITEM()
    ON_WM_DRAWITEM()
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    ON_EN_CHANGE(IDC_EXTENSION_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_EXTENSION_USEDBY, OnItemChanged)
	ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL
CWebServiceExtensionGeneral::OnInitDialog()
{
   CInetPropertyPage::OnInitDialog();

   CString strBeautifullName;
   CString strFormat;
   strFormat.LoadString(IDS_WEBSVCEXT_PROP_PRENAME);
   strBeautifullName.Format(strFormat,m_strExtensionName);

   m_ExtensionName.SetWindowText(strBeautifullName);
   m_ExtensionUsedBy.SetWindowText(m_strExtensionUsedBy);

   if (m_hGeneralImage)
   {
       ::SendDlgItemMessage(m_hWnd,IDC_FILE_ICON,STM_SETIMAGE,(WPARAM)IMAGE_BITMAP,(LPARAM) m_hGeneralImage);
   }

   strFormat.LoadString(IDS_WEBSVCEXT_PROP_CAPTION);
   strBeautifullName.Format(strFormat,m_strExtensionName);
   ::SetWindowText(::GetForegroundWindow(), strBeautifullName);

   SetControlsState();
   SetModified(FALSE); 
   return TRUE;
}

BOOL
CWebServiceExtensionGeneral::OnHelpInfo(HELPINFO * pHelpInfo)
{
    OnHelp();
    return TRUE;
}

void
CWebServiceExtensionGeneral::OnHelp()
{
    WinHelpDebug(0x20000 + CWebServiceExtensionGeneral::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CWebServiceExtensionGeneral::IDD);
}

void
CWebServiceExtensionGeneral::SetControlsState()
{
    m_ExtensionName.SetReadOnly(TRUE);
    m_ExtensionUsedBy.SetReadOnly(TRUE);
}

void
CWebServiceExtensionGeneral::OnItemChanged()
{
    SetModified(TRUE);
}

void
CWebServiceExtensionGeneral::OnDestroy()
{
	CInetPropertyPage::OnDestroy();
}

BOOL 
CWebServiceExtensionGeneral::OnSetActive() 
{
    // dunno why this doesn't work.
    m_ExtensionName.SetSel(0,0);
    //m_ExtensionUsedBy.SetFocus();

    return CInetPropertyPage::OnSetActive();
}


//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CWebServiceExtensionRequiredFiles, CInetPropertyPage)

CWebServiceExtensionRequiredFiles::CWebServiceExtensionRequiredFiles(CWebServiceExtensionSheet * pSheet,CComAuthInfo * pComAuthInfo,CRestrictionUIEntry * pRestrictionUIEntry)
    : CInetPropertyPage(CWebServiceExtensionRequiredFiles::IDD, pSheet)
{
    m_pComAuthInfo = pComAuthInfo;
	m_pInterface =  pSheet->m_pWebServiceExtension->QueryInterface();
	
    m_pRestrictionUIEntry = pRestrictionUIEntry;
    m_MyRestrictionList.RemoveAll();
   
    RestrictionListCopy(&m_MyRestrictionList,&m_pRestrictionUIEntry->strlstRestrictionEntries);
}

CWebServiceExtensionRequiredFiles::~CWebServiceExtensionRequiredFiles()
{
    // delete the list and all the newly items
    CleanRestrictionList(&m_MyRestrictionList);
}

/* virtual */
HRESULT
CWebServiceExtensionRequiredFiles::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CWebServiceExtensionSheet)
      //FETCH_INST_DATA_FROM_SHEET(m_strFileList);
      RestrictionListCopy(&m_MyRestrictionList,&pSheet->GetInstanceProperties().m_MyRestrictionList);
   END_META_INST_READ(err)

   return err;
}

/* virtual */
HRESULT
CWebServiceExtensionRequiredFiles::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CWebServiceExtensionSheet)
        //STORE_INST_DATA_ON_SHEET(m_MyRestrictionList);
        RestrictionListCopy(&pSheet->GetInstanceProperties().m_MyRestrictionList,&m_MyRestrictionList);
   END_META_INST_WRITE(err)

   return err;
}

void
CWebServiceExtensionRequiredFiles::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CWebServiceExtensionRequiredFiles)
   DDX_Control(pDX, IDC_BTN_ADD, m_bnt_Add);
   DDX_Control(pDX, IDC_BTN_REMOVE, m_bnt_Remove);
   DDX_Control(pDX, IDC_BTN_ENABLE, m_bnt_Enable);
   DDX_Control(pDX, IDC_BTN_DISABLE, m_bnt_Disable);
   //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_FILES, m_list_Files);
}

BEGIN_MESSAGE_MAP(CWebServiceExtensionRequiredFiles, CInetPropertyPage)
    //{{AFX_MSG_MAP(CWebServiceExtensionRequiredFiles)
    ON_BN_CLICKED(IDC_BTN_ADD, OnDoButtonAdd)
    ON_BN_CLICKED(IDC_BTN_REMOVE, OnDoButtonRemove)
    ON_BN_CLICKED(IDC_BTN_ENABLE, OnDoButtonEnable)
    ON_BN_CLICKED(IDC_BTN_DISABLE, OnDoButtonDisable)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST_FILES, OnDblclkListFiles)
    ON_NOTIFY(NM_CLICK, IDC_LIST_FILES, OnClickListFiles)
	ON_NOTIFY(LVN_KEYDOWN, IDC_LIST_FILES, OnKeydownListFiles)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_FILES, OnSelChangedListFiles)
    ON_NOTIFY(LVN_BEGINDRAG, IDC_LIST_FILES, OnSelChangedListFiles)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define COL_1     0
#define COL_1_WID 256

BOOL
CWebServiceExtensionRequiredFiles::OnInitDialog()
{
    CInetPropertyPage::OnInitDialog();

    CString strMyTitle;
    if (m_pRestrictionUIEntry)
    {
        CString strTruncatedName;
        CString strFormat;
        strFormat.LoadString(IDS_REQUIREDFILES_TITLE);
        if (m_pRestrictionUIEntry->strGroupDescription.GetLength() <= 40)
        {
            strTruncatedName = m_pRestrictionUIEntry->strGroupDescription;
        }
        else
        {
            strTruncatedName = m_pRestrictionUIEntry->strGroupDescription.Left(40);
            strTruncatedName = strTruncatedName + _T("...");
        }

        strMyTitle.Format(strFormat,strTruncatedName,strTruncatedName);
    }
    GetDlgItem(IDC_REQUIREDFILES_STATIC_TITLE)->SetWindowText(strMyTitle);
   
    m_list_Files.Initialize(2);
    FillListBox(NULL);

    SetControlState();
    SetModified(FALSE);
    return TRUE;
}

BOOL
CWebServiceExtensionRequiredFiles::OnHelpInfo(HELPINFO * pHelpInfo)
{
    OnHelp();
    return TRUE;
}

void
CWebServiceExtensionRequiredFiles::OnHelp()
{
    WinHelpDebug(0x20000 + CWebServiceExtensionRequiredFiles::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CWebServiceExtensionRequiredFiles::IDD);
}

void
CWebServiceExtensionRequiredFiles::FillListBox(CRestrictionEntry * pSelection)
{
    m_list_Files.SetRedraw(FALSE);
    m_list_Files.DeleteAllItems();
    int cItems = 0;

    POSITION pos;
    CString TheKey;
    CRestrictionEntry * pOneEntry = NULL;

    for(pos = m_MyRestrictionList.GetStartPosition();pos != NULL;)
    {
        m_MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            m_list_Files.AddItem(pOneEntry);
            ++cItems;
        }
    }
    m_list_Files.SetRedraw(TRUE);

    if (pSelection)
    {
        LVFINDINFO fi;
        fi.flags = LVFI_PARAM;
        fi.lParam = (LPARAM)pSelection;
        fi.vkDirection = VK_DOWN;
        int i = m_list_Files.FindItem(&fi);
        if (i != -1)
        {
            m_list_Files.SelectItem(i);
        }
    }
}



void
CWebServiceExtensionRequiredFiles::SetControlState()
{
    int nCurSel = m_list_Files.GetSelectionMark();
    BOOL bAdd_able = TRUE;
    BOOL bRemove_able = FALSE;
    BOOL bEnable_able = FALSE;
    BOOL bDisable_able = FALSE;
	BOOL bNoEntries = TRUE;
	CString TheKey;
	POSITION pos;
	CRestrictionEntry * pOneEntry;

    if (-1 != nCurSel)
    {
        CRestrictionEntry * pOneEntry = m_list_Files.GetItem(nCurSel);
        if (pOneEntry)
        {
            // Check if the entry -- is "not deletable"
            if (0 == pOneEntry->iDeletable)
            {
                bAdd_able = FALSE;
                bRemove_able = FALSE;
            }
            else
            {
                bRemove_able = TRUE;
            }

            // check if it's currently prohibited...
            // then we should allow them to "allow"
            if (WEBSVCEXT_STATUS_PROHIBITED == pOneEntry->iStatus)
            {
                bEnable_able = TRUE;
            }

            // check if it's currently allowed...
            // then we should allow them to "prohibit"
            if (WEBSVCEXT_STATUS_ALLOWED == pOneEntry->iStatus)
            {
                bDisable_able = TRUE;
            }
        }
    }

    if (bAdd_able || bRemove_able)
    {
        // if we are on one of the "special" entries
        // then we cannot add or remove to the entry.
        if (WEBSVCEXT_TYPE_ALL_UNKNOWN_ISAPI == m_pRestrictionUIEntry->iType || WEBSVCEXT_TYPE_ALL_UNKNOWN_CGI == m_pRestrictionUIEntry->iType)
        {
            bAdd_able = FALSE;
            bRemove_able = FALSE;
        }

        // or if our entry is marked as not delet-able...
        // then the user cannot add or remove from this list...
        for(pos = m_MyRestrictionList.GetStartPosition();pos != NULL;)
        {
            m_MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
				bNoEntries = FALSE;

                if (0 == pOneEntry->iDeletable)
                {
                    bAdd_able = FALSE;
                    bRemove_able = FALSE;
                    break;
                }
            }
        }
    }

	if (TRUE == bNoEntries)
	{
		for(pos = m_MyRestrictionList.GetStartPosition();pos != NULL;)
		{
			m_MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
			if (pOneEntry)
			{
				bNoEntries = FALSE;
				break;
			}
		}
	}

    m_bnt_Add.EnableWindow(bAdd_able);
    m_bnt_Remove.EnableWindow(bRemove_able);
    m_bnt_Enable.EnableWindow(bEnable_able);
    m_bnt_Disable.EnableWindow(bDisable_able);

	if (bNoEntries)
	{
		// disable the OK button
		SetModified(FALSE);
		::EnableWindow(::GetDlgItem(::GetForegroundWindow(), IDOK), FALSE);
	}
	else
	{
		// enable the OK button
		::EnableWindow(::GetDlgItem(::GetForegroundWindow(), IDOK), TRUE);
	}
	
    m_list_Files.EnableWindow(TRUE);
}

void 
CWebServiceExtensionRequiredFiles::OnClickListFiles(NMHDR * pNMHDR, LRESULT * pResult)
{
    SetControlState();
    *pResult = 0;
}

void 
CWebServiceExtensionRequiredFiles::OnKeydownListFiles(NMHDR * pNMHDR, LRESULT* pResult) 
{
	LV_KEYDOWN * pLVKeyDow = (LV_KEYDOWN *)pNMHDR;

	SetControlState();

	switch (pLVKeyDow->wVKey)
	{
		case VK_INSERT:
			SendMessage(WM_COMMAND, IDC_BTN_ADD);
			break;
		case VK_DELETE:
			SendMessage(WM_COMMAND, IDC_BTN_REMOVE);
			break;
		case VK_SPACE:
			{
				if (GetDlgItem(IDC_BTN_ENABLE)->IsWindowEnabled())
				{
					OnDoButtonEnable();
				}
				else if (GetDlgItem(IDC_BTN_DISABLE)->IsWindowEnabled())
				{
					OnDoButtonDisable();
				}
				SetControlState();
			}
			break;
		default:
			// Continue default action
			*pResult = 0;
			break;
	}
}

void
CWebServiceExtensionRequiredFiles::OnSelChangedListFiles(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetControlState();
    *pResult = 1;
}

void 
CWebServiceExtensionRequiredFiles::OnDblclkListFiles(NMHDR * pNMHDR, LRESULT * pResult)
{
    if (GetDlgItem(IDC_BTN_ENABLE)->IsWindowEnabled())
	{
		OnDoButtonEnable();
	}
    else if (GetDlgItem(IDC_BTN_DISABLE)->IsWindowEnabled())
	{
		OnDoButtonDisable();
	}

    SetControlState();
    *pResult = 0;
}

void
CWebServiceExtensionRequiredFiles::OnDoButtonAdd()
{
    CFileDlg dlg(IsLocal(), m_pInterface, &m_MyRestrictionList, m_pRestrictionUIEntry ? m_pRestrictionUIEntry->strGroupID : _T(""), this);
    if (dlg.DoModal() == IDOK)
    {
        // Get the filename that they entered
        // and add it to our list.
        CString strReturnFileName;
        strReturnFileName = dlg.m_strFileName; 
        {
            // Get the Status
            int iMyStatus = WEBSVCEXT_STATUS_PROHIBITED;
            {
                POSITION pos;
                CString TheKey;
                CRestrictionEntry * pOneEntry = NULL;
                for(pos = m_MyRestrictionList.GetStartPosition();pos != NULL;)
                {
                    m_MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
                    if (pOneEntry)
                    {
                        if (WEBSVCEXT_STATUS_ALLOWED == pOneEntry->iStatus)
                        {
                            iMyStatus = WEBSVCEXT_STATUS_ALLOWED;
                            break;
                        }
                    }
                }
            }

            CRestrictionEntry * pNewEntry = CreateRestrictionEntry(
                strReturnFileName,
                iMyStatus,
                1,
                m_pRestrictionUIEntry ? m_pRestrictionUIEntry->strGroupID : _T(""),          // from parent data
                m_pRestrictionUIEntry ? m_pRestrictionUIEntry->strGroupDescription : _T(""), // from parent data
                WEBSVCEXT_TYPE_REGULAR);
            if (pNewEntry)
            {
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey=pNewEntry->strFileName;strKey.MakeUpper();
                m_MyRestrictionList.SetAt(strKey,pNewEntry);
                FillListBox(pNewEntry);
            }
        }
     }

    SetControlState();
    SetModified(TRUE);
}

void
CWebServiceExtensionRequiredFiles::OnDoButtonRemove()
{
    int nCurSel = m_list_Files.GetSelectionMark();
    if (-1 != nCurSel)
    {
        CString TheKey;
        CRestrictionEntry * pRestrictionEntry = m_list_Files.GetItem(nCurSel);
        if (pRestrictionEntry)
        {
            // 1st -- set to disabled...
            pRestrictionEntry->iStatus = WEBSVCEXT_STATUS_PROHIBITED;
            m_list_Files.SetListItem(nCurSel, pRestrictionEntry);
            // then remove the entry...
            {
                TheKey = pRestrictionEntry->strFileName;
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				TheKey.MakeUpper();
                m_MyRestrictionList.RemoveKey(TheKey);
            }
        }
        FillListBox(NULL);

        int count = m_list_Files.GetItemCount();
        if (count > 0)
        {
            m_list_Files.SelectItem(nCurSel < count ? nCurSel : --nCurSel);
            GetDlgItem(IDC_BTN_REMOVE)->SetFocus();
        }
        else
        {
            m_list_Files.SelectItem(nCurSel, FALSE);
            GetDlgItem(IDC_LIST_FILES)->SetFocus();
        }

		SetModified(TRUE);
        SetControlState();
    }
}

void
CWebServiceExtensionRequiredFiles::OnDoButtonEnable()
{
    int nCurSel = m_list_Files.GetSelectionMark();
    if (-1 != nCurSel)
    {
        CRestrictionEntry * pRestrictionEntry = m_list_Files.GetItem(nCurSel);
        if (pRestrictionEntry)
        {
            if (WEBSVCEXT_STATUS_ALLOWED != pRestrictionEntry->iStatus)
            {
                pRestrictionEntry->iStatus = WEBSVCEXT_STATUS_ALLOWED;
                SetModified(TRUE);
            }
            m_list_Files.SetListItem(nCurSel, pRestrictionEntry);
            // make sure to select it.
            m_list_Files.SelectItem(nCurSel, TRUE);
        }
        SetControlState();
    }
}

void
CWebServiceExtensionRequiredFiles::OnDoButtonDisable()
{
    BOOL bProceed = TRUE;
    int nCurSel = m_list_Files.GetSelectionMark();
    if (-1 != nCurSel)
    {
        CRestrictionEntry * pRestrictionEntry = m_list_Files.GetItem(nCurSel);
        if (pRestrictionEntry)
        {
            if (WEBSVCEXT_TYPE_REGULAR == pRestrictionEntry->iType)
            {
                // Check if this item has apps that
                // are dependent upon it.
                CStringListEx strlstDependApps;
                if (TRUE == ReturnDependentAppsList(m_pInterface,pRestrictionEntry->strGroupID,&strlstDependApps,FALSE))
                {
                    bProceed = FALSE;

                    // check if they really want to do this.
                    CDepedentAppsDlg dlg(&strlstDependApps,pRestrictionEntry->strGroupDescription,NULL);
                    if (dlg.DoModal() == IDOK)
                    {
                        bProceed = TRUE;
                    }
                }
            }

            if (bProceed)
            {
                if (WEBSVCEXT_STATUS_PROHIBITED != pRestrictionEntry->iStatus)
                {
                    pRestrictionEntry->iStatus = WEBSVCEXT_STATUS_PROHIBITED;
                    SetModified(TRUE);
                }
                m_list_Files.SetListItem(nCurSel, pRestrictionEntry);
                // make sure to select it.
                m_list_Files.SelectItem(nCurSel, TRUE);
            }
        }
        SetControlState();
    }
}

//
// properties
//
CWebServiceExtensionProps::CWebServiceExtensionProps(
   CMetaInterface * pInterface, 
   LPCTSTR meta_path, 
   CRestrictionUIEntry * pRestrictionUIEntry, 
   CWebServiceExtension * pWebServiceExtension
   )
   : CMetaProperties(pInterface, meta_path),
   m_pRestrictionUIEntry(pRestrictionUIEntry),
   m_pWebServiceExtension(pWebServiceExtension)
{
    m_MyRestrictionList.RemoveAll();
    m_pInterface = pInterface;
}

CWebServiceExtensionProps::~CWebServiceExtensionProps()
{
    CleanRestrictionList(&m_MyRestrictionList);
}

//
// This is where the values get read from the metabase
//
void
CWebServiceExtensionProps::ParseFields()
{
    // Get the data out from our passed in format.
    CRestrictionUIEntry * pMyPointer = m_pRestrictionUIEntry;
    CString strAllEntries;
    CString strOurGroupID;

    strOurGroupID = pMyPointer->strGroupID;
    //
    //  General property
    //
    m_strExtensionName = pMyPointer->strGroupDescription;
    m_strExtensionUsedBy = _T("");
    m_iExtensionUsedByCount = 0;

    // Load Applications which are using this GroupID!!!
    // fetch the list from the metabase and loop thru the list
    CStringListEx strlstDependApps;
    if (TRUE == ReturnDependentAppsList(m_pWebServiceExtension->QueryInterface(),strOurGroupID,&strlstDependApps,FALSE))
    {
        CString csOneEntry,csOneEntry2;
        POSITION pos,pos2 = NULL;

        int count = (int) strlstDependApps.GetCount();
        for (int i = 0; i < count-1; i++)
        {
            if( ( pos = strlstDependApps.FindIndex( i )) != NULL )
            {
                csOneEntry = strlstDependApps.GetAt(pos);
                for (int j = i; j < count; j++ )
                {
                    if( ( pos2 = strlstDependApps.FindIndex( j )) != NULL )
                    {
                        csOneEntry2 = strlstDependApps.GetAt(pos2);
                        if (0 < csOneEntry.Compare(csOneEntry2))
                        {
                            strlstDependApps.SetAt( pos, csOneEntry2 );
                            strlstDependApps.SetAt( pos2, csOneEntry );
                            csOneEntry = csOneEntry2;
                        }
                    }
                }
            }
        }

        m_iExtensionUsedByCount = count;
    }

    POSITION pos1 = strlstDependApps.GetHeadPosition();
    while (pos1)
    {
        strAllEntries = strAllEntries + strlstDependApps.GetNext(pos1);
        strAllEntries = strAllEntries + _T("\r\n");
    }

    if (strAllEntries.IsEmpty())
    {
        strAllEntries.LoadString(IDS_UNKNOWN);
    }
    m_strExtensionUsedBy = strAllEntries;

    //
    //  Required Files propety
    //
    m_MyRestrictionList.RemoveAll();
    RestrictionListCopy(&m_MyRestrictionList,&pMyPointer->strlstRestrictionEntries);

    return;
}

HRESULT
CWebServiceExtensionProps::UpdateMMC(DWORD dwUpdateFlag)
{
	void ** ppParam = (void **) m_pWebServiceExtension;
	if (IsValidAddress( (const void*) *ppParam,sizeof(void*),FALSE))
	{
		CWebServiceExtension * lParam = (CWebServiceExtension *) m_pWebServiceExtension;
		if (lParam)
		{
			// Make sure to refresh the GetProperty stuff too..
			// this will be done in the destructor, so we don't have to do it here
			if (lParam)
			{
				// caution
				if (IsValidAddress( (const void*) lParam->m_ppHandle,sizeof(void*),FALSE))
				{
					if (lParam->QueryResultItem())
					{
						// RefreshData at the container level
						// will sync up everything.
						lParam->m_UpdateFlag = dwUpdateFlag; //PROP_CHANGE_DISPLAY_ONLY;
						MMCPropertyChangeNotify(lParam->m_ppHandle, (LPARAM) lParam);
					}
					else
					{
                        TRACEEOLID("MMCPropertyChangeNotify:Looks like this is an orphaned property sheet, don't send notification...\r\n");
					}
	                
				}
			}
		}
	}
	return S_OK;
}
//
// This is where the values get written to the metabase
//
HRESULT
CWebServiceExtensionProps::WriteDirtyProps()
{
	CError err;
    CRestrictionUIList MasterRestrictionUIList;
    CRestrictionUIEntry NewUIEntry;
    CMetaInterface * pInterface = m_pInterface;

    // Get the data out from our passed in format.
    CRestrictionUIEntry * pMyPointer = m_pRestrictionUIEntry;
    if (!pMyPointer)
    {
        return E_POINTER;
    }

    NewUIEntry.iType = pMyPointer->iType;
    NewUIEntry.strGroupID = pMyPointer->strGroupID;
    NewUIEntry.strGroupDescription = m_strExtensionName;

    // if there is restrictionlist entries
    // then add it to the new entry we are going to write to the metabase.
    {
        POSITION pos;
        CString TheKey;
        CRestrictionEntry * pOneEntry = NULL;
        for(pos = m_MyRestrictionList.GetStartPosition();pos != NULL;)
        {
            m_MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
            if (pOneEntry)
            {
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				TheKey.MakeUpper();
                NewUIEntry.strlstRestrictionEntries.SetAt(TheKey,pOneEntry);
            }
        }

        pMyPointer->strGroupDescription = m_strExtensionName;

        // Check if we still have the interface to the metabase...
        if (pInterface)
        {
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,pInterface,METABASE_PATH_FOR_RESTRICT_LIST);
            if (err.Failed())
            {
                goto WriteDirtyProps_Exit;
            }
        }
        if (SUCCEEDED(LoadMasterUIWithoutOldEntry(pInterface,&MasterRestrictionUIList,pMyPointer)))
        {
            if (m_MyRestrictionList.IsEmpty())
            {
                // if there are no restrictionlist entries...
                // then we don't have an entry... remove it
                AddRestrictUIEntryToRestrictUIList(&MasterRestrictionUIList,NULL);
            }
            else
            {
                AddRestrictUIEntryToRestrictUIList(&MasterRestrictionUIList,&NewUIEntry);
            }

            // Merge our changes with the master list!!!!!
            // 1. read the master list.
            // 2. merge our changes into it.
            // 3. write out the master list.
            // 4. update the UI.
            CStringListEx strlstReturned;
            if (SUCCEEDED(PrepRestictionUIListForWrite(&MasterRestrictionUIList,&strlstReturned)))
            {
                // Write out the strlstReturned to the metabase.
                err = OpenForWriting(FALSE);
                if (err.Succeeded())
                {
                    err = SetValue(MD_WEB_SVC_EXT_RESTRICTION_LIST, strlstReturned);
                    Close();
                }

                if (err.Succeeded())
                {
                    // update the UI with the changed value
                    // 1. remove the UI's old value
                    // 2. add in the new value to the UI
                    //
                    // get the list of extensions
                    // update our entry or delete our entry...

                    // copy new value into existing place.
                    // this will clean out the existing place's objects...
					UpdateMMC(0);
                }
            }
        }
    }

WriteDirtyProps_Exit:
    //m_Dirty = err.Succeeded();
	return err;
}


// -----------------------------------------------------------
CFileDlg::CFileDlg(
    IN BOOL fLocal,
	IN CMetaInterface * pInterface,
	IN CRestrictionList * pMyRestrictionList,
    IN LPCTSTR strGroupID,
    IN CWnd * pParent OPTIONAL
    )
    : CDialog(CFileDlg::IDD, pParent),
      m_fLocal(fLocal)
{
    //{{AFX_DATA_INIT(CFileDlg)
    m_strFileName = _T("");
	m_pInterface = pInterface;
    m_strGroupID = strGroupID;
	m_pRestrictionList = pMyRestrictionList;
    m_bValidateFlag = FALSE;
    //}}AFX_DATA_INIT
}

void 
CFileDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFileDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_FILENAME, m_edit_FileName);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_FILENAME, m_strFileName);
    if (pDX->m_bSaveAndValidate)
    {
        DDV_MaxCharsBalloon(pDX, m_strFileName, 255);

        int iErrorMsg = 0;
		m_strFileName.TrimLeft();m_strFileName.TrimRight();
        CString csPathMunged;
        csPathMunged = m_strFileName;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
        GetSpecialPathRealPath(0,m_strFileName,csPathMunged);
#endif
        
	    //DDV_FilePath(pDX, csPathMunged, m_fLocal);

		// if this is a path/filename without a .ext then remove any period from the end.
		// check if it ends with a period.
		if (csPathMunged.Right(1) == _T("."))
		{
			TCHAR szFilename_ext_only[_MAX_EXT];
			_tsplitpath(csPathMunged, NULL, NULL, NULL, szFilename_ext_only);
			if (szFilename_ext_only)
			{
				if (0 == _tcscmp(szFilename_ext_only,_T(".")))
				{
					csPathMunged.TrimRight(_T("."));
				}
			}
		}

        DWORD dwAllowedFlags = CHKPATH_ALLOW_UNC_PATH;
        DWORD dwCharsetFlags = CHKPATH_CHARSET_GENERAL;
        dwCharsetFlags |= CHKPATH_CHARSET_GENERAL_NO_COMMA;
        FILERESULT dwReturn = MyValidatePath(csPathMunged,m_fLocal,CHKPATH_WANT_FILE,dwAllowedFlags,dwCharsetFlags);
        if (FAILED(dwReturn))
        {
            iErrorMsg = IDS_WEBSVCEXT_INVALID_FILENAME_FORMAT;
            if (IS_FLAG_SET(dwReturn,CHKPATH_FAIL_INVALID_CHARSET))
            {
                iErrorMsg = IDS_WEBSVCEXT_INVALID_FILENAME_CHARS;
            }
            else
            {
                if (dwReturn == CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST)
                {
                    iErrorMsg = IDS_ERR_PATH_NOT_FOUND;
                }
            }
        }
        else
        {
            // check for % character
		    // there must be at least 2
		    TCHAR * pChar = NULL;
		    pChar = _tcschr(csPathMunged, _T('%'));
		    if (pChar)
            {
			    pChar++;
			    pChar = _tcschr(pChar, _T('%'));
			    if (pChar)
			    {
				    TRACEEOL("Path:Warn if percent character");
				    iErrorMsg = IDS_WEBSVCEXT_INVALID_PERCENT_WARNING;
			    }
            }
        }

        // Check for invalid characters
        if (0 != iErrorMsg)
        {
            if (IDS_WEBSVCEXT_INVALID_PERCENT_WARNING == iErrorMsg)
            {
                // For some reason, we need this
                // flag so that we don't show the message twice...
                if (!m_bValidateFlag)
                {
                    if (IDCANCEL == ::AfxMessageBox(IDS_WEBSVCEXT_INVALID_PERCENT_WARNING,MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2))
                    {
                        m_bValidateFlag = FALSE;
                        pDX->Fail();
                    }
                    else
                    {
                        // ensure user doesn't see the 2nd msgbox
                        m_bValidateFlag = TRUE;
                    }
                }
                else
                {
                    // flip it back on
                    m_bValidateFlag = FALSE;
                }
            }
            else if (IDS_WEBSVCEXT_INVALID_FILENAME_CHARS == iErrorMsg)
            {
                // formulate the real error message
                CString strMsg;
                CString strTempList;
                CComBSTR strTempFormat;
                strTempFormat.LoadString(IDS_WEBSVCEXT_INVALID_FILENAME_CHARS);
                LoadStatics();
                strTempList = _T(":");
                strTempList += g_InvalidWebSvcExtCharsPath;
                strMsg.Format(strTempFormat,strTempList);
                DDV_ShowBalloonAndFail(pDX, strMsg);
                m_bValidateFlag = FALSE;
            }
            else
            {
                DDV_ShowBalloonAndFail(pDX, iErrorMsg);
                m_bValidateFlag = FALSE;
            }
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFileDlg, CDialog)
    //{{AFX_MSG_MAP(CFileDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_EN_CHANGE(IDC_EDIT_FILENAME, OnFilenameChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
HRESULT AFXAPI
MyLimitInputPath(HWND hWnd)
{
    CString strMsg;
    CComBSTR strTempFormat;
    strTempFormat.LoadString(IDS_WEBSVCEXT_INVALID_FILENAME_CHARS);
    LoadStatics();
    strMsg.Format(strTempFormat,g_InvalidWebSvcExtCharsPath);
    
    LIMITINPUT li   = {0};
    li.cbSize       = sizeof(li);
    li.dwMask       = LIM_FLAGS | LIM_FILTER | LIM_MESSAGE | LIM_HINST;
    li.dwFlags      = LIF_EXCLUDEFILTER | LIF_HIDETIPONVALID | LIF_PASTESKIP;
    li.hinst        = _Module.GetResourceInstance();
    // don't ask me why, but when we use this
    // it truncates it to like 80 chars.
    // specifying an actual string allows more than 80
    //li.pszMessage  = MAKEINTRESOURCE(IDS_WEBSVCEXT_INVALID_FILENAME_CHARS);
    li.pszMessage   = (LPTSTR) (LPCTSTR) strMsg;
    li.pszFilter    = g_InvalidWebSvcExtCharsPath;

	return SHLimitInputEditWithFlags(hWnd, &li);
}

HRESULT AFXAPI
MyLimitInputName(HWND hWnd)
{
    CComBSTR strTempString;
    strTempString.LoadString(IDS_WEBSVCEXT_INVALID_NAME_CHARS);
    LoadStatics();

    LIMITINPUT li   = {0};
    li.cbSize       = sizeof(li);
    li.dwMask       = LIM_FLAGS | LIM_FILTER | LIM_MESSAGE | LIM_HINST;
    li.dwFlags      = LIF_EXCLUDEFILTER | LIF_HIDETIPONVALID | LIF_PASTESKIP;
    li.hinst        = _Module.GetResourceInstance();
    // don't ask me why, but when we use this
    // it truncates it to like 80 chars.
    // specifying an actual string allows more than 80
    //li.pszMessage  = MAKEINTRESOURCE(IDS_WEBSVCEXT_INVALID_NAME_CHARS);
    li.pszMessage   = strTempString;
    li.pszFilter    = g_InvalidWebSvcExtCharsName;
    
	return SHLimitInputEditWithFlags(hWnd, &li);
}

BOOL 
CFileDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    //
    // Available on local connections only
    //
    m_button_Browse.EnableWindow(m_fLocal);

    MySetControlStates();
    MyLimitInputPath(CONTROL_HWND(IDC_EDIT_FILENAME));
    return TRUE;
}

void 
CFileDlg::OnButtonBrowse() 
{
    ASSERT(m_fLocal);

    CString strFileMask((LPCTSTR)IDS_ISAPI_CGI_MASK);

    //
    // CODEWORK: Derive a class from CFileDialog that allows
    // the setting of the initial path
    //

    //CString strPath;
    //m_edit_FileName.GetWindowText(strPath);
    CFileDialog dlgBrowse(
        TRUE, 
        NULL, 
        NULL, 
        OFN_HIDEREADONLY, 
        strFileMask, 
        this
        );
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

	INT_PTR rc = dlgBrowse.DoModal();
    if (rc == IDOK)
    {
        m_edit_FileName.SetWindowText(dlgBrowse.GetPathName());
    }
	else if (rc == IDCANCEL)
	{
		DWORD err = CommDlgExtendedError();
	}

    OnItemChanged();
}

void 
CFileDlg::MySetControlStates()
{
    m_button_Ok.EnableWindow(m_edit_FileName.GetWindowTextLength() > 0);
}

void
CFileDlg::OnItemChanged()
{
    MySetControlStates();
}

void
CFileDlg::OnFilenameChanged()
{
    OnItemChanged();
}

BOOL
CFileDlg::FilePathEntryExists(
    IN LPCTSTR lpName,
    IN OUT CString * strUser
    )
/*++

Routine Description:

    Look for a given filename in the list

Arguments:

    LPCTSTR lpName  : filename name to look for

Return Value:

    TRUE if the name already existed in the metabase

--*/
{
    // Loop thru to ensure that this specified path\filename
    // isn't already being used in the metabase by
    // a different entry.
    return IsFileUsedBySomeoneElse(m_pInterface, lpName, m_strGroupID,strUser);
}

void 
CFileDlg::OnOK() 
{
    if (UpdateData(TRUE))
    {
		BOOL bInUseAlready = FALSE;

		// Make sure the filname is unique
		// within our own entry!
		if (!m_strFileName.IsEmpty())
		{
			CString strUser;
			CRestrictionEntry * pOneRestrictEntry = NULL;

			pOneRestrictEntry = NULL;
			if (m_pRestrictionList)
			{
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey=m_strFileName;strKey.MakeUpper();
				m_pRestrictionList->Lookup(strKey,(CRestrictionEntry *&) pOneRestrictEntry);
				if (pOneRestrictEntry)
				{
					bInUseAlready = TRUE;
					CComBSTR strMessage;
				
					strMessage.LoadString(IDS_DUPLICATE_ENTRY);
					EditShowBalloon(m_edit_FileName.m_hWnd, (CString) strMessage);
				}
			}
		}

        //
        // Make sure the filename is unique
        //
		if (FALSE == bInUseAlready)
		{
			CString strUser;
			if (FilePathEntryExists(m_strFileName,&strUser))
			{
				bInUseAlready = TRUE;

				CString strMessage;
				CComBSTR strFormat;
				strFormat.LoadString(IDS_WEBSVCEXT_NOT_UNIQUE);
				strMessage.Format(strFormat,strUser);
				EditShowBalloon(m_edit_FileName.m_hWnd, strMessage);
			}
		}

		// Everything okay
		if (!bInUseAlready)
		{
			CDialog::OnOK();
		}
    }

    //
    // Don't dismiss the dialog
    //
}



// -----------------------------------------------------------
CWebSvcExtAddNewDlg::CWebSvcExtAddNewDlg(
    IN BOOL fLocal,
	IN CMetaInterface * pInterface,
    IN CWnd * pParent OPTIONAL
    )
    : CDialog(CWebSvcExtAddNewDlg::IDD, pParent),
      m_fIsLocal(fLocal)
{
    //{{AFX_DATA_INIT(CWebSvcExtAddNewDlg)
    m_strGroupName = _T("");
    m_fAllow = FALSE;
	m_pInterface = pInterface;
    m_MyRestrictionList.RemoveAll();
    //}}AFX_DATA_INIT
}

CWebSvcExtAddNewDlg::~CWebSvcExtAddNewDlg()
{
    CleanRestrictionList(&m_MyRestrictionList);
}

void 
CWebSvcExtAddNewDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWebSvcExtAddNewDlg)
    DDX_Control(pDX, IDC_EDIT_EXTENSION_NAME, m_edit_FileName);
    DDX_Control(pDX, IDC_BTN_ADD, m_bnt_Add);
    DDX_Control(pDX, IDC_BTN_REMOVE, m_bnt_Remove);
    DDX_Control(pDX, IDC_CHECK_ALLOW, m_chk_Allow);
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, ID_HELP, m_button_Help);
    //}}AFX_DATA_MAP

	DDX_Text(pDX, IDC_EDIT_EXTENSION_NAME, m_strGroupName);
    DDX_Control(pDX, IDC_LIST_FILES, m_list_Files);

	if (pDX->m_bSaveAndValidate)
	{
        m_strGroupName.TrimLeft();
        m_strGroupName.TrimRight();

		DDV_MinMaxChars(pDX, m_strGroupName, 1, 256);
		if (m_strGroupName.GetLength() > 256){DDV_ShowBalloonAndFail(pDX, IDS_ERR_INVALID_PATH /*IDS_BAD_URL_PATH*/ );}
	}
    //if (pDX->m_bSaveAndValidate){DDV_FilePath(pDX, m_strGroupName, m_fLocal);}
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebSvcExtAddNewDlg, CDialog)
    //{{AFX_MSG_MAP(CWebSvcExtAddNewDlg)
    ON_EN_CHANGE(IDC_EDIT_EXTENSION_NAME, OnFilenameChanged)
    ON_BN_CLICKED(IDC_BTN_ADD, OnDoButtonAdd)
    ON_BN_CLICKED(IDC_BTN_REMOVE, OnDoButtonRemove)
    ON_BN_CLICKED(IDC_CHECK_ALLOW, OnDoCheckAllow)
    ON_NOTIFY(NM_CLICK, IDC_LIST_FILES, OnClickListFiles)
	ON_NOTIFY(LVN_KEYDOWN, IDC_LIST_FILES, OnKeydownListFiles)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_FILES, OnSelChangedListFiles)
    ON_NOTIFY(LVN_BEGINDRAG, IDC_LIST_FILES, OnSelChangedListFiles)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BOOL 
CWebSvcExtAddNewDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();
    m_list_Files.Initialize(1);
    m_fAllow = FALSE;

    m_chk_Allow.SetCheck(m_fAllow);
    MySetControlStates();
    MyLimitInputName(CONTROL_HWND(IDC_EDIT_EXTENSION_NAME));
    return TRUE;
}

BOOL
CWebSvcExtAddNewDlg::OnHelpInfo(HELPINFO * pHelpInfo)
{
    OnHelp();
    return TRUE;
}

void
CWebSvcExtAddNewDlg::OnHelp()
{
    WinHelpDebug(0x20000 + CWebSvcExtAddNewDlg::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CWebSvcExtAddNewDlg::IDD);
}

void 
CWebSvcExtAddNewDlg::MySetControlStates()
{
    m_edit_FileName.EnableWindow(TRUE);
    m_bnt_Add.EnableWindow(TRUE);
    m_list_Files.EnableWindow(TRUE);

    // Enable Remove only if there is something selected...
    int nCurSel = m_list_Files.GetSelectionMark();
    if (-1 != nCurSel)
    {
        m_bnt_Remove.EnableWindow(TRUE);
    }
    else
    {
        m_bnt_Remove.EnableWindow(FALSE);
    }

    // Enable OK only if there is a filename
    // and at least one entry in the list box
    int nCount = m_list_Files.GetItemCount();
    if (nCount > 0)
    {
        m_button_Ok.EnableWindow(m_edit_FileName.GetWindowTextLength() > 0);
    }
    else
    {
        m_button_Ok.EnableWindow(FALSE);
    }

    m_fAllow = m_chk_Allow.GetCheck();
}

void
CWebSvcExtAddNewDlg::OnItemChanged()
{
    MySetControlStates();
}

void
CWebSvcExtAddNewDlg::OnFilenameChanged()
{
    OnItemChanged();
}

BOOL
CWebSvcExtAddNewDlg::FilePathEntryExists(
    IN LPCTSTR lpName
    )
{
    // Loop thru to ensure that this specified GroupID
    // isn't already being used in the metabase by
    // a different entry.
    return IsGroupIDUsedBySomeoneElse(m_pInterface, lpName);
}

void 
CWebSvcExtAddNewDlg::OnOK() 
{
    if (UpdateData(TRUE))
    {
        //
        // Make sure the group name is unique
        //
        if (FilePathEntryExists(m_strGroupName))
        {
			EditShowBalloon(m_edit_FileName.m_hWnd, IDS_WEBSVCEXT_ID_NOT_UNIQUE);
            return;
        }
        CDialog::OnOK();
    }
}

void
CWebSvcExtAddNewDlg::OnDoCheckAllow()
{
    m_fAllow = !m_fAllow;
    OnItemChanged();
    MySetControlStates();
}

void
CWebSvcExtAddNewDlg::OnDoButtonAdd()
{
    int nCurSel = m_list_Files.GetSelectionMark();
    CFileDlg dlg(m_fIsLocal, m_pInterface, &m_MyRestrictionList, _T(""), this);
    if (dlg.DoModal() == IDOK)
    {
        // Get the filename that they entered
        // and add it to our list.
        CString strReturnFileName;
        strReturnFileName = dlg.m_strFileName; 
        {
            CRestrictionEntry * pNewEntry = CreateRestrictionEntry(
                strReturnFileName,
                WEBSVCEXT_STATUS_ALLOWED, // doesn't matter we won't use what gets set here..
                1,                        // doesn't matter we won't use what gets set here..
                _T(""),
                _T(""),
                WEBSVCEXT_TYPE_REGULAR    // doesn't matter we won't use what gets set here..
                );
            if (pNewEntry)
            {
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey=pNewEntry->strFileName;strKey.MakeUpper();
                m_MyRestrictionList.SetAt(strKey,pNewEntry);

                FillListBox(pNewEntry);
            }
        }
     }

    MySetControlStates();
}

void
CWebSvcExtAddNewDlg::OnDoButtonRemove()
{
    int nCurSel = m_list_Files.GetSelectionMark();
    if (-1 != nCurSel)
    {
        CString TheKey;
        CRestrictionEntry * pRestrictionEntry = m_list_Files.GetItem(nCurSel);
        if (pRestrictionEntry)
        {
            // remove the entry...
            {
                TheKey = pRestrictionEntry->strFileName;
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				TheKey.MakeUpper();
                m_MyRestrictionList.RemoveKey(TheKey);
            }
        }
        FillListBox(NULL);

        int count = m_list_Files.GetItemCount();
        if (count > 0)
        {
            m_list_Files.SelectItem(nCurSel < count ? nCurSel : --nCurSel);
            GetDlgItem(IDC_BTN_REMOVE)->SetFocus();
        }
        else
        {
            m_list_Files.SelectItem(nCurSel, FALSE);
            GetDlgItem(IDC_LIST_FILES)->SetFocus();
        }

        MySetControlStates();
    }
}

void 
CWebSvcExtAddNewDlg::OnClickListFiles(NMHDR * pNMHDR, LRESULT * pResult)
{
    MySetControlStates();
    *pResult = 0;
}

void 
CWebSvcExtAddNewDlg::OnKeydownListFiles(NMHDR * pNMHDR, LRESULT* pResult) 
{
	LV_KEYDOWN * pLVKeyDow = (LV_KEYDOWN *)pNMHDR;

	MySetControlStates();

	switch (pLVKeyDow->wVKey)
	{
		case VK_INSERT:
			SendMessage(WM_COMMAND, IDC_BTN_ADD);
			break;
		case VK_DELETE:
			SendMessage(WM_COMMAND, IDC_BTN_REMOVE);
			break;
		default:
			// Continue default action
			*pResult = 0;
			break;
	}
}

void
CWebSvcExtAddNewDlg::OnSelChangedListFiles(NMHDR* pNMHDR, LRESULT* pResult) 
{
	MySetControlStates();
    *pResult = 1;
}

void
CWebSvcExtAddNewDlg::FillListBox(CRestrictionEntry * pSelection)
{
    m_list_Files.SetRedraw(FALSE);
    m_list_Files.DeleteAllItems();
    int cItems = 0;

    POSITION pos;
    CString TheKey;
    CRestrictionEntry * pOneEntry = NULL;

    for(pos = m_MyRestrictionList.GetStartPosition();pos != NULL;)
    {
        m_MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
        if (pOneEntry)
        {
            m_list_Files.AddItem(pOneEntry);
            ++cItems;
        }
    }
    m_list_Files.SetRedraw(TRUE);

    if (pSelection)
    {
        LVFINDINFO fi;
        fi.flags = LVFI_PARAM;
        fi.lParam = (LPARAM)pSelection;
        fi.vkDirection = VK_DOWN;
        int i = m_list_Files.FindItem(&fi);
        if (i != -1)
        {
            m_list_Files.SelectItem(i);
        }
    }
}


// -----------------------------------------------------------

CWebSvcExtAddNewForAppDlg::CWebSvcExtAddNewForAppDlg(
    IN BOOL fLocal,
    IN CMetaInterface * pInterface,
    IN CWnd * pParent OPTIONAL
    )
    : CDialog(CWebSvcExtAddNewForAppDlg::IDD, pParent),
      m_fLocal(fLocal)
{
    //{{AFX_DATA_INIT(CWebSvcExtAddNewForAppDlg)
    m_pMySelectedApplication = NULL;
    m_nComboSelection = -1;
    m_pInterface = pInterface;
    //}}AFX_DATA_INIT
}

void 
CWebSvcExtAddNewForAppDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWebSvcExtAddNewForAppDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, ID_HELP, m_button_Help);
    DDX_CBIndex(pDX, IDC_COMBO_APPLICATION, m_nComboSelection);
    DDX_Control(pDX, IDC_COMBO_APPLICATION, m_combo_Applications);
    DDX_Control(pDX, IDC_DEPENDENCIES_TXT, m_Dependencies);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebSvcExtAddNewForAppDlg, CDialog)
    //{{AFX_MSG_MAP(CWebSvcExtAddNewForAppDlg)
    ON_CBN_SELCHANGE(IDC_COMBO_APPLICATION, OnSelchangeComboApplications)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BOOL 
CWebSvcExtAddNewForAppDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    m_combo_Applications.SetRedraw(FALSE);
    m_combo_Applications.ResetContent();

    // fetch the list from the
    // metabase and loop thru the list
    CApplicationDependList MyMasterList;
    if (SUCCEEDED(LoadApplicationDependList(m_pInterface,&MyMasterList,TRUE)))
    {
        // loop thru the returned back list
        int TheIndex;
        POSITION pos;
        CString TheKey;
        CApplicationDependEntry * pOneEntry = NULL;
        for(pos = MyMasterList.GetStartPosition();pos != NULL;)
        {
            MyMasterList.GetNextAssoc(pos, TheKey, (CApplicationDependEntry *&) pOneEntry);
            if (pOneEntry)
            {
                TheIndex = m_combo_Applications.AddString(pOneEntry->strApplicationName);
                if (TheIndex != CB_ERR)
                {
                    m_combo_Applications.SetItemDataPtr(TheIndex, pOneEntry);
                }
            }
        }
    }

    // Load Mapping for GroupID to friendlyName
    LoadApplicationFriendlyNames(m_pInterface,&m_GroupIDtoGroupFriendList);

    m_combo_Applications.EnableWindow(TRUE);
    m_combo_Applications.SetRedraw(TRUE);
	m_combo_Applications.SetCurSel(m_nComboSelection);

	// Highlight the 1st selection...
	if (-1 == m_nComboSelection)
	{
		m_nComboSelection = m_combo_Applications.GetCount();
		if (m_nComboSelection >= 0)
		{
			m_combo_Applications.SetCurSel(0);
			OnSelchangeComboApplications();
		}
	}

	MySetControlStates();
    return TRUE;
}

BOOL
CWebSvcExtAddNewForAppDlg::OnHelpInfo(HELPINFO * pHelpInfo)
{
    OnHelp();
    return TRUE;
}

void
CWebSvcExtAddNewForAppDlg::OnHelp()
{
    WinHelpDebug(0x20000 + CWebSvcExtAddNewForAppDlg::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CWebSvcExtAddNewForAppDlg::IDD);
}

void 
CWebSvcExtAddNewForAppDlg::MySetControlStates()
{
    m_Dependencies.SetReadOnly(TRUE);
    int nSel = m_combo_Applications.GetCurSel();
    if (-1 == nSel)
    {
        m_button_Ok.EnableWindow(FALSE);
    }
    else
    {
        m_button_Ok.EnableWindow(TRUE);
    }
}

void
CWebSvcExtAddNewForAppDlg::OnSelchangeComboApplications()
{
    int nSel = m_combo_Applications.GetCurSel();
    if (m_nComboSelection == nSel)
    {
        //
        // Selection didn't change
        //
        return;
    }

    m_nComboSelection = nSel;

    int idx = m_combo_Applications.GetCurSel();
    if (idx != -1)
    {
        m_Dependencies.SetWindowText(_T(""));

        CApplicationDependEntry * pOneEntry = NULL;
        CString strOneFriendly;
        CString strOneGroupID;
        CString strAllEntries;
        pOneEntry = (CApplicationDependEntry *) m_combo_Applications.GetItemDataPtr(idx);
        if (pOneEntry)
        {
            // dump out our info.
            POSITION pos = pOneEntry->strlistGroupID.GetHeadPosition();
            while (pos)
            {
                strOneGroupID = pOneEntry->strlistGroupID.GetNext(pos);
                // replace ID with friendly string
                strOneFriendly = _T("");
				// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
				CString strKey;strKey=strOneGroupID;strKey.MakeUpper();
                m_GroupIDtoGroupFriendList.Lookup(strKey,strOneFriendly);
                if (strOneFriendly.IsEmpty())
                {
                    strAllEntries = strAllEntries + strOneGroupID;
                }
                else
                {
                    strAllEntries = strAllEntries + strOneFriendly;
                }
                strAllEntries = strAllEntries + _T("\r\n");
            }
        }

        m_Dependencies.SetWindowText(strAllEntries);
    }

    MySetControlStates();
}

void 
CWebSvcExtAddNewForAppDlg::OnOK() 
{
    if (UpdateData(TRUE))
    {
        int idx = m_combo_Applications.GetCurSel();
        if (idx != -1)
        {
            CApplicationDependEntry * pOneEntry = NULL;
            pOneEntry = (CApplicationDependEntry *) m_combo_Applications.GetItemDataPtr(idx);
            m_pMySelectedApplication = pOneEntry;
        }
        CDialog::OnOK();
    }
}

BOOL StartAddNewDialog(CWnd * pParent,CMetaInterface * pInterface,BOOL bIsLocal,CRestrictionUIEntry **pReturnedNewEntry)
{
    BOOL bRet = FALSE;
    CError err;
    CWebSvcExtAddNewDlg dlg(bIsLocal, pInterface, pParent);
    *pReturnedNewEntry = NULL;

    if (dlg.DoModal() == IDOK)
    {
        BOOL bPleaseUpdateMetabase = FALSE;
        CRestrictionList MasterRestrictionList;
        CString strReturnGroupName = dlg.m_strGroupName;
        BOOL bReturnedAllowStatus = dlg.m_fAllow;
        // get the data from the modal dialog
        // and create a new entry...
        // also, add the entry to the metabase
        // and update the UI

        // Create a new UI entry for the UI
        // if all of this is successfull...

        // update the UI
        CRestrictionUIEntry * pNewUIEntry = new CRestrictionUIEntry;
        if (pNewUIEntry)
        {
            pNewUIEntry->iType = WEBSVCEXT_TYPE_REGULAR;
            // this has to have the EMPTY_GROUPID_KEY part!
            pNewUIEntry->strGroupID = EMPTY_GROUPID_KEY + strReturnGroupName;
            pNewUIEntry->strGroupDescription = strReturnGroupName;
        }

        if (SUCCEEDED(LoadMasterRestrictListWithoutOldEntry(pInterface,&MasterRestrictionList,NULL)))
        {
            // Loop thru the restrictionlist that the had.
            CRestrictionEntry * pOneEntry = NULL;
            CString TheKey;
            POSITION pos;
            for(pos = dlg.m_MyRestrictionList.GetStartPosition();pos != NULL;)
            {
                dlg.m_MyRestrictionList.GetNextAssoc(pos, TheKey, (CRestrictionEntry *&) pOneEntry);
                if (pOneEntry)
                {
                    CRestrictionEntry * pNewEntry = CreateRestrictionEntry(
                        pOneEntry->strFileName,
                        bReturnedAllowStatus ? WEBSVCEXT_STATUS_ALLOWED : WEBSVCEXT_STATUS_PROHIBITED,
                        1,
                        // this has to have the EMPTY_GROUPID_KEY part!
                        EMPTY_GROUPID_KEY + strReturnGroupName,
                        strReturnGroupName,
                        WEBSVCEXT_TYPE_REGULAR); // user can only add regular type entries that are deletable.
                    if (pNewEntry)
                    {
                        // Add our new entry to the "master restrictlist"...
                        AddRestrictEntryToRestrictList(&MasterRestrictionList,pNewEntry);

                        // add it to our new UI entry
						// THE KEY IS ALWAYS UPPERASE -- REMEMBER THIS!!!!!!!
						CString strKey;strKey=pNewEntry->strFileName;strKey.MakeUpper();
                        pNewUIEntry->strlstRestrictionEntries.SetAt(strKey,pNewEntry);
                        bPleaseUpdateMetabase = TRUE;
                    }
                }
            }

            if (bPleaseUpdateMetabase)
            {
                CStringListEx strlstReturned;
                if (SUCCEEDED(PrepRestictionListForWrite(&MasterRestrictionList,&strlstReturned)))
                {
                    // Write out the strlstReturned to the metabase.
                    if (SUCCEEDED(WriteSettingsRestrictionList(pInterface,&strlstReturned)))
                    {
                        bRet = TRUE;
                    }
                }
            }
        }

        if (pNewUIEntry)
        {
            if (bRet)
            {
                // if we have a new ui entry
                // then pass it back
                 *pReturnedNewEntry = pNewUIEntry;
            }
            else
            {
                // clean this entry up 
                delete pNewUIEntry;
                pNewUIEntry = NULL;
            }
        }
    }
    return bRet;
}

BOOL StartAddNewByAppDialog(CWnd * pParent,CMetaInterface * pInterface,BOOL bIsLocal)
{
    BOOL bRet = FALSE;
    CRestrictionList MasterRestrictionList;

    CWebSvcExtAddNewForAppDlg dlg(bIsLocal, pInterface, pParent);
    if (dlg.DoModal() != IDOK)
    {
        goto StartAddNewByAppDialog_Exit;
    }

    // Get the selected Application from the list
    // that they selected.
    if (NULL == dlg.m_pMySelectedApplication)
    {
        goto StartAddNewByAppDialog_Exit;
    }

    int iDesiredState = WEBSVCEXT_STATUS_ALLOWED;
    BOOL bPleaseUpdateMetabase = FALSE;
    CApplicationDependEntry * pOneEntry = dlg.m_pMySelectedApplication;
    if (SUCCEEDED(LoadMasterRestrictListWithoutOldEntry(pInterface,&MasterRestrictionList,NULL)))
    {
        POSITION pos1,pos2;
        CString strOneAppName;
        CRestrictionEntry * pOneRestEntry = NULL;
        CString TheKey;

        // Loop thru the list of GROUPID's
        // that they specified that they want to be enabled...
        pos1 = pOneEntry->strlistGroupID.GetHeadPosition();
        while (pos1)
        {
            strOneAppName = pOneEntry->strlistGroupID.GetNext(pos1);

            // we have a GroupID,
            // let's find all the entries with that entry
            // and update them...
            for(pos2 = MasterRestrictionList.GetStartPosition();pos2 != NULL;)
            {
                pOneRestEntry = NULL;
                MasterRestrictionList.GetNextAssoc(pos2, TheKey, (CRestrictionEntry *&) pOneRestEntry);
                if (pOneRestEntry)
                {
                    // if the GroupID matches, then update it to desired state
                    if (0 == strOneAppName.Compare(pOneRestEntry->strGroupID))
                    {
                        if (WEBSVCEXT_TYPE_REGULAR == pOneRestEntry->iType)
                        {
                            if (pOneRestEntry->iStatus != iDesiredState)
                            {
                                bPleaseUpdateMetabase = TRUE;
                                pOneRestEntry->iStatus = iDesiredState;
                            }
                        }
                    }
                }
            }
        }

        //
        // save the metabase info
        //
        if (bPleaseUpdateMetabase)
        {
            CStringListEx strlstReturned;
            if (SUCCEEDED(PrepRestictionListForWrite(&MasterRestrictionList,&strlstReturned)))
            {
                // Write out the strlstReturned to the metabase.
                if (SUCCEEDED(WriteSettingsRestrictionList(pInterface,&strlstReturned)))
                {
                    bRet = TRUE;
                }
            }
        }

        //
        // resync the UI with the changes.
        //
    }

StartAddNewByAppDialog_Exit:
    return bRet;
}



CDepedentAppsDlg::CDepedentAppsDlg(
    IN CStringListEx * pstrlstDependApps,
    IN LPCTSTR strExtensionName,
    IN CWnd * pParent OPTIONAL
    )
    : CDialog(CDepedentAppsDlg::IDD, pParent),m_pstrlstDependentAppList(NULL)
{
    //{{AFX_DATA_INIT(CDepedentAppsDlg)
    m_strExtensionName = strExtensionName;
    //}}AFX_DATA_INIT

    if (pstrlstDependApps){m_pstrlstDependentAppList = pstrlstDependApps;}
}

void
CDepedentAppsDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDepedentAppsDlg)
    DDX_Control(pDX, ID_HELP, m_button_Help);
    DDX_Control(pDX, IDC_DEPENDENT_APPS_LIST, m_dependent_apps_list);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CDepedentAppsDlg, CDialog)
    //{{AFX_MSG_MAP(CDepedentAppsDlg)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
CDepedentAppsDlg::OnInitDialog()
{
    CString strTempString;
    CString strWarn1;
    CString strWarn2;
    CDialog::OnInitDialog();
    strTempString.Empty();

    // Display the stuff that was passed to us...
    if (m_pstrlstDependentAppList)
    {
        m_dependent_apps_list.SetRedraw(FALSE);
        m_dependent_apps_list.ResetContent();

        CString strOneAppNameEntry;
        POSITION pos = m_pstrlstDependentAppList->GetHeadPosition();
        while (pos)
        {
            strOneAppNameEntry = m_pstrlstDependentAppList->GetNext(pos);

            // add it to the new listbox
            m_dependent_apps_list.AddString(strOneAppNameEntry);
        }

        // Set the Backcolor to read only color.
        //m_dependent_apps_list.SetBack

        m_dependent_apps_list.SetRedraw(TRUE);
    }

    // Formulate text for the static labels..
    strTempString.LoadString(IDS_APP_DEPEND_WARN1);
    strWarn1.Format(strTempString,m_strExtensionName);
    GetDlgItem(IDC_EDIT_WARN1)->SetWindowText(strWarn1);
    if (strWarn1.GetLength() > 200)
    {
        ::ShowScrollBar(CONTROL_HWND(IDC_EDIT_WARN1), SB_VERT, TRUE);
    }

    strTempString.LoadString(IDS_APP_DEPEND_WARN2);
    strWarn2.Format(strTempString,m_strExtensionName);
    GetDlgItem(IDC_EDIT_WARN2)->SetWindowText(strWarn2);
    if (strWarn2.GetLength() > 200)
    {
        ::ShowScrollBar(CONTROL_HWND(IDC_EDIT_WARN2), SB_VERT, TRUE);
    }

    CenterWindow();
    MessageBeep(MB_ICONEXCLAMATION);

    // Default to NO
    GetDlgItem(IDCANCEL)->SetFocus();
    return FALSE;
}

BOOL
CDepedentAppsDlg::OnHelpInfo(HELPINFO * pHelpInfo)
{
    OnHelp();
    return TRUE;
}

void
CDepedentAppsDlg::OnHelp()
{
    WinHelpDebug(0x20000 + CDepedentAppsDlg::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CDepedentAppsDlg::IDD);
}

void 
CDepedentAppsDlg::OnOK() 
{
    if (UpdateData(TRUE))
    {
        CDialog::OnOK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wfile.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wfile.h

   Abstract:
        WWW File Properties Page Definitions

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __WFILE_H__
#define __WFILE__H_ 


class CW3FilePage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CW3FilePage)

//
// Constructor/Destructor
//
public:
    CW3FilePage(CInetPropertySheet * pSheet = NULL);
    ~CW3FilePage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_DIRECTORY,
        RADIO_REDIRECT,
    };

    //{{AFX_DATA(CW3DirectoryPage)
    enum { IDD = IDD_WEB_FILE_PROPERTIES };
    int     m_nPathType;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAuthor;
    BOOL    m_fLogAccess;
//    BOOL    m_fChild;
    BOOL    m_fExact;
    BOOL    m_fPermanent;
    CString m_strRedirectPath;
    CEdit   m_edit_Path;
    CEdit   m_edit_Redirect;
//    CStatic m_static_Path;
    CStatic m_static_PathPrompt;
    CButton m_radio_Dir;
    CButton m_check_Author;
//    CButton m_check_Child;
//    CButton m_check_DirBrowse;
//    CButton m_check_Index;
    CButton m_check_Write;
    CButton m_check_Read;
    //}}AFX_DATA

    
//    DWORD m_dwAccessPermissions;
    DWORD m_dwBitRangePermissions;
    DWORD m_dwAccessPerms;
    CButton m_radio_Redirect;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3FilePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3FilePage)
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckRead();
    afx_msg void OnCheckWrite();
    afx_msg void OnCheckAuthor();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioRedirect();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void ShowControl(CWnd * pWnd, BOOL fShow);
    void ShowControl(UINT nID, BOOL fShow);
    void SetStateByType();
    void SetPathType();
    void SetAuthoringState(BOOL fAlterReadAndWrite = TRUE);
    void ChangeTypeTo(int nNewType);

protected:
    //
    // Remember/restore settings.
    //
    void SaveAuthoringState();
    void RestoreAuthoringState();

private:
    BOOL  m_fOriginalRead;
    BOOL  m_fOriginalWrite;
    DWORD m_dwAttributes;
    CString m_strFullMetaPath;
    CString m_strPrompt[2];
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CW3FilePage::ShowControl(UINT nID, BOOL fShow)
{
    ASSERT(nID > 0);
    ShowControl(GetDlgItem(nID), fShow);
}

#endif // __WFILE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\websvcext_sheet.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        websvcext_sheet.h

   Abstract:
        Property Sheet

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef _WEBSVCEXT_SHEET_H
#define _WEBSVCEXT_SHEET_H

class CWebServiceExtensionProps : public CMetaProperties
{
public:
	CWebServiceExtensionProps(CMetaInterface * pInterface, LPCTSTR meta_path, CRestrictionUIEntry * pRestrictionUIEntry, CWebServiceExtension * pWebServiceExtension);
    virtual ~CWebServiceExtensionProps();
	virtual HRESULT WriteDirtyProps();
	HRESULT UpdateMMC(DWORD dwUpdateFlag);

protected:
	virtual void ParseFields();

public:
    MP_CString m_strExtensionName;
    MP_CString m_strExtensionUsedBy;
    MP_int m_iExtensionUsedByCount;

public:
    CRestrictionList m_MyRestrictionList;

public:
    CRestrictionUIEntry * m_pRestrictionUIEntry;
    CWebServiceExtension * m_pWebServiceExtension;
    CMetaInterface * m_pInterface;
};

class CWebServiceExtensionSheet : public CInetPropertySheet
{
   DECLARE_DYNAMIC(CWebServiceExtensionSheet)

public:
   CWebServiceExtensionSheet(
        CComAuthInfo * pComAuthInfo,
        LPCTSTR lpszMetaPath,
        CWnd * pParentWnd  = NULL,
        LPARAM lParam = 0L,
        LPARAM lParamParent = 0L,
		LPARAM lParam2 = 0L,
        UINT iSelectPage = 0
        );

   virtual ~CWebServiceExtensionSheet();

public:
   // The following methods have predefined names to be compatible with
   // BEGIN_META_INST_READ and other macros.
	HRESULT QueryInstanceResult() const
    {
        return m_pprops ? m_pprops->QueryResult() : S_OK;
    }
   CWebServiceExtensionProps & GetInstanceProperties() { return *m_pprops; }

   virtual HRESULT LoadConfigurationParameters();
   virtual void FreeConfigurationParameters();

   //{{AFX_MSG(CWebServiceExtensionSheet)
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

public:
	CRestrictionUIEntry * m_pRestrictionUIEntry;
    CWebServiceExtension * m_pWebServiceExtension;

private:
   CWebServiceExtensionProps * m_pprops;
};

class CWebServiceExtensionGeneral : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CWebServiceExtensionGeneral)

public:
   CWebServiceExtensionGeneral(CWebServiceExtensionSheet * pSheet = NULL,int iImageIndex = 0,CRestrictionUIEntry * pRestrictionUIEntry = NULL);
   virtual ~CWebServiceExtensionGeneral();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebServiceExtensionGeneral)
    enum { IDD = IDD_WEBSVCEXT_GENERAL };

    CEdit m_ExtensionName;
    CEdit m_ExtensionUsedBy;
    //}}AFX_DATA

    //{{AFX_MSG(CWebServiceExtensionGeneral)
    virtual BOOL OnInitDialog();
    afx_msg void OnItemChanged();
    virtual BOOL OnSetActive();
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
	afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebServiceExtensionGeneral)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlsState();

    CString m_strExtensionName;
    CString m_strExtensionUsedBy;
    int m_iExtensionUsedByCount;

    HBITMAP m_hGeneralImage;

    CRestrictionUIEntry * m_pRestrictionUIEntry;
};

class CWebServiceExtensionRequiredFiles : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CWebServiceExtensionRequiredFiles)

public:
   CWebServiceExtensionRequiredFiles(CWebServiceExtensionSheet * pSheet = NULL, CComAuthInfo * pComAuthInfo = NULL, CRestrictionUIEntry * pRestrictionUIEntry = NULL);
   virtual ~CWebServiceExtensionRequiredFiles();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebServiceExtensionRequiredFiles)
    enum { IDD = IDD_WEBSVCEXT_REQUIREDFILES };
    CButton m_bnt_Add;
    CButton m_bnt_Remove;
    CButton m_bnt_Enable;
    CButton m_bnt_Disable;
    CRestrictionListBox m_list_Files;
    //}}AFX_DATA

    //{{AFX_MSG(CWebServiceExtensionRequiredFiles)
    virtual BOOL OnInitDialog();
    afx_msg void OnDoButtonAdd();
    afx_msg void OnDoButtonRemove();
    afx_msg void OnDoButtonEnable();
    afx_msg void OnDoButtonDisable();
    afx_msg void OnClickListFiles(NMHDR * pNMHDR, LRESULT * pResult);
    afx_msg void OnDblclkListFiles(NMHDR * pNMHDR, LRESULT * pResult);
    afx_msg void OnKeydownListFiles(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChangedListFiles(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlState();
    void FillListBox(CRestrictionEntry * pSelection = NULL);

    CComAuthInfo * m_pComAuthInfo;
	CMetaInterface * m_pInterface;
    CRestrictionList m_MyRestrictionList;
    CRestrictionUIEntry * m_pRestrictionUIEntry;
};


//
// CFileDlg dialog
//
class CFileDlg : public CDialog
{
//
// Construction
//
public:
    CFileDlg(
        IN BOOL fLocal,
		IN CMetaInterface * pInterface,
		IN CRestrictionList * pMyRestrictionList,
        IN LPCTSTR strGroupID,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFileDlg)
    enum { IDD = IDD_ADD_FILE };
    CEdit   m_edit_FileName;
    CButton m_button_Browse;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFileDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Access
//
public:
    CString m_strFileName;
    CString m_strGroupID;
    BOOL    m_bValidateFlag;
	CRestrictionList * m_pRestrictionList;

//
// Implementation
//
protected:
    //{{AFX_MSG(CFileDlg)
    afx_msg void OnButtonBrowse();
    afx_msg void OnFilenameChanged();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    void MySetControlStates();
    BOOL FilePathEntryExists(LPCTSTR lpName,CString * strUser);

    DECLARE_MESSAGE_MAP()

private:
	CMetaInterface * m_pInterface;
    BOOL m_fLocal;
};

//
// CWebSvcExtAddNewDlg dialog
//
class CWebSvcExtAddNewDlg : public CDialog
{
//
// Construction
//
public:
    CWebSvcExtAddNewDlg(
        IN BOOL fLocal,
        CMetaInterface * pInterface,
        IN CWnd * pParent = NULL
        );
    ~CWebSvcExtAddNewDlg();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebSvcExtAddNewDlg)
    enum { IDD = IDD_WEBSVCEXT_ADDNEW };
    CEdit   m_edit_FileName;
    CButton m_bnt_Add;
    CButton m_bnt_Remove;
    CButton m_chk_Allow;
    CButton m_button_Ok;
    CButton m_button_Help;
    CRestrictionListBox m_list_Files;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebSvcExtAddNewDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Access
//
public:
    BOOL m_fAllow;
    CString m_strGroupName;
	CMetaInterface * m_pInterface;
    CRestrictionList m_MyRestrictionList;

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebSvcExtAddNewDlg)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnFilenameChanged();
    afx_msg void OnDoButtonAdd();
    afx_msg void OnDoButtonRemove();
    afx_msg void OnDoCheckAllow();
    afx_msg void OnClickListFiles(NMHDR * pNMHDR, LRESULT * pResult);
    afx_msg void OnKeydownListFiles(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChangedListFiles(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    void MySetControlStates();
    void FillListBox(CRestrictionEntry * pSelection = NULL);
    BOOL FilePathEntryExists(LPCTSTR lpName);
    
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fIsLocal;
};


//
// CWebSvcExtAddNewDlg dialog
//
class CWebSvcExtAddNewForAppDlg : public CDialog
{
//
// Construction
//
public:
    CWebSvcExtAddNewForAppDlg(
        IN BOOL fLocal,
        IN CMetaInterface * pInterface,
        IN CWnd * pParent = NULL
        );   
//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebSvcExtAddNewForAppDlg)
    enum { IDD = IDD_WEBSVCEXT_ADDBYAPP};
    CButton m_button_Ok;
    CButton m_button_Help;
    CComboBox m_combo_Applications;
    int       m_nComboSelection;
	CMetaInterface * m_pInterface;
	CEdit m_Dependencies;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebSvcExtAddNewForAppDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Access
//
public:
    CApplicationDependEntry * m_pMySelectedApplication;

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebSvcExtAddNewForAppDlg)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    virtual void OnSelchangeComboApplications();
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    void MySetControlStates();

    DECLARE_MESSAGE_MAP()

private:
    CApplicationDependList m_MyApplicationDependList;
    CMyMapStringToString m_GroupIDtoGroupFriendList;
    BOOL m_fLocal;
};


class CDepedentAppsDlg : public CDialog
{
public:
    //
    // Constructor
    //
    CDepedentAppsDlg(CStringListEx * pstrlstDependApps,LPCTSTR strExtensionName,CWnd * pParent = NULL);

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CDepedentAppsDlg)
    enum { IDD = IDD_CONFIRM_DEPENDENT_APPS };
    CButton m_button_Help;
    CListBox m_dependent_apps_list;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CDepedentAppsDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
//
// Implementation
//
protected:
    //{{AFX_MSG(CDepedentAppsDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
    CString m_strExtensionName;
    CStringListEx * m_pstrlstDependentAppList;
};

BOOL StartAddNewDialog(CWnd * pParent,CMetaInterface * pInterface,BOOL bIsLocal,CRestrictionUIEntry **pReturnedNewEntry);
BOOL StartAddNewByAppDialog(CWnd * pParent,CMetaInterface * pInterface,BOOL bIsLocal);

#endif //_WEBSVCEXT_SHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wfile.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wfile.cpp

   Abstract:
        WWW File Properties Page

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        27/02/2001      sergeia     Created from wvdir.cpp
--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wfile.h"
#include "dirbrows.h"
#include "iisobj.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCTSTR CvtPathToDosStyle(CString & strPath);

IMPLEMENT_DYNCREATE(CW3FilePage, CInetPropertyPage)

CW3FilePage::CW3FilePage(CInetPropertySheet * pSheet) 
    : CInetPropertyPage(CW3FilePage::IDD, pSheet, IDS_TAB_FILE),
      //
      // Assign the range of bits in m_dwAccessPermissions that
      // we manage.  This is important, because another page
      // manages other bits, and we don't want to screw up
      // the master value bits when our changes collide (it
      // will mark the original bits as dirty, because we're not
      // notified when the change is made...
      //
      m_dwBitRangePermissions(MD_ACCESS_EXECUTE | 
            MD_ACCESS_SCRIPT | 
            MD_ACCESS_WRITE  | 
            MD_ACCESS_SOURCE |
            MD_ACCESS_READ)
{
    VERIFY(m_strPrompt[RADIO_DIRECTORY].LoadString(IDS_PROMPT_DIR));
    VERIFY(m_strPrompt[RADIO_REDIRECT].LoadString(IDS_PROMPT_REDIRECT));
}

CW3FilePage::~CW3FilePage()
{
}

void 
CW3FilePage::DoDataExchange(CDataExchange * pDX)
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3FilePage)
//    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_RADIO_REDIRECT, m_radio_Redirect);
    DDX_Check(pDX, IDC_CHECK_AUTHOR, m_fAuthor);
    DDX_Control(pDX, IDC_CHECK_AUTHOR, m_check_Author);
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);    
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);

    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_EDIT_REDIRECT, m_edit_Redirect);

    DDX_Control(pDX, IDC_STATIC_PATH_PROMPT, m_static_PathPrompt);
//    DDX_Control(pDX, IDC_CHECK_CHILD, m_check_Child);
    //}}AFX_DATA_MAP


//    DDX_Check(pDX, IDC_CHECK_CHILD, m_fChild);
    DDX_Check(pDX, IDC_CHECK_EXACT, m_fExact);
    DDX_Check(pDX, IDC_CHECK_PERMANENT, m_fPermanent);

    if (pDX->m_bSaveAndValidate)
    {
        if (m_nPathType == RADIO_REDIRECT)
        {
            DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
            DDV_Url(pDX, m_strRedirectPath);
            // We could have only absolute URLs here
			// Nope, we allow relative URL's...
			if (IsRelURLPath(m_strRedirectPath))
			{
			}
			else
			{
				if (!PathIsURL(m_strRedirectPath) || m_strRedirectPath.GetLength() <= lstrlen(_T("http://")))
				{
					DDV_ShowBalloonAndFail(pDX, IDS_BAD_URL_PATH);
				}
			}

			if (m_strRedirectPath.Find(_T(",")) > 0)
			{
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_COMMA_IN_REDIRECT);
			}
        }
        else // Local directory
        {
            m_strRedirectPath.Empty();
        }
    }
    else
    {
        DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3FilePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3FilePage)
    ON_BN_CLICKED(IDC_CHECK_READ, OnCheckRead)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnCheckWrite)
    ON_BN_CLICKED(IDC_CHECK_AUTHOR, OnCheckAuthor)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_REDIRECT, OnRadioRedirect)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_REDIRECT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
//    ON_BN_CLICKED(IDC_CHECK_CHILD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_EXACT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_PERMANENT, OnItemChanged)

END_MESSAGE_MAP()



void
CW3FilePage::ChangeTypeTo(int nNewType)
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        return;
    }

    OnItemChanged();
    SetStateByType();

    int nID = -1;
    CEdit * pPath = NULL;
    LPCTSTR lpKeepPath = NULL;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        break;

    case RADIO_REDIRECT:
        if (!m_strRedirectPath.IsEmpty())
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath =  m_strRedirectPath;
        }

        nID = IDS_REDIRECT_MASK;
        pPath = &m_edit_Redirect;
        break;

    default:
        ASSERT(FALSE);
        return;
    }

    //
    // Load mask resource, and display
    // this in the directory
    //
    if (pPath != NULL)
    {
        if (lpKeepPath != NULL)
        {
            pPath->SetWindowText(lpKeepPath);
        }
        else
        {
            CString str;
            VERIFY(str.LoadString(nID));
            pPath->SetWindowText(str);
        }
        pPath->SetSel(0,-1);
        pPath->SetFocus();
    }
    SetAuthoringState(FALSE);
}



void 
CW3FilePage::ShowControl(CWnd * pWnd, BOOL fShow)
{
    ASSERT(pWnd != NULL);
	pWnd->EnableWindow(fShow);
	pWnd->ShowWindow(fShow ? SW_SHOW : SW_HIDE);
}

void
CW3FilePage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL fShowDirFlags;
    BOOL fShowRedirectFlags;
    BOOL fShowScript;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        ShowControl(&m_edit_Path, fShowDirFlags = TRUE);
		m_edit_Path.EnableWindow(FALSE);
        ShowControl(&m_edit_Redirect, fShowRedirectFlags = FALSE);
        fShowScript = TRUE;
        break;

    case RADIO_REDIRECT:
        ShowControl(&m_edit_Path, fShowDirFlags = FALSE);
        ShowControl(&m_edit_Redirect, fShowRedirectFlags = TRUE);
        fShowScript = FALSE;
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
        return;
    }

    ShowControl(GetDlgItem(IDC_CHECK_READ), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_WRITE), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_LOG_ACCESS), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_AUTHOR), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_SMALL), fShowDirFlags);

    ShowControl(IDC_CHECK_EXACT, fShowRedirectFlags);
    ShowControl(IDC_CHECK_CHILD, fShowRedirectFlags);
	if (fShowRedirectFlags)
	{
		GetDlgItem(IDC_CHECK_CHILD)->EnableWindow(FALSE);
	}
    ShowControl(IDC_CHECK_PERMANENT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRECT_PROMPT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRFLAGS, fShowRedirectFlags);
    ShowControl(&m_check_Author, fShowScript);

    //
    // Enable/Disable must come after the showcontrols
    //
    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}



void
CW3FilePage::SaveAuthoringState()
{
    if (m_check_Write.m_hWnd)
    {
        //
        // Controls initialized -- store live data
        //
        m_fOriginalWrite = m_check_Write.GetCheck() > 0;
        m_fOriginalRead = m_check_Read.GetCheck() > 0;
    }
    else
    {
        //
        // Controls not yet initialized, store original data
        //
        m_fOriginalWrite = m_fWrite;
        m_fOriginalRead = m_fRead;
    }
}

void
CW3FilePage::RestoreAuthoringState()
{
    m_fWrite = m_fOriginalWrite;
    m_fRead = m_fOriginalRead;
}

void 
CW3FilePage::SetAuthoringState(BOOL fAlterReadAndWrite)
{
    if (fAlterReadAndWrite)
    {
        if (m_fAuthor)
        {
            //
            // Remember previous setting to undo
            // this thing.
            //
            SaveAuthoringState();
            m_fRead = m_fWrite = TRUE;
        }
        else
        {
            //
            // Restore previous defaults
            //
            RestoreAuthoringState();
        }

        m_check_Read.SetCheck(m_fRead);
        m_check_Write.SetCheck(m_fWrite);
    }

    m_check_Author.EnableWindow((m_fRead || m_fWrite) 
		&& HasAdminAccess() 
        );

//    m_check_Read.EnableWindow(!m_fAuthor && HasAdminAccess());
//    m_check_Write.EnableWindow(!m_fAuthor && HasAdminAccess());
}

void 
CW3FilePage::SetPathType()
{
    if (!m_strRedirectPath.IsEmpty())
    {
        m_nPathType = RADIO_REDIRECT;
        m_radio_Dir.SetCheck(0);
        m_radio_Redirect.SetCheck(1);
    }
    else
    {
        m_nPathType = RADIO_DIRECTORY;
        m_radio_Redirect.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }

    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3FilePage::OnItemChanged()
{
    SetModified(TRUE);
}

BOOL 
CW3FilePage::OnInitDialog() 
{
    CInetPropertyPage::OnInitDialog();

    SetPathType();
    SetStateByType();
    SetAuthoringState(FALSE);

	// It is enough to set file alias once -- we cannot change it here
    CString buf1, buf2, strAlias;
	CMetabasePath::GetRootPath(m_strFullMetaPath, buf1, &buf2);

	strAlias += _T("\\");
	strAlias += buf2;
    CvtPathToDosStyle(strAlias);
	m_edit_Path.SetWindowText(strAlias);
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),FALSE);
#endif

    return TRUE;  
}



/* virtual */
HRESULT
CW3FilePage::FetchLoadedValues()
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        //
        // Use m_ notation because the message crackers require it
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strFullMetaPath);
        FETCH_DIR_DATA_FROM_SHEET(m_strRedirectPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);
        FETCH_DIR_DATA_FROM_SHEET(m_fExact);
        FETCH_DIR_DATA_FROM_SHEET(m_fPermanent);

        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fAuthor = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SOURCE);
        m_fLogAccess = !m_fDontLog;

        SaveAuthoringState();
    END_META_DIR_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3FilePage::SaveInfo()
{
    ASSERT(IsDirty());

    CError err;

    SET_FLAG_IF(m_fRead, m_dwAccessPerms,   MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms,  MD_ACCESS_WRITE);
    SET_FLAG_IF(m_fAuthor, m_dwAccessPerms, MD_ACCESS_SOURCE);
    BOOL m_fDontLog = !m_fLogAccess;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwAccessPerms, m_dwBitRangePermissions)

        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_fExact);
        STORE_DIR_DATA_ON_SHEET(m_fPermanent);
        //
        // CODEWORK: Not an elegant solution
        //
//        pSheet->GetDirectoryProperties().MarkRedirAsInherit(!m_fChild);
        STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        SaveAuthoringState();
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
        NotifyMMC(PROP_CHANGE_DISPLAY_ONLY);
    }

    EndWaitCursor();

    return err;
}

void
CW3FilePage::OnCheckRead() 
{
    m_fRead = !m_fRead;
    SetAuthoringState(FALSE);
    OnItemChanged();
}

void
CW3FilePage::OnCheckWrite() 
{
    m_fWrite = !m_fWrite;
    SetAuthoringState(FALSE);
    OnItemChanged();
}

void 
CW3FilePage::OnCheckAuthor() 
{
    m_fAuthor = !m_fAuthor;
    SetAuthoringState(FALSE);
    OnItemChanged();
}

void 
CW3FilePage::OnRadioDir() 
{
    ChangeTypeTo(RADIO_DIRECTORY);
}

void 
CW3FilePage::OnRadioRedirect() 
{
    ChangeTypeTo(RADIO_REDIRECT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wiztempl.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        WizTempl.h

   Abstract:

        Template for wizard pages

   Author:

        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        11/9/2000       sergeia     Initial creation

--*/
#ifndef _WIZTEMPL_H
#define _WIZTEMPL_H

#ifndef _PRSHT_H_
	#error WizTempl.h requires prsht.h to be included first
#endif

#pragma comment(lib, "comctl32.lib")

template <class T>
class CWizardPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE	m_psp;
	HPROPSHEETPAGE	m_hpsp;
	CComBSTR		m_bstrTitle;
	CComBSTR		m_bstrSubTitle;


	operator PROPSHEETPAGE*() { return &m_psp; }

	CWizardPageImpl(
		IN bool			i_bShowHeader
		)
		:m_hpsp(NULL)
	{
		
		ZeroMemory(&m_psp, sizeof m_psp);

		m_psp.dwSize = sizeof m_psp;
		m_psp.hInstance = _Module.GetResourceInstance();

		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = T::StartDialogProc;
		
		m_psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
		m_psp.pfnCallback = T::PropPageCallback;
		
		if ( false == i_bShowHeader)
		{
			m_psp.dwFlags |= PSP_HIDEHEADER;
		}

		m_psp.lParam = (LPARAM)this;
	}


	void SetHeaderTitle(
		IN LPCTSTR		i_lpszHeaderTitle
		)
	{
		m_psp.dwFlags |= PSP_USEHEADERTITLE;	// Header title. Wizard 97
		m_bstrTitle = i_lpszHeaderTitle;
		m_psp.pszHeaderTitle = m_bstrTitle;
	}


	void SetHeaderSubTitle(
		IN LPCTSTR		i_lpszHeaderSubTitle
		)
	{
		m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;	// Header sub title. Wizard 97
		m_bstrSubTitle = i_lpszHeaderSubTitle;
		m_psp.pszHeaderSubTitle = m_bstrSubTitle;
	}

	static UINT CALLBACK PropPageCallback(
		HWND	hWnd, 
		UINT	uMsg, 
		LPPROPSHEETPAGE ppsp
		)
	{
		if(uMsg == PSPCB_CREATE)
		{
			_ASSERTE(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		else if(uMsg == PSPCB_RELEASE)
		{
			CWizardPageImpl* pPage = (CWizardPageImpl*)ppsp->lParam;
			pPage->Delete();
		}

		return 1;
	}

	virtual HPROPSHEETPAGE Create()
	{
		return (m_hpsp = ::CreatePropertySheetPage(&m_psp));
	}

							// Implement this in derived class to do clean up when property
							// Page is closed.
	virtual void Delete()
	{
		return;
	}

	virtual BOOL EndDialog(int)
	{
		// Calling ::EndDialog will close the whole sheet
		_ASSERTE(FALSE);
		return FALSE;
	}


	BEGIN_MSG_MAP(CWizardPageImpl<T>)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()


	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_ASSERTE(::IsWindow(m_hWnd));

		NMHDR*		pNMHDR = (NMHDR*)lParam;
		_ASSERT(NULL != pNMHDR);
		if (NULL == pNMHDR)
		{
			bHandled = FALSE;
			return 1;
		}


		// Ignore messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T*			pT = (T*)this;
		LRESULT		lResult = 0;
		
		
		switch(pNMHDR->code)	// Used to call actual methods
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;

		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;

		case PSN_RESET:
			pT->OnReset();
			break;

		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;

		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;

		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;

		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;

		case PSN_HELP:
			lResult = pT->OnHelp();
			break;

		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;

		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

	BOOL OnSetActive()
	{
		return TRUE;
	}

	BOOL OnKillActive()
	{
		return TRUE;
	}

	void OnReset()
	{
	}

	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	
	BOOL OnHelp()
	{
		return TRUE;
	}

	BOOL OnApply()
	{
		return TRUE;
	}

};


#endif //_WIZTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wsecure.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        security.cpp

   Abstract:
        WWW Security Property Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wincrypt.h"
#include "resource.h"
#include "wsecure.h"
#include "authent.h"
#include "seccom.h"
#include "ipdomdlg.h"
#include <schannel.h>

#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CInetmgrApp theApp;

//
// CW3SecurityPage property page
//
IMPLEMENT_DYNCREATE(CW3SecurityPage, CInetPropertyPage)



CW3SecurityPage::CW3SecurityPage(
    IN CInetPropertySheet * pSheet,
    IN BOOL  fHome,
    IN DWORD dwAttributes
    )
/*++

Routine Description:

    Constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet object
    BOOL fHome                  : TRUE if this is a home directory
    DWORD dwAttributes          : Attributes

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3SecurityPage::IDD, pSheet,
        IS_FILE(dwAttributes)
            ? IDS_TAB_FILE_SECURITY
            : IDS_TAB_DIR_SECURITY
            ),
      m_oblAccessList(),
      m_fU2Installed(FALSE),
      m_fIpDirty(FALSE),
      m_fHome(fHome),
	  m_fPasswordSync(FALSE),
	  m_fPasswordSyncInitial(FALSE),
      //
      // By default, we grant access
      //
      m_fOldDefaultGranted(TRUE),
      m_fDefaultGranted(TRUE)   
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3SecurityPage)
    m_fUseNTMapper = FALSE;
    //}}AFX_DATA_INIT

#endif // 0
}


CW3SecurityPage::~CW3SecurityPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CW3SecurityPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3SecurityPage)
    DDX_Check(pDX, IDC_CHECK_ENABLE_DS, m_fUseNTMapper);
    DDX_Control(pDX, IDC_ICON_SECURE, m_icon_Secure);
    DDX_Control(pDX, IDC_STATIC_SSL_PROMPT, m_static_SSLPrompt);
    DDX_Control(pDX, IDC_CHECK_ENABLE_DS, m_check_EnableDS);
    DDX_Control(pDX, IDC_BUTTON_GET_CERTIFICATES, m_button_GetCertificates);
    DDX_Control(pDX, IDC_VIEW_CERTIFICATE, m_button_ViewCertificates);
    DDX_Control(pDX, IDC_BUTTON_COMMUNICATIONS, m_button_Communications);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3SecurityPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3SecurityPage)
    ON_BN_CLICKED(IDC_BUTTON_AUTHENTICATION, OnButtonAuthentication)
    ON_BN_CLICKED(IDC_BUTTON_COMMUNICATIONS, OnButtonCommunications)
    ON_BN_CLICKED(IDC_BUTTON_IP_SECURITY, OnButtonIpSecurity)
    ON_BN_CLICKED(IDC_BUTTON_GET_CERTIFICATES, OnButtonGetCertificates)
    ON_BN_CLICKED(IDC_VIEW_CERTIFICATE, OnButtonViewCertificates)
    //}}AFX_MSG_MAP

    ON_BN_CLICKED(IDC_CHECK_ENABLE_DS, OnItemChanged)

END_MESSAGE_MAP()



/* virtual */
HRESULT
CW3SecurityPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_dwAuthFlags);
        FETCH_DIR_DATA_FROM_SHEET(m_dwSSLAccessPermissions);
        FETCH_DIR_DATA_FROM_SHEET(m_strBasicDomain);
        FETCH_DIR_DATA_FROM_SHEET(m_strRealm);
        FETCH_DIR_DATA_FROM_SHEET(m_strAnonUserName);
        FETCH_DIR_DATA_FROM_SHEET_PASSWORD(m_strAnonPassword);
		if (GetSheet()->QueryMajorVersion() < 6)
		{
			FETCH_DIR_DATA_FROM_SHEET(m_fPasswordSync);
		}
        FETCH_DIR_DATA_FROM_SHEET(m_fU2Installed);        
        FETCH_DIR_DATA_FROM_SHEET(m_fUseNTMapper);
    END_META_DIR_READ(err)
	m_fPasswordSyncInitial = m_fPasswordSync;
    //
    // First we need to read in the hash and the name of the store. If either
    // is not there then there is no certificate.
    //
    BEGIN_META_INST_READ(CW3Sheet)
// BUGBUG we are not fetching the hash right now because it needs a new
// copy constructor. Otherwise it does a bitwise copy of the pointer value.
// Then this one desctructs, freeing the pointer. Then the other one desctucts
// freeing it again.
//        FETCH_INST_DATA_FROM_SHEET(m_CertHash);
        FETCH_INST_DATA_FROM_SHEET(m_strCertStoreName);
        FETCH_INST_DATA_FROM_SHEET(m_strCTLIdentifier);
        FETCH_INST_DATA_FROM_SHEET(m_strCTLStoreName);
    END_META_INST_READ(err) 

    //
    // Build the IPL list
    //
    err = BuildIplOblistFromBlob(
        GetIPL(),
        m_oblAccessList,
        m_fDefaultGranted
        );

    m_fOldDefaultGranted = m_fDefaultGranted;

    return err;
}



/* virtual */
HRESULT
CW3SecurityPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 security page now...");

    CError err;

    //
    // Check to see if the ip access list needs saving.
    //
    BOOL fIplDirty = m_fIpDirty || (m_fOldDefaultGranted != m_fDefaultGranted);

    //
    // Use m_ notation because the message crackers require it
    //
    CBlob m_ipl;

    if (fIplDirty)
    {
        BuildIplBlob(m_oblAccessList, m_fDefaultGranted, m_ipl);
    }

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_dwSSLAccessPermissions)
        STORE_DIR_DATA_ON_SHEET(m_dwAuthFlags)
        STORE_DIR_DATA_ON_SHEET(m_strBasicDomain)
        STORE_DIR_DATA_ON_SHEET(m_strRealm)

        if (fIplDirty)
        {
            STORE_DIR_DATA_ON_SHEET(m_ipl)
        }
        STORE_DIR_DATA_ON_SHEET(m_strAnonUserName)
        STORE_DIR_DATA_ON_SHEET(m_fUseNTMapper)
		if (GetSheet()->QueryMajorVersion() < 6)
		{
			STORE_DIR_DATA_ON_SHEET(m_fPasswordSync)
			if (m_fPasswordSync != m_fPasswordSyncInitial && m_fPasswordSync)
			{
				FLAG_DIR_DATA_FOR_DELETION(MD_ANONYMOUS_PWD);
			}
			else
			{
				STORE_DIR_DATA_ON_SHEET(m_strAnonPassword);
			}
		}
		else
		{
			STORE_DIR_DATA_ON_SHEET(m_strAnonPassword);
		}
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        BEGIN_META_INST_WRITE(CW3Sheet)
            if ( m_strCTLIdentifier.IsEmpty() )
            {
                FLAG_INST_DATA_FOR_DELETION( MD_SSL_CTL_IDENTIFIER )
            }
            else
            {
                STORE_INST_DATA_ON_SHEET(m_strCTLIdentifier)
            }

            if ( m_strCTLStoreName.IsEmpty() )
            {
                FLAG_INST_DATA_FOR_DELETION( MD_SSL_CTL_STORE_NAME )
            }
            else
            {
                STORE_INST_DATA_ON_SHEET(m_strCTLStoreName)
            }
        END_META_INST_WRITE(err)
    }

    EndWaitCursor();

    if (err.Succeeded())
    {
        m_fIpDirty = FALSE;
        m_fOldDefaultGranted = m_fDefaultGranted;
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
    }

    return err;
}



BOOL
CW3SecurityPage::FetchSSLState()
/*++

Routine Description:

    Obtain the state of the dialog depending on whether certificates
    are installed or not.

Arguments:

    None

Return Value:

    TRUE if certificates are installed, FALSE otherwise

--*/
{
    BeginWaitCursor();
    m_fCertInstalled = ::IsCertInstalledOnServer(
        QueryAuthInfo(), 
        QueryMetaPath()
        );
    EndWaitCursor();

    return m_fCertInstalled;
}



void
CW3SecurityPage::SetSSLControlState()
/*++

Routine Description:

    Enable/disable supported controls depending on what's installed.
    Only available on non-master instance nodes.

Arguments:

    None

Return Value:

    None

--*/
{
    // only enable these buttons on the local system!
    FetchSSLState();

    m_static_SSLPrompt.EnableWindow(!IsMasterInstance());
    m_button_GetCertificates.EnableWindow(
        !IsMasterInstance() 
     && m_fHome 
     && IsLocal() 
        );

    m_button_Communications.EnableWindow(
        !IsMasterInstance() 
     && IsSSLSupported() 
//     && FetchSSLState()
     && IsLocal() 
        );

    m_button_ViewCertificates.EnableWindow(IsLocal() ? m_fCertInstalled: FALSE);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CW3SecurityPage::OnSetActive() 
/*++

Routine Description:

    Page got activated -- set the SSL state depending on whether a
    certificate is installed or not.

Arguments:

    None

Return Value:

    TRUE to activate the page, FALSE otherwise.

--*/
{
    //
    // Enable/disable ssl controls
    //
    SetSSLControlState();
    
    return CInetPropertyPage::OnSetActive();
}



BOOL 
CW3SecurityPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Initialize certificate authorities ocx
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_CertificateAuthorities.Create(
        _T("CertWiz"),
        WS_BORDER,
        rc,
        this,
        IDC_APPSCTRL
        );

    GetDlgItem(IDC_GROUP_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_STATIC_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_BUTTON_IP_SECURITY)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_BUTTON_AUTHENTICATION)->EnableWindow(!m_fU2Installed);

    //
    // Configure for either master or non-master display.
    //
    m_check_EnableDS.ShowWindow(IsMasterInstance() ? SW_SHOW : SW_HIDE);
    m_check_EnableDS.EnableWindow(
        HasAdminAccess() 
     && IsMasterInstance() 
     && HasNTCertMapper()
        );

#define SHOW_NON_MASTER(x)\
   (x).ShowWindow(IsMasterInstance() ? SW_HIDE : SW_SHOW)
    
    SHOW_NON_MASTER(m_static_SSLPrompt);
    SHOW_NON_MASTER(m_icon_Secure);
    SHOW_NON_MASTER(m_button_GetCertificates);
    SHOW_NON_MASTER(m_button_Communications);
    SHOW_NON_MASTER(m_button_ViewCertificates);

#undef SHOW_NON_MASTER

    return TRUE;  
}



void 
CW3SecurityPage::OnButtonAuthentication() 
/*++

Routine Description:

    'Authentication' button hander

Arguments:

    None

Return Value:

    None

--*/
{
    CAuthenticationDlg dlg(
        QueryServerName(), 
        QueryInstance(), 
        m_strBasicDomain,
        m_strRealm,
        m_dwAuthFlags, 
        m_dwSSLAccessPermissions, 
        m_strAnonUserName,
        m_strAnonPassword,
        m_fPasswordSync,
        HasAdminAccess(),
        HasDigest(),
        this
        );

    DWORD dwOldAccess = m_dwSSLAccessPermissions;
    DWORD dwOldAuth = m_dwAuthFlags;
    CString strOldDomain = m_strBasicDomain;
    CString strOldRealm = m_strRealm;
    CString strOldUserName = m_strAnonUserName;
    CStrPassword strOldPassword = m_strAnonPassword;
    BOOL fOldPasswordSync = m_fPasswordSync;
    dlg.m_dwVersionMajor = GetSheet()->QueryMajorVersion();
    dlg.m_dwVersionMinor = GetSheet()->QueryMinorVersion();

    if (dlg.DoModal() == IDOK)
    {
        //
        // See if anything has changed
        //
        if (dwOldAccess != m_dwSSLAccessPermissions 
            || dwOldAuth != m_dwAuthFlags
            || m_strBasicDomain != strOldDomain
            || m_strRealm != strOldRealm
            || m_strAnonUserName != strOldUserName 
            || m_strAnonPassword != strOldPassword
            || m_fPasswordSync != fOldPasswordSync
            )
        {
            //
            // Mark as dirty
            //
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonCommunications() 
/*++

Routine Description:

    'Communications' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Prep the flag for if we can edit CTLs or not
    //
    BOOL fEditCTLs = IsMasterInstance() || m_fHome;

    //
    // Prep the communications dialog
    //
    CSecCommDlg dlg(
        QueryServerName(), 
        QueryInstanceMetaPath(), 
        m_strBasicDomain,
        m_dwAuthFlags, 
        QueryAuthInfo(),
        m_dwSSLAccessPermissions, 
        IsMasterInstance(),
        IsSSLSupported(), 
        IsSSL128Supported(),
        m_fU2Installed,
        m_strCTLIdentifier,
        m_strCTLStoreName,
        fEditCTLs,
        IsLocal(),
        this
        );

    DWORD dwOldAccess = m_dwSSLAccessPermissions;
    DWORD dwOldAuth = m_dwAuthFlags;

    if (dlg.DoModal() == IDOK)
    {
        //
        // See if anything has changed
        //
        if (dwOldAccess != m_dwSSLAccessPermissions 
            || dwOldAuth != m_dwAuthFlags
            )
        {
            //
            // Mark as dirty
            //
            OnItemChanged();
        }

        //
        // See if the CTL information has changed
        //
        if (dlg.m_bCTLDirty)
        {
            m_strCTLIdentifier = dlg.m_strCTLIdentifier;
            m_strCTLStoreName = dlg.m_strCTLStoreName;
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonIpSecurity() 
/*++

Routine Description:

    'tcpip' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CIPDomainDlg dlg(
        m_fIpDirty,
        m_fDefaultGranted,
        m_fOldDefaultGranted,
        m_oblAccessList, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        //
        // Rebuild the list.  Temporarily reset ownership, otherwise
        // RemoveAll() will destroy the pointers which are shared with the
        // new list.
        //
        BOOL fOwn = m_oblAccessList.SetOwnership(FALSE);
        m_oblAccessList.RemoveAll();
        m_oblAccessList.AddTail(&dlg.GetAccessList());
        m_oblAccessList.SetOwnership(fOwn);

        if (m_fIpDirty || m_fOldDefaultGranted != m_fDefaultGranted)
        {
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonGetCertificates() 
/*++

Routine Description:

    "get certicate" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_ocx_CertificateAuthorities.SetMachineName(QueryServerName());
    m_ocx_CertificateAuthorities.SetServerInstance(QueryInstanceMetaPath());
    CThemeContextActivator activator(theApp.GetFusionInitHandle());
    m_ocx_CertificateAuthorities.DoClick();

    //
    // There may now be a certificate. See if we should enable the edit button.
    //
    SetSSLControlState();
}


void 
CW3SecurityPage::OnButtonViewCertificates() 
/*++

Routine Description:

    "view certicate" button handler

Arguments:

    None

Return Value:

    None

--*/
{
   HCERTSTORE hStore = NULL;
   PCCERT_CONTEXT pCert = NULL;
   PCCERT_CONTEXT pNewCertificate = NULL;
   CMetaKey key(QueryAuthInfo(),
            QueryInstanceMetaPath(),
				METADATA_PERMISSION_READ,
				METADATA_MASTER_ROOT_HANDLE);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
            // We got our information already...
            // so don't keep the handle open...
            key.Close();

			hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
           		    NULL,
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    store_name
                    );
            if (hStore != NULL)
            {
				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = CertFindCertificateInStore(hStore, 
					X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
					0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);

                // check if this cert has been renewed and is actually
                // pointing to another cert... if it is then display the other cert.
                if (pCert)
                {
                    DWORD dwProtocol = SP_PROT_SERVERS;
                    if (TRUE == CheckForCertificateRenewal(dwProtocol,pCert,&pNewCertificate))
                    {
                        TRACEEOLID(_T("Cert has been renewed:display new cert\r\n"));
                        if (pCert != NULL)
                        {
                            // free the one we already had.
                            ::CertFreeCertificateContext(pCert);pCert=NULL;
                        }

                        pCert = pNewCertificate;
                    }
                }

            }
        }
    }
	if (pCert)
	{
		BOOL fPropertiesChanged;
		CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
		HCERTSTORE hCertStore = ::CertDuplicateStore(hStore);
		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
		vcs.hwndParent = GetParent()->GetSafeHwnd();
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert;
		::CryptUIDlgViewCertificate(&vcs, &fPropertiesChanged);
		::CertCloseStore (hCertStore, 0);
	}

    if (pCert != NULL)
    {
        ::CertFreeCertificateContext(pCert);pCert=NULL;
    }
    if (hStore != NULL)
    {
        ::CertCloseStore(hStore, 0);
    }
}

void
CW3SecurityPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}

#define CB_SHA_DIGEST_LEN   20

BOOL
CheckForCertificateRenewal(
    DWORD dwProtocol,
    PCCERT_CONTEXT pCertContext,
    PCCERT_CONTEXT *ppNewCertificate)
{
    BYTE rgbThumbprint[CB_SHA_DIGEST_LEN];
    DWORD cbThumbprint = sizeof(rgbThumbprint);
    CRYPT_HASH_BLOB HashBlob;
    PCCERT_CONTEXT pNewCert;
    BOOL fMachineCert;
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    DWORD cbSize;
    HCERTSTORE hMyCertStore = 0;
    BOOL fRenewed = FALSE;

    HCERTSTORE g_hMyCertStore;

    if(dwProtocol & SP_PROT_SERVERS)
    {
        fMachineCert = TRUE;
    }
    else
    {
        fMachineCert = FALSE;
    }


    //
    // Loop through the linked list of renewed certificates, looking
    // for the last one.
    //
    
    while(TRUE)
    {
        //
        // Check for renewal property.
        //

        if(!CertGetCertificateContextProperty(pCertContext,
                                              CERT_RENEWAL_PROP_ID,
                                              rgbThumbprint,
                                              &cbThumbprint))
        {
            // Certificate has not been renewed.
            break;
        }
        //DebugLog((DEB_TRACE, "Certificate has renewal property\n"));


        //
        // Determine whether to look in the local machine MY store
        // or the current user MY store.
        //

        if(!hMyCertStore)
        {
            if(CertGetCertificateContextProperty(pCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 NULL,
                                                 &cbSize))
            {
                //SafeAllocaAllocate(pProvInfo, cbSize);
                pProvInfo = (PCRYPT_KEY_PROV_INFO) LocalAlloc(LPTR,cbSize);
                if(pProvInfo == NULL)
                {
                    break;
                }

                if(CertGetCertificateContextProperty(pCertContext,
                                                     CERT_KEY_PROV_INFO_PROP_ID,
                                                     pProvInfo,
                                                     &cbSize))
                {
                    if(pProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                    {
                        fMachineCert = TRUE;
                    }
                    else
                    {
                        fMachineCert = FALSE;
                    }
                }
                if (pProvInfo)
                {
                    LocalFree(pProvInfo);pProvInfo=NULL;
                }
                //SafeAllocaFree(pProvInfo);
            }
        }


        //
        // Open up the appropriate MY store, and attempt to find
        // the new certificate.
        //

        if(!hMyCertStore)
        {
            if(fMachineCert)
            {
                g_hMyCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,X509_ASN_ENCODING,0,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"MY");
                if(g_hMyCertStore)
                {
                    hMyCertStore = g_hMyCertStore;
                }
            }
            else
            {
                hMyCertStore = CertOpenSystemStore(0, _T("MY"));
            }

            if(!hMyCertStore)
            {
                //DebugLog((DEB_ERROR, "Error 0x%x opening %s MY certificate store!\n", GetLastError(),(fMachineCert ? "local machine" : "current user") ));
                break;
            }
        }

        HashBlob.cbData = cbThumbprint;
        HashBlob.pbData = rgbThumbprint;

        pNewCert = CertFindCertificateInStore(hMyCertStore, 
                                              X509_ASN_ENCODING, 
                                              0, 
                                              CERT_FIND_HASH, 
                                              &HashBlob, 
                                              NULL);
        if(pNewCert == NULL)
        {
            // Certificate has been renewed, but the new certificate
            // cannot be found.
            //DebugLog((DEB_ERROR, "New certificate cannot be found: 0x%x\n", GetLastError()));
            break;
        }


        //
        // Return the new certificate, but first loop back and see if it's been
        // renewed itself.
        //

        pCertContext = pNewCert;
        *ppNewCertificate = pNewCert;


        //DebugLog((DEB_TRACE, "Certificate has been renewed\n"));
        fRenewed = TRUE;
    }


    //
    // Cleanup.
    //

    if(hMyCertStore && hMyCertStore != g_hMyCertStore)
    {
        CertCloseStore(hMyCertStore, 0);
    }

    return fRenewed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wsecure.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        security.h

   Abstract:

        WWW Security Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/
#ifndef __WSECURITY_H__
#define __WSECURITY_H__

//{{AFX_INCLUDES()
#include "certauth.h"
#include "certmap.h"
#include "certwiz.h"
//}}AFX_INCLUDES

#include "wincrypt.h"

class CW3SecurityPage : public CInetPropertyPage
/*++

Class Description:

    WWW Security property page

Public Interface:

    CW3SecurityPage     : Constructor
    ~CW3SecurityPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3SecurityPage)

//
// Construction
//
public:
    CW3SecurityPage(
        IN CInetPropertySheet * pSheet = NULL,
        IN BOOL  fHome                 = FALSE,
        IN DWORD dwAttributes          = 0L
        );

    ~CW3SecurityPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3SecurityPage)
    enum { IDD = IDD_DIRECTORY_SECURITY };
    BOOL    m_fUseNTMapper;
    CStatic m_icon_Secure;
    CStatic m_static_SSLPrompt;
    CButton m_check_EnableDS;
    CButton m_button_GetCertificates;
    CButton m_button_ViewCertificates;
    CButton m_button_Communications;
    //}}AFX_DATA

    CCertWiz    m_ocx_CertificateAuthorities;

    DWORD       m_dwAuthFlags;
    DWORD       m_dwSSLAccessPermissions;
    CString     m_strBasicDomain;
    CString     m_strRealm;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3SecurityPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3SecurityPage)
    afx_msg void OnButtonAuthentication();
    afx_msg void OnButtonCommunications();
    afx_msg void OnButtonIpSecurity();
    afx_msg void OnButtonGetCertificates();
    afx_msg void OnButtonViewCertificates();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    BOOL FetchSSLState();
    void SetSSLControlState();

    LPCTSTR QueryInstanceMetaPath();

//
// Sheet Access
//
protected:
    CBlob & GetIPL() { return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().m_ipl; }

private:
    BOOL        m_fIpDirty;
    BOOL        m_fDefaultGranted;
    BOOL        m_fOldDefaultGranted;
    BOOL        m_fPasswordSync;
	BOOL		m_fPasswordSyncInitial;
    BOOL        m_fCertInstalled;
    BOOL        m_fU2Installed;
    BOOL        m_fHome;
    CString     m_strAnonUserName;
    CStrPassword m_strAnonPassword;
    CObListPlus m_oblAccessList;
    //
    // Certificate and CTL information
    //
    CBlob       m_CertHash;
    CString     m_strCertStoreName;
    CString     m_strCTLIdentifier;
    CString     m_strCTLStoreName;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR CW3SecurityPage::QueryInstanceMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}

BOOL
CheckForCertificateRenewal(
    DWORD dwProtocol,
    PCCERT_CONTEXT pCertContext,
    PCCERT_CONTEXT *ppNewCertificate);

#endif // __SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wservic.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wservic.cpp

   Abstract:
        WWW Service Property Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "wservic.h"
#include "mmmdlg.h"
#include "iisobj.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Values for PWS
//
#define LIMITED_CONNECTIONS_MIN    (10)
#define LIMITED_CONNECTIONS_MAX    (40)



//
// Default SSL port
//
#define DEFAULT_SSL_PORT            (441)

//#define ZERO_IS_A_VALID_SSL_PORT 

IMPLEMENT_DYNCREATE(CW3ServicePage, CInetPropertyPage)




CW3ServicePage::CW3ServicePage(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CW3ServicePage::IDD, pSheet),
      m_nSSLPort(DEFAULT_SSL_PORT),
      m_nTCPPort(80),
      m_iSSL(-1),
      m_iaIpAddress(NULL_IP_ADDRESS),
	  m_iaIpAddressSSL(NULL_IP_ADDRESS),
      m_strDomainName()
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CW3ServicePage)
    m_nUnlimited = RADIO_LIMITED;
    m_nIpAddressSel = -1;
    m_nTCPPort = 80;
    m_fEnableLogging = FALSE;
    m_fUseKeepAlives = FALSE;
    m_strComment = _T("");
    m_strDomainName = _T("");
    m_nSSLPort = DEFAULT_SSL_PORT;
    //}}AFX_DATA_INIT

    m_iaIpAddress = (LONG)0L;
	m_iaIpAddressSSL = (LONG)0L;
    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
    m_nConnectionTimeOut = 600;
    m_nSSLPort = DEFAULT_SSL_PORT;
    m_fUnlimitedConnections = FALSE;

#endif // 0
}

CW3ServicePage::~CW3ServicePage()
{
}

void
CW3ServicePage::GetTopBinding()
/*++

Routine Description:
    Get the first binding information in the list

--*/
{
    //
    // Show primary values;
    //
    ASSERT(m_strlBindings.GetCount() > 0 || IS_MASTER_INSTANCE(QueryInstance()));
    if (m_strlBindings.GetCount() > 0)
    {
        CString & strBinding = m_strlBindings.GetHead();
        CInstanceProps::CrackBinding(strBinding, m_iaIpAddress, m_nTCPPort, m_strDomainName);
    }

	m_iSSL = -1;
	m_nSSLPort = -1;
    if (m_strlSecureBindings.GetCount() > 0)
    {
		CString strDomainName;
        CString & strBindingSSL = m_strlSecureBindings.GetHead();
        CInstanceProps::CrackBinding(strBindingSSL, m_iaIpAddressSSL, m_nSSLPort, strDomainName);

        //
        // Find SSL port that is bound to this IP address
        //
        m_iSSL = CInstanceProps::FindMatchingSecurePort(
            m_strlSecureBindings, m_iaIpAddressSSL, m_nSSLPort);
		if (-1 == m_iSSL)
		{
			m_nSSLPort = -1;
		}
	}
}



BOOL
CW3ServicePage::StoreTopBinding()
/*++

Routine Description:

    Take values from the dialog, and put them into the top level
    binding string.

Arguments:

    None

Return Value:

    TRUE if the values are correct, FALSE otherwise.

--*/
{
    if (!FetchIpAddressFromCombo(m_combo_IpAddresses, m_oblIpAddresses, m_iaIpAddress))
    {
        //
        // Because UpdateData() is called before this, this should NEVER fail
        //
        ASSERT(FALSE);
        return FALSE;
    }

    CString strBinding;
    ASSERT(m_nTCPPort > 0);

    if (m_nTCPPort == m_nSSLPort)
    {
        //
        // TCP port and SSL port cannot be the same
        //
        EditShowBalloon(GetDlgItem(IDC_EDIT_SSL_PORT)->m_hWnd, IDS_TCP_SSL_PART);
        return FALSE;
    }

    CInstanceProps::BuildBinding(strBinding, m_iaIpAddress, m_nTCPPort, m_strDomainName);
    //
    // Check binding ok
    //
    if (m_strlBindings.GetCount() > 0)
    {
        if (!IsBindingUnique(strBinding, m_strlBindings, 0))
        {
            EditShowBalloon(GetDlgItem(IDC_EDIT_TCP_PORT)->m_hWnd, IDS_ERR_BINDING);
            return FALSE;
        }
        m_strlBindings.SetAt(m_strlBindings.GetHeadPosition(), strBinding);
    }
    else
    {
        m_strlBindings.AddTail(strBinding);
    }

    //
    // Now do the same for the SSL binding
    //
//    if (m_fCertInstalled)
//    {
#ifdef ZERO_IS_A_VALID_SSL_PORT
	if (m_nSSLPort != -1)
#else
	if (m_nSSLPort > 0 && m_nSSLPort != -1)
#endif
        {
			CInstanceProps::BuildSecureBinding(strBinding, m_iaIpAddressSSL, m_nSSLPort);

            if (m_strlSecureBindings.GetCount() > 0)
            {
                if (IsBindingUnique(strBinding, m_strlSecureBindings, m_iSSL))
                {
                    //
                    // Find its place
                    //
                    if (m_iSSL != -1)
                    {
                        //
                        // Replace selected entry
                        //
                        m_strlSecureBindings.SetAt(
                            m_strlSecureBindings.FindIndex(m_iSSL), strBinding);
                    }
                    else
                    {
                        //
                        // Add to end of list
                        //
                        ASSERT(!m_strlSecureBindings.IsEmpty());
                        m_strlSecureBindings.AddTail(strBinding);
                        m_iSSL = (int)m_strlSecureBindings.GetCount() - 1;
                    }
                }
                else
                {
                    //
                    // Entry already existed in the list.  This is OK, just
                    // delete the current entry rather than bothering
                    // to change it.
                    //
                    ASSERT(m_iSSL != -1);
                    if (m_iSSL != -1)
                    {
                        m_strlSecureBindings.RemoveAt(
                            m_strlSecureBindings.FindIndex(m_iSSL)
                            );

                        m_iSSL = CInstanceProps::FindMatchingSecurePort(
                            m_strlSecureBindings, m_iaIpAddress, m_nSSLPort);

                        ASSERT(m_iSSL != -1);
						if (-1 == m_iSSL)
						{
							m_nSSLPort = -1;
						}
                    }
                }
            }
            else
            {
                //
                // List of secure bindings was empty, add new entry
                //
                m_strlSecureBindings.AddTail(strBinding);
                m_iSSL = 0;
            }
        }
        else
        {
            //
            // Delete the secure binding if it did exist
            //
            if (m_iSSL != -1)
            {
                m_strlSecureBindings.RemoveAt(
                    m_strlSecureBindings.FindIndex(m_iSSL)
                    );
                m_iSSL = -1;
            }
        }
//    }

    return TRUE;
}



void
CW3ServicePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store Control Data

Arguments:

    CDataExchange * pDX : Data exchange object

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        m_fEnableLogging = LoggingEnabled(m_dwLogType);
    }

    //{{AFX_DATA_MAP(CW3ServicePage)
    DDX_Control(pDX, IDC_BUTTON_PROPERTIES, m_button_LogProperties);
    DDX_Control(pDX, IDC_STATIC_LOG_PROMPT, m_static_LogPrompt);
    DDX_Control(pDX, IDC_EDIT_SSL_PORT, m_edit_SSLPort);
    DDX_Control(pDX, IDC_EDIT_TCP_PORT, m_edit_TCPPort);
    DDX_Control(pDX, IDC_COMBO_LOG_FORMATS, m_combo_LogFormats);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESS, m_combo_IpAddresses);
    DDX_Check(pDX, IDC_CHECK_USE_KEEPALIVE, m_fUseKeepAlives);
    DDX_Check(pDX, IDC_CHECK_ENABLE_LOGGING, m_fEnableLogging);
    DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
    DDV_MinMaxChars(pDX, m_strComment, 0, MAX_PATH);
    //}}AFX_DATA_MAP

    if (    pDX->m_bSaveAndValidate 
        &&  !FetchIpAddressFromCombo(m_combo_IpAddresses, m_oblIpAddresses, m_iaIpAddress)
        )
    {
        pDX->Fail();
    }

	// This Needs to come before DDX_Text which will try to put text big number into small number
	DDV_MinMaxBalloon(pDX, IDC_EDIT_CONNECTION_TIMEOUT, 0, MAX_TIMEOUT);
    DDX_Text(pDX, IDC_EDIT_CONNECTION_TIMEOUT, m_nConnectionTimeOut);

    //
    // Port DDXV must be done just prior to storetopbinding,
    // so as to activate the right control in case of
    // failure
    //
    if (!IS_MASTER_INSTANCE(QueryInstance()))
    {
        DDXV_UINT(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort, 1, 65535, IDS_NO_PORT);

        // If user will clear SSL port or set it to 0, we will remove this property
        if (pDX->m_bSaveAndValidate)
        {
			// user is not forced to put a number in when saving port
            if (GetDlgItem(IDC_EDIT_SSL_PORT)->GetWindowTextLength())
            {
				DDXV_UINT(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort, 1, 65535, IDS_NO_PORT);
                DDX_TextBalloon(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort);
            }
            else
			{
                m_nSSLPort = -1;
			}
        }
        else
		{
			DDXV_UINT(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort, 1, 65535, IDS_NO_PORT);
			if (m_nSSLPort == -1)
			{
				CString strTemp = _T("");
				DDX_Text(pDX, IDC_EDIT_SSL_PORT, strTemp);
			}
			else
			{
				DDX_Text(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort);
			}
		}
    }

    if (pDX->m_bSaveAndValidate)
    {
        if (!IS_MASTER_INSTANCE(QueryInstance()))
        {
            if (!StoreTopBinding())
            {
                pDX->Fail();
            }
        }

        EnableLogging(m_dwLogType, m_fEnableLogging);
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CW3ServicePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3ServicePage)
//    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
//    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_LOGGING, OnCheckEnableLogging)
    ON_BN_CLICKED(IDC_BUTTON_ADVANCED, OnButtonAdvanced)
    ON_BN_CLICKED(IDC_BUTTON_PROPERTIES, OnButtonProperties)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_BN_CLICKED(IDC_CHECK_USE_KEEPALIVE, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnItemChanged)
//    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_IP_ADDRESS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_SSL_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_CBN_EDITCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_LOG_FORMATS, OnItemChanged)

END_MESSAGE_MAP()



void
CW3ServicePage::SetControlStates()
/*++

Routine Description:

    Set control states depending on the currently selected items

Arguments:

    None

Return Value:

    None.

--*/
{
//    if (m_edit_MaxConnections.m_hWnd)
//    {
//        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
//        m_static_Connections.EnableWindow(!m_fUnlimitedConnections);
//    }
}



void
CW3ServicePage::SetLogState()
/*++

Routine Description:

    Enable/disable logging controls depending on whether logging
    is enabled or not.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_LogPrompt.EnableWindow(m_fEnableLogging);
    m_combo_LogFormats.EnableWindow(m_fEnableLogging);
    m_button_LogProperties.EnableWindow(m_fEnableLogging);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3ServicePage::OnSetActive()
/*++

Routine Description:

    Property page is getting activation notification

Arguments:

    None

Return Value:

    TRUE to activate the page, FALSE otherwise.

--*/
{
    //
    // No certificates, no SSL
    //
    BeginWaitCursor();
    m_fCertInstalled = IsCertInstalledOnServer(QueryAuthInfo(), QueryMetaPath());
    EndWaitCursor();

    GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(
        !IS_MASTER_INSTANCE(QueryInstance())
     && HasAdminAccess()
        );

    GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(
        !IS_MASTER_INSTANCE(QueryInstance())
     && HasAdminAccess()
        );

    return CInetPropertyPage::OnSetActive();
}



BOOL
CW3ServicePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CInetPropertyPage::OnInitDialog();

    //
    // Take our direction from a phony button
    //
    CRect rc(0, 0, 0, 0);
    VERIFY(m_ocx_LogProperties.Create(_T("LogUI"), WS_BORDER,
        rc, this, IDC_LOGUICTRL));
    //
    // Initialize the logging ocx
    //
    m_ocx_LogProperties.SetAdminTarget(QueryServerName(), QueryMetaPath());
    m_ocx_LogProperties.SetUserData(QueryAuthInfo()->QueryUserName(), QueryAuthInfo()->QueryPassword());
    m_ocx_LogProperties.SetComboBox(m_combo_LogFormats.m_hWnd);

    //
    // Disable non heritable properties for master instance
    // or operator
    //
    if (IS_MASTER_INSTANCE(QueryInstance()) || !HasAdminAccess())
    {
        GetDlgItem(IDC_STATIC_IP_ADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_COMBO_IP_ADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON_ADVANCED)->EnableWindow(FALSE);
		GetDlgItem(IDC_STATIC_DESCRIPTION)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_COMMENT)->EnableWindow(FALSE);
    }

    {
        CWaitCursor wait;

        PopulateComboWithKnownIpAddresses(
            QueryServerName(),
            m_combo_IpAddresses,
            m_iaIpAddress,
            m_oblIpAddresses,
            m_nIpAddressSel
            );
    }

    SetControlStates();
    SetLogState();

    return TRUE;
}



/* virtual */
HRESULT
CW3ServicePage::FetchLoadedValues()
/*++

Routine Description:

    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    m_fCertInstalled = ::IsCertInstalledOnServer(QueryAuthInfo(), QueryMetaPath());

    BEGIN_META_INST_READ(CW3Sheet)
        FETCH_INST_DATA_FROM_SHEET(m_fUseKeepAlives);
//        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_nConnectionTimeOut);
        FETCH_INST_DATA_FROM_SHEET(m_strComment);
        FETCH_INST_DATA_FROM_SHEET(m_dwLogType);
        FETCH_INST_DATA_FROM_SHEET(m_strlBindings);
        FETCH_INST_DATA_FROM_SHEET(m_strlSecureBindings);
        GetTopBinding();
#if 0
        m_fUnlimitedConnections =
            ((ULONG)(LONG)m_nMaxConnections >= UNLIMITED_CONNECTIONS);

        if (Has10ConnectionLimit())
        {
            m_fUnlimitedConnections = FALSE;
            if ((LONG)m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
            {
                m_nMaxConnections = LIMITED_CONNECTIONS_MAX;
            }
        }
        //
        // Set the visible max connections edit field, which
        // may start out with a default value
        //
        m_nVisibleMaxConnections = m_fUnlimitedConnections
            ? INITIAL_MAX_CONNECTIONS
            : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;
#endif
        m_nOldTCPPort = m_nTCPPort;
    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3ServicePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    BOOL fUpdateData : If TRUE, control data has not yet been stored.  This
                       is the case when "apply" is pressed.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 service page now...");

    CError err;
#if 0
    m_nMaxConnections = m_fUnlimitedConnections
        ? UNLIMITED_CONNECTIONS
        : m_nVisibleMaxConnections;

    //
    // Check to make sure we're not violating the license
    // agreement
    //
    if (Has10ConnectionLimit())
    {
        if (m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
        {
            DoHelpMessageBox(m_hWnd,IDS_CONNECTION_LIMIT, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
            m_nMaxConnections = LIMITED_CONNECTIONS_MIN;
        }
        else if (m_nMaxConnections >  LIMITED_CONNECTIONS_MIN
              && m_nMaxConnections <= LIMITED_CONNECTIONS_MAX)
        {
            DoHelpMessageBox(m_hWnd,IDS_WRN_CONNECTION_LIMIT, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
        }
    }
#endif
    m_ocx_LogProperties.ApplyLogSelection();
//	BOOL fUpdateNode = FALSE;

    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        STORE_INST_DATA_ON_SHEET(m_fUseKeepAlives);
        STORE_INST_DATA_ON_SHEET(m_nConnectionTimeOut);
        STORE_INST_DATA_ON_SHEET(m_strComment);
//		fUpdateNode = MP_D(((CW3Sheet *)GetSheet())->GetInstanceProperties().m_strComment);
        STORE_INST_DATA_ON_SHEET(m_dwLogType);
        STORE_INST_DATA_ON_SHEET(m_strlBindings);
        STORE_INST_DATA_ON_SHEET(m_strlSecureBindings);
    END_META_INST_WRITE(err)

	if (err.Succeeded()/* && fUpdateNode*/)
	{
		NotifyMMC(PROP_CHANGE_DISPLAY_ONLY);
	}

    EndWaitCursor();

    return err;
}



void
CW3ServicePage::OnItemChanged()
/*++

Routine Description

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    SetModified(TRUE);
}


#if 0
void
CW3ServicePage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0,-1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}



void
CW3ServicePage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}
#endif


void
CW3ServicePage::ShowTopBinding()
/*++

Routine Description:

    Put information about the top level binding in the dialog controls

Arguments:

    None

Return Value:

    None

--*/
{
    BeginWaitCursor();
    GetTopBinding();

    PopulateComboWithKnownIpAddresses(
        QueryServerName(),
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();

    CString strTCPPort, strSSLPort;
    if (m_nTCPPort)
    {
        strTCPPort.Format(_T("%ld"), m_nTCPPort);
    }
#ifdef ZERO_IS_A_VALID_SSL_PORT
	if (-1 == m_nSSLPort)
#else
	if (0 == m_nSSLPort || -1 == m_nSSLPort)
#endif
    {
		strSSLPort = _T("");
	}
	else
	{
		strSSLPort.Format(_T("%ld"), m_nSSLPort);
    }

    m_edit_TCPPort.SetWindowText(strTCPPort);
    m_edit_SSLPort.SetWindowText(strSSLPort);
}



void
CW3ServicePage::OnButtonAdvanced()
/*++

Routine Description:

    'advanced' button handler -- bring up the bindings dialog

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CMMMDlg dlg(
        QueryServerName(),
        QueryInstance(),
        QueryAuthInfo(),
        QueryMetaPath(),
        m_strlBindings,
        m_strlSecureBindings,
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        //
        // Get information about the top level binding
        //
        m_strlBindings.RemoveAll();
        m_strlSecureBindings.RemoveAll();
        m_strlBindings.AddTail(&(dlg.GetBindings()));
        m_strlSecureBindings.AddTail(&(dlg.GetSecureBindings()));
        ShowTopBinding();
        OnItemChanged();
    }
}



void
CW3ServicePage::OnCheckEnableLogging()
/*++

Routine Description:

    'enable logging' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableLogging = !m_fEnableLogging;
    SetLogState();
    OnItemChanged();
}



void
CW3ServicePage::OnButtonProperties()
/*++

Routine Description:

    Pass on "log properties" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    m_ocx_LogProperties.DoClick();
}



void
CW3ServicePage::OnDestroy()
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();

    if (m_ocx_LogProperties.m_hWnd)
    {
        m_ocx_LogProperties.Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wservic.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wservic.h

   Abstract:
        WWW Service Property Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//{{AFX_INCLUDES()
#include "logui.h"
//}}AFX_INCLUDES

class CW3Sheet;

class CW3ServicePage : public CInetPropertyPage
/*++

Class Description:

    WWW Service Page 

Public Interface:

    CW3ServicePage      : Constructor
    ~CW3ServicePage     : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3ServicePage)

//
// Construction
//
public:
    CW3ServicePage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3ServicePage();

//
// Dialog Data
//
protected:
    //
    //  Radio button IDs for unlimited radio control
    //
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CW3ServicePage)
    enum { IDD = IDD_WEB_SERVICE };
//    int         m_nUnlimited;
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    BOOL        m_fUseKeepAlives;
    BOOL        m_fEnableLogging;
    CString     m_strComment;
    CString     m_strDomainName;
    CEdit       m_edit_SSLPort;
    CEdit       m_edit_TCPPort;
//    CEdit       m_edit_MaxConnections;
//    CButton     m_radio_Unlimited;
    CButton     m_button_LogProperties;
    CStatic     m_static_SSLPort;
//    CStatic     m_static_Connections;
    CStatic     m_static_LogPrompt;
    CComboBox   m_combo_LogFormats;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    int         m_iSSL;
//    BOOL        m_fUnlimitedConnections;
    UINT        m_nOldTCPPort;
    UINT        m_nSSLPort;
    CILong      m_nConnectionTimeOut;
//    CILong      m_nMaxConnections;
//    CILong      m_nVisibleMaxConnections;
    CLogUI      m_ocx_LogProperties;
    CIPAddress  m_iaIpAddress;
	CIPAddress  m_iaIpAddressSSL;
    DWORD       m_dwLogType;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3ServicePage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3ServicePage)
    virtual BOOL OnInitDialog();
//    afx_msg void OnRadioLimited();
//    afx_msg void OnRadioUnlimited();
    afx_msg void OnCheckEnableLogging();
    afx_msg void OnButtonAdvanced();
    afx_msg void OnButtonProperties();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    void SetLogState();
    void GetTopBinding();
    void ShowTopBinding();
    BOOL StoreTopBinding();
    LPCTSTR QueryMetaPath();

//
// Access to the sheet data
//
protected:
    BOOL          m_fCertInstalled;
    CObListPlus   m_oblIpAddresses;
    CStringListEx m_strlBindings;
    CStringListEx m_strlSecureBindings;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR CW3ServicePage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\ssltools\backup.cpp ===
#include "stdafx.h"

#ifndef _CHICAGO_

// this file is always compile UNICODE in the library - so the conversions work out right

//
//Local includes
//
#include "certupgr.h"

#define		BACKUP_ID	'KRBK'

//------------------------------------------------------------------------------
void ReadWriteDWORD( HANDLE hFile, DWORD *pDword, BOOL fRead );
void ReadWriteString( HANDLE hFile, LPTSTR* ppsz, BOOL fRead );
void ReadWriteBlob( HANDLE hFile, PVOID pBlob, DWORD cbBlob, BOOL fRead );

//-------------------------------------------------------------------------
PCCERT_CONTEXT ImportKRBackupToCAPIStore_A(
                        PCHAR pszFileName,          // path of the file
                        PCHAR pszPassword,          // ANSI password
                        PCHAR pszCAPIStore,         // name of the capi store
                        BOOL  bOverWrite
                        )        
    {
    PCCERT_CONTEXT  pCert = NULL;

    // prep the wide strings
    PWCHAR  pszwFileName = NULL;
    PWCHAR  pszwCAPIStore = NULL;
    DWORD   lenFile = (strlen(pszFileName)+1) * sizeof(TCHAR);
    DWORD   lenStore = (strlen(pszCAPIStore)+1) * sizeof(TCHAR);
    pszwFileName = (PWCHAR)GlobalAlloc( GPTR, lenFile );
    pszwCAPIStore = (PWCHAR)GlobalAlloc( GPTR, lenStore );
    if ( !pszwFileName || !pszwCAPIStore )
        goto cleanup;

    // convert the strings
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszFileName, -1, pszwFileName, lenFile );
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszCAPIStore, -1, pszwCAPIStore, lenStore );

    // do the real call
    pCert = ImportKRBackupToCAPIStore_W( pszwFileName, pszPassword, pszwCAPIStore, bOverWrite);
    
cleanup:
    // preserve the last error state
    DWORD   err = GetLastError();

    // clean up the strings
    if ( pszwFileName )
        GlobalFree( pszwFileName );
    if ( pszwCAPIStore )
        GlobalFree( pszwCAPIStore );

    // reset the last error state
    SetLastError( err );

    // return the cert
    return pCert;
    }

//-------------------------------------------------------------------------
// Import old-style keyring backup file
PCCERT_CONTEXT ImportKRBackupToCAPIStore_W(
                            PWCHAR ptszFileName,        // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PWCHAR pszCAPIStore,        // name of the capi store
                            BOOL bOverWrite
                            )
    {
    PCCERT_CONTEXT  pCertContext = NULL;
	DWORD	        dword;
    LPTSTR          psz = NULL;

    // prep the file name
    HANDLE          hFile = NULL;

    // This code is originally from KeyRing. The fImport controlled whether it was reading
    // or writing the file. In this case, we are always and only reading it. so....
    const BOOL    fImport = TRUE;

    // also, this was a method on a class. The appropriate member variables are now here
    PVOID   pPrivateKey = NULL;
    DWORD   cbPrivateKey;
    PVOID   pCertificate = NULL;
    DWORD   cbCertificate;
    PVOID   pRequest = NULL;
    DWORD   cbRequest = 0;
	CString	szName;

    // open the file
    hFile = CreateFile(
            ptszFileName,               // pointer to name of the file  
            GENERIC_READ,               // access (read-write) mode  
            FILE_SHARE_READ,            // share mode  
            NULL,                       // pointer to security attributes  
            OPEN_EXISTING,              // how to create  
            FILE_ATTRIBUTE_NORMAL,      // file attributes  
            NULL                        // handle to file with attributes to copy  
            );
    if ( hFile == INVALID_HANDLE_VALUE )
        return NULL;

	// do the backup id
	dword = BACKUP_ID;
	ReadWriteDWORD( hFile, &dword, fImport );

	// check the backup id
	if ( dword != BACKUP_ID )
		{
        goto cleanup;
		}

	// start with the name of the key
	ReadWriteString( hFile, &psz, fImport );

    // we aren't using the name for now, so throw it away.....
    if ( psz )
        GlobalFree( psz );
    psz = NULL;

	// now the private key data size
	ReadWriteDWORD( hFile, &cbPrivateKey, fImport );

	// make a private key data pointer if necessary
	if ( fImport && cbPrivateKey )
		{
		pPrivateKey = GlobalAlloc( GPTR, cbPrivateKey );
		if ( !pPrivateKey )
            {
            goto cleanup;
            }
		}
	
	// use the private key pointer
	if ( cbPrivateKey )
		ReadWriteBlob( hFile, pPrivateKey, cbPrivateKey, fImport );


	// now the certificate
	ReadWriteDWORD( hFile, &cbCertificate, fImport );

	// make a data pointer if necessary
	if ( fImport && cbCertificate )
		{
		pCertificate = GlobalAlloc( GPTR, cbCertificate );
		if ( !pCertificate )
            {
            goto cleanup;
            }
		}
	
	// use the public key pointer
	if ( cbCertificate )
		ReadWriteBlob( hFile, pCertificate, cbCertificate, fImport );


	// now the request - if there is one
	ReadWriteDWORD( hFile, &cbRequest, fImport );

	// make a data pointer if necessary
	if ( fImport && cbRequest )
		{
		pRequest = GlobalAlloc( GPTR, cbRequest );
		if ( !pRequest )
            {
            goto cleanup;
            }
		}
	
	// use the request pointer
	if ( cbRequest )
		ReadWriteBlob( hFile, pRequest, cbRequest, fImport );


    // finally, do the CAPI conversion here
    pCertContext = CopyKRCertToCAPIStore(
                        pPrivateKey, cbPrivateKey,
                        pCertificate, cbCertificate,
                        pRequest, cbRequest,
                        pszPassword,
                        pszCAPIStore,
                        bOverWrite);

    // clean up
cleanup:
    if ( hFile )
        CloseHandle( hFile );
    if ( pPrivateKey )
        GlobalFree( pPrivateKey );
    if ( pCertificate )
        GlobalFree( pCertificate );
    if ( pRequest )
        GlobalFree( pRequest );

    // return the context
    return pCertContext;
    }




// file utilities
//---------------------------------------------------------------------------
void ReadWriteDWORD( HANDLE hFile, DWORD *pDword, BOOL fRead )
	{
	// read it or write it
    ReadWriteBlob( hFile, pDword, sizeof(DWORD), fRead );
	}

//---------------------------------------------------------------------------
// remember - we are only and always reading - never writing.......
void ReadWriteString( HANDLE hFile, LPTSTR* ppsz, BOOL fRead )
	{
	// get the length of the string
	DWORD	cbLength = 0;
	ReadWriteDWORD(hFile,&cbLength,fRead );

    // allocate the buffer for the new string - it is the responsibility
    // of the caller to ensure that ppsz is not pointing to something that
    // needs to be freed.
    if ( fRead )
        {
        *ppsz = (LPTSTR)GlobalAlloc( GPTR, cbLength+1 );
        ASSERT( *ppsz );
        if ( !*ppsz )
            AfxThrowMemoryException();
        }

	// read or write the string
	ReadWriteBlob(hFile, *ppsz, cbLength+1, fRead);
	}

/* #pragma INTRINSA suppress=all */

//---------------------------------------------------------------------------
void ReadWriteBlob( HANDLE hFile, PVOID pBlob, DWORD cbBlob, BOOL fRead )
	{
	// read it or write it 
    // - always read it here this isn't keyring anymore
    ReadFile(
            hFile,              // handle of file to read
            pBlob,              // address of buffer that receives data
            cbBlob,             // number of bytes to read
            &cbBlob,            // address of number of bytes read
            NULL                // address of structure for data
            ); 
	}





#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\ssltools\certupgr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    certupgr.cxx

Abstract:

    Functions used in upgrading server certs from K2 [server cert in metabase] to
    Avalanche [server cert in CAPI store].

Author:

    Alex Mallet (amallet)    07-Dec-1997
    Boyd Multerer (boydm)    20-Jan-1998        Converted to be useful in setup

--*/

#include "stdafx.h"
#include <objbase.h>

#ifndef _CHICAGO_


#include "oidenc.h"


// keyring include
//#include "intrlkey.h"
// This stuff below is moved from above include
#define REQUEST_HEADER_K2B2VERSION  0x0101

#define REQUEST_HEADER_IDENTIFIER	'RHDR'
#define REQUEST_HEADER_CURVERSION	0x0101



typedef struct _KeyRequestHeader
	{
	DWORD	Identifier;				// must be 'RHDR'
	DWORD	Version;				// version of header record
	DWORD	cbSizeOfHeader;			// byte count of header. Afterwards is the request.
	DWORD	cbRequestSize;			// size of the request that follows
	BOOL	fReqSentToOnlineCA;
    LONG    longRequestID;
	BOOL	fWaitingForApproval;
	char	chCA[MAX_PATH];
	} KeyRequestHeader, *LPREQUEST_HEADER;
///--- end of #include "intrlkey.h"

//
//Local includes
//
#include "certupgr.h"
//#include "certtools.h"


// The below define is in some interal schannel header file. John Banes
// told me to just redefine it below as such........ - Boyd
LPCSTR SGC_KEY_SALT  =  "SGCKEYSALT";


// prototypes
BOOL DecodeAndImportPrivateKey( PBYTE pbEncodedPrivateKey IN,
                                DWORD cbEncodedPrivateKey IN,
                                PCHAR pszPassword IN,
                                PWCHAR pszKeyContainerIN,
                                CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo );
BOOL UpdateCSPInfo( PCCERT_CONTEXT pcCertContext );


BOOL FImportAndStoreRequest( PCCERT_CONTEXT pCert, PVOID pbPKCS10req, DWORD cbPKCS10req );

//-------------------------------------------------------------------------
PCCERT_CONTEXT CopyKRCertToCAPIStore_A( PVOID pbPrivateKey, DWORD cbPrivateKey,
                            PVOID pbPublicKey, DWORD cbPublicKey,
                            PVOID pbPKCS10req, DWORD cbPKCS10req,
                            PCHAR pszPassword,
                            PCHAR pszCAPIStore,
                            BOOL  bOverWrite)
    {
    PCCERT_CONTEXT  pCert = NULL;

    // prep the wide strings
    PWCHAR  pszwCAPIStore = NULL;
    DWORD   lenStore = (strlen(pszCAPIStore)+1) * sizeof(WCHAR);
    pszwCAPIStore = (PWCHAR)GlobalAlloc( GPTR, lenStore );
    if ( !pszwCAPIStore )
        goto cleanup;

    // convert the strings
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszCAPIStore, -1, pszwCAPIStore, lenStore );

    // do the real call
    pCert = CopyKRCertToCAPIStore_W(
                            pbPrivateKey, cbPrivateKey,
                            pbPublicKey, cbPublicKey,
                            pbPKCS10req, cbPKCS10req,
                            pszPassword,
                            pszwCAPIStore,
                            bOverWrite);

cleanup:
    // preserve the last error state
    DWORD   err = GetLastError();

    // clean up the strings
    if ( pszwCAPIStore )
        GlobalFree( pszwCAPIStore );

    // reset the last error state
    SetLastError( err );

    // return the cert
    return pCert;
    }

//--------------------------------------------------------------------------------------------
// Copies an old Key-Ring style cert to the CAPI store. This cert comes in as two binaries and a password.
PCCERT_CONTEXT CopyKRCertToCAPIStore_W( PVOID pbPrivateKey, DWORD cbPrivateKey,
                            PVOID pbPublicKey, DWORD cbPublicKey,
                            PVOID pbPKCS10req, DWORD cbPKCS10req,
                            PCHAR pszPassword,
                            PWCHAR pszCAPIStore,
                            BOOL  bOverWrite)
/*++

Routine Description:

    Upgrades K2 server certs to Avalanche server certs - reads server cert out of K2
    metabase, creates cert context and stores it in CAPI2 "MY" store and writes
    relevant information back to metabase.

Arguments:

    pMDObject - pointer to Metabase object 
    pszOldMBPath - path to where server cert is stored in old MB, relative to SSL_W3_KEYS_MD_PATH
    pszNewMBPath - fully qualified path to where server cert info should be stored in new MB

Returns:

    BOOL indicating success/failure

--*/
    {
    BOOL        fSuccess = FALSE;

    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pcCertContext = NULL;
    LPOLESTR    polestr = NULL;


    // start by opening the CAPI store that we will be saving the certificate into
    hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                pszCAPIStore );
    if ( !hStore )
        {
//        iisDebugOut((_T("Error 0x%x calling CertOpenStore \n"), GetLastError());
        goto EndUpgradeServerCert;
        }


    // at this point we check to see if a certificate was passed in. If none was, then we need
    // to create a dummy-temporary certificate that markes the private key as incomplete. That
    // way, then the real certificate comes back from verisign the regular tools can be used
    // to complete the key.
    //CertCreateSelfSignCertificate()


    //
    //Create cert context to be stored in CAPI store
    //
    pbPublicKey = (PVOID)((PBYTE)pbPublicKey + CERT_DER_PREFIX);
    cbPublicKey -= CERT_DER_PREFIX;
    pcCertContext = CertCreateCertificateContext( X509_ASN_ENCODING, (PUCHAR)pbPublicKey, cbPublicKey);
    if ( pcCertContext )
        {

        // the private key gets stored in a seperate location from the certificate and gets referred to
        // by the certificate. We should try to pick a unique name so that some other cert won't step
        // on it by accident. There is no formal format for this name whatsoever. Some groups use a
        // human-readable string, some use a hash of the cert, and some use a GUID string. All are valid
        // although for generated certs the hash or the GUID are probably better.

        // get the 128 big md5 hash of the cert for the name
        DWORD dwHashSize;
        BOOL    fHash;

        BYTE MD5Hash[16];                // give it some extra size
        dwHashSize = sizeof(MD5Hash);
        fHash = CertGetCertificateContextProperty( pcCertContext,
                            CERT_MD5_HASH_PROP_ID,
                            (VOID *) MD5Hash,
                            &dwHashSize );

        // Since the MD5 hash is the same size as a guid, we can use the guid utilities to make a
        // nice string out of it.
        HRESULT     hresult;
        hresult = StringFromCLSID( (REFCLSID)MD5Hash, &polestr );

        //
        // Now decode private key blob and import it into CAPI1 private key
        //
        CRYPT_KEY_PROV_INFO CryptKeyProvInfo;

        if ( DecodeAndImportPrivateKey( (PUCHAR)pbPrivateKey, cbPrivateKey, pszPassword,
                                        polestr, &CryptKeyProvInfo ) )
            {
            //
            // Add the private key to the cert context
            //
            BOOL    f;
            f = CertSetCertificateContextProperty( pcCertContext, CERT_KEY_PROV_INFO_PROP_ID, 
                                                    0, &CryptKeyProvInfo );
            f = UpdateCSPInfo( pcCertContext );
            if ( f )
                {
                //
                // Store it in the provided store
                //
                if (bOverWrite)
                {
                    if ( CertAddCertificateContextToStore( hStore, pcCertContext,
                                                           CERT_STORE_ADD_REPLACE_EXISTING, NULL ) )
                        {
                        fSuccess = TRUE;

                        // Write out the original request as a property on the cert
                        FImportAndStoreRequest( pcCertContext, pbPKCS10req, cbPKCS10req );
                        }
                    else
                        {
    //                    iisDebugOut((_T("Error 0x%x calling CertAddCertificateContextToStore"), GetLastError());
                        }
                }
                else
                {
                    if ( CertAddCertificateContextToStore( hStore, pcCertContext,
                                                           CERT_STORE_ADD_NEW, NULL ) )
                        {
                        fSuccess = TRUE;

                        // Write out the original request as a property on the cert
                        FImportAndStoreRequest( pcCertContext, pbPKCS10req, cbPKCS10req );
                        }
                    else
                        {
    //                    iisDebugOut((_T("Error 0x%x calling CertAddCertificateContextToStore"), GetLastError());
                        }
                }
                }
            else
                {
//                iisDebugOut((_T("Error 0x%x calling CertSetCertificateContextProperty"), GetLastError());
                }
            }
        }
    else
        {
//        iisDebugOut((_T("Error 0x%x calling CertCreateCertificateContext"), GetLastError());
        }

    //
    //Cleanup that's done only on failure
    //
    if ( !fSuccess )
        {
        if ( pcCertContext )
            {
            CertFreeCertificateContext( pcCertContext );
            }
        pcCertContext = NULL;
        }

EndUpgradeServerCert:
    // cleanup
    if ( hStore )
        CertCloseStore ( hStore, 0 );

    if ( polestr )
        CoTaskMemFree( polestr );


    // return the answer
    return pcCertContext;
    }


//--------------------------------------------------------------------------------------------
BOOL UpdateCSPInfo( PCCERT_CONTEXT pcCertContext )
    {
    BYTE                    cbData[1000];
    CRYPT_KEY_PROV_INFO*    pProvInfo = (CRYPT_KEY_PROV_INFO *) cbData;
    DWORD                   dwFoo = 1000;
    BOOL                    fSuccess = TRUE;

    if ( ! CertGetCertificateContextProperty( pcCertContext,
                                              CERT_KEY_PROV_INFO_PROP_ID,
                                              pProvInfo,
                                              &dwFoo ) )
        {
        fSuccess = FALSE;
//        iisDebugOut((_T("Fudge. failed to get property : 0x%x"), GetLastError());
        }
    else
        {
        pProvInfo->dwProvType = PROV_RSA_SCHANNEL;
        pProvInfo->pwszProvName = NULL;
        if ( !CertSetCertificateContextProperty( pcCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 0,
                                                 pProvInfo ) )
            {
            fSuccess = FALSE;
//            iisDebugOut((_T("Fudge. failed to set property : 0x%x"), GetLastError());
            }
        }

    // return success
    return fSuccess;
    }

//--------------------------------------------------------------------------------------------
BOOL DecodeAndImportPrivateKey( PBYTE pbEncodedPrivateKey IN,
                                DWORD cbEncodedPrivateKey IN,
                                PCHAR pszPassword IN,
                                PWCHAR pszKeyContainer IN,
                                CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo )
    
/*++

Routine Description:

    Converts the private key stored in the metabase, in Schannel-internal format,
    into a key that can be imported via CryptImportKey() to create a CAP1 key blob.

Arguments:

    pbEncodedPrivateKey - pointer to [encoded] private key
    cbEncodedPrivateKey - size of encoded private key blob
    pszPassword - password used to encode private key
    pszKeyContainer - container name for private key
    pCryptKeyProvInfo - pointer to CRYPT_KEY_PROV_INFO structure filled in on success

Returns:

   BOOL indicating success/failure

--*/
    {
    BOOL fSuccess = FALSE;
    DWORD cbPassword = strlen(pszPassword);
    PPRIVATE_KEY_FILE_ENCODE pPrivateFile = NULL;
    DWORD                    cbPrivateFile = 0;
    MD5_CTX md5Ctx;
    struct RC4_KEYSTRUCT rc4Key;
    DWORD i;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hPrivateKey = NULL;
    DWORD cbDecodedPrivateKey = 0;
    PBYTE pbDecodedPrivateKey = NULL;

	DWORD err;
    //
    //HACK HACK HACK - need to make sure Schannel is initialized, so it registers
    //its custom decoders, which we make use of in the following code. So, make a 
    //bogus call to an Schannel function

    // Note: on NT5, the AcquireCredentialsHandle operates in the lsass process and
    // thus will not properly initialize the stuff we need in our process. Thus we
    // call SslGenerateRandomBits instead.
    //
    DWORD   dw;
    SslGenerateRandomBits( (PUCHAR)&dw, sizeof(dw) );

    // We have to do a little fixup here.  Old versions of
    // schannel wrote the wrong header data into the ASN
    // for private key files, so we must fix the size data.
    pbEncodedPrivateKey[2] = (BYTE) (((cbEncodedPrivateKey - 4) & 0xFF00) >> 8); //Get MSB
    pbEncodedPrivateKey[3] = (BYTE) ((cbEncodedPrivateKey - 4) & 0xFF); //Get LSB

    //
    // ASN.1 decode the private key.
    //

    //
    // Figure out the size of the buffer needed
    //
    if( !CryptDecodeObject(X509_ASN_ENCODING,
                           szPrivateKeyFileEncode,
                           pbEncodedPrivateKey,
                           cbEncodedPrivateKey,
                           0,
                           NULL,
                           &cbPrivateFile) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }

    pPrivateFile = (PPRIVATE_KEY_FILE_ENCODE) LocalAlloc( LPTR, cbPrivateFile );

    if(pPrivateFile == NULL)
        {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndDecodeKey;
        }

    //
    // Actually fill in the buffer
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyFileEncode,
                            pbEncodedPrivateKey,
                            cbEncodedPrivateKey,
                            0,
                            pPrivateFile,
                            &cbPrivateFile ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }

    //
    // Decrypt the decoded private key using the password.
    //
    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, (PBYTE) pszPassword, cbPassword);
    MD5Final(&md5Ctx);

    rc4_key( &rc4Key, 16, md5Ctx.digest );
//    memset( &md5Ctx, 0, sizeof(md5Ctx) );

    rc4( &rc4Key, 
         pPrivateFile->EncryptedBlob.cbData,
         pPrivateFile->EncryptedBlob.pbData );



    //
    // Build a PRIVATEKEYBLOB from the decrypted private key.
    //

    //
    // Figure out size of buffer needed
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyInfoEncode,
                            pPrivateFile->EncryptedBlob.pbData,
                            pPrivateFile->EncryptedBlob.cbData,
                            0,
                            NULL,
                            &cbDecodedPrivateKey ) )
        {
            // NOTE: This stuff is complicated!!! The following code came
            // from John Banes. Heck this whole routine pretty much came
            // from John Banes. -- Boyd

            // Maybe this was a SGC style key.
            // Re-encrypt it, and build the SGC decrypting
            // key, and re-decrypt it.
            BYTE md5Digest[MD5DIGESTLEN];

            rc4_key(&rc4Key, 16, md5Ctx.digest);
            rc4(&rc4Key,
                pPrivateFile->EncryptedBlob.cbData,
                pPrivateFile->EncryptedBlob.pbData);
            CopyMemory(md5Digest, md5Ctx.digest, MD5DIGESTLEN);

            MD5Init(&md5Ctx);
            MD5Update(&md5Ctx, md5Digest, MD5DIGESTLEN);
            MD5Update(&md5Ctx, (PUCHAR)SGC_KEY_SALT, strlen(SGC_KEY_SALT));
            MD5Final(&md5Ctx);
            rc4_key(&rc4Key, 16, md5Ctx.digest);
            rc4(&rc4Key,
                pPrivateFile->EncryptedBlob.cbData,
                pPrivateFile->EncryptedBlob.pbData);

            // Try again...
            if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szPrivateKeyInfoEncode,
                          pPrivateFile->EncryptedBlob.pbData,
                          pPrivateFile->EncryptedBlob.cbData,
                          0,
                          NULL,
                          &cbDecodedPrivateKey))
            {
                ZeroMemory(&md5Ctx, sizeof(md5Ctx));
                err = GetLastError();
		        goto EndDecodeKey;
            }
        
        
        }

    pbDecodedPrivateKey = (PBYTE) LocalAlloc( LPTR, cbDecodedPrivateKey );

    if( pbDecodedPrivateKey == NULL )
        {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndDecodeKey;
        }

    //
    // Actually fill in the buffer
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyInfoEncode,
                            pPrivateFile->EncryptedBlob.pbData,
                            pPrivateFile->EncryptedBlob.cbData,
                            0,
                            pbDecodedPrivateKey,
                            &cbDecodedPrivateKey ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }


    // On NT 4 the ff holds true : <- from Alex Mallet
    // Although key is going to be used for key exchange, mark it as being
    // used for signing, because only 512-bit key exchange keys are supported 
    // in the non-domestic rsabase.dll, whereas signing keys can be up to
    // 2048 bits.
    //
    // On NT 5, PROV_RSA_FULL should be changed to PROV_RSA_SCHANNEL, and 
    // aiKeyAlg to CALG_RSA_KEYX, because PROV_RSA_SCHANNEL, which is only
    // installed on NT 5, supports 1024-bit private keys for key exchange
    //
    // On NT4, Schannel doesn't care whether a key is marked for signing or exchange,
    // but on NT5 it does, so aiKeyAlg must be set appropriately
    //
    ((BLOBHEADER *) pbDecodedPrivateKey)->aiKeyAlg = CALG_RSA_KEYX;

    //
    // Clean out the key container, pszKeyContainer
    //

    CryptAcquireContext(&hProv,
                        pszKeyContainer,
                        NULL,
                        PROV_RSA_SCHANNEL,
                        CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET);
    //
    // Create a CryptoAPI key container in which to store the key.
    //
    if( !CryptAcquireContext( &hProv,
                              pszKeyContainer,
                              NULL,
                              PROV_RSA_SCHANNEL,
                              CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET))
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x calling CryptAcquireContext"), err);
        goto EndDecodeKey;
        }

    //
    // Import the private key blob into the key container.
    //
    if( !CryptImportKey( hProv,
                         pbDecodedPrivateKey,
                         cbDecodedPrivateKey,
                         0, 
                         CRYPT_EXPORTABLE, //so we can export it later
                         &hPrivateKey ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x importing PRIVATEKEYBLOB"), err);
        goto EndDecodeKey;
        }

    
    //
    // Fill in the CRYPT_KEY_PROV_INFO structure, with the same parameters we 
    // used in the call to CryptAcquireContext() above
    //

    //
    // container name in the structure is a unicode string, so we need to convert
    //

    if ( pszKeyContainer != NULL )
        {
        // point the key container name to the passed in string
        // WARNING: this does not actually copy the string, just the pointer
        // to it. So the strings needs to remain valid until the ProvInfo is commited.
        pCryptKeyProvInfo->pwszContainerName = pszKeyContainer;
        }
    else
        {
        pCryptKeyProvInfo->pwszContainerName = NULL;
        }

    pCryptKeyProvInfo->pwszProvName = NULL;
    pCryptKeyProvInfo->dwProvType = PROV_RSA_FULL;
    pCryptKeyProvInfo->dwFlags = 0x20;              // allow the cert to be exchanged
    pCryptKeyProvInfo->cProvParam = 0;
    pCryptKeyProvInfo->rgProvParam = NULL;
    pCryptKeyProvInfo->dwKeySpec = AT_KEYEXCHANGE;  // allow the cert to be exchanged

    fSuccess = TRUE;

EndDecodeKey:

    //
    // Clean-up that happens regardless of success/failure
    //
    if ( pPrivateFile )
        {
        LocalFree( pPrivateFile );
        }

    if ( pbDecodedPrivateKey )
        {
        LocalFree( pbDecodedPrivateKey );
        }

    if ( hPrivateKey )
        {
        CryptDestroyKey( hPrivateKey );
        }

    if ( hProv )
        {
        CryptReleaseContext( hProv, 0 ); 
        }

    return fSuccess;


    } //DecodeAndImportPrivateKey


//--------------------------------------------------------------------------------------------
/*++

Routine Description:

    Takes an incoming PKCS10 request and saves it as a property attached to the key. It also
    checks if the request is in the old internal Keyring format or not......

Arguments:

    pCert - CAPI certificate context pointer for the cert to save the request on
    pbPKCS10req - pointer to the request
    cbPKCS10req - size of the request

Returns:

   BOOL indicating success/failure

--*/
BOOL FImportAndStoreRequest( PCCERT_CONTEXT pCert, PVOID pbPKCS10req, DWORD cbPKCS10req )
{
    BOOL    f;
    DWORD   err;

    // if any NULLS are passed in, fail gracefully
    if ( !pCert || !pbPKCS10req || !cbPKCS10req )
        return FALSE;

    // first, check if the incoming request is actually pointing to an old KeyRing internal
    // request format. That just means that the real request is actuall slightly into
    // the block. The way you tell is by testing the first DWORD to see it
    // is REQUEST_HEADER_IDENTIFIER
    // start by seeing if this is a new style key request
    LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pbPKCS10req;
    if ( pHeader->Identifier == REQUEST_HEADER_IDENTIFIER )
        {
        // update the request pointer and data count
            pbPKCS10req = (PBYTE)pbPKCS10req + pHeader->cbSizeOfHeader;
            cbPKCS10req = pHeader->cbRequestSize;
        }

    // now save the request onto the key
	CRYPT_DATA_BLOB dataBlob;
    ZeroMemory( &dataBlob, sizeof(dataBlob) );
    dataBlob.pbData = (PBYTE)pbPKCS10req;           // pointer to blob data
    dataBlob.cbData = cbPKCS10req;                  // blob length info
	f = CertSetCertificateContextProperty(
        pCert, 
        CERTWIZ_REQUEST_PROP_ID,
        0,
        &dataBlob
        );
    err = GetLastError();

/*
    HRESULT hRes = CertTool_SetBinaryBlobProp(
                    pCert,                  // cert context to set the prop on
                    pbPKCS10req,            // pointer to blob data
                    cbPKCS10req,            // blob length info
                    CERTWIZ_REQUEST_PROP_ID,// property ID for context
                    TRUE                   // the request is already encoded
                    );
*/

    return f;
}



#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\ssltools\certupgr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   certupgr.hxx

Abstract:

    Declarations for functions used to upgrade K2 server certs to Avalanche server certs

Author:

    Alex Mallet (amallet)    02-Dec-1997
    Boyd Multerer (boydm)    20-Jan-1998

--*/

#ifndef _CERTUPGR_H_
#define _CERTUPGR_H_

#define CERT_DER_PREFIX		17

#define CERTWIZ_REQUEST_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1001)


#ifdef UNICODE
    #define ImportKRBackupToCAPIStore   ImportKRBackupToCAPIStore_W
    #define CopyKRCertToCAPIStore       CopyKRCertToCAPIStore_W
#else
    #define ImportKRBackupToCAPIStore   ImportKRBackupToCAPIStore_A
    #define CopyKRCertToCAPIStore       CopyKRCertToCAPIStore_A
#endif

// NOTE: In both the below routines the password must always be ANSI.

// NOTE: The PCCERT_CONTEXT that is returned from the below routines MUST be freed
// via the CAPI call CertFreeCertificateContext(). Otherwise you will be leaking.

//----------------------------------------------------------------
// given a path to an old keyring style backup file, this reads in the public and private
// key information and, using the passed-in password, imports it into the specified
// CAPI store.
PCCERT_CONTEXT ImportKRBackupToCAPIStore_A(
                            PCHAR ptszFileName,         // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PCHAR pszCAPIStore,         // name of the capi store
                            BOOL  bOverWrite            // if true, then overwrite existing cert if already there
                            );       

PCCERT_CONTEXT ImportKRBackupToCAPIStore_W(
                            PWCHAR ptszFileName,        // path of the file
                            PCHAR  pszPassword,         // ANSI password
                            PWCHAR pszCAPIStore,        // name of the capi store
                            BOOL   bOverWrite           // if true, then overwrite existing cert if already there
                            );

//----------------------------------------------------------------
// given a path to an old keyring style backup file, this reads in the public and private
// key information and, using the passed-in password, imports it into the specified
// CAPI store.
// ptszFilePath:    Pointer to the path of the file to be imported
// pszPassword:     Pointer to the password.        MUST BE ANSI 
// ptszPassword:     Pointer to the CAPI store name.
PCCERT_CONTEXT CopyKRCertToCAPIStore_A(
                            PVOID pbPrivateKey, DWORD cbPrivateKey,     // private key info
                            PVOID pbPublicKey, DWORD cbPublicKey,       // public key info
                            PVOID pbPKCS10req, DWORD cbPKCS10req,       // the pkcs10 request
                            PCHAR pszPassword,                          // ANSI password
                            PCHAR pszCAPIStore,                         // name of the capi store
                            BOOL  bOverWrite                            // if true, then overwrite existing cert if already there
                            );

PCCERT_CONTEXT CopyKRCertToCAPIStore_W(
                            PVOID pbPrivateKey, DWORD cbPrivateKey,     // private key info
                            PVOID pbPublicKey, DWORD cbPublicKey,       // public key info
                            PVOID pbPKCS10req, DWORD cbPKCS10req,       // the pkcs10 request
                            PCHAR pszPassword,                          // ANSI password
                            PWCHAR pszCAPIStore,                         // name of the capi store
                            BOOL  bOverWrite                            // if true, then overwrite existing cert if already there
                            );

#endif // _CERTUPGR_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\ssltools\oidenc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.h
//
//  Contents:   Schannel context declarations.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#ifndef __OIDENC_H__
#define __OIDENC_H__

#define szPublicTag   ".public"
#define szParamTag    ".params"
#define szPrivateTag  ".private"

#define MAX_OID_SIZE  64

#define szOID_DH  szOID_PKCS_3 ".1"


#define szOID_DH_Public szOID_DH szPublicTag
#define szOID_DH_Params szOID_DH szParamTag

#define szOID_RSA_RSA_Public szOID_RSA_RSA szPublicTag


#define szOID_INFOSEC_mosaicUpdatedSig_Public  szOID_INFOSEC_mosaicUpdatedSig  szPublicTag
#define szOID_INFOSEC_mosaicUpdatedSig_Params  szOID_INFOSEC_mosaicUpdatedSig  szParamTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Public szOID_INFOSEC_mosaicKMandUpdSig szPublicTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Params szOID_INFOSEC_mosaicKMandUpdSig szParamTag

#define szOID_DSA_Public szOID_OIWSEC_dsa szPublicTag
#define szOID_DSA_Params szOID_OIWSEC_dsa szParamTag

#define szOID_RSA_ENCRYPT_RC4_MD5  szOID_RSA_ENCRYPT ".4"


#define szPrivateKeyFileEncode "PrivateKeyFileEncode"
#define szPrivateKeyInfoEncode "PrivateKeyInfoEncode"

#ifndef X509_ENHANCED_KEY_USAGE
#define X509_ENHANCED_KEY_USAGE             ((LPCSTR) 36)

typedef struct _CTL_USAGE {
    DWORD               cUsageIdentifier;
    LPSTR               *rgpszUsageIdentifier;      // array of pszObjId
} CTL_USAGE, *PCTL_USAGE,
  CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;


#endif

#ifndef szOID_ENHANCED_KEY_USAGE
#define szOID_ENHANCED_KEY_USAGE        "2.5.29.37"
#endif

#ifndef szOID_SERVER_GATED_CRYPTO
#define szOID_SERVER_GATED_CRYPTO       "1.3.6.1.4.1.311.10.3.3"
#endif

#define szOID_NETSCAPE_SGC              "2.16.840.1.113730.4.1"


BOOL
WINAPI
InitSchannelOSS(
        HMODULE hModule);

typedef struct _PRIVATE_KEY_FILE_ENCODE
{
    CRYPT_BIT_BLOB              EncryptedBlob;
    CRYPT_ALGORITHM_IDENTIFIER  Alg; 
} PRIVATE_KEY_FILE_ENCODE, *PPRIVATE_KEY_FILE_ENCODE;


#endif // __OIDENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\ssltools\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#include <tchar.h>
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
}
#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>

extern "C"
{
#include <ntsam.h>
#include <lm.h>
#include <lmerr.h>
}

//#include <dbgutil.h>
//#include <assert.h>

extern "C"
    {
    #include <md5.h>
    #include <rc4.h>
    #include <wincrypt.h>

    #define SECURITY_WIN32
    #include <sspi.h>
    #include <ntsecapi.h>
    #include <spseal.h>
    #include <schnlsp.h>
    }

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wvdir.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        wvdir.cpp

   Abstract:
        WWW Directory Properties Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/15/2000      sergeia     Added the mess of application pools for iis6
        03/01/2001      sergeia     Split dialog for file system objects. Now this source
                                    works for sites and vdirs only
--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wvdir.h"
#include "dirbrows.h"
#include "iisobj.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Directory Properties Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

LPCTSTR 
CvtPathToDosStyle(CString & strPath)
{
    //
    // Get a pointer to the string data without increasing the buffer
    //
    for (LPTSTR lp = strPath.GetBuffer(1); *lp; ++lp)
    {
        if (*lp == _T('/'))
        {
            *lp = _T('\\');
        }
    }
    strPath.ReleaseBuffer();

    return strPath;
}

IMPLEMENT_DYNCREATE(CW3DirectoryPage, CInetPropertyPage)



CW3DirectoryPage::CW3DirectoryPage(
    CInetPropertySheet * pSheet,
    BOOL fHome,
    DWORD dwAttributes
    ) 
/*++

Routine Description:

    Constructor for directory property page

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer
    BOOL fHome                  : TRUE if this is a home directory
    DWORD dwAttributes          : Attributes of the  directory/file/vroot

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3DirectoryPage::IDD, pSheet, 
		fHome ? IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY),
      //
      // Assign the range of bits in m_dwAccessPermissions that
      // we manage.  This is important, because another page
      // manages other bits, and we don't want to screw up
      // the master value bits when our changes collide (it
      // will mark the original bits as dirty, because we're not
      // notified when the change is made...
      //
      m_dwBitRangePermissions(MD_ACCESS_EXECUTE | 
            MD_ACCESS_SCRIPT | 
            MD_ACCESS_WRITE  | 
            MD_ACCESS_SOURCE |
            MD_ACCESS_READ),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_ENABLED),
      m_fHome(fHome),
      m_fRecordChanges(TRUE),
      m_strMetaRoot(),
      m_pApplication(NULL),
      m_fOriginallyUNC(FALSE),
      m_fCompatibilityMode(FALSE)
{
    VERIFY(m_strPrompt[RADIO_DIRECTORY].LoadString(IDS_PROMPT_DIR));
    VERIFY(m_strPrompt[RADIO_NETDIRECTORY].LoadString(IDS_PROMPT_UNC));
    VERIFY(m_strPrompt[RADIO_REDIRECT].LoadString(IDS_PROMPT_REDIRECT));
    VERIFY(m_strRemove.LoadString(IDS_BUTTON_REMOVE));
    VERIFY(m_strCreate.LoadString(IDS_BUTTON_CREATE));
    VERIFY(m_strEnable.LoadString(IDS_BUTTON_ENABLE));
    VERIFY(m_strDisable.LoadString(IDS_BUTTON_DISABLE));
    VERIFY(m_strWebFmt.LoadString(IDS_APPROOT_FMT));
}



CW3DirectoryPage::~CW3DirectoryPage()
{
    SAFE_DELETE(m_pApplication);
}



void 
CW3DirectoryPage::DoDataExchange(CDataExchange * pDX)
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3DirectoryPage)
    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_RADIO_REDIRECT, m_radio_Redirect);
    DDX_Control(pDX, IDC_RADIO_UNC, m_radio_Unc);

    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Check(pDX, IDC_CHECK_AUTHOR, m_fAuthor);
    DDX_Control(pDX, IDC_CHECK_AUTHOR, m_check_Author);
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);    
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Check(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_fBrowsingAllowed);
    DDX_Control(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_check_DirBrowse);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
    DDX_Check(pDX, IDC_CHECK_INDEX, m_fIndexed);
    DDX_Control(pDX, IDC_CHECK_INDEX, m_check_Index);

    DDX_Control(pDX, IDC_EDIT_REDIRECT, m_edit_Redirect);
    DDX_Control(pDX, IDC_BUTTON_CONNECT_AS, m_button_ConnectAs);
    DDX_Check(pDX, IDC_CHECK_CHILD, m_fChild);
    DDX_Control(pDX, IDC_CHECK_CHILD, m_check_Child);
    DDX_Check(pDX, IDC_CHECK_EXACT, m_fExact);
    DDX_Check(pDX, IDC_CHECK_PERMANENT, m_fPermanent);

    DDX_Control(pDX, IDC_STATIC_PATH_PROMPT, m_static_PathPrompt);

    DDX_Control(pDX, IDC_STATIC_PERMISSIONS, m_static_PermissionsPrompt);
    DDX_CBIndex(pDX, IDC_COMBO_PERMISSIONS, m_nPermissions);
    DDX_Control(pDX, IDC_COMBO_PERMISSIONS, m_combo_Permissions);

    DDX_Control(pDX, IDC_STATIC_APP_PROMPT, m_static_AppPrompt);
    DDX_Text(pDX, IDC_EDIT_APPLICATION, m_strAppFriendlyName);
    DDV_MinMaxChars(pDX, m_strAppFriendlyName, 0, MAX_PATH); /// ?
    DDX_Control(pDX, IDC_EDIT_APPLICATION, m_edit_AppFriendlyName);

    DDX_Control(pDX, IDC_STATIC_STARTING_POINT, m_static_StartingPoint);
    DDX_Control(pDX, IDC_STATIC_PROTECTION, m_static_ProtectionPrompt);
    DDX_Control(pDX, IDC_BUTTON_UNLOAD_APP, m_button_Unload);
    DDX_Control(pDX, IDC_BUTTON_CREATE_REMOVE_APP, m_button_CreateRemove);
    DDX_Control(pDX, IDC_APP_CONFIGURATION, m_button_Configuration);

    DDX_Control(pDX, IDC_COMBO_PROCESS, m_combo_Process);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        CString csPathMunged;
        //
        // Make sure all field names are correct
        //
        if (m_nPathType == RADIO_NETDIRECTORY)
        {
            DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
            DDV_UNCFolderPath(pDX, m_strPath,IsLocal());
            m_strRedirectPath.Empty();
            if (IsLocal())
            {
				// do this check only if a change was made.
				if (IsDirty())
				{
                    csPathMunged = m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
                    GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif
					if (PathIsUNCServerShare(csPathMunged))
					{
						if (FALSE == DoesUNCShareExist(csPathMunged))
						{
							CError err;
							err = ERROR_PATH_NOT_FOUND;
							if (IDCANCEL == err.MessageBox(m_hWnd,MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2,NO_HELP_CONTEXT))
							{
								pDX->Fail();
							}
						}
					}
				}
            }
        }
        else if (m_nPathType == RADIO_REDIRECT)
        {
            DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
            DDV_Url(pDX, m_strRedirectPath);

            // We could have only absolute URLs here
			// Nope, we allow relative URL's...
			if (IsRelURLPath(m_strRedirectPath))
			{
			}
			else
			{
				if (!PathIsURL(m_strRedirectPath) || m_strRedirectPath.GetLength() <= lstrlen(_T("http://")))
				{
					DDV_ShowBalloonAndFail(pDX, IDS_BAD_URL_PATH);
				}
			}
			if (m_strRedirectPath.Find(_T(",")) > 0)
			{
				DDV_ShowBalloonAndFail(pDX, IDS_ERR_COMMA_IN_REDIRECT);
			}
        }
        else // Local directory
        {
            ASSERT(m_nPathType == RADIO_DIRECTORY);
            if (!IsMasterInstance())
            {
                DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
			    DDV_FolderPath(pDX, m_strPath, IsLocal());
            }
            m_strRedirectPath.Empty();
        }
		if (!m_fCompatibilityMode)
		{
			// Check what AppPoolID is assigned
			CString str, strSel;
			str.LoadString(IDS_INVALID_POOL_ID);
			int idx = m_combo_Process.GetCurSel();
			ASSERT(idx != CB_ERR);
			m_combo_Process.GetLBText(idx, strSel);
			if (strSel.Compare(str) == 0)
			{
				HWND hWndCtrl = pDX->PrepareCtrl(IDC_COMBO_PROCESS);
                // Force user to input a valid app pool
                // even if the control is diabled!!!
                DDV_ShowBalloonAndFail(pDX, IDS_MUST_SELECT_APP_POOL);
			}
		}
    }
    else
    {
        DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
        DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
        DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);
	}
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DirectoryPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DirectoryPage)
    ON_BN_CLICKED(IDC_CHECK_AUTHOR, OnCheckAuthor)
    ON_BN_CLICKED(IDC_CHECK_READ, OnCheckRead)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnCheckWrite)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_REDIRECT, OnRadioRedirect)
    ON_BN_CLICKED(IDC_RADIO_UNC, OnRadioUnc)

    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_CONNECT_AS, OnButtonConnectAs)
    ON_BN_CLICKED(IDC_BUTTON_CREATE_REMOVE_APP, OnButtonCreateRemoveApp)
    ON_BN_CLICKED(IDC_BUTTON_UNLOAD_APP, OnButtonUnloadApp)
    ON_BN_CLICKED(IDC_APP_CONFIGURATION, OnButtonConfiguration)
    ON_CBN_SELCHANGE(IDC_COMBO_PERMISSIONS, OnSelchangeComboPermissions)
    ON_CBN_SELCHANGE(IDC_COMBO_PROCESS, OnSelchangeComboProcess)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PATH, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_REDIRECT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_APPLICATION, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
//    ON_BN_CLICKED(IDC_CHECK_SCRIPT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_CHILD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_EXACT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_PERMANENT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_INDEX, OnItemChanged)

END_MESSAGE_MAP()



void
CW3DirectoryPage::RefreshAppState()
{
    ASSERT(m_pApplication != NULL);

    CError err(m_pApplication->RefreshAppState());

    if (err.Failed())
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;    

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Ignore this error, it really just means the path 
            // doesn't exist in the metabase, which is true for most
            // file and directory properties, and not an error
            // condition.
            //
            err.Reset();
        }
    }
    else
    {
        m_dwAppState = m_pApplication->QueryAppState();
    }

    if (err.Succeeded())
    {
        //
        // Get metabase information
        //
        m_strAppRoot = m_pApplication->m_strAppRoot;
        m_dwAppProtection = m_pApplication->m_dwProcessProtection;
        m_strAppFriendlyName = m_pApplication->m_strFriendlyName;
        m_fIsAppRoot = m_strMetaRoot.CompareNoCase(
            CMetabasePath::CleanMetaPath(m_strAppRoot)) == 0;
    }
    else
    {
        //
        // Display error information
        //
        err.MessageBoxFormat(m_hWnd, IDS_ERR_APP, MB_OK, NO_HELP_CONTEXT);
    }
}



CString &
CW3DirectoryPage::FriendlyAppRoot(LPCTSTR lpAppRoot, CString & strFriendly)
/*++

Routine Description:

    Convert the metabase app root path to a friendly display name
    format.

Arguments:

    LPCTSTR lpAppRoot           : App root
    CString & strFriendly       : Output friendly app root format

Return Value:

    Reference to the output string

Notes:

    App root must have been cleaned from WAM format prior
    to calling this function (see first ASSERT below)

--*/
{
    if (lpAppRoot != NULL && *lpAppRoot != 0)
    {
        //
        // Make sure we cleaned up WAM format
        //
        ASSERT(*lpAppRoot != _T('/'));
        strFriendly.Empty();

        CInstanceProps prop(QueryAuthInfo(), lpAppRoot);
        HRESULT hr = prop.LoadData();

        if (SUCCEEDED(hr))
        {
            CString root, tail;
            strFriendly.Format(
                    m_strWebFmt, 
                    prop.GetDisplayText(root)
                    );
            CMetabasePath::GetRootPath(lpAppRoot, root, &tail);
            if (!tail.IsEmpty())
            {
                //
                // Add rest of dir path
                //
                strFriendly += _T("/");
                strFriendly += tail;
            }

            //
            // Now change forward slashes in the path to backward slashes
            //
            CvtPathToDosStyle(strFriendly);

            return strFriendly;
        }
    }    
    //
    // Bogus
    //    
    VERIFY(strFriendly.LoadString(IDS_APPROOT_UNKNOWN));

    return strFriendly;
}



int   
CW3DirectoryPage::SetComboSelectionFromAppState(DWORD dwAppState)
/*++

Routine Description:

    Set the protection combo box current selection from the 
    app state DWORD

Arguments:

    DWORD  dwAppState       : Application State

Return Value:

    Combo selection ID

--*/
{
    int nSel = -1;

    switch(dwAppState)
    {
    case CWamInterface::APP_INPROC:
        nSel = m_nSelInProc;
        break;

    case CWamInterface::APP_POOLEDPROC:
        ASSERT(m_pApplication->SupportsPooledProc());
        nSel = m_nSelPooledProc;
        break;

    case CWamInterface::APP_OUTOFPROC:
        nSel = m_nSelOutOfProc;
        break;

    default:
        ASSERT("Bogus app protection level");
    }

    ASSERT(nSel >= 0);
    m_combo_Process.SetCurSel(nSel);

    return nSel;
}



DWORD 
CW3DirectoryPage::GetAppStateFromComboSelection() const
/*++

Routine Description:

    Get the app state DWORD that coresponds to the current combo
    box list selection

Arguments:

    None

Return Value:

    App state DWORD or 0xffffffff;

--*/
{
    int nSel = m_combo_Process.GetCurSel();

    if (nSel == m_nSelOutOfProc)
    {
        return CWamInterface::APP_OUTOFPROC;
    }

    if (nSel == m_nSelPooledProc)
    {
        ASSERT(m_pApplication->SupportsPooledProc());
        return CWamInterface::APP_POOLEDPROC;
    }

    if (nSel == m_nSelInProc)
    {
        return CWamInterface::APP_INPROC;
    }

    ASSERT(FALSE && "Invalid application state");

    return 0xffffffff;
}
 


void
CW3DirectoryPage::SetApplicationState()
/*++

Routine Description:

    Set application control state

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // SetWindowText causes a dirty marker
    //
    BOOL fOld = m_fRecordChanges;
    m_fRecordChanges = FALSE;
    m_fParentEnabled = !m_strAppRoot.IsEmpty();
    m_fAppEnabled = FALSE;

    if (m_pApplication != NULL)
    {
        m_pApplication->RefreshAppState();
        m_fAppEnabled = m_fIsAppRoot && m_pApplication->IsEnabledApplication();
    }
	BOOL fVisible = (
		m_nPathType == RADIO_DIRECTORY || m_nPathType == RADIO_NETDIRECTORY);

    m_button_CreateRemove.EnableWindow(fVisible && !IsMasterInstance() && HasAdminAccess());
    m_button_CreateRemove.SetWindowText(m_fAppEnabled ? m_strRemove : m_strCreate);
    
    m_static_ProtectionPrompt.EnableWindow(fVisible && 
        m_fAppEnabled && !IsMasterInstance() && HasAdminAccess());

    //
    // Set selection in combo box to match current app state
    //
    if (m_fCompatibilityMode)
    {
        SetComboSelectionFromAppState(m_dwAppProtection);
    }

    m_combo_Process.EnableWindow(fVisible && 
        m_fAppEnabled && !IsMasterInstance() && HasAdminAccess());
    m_static_PermissionsPrompt.EnableWindow(fVisible && HasAdminAccess());
    m_combo_Permissions.EnableWindow(fVisible && HasAdminAccess());

    m_static_AppPrompt.EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
    m_edit_AppFriendlyName.EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
    m_button_Configuration.EnableWindow(fVisible && (m_fAppEnabled || IsMasterInstance()));

    //
    // Write out the verbose starting point.  
    //
    CString str;
   if (IsMasterInstance())
	{
		VERIFY(str.LoadString(IDS_WEB_MASTER));
	}
	else
	{
		FriendlyAppRoot(m_strAppRoot, str);
	}
	FitPathToControl(m_static_StartingPoint, str, FALSE);

    m_edit_AppFriendlyName.SetWindowText(m_strAppFriendlyName);
    m_button_Unload.EnableWindow(fVisible && m_dwAppState == APPSTATUS_RUNNING);

    //
    // Restore (see note on top)
    //
    m_fRecordChanges = fOld;
}



void
CW3DirectoryPage::ChangeTypeTo(int nNewType)
/*++

Routine Description

    Change the directory type

Arguments:

    int nNewType    : New radio value

Return Value:

    None

--*/
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        return;
    }

    OnItemChanged();
    SetStateByType();

    int nID = -1;
    CEdit * pPath = NULL;
    LPCTSTR lpKeepPath = NULL;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        {
            CString csPathMunged;
            csPathMunged = m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
            GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif
            if (!PathIsUNC(csPathMunged) && (!PathIsRelative(csPathMunged) || IsDevicePath(csPathMunged)))
            {
                //
                // The old path info is acceptable, propose it
                // as a default
                //
                lpKeepPath = m_strPath;
            }
            nID = IDS_DIRECTORY_MASK;
            pPath = &m_edit_Path;
            break;
        }

    case RADIO_NETDIRECTORY:
        {
            CString csPathMunged;
            csPathMunged = m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
            GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif
            if (PathIsUNC(csPathMunged))
            {
                //
                // The old path info is acceptable, propose it
                // as a default
                //
                lpKeepPath = m_strPath;
            }
            nID = IDS_UNC_MASK;
            pPath = &m_edit_Path;
        }
        break;

    case RADIO_REDIRECT:
        if (!m_strRedirectPath.IsEmpty())
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath =  m_strRedirectPath;
        }

        nID = IDS_REDIRECT_MASK;
        pPath = &m_edit_Redirect;
        break;

    default:
        ASSERT(FALSE);
        return;
    }

    //
    // Load mask resource, and display
    // this in the directory
    //
    if (pPath != NULL)
    {
        if (lpKeepPath != NULL)
        {
            pPath->SetWindowText(lpKeepPath);
        }
        else
        {
            CString str;
            VERIFY(str.LoadString(nID));
            pPath->SetWindowText(str);
//            Edit_SetCueBannerText(pPath->m_hWnd, (LPCTSTR)str);
        }
        pPath->SetSel(0,-1);
        pPath->SetFocus();
    }
    SetAuthoringState(FALSE);
}



void 
CW3DirectoryPage::ShowControl(CWnd * pWnd, BOOL fShow)
{
    ASSERT(pWnd != NULL);
	pWnd->EnableWindow(fShow);
	pWnd->ShowWindow(fShow ? SW_SHOW : SW_HIDE);
}



int
CW3DirectoryPage::AddStringToComboBox(CComboBox & combo, UINT nID)
{
    CString str;

    VERIFY(str.LoadString(nID));
    return combo.AddString(str);
}



void
CW3DirectoryPage::SetStateByType()
{
    BOOL fShowDirFlags;
    BOOL fShowLargeDirGroup;
    BOOL fShowRedirectFlags;
    BOOL fShowApp;
    BOOL fShowIndex;
    BOOL fShowDirBrowse;
    BOOL fEnableChild;
    BOOL fEnableBrowse;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        ShowControl(&m_button_ConnectAs, FALSE);
        ShowControl(&m_button_Browse, TRUE);
        ShowControl(&m_edit_Path, TRUE);
        ShowControl(&m_edit_Redirect, FALSE);
        fShowDirFlags = TRUE;
        fShowLargeDirGroup = TRUE;
        fShowRedirectFlags = FALSE;
        fShowApp = TRUE;
        fShowIndex = TRUE;
        fShowDirBrowse = TRUE;
        fEnableChild = FALSE;
        fEnableBrowse = IsLocal() && !IsMasterInstance() && HasAdminAccess();
        break;

    case RADIO_NETDIRECTORY:
        ShowControl(&m_button_ConnectAs, TRUE);
        ShowControl(&m_button_Browse, FALSE);
        ShowControl(&m_edit_Path, TRUE);
        ShowControl(&m_edit_Redirect, FALSE);
        fShowDirFlags = TRUE;
        fShowLargeDirGroup = TRUE;
        fShowRedirectFlags = FALSE;
        fShowApp = TRUE;
        fShowIndex = TRUE;
        fShowDirBrowse = TRUE;
        fEnableChild = FALSE;
        fEnableBrowse = FALSE;
        break;

    case RADIO_REDIRECT:
        ShowControl(&m_button_ConnectAs, FALSE);
        ShowControl(&m_button_Browse, FALSE);
        ShowControl(&m_edit_Path, FALSE);
        ShowControl(&m_edit_Redirect, TRUE);
        fShowDirFlags = FALSE;
        fShowRedirectFlags = TRUE;
        fShowApp = FALSE;
        fShowIndex = FALSE;
        fShowDirBrowse = FALSE;
        fEnableChild = TRUE;
        fEnableBrowse = FALSE;
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
        return;
    }

    ShowControl(GetDlgItem(IDC_CHECK_READ), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_WRITE), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_LOG_ACCESS), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_INDEX), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_AUTHOR), fShowDirFlags);

    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_LARGE),
        fShowDirFlags && fShowLargeDirGroup);
    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_SMALL),
        fShowDirFlags && !fShowLargeDirGroup);

    ShowControl(IDC_CHECK_EXACT, fShowRedirectFlags);
    ShowControl(IDC_CHECK_CHILD, fShowRedirectFlags);
    ShowControl(IDC_CHECK_PERMANENT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRECT_PROMPT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRFLAGS, fShowRedirectFlags);

    ShowControl(IDC_STATIC_APPLICATIONS, fShowApp);
    ShowControl(IDC_STATIC_APP_PROMPT, fShowApp);
    ShowControl(IDC_EDIT_APPLICATION, fShowApp);
    ShowControl(IDC_STATIC_STARTING_POINT, fShowApp);
    ShowControl(IDC_STATIC_SP_PROMPT, fShowApp);
    ShowControl(IDC_COMBO_PROCESS, fShowApp);
    ShowControl(IDC_STATIC_PERMISSIONS, fShowApp);
    ShowControl(IDC_BUTTON_CREATE_REMOVE_APP, fShowApp);
    ShowControl(IDC_BUTTON_UNLOAD_APP, fShowApp);
    ShowControl(IDC_APP_CONFIGURATION, fShowApp);
    ShowControl(IDC_STATIC_APPLICATION_SETTINGS, fShowApp);
    ShowControl(IDC_COMBO_PERMISSIONS, fShowApp);
    ShowControl(IDC_STATIC_PROTECTION, fShowApp);

//    ShowControl(&m_check_Author, fShowDAV);
//    ShowControl(&m_check_DirBrowse, fShowDirBrowse);
//    ShowControl(&m_check_Index, fShowIndex);

    //
    // Enable/Disable must come after the showcontrols
    //
    m_button_Browse.EnableWindow(fEnableBrowse);
    m_check_Child.EnableWindow(fEnableChild);
    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);

    SetApplicationState();
}



void
CW3DirectoryPage::SaveAuthoringState()
/*++

Routine Description:

    Save authoring state

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_check_Write.m_hWnd)
    {
        //
        // Controls initialized -- store live data
        //
        m_fOriginalWrite = m_check_Write.GetCheck() > 0;
        m_fOriginalRead = m_check_Read.GetCheck() > 0;
    }
    else
    {
        //
        // Controls not yet initialized, store original data
        //
        m_fOriginalWrite = m_fWrite;
        m_fOriginalRead = m_fRead;
    }
}



void
CW3DirectoryPage::RestoreAuthoringState()
/*++

Routine Description:

    Restore the authoring state

Arguments:

    None

Return Value:

    None

--*/
{
    m_fWrite = m_fOriginalWrite;
    m_fRead = m_fOriginalRead;
}



void 
CW3DirectoryPage::SetAuthoringState(
    BOOL fAlterReadAndWrite
    )
/*++

Routine Description:

    Set authoring state

Arguments:

    None

Return Value:

    None

--*/
{
    if (fAlterReadAndWrite)
    {
        if (m_fAuthor)
        {
            //
            // Remember previous setting to undo
            // this thing.
            //
            SaveAuthoringState();
            m_fRead = m_fWrite = TRUE;
        }
        else
        {
            //
            // Restore previous defaults
            //
            RestoreAuthoringState();
        }

        m_check_Read.SetCheck(m_fRead);
        m_check_Write.SetCheck(m_fWrite);
    }

    m_check_Author.EnableWindow((m_fRead || m_fWrite) && HasAdminAccess());

//    m_check_Read.EnableWindow(!m_fAuthor && HasAdminAccess());
//    m_check_Write.EnableWindow(!m_fAuthor && HasAdminAccess());
}



void 
CW3DirectoryPage::SetPathType()
/*++

Routine Description:

    Set path type from given path

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_strRedirectPath.IsEmpty())
    {
        m_nPathType = RADIO_REDIRECT;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(0);
        m_radio_Redirect.SetCheck(1);
    }
    else
    {
        m_radio_Redirect.SetCheck(0);
        SetPathType(m_strPath);
    }

    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
    SetAuthoringState(FALSE);
}


void 
CW3DirectoryPage::SetPathType(LPCTSTR lpstrPath)
/*++

Routine Description:

    Set path type from given path

Arguments:

    LPCTSTR lpstrPath       : Path string

Return Value:

    None

--*/
{
    CString expanded;
    ExpandEnvironmentStrings(lpstrPath, expanded.GetBuffer(MAX_PATH), MAX_PATH);
	expanded.ReleaseBuffer();

    CString csPathMunged;
    csPathMunged = expanded;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,expanded,csPathMunged);
#endif
    if (!IsDevicePath(csPathMunged) && PathIsUNC(csPathMunged))
    {
        m_nPathType = RADIO_NETDIRECTORY;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(1);
    }
    else
    {
        m_nPathType = RADIO_DIRECTORY;
        m_radio_Unc.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }
    SetAuthoringState(FALSE);
}



BOOL
CW3DirectoryPage::BrowseUser()
/*++

Routine Description:

    Browse for username/password

Arguments:

    None

Return Value:

    TRUE if one was selected, FALSE otherwise.

--*/
{
    CString csTempPassword;
    m_strPassword.CopyTo(csTempPassword);

    CUserAccountDlg dlg(
        QueryServerName(), 
        m_strUserName, 
        csTempPassword, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        m_strUserName = dlg.m_strUserName;
        m_strPassword = dlg.m_strPassword;
        OnItemChanged();

        return TRUE;
    }

    return FALSE;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DirectoryPage::OnItemChanged()
/*++

Routine Description:

    Handle change in data on the item

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fRecordChanges)
    {
        SetModified(TRUE);
    }
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CW3DirectoryPage * pThis = (CW3DirectoryPage *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CW3DirectoryPage::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void 
CW3DirectoryPage::OnButtonBrowse() 
/*++

Routine Description:

    "Browse" button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(IsLocal());
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
	     ExpandEnvironmentStrings(str, buf, MAX_PATH);
		 str = buf;
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(IsHome() ? 
            IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Path.SetWindowText(str);
	   m_strPath = str;
       SetPathType();
       OnItemChanged();
   }
}



BOOL 
CW3DirectoryPage::OnSetActive() 
/*++

Routine Description:

    Page has become active.  Dismiss if we're in an inconsistent state

Arguments:

    None

Return Value:

    TRUE to proceed, FALSE to dismiss.

--*/
{
    if (m_pApplication == NULL)
    {
        return FALSE;
    }
    SetApplicationState();

    return CInetPropertyPage::OnSetActive();
}



BOOL 
CW3DirectoryPage::OnInitDialog() 
{
    CInetPropertyPage::OnInitDialog();

    m_fCompatibilityMode = ((CW3Sheet *)GetSheet())->InCompatibilityMode();

    CString str;
    VERIFY(str.LoadString(IDS_RADIO_VDIR));
    m_radio_Dir.SetWindowText(str);

    //
    // Fill permissions combo box.
    //
    AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_NONE);
    AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_SCRIPT);
    AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_EXECUTE);
    m_combo_Permissions.SetCurSel(m_nPermissions);

    if (m_fCompatibilityMode)
    {
        m_nSelInProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_INPROC);
        if (m_pApplication->SupportsPooledProc())
        {
            m_nSelPooledProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_POOLEDPROC); 
        }
        else
        {
            m_nSelPooledProc = -1; // N/A
        }
        m_nSelOutOfProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_OUTPROC);
    }
    else
    {
       CString buf;
       buf.LoadString(IDS_APPLICATION_POOL);
       m_static_ProtectionPrompt.SetWindowText(buf);

	   CStringListEx pools;
	   CError err = ((CW3Sheet *)GetSheet())->EnumAppPools(pools);
	   int idx_sel = CB_ERR;
       int idx_def = CB_ERR;
	   err = ((CW3Sheet *)GetSheet())->QueryDefaultPoolId(buf);
	   if (err.Succeeded())
       {
	      ASSERT(pools.GetCount() > 0);
		  POSITION pos = pools.GetHeadPosition();
		  CString pool_id;
		  while (pos != NULL)
          {
		     pool_id = pools.GetNext(pos);
			 int idx = m_combo_Process.AddString(pool_id);
			 if (0 == m_pApplication->m_strAppPoolId.CompareNoCase(pool_id))
             {
			    idx_sel = idx;
             }
             if (0 == buf.CompareNoCase(pool_id))
             {
				 idx_def = idx;
             }
          }
       }
	   // select the app pool which has an id the same as in current application
       // It could be new app created in compatibility mode, no app pool is default app pool
       if (CB_ERR == idx_sel)
       {
	       if (m_pApplication->m_strAppPoolId.IsEmpty())
		   {
			   idx_sel = idx_def;
		   }
		   else
		   {
			   CString str;
			   str.LoadString(IDS_INVALID_POOL_ID);
			   m_combo_Process.InsertString(0, str);
			   idx_sel = 0;
		   }
       }
	   m_combo_Process.SetCurSel(idx_sel);
    }
    //
    // Selection will be set later...
    //
    SetPathType();
    SetStateByType();
    SetAuthoringState(FALSE);

    TRACEEOLID(m_strMetaRoot);

    //
    // Some items not available on master instance, or if no admin
    // access exists
    //
    BOOL fOkToDIR = TRUE;
    BOOL fOkToUNC = TRUE;

    if (!HasAdminAccess())
    {
        //
        // If not an admin, operator cannot change
        // the path, he can only cancel a redirect 
        // by going back to the path it had before.
        // 
        CString csPathMunged;
        csPathMunged = m_strPath;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
        GetSpecialPathRealPath(0,m_strPath,csPathMunged);
#endif

        fOkToDIR = !PathIsRelative(csPathMunged) || IsDevicePath(csPathMunged);
        fOkToUNC = PathIsUNC(csPathMunged);
    }

    GetDlgItem(IDC_STATIC_PATH_TYPE)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_RADIO_DIR)->EnableWindow(!IsMasterInstance() && fOkToDIR);
    GetDlgItem(IDC_RADIO_UNC)->EnableWindow(!IsMasterInstance() && fOkToUNC);
    GetDlgItem(IDC_RADIO_REDIRECT)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_STATIC_PATH_PROMPT)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_EDIT_PATH)->EnableWindow(!IsMasterInstance() && HasAdminAccess());
//    GetDlgItem(IDC_BUTTON_EDIT_PATH_TYPE)->EnableWindow(!IsMasterInstance());

    //SetApplicationState();
    m_fOriginallyUNC = (m_nPathType == RADIO_NETDIRECTORY);
    //
    // All changes from here on out need to be reflected.
    //
    m_fRecordChanges = TRUE;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_EDIT_PATH),FALSE);
#endif

    return TRUE;  
}


void
CW3DirectoryPage::OnDestroy()
{
    //int count = m_combo_Process.GetCount();
    //if (count != CB_ERR)
    //{
    //    for (int i = 0; i < count; i++)
    //    {
    //        void * p = m_combo_Process.GetItemDataPtr(i);
    //        LocalFree(p);
    //        m_combo_Process.SetItemDataPtr(i, NULL);
    //    }
    //}
}


/* virtual */
HRESULT
CW3DirectoryPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    m_strMetaRoot = QueryMetaPath();

    BEGIN_META_DIR_READ(CW3Sheet)
        //
        // Use m_ notation because the message crackers require it
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strAlias);
        FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
        FETCH_DIR_DATA_FROM_SHEET_PASSWORD(m_strPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_strPath);
        FETCH_DIR_DATA_FROM_SHEET(m_strRedirectPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);
        FETCH_DIR_DATA_FROM_SHEET(m_fIndexed);
        FETCH_DIR_DATA_FROM_SHEET(m_fExact);
        FETCH_DIR_DATA_FROM_SHEET(m_fChild);
        FETCH_DIR_DATA_FROM_SHEET(m_fPermanent);

        m_fBrowsingAllowed = IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_ENABLED);
        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fAuthor = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SOURCE);
        m_fLogAccess = !m_fDontLog;

        SaveAuthoringState();

        if (!m_fIsAppRoot)
        {
            m_dwAppState = APPSTATUS_NOTDEFINED;
        }

    END_META_DIR_READ(err)

    m_nPermissions = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_EXECUTE)
        ? COMBO_EXECUTE : IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SCRIPT)
            ? COMBO_SCRIPT : COMBO_NONE;

    //
    // Make sure we were passed the right home directory
    // flag
    //
    ASSERT(IsMasterInstance() 
         || (m_fHome && !::lstrcmp(m_strAlias, g_cszRoot))
         || (!m_fHome && ::lstrcmp(m_strAlias, g_cszRoot))
         );

    TRACEEOLID(QueryMetaPath());

    BeginWaitCursor();
    m_pApplication = new CIISApplication(QueryAuthInfo(), QueryMetaPath());
    err = m_pApplication != NULL
        ? m_pApplication->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // No app information; that's ok in cases of file system directories
        // that don't exist in the metabase yet.
        //
        err.Reset();
    }
    EndWaitCursor();

    if (err.Succeeded())
    {
        //
        // CODEWORK: RefreshAppState should be split up into two
        // different methods: one that fetches the data, and one
        // that moves the data to the UI controls on this page.
        //
        RefreshAppState();
    }
    
    return err;
}



/* virtual */
HRESULT
CW3DirectoryPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 virtual directory page now...");

    CError err;

    SET_FLAG_IF(m_fBrowsingAllowed, m_dwDirBrowsing, MD_DIRBROW_ENABLED);
    SET_FLAG_IF(m_fRead, m_dwAccessPerms,   MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms,  MD_ACCESS_WRITE);
    SET_FLAG_IF(m_fAuthor, m_dwAccessPerms, MD_ACCESS_SOURCE);
    SET_FLAG_IF((m_nPermissions == COMBO_EXECUTE), m_dwAccessPerms, MD_ACCESS_EXECUTE);
    //
    // script is set on EXECUTE as well "Execute (including script)"
    //
    SET_FLAG_IF(((m_nPermissions == COMBO_SCRIPT) || (m_nPermissions == COMBO_EXECUTE)), 
        m_dwAccessPerms, MD_ACCESS_SCRIPT);
    BOOL m_fDontLog = !m_fLogAccess;
    BOOL fUNC = (m_nPathType == RADIO_NETDIRECTORY);

    if (m_fCompatibilityMode)
    {
        DWORD dwAppProtection = GetAppStateFromComboSelection();
        if (dwAppProtection != m_dwAppProtection && m_fAppEnabled)
        {
            //
            // Isolation state has changed; recreate the application
            //
            CError err2(m_pApplication->RefreshAppState());
            if (err2.Succeeded())
            {
                err2 = m_pApplication->Create(m_strAppFriendlyName, dwAppProtection);
                //
                // Remember the new state, so we don't do this again
                // the next time the guy hits "apply"
                //
                if (err2.Succeeded())
                {
                    m_dwAppProtection = dwAppProtection;
                }
            }

            err2.MessageBoxOnFailure(m_hWnd);
        }
    }

    BOOL fUserNameWritten = FALSE;
    BOOL bPathDirty = FALSE, bRedirectDirty = FALSE;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwAccessPerms, m_dwBitRangePermissions)
        INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)

        if (fUNC)      
        {
            STORE_DIR_DATA_ON_SHEET(m_strUserName);
            STORE_DIR_DATA_ON_SHEET(m_strPassword);
        }
        else
        {
            if (m_fOriginallyUNC)
            {
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_USERNAME)
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_PASSWORD)
            }
        }
        STORE_DIR_DATA_ON_SHEET_REMEMBER(m_strPath, bPathDirty)
        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_fIndexed)
        STORE_DIR_DATA_ON_SHEET(m_fChild);
        STORE_DIR_DATA_ON_SHEET(m_fExact);
        STORE_DIR_DATA_ON_SHEET(m_fPermanent);
        //
        // CODEWORK: Not an elegant solution
        //
        if (m_nPathType == RADIO_REDIRECT)
        {
			bRedirectDirty = 
				pSheet->GetDirectoryProperties().m_strRedirectPath.CompareNoCase(m_strRedirectPath) != 0;
            pSheet->GetDirectoryProperties().MarkRedirAsInherit(!m_fChild);
            STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
        }
        else
        {
//			FLAG_DIR_DATA_FOR_DELETION(MD_HTTP_REDIRECT)
            CString buf = m_strRedirectPath;
            m_strRedirectPath.Empty();
			bRedirectDirty = 
				pSheet->GetDirectoryProperties().m_strRedirectPath.CompareNoCase(m_strRedirectPath) != 0;
            STORE_DIR_DATA_ON_SHEET(m_strRedirectPath);
            m_strRedirectPath = buf;
        }
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
        STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
    END_META_DIR_WRITE(err)

    if (err.Succeeded() && m_pApplication->IsEnabledApplication())
    {
        CString OldFriendlyName;
        OldFriendlyName = m_pApplication->m_strFriendlyName;

        err = m_pApplication->WriteFriendlyName(m_strAppFriendlyName);
        if (!m_fCompatibilityMode)
        {
            INT iRefreshMMCObjects = 0;

            // get app pool id from the combo, 
            // check if it was changed and reassign to application
            CString id, idOld;
            int idx = m_combo_Process.GetCurSel();
            ASSERT(idx != CB_ERR);
            m_combo_Process.GetLBText(idx, id);
            idOld = m_pApplication->m_strAppPoolId;
            m_pApplication->WritePoolId(id);

            if (0 != idOld.CompareNoCase(id))
            {
                iRefreshMMCObjects = 1;
            } else if (0 != OldFriendlyName.Compare(m_strAppFriendlyName))
            {
                iRefreshMMCObjects = 2;
            }

            // Refresh the applications node in the MMC...
            if (iRefreshMMCObjects)
            {
                CIISMBNode * pNode = (CIISMBNode *) GetSheet()->GetParameter();
                if (pNode)
                {
                    // this CAppPoolsContainer will only be here if it's iis6
                    CIISMachine * pOwner = pNode->GetOwner();
                    if (pOwner)
                    {
                        CAppPoolsContainer * pPools = pOwner->QueryAppPoolsContainer();
                        if (pPools)
                        {
                            if (pPools->IsExpanded())
                            {
                                pPools->RefreshData();
                                if (1 == iRefreshMMCObjects)
                                {
                                    // refresh the old AppID, because this one needs to be removed
                                    pPools->RefreshDataChildren(idOld,FALSE);
                                    // fresh the new AppID, this one needs to be added
                                    pPools->RefreshDataChildren(id,FALSE);
                                }
                                else
                                {
                                    // friendly name changed
                                    pPools->RefreshDataChildren(id,FALSE);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (err.Succeeded())
    {
        //
        // Save Defaults
        //
        SaveAuthoringState();
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
        NotifyMMC(bPathDirty || bRedirectDirty ? 
			PROP_CHANGE_REENUM_FILES|PROP_CHANGE_REENUM_VDIR : PROP_CHANGE_DISPLAY_ONLY);
    }

    EndWaitCursor();

    return err;
}



BOOL
CW3DirectoryPage::CheckWriteAndExecWarning()
{
    if (m_nPermissions == COMBO_EXECUTE && m_fWrite)
    {
        if (::AfxMessageBox(IDS_WRN_WRITE_EXEC, MB_YESNO | MB_DEFBUTTON2 ) != IDYES)
        {
            return FALSE;
        }
    }

    OnItemChanged();

    return TRUE;
}



void
CW3DirectoryPage::OnCheckRead() 
{
    m_fRead = !m_fRead;
    SetAuthoringState(FALSE);
    OnItemChanged();
}



void
CW3DirectoryPage::OnCheckWrite() 
{
    m_fWrite = !m_fWrite;

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo
        //
        m_fWrite = FALSE;
        m_check_Write.SetCheck(m_fWrite);
    }
    else
    {
        SetAuthoringState(FALSE);
        OnItemChanged();
    }
}



void 
CW3DirectoryPage::OnCheckAuthor() 
{
    m_fAuthor = !m_fAuthor;
    SetAuthoringState(FALSE);

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo -- set script instead
        //
        m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
    }

    OnItemChanged();
}



void 
CW3DirectoryPage::OnSelchangeComboPermissions() 
{
    m_nPermissions = m_combo_Permissions.GetCurSel();
    ASSERT(m_nPermissions >= COMBO_NONE && m_nPermissions <= COMBO_EXECUTE);

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo -- set script instead
        //
        m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
    }

    OnItemChanged();
}



void 
CW3DirectoryPage::OnButtonConnectAs() 
{
    BrowseUser();
}



void 
CW3DirectoryPage::OnRadioDir() 
{
    ChangeTypeTo(RADIO_DIRECTORY);
}



void 
CW3DirectoryPage::OnRadioUnc() 
{
    ChangeTypeTo(RADIO_NETDIRECTORY);
}

void 
CW3DirectoryPage::OnRadioRedirect() 
{
    ChangeTypeTo(RADIO_REDIRECT);
}

void 
CW3DirectoryPage::OnButtonCreateRemoveApp() 
{
    BeginWaitCursor();

    CError err(m_pApplication->RefreshAppState());

    if (m_fAppEnabled)
    {
        //
        // App currently exists -- delete it
        //
        err = m_pApplication->Delete();
    }    
    else
    {
        //
        // Create new app in-proc
        //
        CString strAppName;

        if (m_fHome)
        {
            //
            // Use default name for application name
            //
            VERIFY(strAppName.LoadString(IDS_DEF_APP));
        }
        else
        {
            //
            // Use name of the virtual directory for the
            // application name
            //
            strAppName = m_strAlias;
        }

        //
        // Attempt to create a pooled-proc by default;  failing
        // that if it's not supported, create it in proc
        //
        DWORD dwAppProtState = 
            m_pApplication->SupportsPooledProc() ? 
                CWamInterface::APP_POOLEDPROC : CWamInterface::APP_INPROC;
        err = m_pApplication->Create(strAppName, dwAppProtState);
    }

    if (err.Succeeded())
    {
        RefreshAppState();
        NotifyMMC(PROP_CHANGE_DISPLAY_ONLY);
		GetSheet()->NotifyMMC();
    }

    //
    // Move app data to the controls
    //
    UpdateData(FALSE);

    EndWaitCursor();    

    err.MessageBoxOnFailure(m_hWnd);    
	if (err.Succeeded())
	{
		SetApplicationState();
		// Don't set this because Creating/Removing App
		// already committed the changes...

		// we need this to write the KeyType out
		((CW3Sheet *)GetSheet())->SetKeyType();
		
		//OnItemChanged();
	}

    // SetApplicationState will enable/disable
    // a lot of controls, make sure we are on a control
    // that is enabled.  if we are on a control which is not enabled
    // then user will lose ability to use hotkeys.
    if (!::GetFocus())
    {
        m_button_CreateRemove.SetFocus();
    }
}



void 
CW3DirectoryPage::OnButtonUnloadApp() 
{
    ASSERT(m_dwAppState == APPSTATUS_RUNNING);

    BeginWaitCursor();
    CError err(m_pApplication->RefreshAppState());

    if (err.Succeeded())
    {
        if (m_dwAppProtection == CWamInterface::APP_POOLEDPROC)
        {
            //
            // Warn that everything in its process will get unloaded
            //
            if (!NoYesMessageBox(IDS_WRN_UNLOAD_POOP))
            {
                //
                // Chickened out
                //
                return;
            }
        }

        err = m_pApplication->Unload();
    }

    err.MessageBoxOnFailure(m_hWnd);
    RefreshAppState();
    EndWaitCursor();    

    //
    // Ensure that an enabled button will have focus.
    // 
    if (::IsWindowEnabled(CONTROL_HWND(IDC_BUTTON_CREATE_REMOVE_APP)))
    {
        m_button_CreateRemove.SetFocus();
    }
    SetApplicationState();
}

//#include "..\AppConfig\AppConfig.h"
//extern CInetmgrApp theApp;

extern HRESULT
AppConfigSheet(CIISMBNode * pNode, CIISMBNode * pNodeParent, LPCTSTR metapath, CWnd * pParent);

void 
CW3DirectoryPage::OnButtonConfiguration() 
{
    CIISMBNode * pTheObject = (CIISMBNode *) GetSheet()->GetParameter();
    if (pTheObject)
    {
        CError err = AppConfigSheet(
            pTheObject,
            pTheObject->GetParentNode(),
            QueryMetaPath(),
            this
            );
    }
}

void 
CW3DirectoryPage::OnSelchangeComboProcess() 
{
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\wvdir.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        vdir.h

   Abstract:

        WWW Directory Properties Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __WVDIR_H__
#define __WVDIR__H_ 



//{{AFX_INCLUDES()
//#include "apps.h"
//}}AFX_INCLUDES

class CW3DirectoryPage : public CInetPropertyPage
/*++

Class Description:

    WWW Virtual Directory Page.

Public Interface:

    CW3DirectoryPage    : Constructor
    ~CW3DirectoryPage   : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3DirectoryPage)

//
// Constructor/Destructor
//
public:
    CW3DirectoryPage(
        IN CInetPropertySheet * pSheet = NULL, 
        IN BOOL fHome                  = FALSE,
        IN DWORD dwAttributes          = FILE_ATTRIBUTE_VIRTUAL_DIRECTORY
        );

    ~CW3DirectoryPage();

	int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_DIRECTORY,
        RADIO_NETDIRECTORY,
        RADIO_REDIRECT,
    };

    enum
    {
        COMBO_NONE,
        COMBO_SCRIPT,
        COMBO_EXECUTE,
    };

    //{{AFX_DATA(CW3DirectoryPage)
    enum { IDD = IDD_WEB_DIRECTORY_PROPERTIES };
    CStatic m_static_ProtectionPrompt;
    CStatic m_static_PermissionsPrompt;
    int     m_nPathType;
    int     m_nPermissions;
    BOOL    m_fBrowsingAllowed;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAuthor;
    BOOL    m_fLogAccess;
    BOOL    m_fIndexed;
    BOOL    m_fChild;
    BOOL    m_fExact;
    BOOL    m_fPermanent;
    CString m_strPath;
    CString m_strRedirectPath;
    CString m_strAppFriendlyName;
    CEdit   m_edit_Footer;
    CEdit   m_edit_Path;
    CEdit   m_edit_Redirect;
    CEdit   m_edit_AppFriendlyName;
    CStatic m_static_AppPrompt;
    CStatic m_static_Path;
    CStatic m_static_PathPrompt;
    CStatic m_static_AliasPrompt;
    CStatic m_static_Alias;
    CStatic m_static_StartingPoint;
    CButton m_button_Unload;
    CButton m_button_CreateRemove;
    CButton m_button_Browse;
    CButton m_button_ConnectAs;
    CButton m_button_Configuration;
    CButton m_radio_Dir;
    CButton m_check_Author;
    CButton m_check_Child;
    CButton m_check_DirBrowse;
    CButton m_check_Index;
    CButton m_check_Write;
    CButton m_check_Read;
    CComboBox m_combo_Permissions;
    CComboBox m_combo_Process;
    //}}AFX_DATA

    
    BOOL  m_fOriginallyUNC;
    BOOL  m_fLoaded;
    DWORD m_dwAppState;
    DWORD m_dwAppProtection;
    DWORD m_dwAccessPermissions;
    DWORD m_dwDirBrowsing;
    DWORD m_dwBitRangePermissions;
    DWORD m_dwAccessPerms;
    DWORD m_dwBitRangeDirBrowsing;
    CString m_strAlias;
    CString m_strAppRoot;
    CButton m_radio_Unc;
    CButton m_radio_Redirect;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3DirectoryPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3DirectoryPage)
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonConnectAs();
    afx_msg void OnButtonCreateRemoveApp();
    afx_msg void OnButtonUnloadApp();
    afx_msg void OnButtonConfiguration();
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckRead();
    afx_msg void OnCheckWrite();
    afx_msg void OnCheckAuthor();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioRedirect();
    afx_msg void OnRadioUnc();
    afx_msg void OnSelchangeComboPermissions();
    afx_msg void OnSelchangeComboProcess();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void ShowControl(
        IN CWnd * pWnd,
        IN BOOL fShow
        );

    void ShowControl(
        IN UINT nID,
        IN BOOL fShow
        );

    int AddStringToComboBox(
        IN CComboBox & combo,
        IN UINT nID
        );

    int   SetComboSelectionFromAppState(DWORD dwAppState);
    DWORD GetAppStateFromComboSelection()  const;
    BOOL  ShowProcOptionsForThisAppState(
        IN DWORD dwAppProtection
        ) const;
    
    void SetStateByType();
    void SetPathType();
    void SetPathType(LPCTSTR lpstrPath);
    void SetApplicationState();
    void SetState();
    void SetAuthoringState(BOOL fAlterReadAndWrite = TRUE);
    void RefreshAppState();
    void ChangeTypeTo(int nNewType);
    BOOL BrowseUser();
    BOOL CheckWriteAndExecWarning();
    LPCTSTR QueryMetaPath();

    CString & FriendlyAppRoot(
        IN LPCTSTR lpAppRoot,
        OUT CString & strStartingPoint
        );

    BOOL IsHome() const { return m_fHome; }

//
// Sheet Data Access
//
protected:
    BOOL IsVroot() const { return IS_VROOT(m_dwAttributes); }
    BOOL IsDir() const { return IS_DIR(m_dwAttributes); }
    BOOL IsFile() const { return IS_FILE(m_dwAttributes); }

protected:
    //
    // Remember/restore settings.
    //
    void SaveAuthoringState();
    void RestoreAuthoringState();

private:
    int   m_nSelInProc;
    int   m_nSelPooledProc;
    int   m_nSelOutOfProc;
    BOOL  m_fHome;
    BOOL  m_fRecordChanges;  
    BOOL  m_fAppEnabled;
    BOOL  m_fIsAppRoot;
    BOOL  m_fParentEnabled;
    BOOL  m_fOriginalBrowsingAllowed;
    BOOL  m_fOriginalRead;
    BOOL  m_fOriginalWrite;
    BOOL  m_fCompatibilityMode;
    DWORD m_dwAttributes;
    CString m_strMetaRoot;
    CString m_strOldPath;
    CString m_strUserName;
    CStrPassword m_strPassword;
    CString m_strRemove;
    CString m_strCreate;
    CString m_strEnable;
    CString m_strDisable;
    CString m_strWebFmt;
    CString m_strPrompt[3];
    CIISApplication * m_pApplication;
	LPTSTR m_pPathTemp;
	CString m_strBrowseTitle;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CW3DirectoryPage::ShowControl(
    IN UINT nID,
    IN BOOL fShow
    )
{
    ASSERT(nID > 0);
    ShowControl(GetDlgItem(nID), fShow);
}

inline LPCTSTR CW3DirectoryPage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().QueryMetaRoot();
}

inline BOOL CW3DirectoryPage::ShowProcOptionsForThisAppState(
    IN DWORD dwAppProtection
    ) const
{
    return dwAppProtection == CWamInterface::APP_OUTOFPROC 
        || IsMasterInstance();
}

#endif // __WVDIR__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "w3ext_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\iisdebug.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;

#ifdef DEBUG_FLAG
    void GetOutputDebugFlag(void)
    {
        DWORD rc, err, size, type;
        HKEY  hkey;
        err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
        if (err != ERROR_SUCCESS) {return;}
        size = sizeof(DWORD);
        err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
        if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
        RegCloseKey(hkey);

	    if (rc < 0xffffffff)
	    {
		    g_iDebugOutputLevel = rc;
	    }
        return;
    }
#else
    void GetOutputDebugFlag(void){}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\editalias.h ===
// EditAlias.h : Declaration of the CEditAlias

#ifndef __EDITALIAS_H_
#define __EDITALIAS_H_

#include "resource.h"       // main symbols
#include "common.h"

// These constants depend on dialog layout
#define APP_PERM_NONE      0
#define APP_PERM_SCRIPTS   1
#define APP_PERM_EXECUTE   2

/////////////////////////////////////////////////////////////////////////////
// CEditAlias
class CEditAlias : 
	public CDialogImpl<CEditAlias>,
   public CWinDataExchange<CEditAlias>
{
public:
   CEditAlias() :
      m_read(FALSE),
      m_write(FALSE),
      m_source(FALSE),
      m_browse(FALSE),
      m_appcontrol(APP_PERM_NONE),
      m_pRootKey(NULL)
	{
	}

	~CEditAlias()
	{
	}

	enum { IDD = IDD_EDIT_ALIAS };

BEGIN_MSG_MAP_EX(CEditAlias)
	MSG_WM_INITDIALOG(OnInitDialog)
	COMMAND_ID_HANDLER_EX(IDOK, OnOK)
	COMMAND_ID_HANDLER_EX(IDCANCEL, OnCancel)
//   COMMAND_ID_HANDLER_EX(IDC_READ, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_WRITE, OnPermissions)
//   COMMAND_ID_HANDLER_EX(IDC_FULLCONTROL, OnPermissions)
//   COMMAND_ID_HANDLER_EX(IDC_DIRBROWSE, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_SCRIPTS_PERMS, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_EXECUTE_PERMS, OnPermissions)
   COMMAND_HANDLER_EX(IDC_ALIAS, EN_CHANGE, OnAliasChange)
END_MSG_MAP()

	LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
	void OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl);
	void OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnPermissions(WORD wNotifyCode, WORD wID, HWND hWndCtrl);
   void OnAccess(WORD wNotifyCode, WORD wID, HWND hWndCtrl);
   void OnAliasChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);

   BEGIN_DDX_MAP(CEditAlias)
      DDX_TEXT(IDC_PATH, m_path)
      DDX_TEXT(IDC_ALIAS, m_alias)
      DDX_CHECK(IDC_READ, m_read)
      DDX_CHECK(IDC_WRITE, m_write)
      DDX_CHECK(IDC_FULLCONTROL, m_source)
      DDX_CHECK(IDC_DIRBROWSE, m_browse)
      DDX_RADIO(IDC_NONE_PERMS, m_appcontrol)
   END_DDX_MAP()

   TCHAR m_path[MAX_PATH], m_alias[MAX_PATH];
   CString m_prev_alias;
//   CMetabasePath m_root;
   CString m_instance;
   BOOL  m_read, 
         m_write, 
         m_source,
         m_browse, 
         m_appcontrol, 
         m_new;
   BOOL  m_in_init;
//   CToolTipCtrl m_tool_tip;
   CMetaKey * m_pRootKey;
};

#endif //__EDITALIAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\iisdebug.h ===
#include "stdafx.h"
#include "debugdefs.h"

extern g_iDebugOutputLevel;

#if defined(_DEBUG) || DBG
	#define DEBUG_FLAG
#endif

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_HELP & g_iDebugOutputLevel)
			{
				TCHAR szBuffer[30];
				_stprintf(szBuffer,_T("WinHelp:0x%x,%d\r\n"),dwWinHelpID,dwWinHelpID);
				OutputDebugString(szBuffer);
			}
		}
        return;
    }

    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_W3EXT & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }
#else
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID){}
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

void GetOutputDebugFlag(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_)
#define AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\propshellext.cpp ===
// PropShellExt.cpp : Implementation of CW3extApp and DLL registration.

#include "stdafx.h"
#include "w3ext.h"
#include "PropShellExt.h"
#include "StrFn.h"

/////////////////////////////////////////////////////////////////////////////
//
// IShellExtInit Implementation.

STDMETHODIMP 
CPropShellExt::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID)
{
   if (pDataObj == NULL)
   {
      ATLASSERT(FALSE);
      return (E_INVALIDARG);
   }
   FORMATETC f = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
   STGMEDIUM m;
   HRESULT hr = pDataObj->GetData(&f, &m);
   if (FAILED(hr))
   {
      return(hr);
   }
   hr = E_FAIL;
   if (1 == DragQueryFile((HDROP)m.hGlobal, (UINT)(-1), NULL,0))
   {
      TCHAR szFileName[MAX_PATH];
      DragQueryFile((HDROP)m.hGlobal, 0, szFileName, sizeof(szFileName) / sizeof(TCHAR));
      SHFILEINFO shfi;
      SHGetFileInfo(szFileName, 0, &shfi, sizeof(SHFILEINFO), SHGFI_ATTRIBUTES);
      if (  (shfi.dwAttributes & (SFGAO_LINK | SFGAO_REMOVABLE)) == 0
         && (shfi.dwAttributes & SFGAO_FILESYSTEM) != 0
         )
      {
         int drive_number, drive_type;
         TCHAR szRoot[4];
         if (  -1 != (drive_number = PathGetDriveNumber(szFileName))
            && NULL != PathBuildRoot(szRoot, drive_number)
            && DRIVE_REMOTE != (drive_type = GetDriveType(szRoot))
            && DRIVE_NO_ROOT_DIR != drive_type
            )
         {
            StrCpy(m_szFileName, szFileName);
            hr = S_OK;
         }
      }
   }
   ReleaseStgMedium(&m);
   return hr;
}


STDMETHODIMP 
CPropShellExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
   // We only add the page if the user has admin priviliges in the metabase.
   // The only way to check it now is to try to write something.
   // Test key is /LM/W3SVC.
   CMetabasePath path(SZ_MBN_WEB);
   CMetaKey key(LOCAL_KEY, path,
      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
      );
   if (key.Succeeded() && SUCCEEDED(key.SetValue(MD_ISM_ACCESS_CHECK, 0x0000FFFF)))
   {
      m_psW3ShellExtProp.SetParentExt(this);
      HPROPSHEETPAGE hpage = m_psW3ShellExtProp.Create();
      ASSERT(hpage != NULL);
      if (NULL != hpage)
      {
         AddRef();
         if (!lpfnAddPage(hpage, lParam))
         {
            DestroyPropertySheetPage(hpage);
         }
      }
   }
   return key.QueryResult();
}


STDMETHODIMP 
CPropShellExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
   return E_FAIL;
}

BOOL
RecursiveCheckVRoots(CMetaEnumerator& en, LPCTSTR meta_path, LPCTSTR folder_path)
{
   BOOL shared = FALSE;
   CString vrpath, csPathMunged;
   BOOL bInheritOverride = FALSE;
   if (SUCCEEDED(en.QueryValue(MD_VR_PATH, vrpath, &bInheritOverride, meta_path)))
   {
      // vrpath could be a "special" path
      // like \\?\c:\temp\mydir
      // we need to munge it before compareing it.
      GetSpecialPathRealPath(vrpath,csPathMunged);
      if (csPathMunged.CompareNoCase(folder_path) == 0)
      {
         return TRUE;
      }
   }
   CString vdir;
   while (SUCCEEDED(en.Next(vdir, meta_path)) && !shared)
   {
      CString next_vdir;
      if (meta_path != NULL)
         next_vdir += meta_path;
      next_vdir += vdir;
      next_vdir += SZ_MBN_SEP_STR;
      en.Push();
      en.Reset();
      shared = RecursiveCheckVRoots(en, next_vdir, folder_path);
      en.Pop();
   }
   return shared;
}

BOOL IsFolderShared(LPCTSTR path)
{
   BOOL shared = FALSE;
   CMetaEnumerator en(LOCAL_KEY, CMetabasePath(SZ_MBN_WEB));
   if (en.Succeeded())
   {
      DWORD di;
      int i = -1;
      CString inst;
      HRESULT hr = S_OK;
      while (SUCCEEDED(hr) && !shared)
      {
         if (SUCCEEDED(hr = en.Next(di, inst)))
         {
            CMetabasePath meta_path(TRUE, SZ_MBN_WEB, inst, SZ_MBN_ROOT);
            CMetaEnumerator en(LOCAL_KEY, meta_path);
            ASSERT(en.Succeeded());
            if (en.Succeeded())
            {
               shared = RecursiveCheckVRoots(en, NULL, path);
            }
         }
      }
   }
   return shared;
}


UINT
CPropShellExt::CopyCallback(
        HWND hwnd,          
        UINT wFunc,         
        UINT wFlags,        
        LPCTSTR pszSrcFile,  
        DWORD dwSrcAttribs, 
        LPCTSTR pszDestFile, 
        DWORD dwDestAttribs 
        )
{
    UINT rc = IDYES;
    if ((dwSrcAttribs & FILE_ATTRIBUTE_DIRECTORY) != 0)
    {
        switch (wFunc)
        {
        case FO_DELETE:
        case FO_MOVE:
        case FO_RENAME:
           if (IsFolderShared(pszSrcFile))
           {
              CString cap, msg;
              cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
              msg.Format(_Module.GetResourceInstance(), IDS_CONFIRM_OPERATION, pszSrcFile);
              rc = MessageBox(hwnd, msg, cap, MB_YESNOCANCEL|MB_ICONQUESTION);
           }
           break;
        }
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\propshellext.h ===
// PropShellExt.h: Definition of the CPropShellExt class
//
//////////////////////////////////////////////////////////////////////

#if !defined(_PROPSHELLEXT_H)
#define _PROPSHELLEXT_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "common.h"
#include "mdkeys.h"
#include "W3PropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CPropShellExt

typedef ICopyHook IShellCopyHook;

class CPropShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropShellExt,&CLSID_PropShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt,
    public ICopyHook
{
public:
   CPropShellExt()
   {
   }

BEGIN_COM_MAP(CPropShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY_IID(IID_IShellCopyHook, ICopyHook)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPropShellExt) 

DECLARE_REGISTRY_RESOURCEID(IDR_PROP_SHELL_EXT)

public:
   // IShellExtInit Methods
   STDMETHOD(Initialize)(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID );

   //IShellPropSheetExt methods
   STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
   STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

   //ICopyHook methods
   STDMETHODIMP_(UINT) CopyCallback(
        HWND hwnd,          
        UINT wFunc,         
        UINT wFlags,        
        LPCTSTR pszSrcFile,  
        DWORD dwSrcAttribs, 
        LPCTSTR pszDestFile, 
        DWORD dwDestAttribs 
        );

//   const CComAuthInfo * GetAuthentication() const
//   {
//      return &m_auth;
//   }
   LPCTSTR GetPath()
   {
      return m_szFileName;
   }

private:
   TCHAR m_szFileName[MAX_PATH];
//   CComAuthInfo m_auth;
	CW3PropPage m_psW3ShellExtProp;
};

#endif // !defined(_PROPSHELLEXT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\editalias.cpp ===
// EditAlias.cpp : Implementation of CEditAlias
#include "stdafx.h"
#include "W3PropPage.h"
#include "w3ext.h"
#include "PropShellExt.h"
#include "EditAlias.h"
#include "iisdebug.h"

/////////////////////////////////////////////////////////////////////////////
// CEditAlias

#define TOOLTIP_READ_PERMISSIONS      1000

LRESULT 
CEditAlias::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   CMetabasePath path(TRUE, SZ_MBN_WEB, m_instance, SZ_MBN_ROOT, m_new ? NULL : m_alias);
   CMetaKey mk(LOCAL_KEY, path);
   DWORD flags;
   m_prev_alias = m_alias;
   if (SUCCEEDED(mk.QueryValue(MD_ACCESS_PERM, flags)))
   {
      m_read = ((flags & MD_ACCESS_READ) != 0);
      m_write = ((flags & MD_ACCESS_WRITE) != 0);
      m_source = ((flags & MD_ACCESS_SOURCE) != 0);

      if (!m_new)
      {
         if ((flags & MD_ACCESS_EXECUTE) != 0)
            m_appcontrol = APP_PERM_EXECUTE;
         else if ((flags & MD_ACCESS_SCRIPT) != 0)
            m_appcontrol = APP_PERM_SCRIPTS;
      }
      else
         m_appcontrol = APP_PERM_SCRIPTS;
   }
   else
   {
      EndDialog(0);
   }
   if (SUCCEEDED(mk.QueryValue(MD_DIRECTORY_BROWSING, flags)))
   {
      m_browse = ((flags & MD_DIRBROW_ENABLED) != 0);
   }
   else
   {
      EndDialog(0);
   }

   // enable Alias only if doing a new
   ::EnableWindow(GetDlgItem(IDC_ALIAS), m_new);
   ::EnableWindow(GetDlgItem(IDOK), m_alias[0] != 0);
   m_in_init = TRUE;
   DoDataExchange();
   m_in_init = FALSE;

//   if (NULL != m_tool_tip.Create(hDlg))
//   {
//      RECT rc;
//      ::GetWindowRect(GetDlgItem(IDC_READ), &rc);
//      ScreenToClient(&rc);
//      m_tool_tip.AddTool(hDlg, 
//         _T("Users could read this directory"),
//         &rc, TOOLTIP_READ_PERMISSIONS
//         );
//   }
   return 1;
}

void 
CEditAlias::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CError err;
   DWORD app_state = 0;
   BOOL bRenamed = FALSE;

   DoDataExchange(TRUE);
   CMetabasePath alias(FALSE, m_alias);
   CMetabasePath::CleanMetaPath(alias);
   if (alias.QueryMetaPath()[0] == 0)
   {
      CString cap, msg;
      cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
      msg.Format(_Module.GetResourceInstance(), IDS_BAD_ALIAS, m_alias);
      MessageBox(msg, cap);
      ::SetFocus(GetDlgItem(IDC_ALIAS));
      SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
      return;
   }
   CMetabasePath path(TRUE, SZ_MBN_WEB, m_instance, 
      SZ_MBN_ROOT, alias.QueryMetaPath());
   CMetabasePath::CleanMetaPath(path);
   CMetabasePath parent(path);
   CString sub_alias;
   CMetabasePath::GetLastNodeName(path, sub_alias);
   CMetabasePath::ConvertToParentPath(parent);
   CWaitCursor wait;
   do 
   {
      if (!m_new)
      {
         if (m_prev_alias.Compare(m_alias) != 0)
         {
            CMetabasePath prev_path(TRUE, SZ_MBN_WEB, m_instance, SZ_MBN_ROOT, m_prev_alias);
            CIISApplication app(NULL, prev_path);
            err = app.QueryResult();
            BREAK_ON_ERR_FAILURE(err)
            app_state = app.QueryAppState();
            err = app.Delete();
            BREAK_ON_ERR_FAILURE(err)
            CString str;
            CMetabasePath::GetLastNodeName(prev_path, str);
            CMetabasePath::ConvertToParentPath(prev_path);
            CMetaKey mk_prev(LOCAL_KEY, prev_path, METADATA_PERMISSION_WRITE);
            err = mk_prev.DeleteKey(str);
            BREAK_ON_ERR_FAILURE(err)
            bRenamed = TRUE;
         }
      }
      //make sure the parent is there
      CMetaKey mk(LOCAL_KEY, parent, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
      err = mk.QueryResult();
      if (err.Failed())
	   {
         if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
         {
            CString caption, msg;
            caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
            msg.LoadString(_Module.GetResourceInstance(), IDS_NO_PARENT);
	         MessageBox (msg, caption, MB_OK);
            ::SetFocus(GetDlgItem(IDC_ALIAS));
            SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
            break;
         }
         err.MessageBox();
         break;
	   }
      // if we are editing, delete previous vdir and application
      if (m_new)
      {
         // check if this alias is already available
         err = mk.DoesPathExist(sub_alias);
         if (err.Succeeded())
         {
            CString caption, fmt, msg;
            caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
            fmt.LoadString(_Module.GetResourceInstance(), IDS_ALIAS_IS_TAKEN);
            msg.Format(fmt, path.QueryMetaPath());
            MessageBox (msg, caption, MB_OK);
            ::SetFocus(GetDlgItem(IDC_ALIAS));
            SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
            err = E_FAIL;
            break;
         }
         err = S_OK;
      }
      if (err.Succeeded())
      {
         if (m_new || bRenamed)
         {
            err = mk.AddKey(sub_alias);
            BREAK_ON_ERR_FAILURE(err)
            err = mk.SetValue(MD_KEY_TYPE, CString(_T("IIsWebVirtualDir")), NULL, sub_alias);
            BREAK_ON_ERR_FAILURE(err)
            err = mk.SetValue(MD_VR_PATH, CString(m_path), NULL, sub_alias);
            BREAK_ON_ERR_FAILURE(err)
         }
      }
      // apply permissions
      DWORD flags;
      mk.QueryValue(MD_ACCESS_PERM, flags, NULL, sub_alias);
      flags &= ~(MD_ACCESS_READ|MD_ACCESS_WRITE|MD_ACCESS_SOURCE|MD_ACCESS_SCRIPT|MD_ACCESS_EXECUTE);
      flags |= m_read ? MD_ACCESS_READ : 0;
      flags |= m_write ? MD_ACCESS_WRITE : 0;
      flags |= m_source ? MD_ACCESS_SOURCE : 0;
      if (m_appcontrol == APP_PERM_SCRIPTS)
         flags |= MD_ACCESS_SCRIPT;
      else if (m_appcontrol == APP_PERM_EXECUTE)
         flags |= MD_ACCESS_SCRIPT|MD_ACCESS_EXECUTE;
      mk.SetValue(MD_ACCESS_PERM, flags, NULL, sub_alias);
      
      mk.QueryValue(MD_DIRECTORY_BROWSING, flags, NULL, sub_alias);
      flags &= ~MD_DIRBROW_ENABLED;
      flags |= m_browse ? MD_DIRBROW_ENABLED : 0;
      err = mk.SetValue(MD_DIRECTORY_BROWSING, flags, NULL, sub_alias);
      BREAK_ON_ERR_FAILURE(err)
      if (m_new)
      {
          DWORD dwAuthFlags;
          err = mk.QueryValue(MD_AUTHORIZATION, dwAuthFlags, NULL, sub_alias);
          BREAK_ON_ERR_FAILURE(err)
          dwAuthFlags &= ~(MD_AUTH_BASIC|MD_AUTH_ANONYMOUS|MD_AUTH_MD5);
          dwAuthFlags |= MD_AUTH_NT;
          err = mk.SetValue(MD_AUTHORIZATION, dwAuthFlags, NULL, sub_alias);
          BREAK_ON_ERR_FAILURE(err)
      }
   } while (FALSE);
   if (err.Succeeded())
   {
       do
       {
           if (m_new || bRenamed)
           {
                CIISApplication app(NULL, path);
                err = app.QueryResult();
                BREAK_ON_ERR_FAILURE(err)
                // give the application the "Alias" name...
                err = app.Create((LPCTSTR) sub_alias, //old code used to have NULL here
                app_state ? app_state : CWamInterface::APP_POOLEDPROC);
                BREAK_ON_ERR_FAILURE(err)
           }
           EndDialog(wID);
       } while (FALSE);
   }
}

void 
CEditAlias::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   EndDialog(wID);
}

void 
CEditAlias::OnPermissions(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   if (!m_in_init)
   {
      DoDataExchange(TRUE);
      if (m_write && m_appcontrol > 0)
      {
         CString caption, msg;
         VERIFY(caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE));
         VERIFY(msg.LoadString(_Module.GetResourceInstance(), IDS_WRITEEXECUTE_DANGER));
	      if (IDNO == MessageBox(msg, caption, MB_YESNO | MB_ICONEXCLAMATION))
         {
            CheckDlgButton(wID, 0);
            if (wID != IDC_WRITE)
            {
               CheckDlgButton(IDC_NONE_PERMS, 1);
            }
         }
      }
   }
}

void 
CEditAlias::OnAliasChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   if (!m_in_init)
   {
      DoDataExchange(TRUE);
      ::EnableWindow(GetDlgItem(IDOK), m_alias[0] != 0);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\w3proppage.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        W3PropPage.cpp

   Abstract:
        IIS Shell extension PropertyPage class implementation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "W3PropPage.h"
#include "w3ext.h"
#include "PropShellExt.h"
#include "EditAlias.h"
#include "StrFn.h"

#define SZ_SERVER_KEYTYPE     _T("IIsWebServer")

/////////////////////////////////////////////////////////////////////////////
// CW3PropPage

LRESULT 
CW3PropPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   // subclass dialog controls
   DoDataExchange();

   ASSERT(m_pParentExt != NULL);
   CMetaEnumerator en(LOCAL_KEY, CMetabasePath(SZ_MBN_WEB));
   ASSERT(en.Succeeded());
   if (en.Succeeded())
   {
      DWORD di;
      int i = -1;
      CString inst;
      HRESULT hr = S_OK;
      while (SUCCEEDED(hr))
      {
         if (SUCCEEDED(hr = en.Next(di, inst)))
         {
            CString cmt;
            if (SUCCEEDED(hr = en.QueryValue(MD_SERVER_COMMENT, cmt, NULL, inst)))
            {
               if (cmt.IsEmpty())
               {
                  cmt.Format(_Module.GetResourceInstance(), 
                     IDS_DEFAULT_SERVER_COMMENT, di);
               }
               if (CB_ERR != (i = m_servers_list.AddString(cmt)))
               {
                  m_servers_list.SetItemDataPtr(i, StrDup(inst));
               }
            }
         }
      }
      if (i >= 0)
         m_servers_list.SetCurSel(0);

      m_ShareThis = 0;

      // Fill shares list box for selected server
      OnServerChange(0, 0, NULL);
   }
   return 1;
}

void 
CW3PropPage::OnDestroy()
{
   ATLTRACE("In OnDestroy handler\n");
//   DebugBreak();
}

HRESULT GetKeyNames(CMetaEnumerator& en, std::set<CString>& keys)
{
   CString key;
   HRESULT hr;
   if (SUCCEEDED(hr = en.Next(key)))
   {
      keys.insert(key);
   }
   return hr;
}

void 
CW3PropPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CEditAlias dlg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   dlg.m_instance = p;
   p = m_pParentExt->GetPath();
   ::StrCpy(dlg.m_path, p);
   dlg.m_new = TRUE;
   if (p == PathFindFileName(p))
   {
      /* No file name -- could be root directory like c:\ */
      dlg.m_alias[0] = 0;
   }
   else
   {
      TCHAR buf[MAX_PATH];

      StrCpy(buf, PathFindFileName(p));
      PathMakePretty(buf);
      StrCpy(dlg.m_alias, buf);
      // Now we need to generate unique prompt for this new alias
      CMetaEnumerator en(LOCAL_KEY, 
         CMetabasePath(TRUE, SZ_MBN_WEB, dlg.m_instance, SZ_MBN_ROOT));
      ASSERT(en.Succeeded());
      if (en.Succeeded())
      {
         std::set<CString> keys;
         if (SUCCEEDED(GetKeyNames(en, keys)) && !keys.empty())
         {
            int i = 0;
            while (keys.find(buf) != keys.end())
            {
               wsprintf(buf, _T("%s%d"), dlg.m_alias, ++i);
            }
            StrCpy(dlg.m_alias, buf);
         }
      }
   }
   if (IDOK == dlg.DoModal())
   {
      OnServerChange(0, 0, NULL);
      ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
   }
}

void 
CW3PropPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CString cap, msg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
   index = m_share_list.GetCurSel();
   TCHAR buf[MAX_PATH];
   m_share_list.GetText(index, buf);
   msg.Format(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE, buf);
   CError err;
   if (IDYES == MessageBox(msg, cap, MB_YESNO|MB_ICONQUESTION))
   {
      CWaitCursor wait;

      do 
      {
         CIISApplication app(NULL, CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT, buf));
         err = app.QueryResult();
         BREAK_ON_ERR_FAILURE(err)
         err = app.Delete(TRUE);
      } while (FALSE);
      if (err.Succeeded())
      {
         CMetaKey mk(LOCAL_KEY, 
            CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT),
            METADATA_PERMISSION_WRITE);
         err = mk.DeleteKey(buf);
         if (err.Succeeded())
         {
            m_share_list.DeleteString(index);
            int count = m_share_list.GetCount();
            m_ShareThis = count > 0 ? 1 : 0;
            if (m_ShareThis)
            {
               m_share_list.SetCurSel(index >= count ? count - 1 : index);
            }
            EnableOnShare();
            CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
            CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
            ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
         }
         else
         {
            err.MessageBox();
         }
      }
      else
      {
         err.MessageBox();
      }
   }
}

void 
CW3PropPage::OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CEditAlias dlg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   dlg.m_instance = p;
   p = m_pParentExt->GetPath();
   ::StrCpy(dlg.m_path, p);
   index = m_share_list.GetCurSel();
   TCHAR buf[MAX_PATH];
   m_share_list.GetText(index, buf);
   ::StrCpy(dlg.m_alias, buf);
   dlg.m_new = FALSE;
   if (IDOK == dlg.DoModal())
   {
      OnServerChange(0, 0, NULL);
      ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
   }
}

void 
CW3PropPage::OnServerChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   // get selected server instance number
   int index = m_servers_list.GetCurSel();
   if (LB_ERR != index)
   {
      LPTSTR p = (LPTSTR)m_servers_list.GetItemDataPtr(index);
      CMetabasePath path(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT);
      CMetaEnumerator en(LOCAL_KEY, path);
      ASSERT(en.Succeeded());
      m_share_list.ResetContent();
      if (en.Succeeded())
      {
         RecurseVDirs(en, NULL);
      }
      m_ShareThis = m_share_list.GetCount() > 0 ? 1 : 0;
   }
   if (m_ShareThis)
   {
      m_share_list.SetCurSel(0);
   }
   EnableOnShare();
   CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
   CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
   ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
}

void
CW3PropPage::RecurseVDirs(CMetaEnumerator& en, LPCTSTR path)
{
   CString vrpath, csPathMunged;
   BOOL bInheritOverride = FALSE;
   if (SUCCEEDED(en.QueryValue(MD_VR_PATH, vrpath, &bInheritOverride, path)))
   {
      GetSpecialPathRealPath(vrpath,csPathMunged);
      if (csPathMunged.CompareNoCase(m_pParentExt->GetPath()) == 0)
      {
         CMetabasePath mpath(FALSE, path);
         CMetabasePath::CleanMetaPath(mpath);
         m_share_list.AddString(path == NULL ? 
            SZ_MBN_SEP_STR : mpath.QueryMetaPath());
      }
   }
   CString vdir;
   while (SUCCEEDED(en.Next(vdir, path)))
   {
      CString next_vdir;
      if (path != NULL)
         next_vdir += path;
      next_vdir += vdir;
      next_vdir += SZ_MBN_SEP_STR;
      en.Push();
      en.Reset();
      RecurseVDirs(en, next_vdir);
      en.Pop();
   }
}

void 
CW3PropPage::OnShareYesNo(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   int count = m_share_list.GetCount();
   m_ShareThis = IsDlgButtonChecked(IDC_SHARE_ON);
   if (m_ShareThis)
   {
      if (count <= 0)
      {
         OnAdd(0, 0, NULL);
         m_ShareThis = (m_share_list.GetCount() > 0);
      }
   }
   else
   {
      if (count > 0)
      {
         CString cap, msg;
         int index = m_servers_list.GetCurSel();
         LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
         cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
         msg.LoadString(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE_ALL);
         CError err;
         if (IDYES == MessageBox(msg, cap, MB_YESNO))
         {
            CWaitCursor wait;
            TCHAR alias[MAX_PATH];
            int del_idx = 0;
            for (index = 0; err.Succeeded() && index < count; index++)
            {
               m_share_list.GetText(del_idx, alias);
               if (0 == StrCmp(alias, SZ_MBN_SEP_STR))
               {
                   // Do not remove sites! Skip it.
                   del_idx++;
                   continue;
               }
               do 
               {
                  CIISApplication app(NULL, CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT, alias));
                  err = app.QueryResult();
                  BREAK_ON_ERR_FAILURE(err)
                  err = app.Delete(TRUE);
                  BREAK_ON_ERR_FAILURE(err)
                  CMetaKey mk(LOCAL_KEY, 
                     CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT),
                     METADATA_PERMISSION_WRITE);
                  err = mk.DeleteKey(alias);
                  BREAK_ON_ERR_FAILURE(err)
               } while (FALSE);
               BREAK_ON_ERR_FAILURE(err)
               m_share_list.DeleteString(del_idx);
            }
            if (err.Failed() || del_idx > 0)
            {
// BUGBUG: we have AV when preparing message box text here
//               err.MessageBox();
               m_ShareThis = TRUE;
            }
         }
         else
         {
            m_ShareThis = TRUE;
         }
      }
   }
   CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
   CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
   EnableOnShare();
   ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
}

void
CW3PropPage::EnableOnShare()
{
   m_share_list.EnableWindow(m_ShareThis);
   ::EnableWindow(GetDlgItem(IDC_ADD), m_ShareThis);
   ::EnableWindow(GetDlgItem(IDC_EDIT), m_ShareThis 
      && m_share_list.GetCurSel() != LB_ERR);
   ::EnableWindow(GetDlgItem(IDC_REMOVE), m_ShareThis
      && m_share_list.GetCurSel() != LB_ERR);
   if (m_ShareThis)
   {
       EnableEditRemove();
   }
}

void 
CW3PropPage::OnVDirChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
    EnableEditRemove();
}

void
CW3PropPage::EnableEditRemove()
{
    // We are disabling Edit and Remove buttons when user
    // select root alias, i.e. user cannot delete or edit sites
    int index = m_share_list.GetCurSel();
    BOOL bEnable = index != LB_ERR;
    if (bEnable)
    {
        TCHAR alias[MAX_PATH];
        m_share_list.GetText(index, alias);
        bEnable = (0 != StrCmp(alias, SZ_MBN_SEP_STR));
    }
    ::EnableWindow(GetDlgItem(IDC_EDIT), bEnable);
    ::EnableWindow(GetDlgItem(IDC_REMOVE), bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\w3proppage.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        W3PropPage.h

   Abstract:
        IIS Shell extension PropertyPage class definition

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef __W3PROPPAGE_H_
#define __W3PROPPAGE_H_

#include "resource.h"       // main symbols

class CPropShellExt;
class CMetaEnumerator;

#define LOCAL_KEY    ((CComAuthInfo *)NULL)

template <class T, bool bAutoDelete = true>
class CShellExtPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CShellExtPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK | PSP_USEREFPARENT | PSP_DEFAULT;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
        m_psp.pcRefParent = reinterpret_cast<UINT *>(&_Module.m_nLockCnt);
        m_psp.lParam = reinterpret_cast<LPARAM>(this);

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE || uMsg == PSPCB_ADDREF)
		{
			CDialogImplBase * pPage = (CDialogImplBase *)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T * pPage = (T *)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}
};

class CComboBoxExch : public CWindowImpl<CComboBoxExch, CComboBox>
{
public:
   BEGIN_MSG_MAP_EX(CComboBoxExch)
   END_MSG_MAP()
};

class CListBoxExch : public CWindowImpl<CListBoxExch, CListBox>
{
public:
   BEGIN_MSG_MAP_EX(CListBoxExch)
   END_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CW3PropPage

// We cannot make this class autodelete -- we are storing instance of this page 
// inside of shell extension module
//
class CW3PropPage : 
   public CShellExtPropertyPageImpl<CW3PropPage, false>,
   public CWinDataExchange<CW3PropPage>
{
public:
   CW3PropPage() :
      CShellExtPropertyPageImpl<CW3PropPage, false>(MAKEINTRESOURCE(IDS_PAGE_TITLE)),
      m_pParentExt(NULL)
	{
	}

	~CW3PropPage()
	{
	}

	enum { IDD = IDD_W3PROPERTY_PAGE };

BEGIN_MSG_MAP_EX(CW3PropPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   MSG_WM_DESTROY(OnDestroy)
   COMMAND_ID_HANDLER_EX(IDC_ADD, OnAdd)
   COMMAND_ID_HANDLER_EX(IDC_REMOVE, OnRemove)
   COMMAND_ID_HANDLER_EX(IDC_EDIT, OnEdit)
   COMMAND_HANDLER_EX(IDC_COMBO_SERVER, CBN_SELCHANGE, OnServerChange)
   COMMAND_HANDLER_EX(IDC_SHARE_OFF, BN_CLICKED, OnShareYesNo)
   COMMAND_HANDLER_EX(IDC_SHARE_ON, BN_CLICKED, OnShareYesNo)
   COMMAND_HANDLER_EX(IDC_LIST, LBN_SELCHANGE, OnVDirChange)
   COMMAND_HANDLER_EX(IDC_LIST, LBN_DBLCLK, OnEdit)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnDestroy();
   void OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnServerChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnShareYesNo(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnVDirChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);

   BEGIN_DDX_MAP(CW3PropPage)
      DDX_CONTROL(IDC_COMBO_SERVER, m_servers_list)
      DDX_CONTROL(IDC_LIST, m_share_list)
   END_DDX_MAP()

   void SetParentExt(CPropShellExt * pExt)
   {
      m_pParentExt = pExt;
   }

protected:
   void RecurseVDirs(CMetaEnumerator& en, LPCTSTR path);
   void EnableOnShare();
   void EnableEditRemove();

protected:
   CComboBoxExch m_servers_list;
   CListBoxExch m_share_list;
   BOOL m_ShareThis;
   CPropShellExt * m_pParentExt;
};

#endif //__W3PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by w3ext.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPSHELLEXT_DESC           101
#define IDR_PROP_SHELL_EXT              102
#define IDS_SERVICE_NAME                102
#define IDD_W3PROPERTY_PAGE             103
#define IDS_PAGE_TITLE                  103
#define IDS_DEFAULT_SERVER_COMMENT      104
#define IDS_NO_PARENT                   105
#define IDS_WRITEEXECUTE_DANGER         106
#define IDS_ALIAS_IS_TAKEN              107
#define IDS_CONFIRM_REMOVE              108
#define IDS_CONFIRM_REMOVE_ALL          109
#define IDI_ICON_WEB_SERVICE            110
#define IDS_BAD_ALIAS                   110
#define IDI_ICON_IIS                    111
#define IDS_CONFIRM_OPERATION           111
#define IDC_ICON_WEB_SERVICE            201
#define IDC_STATIC_STATUS               202
#define IDD_EDIT_ALIAS                  202
#define IDC_STATIC_SHARE_ON             203
#define IDC_COMBO_SERVER                204
#define IDC_SHARE_OFF                   205
#define IDC_SHARE_ON                    206
#define IDC_STATIC_ALIAS_TITLE          207
#define IDC_LIST                        208
#define IDC_ADD                         209
#define IDC_EDIT                        210
#define IDC_REMOVE                      211
#define IDC_STATIC_ICON_IIS             212
#define IDC_ALIAS                       213
#define IDC_READ                        214
#define IDC_WRITE                       215
#define IDC_FULLCONTROL                 216
#define IDC_DIRBROWSE                   217
#define IDC_NONE_PERMS                  218
#define IDC_SCRIPTS_PERMS               219
#define IDC_EXECUTE_PERMS               220
#define IDC_PATH                        221

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         207
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED_)
#define AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
#include <prsht.h>
#include <shfusion.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define _WTL_NO_CSTRING

#include <shellapi.h>
#include <shlobj.h>
#include <shlguid.h>
#include <shlwapi.h>

#include <comdef.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlctrlx.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <set>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\adminacl.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    adminacl.h

Abstract:

    Contains definition of CAdminACL

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _adminacl_h_
#define _adminacl_h_

#include <iads.h>
#include <adshlp.h>

#include <atlbase.h>
#include <comutil.h>
#include <dbgutil.h>

//
// A parameter to the GetACE function.  As we enumerate the ACEs,
// we call IACEEnumOperation::Do.
// Then, we call Done to see whether to continue enumeration.
//
class CACEEnumOperation_Base
{
public:
    enum eDone
    {
        eDONE_YES,
        eDONE_NO,
        eDONE_DONT_KNOW
    };

    virtual HRESULT Do(
        IADsAccessControlEntry* pACE)   = 0;

    virtual eDone   Done() = 0;

protected:
    HRESULT PopulateWmiACE(
        IWbemClassObject* pObj,
        IADsAccessControlEntry* pACE,
        BOOL bIsInherit);
};

class CAdminACL
{
    friend class CAssocACLACE;

private:

    IADs* m_pADs;
    IADsSecurityDescriptor* m_pSD;
    IADsAccessControlList* m_pDACL;
    BOOL bIsInherit;

    //
    // Indicate all ACEs we enum to WMI.
    //
    class CACEEnumOperation_IndicateAll : public CACEEnumOperation_Base
    {
    public:
        CACEEnumOperation_IndicateAll(
            BSTR             i_bstrNameValue,
            CWbemServices&   i_refNamespace,
            IWbemObjectSink& i_refWbemObjectSink,
            BOOL             bArgIsInherit)
        {
            m_vNameValue.bstrVal = i_bstrNameValue;
            m_vNameValue.vt      = VT_BSTR;
            m_pNamespace         = &i_refNamespace;
            m_pWbemObjectSink    = &i_refWbemObjectSink;
            m_hr                 = WBEM_S_NO_ERROR;
            bLocalIsInherit      = bArgIsInherit;

            m_hr = m_pNamespace->GetObject(
                WMI_CLASS_DATA::s_ACE.pszClassName, 
                0, 
                NULL, 
                &m_spClass,
                NULL);
            if(FAILED(m_hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", m_hr));
                return;
            }
        }

        virtual HRESULT Do(
            IADsAccessControlEntry* pACE);

        virtual eDone Done() { return eDONE_DONT_KNOW; }

    private:
        CWbemServices*   m_pNamespace;
        IWbemObjectSink* m_pWbemObjectSink;
        VARIANT          m_vNameValue;
        BOOL             bLocalIsInherit;
        HRESULT          m_hr;

        CComPtr<IWbemClassObject> m_spClass;
    };

    //
    // Find the matching ACE.
    //
    class CACEEnumOperation_Find : public CACEEnumOperation_Base
    {
    public:
        CACEEnumOperation_Find(
            CAdminACL*        pAdminACL,
            BSTR              bstrTrustee)
        {
            DBG_ASSERT(pAdminACL);
            DBG_ASSERT(bstrTrustee);

            m_pAdminACL   = pAdminACL;
            m_bstrTrustee = bstrTrustee;
            m_eDone       = eDONE_NO;
        }

        virtual HRESULT Do(
            IADsAccessControlEntry* pACE);

        virtual eDone Done() { return m_eDone; }

    protected:
        eDone                     m_eDone;

        CAdminACL*                m_pAdminACL;
        BSTR                      m_bstrTrustee;

        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE) = 0;
    };

    //
    // Find and return the matching ACE.
    //
    class CACEEnumOperation_FindAndReturn : public CACEEnumOperation_Find
    {
    public:
        CACEEnumOperation_FindAndReturn(
            CAdminACL*        pAdminACL,
            IWbemClassObject* pObj,
            BSTR              bstrTrustee,
            BOOL              bArgIsInherit) : 
            CACEEnumOperation_Find(pAdminACL, bstrTrustee) 
        {
            DBG_ASSERT(pObj);
            m_spObj = pObj;
            bLocalIsInherit = bArgIsInherit;
        }
    protected:
        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE)
        {
            DBG_ASSERT(pACE);
            return PopulateWmiACE(m_spObj, pACE, bLocalIsInherit);
        }
    private:
        CComPtr<IWbemClassObject> m_spObj;
        BOOL bLocalIsInherit;
    };

    //
    // Find and update the matching ACE.
    //
    class CACEEnumOperation_FindAndUpdate : public CACEEnumOperation_Find
    {
    public:
        CACEEnumOperation_FindAndUpdate(
            CAdminACL*        pAdminACL,
            IWbemClassObject* pObj,
            BSTR              bstrTrustee) : 
            CACEEnumOperation_Find(pAdminACL, bstrTrustee) 
        {
            DBG_ASSERT(pObj);
            m_spObj = pObj;
        }
    protected:
        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE)
        {
            DBG_ASSERT(pACE);
            return m_pAdminACL->SetDataOfACE(m_spObj, pACE);
        }
    private:
        CComPtr<IWbemClassObject> m_spObj;
    };

    //
    // Find and remove the matching ACE.
    //
    class CACEEnumOperation_FindAndRemove : public CACEEnumOperation_Find
    {
    public:
        CACEEnumOperation_FindAndRemove(
            CAdminACL*        pAdminACL,
            BSTR              bstrTrustee) : 
            CACEEnumOperation_Find(pAdminACL, bstrTrustee) 
        {
        }
    protected:
        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE)
        {
            DBG_ASSERT(pACE);

            CComPtr<IDispatch> spDisp;
            HRESULT hr = pACE->QueryInterface(IID_IDispatch,(void**)&spDisp);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
                return hr;
            }
        
            hr = m_pAdminACL->m_pDACL->RemoveAce(spDisp);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
                return hr;
            }

            return hr;
        }
    };

public:

    CAdminACL();
    ~CAdminACL();

    HRESULT GetObjectAsync(
        IWbemClassObject* pObj,
        ParsedObjectPath* pParsedObject,
        WMI_CLASS* pWMIClass
        ); 

    HRESULT PutObjectAsync(
        IWbemClassObject* pObj,
        ParsedObjectPath* pParsedObject,
        WMI_CLASS* pWMIClass
        );

    HRESULT EnumerateACEsAndIndicate(
        BSTR             i_bstrNameValue,
        CWbemServices&   i_refNamespace,
        IWbemObjectSink& i_refWbemObjectSink);

    HRESULT DeleteObjectAsync(ParsedObjectPath* pParsedObject);

    HRESULT OpenSD(
        LPCWSTR         wszMbPath,
        IMSAdminBase2*  pAdminBase);
    
    void CloseSD();

    HRESULT GetACEEnum(IEnumVARIANT** pEnum);

private:

    HRESULT SetSD();

    HRESULT CAdminACL::GetAdsPath(
        LPCWSTR     i_wszMbPath,
        BSTR*       o_pbstrAdsPath);

    //
    // ACL stuff
    //
    
    HRESULT PopulateWmiAdminACL(IWbemClassObject* pObj);
    
    HRESULT SetADSIAdminACL(
        IWbemClassObject* pObj);

    //
    // ACE stuff
    //

    HRESULT EnumACEsAndOp(
        CACEEnumOperation_Base& refOp);

    void GetTrustee(
        IWbemClassObject* pObj,
        ParsedObjectPath* pPath,    
        _bstr_t&          bstrTrustee);

    HRESULT AddACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee);

    HRESULT NewACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee,
        IADsAccessControlEntry** ppACE);

    HRESULT SetDataOfACE(
        IWbemClassObject* pObj,
        IADsAccessControlEntry* pACE);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\w3ext\w3ext.cpp ===
// w3ext.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for w3ext.idl by adding the following 
//      files to the Outputs.
//          w3ext_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f w3extps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "w3ext.h"
#include "iisdebug.h"
#include "dlldatax.h"

#include "w3ext_i.c"
#include "PropShellExt.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(CLSID_PropShellExt, CPropShellExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_W3EXTLib);
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModule(hInstance);
//        SHFusionInitialize(NULL);
		GetOutputDebugFlag();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
       SHFusionUninitialize ();
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\appladmin.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    appladmin.cpp

Abstract:

    This file contains implementation of:
        CAppPoolMethod, CWebAppMethod

Author:

    ???

Revision History:

    Mohit Srivastava            21-Jan-01

--*/


#include "iisprov.h"
#include "appladmin.h"
#include "MultiSzHelper.h"
#include "iiswmimsg.h"

//
// CApplAdmin
//

CAppPoolMethod::CAppPoolMethod()
{
    m_pIABase = (IMSAdminBase2*)metabase;   

    HRESULT hr = CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IIISApplicationAdmin,
        (void**)&m_spAppAdmin);

    THROW_ON_ERROR(hr);
}

CAppPoolMethod::~CAppPoolMethod()
{
}

void CAppPoolMethod::GetCurrentMode(
    VARIANT* io_pvtServerMode)
/*++

Synopsis: 
    This method, unlike the others, is actually on the IIsWebService node.

Arguments: [io_pvtServerMode] - 
           
--*/
{
    DBG_ASSERT(io_pvtServerMode != NULL);

    DWORD dwServerMode = 0;
    VariantInit(io_pvtServerMode);

    HRESULT hr = m_spAppAdmin->GetProcessMode(&dwServerMode);
    THROW_ON_ERROR(hr);

    io_pvtServerMode->vt   = VT_I4;
    io_pvtServerMode->lVal = dwServerMode;
}

void CAppPoolMethod::Start(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath != NULL);

    m_wszPath = i_wszMbPath;

    HRESULT hr = ExecMethod(MD_APPPOOL_COMMAND_START);
    THROW_ON_ERROR(hr);
}

void CAppPoolMethod::Stop(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath != NULL);

    m_wszPath = i_wszMbPath;

    HRESULT hr = ExecMethod(MD_APPPOOL_COMMAND_STOP);
    THROW_ON_ERROR(hr);
}

void CAppPoolMethod::RecycleAppPool(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath    != NULL);
    
    LPCWSTR wszAppPool = NULL;
    GetPtrToAppPool(i_wszMbPath, &wszAppPool);

    HRESULT hr = m_spAppAdmin->RecycleApplicationPool(wszAppPool);
    THROW_ON_ERROR(hr);
}

void CAppPoolMethod::EnumAppsInPool(
    LPCWSTR  i_wszMbPath,
    VARIANT* io_pvtApps)
/*++

Synopsis: 

Arguments: [i_wszMbPath] - 
           [io_pvtApps] - Will be an array of strings
           
--*/
{
    DBG_ASSERT(i_wszMbPath  != NULL);
    DBG_ASSERT(io_pvtApps != NULL);

    CComBSTR sbstrApps = NULL;
    VariantInit(io_pvtApps);

    LPCWSTR wszAppPool = NULL;
    GetPtrToAppPool(i_wszMbPath, &wszAppPool);

    HRESULT hr = m_spAppAdmin->EnumerateApplicationsInPool(
        wszAppPool,
        &sbstrApps);
    THROW_ON_ERROR(hr);

    CMultiSz MultiSz;

    hr = MultiSz.ToWmiForm(
        sbstrApps,
        io_pvtApps);
    THROW_ON_ERROR(hr);
}

void CAppPoolMethod::DeleteAppPool(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath);

    LPCWSTR wszAppPool = NULL;
    GetPtrToAppPool(i_wszMbPath, &wszAppPool);

    HRESULT hr = m_spAppAdmin->DeleteApplicationPool(wszAppPool);
    THROW_ON_ERROR(hr);
}

//
// CAppPoolMethod - private methods
//

void CAppPoolMethod::GetPtrToAppPool(
    LPCWSTR  i_wszMbPath,
    LPCWSTR* o_pwszAppPool)
/*++

Synopsis: 

Arguments: [i_wszMbPath] - 
           [o_wszAppPool] - This is a ptr to i_wszMbPath.  Does not need to be
                            freed by caller.
           
--*/
{
    DBG_ASSERT(i_wszMbPath);
    DBG_ASSERT(o_pwszAppPool);
    DBG_ASSERT(*o_pwszAppPool == NULL);

    DBG_ASSERT(i_wszMbPath[0] == L'/');
    DBG_ASSERT(i_wszMbPath[1] != L'\0');

    LPWSTR wszAppPool = (LPWSTR)wcsrchr(i_wszMbPath, L'/');

    if (NULL == wszAppPool)
    {
        CIIsProvException e;
        e.SetMC(WBEM_E_FAILED, IISWMI_INVALID_APPPOOL_CONTAINER, i_wszMbPath);
        throw e;
    }

    *wszAppPool = L'\0';
    if(_wcsicmp(i_wszMbPath, L"/LM/w3svc/AppPools") != 0)
    {
        *wszAppPool = L'/';
        CIIsProvException e;
        e.SetMC(WBEM_E_FAILED, IISWMI_INVALID_APPPOOL_CONTAINER, i_wszMbPath);
        throw e;
    }

    *wszAppPool = L'/';

    //
    // Set out params on success
    //
    *o_pwszAppPool = wszAppPool + 1;
}

HRESULT
CAppPoolMethod::IISGetAppPoolState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDD