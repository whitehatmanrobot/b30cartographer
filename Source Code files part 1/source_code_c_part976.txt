ind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

public:

	SetQueryOperation  (IN SnmpSession &session,	IN SnmpSetResponseEventObject *eventObjectArg ) ;
	~SetQueryOperation  () ;

	void Send () ;
	
	ULONG GetRowReceived () { return rowReceived ; }

	void DestroyOperation () { SnmpGetOperation :: DestroyOperation () ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpset.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

class SetOperation : public SnmpSetOperation
{
private:

	WbemSnmpProperty **m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	SnmpSetResponseEventObject *eventObject ;

	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;

	SnmpSession *session ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

public:

	SetOperation (IN SnmpSession &session , IN SnmpSetResponseEventObject *eventObject ) ;
	~SetOperation () ;

	void Send ( const ULONG &a_NumberToSend = 0xffffffff ) ;

	void DestroyOperation () { SnmpSetOperation :: DestroyOperation () ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpget.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

class GetOperation : public SnmpGetOperation
{
private:

	WbemSnmpProperty **m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	SnmpGetResponseEventObject *eventObject ;

	BOOL virtuals ;
	BOOL virtualsInitialised ;
	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;

	SnmpSession *session ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

public:

	GetOperation (IN SnmpSession &session , IN SnmpGetResponseEventObject *eventObject ) ;
	~GetOperation () ;

	void Send () ;

	void DestroyOperation () { SnmpGetOperation :: DestroyOperation () ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpobj.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include <windows.h>
#include <provexpt.h>

#define WBEM_NAMESPACE_EQUALS L"__Namespace=\""
#define WBEM_NAMESPACE_QUOTE L"\""

#define WBEM_CLASS_NAMESPACE			L"__Namespace"
#define WBEM_CLASS_NOTIFYSTATUS		L"__NotifyStatus"
#define WBEM_CLASS_EXTENDEDSTATUS		L"__ExtendedStatus"
#define WBEM_CLASS_SNMPNOTIFYSTATUS	L"SnmpNotifyStatus"
#define WBEM_CLASS_SNMPMACRO			L"SnmpMacro"
#define WBEM_CLASS_SNMPOBJECTTYPE	L"SnmpObjectType"
#define WBEM_CLASS_EXTRINSICEVENT	L"__ExtrinsicEvent"
#define WBEM_CLASS_SNMPNOTIFICATION L"SnmpNotification"
#define WBEM_CLASS_SNMPEXTENDEDNOTIFICATION L"SnmpExtendedNotification"
#define WBEM_CLASS_SNMPVARBIND L"SnmpVarBind"
#define WBEM_CLASS_NULL	L""

#define WBEM_PROPERTY_CLASS		L"__class"
#define WBEM_PROPERTY_SUPERCLASS	L"__superclass"
#define WBEM_PROPERTY_KEY			L"__key"
#define WBEM_PROPERTY_GENUS		L"__genus"
#define WBEM_PROPERTY_DYNASTY		L"__dynasty"
#define WBEM_PROPERTY_STATUSCODE   L"StatusCode"
#define WBEM_PROPERTY_SNMPSTATUSCODE   L"SnmpStatusCode"
#define WBEM_PROPERTY_SNMPSTATUSMESSAGE   L"Description"

#define WBEM_QUALIFIER_DYNAMIC						L"dynamic"
#define WBEM_QUALIFIER_PROVIDER						L"provider"
#define WBEM_QUALIFIER_KEY							L"key"
#define WBEM_QUALIFIER_KEY_ORDER					L"key_order"
#define WBEM_QUALIFIER_READ							L"read"
#define WBEM_QUALIFIER_WRITE						L"write"
#define WBEM_QUALIFIER_AGENTSNMPVERSION				L"AgentSNMPVersion"
#define WBEM_QUALIFIER_AGENTTRANSPORT				L"AgentTransport"
#define WBEM_QUALIFIER_AGENTADDRESS					L"AgentAddress"
#define WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME		L"AgentReadCommunityName"
#define WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME		L"AgentWriteCommunityName"
#define WBEM_QUALIFIER_AGENTRETRYCOUNT				L"AgentRetryCount"
#define WBEM_QUALIFIER_AGENTRETRYTIMEOUT			L"AgentRetryTimeout"
#define WBEM_QUALIFIER_AGENTVARBINDSPERPDU			L"AgentVarBindsPerPdu"
#define WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE	L"AgentFlowControlWindowSize"
#define WBEM_QUALIFIER_TYPE				L"type"
#define WBEM_QUALIFIER_NAME				L"name"
#define WBEM_QUALIFIER_DESCRIPTION			L"description"
#define WBEM_QUALIFIER_DYNASTY				L"dynasty"
#define WBEM_QUALIFIER_MODULE_NAME			L"module_name"
#define WBEM_QUALIFIER_GROUP_OBJECTID		L"group_objectid"
#define WBEM_QUALIFIER_VIRTUAL_KEY			L"virtual_key"
#define WBEM_QUALIFIER_OBJECT_IDENTIFIER	L"object_identifier"
#define WBEM_QUALIFIER_TEXTUAL_CONVENTION	L"textual_convention"
#define WBEM_QUALIFIER_ENCODING			L"encoding"
#define WBEM_QUALIFIER_SYNTAX				L"syntax"
#define WBEM_QUALIFIER_ENUMERATION			L"enumeration"
#define WBEM_QUALIFIER_BITS				L"bits"
#define WBEM_QUALIFIER_FIXED_LENGTH		L"fixed_length"
#define WBEM_QUALIFIER_VARIABLE_VALUE		L"variable_value"
#define WBEM_QUALIFIER_VARIABLE_LENGTH		L"variable_length"
#define WBEM_QUALIFIER_DISPLAY_HINT		L"display_hint"
#define WBEM_QUALIFIER_TYPE_MISMATCH		L"type_mismatch"
#define WBEM_QUALIFIER_VALUE_MISMATCH		L"value_mismatch"
#define WBEM_QUALIFIER_NOT_AVAILABLE		L"not_available"
#define WBEM_QUALIFIER_SINGLETON 		L"singleton"
#define WBEM_QUALIFIER_TABLECLASS		L"TableClass"
#define WBEM_QUALIFIER_KEYTYPES			L"KeyTypes"
#define WBEM_QUALIFIER_KEYVALUES			L"KeyValues"
#define WBEM_QUALIFIER_VARBINDINDEX		L"VarBindIndex"
#define WBEM_QUALIFIER_ROWSTATUS					L"rowstatus"

#define WBEM_INDEX_QUALIFIER_KEY							1
#define WBEM_INDEX_QUALIFIER_KEY_ORDER						2
#define WBEM_INDEX_QUALIFIER_READ							3
#define WBEM_INDEX_QUALIFIER_WRITE							4
#define WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION				5
#define WBEM_INDEX_QUALIFIER_AGENTTRANSPORT				6
#define WBEM_INDEX_QUALIFIER_AGENTADDRESS					7
#define WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME		8
#define WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME		9
#define WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT				10
#define WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT				11
#define WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU			12	
#define WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE	13	
#define WBEM_INDEX_QUALIFIER_TYPE							14
#define WBEM_INDEX_QUALIFIER_NAME							15
#define WBEM_INDEX_QUALIFIER_DESCRIPTION					16
#define WBEM_INDEX_QUALIFIER_DYNASTY						17
#define WBEM_INDEX_QUALIFIER_MODULE_NAME					18
#define WBEM_INDEX_QUALIFIER_GROUP_OBJECTID				19
#define WBEM_INDEX_QUALIFIER_VIRTUAL_KEY					20
#define WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER				21
#define WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION			22
#define WBEM_INDEX_QUALIFIER_ENCODING						23
#define WBEM_INDEX_QUALIFIER_SYNTAX						24
#define WBEM_INDEX_QUALIFIER_ENUMERATION					25
#define WBEM_INDEX_QUALIFIER_BITS							26
#define WBEM_INDEX_QUALIFIER_FIXED_LENGTH					27
#define WBEM_INDEX_QUALIFIER_VARIABLE_VALUE				28
#define WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH				29
#define WBEM_INDEX_QUALIFIER_DISPLAY_HINT					30
#define WBEM_INDEX_QUALIFIER_TYPE_MISMATCH					31
#define WBEM_INDEX_QUALIFIER_VALUE_MISMATCH					32
#define WBEM_INDEX_QUALIFIER_NOT_AVAILABLE					33
#define WBEM_INDEX_QUALIFIER_SINGLETON					34
#define WBEM_INDEX_QUALIFIER_TABLECLASS					35
#define WBEM_INDEX_QUALIFIER_KEYTYPES					36
#define WBEM_INDEX_QUALIFIER_KEYVALUES					37
#define WBEM_INDEX_QUALIFIER_VARBINDINDEX					38
#define WBEM_INDEX_QUALIFIER_ROWSTATUS					39

#define WBEM_TYPE_NULL					L"NULL"
#define WBEM_TYPE_INTEGER				L"INTEGER"
#define WBEM_TYPE_INTEGER32				L"INTEGER32"
#define WBEM_TYPE_COUNTER				L"Counter"
#define WBEM_TYPE_GAUGE				L"Gauge"
#define WBEM_TYPE_TIMETICKS			L"TimeTicks"
#define WBEM_TYPE_UNSIGNED32			L"UNSIGNED32"
#define WBEM_TYPE_COUNTER32			L"Counter32"
#define WBEM_TYPE_COUNTER64			L"Counter64"
#define WBEM_TYPE_GAUGE32				L"Gauge32"
#define WBEM_TYPE_OCTETSTRING			L"OCTETSTRING"
#define WBEM_TYPE_OPAQUE				L"Opaque"
#define WBEM_TYPE_IPADDRESS			L"IpAddress"
#define WBEM_TYPE_NETWORKADDRESS		L"NetworkAddress"
#define WBEM_TYPE_OBJECTIDENTIFIER		L"OBJECTIDENTIFIER"
#define WBEM_TYPE_DISPLAYSTRING		L"DisplayString"
#define WBEM_TYPE_MACADDRESS			L"MacAddress"
#define WBEM_TYPE_PHYSADDRESS			L"PhysAddress" 
#define WBEM_TYPE_ENUMERATEDINTEGER	L"EnumeratedInteger"
#define WBEM_TYPE_BITS					L"BITS"
#define WBEM_TYPE_DATETIME				L"DateAndTime"
#define WBEM_TYPE_SNMPOSIADDRESS		L"SnmpOSIAddress"
#define WBEM_TYPE_SNMPUDPADDRESS		L"SnmpUDPAddress"
#define WBEM_TYPE_SNMPIPXADDRESS		L"SnmpIPXAddress"
#define WBEM_TYPE_ROWSTATUS		L"RowStatus"


#define WBEM_INDEX_TYPE_NULL				1
#define WBEM_INDEX_TYPE_INTEGER			2
#define WBEM_INDEX_TYPE_INTEGER32			3
#define WBEM_INDEX_TYPE_COUNTER			4
#define WBEM_INDEX_TYPE_GAUGE				5
#define WBEM_INDEX_TYPE_TIMETICKS			6
#define WBEM_INDEX_TYPE_OCTETSTRING		7
#define WBEM_INDEX_TYPE_OPAQUE				8
#define WBEM_INDEX_TYPE_IPADDRESS			9
#define WBEM_INDEX_TYPE_NETWORKADDRESS		10
#define WBEM_INDEX_TYPE_OBJECTIDENTIFIER	11
#define WBEM_INDEX_TYPE_DISPLAYSTRING		12
#define WBEM_INDEX_TYPE_MACADDRESS			13
#define WBEM_INDEX_TYPE_PHYSADDRESS		14
#define WBEM_INDEX_TYPE_ENUMERATEDINTEGER	15
#define WBEM_INDEX_TYPE_UNSIGNED32			16
#define WBEM_INDEX_TYPE_COUNTER32			17
#define WBEM_INDEX_TYPE_COUNTER64			18
#define WBEM_INDEX_TYPE_GAUGE32			19
#define WBEM_INDEX_TYPE_BITS				20
#define WBEM_INDEX_TYPE_DATETIME			21
#define WBEM_INDEX_TYPE_SNMPOSIADDRESS		22
#define WBEM_INDEX_TYPE_SNMPUDPADDRESS		23
#define WBEM_INDEX_TYPE_SNMPIPXADDRESS		24
#define WBEM_INDEX_TYPE_ROWSTATUS		25

#define WBEM_AGENTSNMPVERSION_DBCS_V1	"1"		
#define WBEM_AGENTSNMPVERSION_DBCS_V2C	"2C"		
#define WBEM_AGENTIPTRANSPORT_DBCS		"IP"
#define WBEM_AGENTIPXTRANSPORT_DBCS		"IPX"

#define WBEM_AGENTSNMPVERSION_V1	L"1"		
#define WBEM_AGENTSNMPVERSION_V2C	L"2C"		
#define WBEM_AGENTIPTRANSPORT		L"IP"
#define WBEM_AGENTIPXTRANSPORT		L"IPX"
#define WBEM_AGENTCOMMUNITYNAME  L"public"

#define WBEM_GENUS_INSTANCE		2
#define WBEM_GENUS_CLASS			1

#define WBEM_CLASS_NOCORRELATE 0x1000
#define WBEM_CLASS_CORRELATE_CONTEXT_PROP L"Correlate"

#define WBEM_QUERY_LANGUAGE_WQL			L"WQL"

#define WBEM_ERROR_CRITICAL_ERROR		WBEM_E_PROVIDER_FAILURE
#define WBEM_SNMP_ERROR_CRITICAL_ERROR	WBEM_SNMP_E_PROVIDER_FAILURE

#define WBEM_CLASS_PROPAGATION	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

typedef 
enum tag_WBEMSNMPSTATUS
{

	WBEM_SNMP_NO_ERROR							= 0,
	WBEM_SNMP_S_NO_ERROR							= 0,
	WBEM_SNMP_S_NO_MORE_DATA						= 0x40001,
	WBEM_SNMP_S_ALREADY_EXISTS					= WBEM_SNMP_S_NO_MORE_DATA + 1,
	WBEM_SNMP_S_NOT_FOUND						= WBEM_SNMP_S_ALREADY_EXISTS + 1,
	WBEM_SNMP_S_RESET_TO_DEFAULT					= WBEM_SNMP_S_NOT_FOUND + 1,
	WBEM_SNMP_E_FAILED							= 0x80041001,
	WBEM_SNMP_E_NOT_FOUND						= WBEM_SNMP_E_FAILED + 1,
	WBEM_SNMP_E_ACCESS_DENIED					= WBEM_SNMP_E_NOT_FOUND + 1,
	WBEM_SNMP_E_PROVIDER_FAILURE					= WBEM_SNMP_E_ACCESS_DENIED + 1,
	WBEM_SNMP_E_TYPE_MISMATCH					= WBEM_SNMP_E_PROVIDER_FAILURE + 1,
	WBEM_SNMP_E_OUT_OF_MEMORY					= WBEM_SNMP_E_TYPE_MISMATCH + 1,
	WBEM_SNMP_E_INVALID_CONTEXT					= WBEM_SNMP_E_OUT_OF_MEMORY + 1,
	WBEM_SNMP_E_INVALID_PARAMETER				= WBEM_SNMP_E_INVALID_CONTEXT + 1,
	WBEM_SNMP_E_NOT_AVAILABLE					= WBEM_SNMP_E_INVALID_PARAMETER + 1,
	WBEM_SNMP_E_CRITICAL_ERROR					= WBEM_SNMP_E_NOT_AVAILABLE + 1,
	WBEM_SNMP_E_INVALID_STREAM					= WBEM_SNMP_E_CRITICAL_ERROR + 1,
	WBEM_SNMP_E_NOT_SUPPORTED					= WBEM_SNMP_E_INVALID_STREAM + 1,
	WBEM_SNMP_E_INVALID_SUPERCLASS				= WBEM_SNMP_E_NOT_SUPPORTED + 1,
	WBEM_SNMP_E_INVALID_NAMESPACE				= WBEM_SNMP_E_INVALID_SUPERCLASS + 1,
	WBEM_SNMP_E_INVALID_OBJECT					= WBEM_SNMP_E_INVALID_NAMESPACE + 1,
	WBEM_SNMP_E_INVALID_CLASS					= WBEM_SNMP_E_INVALID_OBJECT + 1,
	WBEM_SNMP_E_PROVIDER_NOT_FOUND				= WBEM_SNMP_E_INVALID_CLASS + 1,
	WBEM_SNMP_E_INVALID_PROVIDER_REGISTRATION	= WBEM_SNMP_E_PROVIDER_NOT_FOUND + 1,
	WBEM_SNMP_E_PROVIDER_LOAD_FAILURE			= WBEM_SNMP_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_SNMP_E_INITIALIZATION_FAILURE			= WBEM_SNMP_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_SNMP_E_TRANSPORT_FAILURE				= WBEM_SNMP_E_INITIALIZATION_FAILURE + 1,
	WBEM_SNMP_E_INVALID_OPERATION				= WBEM_SNMP_E_TRANSPORT_FAILURE + 1,
	WBEM_SNMP_E_INVALID_QUERY					= WBEM_SNMP_E_INVALID_OPERATION + 1,
	WBEM_SNMP_E_INVALID_QUERY_TYPE				= WBEM_SNMP_E_INVALID_QUERY + 1,
	WBEM_SNMP_E_ALREADY_EXISTS					= WBEM_SNMP_E_INVALID_QUERY_TYPE + 1,
	WBEM_SNMP_E_OVERRIDE_NOT_ALLOWED				= WBEM_SNMP_E_ALREADY_EXISTS + 1,
	WBEM_SNMP_E_PROPAGATED_QUALIFIER				= WBEM_SNMP_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_SNMP_E_UNEXPECTED						= WBEM_SNMP_E_PROPAGATED_QUALIFIER + 1,
	WBEM_SNMP_E_ILLEGAL_OPERATION				= WBEM_SNMP_E_UNEXPECTED + 1,
	WBEM_SNMP_E_CANNOT_BE_KEY					= WBEM_SNMP_E_ILLEGAL_OPERATION + 1,
	WBEM_SNMP_E_INCOMPLETE_CLASS					= WBEM_SNMP_E_CANNOT_BE_KEY + 1,
	WBEM_SNMP_E_INVALID_SYNTAX					= WBEM_SNMP_E_INCOMPLETE_CLASS + 1,
	WBEM_SNMP_E_NONDECORATED_OBJECT				= WBEM_SNMP_E_INVALID_SYNTAX + 1,
	WBEM_SNMP_E_READ_ONLY						= WBEM_SNMP_E_NONDECORATED_OBJECT + 1,
	WBEM_SNMP_E_PROVIDER_NOT_CAPABLE				= WBEM_SNMP_E_READ_ONLY + 1,
	WBEM_SNMP_E_CLASS_HAS_CHILDREN				= WBEM_SNMP_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_SNMP_E_CLASS_HAS_INSTANCES				= WBEM_SNMP_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_SNMP_E_INVALID_PROPERTY					= WBEM_SNMP_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_SNMP_E_INVALID_QUALIFIER				= WBEM_SNMP_E_INVALID_PROPERTY + 1 ,
	WBEM_SNMP_E_INVALID_PATH						= WBEM_SNMP_E_INVALID_QUALIFIER + 1 ,
	WBEM_SNMP_E_INVALID_PATHKEYPARAMETER			= WBEM_SNMP_E_INVALID_PATH + 1 ,
	WBEM_SNMP_E_MISSINGPATHKEYPARAMETER 			= WBEM_SNMP_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_SNMP_E_INVALID_KEYORDERING				= WBEM_SNMP_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER		= WBEM_SNMP_E_INVALID_KEYORDERING + 1 ,
	WBEM_SNMP_E_MISSINGKEY						= WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_SNMP_E_INVALID_TRANSPORT				= WBEM_SNMP_E_MISSINGKEY + 1 ,
	WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT			= WBEM_SNMP_E_INVALID_TRANSPORT + 1 ,
	WBEM_SNMP_E_TRANSPORT_ERROR					= WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_SNMP_E_TRANSPORT_NO_RESPONSE			= WBEM_SNMP_E_TRANSPORT_ERROR + 1 ,
	WBEM_SNMP_E_NOWRITABLEPROPERTIES				= WBEM_SNMP_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_SNMP_E_NOREADABLEPROPERTIES				= WBEM_SNMP_E_NOWRITABLEPROPERTIES + 1 

} WBEMSNMPSTATUS;

enum WbemPropertyValueCheck
{
	SetValueRegardlessReturnCheck = 0 ,
	SetValueRegardlessDontReturnCheck ,
	SetValueIfCheckOk ,
	DontSetValueReturnCheck
} ;

#if 0
#if _MSC_VER >= 1100
template <> __declspec ( dllexport ) UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
__declspec ( dllexport ) UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> __declspec ( dllexport ) BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 ) ;
#else
__declspec ( dllexport ) BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif
#endif 

class __declspec ( dllexport ) WbemSnmpErrorObject 
{
private:

	wchar_t *m_snmpErrorMessage ;
	WBEMSNMPSTATUS m_snmpErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;

protected:
public:

	WbemSnmpErrorObject () : m_snmpErrorMessage ( NULL ) , m_wbemErrorStatus ( WBEM_NO_ERROR ) , m_snmpErrorStatus ( WBEM_SNMP_NO_ERROR ) {} ;
	virtual ~WbemSnmpErrorObject () { delete [] m_snmpErrorMessage ; } ;

	void SetStatus ( WBEMSNMPSTATUS a_snmpErrorStatus )
	{
		m_snmpErrorStatus = a_snmpErrorStatus ;
	} ;

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	} ;

	void SetMessage ( wchar_t *a_snmpErrorMessage )
	{
		DebugMacro1 ( 

			if ( a_snmpErrorMessage )
			{
				SnmpDebugLog :: s_SnmpDebugLog->Write ( 

					L"\r\nWbemSnmpErrorObject :: SetMessage ( (%s) )" , a_snmpErrorMessage 
				) ; 
			}
		)

		delete [] m_snmpErrorMessage ;
		m_snmpErrorMessage = UnicodeStringDuplicate ( a_snmpErrorMessage ) ;
	} ;

	wchar_t *GetMessage () { return m_snmpErrorMessage ; } ;
	WBEMSNMPSTATUS GetStatus () { return m_snmpErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
} ;

class __declspec ( dllexport ) WbemSnmpQualifier 
{
private:

	wchar_t *qualifierName ;
	SnmpInstanceType *typeValue ;

protected:
public:

	WbemSnmpQualifier ( const WbemSnmpQualifier &copy ) ;

	WbemSnmpQualifier (

		const wchar_t *qualifierName ,
		const SnmpInstanceType *typeValue 
	) ;

	virtual ~WbemSnmpQualifier () ;

	BOOL IsPropagatable () const ;

	wchar_t *GetName () const ;

	SnmpInstanceType *GetValue () const ;
	BOOL GetValue ( VARIANT &variant ) const ;
	VARTYPE GetValueVariantType () const ;

	BOOL SetValue ( const VARIANT &variant ) ;
	BOOL SetValue ( const SnmpInstanceType *value ) ;
	BOOL SetValue ( const wchar_t *value ) ;
	BOOL SetValue ( IWbemQualifierSet *a_Qualifier , const SnmpInstanceType &value ) ;
} ;

class __declspec ( dllexport ) WbemSnmpProperty 
{
private:

/* 
 * Qualifier Information
 */

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpQualifier *,WbemSnmpQualifier *

	> qualifierMap ;

	POSITION qualifierPosition ;

/* 
 * Property Information
 */

	BOOL m_isWritable ;
	BOOL m_isReadable ;
	BOOL m_isKey ;
	BOOL m_isVirtualKey ;
	BOOL m_IsNull ;
	BOOL tagged ;

	ULONG m_keyOrder ;
	ULONG m_TextualConvention ;

	wchar_t *propertyName ;
	SnmpInstanceType *propertyValue ;

	long m_Handle ;

protected:
public:

	WbemSnmpProperty ( const wchar_t *propertyName ) ;
	WbemSnmpProperty ( const WbemSnmpProperty &copy ) ;
	virtual ~WbemSnmpProperty () ;

	void SetTag ( BOOL tag = TRUE ) ;
	BOOL GetTag () ;

	BOOL IsKey () ;
	BOOL IsVirtualKey () ;
	BOOL IsWritable () ;
	BOOL IsReadable () ;
	ULONG GetKeyOrder () ;
	ULONG GetTextualConvention () ;
	CIMTYPE GetCimType () ;

	long GetHandle () ;

	void SetKey ( BOOL a_isKey = TRUE ) ;
	void SetKeyOrder ( ULONG a_keyOrder ) ;
	void SetVirtualKey ( BOOL a_isVirtualKey = TRUE ) ;
	void SetReadable ( BOOL a_isReadable = TRUE ) ;
	void SetWritable ( BOOL a_isWritable = TRUE ) ;
	void SetTextualConvention ( ULONG a_TextualConvention ) ;
	void SetHandle ( long a_Handle ) ;

	wchar_t *GetName () const ;

	BOOL IsNull () ;
	BOOL IsSNMPV1Type () { return propertyValue->IsSNMPV1Type () ; }
	BOOL IsSNMPV2CType () { return propertyValue->IsSNMPV2CType () ; }

	SnmpInstanceType *GetValue () const ;
	BOOL GetValue ( VARIANT &variant , CIMTYPE &type ) const ;
	VARTYPE GetValueVariantType () const ;
	VARTYPE GetValueVariantEncodedType () const ;

	BOOL SetValue ( const VARIANT &variant , const CIMTYPE &type , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const wchar_t *value , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const SnmpInstanceType *propertyValue , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const SnmpValue *propertyValue , WbemPropertyValueCheck check = SetValueIfCheckOk  ) ;
	BOOL SetValue ( IWbemClassObject *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;

	BOOL Encode ( const VARIANT &a_EncodeValue , SnmpObjectIdentifier &a_Encode ) ;

#if 0
	BOOL SetValue ( IWbemObjectAccess *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetDWORD ( BOOL a_Status , IWbemObjectAccess *a_Object , DWORD a_Value , WbemPropertyValueCheck check ) ;
	BOOL SetNULL ( BOOL a_Status , IWbemObjectAccess *a_Object , WbemPropertyValueCheck check ) ;
	BOOL SetSTRING ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t *t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check ) ;

#endif

	ULONG GetQualifierCount () ;
	BOOL AddQualifier ( wchar_t *qualifierName ) ;
	BOOL AddQualifier ( WbemSnmpQualifier *qualifier ) ;
	void ResetQualifier () ;
	WbemSnmpQualifier *NextQualifier () ;
	WbemSnmpQualifier *FindQualifier ( wchar_t *qualifierName ) const ;

	virtual BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class __declspec ( dllexport ) WbemSnmpClassObject 
{
private:

/* 
 * Object Information
 */

	BOOL m_isClass ;
	BOOL m_isKeyed ;
	BOOL m_isSingleton ;
	BOOL m_isVirtual ;
	BOOL m_isReadable ;
	BOOL m_isWritable ;
	ULONG m_numberOfAccessible ;

	wchar_t *className ;

/*
 * Qualifier Information
 */

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpQualifier *,WbemSnmpQualifier *

	> qualifierMap ;

	POSITION qualifierPosition ;

/*
 * Property Information
 */

	SnmpList <WbemSnmpProperty *,WbemSnmpProperty *> keyedPropertyList ;

	LONG keyedPropertyPosition ;

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpProperty *,WbemSnmpProperty *

	> propertyMap ;

	POSITION propertyPosition ;

private:

	BOOL SetMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL SetMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL SetMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL SetMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	BOOL  GetMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject 
	) ;

	BOOL GetMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL MergeMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject , 
		IWbemClassObject *mosClassObject , 
		BOOL rigorous 
	) ;

	BOOL GetMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject 
	) ;

	BOOL GetMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	BOOL MergeMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL MergeMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL MergeMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	void AddKeyedProperty ( WbemSnmpProperty *snmpProperty ) ;

protected:
public:

	WbemSnmpClassObject () ;
	WbemSnmpClassObject ( const WbemSnmpClassObject &copy ) ;
	WbemSnmpClassObject ( const wchar_t *className , const BOOL isClass = TRUE ) ;
	virtual ~WbemSnmpClassObject () ;

	BOOL IsReadable () ;
	void SetReadable ( BOOL a_isReadable = TRUE ) ;

	BOOL IsWritable () ;
	void SetWritable ( BOOL a_isWritable = TRUE ) ;

	BOOL IsKeyed () ;
	void SetKeyed ( BOOL a_isKeyed = TRUE ) ;

	BOOL IsVirtual () ;
	void SetVirtual ( BOOL a_isVirtual = TRUE ) ;

	BOOL IsSingleton () ;
	void SetSingleton ( BOOL a_isSingleton = TRUE ) ;

	ULONG GetNumberOfAccessible () ;
	void SetNumberOfAccessible ( ULONG m_numberOfAccessible ) ;

	void SetIsClass ( const BOOL isClass ) { m_isClass = isClass ; }

	BOOL IsClass () { return m_isClass ; }

	wchar_t *GetClassName () const ;

	ULONG GetPropertyCount () ;
	BOOL AddProperty ( wchar_t *propertyName ) ;
	BOOL AddProperty ( WbemSnmpProperty *property ) ;
	void ResetProperty () ;
	void DeleteProperty ( wchar_t *propertyName ) ;
	WbemSnmpProperty *NextProperty () ;
	WbemSnmpProperty *GetCurrentProperty () ;
	BOOL GotoProperty ( WbemSnmpProperty *property );
	

	WbemSnmpProperty *FindProperty ( wchar_t *propertyName ) const ;

	BOOL AddKeyedProperty ( wchar_t *propertyName ) ;
	ULONG GetKeyPropertyCount () ;
	void ResetKeyProperty () ;
	WbemSnmpProperty *NextKeyProperty () ;
	WbemSnmpProperty *FindKeyProperty ( wchar_t *propertyName ) const ;

	ULONG GetQualifierCount () ;
	BOOL AddQualifier ( wchar_t *qualifierName ) ;
	BOOL AddQualifier ( WbemSnmpQualifier *qualifier ) ;
	void ResetQualifier () ;
	WbemSnmpQualifier *NextQualifier () ;
	WbemSnmpQualifier *FindQualifier ( wchar_t *qualifierName ) const ;

	BOOL Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous = TRUE ) ;
	BOOL Get ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) ;
	BOOL Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous = TRUE ) ;

	virtual BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\clasprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpClasProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>
#include <typeinfo.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <correlat.h>
#include <genlex.h>
#include <objpath.h>
#include <cominit.h>

#include "classfac.h"
#include "clasprov.h"
#include "creclass.h"
#include "guids.h"

SnmpClassDefaultThreadObject *CImpClasProv :: s_defaultThreadObject = NULL ;

void SnmpClassDefaultThreadObject::Initialise ()
{
	InitializeCom () ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpClasProv::CImpClasProv
// CImpClasProv::~CImpClasProv
//
//***************************************************************************

CImpClasProv::CImpClasProv ()
{
	m_referenceCount = 0 ; 

/* 
 * Place code in critical section
 */

    InterlockedIncrement ( & CClasProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	initialised = FALSE ;
	server = NULL ;
	m_InitSink = NULL ;
	thisNamespace = NULL ;
	propertyProvider = NULL ;
	ipAddressString = NULL ;	
	ipAddressValue = NULL ;	
	m_notificationClassObject = NULL ;
	m_snmpNotificationClassObject = NULL ;
	m_getNotifyCalled = FALSE ;
	m_getSnmpNotifyCalled = FALSE ;
}

CImpClasProv::~CImpClasProv(void)
{

/*
 * Implementation
 */

	delete [] ipAddressString ;
	free ( ipAddressValue ) ;
 
	if ( server )
		server->Release () ;

	if ( m_InitSink )
		m_InitSink->Release () ;

	if ( propertyProvider )
		propertyProvider->Release () ;

	if ( m_notificationClassObject )
		m_notificationClassObject->Release () ;

	if ( m_snmpNotificationClassObject )
		m_snmpNotificationClassObject->Release () ;

	delete [] thisNamespace ;
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CClasProvClassFactory :: objectsInProgress ) ;

}


//***************************************************************************
//
// CImpClasProv::QueryInterface
// CImpClasProv::AddRef
// CImpClasProv::Release
//
// Purpose: IUnknown members for CImpClasProv object.
//***************************************************************************

STDMETHODIMP CImpClasProv::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

STDMETHODIMP_(ULONG) CImpClasProv::AddRef(void)
{
    return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpClasProv::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

void CImpClasProv :: SetServer ( IWbemServices *serverArg ) 
{
	server = serverArg ; 
	server-AddRef () ; 
}

void CImpClasProv :: SetProvider ( IWbemServices *provider ) 
{ 
	propertyProvider = provider ; 
}

IWbemServices *CImpClasProv :: GetServer () 
{ 
	return ( IWbemServices * ) server ; 
}

WbemNamespacePath *CImpClasProv :: GetNamespacePath () 
{ 
	return & namespacePath ; 
}

IWbemClassObject *CImpClasProv :: GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_notificationClassObject )
	{
		m_notificationClassObject->AddRef () ;
	}

	return m_notificationClassObject ; 
}

IWbemClassObject *CImpClasProv :: GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_snmpNotificationClassObject )
	{
		m_snmpNotificationClassObject->AddRef () ;
	}

	return m_snmpNotificationClassObject ; 
}

wchar_t *CImpClasProv :: GetThisNamespace () 
{
	return thisNamespace ; 
}

void CImpClasProv :: SetThisNamespace ( wchar_t *thisNamespaceArg ) 
{
	thisNamespace = UnicodeStringDuplicate ( thisNamespaceArg ) ; 
}

BOOL CImpClasProv:: FetchSnmpNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
	
)
{
	if ( m_getSnmpNotifyCalled )
	{
		if ( m_snmpNotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_getSnmpNotifyCalled = TRUE ;

	BOOL status = TRUE ;

	IWbemClassObject *classObject = NULL ;
	ISmirInterrogator *smirInterrogator = NULL ;

	HRESULT result = CoCreateInstance (
 
		CLSID_SMIR_Database ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_ISMIR_Interrogative ,
		( void ** ) &smirInterrogator 
	);

	if ( SUCCEEDED ( result ) )
	{
		ISMIRWbemConfiguration *smirConfiguration = NULL ;
		result = smirInterrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
		if ( SUCCEEDED ( result ) )
		{
			smirConfiguration->SetContext ( a_Ctx) ;
			smirConfiguration->Release () ;

			result = smirInterrogator->GetWBEMClass ( &m_snmpNotificationClassObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;	
			if ( ! SUCCEEDED ( result ) )
			{
				status = FALSE ;

				m_snmpNotificationClassObject = NULL ;
			}
		}
		else
		{		
			status = FALSE ;

			m_snmpNotificationClassObject = NULL ;
		}

		smirInterrogator->Release () ;
	}

	return status ;
}

BOOL CImpClasProv:: FetchNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	if ( m_getNotifyCalled )
	{
		if ( m_notificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_getNotifyCalled = TRUE ;

	BOOL status = TRUE ;

	IWbemCallResult *errorObject = NULL ;

	HRESULT result = server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx ,
		& m_notificationClassObject ,
		& errorObject 
	) ;

	if ( errorObject )
		errorObject->Release () ;

	if ( ! SUCCEEDED ( result ) )
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
	}

	return status ;
}

BOOL CImpClasProv::ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpClasProv::ObtainCachedIpAddress ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemClassObject *namespaceObject = NULL ;
	IWbemCallResult *errorObject = NULL ;

	HRESULT result = server->GetObject ( 

		WBEM_SNMP_TRANSPORTCONTEXT_OBJECT ,		
		0 ,
		NULL ,
		&namespaceObject ,
		&errorObject 
	) ;

	if ( errorObject )
			errorObject->Release () ;

	if ( SUCCEEDED ( result ) )
	{
		VARIANT variant ;
		VariantInit ( & variant ) ;

		LONG flavour;
		CIMTYPE cimType ;

		result = namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT, 
			0,	
			& variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( variant.vt == VT_BSTR ) 
			{
				if ( _wcsicmp ( variant.bstrVal , L"IP" ) == 0 )
				{
					VARIANT variant ;
					VariantInit ( & variant ) ;

					result = namespaceObject->Get ( 

						WBEM_QUALIFIER_AGENTADDRESS, 
						0,	
						& variant ,
						& cimType,
						& flavour
					) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( variant.vt == VT_BSTR ) 
						{
							ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
							if ( ipAddressString )
							{						

								SnmpTransportIpAddress transportAddress ( 
		
									ipAddressString , 
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
								) ;

								if ( transportAddress () )
								{	
									ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
								}
								else
								{
									delete [] ipAddressString ;
									ipAddressString = NULL ;

/*
 *	Invalid Transport Address.
 */

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
								}
 							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
						}

						VariantClear ( &variant ) ;
					}
					else
					{
/*
*	Transport Address not specified, ignore it
*/
					}
				}
				else if ( _wcsicmp ( variant.bstrVal , L"IPX" ) == 0 )
				{
				}
				else
				{
// Unknown transport type

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}
			}
			else
			{
/*
*	Transport qualifier was not a string value
*/

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}

			VariantClear ( & variant ) ;
		}
		else
		{
			VARIANT variant ;
			VariantInit ( & variant ) ;

			result = namespaceObject->Get ( 

				WBEM_QUALIFIER_AGENTADDRESS, 
				0,	
				& variant ,
				& cimType,
				& flavour
			) ;

			if ( SUCCEEDED ( result ) )
			{
				if ( variant.vt == VT_BSTR ) 
				{
					ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
					if ( ipAddressString )
					{
						SnmpTransportIpAddress transportAddress ( 

							ipAddressString , 
							SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
						) ;

						if ( transportAddress () )
						{	
							ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
						}
						else
						{
							delete [] ipAddressString ;
							ipAddressString = NULL ;

/*
 *	Invalid Transport Address.
 */

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}

				VariantClear ( & variant );
			}
			else
			{
/*
*	Transport Address not specified, ignore it
*/
			}
		}

		namespaceObject->Release () ;
	}

DebugMacro0( 

	wchar_t *t_UnicodeString = ipAddressValue ? DbcsToUnicodeString ( ipAddressValue ) : NULL ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from CImpClasProv::ObtainCachedIpAddress () with IP Address (%s)",
		t_UnicodeString ? t_UnicodeString : L"NULL"
	) ;

	delete [] t_UnicodeString ;
)

	return status ;
}


HRESULT STDMETHODCALLTYPE CImpClasProv::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpClasProv::GetObjectAsync ( (%s) )" ,
		ObjectPath
	) ;
)

	WbemSnmpErrorObject errorObject ;

	ParsedObjectPath *t_ParsedObjectPath = NULL ;
	CObjectPathParser t_ObjectPathParser ;

	BOOL status = t_ObjectPathParser.Parse ( ObjectPath , &t_ParsedObjectPath ) ;
	if ( status == 0 )
	{
	// Class requested

		wchar_t *Class = t_ParsedObjectPath->m_pClass ;

/*
 * Create Asynchronous Class object
 */

		SnmpClassGetAsyncEventObject *aSyncEvent = new SnmpClassGetAsyncEventObject ( this , Class, pHandler , pCtx ) ;

		aSyncEvent->Process () ;

		status = TRUE ;

		errorObject.SetStatus ( WBEM_SNMP_NO_ERROR ) ;
		errorObject.SetWbemStatus ( WBEM_NO_ERROR ) ;
		errorObject.SetMessage ( L"" ) ;

		delete t_ParsedObjectPath ;
	}
	else
	{
// Parse Failure

		status = FALSE ;
		errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
		errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		errorObject.SetMessage ( L"Failed to parse object path" ) ;
	}

// Check validity of server/namespace path and validity of request

	HRESULT result = errorObject.GetWbemStatus () ;

DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from CImpClasProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		result 
	) ;
)
 
	return result ;
}

HRESULT CImpClasProv :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

 HRESULT CImpClasProv :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpClasProv :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpClasProv::CreateClassEnumAsync ( (%s) )" ,
		Superclass
	) ;
)

	HRESULT result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	SnmpClassEnumAsyncEventObject *aSyncEvent = new SnmpClassEnumAsyncEventObject ( this , Superclass, lFlags , pHandler , pCtx ) ;

	aSyncEvent->Process () ;

DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning From CImpClasProv::CreateClassEnumAsync ( (%s) ) with Result = (%lx)" ,
		Superclass ,
		result
	) ;
)

	return result ;
}

HRESULT CImpClasProv :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpClasProv :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpClasProv :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpClasProv :: ExecMethod( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpClasProv :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::Initialize ()"
	) ;
)

	EnterCriticalSection ( & s_ProviderCriticalSection ) ;

	server = pCIMOM ;
	server->AddRef () ;

	namespacePath.SetNamespacePath ( pszNamespace ) ;

	BOOL status = TRUE ;

	if ( ! CImpClasProv :: s_defaultThreadObject )
	{
		SnmpThreadObject :: Startup () ;
		SnmpDebugLog :: Startup () ;
		SnmpClassLibrary :: Startup () ;

		CImpClasProv :: s_defaultThreadObject = new SnmpClassDefaultThreadObject ( "SNMP Class Provider" ) ; ;
		CImpClasProv :: s_defaultThreadObject->WaitForStartup () ;
	}

	WbemSnmpErrorObject errorObject ;

	ObtainCachedIpAddress ( errorObject ) ;

	status = FetchSnmpNotificationObject ( errorObject , pCtx ) ;
	status = FetchNotificationObject ( errorObject , pCtx ) ;

	//doing this here hangs cimom so delay until classes are asked for
#ifdef CORRELATOR_INIT
	//prime the correlator...
	if (errorObject.GetWbemStatus() == WBEM_NO_ERROR)
	{
		ISmirInterrogator *t_Interrogator = NULL;
		HRESULT result = CoCreateInstance (
 
			CLSID_SMIR_Database ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
			IID_ISMIR_Interrogative ,
			( void ** ) &t_Interrogator 
		);

		if ( SUCCEEDED ( result ) )
		{
			ISMIRWbemConfiguration *smirConfiguration = NULL ;
			result = t_Interrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
			if ( SUCCEEDED ( result ) )
			{
				smirConfiguration->SetContext ( pCtx ) ;
				CCorrelator::StartUp(t_Interrogator);
				smirConfiguration->Release () ;
			}
			else
			{
				errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				errorObject.SetMessage ( L"QueryInterface on ISmirInterrogator Failed" ) ;
			}

			t_Interrogator->Release();
		}
		else
		{
			errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			errorObject.SetMessage ( L"CoCreateInstance on ISmirInterrogator Failed" ) ;
		}
	}
#endif //CORRELATOR_INIT

	HRESULT result = errorObject.GetWbemStatus () ;

	pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning From CImpPropProv::OpenNamespace () with Result = (%lx)" ,
		result
	) ;
)

	LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
	
	return result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: OLE MS SNMP PROPERTY PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <instpath.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <classfac.h>
#include "clasprov.h"
#include "propprov.h"
#include "guids.h"
#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>


LONG CClasProvClassFactory :: objectsInProgress = 0 ;
LONG CClasProvClassFactory :: locksInProgress = 0 ;

LONG CPropProvClassFactory :: objectsInProgress = 0 ;
LONG CPropProvClassFactory :: locksInProgress = 0 ;

LONG CSNMPEventProviderClassFactory :: objectsInProgress = 0 ;
LONG CSNMPEventProviderClassFactory :: locksInProgress = 0 ;

extern CEventProviderThread* g_pProvThrd;
extern CEventProviderWorkerThread* g_pWorkerThread;
extern CCriticalSection g_ProvLock;

//***************************************************************************
//
// CClasProvClassFactory::CClasProvClassFactory
// CClasProvClassFactory::~CClasProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CClasProvClassFactory :: CClasProvClassFactory ()
{
	InterlockedIncrement ( & objectsInProgress ) ;
	m_referenceCount = 0 ;
}

CClasProvClassFactory::~CClasProvClassFactory ()
{
	InterlockedDecrement ( & objectsInProgress ) ;
}

//***************************************************************************
//
// CClasProvClassFactory::QueryInterface
// CClasProvClassFactory::AddRef
// CClasProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CClasProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CClasProvClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CClasProvClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CClasProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClasProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemServices *lpunk = ( IWbemServices * ) new CImpClasProv ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

//***************************************************************************
//
// CClasProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CClasProvClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & locksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & locksInProgress ) ;
	}

	return S_OK	;
}

//***************************************************************************
//
// CPropProvClassFactory::CPropProvClassFactory
// CPropProvClassFactory::~CPropProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CPropProvClassFactory :: CPropProvClassFactory ()
{
	InterlockedIncrement ( & objectsInProgress ) ;
	m_referenceCount = 0 ;
}

CPropProvClassFactory::~CPropProvClassFactory ()
{
	InterlockedDecrement ( & objectsInProgress ) ;
}

//***************************************************************************
//
// CPropProvClassFactory::QueryInterface
// CPropProvClassFactory::AddRef
// CPropProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CPropProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CPropProvClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CPropProvClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CPropProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CPropProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemServices *lpunk = ( IWbemServices * ) new CImpPropProv ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

//***************************************************************************
//
// CPropProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CPropProvClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & locksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & locksInProgress ) ;
	}

	return S_OK	;
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::CSNMPEventProviderClassFactory
// CSNMPEventProviderClassFactory::~CSNMPEventProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CSNMPEventProviderClassFactory :: CSNMPEventProviderClassFactory ()
{
	m_referenceCount = 0 ;
}

CSNMPEventProviderClassFactory::~CSNMPEventProviderClassFactory ()
{
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::QueryInterface
// CSNMPEventProviderClassFactory::AddRef
// CSNMPEventProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CSNMPEventProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CSNMPEventProviderClassFactory :: AddRef ()
{
	InterlockedIncrement(&objectsInProgress);
	return InterlockedIncrement ( &m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CSNMPEventProviderClassFactory :: Release ()
{	
	LONG ref ;

	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		InterlockedDecrement(&objectsInProgress);
		return 0 ;
	}
	else
	{
		InterlockedDecrement(&objectsInProgress);
		return ref ;
	}
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CSNMPEventProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & locksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & locksInProgress ) ;
	}

	return S_OK	;
}

//***************************************************************************
//
// CSNMPEncapEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSNMPEncapEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	HRESULT status = E_FAIL;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION;
	}
	else 
	{
		if (g_ProvLock.Lock())
		{
			if (NULL == g_pProvThrd)
			{
				g_pWorkerThread = new CEventProviderWorkerThread;
				g_pWorkerThread->WaitForStartup();
				g_pProvThrd = new CEventProviderThread;
				g_pProvThrd->WaitForStartup();
			}

			g_ProvLock.Unlock();
			CTrapEventProvider* prov =  new CTrapEventProvider(CMapToEvent::EMappingType::ENCAPSULATED_MAPPER, g_pProvThrd);
			status = prov->QueryInterface (riid, ppvObject);

			if (NOERROR != status)
			{
				delete prov;
			}
		}
	}

	return status ;
}

//***************************************************************************
//
// CSNMPRefEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSNMPRefEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	HRESULT status = E_FAIL;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION;
	}
	else 
	{
		if (g_ProvLock.Lock())
		{
			if (NULL == g_pProvThrd)
			{
				g_pWorkerThread = new CEventProviderWorkerThread;
				g_pWorkerThread->WaitForStartup();
				g_pProvThrd = new CEventProviderThread;
				g_pProvThrd->WaitForStartup();
			}

			g_ProvLock.Unlock();
			CTrapEventProvider* prov =  new CTrapEventProvider(CMapToEvent::EMappingType::REFERENT_MAPPER, g_pProvThrd);
			status = prov->QueryInterface (riid, ppvObject);

			if (NOERROR != status)
			{
				delete prov;
			}
		}
	}

	return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpnext.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef __SNMPNEXT_H
#define __SNMPNEXT_H

class PropertyDefinition
{
private:
protected:
public:

	WbemSnmpProperty *m_Property ;

	ULONG m_KeyCount ;
	SnmpObjectIdentifier **m_ObjectIdentifierComponent ;
	SnmpObjectIdentifier **m_ObjectIdentifierStart ;
	SnmpObjectIdentifier **m_ObjectIdentifierEnd ;
	ULONG *m_PartitionIndex ;
	PartitionSet **m_KeyPartition ;

public:

	PropertyDefinition () 
	{
		m_KeyCount = 0 ;
		m_Property = NULL ;
		m_ObjectIdentifierStart = NULL ;
		m_ObjectIdentifierEnd = NULL ;
		m_KeyPartition = NULL ;
		m_PartitionIndex = NULL ;
		m_ObjectIdentifierComponent = NULL ;
	}

	~PropertyDefinition () 
	{
		for ( ULONG t_Index = 1 ; t_Index <= m_KeyCount ; t_Index ++ )
		{
			if ( m_ObjectIdentifierStart ) 
				delete m_ObjectIdentifierStart [ t_Index ] ;

			if ( m_ObjectIdentifierEnd ) 
				delete m_ObjectIdentifierEnd [ t_Index ] ;

			if ( m_ObjectIdentifierComponent )
			delete m_ObjectIdentifierComponent [ t_Index ] ;
		}

		delete [] m_ObjectIdentifierStart ;
		delete [] m_ObjectIdentifierEnd ;
		delete [] m_ObjectIdentifierComponent ;

		delete [] m_KeyPartition ;
		delete [] m_PartitionIndex ;
 	}
} ;

class AutoRetrieveOperation : public SnmpAutoRetrieveOperation
{
private:

	PropertyDefinition *m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	BOOL virtuals ;
	BOOL virtualsInitialised ;
	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;
	ULONG rowsReceived ;
	ULONG rowVarBindsReceived ;

	SnmpSession *session ;

	SnmpInstanceResponseEventObject *eventObject ;
	IWbemClassObject *snmpObject ;

	LONG EvaluateInitialVarBind ( 

		ULONG a_PropertyIndex ,
		SnmpObjectIdentifier &a_CurrentIdentifier ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateSubsequentVarBind ( 

		ULONG a_PropertyIndex ,
		IN ULONG &a_CurrentIndex ,
		SnmpObjectIdentifier &a_CurrentIdentifier ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateVarBind ( 

		ULONG a_PropertyIndex ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateResponse (

		ULONG a_PropertyIndex ,
		IN ULONG &a_CurrentIndex ,
		SnmpObjectIdentifier &a_AdvanceIdentifier 
	) ;

protected:

	void ReceiveResponse () ;

	void ReceiveRowResponse () ;

	void ReceiveRowVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	LONG EvaluateNextRequest (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN SnmpVarBind &sendVarBind
) ;


	void FrameTooBig() ;
	void FrameOverRun() ;

public:

	AutoRetrieveOperation (IN SnmpSession &session,	IN SnmpInstanceResponseEventObject *eventObjectArg ) ;
	~AutoRetrieveOperation () ;

	void Send () ;
	
	void DestroyOperation () { SnmpAutoRetrieveOperation :: DestroyOperation () ; }
};

#endif // __SNMPNEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\cormap.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <cormap.h>
#include <cordefs.h>


void CCorrelatorMap::Register(CCorrelator *key)
{
	m_MapLock.Lock();
	SetAt((DWORD)key,key);
	m_MapLock.Unlock();
}


void CCorrelatorMap::UnRegister(CCorrelator *key)
{
	m_MapLock.Lock();
	RemoveKey((DWORD)key);
	m_MapLock.Unlock();
}


CCorrelatorMap::~CCorrelatorMap()
{
	m_MapLock.Lock();

	if (!IsEmpty())
	{
		POSITION pos = GetStartPosition();

		while(NULL != pos)
		{
			CCorrelator* ccorr;
			DWORD key;
			GetNextAssoc(pos, key, ccorr);
			ccorr->CancelRequest();
		}

		RemoveAll();
	}

	m_MapLock.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\correlat.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>
#include <cordefs.h>
#include <cormap.h>
#include <snmplog.h>

extern CCorrCacheWrapper*	g_CacheWrapper;
extern CCorrelatorMap*		g_Map;
extern ISmirDatabase*		g_pNotifyInt;
extern CCorrCacheNotify*	gp_notify;

static CCriticalSection gs_InitLock;

void CCorrelator::StartUp(IN ISmirInterrogator *a_ISmirInterrogator)
{
	if (gs_InitLock.Lock())
	{
		if (NULL == g_CacheWrapper)
		{
			g_CacheWrapper = new CCorrCacheWrapper();
		}

		if (NULL == g_Map)
		{
			g_Map = new CCorrelatorMap();
		}

		gs_InitLock.Unlock();
	}

	CCorrCache* cache = g_CacheWrapper->GetCache();

	if (NULL == cache)
	{
		cache = new CCorrCache(a_ISmirInterrogator);
		g_CacheWrapper->SetCache(cache);
	}

	g_CacheWrapper->ReleaseCache();

}

#ifdef CORRELATOR_INIT
CCorrelator::CCorrelator(IN SnmpSession &session) : CCorrNextId(session)
{
#else //CORRELATOR_INIT
CCorrelator::CCorrelator(IN SnmpSession &session, IN ISmirInterrogator *a_ISmirInterrogator) : CCorrNextId(session)
{
	StartUp(a_ISmirInterrogator);
#endif //CORRELATOR_INIT

	m_VarBindCnt = 0;
	m_inProg = FALSE;
	m_Groups = NULL;
	m_group_OID = NULL;
	m_pCache = NULL;
	m_pItem = NULL;
	m_NoEntries = TRUE;
}


void CCorrelator::ReadRegistry()
{
	HKEY hkey;
	LONG res = RegOpenKey(HKEY_LOCAL_MACHINE, CORRELATOR_KEY, &hkey);
	UINT sessionVarBindCnt = session.GetVarbindsPerPdu();
	UINT maxVarBindCnt = ((VARBIND_COUNT < sessionVarBindCnt)
									? VARBIND_COUNT : sessionVarBindCnt);

	if (ERROR_SUCCESS != res)
	{
		m_VarBindCnt = maxVarBindCnt;
		return;
	}

	DWORD type;
	DWORD data;
	DWORD ldata=sizeof(DWORD);
	res = RegQueryValueEx(hkey, CORRELATOR_VALUE, NULL, &type,
							(unsigned char*) &data, &ldata);
	
	if ((ERROR_SUCCESS != res) || (REG_DWORD != type) ||
		(0 == data) || (maxVarBindCnt < data))
	{
		m_VarBindCnt = maxVarBindCnt;
	}
	else
	{
		m_VarBindCnt = data;
	}

	RegCloseKey(hkey);

}


void CCorrelator::Initialise()
{
	ReadRegistry();
	g_Map->Register(this);
	m_pCache = g_CacheWrapper->GetCache();
	g_CacheWrapper->ReleaseCache();

	if (NULL == m_pCache)
	{
		m_NoEntries = TRUE;
	}
	else
	{
		m_pCache->AddRef();
		m_rangePos = m_pCache->GetHeadRangeTable();
		
		if (m_rangePos)
		{
			m_NoEntries = FALSE;
			m_Groups = new CCorrGroupMask(m_pCache->GetSize());

		}
		else
		{
			m_NoEntries = TRUE;
		}
	}
}

CCorrelator::~CCorrelator()
{
	delete m_Groups;
	delete m_group_OID;

	if (m_pCache)
	{
		m_pCache->DecRef();
	}
}


void CCorrelator::DestroyCorrelator()
{
	Reset();
	DestroyOperation();
}

void CCorrelator::Reset()
{
	g_Map->UnRegister(this);

	if (m_pCache)
	{
		m_pCache->DecRef();
		m_pCache = NULL;
	}

	delete m_Groups;
	m_Groups = NULL;
	m_inProg = FALSE;
	delete m_group_OID;
	m_group_OID = NULL;
}

void CCorrelator::ReceiveNextId(IN const SnmpErrorReport &error,
								IN const CCorrObjectID &next_id)
{
	if (Snmp_Success == error.GetError())
	{
		BOOL nextNeeded = TRUE;

		switch(m_pItem->IsInRange(next_id))
		{
			case CCorrRangeTableItem::ECorrBeforeStart:
			{
				char* id = next_id.GetString();
				CCorrelator_Info i(CCorrelator_Info::ECorrGetNextError, error);
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
				Reset();
				Finished(TRUE);
				return;
			}
			break;

			case CCorrRangeTableItem::ECorrInRange:
			{
				CCorrelator_Info i(CCorrelator_Info::ECorrSuccess, error);

				//loop the group handle list and call correlated fro each...
				POSITION pos = m_pItem->GetGroupIdPtr()->m_groupHandles.GetHeadPosition();
				while (pos)
				{
					ISmirGroupHandle* gH = m_pItem->GetGroupIdPtr()->m_groupHandles.GetNext(pos);
					gH->AddRef();
					Correlated(i, gH);
				}
				
				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());

				if (m_group_OID)
				{
					Reset();
					Finished(TRUE);
					return;
				}
			}
			break;

			case CCorrRangeTableItem::ECorrAfterEnd:
			{
				nextNeeded = ProcessOID(error, next_id);
			}
			break;

			case CCorrRangeTableItem::ECorrEqualToEnd:
			{
				char* id = next_id.GetString();
				CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
			}
			break;

			default:
			{
DebugMacro6( 
				SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
					L"CCorrelator::ReceiveNextId - Undefined case reached\n");
)
			}
			break;

		}
		
		if (!m_rangePos && nextNeeded)
		{
			Reset();
			Finished(TRUE);
			return;
		}

		if (nextNeeded)
		{
			m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
		}

		if (m_group_OID)
		{
			while (!IsItemFromGroup())
			{
				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
				
				if (m_rangePos)
				{
					//check result set and make sure we discard
					//any results for this range item
					ScanAndSkipResults();
					m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
				}
				else
				{
					Reset();
					Finished(TRUE);
					return;
				}
			}
		}

		while (m_Groups->IsBitSet(m_pItem->GetGroupIdPtr()->GetIndex()))
		{
			if (m_rangePos && !m_group_OID)
			{
				//check result set and make sure we discard
				//any results for this range item
				ScanAndSkipResults();
				m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
			}
			else
			{
				Reset();
				Finished(TRUE);
				return;
			}
		}

		// GetNextResult will have called ReceiveNextID if the result is
		// TRUE so at this point we have to make sure recursion is safe.
		// when all the results from the previous GetNext have been processed
		// GetNextResult will return FALSE and the program will do the
		// next GetNext operation and stop recursing.

		if (!GetNextResult())
		{
			GetNextOIDs();
		}

		return;
	}
	else
	{
		switch(error.GetStatus())
		{
			case Snmp_No_Such_Name:
			{
				Reset();
				Finished(TRUE);
				return;
			}
			break;

			case Snmp_Gen_Error:
			case Snmp_Local_Error:
			case Snmp_General_Abort:
			case Snmp_No_Response:
			break;

			default:
			{
DebugMacro6( 
				SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
					L"CCorrelator::ReceiveNextId - Unexpected SNMP Error returned\n");
)
			}
			break;
		}

		CCorrelator_Info i(CCorrelator_Info::ECorrSnmpError, error);
		Correlated(i, (ISmirGroupHandle*)NULL);
		Reset();
		Finished(FALSE);
	}
}

void CCorrelator::ScanAndSkipResults()
{
	if (m_NextResult >= m_ResultsCnt)
	{
		return;
	}

	UINT lastResult = m_NextResult - 1;
	BOOL bInvalidOIDReported = FALSE;
	
	while (m_NextResult < m_ResultsCnt)
	{
		if (m_Results[lastResult].m_Out != m_Results[m_NextResult].m_Out)
		{
			if (Snmp_Success == m_Results[m_NextResult].m_report.GetError())
			{
				switch(m_pItem->IsInRange(m_Results[m_NextResult].m_Out))
				{
					case CCorrRangeTableItem::ECorrBeforeStart:
					case CCorrRangeTableItem::ECorrInRange:
					{
						lastResult = m_NextResult;
						m_NextResult++;
					}
					break;

					case CCorrRangeTableItem::ECorrAfterEnd:
					{
						return;
					}
					break;

					case CCorrRangeTableItem::ECorrEqualToEnd:
					{
						if (!bInvalidOIDReported)
						{
							char* id = m_Results[m_NextResult].m_Out.GetString();
							CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup,
												m_Results[m_NextResult].m_report);
							Correlated(i, (ISmirGroupHandle*)NULL, id);
							delete [] id;
							bInvalidOIDReported = TRUE;
						}

						lastResult = m_NextResult;
						m_NextResult++;
					}
					break;

					default:
					{
DebugMacro6( 
						SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
							L"CCorrelator::ScanAndSkipResults - Undefined case reached\n");
)
					}
					break;

				}
			}
			else
			{
				break;
			}
		}
		else
		{
			m_NextResult++;
		}
	}
}

BOOL CCorrelator::ProcessOID(IN const SnmpErrorReport& error, IN const CCorrObjectID& OID)
{
	BOOL ret = TRUE;
	BOOL invalidOID = TRUE;

	while (m_rangePos)
	{
		invalidOID = FALSE;
		m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);

		switch(m_pItem->IsInRange(OID))
		{
			case CCorrRangeTableItem::ECorrInRange:
			{
				if (!m_group_OID || IsItemFromGroup())
				{
					CCorrelator_Info i(CCorrelator_Info::ECorrSuccess, error);

					//loop the group handle list and call correlated fro each...
					POSITION pos = m_pItem->GetGroupIdPtr()->m_groupHandles.GetHeadPosition();
					while (pos)
					{
						ISmirGroupHandle* gH = m_pItem->GetGroupIdPtr()->m_groupHandles.GetNext(pos);
						gH->AddRef();
						Correlated(i, gH);
					}
				}

				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
				return ret;
			}
			break;
			
			case CCorrRangeTableItem::ECorrAfterEnd:
			{
				invalidOID = TRUE;
			}
			continue;

			case CCorrRangeTableItem::ECorrBeforeStart:
			case CCorrRangeTableItem::ECorrEqualToStart:
			{
				ret = FALSE;
			}
			case CCorrRangeTableItem::ECorrEqualToEnd:
			{
				CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
				char* id = OID.GetString();
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
				return ret;
			}
			break;
		}
	}

	if (invalidOID)
	{
		CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
		char* id = OID.GetString();
		Correlated(i, (ISmirGroupHandle*)NULL, id);
		delete [] id;
	}

	return ret;
}


BOOL CCorrelator::Start(IN const char* groupId) 
{
	if(m_inProg)
	{
		return FALSE;
	}
	
	if (groupId)
	{
		m_group_OID = new CCorrObjectID(groupId);
	}

	Initialise();
	m_inProg = TRUE;

	if (m_NoEntries || !(*this)())
	{
		SnmpErrorReport snmpi(Snmp_Success, Snmp_No_Error);
		CCorrelator_Info i(CCorrelator_Info::ECorrBadSession, snmpi);

		if (m_NoEntries)
		{
			i.SetInfo(CCorrelator_Info::ECorrEmptySMIR);
		}
		
		Correlated(i, (ISmirGroupHandle*)NULL);
		Reset();
		Finished(FALSE);
		return FALSE;
	}

	m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);

	if (m_group_OID)
	{
		while (!IsItemFromGroup())
		{
			m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
			
			if (m_rangePos)
			{
				m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
			}
			else
			{
				SnmpErrorReport snmpi(Snmp_Success, Snmp_No_Error);
				CCorrelator_Info i(CCorrelator_Info::ECorrNoSuchGroup, snmpi);
				Correlated(i, (ISmirGroupHandle*)NULL);
				Reset();
				Finished(FALSE);
				return FALSE;

			}
		}
	}

	GetNextOIDs();

	return TRUE;
}


void CCorrelator::GetNextOIDs()
{
	CCorrObjectID next_ids[VARBIND_COUNT];
	UINT count;
	POSITION tmpRangePos = m_rangePos;
	CCorrRangeTableItem* tmpItem = m_pItem;
	count = 0;
	tmpItem->GetStartRange(next_ids[count]);
	count++;

	if (NULL == m_group_OID)
	{
		while (tmpRangePos && (count < m_VarBindCnt))
		{
			tmpItem = m_pCache->GetNextRangeTable(&tmpRangePos);
			tmpItem->GetStartRange(next_ids[count]);
			count++;
		}
	}

	GetNextId(next_ids, count);
}


BOOL CCorrelator::IsItemFromGroup() const
{
	if (!m_group_OID || !m_pItem)
	{
		return FALSE;
	}

	CCorrObjectID tmp;
	m_pItem->GetGroupIdPtr()->GetGroupID(tmp);
	return(*m_group_OID == tmp);
}


void CCorrelator::TerminateCorrelator()
{
	if (gs_InitLock.Lock())
	{
		delete g_Map;
		g_Map = NULL;

		if (g_pNotifyInt)
		{
			g_pNotifyInt->DeleteNotify(gp_notify->GetCookie());
			g_pNotifyInt->Release();
			g_pNotifyInt = NULL;
		}

		if (gp_notify)
		{
			gp_notify->Release();
			gp_notify = NULL;
		}

		if (g_CacheWrapper)
		{
			CCorrCache* cache = g_CacheWrapper->GetCache();
			
			if (cache)
			{
				delete cache;
			}

			g_CacheWrapper->ReleaseCache();
			delete g_CacheWrapper;
			g_CacheWrapper = NULL;
		}
#if 0
		//matches the CoInitialize in startup
		CoUnintialize();
#endif
		gs_InitLock.Unlock();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\corrsnmp.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <cordefs.h>
#include <snmplog.h>


CCorrResult::CCorrResult() : m_report(Snmp_Success, Snmp_No_Error),
							m_In(NULL, 0),
							m_Out()
{
}


CCorrResult::~CCorrResult()
{
}


void CCorrResult::DebugOutputSNMPResult() const
{
	CCorrObjectID in;
	in.Set((UINT*)m_In.GetValue(), m_In.GetValueLength());
	CString debugstr;
	in.GetString(debugstr);
	debugstr += L"\t\t:\t\t";

	if (Snmp_Success == m_report.GetError())
	{
		CString tmp;
		m_Out.GetString(tmp);
		debugstr += tmp;
	}
	else
	{
		switch(m_report.GetStatus())
		{
			case Snmp_Gen_Error:
			{
				debugstr += L"Snmp_Gen_Error";
			}
			break;

			case Snmp_Local_Error:
			{
				debugstr += L"Snmp_Local_Error";
			}
			break;

			case Snmp_General_Abort:
			{
				debugstr += L"Snmp_General_Abort";
			}
			break;

			case Snmp_No_Response:
			{
				debugstr += L"Snmp_No_Response";
			}
			break;

			case Snmp_Too_Big:
			{
				debugstr += L"Snmp_Too_Big";
			}
			break;

			case Snmp_Bad_Value:
			{
				debugstr += L"Snmp_Bad_Value";
			}
			break;

			case Snmp_Read_Only:
			{
				debugstr += L"Snmp_Read_Only";
			}
			break;

			case Snmp_No_Access:
			{
				debugstr += L"Snmp_No_Access";
			}
			break;

			case Snmp_Wrong_Type:
			{
				debugstr += L"Snmp_Wrong_Type";
			}
			break;

			case Snmp_Wrong_Length:
			{
				debugstr += L"Snmp_Wrong_Length";
			}
			break;

			case Snmp_Wrong_Encoding:
			{
				debugstr += L"Snmp_Wrong_Encoding";
			}
			break;

			case Snmp_Wrong_Value:
			{
				debugstr += L"Snmp_Wrong_Value";
			}
			break;

			case Snmp_No_Creation:
			{
				debugstr += L"Snmp_No_Creation";
			}
			break;

			case Snmp_Inconsistent_Value:
			{
				debugstr += L"Snmp_Inconsistent_Value";
			}
			break;

			case Snmp_Resource_Unavailable:
			{
				debugstr += L"Snmp_Resource_Unavailable";
			}
			break;

			case Snmp_Commit_Failed:
			{
				debugstr += L"Snmp_Commit_Failed";
			}
			break;

			case Snmp_Undo_Failed:
			{
				debugstr += L"Snmp_Undo_Failed";
			}
			break;

			case Snmp_Authorization_Error:
			{
				debugstr += L"Snmp_Authorization_Error";
			}
			break;

			case Snmp_Not_Writable:
			{
				debugstr += L"Snmp_Not_Writable";
			}
			break;

			case Snmp_Inconsistent_Name:
			{
				debugstr += L"Snmp_Inconsistent_Name";
			}
			break;

			case Snmp_No_Such_Name:
			{
				debugstr += L"Snmp_No_Such_Name - Finished successfully!!";
			}
			break;


			default:
			{
				debugstr += L"Unexpected SNMP Error returned";
			}
			break;
		}
	}
	debugstr += L'\n';
DebugMacro6( 
	SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
		debugstr);
)
}

char *CCorrNextId::GetString(IN const SnmpObjectIdentifier &id)
{
   UINT length = id.GetValueLength();

   if (0 == length)
	   return NULL;

   ULONG *value = id.GetValue();

   UINT allocated_bytes = length*BYTES_PER_FIELD;
   char *str = new char[allocated_bytes];

   ostrstream output_stream(str, allocated_bytes);

   if ( !output_stream.good() )
	  return NULL;

   output_stream << (ULONG)value[0];

   for(UINT index=1; 
	   (output_stream.good()) && (index < length); 
	   index++)
	   output_stream << FIELD_SEPARATOR << (ULONG)value[index];

   if ( !output_stream.good() )
      return NULL;

   // end of string
   output_stream << (char)EOS;

   return str;
}

void CCorrNextId::ReceiveResponse()
{
DebugMacro6(
	for (UINT x = 0; x < m_ResultsCnt; x++)
	{
		m_Results[x].DebugOutputSNMPResult();
	}
)
	// the operation is complete - hand the object id
	// and the error report to the user
	m_NextResult = 1;
	ReceiveNextId(m_Results[0].m_report, m_Results[0].m_Out);
}


BOOL CCorrNextId::GetNextResult()
{
	if (m_NextResult >= m_ResultsCnt)
	{
		if (m_Results)
		{
			delete [] m_Results;
			m_Results = NULL;
		}

		return FALSE;
	}

	UINT lastResult = m_NextResult - 1;
	
	while (m_NextResult < m_ResultsCnt)
	{
		if (m_Results[lastResult].m_Out != m_Results[m_NextResult++].m_Out)
		{
			ReceiveNextId(m_Results[m_NextResult - 1].m_report,
							m_Results[m_NextResult - 1].m_Out);
			return TRUE;
		}
	}

	if (m_Results)
	{
		delete [] m_Results;
		m_Results = NULL;
	}

	return FALSE;
}


void CCorrNextId::ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind,
		IN const SnmpVarBind &replyVarBind,
		IN const SnmpErrorReport &error)
{	
	UINT x = 0;

	while (x < m_ResultsCnt) // have a test just in case
	{
		if (m_Results[x].m_In == requestVarBind.GetInstance())
		{
			break;
		}

		x++;
	}

	// currently uses the default "=" operator (bitwise copy)
	m_Results[x].m_report = error;
	m_Results[x].m_Out.Set((UINT*)replyVarBind.GetInstance().GetValue(),
							replyVarBind.GetInstance().GetValueLength());
}


void CCorrNextId::ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind,
		IN const SnmpErrorReport &error)
{
	UINT x = 0;

	while (x < m_ResultsCnt) // have a test just in case
	{
		if (m_Results[x].m_In == requestVarBind.GetInstance())
		{
			break;
		}

		x++;
	}

	// currently uses the default "=" operator (bitwise copy)
	m_Results[x].m_report = error;
}


// constructor - creates an operation and passes the snmp_session to it
CCorrNextId::CCorrNextId(IN SnmpSession &snmp_session)
		: SnmpGetNextOperation(snmp_session),
		  m_Results(NULL),
		  m_NextResult(0),
		  m_ResultsCnt(0)
{
}

// delete the m_object_id_string if required
CCorrNextId::~CCorrNextId()
{
	if ( m_Results != NULL )
	{
		delete [] m_Results;
	}
}

// in case of an error encountered while the method executes, 
// ReceiveNextId(LocalError, NULL) will be called synchronously
// otherwise, an asynchronous call to ReceiveNextId provides the next_id	
void CCorrNextId::GetNextId(IN const CCorrObjectID const *object_ids, IN UINT len)
{
	SnmpVarBindList var_bind_list;

	if (m_Results)
	{
		delete [] m_Results;
	}

	m_Results = new CCorrResult[len];
	m_NextResult = 0;
	m_ResultsCnt = len;

	for (UINT x = 0; x < len; x++)
	{
		m_Results[x].m_In.SetValue((ULONG*)object_ids[x].GetIds(),
										object_ids[x].GetLength());
		SnmpNull null_value;
		SnmpVarBind var_bind(m_Results[x].m_In, null_value);
		var_bind_list.Add(var_bind);
	}

	SendRequest(var_bind_list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\creclass.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpClasProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <correlat.h>
#include "classfac.h"
#include "clasprov.h"
#include "creclass.h"
#include "guids.h"

#ifdef CORRELATOR_INIT
SnmpCorrelation :: SnmpCorrelation ( 

	SnmpSession &session ,
	SnmpClassEventObject *eventObject

) : CCorrelator ( session ) ,
	m_session (  &session ) ,
	m_eventObject ( eventObject )
#else //CORRELATOR_INIT
SnmpCorrelation :: SnmpCorrelation ( 

	SnmpSession &session ,
	SnmpClassEventObject *eventObject,
	ISmirInterrogator *a_ISmirInterrogator

) : CCorrelator ( session, a_ISmirInterrogator ) ,
	m_session (  &session ) ,
	m_eventObject ( eventObject )

#endif //CORRELATOR_INIT
{
}

SnmpCorrelation :: ~SnmpCorrelation ()
{
	m_session->DestroySession () ;
}

void SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )" 
	) ;
)

	switch ( info.GetInfo () )
	{
		case CCorrelator_Info :: ECorrSuccess:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" Successful correlation" 
	) ;
)


			if ( phGroup )
			{
				phGroup->AddRef () ;
				m_eventObject->ReceiveGroup ( phGroup ) ;
			}
			else
			{
			}
		}
		break ;

		case CCorrelator_Info :: ECorrSnmpError:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" Unsuccessful correlation" 
	) ;
)

			m_eventObject->ReceiveError ( info ) ;
		} 
		break ;

		default:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" Unknown Correlation Status" 
	) ;
)

		}		
		break ;
	}

	if ( phGroup )
		phGroup->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" Returning from SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )" 
	) ;
)

}

void SnmpCorrelation :: Finished ( IN const BOOL Complete )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" SnmpCorrelation :: Finished ( IN const BOOL Complete )"
	) ;
)

	m_eventObject->ReceiveComplete () ;
	DestroyCorrelator () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" Returning from SnmpCorrelation :: Finished ( IN const BOOL Complete )"
	) ;
)

}

SnmpClassEventObject :: SnmpClassEventObject ( 

	CImpClasProv *provider ,
	IWbemContext *a_Context

) : m_provider ( provider ) , 
	m_correlate ( TRUE ) ,
	m_synchronousComplete ( FALSE ) ,
	m_correlator ( NULL ) ,
	m_namespaceObject ( NULL ) ,
	m_inCallstack ( FALSE ) ,
	m_Context ( a_Context ) ,
	m_GroupsReceived ( 0 ) ,
	m_State ( 0 )
{
	if ( m_provider )
		m_provider->AddRef () ;

	if ( m_Context )
	{
		m_Context->AddRef () ;

/*
 * Look for correlation flag in Context
 */

	
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT result = m_Context->GetValue ( WBEM_CLASS_CORRELATE_CONTEXT_PROP , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BOOL ) 
				m_correlate = t_Variant.boolVal ;

			VariantClear ( & t_Variant ) ;
		}
	}

	HRESULT result = CoCreateInstance (
 
		CLSID_SMIR_Database ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_ISMIR_Interrogative ,
		( void ** ) &m_Interrogator 
	);

	if ( SUCCEEDED ( result ) )
	{
		ISMIRWbemConfiguration *smirConfiguration = NULL ;
		result = m_Interrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
		if ( SUCCEEDED ( result ) )
		{
			smirConfiguration->SetContext ( m_Context ) ;
			smirConfiguration->Release () ;
		}
		else
		{
			m_Interrogator->Release () ;
			m_synchronousComplete = TRUE ;
			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			m_errorObject.SetMessage ( L"QueryInterface on ISmirInterrogator Failed" ) ;
		}
	}
	else
	{
		m_synchronousComplete = TRUE ;
		m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
		m_errorObject.SetMessage ( L"CoCreateInstance on ISmirInterrogator Failed" ) ;
	}
}

SnmpClassEventObject :: ~SnmpClassEventObject  ()
{
	if ( m_provider ) 
		m_provider->Release () ;

	if ( m_namespaceObject )
		m_namespaceObject->Release () ;

	if ( m_Context )
		m_Context->Release () ;

	if ( m_Interrogator )
		m_Interrogator->Release () ;
}

BOOL SnmpClassEventObject :: GetClass ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject **classObject , BSTR a_Class )
{
	HRESULT result = m_Interrogator->GetWBEMClass ( classObject , a_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
	}
	else
	{
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
		a_errorObject.SetMessage ( L"Failed to get class definition from SMIR" ) ;
	}

	return result ;
}

BOOL SnmpClassEventObject :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = m_provider->GetSnmpNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			VariantClear ( &variant ) ;

			if ( SUCCEEDED ( result ) )
			{
				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( m_errorObject.GetMessage () ) 
					{
						variant.vt = VT_BSTR ;
						variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

						result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
						VariantClear ( &variant ) ;

						if ( ! SUCCEEDED ( result ) )
						{
							(*notifyObject)->Release () ;
							status = GetNotifyStatusObject ( notifyObject ) ;
						}
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				status = GetNotifyStatusObject ( notifyObject ) ;
			}

			notificationClassObject->Release () ;
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}
	else
	{
		status = GetNotifyStatusObject ( notifyObject ) ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = m_provider->GetNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			if ( SUCCEEDED ( result ) )
			{
				if ( m_errorObject.GetMessage () ) 
				{
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( ! SUCCEEDED ( result ) )
					{
						status = FALSE ;
						(*notifyObject)->Release () ;
						(*notifyObject)=NULL ;
					}
				}
			}
			else
			{
				status = FALSE ;
				(*notifyObject)->Release () ;
				(*notifyObject)=NULL ;
			}

			VariantClear ( &variant ) ;

			notificationClassObject->Release () ;
		}
		else
		{
			status = FALSE ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentTransport ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentTransport 
)
{
	BOOL status = TRUE ;
	agentTransport = NULL ;
	BSTR t_Transport = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTTRANSPORT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT , 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
		else
		{
			t_Transport = WBEM_AGENTIPTRANSPORT ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Transport , WBEM_AGENTIPTRANSPORT ) == 0 ) || ( _wcsicmp ( t_Transport , WBEM_AGENTIPXTRANSPORT ) == 0 ) )
		{
			agentTransport = UnicodeStringDuplicate ( t_Transport ) ;
		}
		else
		{
/*
*	Transport type != IP || != IPX
*/
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
		}

	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentVersion ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentVersion 
)
{
	BOOL status = TRUE ;
	agentVersion = NULL ;
	BSTR t_Version = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTSNMPVERSION , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
	}

	if ( status & ! t_Version )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTSNMPVERSION  , 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
		else
		{
			t_Version = WBEM_AGENTSNMPVERSION_V1 ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V1 ) == 0 ) || ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V2C ) == 0 ) )
		{
			agentVersion = UnicodeStringDuplicate ( t_Version ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentAddress ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentAddress 
)
{
	BOOL status = TRUE ;
	agentAddress = NULL ;
	BSTR t_Address = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTADDRESS , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTADDRESS, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Namespace must specify valid qualifier for: AgentAddress" ) ;
		}
	}

	if ( status )
	{
		agentAddress = UnicodeStringDuplicate ( t_Address ) ;
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentReadCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentReadCommunityName 
)
{
	BOOL status = TRUE ;
	agentReadCommunityName = NULL ;
	BSTR t_Community = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentReadCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentRetryCount ( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentRetryCount 
)
{
	BOOL status = TRUE ;
	agentRetryCount = 1 ;
	BOOL t_RetryCount = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYCOUNT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryCount = TRUE ;
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYCOUNT, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentRetryTimeout( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentRetryTimeout 
)
{
	BOOL status = TRUE ;
	agentRetryTimeout = 0 ;
	BOOL t_RetryTimeout = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryTimeout = TRUE ;
 
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYTIMEOUT, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentMaxVarBindsPerPdu ( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentVarBindsPerPdu 
)
{
	BOOL status = TRUE ;
	agentVarBindsPerPdu = 0 ;
	BOOL t_VarBinds = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_VarBinds = TRUE ;
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTVARBINDSPERPDU, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{		
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentFlowControlWindowSize ( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentFlowControlWindowSize 
)
{
	BOOL status = TRUE ;
	agentFlowControlWindowSize = 0 ;
	BOOL t_WindowSize = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_WindowSize = TRUE ;
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	if ( ! m_namespaceObject )
	{
		IWbemServices *t_Server = m_provider->GetServer () ;

		IWbemCallResult *errorObject = NULL ;
		HRESULT result = t_Server->GetObject ( 

			WBEM_SNMP_TRANSPORTCONTEXT_OBJECT ,
			0  ,
			m_Context ,
			&m_namespaceObject ,
			&errorObject 
		) ;

		if ( SUCCEEDED ( result ) )
		{
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetMessage ( L"Failed to obtain transport object" ) ;
		}

		if ( errorObject )
			errorObject->Release () ;

	}

	return status ;
}

BOOL SnmpClassEventObject :: GetTransportInformation ( 

	WbemSnmpErrorObject &a_errorObject ,
	SnmpSession *&session 
)
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" SnmpClassEventObject :: GetTransportInformation ()"
	) ;
)

	BOOL status = TRUE ;

	wchar_t *agentVersion = NULL ;
	wchar_t *agentAddress = NULL ;
	wchar_t *agentTransport = NULL ;
	wchar_t *agentReadCommunityName = NULL ;
	ULONG agentRetryCount ;
	ULONG agentRetryTimeout ;
	ULONG agentMaxVarBindsPerPdu ;
	ULONG agentFlowControlWindowSize ;

	status = GetAgentVersion ( m_errorObject , agentVersion ) ;
	if ( status ) status = GetAgentAddress ( m_errorObject , agentAddress ) ;
	if ( status ) status = GetAgentTransport ( m_errorObject , agentTransport ) ;
	if ( status ) status = GetAgentReadCommunityName ( m_errorObject , agentReadCommunityName ) ;
	if ( status ) status = GetAgentRetryCount ( m_errorObject , agentRetryCount ) ;
	if ( status ) status = GetAgentRetryTimeout ( m_errorObject , agentRetryTimeout ) ;
	if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , agentMaxVarBindsPerPdu ) ;
	if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , agentFlowControlWindowSize ) ;

	if ( status )
	{
		char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
		if ( dbcsAgentAddress )
		{
			char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
			if ( dbcsAgentReadCommunityName )
			{
				if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
				{
					char *t_Address ;
					if ( m_provider->GetIpAddressString () && m_provider->GetIpAddressValue () && _stricmp ( m_provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
					{
						t_Address = m_provider->GetIpAddressValue () ;
					}
					else
					{
						if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
						{
							t_Address = dbcsAgentAddress ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else							
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;

							}
						}
					}

					if ( status )
					{
						if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
						{
							session = new SnmpV1OverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session) () )
							{
// Invalid session object, return failure

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;

								delete session ;
								session = NULL ;
							}
						}
						else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
						{
							session = new SnmpV2COverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session) () )
							{
// Invalid session object, return failure

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;

								delete session ;
								session = NULL ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;
						}
					}
				}
				else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
				{
					if ( ! SnmpTransportIpxAddress :: ValidateAddress ( dbcsAgentAddress  ) )
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
					}

					if ( status )
					{
						if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session) () )
							{
// Invalid session object, return failure

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;

								session = NULL ;
								delete session ;
							}
						}
						else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session) () )
							{
// Invalid session object, return failure

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;

								delete session ;
								session = NULL ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}

				delete [] dbcsAgentReadCommunityName ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
			}

			delete [] dbcsAgentAddress ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
		}
	}
	else
	{
DebugMacro1( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L" TransportInformation settings invalid"
) ;
)
	}

	delete [] agentTransport ;
	delete [] agentAddress ;
	delete [] agentVersion ;
	delete [] agentReadCommunityName ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L" SnmpClassEventObject :: GetTransportInformation () with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

SnmpClassGetEventObject :: SnmpClassGetEventObject ( 

	CImpClasProv *provider , 
	BSTR Class ,
	IWbemContext *a_Context

) : SnmpClassEventObject ( provider , a_Context ) , m_classObject ( NULL ) , m_Received ( FALSE ) 
{
	m_Class = UnicodeStringDuplicate ( Class ) ;
}

SnmpClassGetEventObject :: ~SnmpClassGetEventObject ()
{
	if ( m_classObject )
		m_classObject->Release () ;

	delete [] m_Class ;
}

BOOL SnmpClassGetEventObject :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	WbemSnmpErrorObject errorStatusObject ;

/*
 *	Don't ask for SnmpNotifyStatus if HMOM specifically asked for SnmpNotifyStatus, otherwise
 *	we'll end up in a deadlock situation.
 */
	BOOL status = TRUE ;

	if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFYSTATUS ) == 0 )
	{
		status = GetNotifyStatusObject ( notifyObject ) ;	
	}
	else
	{
		IWbemClassObject *notificationClassObject = NULL ;
		IWbemClassObject *errorObject = NULL ;

		if ( notificationClassObject = m_provider->GetSnmpNotificationObject ( errorStatusObject ) )
		{
			HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
			if ( SUCCEEDED ( result ) )
			{
				VARIANT variant ;
				VariantInit ( &variant ) ;

				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetWbemStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					variant.vt = VT_I4 ;
					variant.lVal = m_errorObject.GetStatus () ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( m_errorObject.GetMessage () ) 
						{
							variant.vt = VT_BSTR ;
							variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

							result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
							VariantClear ( &variant ) ;

							if ( ! SUCCEEDED ( result ) )
							{
								(*notifyObject)->Release () ;
								status = GetNotifyStatusObject ( notifyObject ) ;
							}
						}
					}
					else
					{
						(*notifyObject)->Release () ;
						status = GetNotifyStatusObject ( notifyObject ) ;
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}

				notificationClassObject->Release () ;
			}
			else
			{
				status = GetNotifyStatusObject ( notifyObject ) ;
			}
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}

	return status ;
}

BOOL SnmpClassGetEventObject :: ProcessCorrelatedClass ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	IWbemQualifierSet *classQualifierObject = NULL ;
	HRESULT result = m_classObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		LONG attributeType ;

		VARIANT variant ;
		VariantInit ( & variant ) ;

		result = classQualifierObject->Get ( 

			WBEM_QUALIFIER_GROUP_OBJECTID , 
			0,	
			&variant ,
			& attributeType 

		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( variant.vt == VT_BSTR ) 
			{
// Get Device Transport information

				SnmpObjectIdentifierType objectIdentifier ( variant.bstrVal ) ;						
				if ( objectIdentifier.IsValid () )
				{
					SnmpSession *session ;
					status = GetTransportInformation ( m_errorObject , session ) ;
					if ( status ) 
					{
#ifdef CORRELATOR_INIT
						m_correlator = new SnmpCorrelation ( *session , this ) ;
#else //CORRELATOR_INIT
						m_correlator = new SnmpCorrelation ( *session , this, m_Interrogator ) ;
#endif //CORRELATOR_INIT
						char *groupObjectId = UnicodeToDbcsString ( variant.bstrVal ) ;
						if ( groupObjectId )
						{
							m_inCallstack = TRUE ;
							m_correlator->Start ( groupObjectId ) ;	
							if ( m_inCallstack == FALSE )
								m_synchronousComplete = TRUE ;
							m_inCallstack = FALSE ;
							delete [] groupObjectId ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: group_objectid" ) ;
						}
					}

				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: group_objectid" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: group_objectid" ) ;
			}

			VariantClear ( & variant ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_errorObject.SetMessage ( L"Class must specify valid qualifier for: group_objectid" ) ;
		}

		classQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get Class qualifier set, must specify valid qualifier for: group_objectid" ) ;
	}

	return status ;
}

BOOL SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

// Get Class definition from SMIR

	IWbemClassObject *classObject = NULL ;
	HRESULT result = GetClass ( m_errorObject , &m_classObject , m_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
// Get Namespace object which contains Device Transport information/Also used for merge of class

		status = GetNamespaceObject ( a_errorObject ) ;
		if ( status ) 
		{
			if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPMACRO ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFYSTATUS ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFICATION ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPVARBIND ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else
			{
// Determine if I need to correlate

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				
				result = m_classObject->Get ( L"__SUPERCLASS" , 0 , & t_Variant , NULL , NULL ) ;

				BSTR t_Parent = t_Variant.bstrVal ;
				
				if ( SUCCEEDED ( result ) && (t_Variant.vt == VT_BSTR) && (t_Parent != NULL) && (*t_Parent != L'\0'))
				{
					if ( _wcsicmp ( t_Parent , WBEM_CLASS_SNMPNOTIFICATION ) == 0 || _wcsicmp ( t_Parent , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
					{
						ReceiveClass ( m_classObject ) ;
						m_synchronousComplete = TRUE ;
					}
					else if (_wcsicmp ( t_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0)
					{
						if ( m_correlate )
						{
							CImpClasProv :: s_defaultThreadObject->ScheduleTask ( *this ) ;

							this->Exec () ;

							this->Acknowledge () ;
						}
						else
						{
							ReceiveClass ( m_classObject ) ;
							m_synchronousComplete = TRUE ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
						a_errorObject.SetMessage ( L"This is not a supported SNMP class." ) ;
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
					a_errorObject.SetMessage ( L"Failed to get __SUPERCLASS property. This is not an SNMP base class." ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}
	}
	else
	{
		//no need to set an error msg etc 'cos GetClass does it.
		status = FALSE;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject (%lx))" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

void SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

	ReceiveClass ( m_classObject ) ;
	phGroup->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

}

SnmpClassGetAsyncEventObject :: SnmpClassGetAsyncEventObject ( 

	CImpClasProv *provider , 
	BSTR Class , 
	IWbemObjectSink *notify ,
	IWbemContext *a_Context

) : SnmpClassGetEventObject ( provider , Class , a_Context ) ,
	m_notificationHandler ( notify ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: SnmpClassGetAsyncEventObject ()" 
	) ;
)

	m_notificationHandler->AddRef () ;
}

SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()" 
	) ;
)

// Get Status object

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	m_notificationHandler->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()" 
	) ;
)

}

void SnmpClassGetAsyncEventObject :: Process ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: Process ()" 
	) ;
)

	switch ( m_State ) 
	{

		case 0:
		{
			m_State = 1 ;
			BOOL status = ProcessClass ( m_errorObject ) ;
			if ( status )
			{
				if ( m_synchronousComplete )
					ReceiveComplete () ;
			}
			else
			{
				ReceiveComplete () ;	
			}
		}
		break ;

		case 1:
		{
			Complete () ;
			WaitAcknowledgement () ;

			BOOL status = ProcessCorrelatedClass ( m_errorObject ) ;
			if ( status )
			{
				if ( m_synchronousComplete )
					ReceiveComplete () ;
			}
			else
			{
				ReceiveComplete () ;	
			}
		}
		break ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpClassGetAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject )" 
	) ;
)

	if ( ! m_Received )
	{
		m_Received = TRUE ;
		m_notificationHandler->Indicate ( 1 , & m_classObject ) ;
	}
}

void SnmpClassGetAsyncEventObject :: ReceiveComplete () 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
/*
 *	If no error specified yet then check for NOT_FOUND
 */

		if ( ! m_Received )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			m_errorObject.SetMessage ( L"Class not defined" ) ;
		}
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	CImpClasProv :: s_defaultThreadObject->ReapTask ( *this ) ;

	if ( ! m_inCallstack )
	{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

		delete this ;
	}
	else
		m_inCallstack = FALSE ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

}

void SnmpClassGetAsyncEventObject :: ReceiveError ( IN const SnmpErrorReport &a_errorReport )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ReceiveError ( IN const SnmpErrorReport &a_errorReport )"
	) ;
)

	switch ( a_errorReport.GetError () )
	{
		case Snmp_Error:
		{
			switch ( a_errorReport.GetStatus () )
			{
				case Snmp_No_Response:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"No Response from device" ) ;
				}
				break; 

				default:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
		}
		break ;
	}
}

SnmpClassEnumEventObject :: SnmpClassEnumEventObject ( 

	CImpClasProv *provider , 
	BSTR Parent ,
	ULONG flags ,
	IWbemContext *a_Context

) : SnmpClassEventObject ( provider , a_Context ) , m_Flags ( flags ) 
{
	m_Parent = UnicodeStringDuplicate ( Parent ) ;
}

BOOL SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class = (%s) )" ,
		a_Class
	) ;
)

	BOOL status = TRUE ;

// Get Class definition from SMIR

	IWbemClassObject *classObject = NULL ;
	HRESULT result = GetClass ( a_errorObject , &classObject , a_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
// Get Namespace object which contains Device Transport information/Also used for merge of class

		status = GetNamespaceObject ( a_errorObject ) ;
		if ( status ) 
		{
			ReceiveClass ( classObject ) ;
		}

		classObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
		a_errorObject.SetMessage ( L"Class not defined" ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class = (%s) )" ,
		a_Class
	) ;
)

	return status ;
}

SnmpClassEnumEventObject :: ~SnmpClassEnumEventObject ()
{
	delete [] m_Parent ;
}

BOOL SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
// Determine if I need to correlate

		if ( m_correlate )
		{
			CImpClasProv :: s_defaultThreadObject->ScheduleTask ( *this ) ;

			this->Exec () ;

/*`
 *	Wait for worker object to complete processing
 */

			this->Acknowledge () ;

		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Not Performing Class Correlation"
	) ;
)

			ReceiveGroup ( NULL ) ;
			m_synchronousComplete = TRUE ;
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return status ;
}

BOOL SnmpClassEnumEventObject :: GetCorrelatedEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetCorrelatedEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Performing Class Correlation"
	) ;
)

// Get Device Transport information
					
		SnmpSession *session ;
		BOOL status = GetTransportInformation ( m_errorObject , session ) ;
		if ( status ) 
		{
			m_inCallstack = TRUE ;
#ifdef CORRELATOR_INIT
			m_correlator = new SnmpCorrelation ( *session , this ) ;
#else //CORRELATOR_INIT
			m_correlator = new SnmpCorrelation ( *session , this, m_Interrogator ) ;
#endif //CORRELATOR_INIT
			m_correlator->Start ( NULL ) ;	
			if ( m_inCallstack == FALSE )
				m_synchronousComplete = TRUE ;
			m_inCallstack = FALSE ;
		}
		else
		{
		}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetCorrelatedEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return status ;
}

BOOL SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	HRESULT result = S_OK ;

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
		IWbemClassObject *classObject = NULL ;
		IEnumNotificationClass *enumClass = NULL ;
		ISmirNotificationClassHandle *classHandle = NULL ;

		result = m_Interrogator->EnumAllNotificationClasses (

			&enumClass
		) ;

		if ( SUCCEEDED ( result ) )
		{
			ULONG fetched = 0 ;
			enumClass->Reset () ;
			while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
			{
				result = classHandle->GetWBEMNotificationClass ( & classObject ) ;
				if ( SUCCEEDED ( result ) ) 
				{
					ReceiveClass ( classObject ) ;
					classObject->Release () ;
				}

				classHandle->Release () ;
			}

			enumClass->Release () ;
		}
		else
		{
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return SUCCEEDED ( result ) ;
}

BOOL SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	HRESULT result = S_OK ;

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
		IWbemClassObject *classObject = NULL ;
		IEnumExtNotificationClass *enumClass = NULL ;
		ISmirExtNotificationClassHandle *classHandle = NULL ;

		result = m_Interrogator->EnumAllExtNotificationClasses (

			&enumClass
		) ;

		if ( SUCCEEDED ( result ) )
		{
			ULONG fetched = 0 ;
			enumClass->Reset () ;
			while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
			{
				result = classHandle->GetWBEMExtNotificationClass ( & classObject ) ;
				if ( SUCCEEDED ( result ) ) 
				{
					ReceiveClass ( classObject ) ;
					classObject->Release () ;
				}

				classHandle->Release () ;
			}

			enumClass->Release () ;
		}
		else
		{
		}
	}
	
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return SUCCEEDED ( result ) ;
}

BOOL SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject (%s) )" ,
		m_Parent
	) ;
)

	BOOL status = TRUE ;

// Get Namespace object which contains Device Transport information/Also used for merge of class

	if ( m_Flags & WBEM_FLAG_SHALLOW )
	{
		if ( ( ! m_Parent ) || _wcsicmp ( m_Parent , WBEM_CLASS_NULL ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPMACRO ) ;
			status = status && ProcessClass ( a_errorObject , WBEM_CLASS_SNMPVARBIND ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPMACRO ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
		{
			status = GetEnumeration ( a_errorObject ) ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_NOTIFYSTATUS ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_EXTRINSICEVENT ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFICATION ) ;
			status = status & ProcessClass ( a_errorObject , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) ;

			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPNOTIFICATION ) == 0 )
		{
			status = GetNotificationEnumeration ( a_errorObject ) ;

			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
		{
			status = GetExtendedNotificationEnumeration ( a_errorObject ) ;

			m_synchronousComplete = TRUE ;
		}
		else
		{
// Get Class definition from SMIR

			IWbemClassObject *classObject = NULL ;
			HRESULT result = GetClass ( a_errorObject , &classObject , m_Parent ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				classObject->Release () ;

				m_synchronousComplete = TRUE ;
				status = TRUE ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_errorObject.SetMessage ( L"Parent class not known" ) ;

				m_synchronousComplete = TRUE ;
			}
		}
	}
	else
	{
		if ( ( ! m_Parent ) || _wcsicmp ( m_Parent , WBEM_CLASS_NULL ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPMACRO ) ;
			if ( status )
			{
				status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
				if ( status ) 
				{
					status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;
					if ( status ) 
					{
						status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPVARBIND ) ;
						if ( status )
						{
							status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFICATION ) ;
							if ( status ) 
							{
								status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) ;
								if ( status )
								{
									status = GetNotificationEnumeration ( a_errorObject ) ;
									if ( status ) 
									{
										status = GetExtendedNotificationEnumeration ( a_errorObject ) ;
										if ( status ) 
										{
											status = GetEnumeration ( a_errorObject ) ;
										}
									}
								}
							}
						}
					}					
				}
			}
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPMACRO ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
			if ( status ) 
			{
				status = GetEnumeration ( a_errorObject ) ;
			}
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
		{
			status = GetEnumeration ( a_errorObject ) ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_EXTRINSICEVENT ) == 0 )
		{
			status = GetNotificationEnumeration ( a_errorObject ) ;
			if ( status ) 
			{
				status = GetExtendedNotificationEnumeration ( a_errorObject ) ;
			}
			m_synchronousComplete = TRUE ;
		}
		else
		{
// Get Class definition from SMIR

			IWbemClassObject *classObject = NULL ;
			HRESULT result = GetClass ( a_errorObject , &classObject , m_Parent ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				classObject->Release () ;

				m_synchronousComplete = TRUE ;
				status = TRUE ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_errorObject.SetMessage ( L"Parent class not known" ) ;

				m_synchronousComplete = TRUE ;
			}
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject (%s))" ,
		m_Parent
	) ;
)

	return status ;
}

void SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )
{
DebugMacro1( 

	if ( phGroup )
	{
		BSTR t_ModuleName = NULL ;
		BSTR t_GroupOID = NULL ;

		phGroup->GetModuleName ( &t_ModuleName ) ;
		phGroup->GetGroupOID ( &t_GroupOID ) ;

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup = ((%s),(%s)) )" ,
			t_ModuleName ,
			t_GroupOID
		) ;

		SysFreeString ( t_ModuleName ) ;
		SysFreeString ( t_GroupOID ) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup = NULL )"
		) ;
	}
)

	HRESULT result = S_OK ;

	m_GroupsReceived ++ ;

	IWbemClassObject *classObject = NULL ;
	IEnumClass *enumClass = NULL ;
	ISmirClassHandle *classHandle = NULL ;

	if ( phGroup )
	{
		result = m_Interrogator->EnumClassesInGroup (

			&enumClass ,
			phGroup 
		) ;
	}
	else
	{
		result = m_Interrogator->EnumAllClasses (

			&enumClass 
		) ;
	}

	if ( SUCCEEDED ( result ) )
	{
		ULONG fetched = 0 ;
		enumClass->Reset () ;
		while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
		{
			result = classHandle->GetWBEMClass ( & classObject ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				ReceiveClass ( classObject ) ;
				classObject->Release () ;
			}

			classHandle->Release () ;
		}

		enumClass->Release () ;
	}
	else
	{
	}

	if ( phGroup )
	{
		phGroup->Release () ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

}

SnmpClassEnumAsyncEventObject :: SnmpClassEnumAsyncEventObject ( 

	CImpClasProv *provider , 
	BSTR Parent ,
	ULONG flags ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context

) : SnmpClassEnumEventObject ( provider , Parent , flags , a_Context ) ,
	m_notificationHandler ( notify )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: SnmpClassEnumAsyncEventObject ()" 
	) ;
)

	m_notificationHandler->AddRef () ;
}

SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{

// Get Status object

		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)
			HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	m_notificationHandler->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()" 
	) ;
)

}

void SnmpClassEnumAsyncEventObject :: Process ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: Process ()" 
	) ;
)

	switch ( m_State )
	{
		case 0:
		{
			m_State = 1 ;
		
			BOOL status = ProcessEnumeration ( m_errorObject ) ;
			if ( status )
			{
				if ( m_synchronousComplete )
					ReceiveComplete () ;
			}
			else
			{
				ReceiveComplete () ;	
			}
		}
		break ;

		case 1:
		{
			BOOL status = GetCorrelatedEnumeration ( m_errorObject ) ;
			if ( status )
			{
				if ( m_synchronousComplete )
					ReceiveComplete () ;
			}
			else
			{
				ReceiveComplete () ;	
			}
		}
		break ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpClassEnumAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveClass ()" 
	) ;
)

	m_notificationHandler->Indicate ( 1, & classObject ) ;
}

void SnmpClassEnumAsyncEventObject :: ReceiveError ( IN const SnmpErrorReport &errorReport )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveError ()" 
	) ;
)

	switch ( errorReport.GetError () )
	{
		case Snmp_Error:
		{
			switch ( errorReport.GetStatus () )
			{
				case Snmp_No_Response:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"No Response from device" ) ;
				}
				break; 

				default:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
		}
		break ;
	}
}

void SnmpClassEnumAsyncEventObject :: ReceiveComplete () 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
	}
	else
	{
		if ( m_GroupsReceived )
		{
			if ( FAILED ( m_errorObject.GetWbemStatus () ) ) 
			{
				if ( m_errorObject.GetStatus () == WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) 
				{
					m_errorObject.SetWbemStatus ( WBEM_S_TIMEDOUT ) ;
				}
			}
		}
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	CImpClasProv :: s_defaultThreadObject->ReapTask ( *this ) ;

	if ( ! m_inCallstack )
	{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

		delete this ;
	}
	else
		m_inCallstack = FALSE ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\dnf.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h> 
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <stdio.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <genlex.h>
#include <sql_1.h>
#include <tree.h>
#include "dnf.h"

SnmpOrNode :: ~SnmpOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

SnmpAndNode :: ~SnmpAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

SnmpNotNode :: ~SnmpNotNode ()
{
	delete m_Left ;
}

SnmpOperatorEqualNode :: ~SnmpOperatorEqualNode ()
{
	delete m_Left ;
}

SnmpOperatorNotEqualNode :: ~SnmpOperatorNotEqualNode ()
{
	delete m_Left ;
}

SnmpOperatorEqualOrGreaterNode :: ~SnmpOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

SnmpOperatorEqualOrLessNode :: ~SnmpOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

SnmpOperatorGreaterNode :: ~SnmpOperatorGreaterNode ()
{
	delete m_Left ;
}

SnmpOperatorLessNode :: ~SnmpOperatorLessNode ()
{
	delete m_Left ;
}

SnmpOperatorLikeNode :: ~SnmpOperatorLikeNode ()
{
	delete m_Left ;
}

SnmpOperatorNotLikeNode :: ~SnmpOperatorNotLikeNode ()
{
	delete m_Left ;
}

SnmpTreeNode *SnmpOrNode :: Copy () 
{
	void *t_DataCopy = m_Data ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	SnmpTreeNode *t_Node = new SnmpOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

SnmpTreeNode *SnmpAndNode :: Copy () 
{
	void *t_DataCopy = m_Data ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	SnmpTreeNode *t_Node = new SnmpAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

SnmpTreeNode *SnmpNotNode :: Copy () 
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpNotNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
} ;

SnmpTreeNode *SnmpOperatorEqualNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpOperatorNotEqualNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpOperatorEqualOrGreaterNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpOperatorEqualOrLessNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpOperatorGreaterNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpOperatorLessNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpOperatorLikeNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpOperatorNotLikeNode :: Copy ()
{
	SnmpTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpSignedIntegerNode :: Copy ()
{
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpUnsignedIntegerNode :: Copy ()
{
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpStringNode :: Copy ()
{
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpNullNode :: Copy ()
{
	SnmpTreeNode *t_Parent = m_Parent ;
	SnmpTreeNode *t_Node = new SnmpNullNode ( m_PropertyName , m_Index , t_Parent ) ;
	return t_Node ;
}

SnmpTreeNode *SnmpSignedIntegerRangeNode :: Copy ()
{
	SnmpTreeNode *t_Node = new SnmpSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;
	return t_Node ;
}

SnmpTreeNode *SnmpUnsignedIntegerRangeNode :: Copy ()
{
	SnmpTreeNode *t_Node = new SnmpUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;
	return t_Node ;
}

SnmpTreeNode *SnmpStringRangeNode :: Copy ()
{
	SnmpTreeNode *t_Node = new SnmpStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;
	return t_Node ;
}

SnmpTreeNode *SnmpNullRangeNode :: Copy ()
{
	SnmpTreeNode *t_Node = new SnmpNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;
	return t_Node ;
}

void SnmpOrNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" Or "
	) ;
)

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ) "
	) ;
)

}

void SnmpAndNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" And "
	) ;
)

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ) "
	) ;
)
}

void SnmpNotNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"Not"
	) ;
)

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ) "
	) ;
)
}

void SnmpOperatorEqualNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpOperatorLessNode :: Print () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpOperatorLikeNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void SnmpStringNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

void SnmpUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

void SnmpSignedIntegerNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}


void SnmpNullNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

void SnmpStringRangeNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

void SnmpUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

void SnmpSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}


void SnmpNullRangeNode :: Print ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareLessRangeNode ( 

	SnmpRangeNode *a_LeftRange ,
	SnmpRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( typeid ( *a_LeftRange ) == typeid ( SnmpStringRangeNode ) && typeid ( *a_RightRange ) == typeid ( SnmpStringRangeNode ) )
	{
		SnmpStringRangeNode *t_LeftString = ( SnmpStringRangeNode * ) a_LeftRange ;
		SnmpStringRangeNode *t_RightString = ( SnmpStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLess ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () 
		) ;
	}
	else if ( typeid ( *a_LeftRange ) == typeid ( SnmpSignedIntegerRangeNode ) && typeid ( *a_RightRange ) == typeid ( SnmpSignedIntegerRangeNode ) )
	{
		SnmpSignedIntegerRangeNode *t_LeftInteger = ( SnmpSignedIntegerRangeNode * ) a_LeftRange ;
		SnmpSignedIntegerRangeNode *t_RightInteger = ( SnmpSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () 
		) ;
	}
	else if ( typeid ( *a_LeftRange ) == typeid ( SnmpUnsignedIntegerRangeNode ) && typeid ( *a_RightRange ) == typeid ( SnmpUnsignedIntegerRangeNode ) )
	{
		SnmpUnsignedIntegerRangeNode *t_LeftInteger = ( SnmpUnsignedIntegerRangeNode * ) a_LeftRange ;
		SnmpUnsignedIntegerRangeNode *t_RightInteger = ( SnmpUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () 
		) ;
	}
	else if ( typeid ( *a_LeftRange ) == typeid ( SnmpNullRangeNode ) && typeid ( *a_RightRange ) == typeid ( SnmpNullRangeNode ) )
	{
		t_State = TRUE ;
	}
	else
	{
	}

	return t_State ;
}

BOOL SnmpUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	SnmpUnsignedIntegerRangeNode &a_UnsignedInteger ,
	SnmpUnsignedIntegerRangeNode *&a_Intersection 
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	BOOL t_Status = a_Intersection ? TRUE : FALSE ;
	return t_Status ;
}

BOOL SnmpSignedIntegerRangeNode :: GetIntersectingRange ( 

	SnmpSignedIntegerRangeNode &a_SignedInteger ,
	SnmpSignedIntegerRangeNode *&a_Intersection 
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	BOOL t_Status = a_Intersection ? TRUE : FALSE ;
	return t_Status ;
}

BOOL SnmpStringRangeNode :: GetIntersectingRange ( 

	SnmpStringRangeNode &a_String ,
	SnmpStringRangeNode *&a_Intersection 
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	BOOL t_Status = a_Intersection ? TRUE : FALSE ;
	return t_Status ;
}

BOOL SnmpSignedIntegerRangeNode :: GetNonIntersectingRange ( 

	SnmpSignedIntegerRangeNode &a_SignedInteger ,
	SnmpSignedIntegerRangeNode *&a_Before ,
	SnmpSignedIntegerRangeNode *&a_Intersection ,
	SnmpSignedIntegerRangeNode *&a_After
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

				a_Before = ( SnmpSignedIntegerRangeNode * ) ( this->Copy () ) ;
				a_After = ( SnmpSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( SnmpSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;
			a_After = ( SnmpSignedIntegerRangeNode * ) ( this->Copy () ) ;
		}
	}

	return TRUE ;
}


BOOL SnmpUnsignedIntegerRangeNode :: GetNonIntersectingRange ( 

	SnmpUnsignedIntegerRangeNode &a_UnsignedInteger ,
	SnmpUnsignedIntegerRangeNode *&a_Before ,
	SnmpUnsignedIntegerRangeNode *&a_Intersection ,
	SnmpUnsignedIntegerRangeNode *&a_After
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

				a_Before = ( SnmpUnsignedIntegerRangeNode * ) ( this->Copy () ) ;
				a_After = ( SnmpUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( SnmpUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;
			a_After = ( SnmpUnsignedIntegerRangeNode * ) ( this->Copy () ) ;
		}
	}

	return TRUE ;
}

BOOL SnmpStringRangeNode :: GetNonIntersectingRange ( 

	SnmpStringRangeNode &a_String ,
	SnmpStringRangeNode *&a_Before ,
	SnmpStringRangeNode *&a_Intersection ,
	SnmpStringRangeNode *&a_After
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

				a_Before = ( SnmpStringRangeNode * ) ( this->Copy () ) ;
				a_After = ( SnmpStringRangeNode * ) ( a_String.Copy () ) ;
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new SnmpStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( SnmpStringRangeNode * ) ( a_String.Copy () ) ;
			a_After = ( SnmpStringRangeNode * ) ( this->Copy () ) ;
		}
	}

	return TRUE ;
}

BOOL SnmpSignedIntegerRangeNode :: GetOverlappingRange ( 

	SnmpSignedIntegerRangeNode &a_SignedInteger ,
	SnmpSignedIntegerRangeNode *&a_Overlap
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE,
					Y_E_INFINITE  ,
					X_S_CLOSED ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE,
					X_S_CLOSED ,
					X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new SnmpSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	BOOL t_Status = a_Overlap ? TRUE : FALSE ;
	return t_Status ;
}

BOOL SnmpUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	SnmpUnsignedIntegerRangeNode &a_UnsignedInteger ,
	SnmpUnsignedIntegerRangeNode *&a_Overlap
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE,
					Y_E_INFINITE  ,
					X_S_CLOSED ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE,
					X_S_CLOSED ,
					X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new SnmpUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	BOOL t_Status = a_Overlap ? TRUE : FALSE ;
	return t_Status ;
}

BOOL SnmpStringRangeNode :: GetOverlappingRange ( 

	SnmpStringRangeNode &a_String ,
	SnmpStringRangeNode *&a_Overlap
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE,
					Y_E_INFINITE  ,
					X_S_CLOSED ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE,
					X_S_CLOSED ,
					X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new SnmpStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	BOOL t_Status = a_Overlap ? TRUE : FALSE ;
	return t_Status ;
}

SnmpRangeNode *SnmpOperatorEqualNode :: GetRange ()
{
	SnmpRangeNode *t_Range = NULL ;

	SnmpTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( SnmpNullNode ) )
		{
			SnmpNullNode *t_Null = ( SnmpNullNode * ) t_Value ;
			t_Range = new SnmpNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpUnsignedIntegerNode ) )
		{
			SnmpUnsignedIntegerNode *t_Integer = ( SnmpUnsignedIntegerNode * ) t_Value ;

			t_Range = new SnmpUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				FALSE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpSignedIntegerNode ) )
		{
			SnmpSignedIntegerNode *t_Integer = ( SnmpSignedIntegerNode * ) t_Value ;
			t_Range = new SnmpSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpStringNode ) )
		{
			SnmpStringNode *t_String = ( SnmpStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == SnmpValueNode :: SnmpValueFunction :: Function_None )
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

SnmpRangeNode *SnmpOperatorEqualOrGreaterNode :: GetRange ()
{
	SnmpRangeNode *t_Range = NULL ;

	SnmpTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( SnmpNullNode ) )
		{
			SnmpNullNode *t_Null = ( SnmpNullNode * ) t_Value ;
			t_Range = new SnmpNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpUnsignedIntegerNode ) )
		{
			SnmpUnsignedIntegerNode *t_Integer = ( SnmpUnsignedIntegerNode * ) t_Value ;

			t_Range = new SnmpUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpSignedIntegerNode ) )
		{
			SnmpSignedIntegerNode *t_Integer = ( SnmpSignedIntegerNode * ) t_Value ;
			t_Range = new SnmpSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpStringNode ) )
		{
			SnmpStringNode *t_String = ( SnmpStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == SnmpValueNode :: SnmpValueFunction :: Function_None )
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

SnmpRangeNode *SnmpOperatorEqualOrLessNode :: GetRange ()
{
	SnmpRangeNode *t_Range = NULL ;

	SnmpTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( SnmpNullNode ) )
		{
			SnmpNullNode *t_Null = ( SnmpNullNode * ) t_Value ;
			t_Range = new SnmpNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpUnsignedIntegerNode ) )
		{
			SnmpUnsignedIntegerNode *t_Integer = ( SnmpUnsignedIntegerNode * ) t_Value ;

			t_Range = new SnmpUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpSignedIntegerNode ) )
		{
			SnmpSignedIntegerNode *t_Integer = ( SnmpSignedIntegerNode * ) t_Value ;
			t_Range = new SnmpSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpStringNode ) )
		{
			SnmpStringNode *t_String = ( SnmpStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == SnmpValueNode :: SnmpValueFunction :: Function_None )
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

SnmpRangeNode *SnmpOperatorLessNode :: GetRange ()
{
	SnmpRangeNode *t_Range = NULL ;

	SnmpTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( SnmpNullNode ) )
		{
			SnmpNullNode *t_Null = ( SnmpNullNode * ) t_Value ;
			t_Range = new SnmpNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpUnsignedIntegerNode ) )
		{
			SnmpUnsignedIntegerNode *t_Integer = ( SnmpUnsignedIntegerNode * ) t_Value ;

			t_Range = new SnmpUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpSignedIntegerNode ) )
		{
			SnmpSignedIntegerNode *t_Integer = ( SnmpSignedIntegerNode * ) t_Value ;

			t_Range = new SnmpSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpStringNode ) )
		{
			SnmpStringNode *t_String = ( SnmpStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == SnmpValueNode :: SnmpValueFunction :: Function_None )
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

SnmpRangeNode *SnmpOperatorGreaterNode :: GetRange ()
{
	SnmpRangeNode *t_Range = NULL ;

	SnmpTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( SnmpNullNode ) )
		{
			SnmpNullNode *t_Null = ( SnmpNullNode * ) t_Value ;
			t_Range = new SnmpNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpUnsignedIntegerNode ) )
		{
			SnmpUnsignedIntegerNode *t_Integer = ( SnmpUnsignedIntegerNode * ) t_Value ;

			t_Range = new SnmpUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpSignedIntegerNode ) )
		{
			SnmpSignedIntegerNode *t_Integer = ( SnmpSignedIntegerNode * ) t_Value ;

			t_Range = new SnmpSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpStringNode ) )
		{
			SnmpStringNode *t_String = ( SnmpStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == SnmpValueNode :: SnmpValueFunction :: Function_None )
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

SnmpRangeNode *SnmpOperatorLikeNode :: GetRange ()
{
	SnmpRangeNode *t_Range = NULL ;

	SnmpTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( SnmpNullNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpUnsignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpSignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpStringNode ) )
		{
			SnmpStringNode *t_String = ( SnmpStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == SnmpValueNode :: SnmpValueFunction :: Function_None )
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

SnmpRangeNode *SnmpOperatorNotLikeNode :: GetRange ()
{
	SnmpRangeNode *t_Range = NULL ;

	SnmpTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( SnmpNullNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpUnsignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpSignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( SnmpStringNode ) )
		{
			SnmpStringNode *t_String = ( SnmpStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == SnmpValueNode :: SnmpValueFunction :: Function_None )
			{

				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new SnmpStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	SnmpTreeNode *a_Parent , 
	SnmpTreeNode **a_Node , 
	int &a_Index 
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = FALSE ;

	SQL_LEVEL_1_TOKEN *propertyValue = & ( a_Expression.pArrayOfTokens [ a_Index ] ) ;
	a_Index -- ;

	switch ( propertyValue->nTokenType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EXPRESSION:
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Operation = OP_EXPESSION"
	) ;
)

			SnmpTreeNode *t_ParentNode = a_Parent ;
			SnmpTreeNode **t_Node = a_Node ;
			SnmpTreeNode *t_OperatorNode = NULL ;

			switch ( propertyValue->nOperator )
			{
				case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
				{
					t_OperatorNode = new SnmpOperatorEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
				{
					t_OperatorNode = new SnmpOperatorNotEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
				{
					t_OperatorNode = new SnmpOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN: 
				{
					t_OperatorNode = new SnmpOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
				{
					t_OperatorNode = new SnmpOperatorLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
				{
					t_OperatorNode = new SnmpOperatorGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LIKE:
				{
					t_OperatorNode = new SnmpOperatorLikeNode ( NULL , t_ParentNode ) ;
				}
				break ;

				default:
				{
				}
				break ;
			}

			if ( t_OperatorNode )
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;
			}

			SnmpValueNode :: SnmpValueFunction t_PropertyFunction = SnmpValueNode :: SnmpValueFunction :: Function_None ;

			switch ( propertyValue->dwPropertyFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_PropertyFunction = SnmpValueNode :: SnmpValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_PropertyFunction = SnmpValueNode :: SnmpValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;

			}
			
			SnmpValueNode :: SnmpValueFunction t_ConstantFunction = SnmpValueNode :: SnmpValueFunction :: Function_None ;
			switch ( propertyValue->dwConstFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_ConstantFunction = SnmpValueNode :: SnmpValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_ConstantFunction = SnmpValueNode :: SnmpValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;
			}

			SnmpTreeNode *t_ValueNode = AllocTypeNode ( 

				propertyValue->pPropertyName , 
				propertyValue->vConstValue , 
				t_PropertyFunction ,
				t_ConstantFunction ,
				t_ParentNode 
			) ;

			if ( t_ValueNode )
			{
				*t_Node = t_ValueNode ;

				t_Status = TRUE ;
			}
			else
			{				
				t_Status = FALSE ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_AND:
		{
			*a_Node = new SnmpAndNode ( NULL , NULL , a_Parent ) ;
			SnmpTreeNode **t_Left = NULL ;
			SnmpTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_OR:
		{
			*a_Node = new SnmpOrNode ( NULL , NULL , a_Parent ) ;
			SnmpTreeNode **t_Left = NULL ;
			SnmpTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_NOT:
		{
			*a_Node = new SnmpNotNode ( NULL , a_Parent ) ;
			SnmpTreeNode **t_Left = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;

			t_Status = RecursiveEvaluate ( a_Expression , *a_Node , t_Left , a_Index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;

	return t_Status ;
}

BOOL QueryPreprocessor :: Evaluate ( 

	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	SnmpTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;
	if ( a_Expression.nNumTokens )
	{
		int t_Count = a_Expression.nNumTokens - 1 ;
		t_Status = RecursiveEvaluate ( a_Expression , NULL , a_Root , t_Count ) ;
	}
	else
	{
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"PostEvaluation Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

void QueryPreprocessor :: PrintTree ( SnmpTreeNode *a_Root )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Expression = "
	) ;
)

	if ( a_Root ) 
		a_Root->Print () ;
}

void QueryPreprocessor :: TransformAndOrExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_AndChild , 
	SnmpTreeNode *a_OrChild 
)
{
	SnmpTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	SnmpTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_AndChildCopy = a_AndChild->Copy () ;

	SnmpTreeNode *t_NewOrNode = new SnmpOrNode ( NULL , NULL , t_Parent ) ;
	SnmpTreeNode *t_NewOrNodeLeft = new SnmpAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
	SnmpTreeNode *t_NewOrNodeRight = new SnmpAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;

	t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
	t_NewOrNode->SetRight ( t_NewOrNodeRight) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_OrChild->SetLeft ( NULL ) ;
	a_OrChild->SetRight ( NULL ) ;
	a_OrChild->SetData ( NULL ) ;

	delete a_Node ;
	delete a_OrChild ;

	a_Node = t_NewOrNode ;
}

void QueryPreprocessor :: TransformNotNotExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	delete a_Node ;
	delete a_Child ;

	t_Leaf->SetParent ( t_Parent ) ;

	a_Node = t_Leaf ;
}

void QueryPreprocessor :: TransformNotAndExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	SnmpTreeNode *t_AndRightChild = a_Child->GetRight () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_NewOrNode = new SnmpOrNode ( NULL , NULL , t_Parent ) ;
	SnmpTreeNode *t_LeftNot = new SnmpNotNode ( t_AndLeftChild , t_NewOrNode ) ;
	SnmpTreeNode *t_RightNot= new SnmpNotNode ( t_AndRightChild , t_NewOrNode ) ;

	t_NewOrNode->SetLeft ( t_LeftNot ) ;
	t_NewOrNode->SetRight ( t_RightNot ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;
	delete a_Child ;

	a_Node = t_NewOrNode ;
}

void QueryPreprocessor :: TransformNotOrExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	SnmpTreeNode *t_OrRightChild = a_Child->GetRight () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_NewAndNode = new SnmpAndNode ( NULL , NULL , t_Parent ) ;
	SnmpTreeNode *t_LeftNot = new SnmpNotNode ( t_OrLeftChild , t_NewAndNode ) ;
	SnmpTreeNode *t_RightNot= new SnmpNotNode ( t_OrRightChild , t_NewAndNode ) ;

	t_NewAndNode->SetLeft ( t_LeftNot ) ;
	t_NewAndNode->SetRight ( t_RightNot ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;
	delete a_Child ;

	a_Node = t_NewAndNode ;

}

void QueryPreprocessor :: TransformNotEqualExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *a_CopyLessChild = a_Child->Copy () ;
	SnmpTreeNode *a_CopyGreaterChild = a_Child->Copy () ;

	SnmpTreeNode *t_NewOrNode = new SnmpOrNode ( NULL , NULL , t_Parent ) ;
	SnmpTreeNode *t_LessNode = new SnmpOperatorLessNode  ( a_CopyLessChild , t_NewOrNode ) ;
	SnmpTreeNode *t_GreatorNode = new SnmpOperatorGreaterNode  ( a_CopyGreaterChild , t_NewOrNode ) ;

	t_NewOrNode->SetLeft ( t_LessNode ) ;
	t_NewOrNode->SetRight ( t_GreatorNode ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	

	}

	delete a_Node ;

	a_Node = t_NewOrNode ;
}

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorNotEqualNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorEqualNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorEqualOrLessNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	

	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorEqualOrGreaterNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorEqualOrLessNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorEqualOrGreaterNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorNotLikeNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	

	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	SnmpTreeNode *t_Leaf = a_Child->GetLeft () ;
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	SnmpTreeNode *t_NewNode = new SnmpOperatorLikeNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;

}

BOOL QueryPreprocessor :: EvaluateNotExpression ( SnmpTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		SnmpTreeNode *t_Left = a_Node->GetLeft () ;
		if ( typeid ( *t_Left ) == typeid ( SnmpAndNode ) )
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOrNode ) )
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpNotNode ) )
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorEqualNode ) )
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorNotEqualNode ) )
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorEqualOrGreaterNode ) )
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorEqualOrLessNode ) )
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorLessNode ) )
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorGreaterNode ) )
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorLikeNode ) )
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOperatorNotLikeNode ) )
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else
		{
		}
	}

	return FALSE ;
}

BOOL QueryPreprocessor :: EvaluateNotEqualExpression ( SnmpTreeNode *&a_Node )
{
	SnmpTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return TRUE ;
}

BOOL QueryPreprocessor :: EvaluateAndExpression ( SnmpTreeNode *&a_Node )
{
	SnmpTreeNode *t_Left = a_Node->GetLeft () ;
	SnmpTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( typeid ( *t_Left ) == typeid ( SnmpAndNode ) )
		{
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpOrNode ) )
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( SnmpNotNode ) )
		{
		}
		else
		{
		}
	}

	if ( t_Right )
	{
		if ( typeid ( *t_Right ) == typeid ( SnmpAndNode ) )
		{
		}
		else if ( typeid ( *t_Right ) == typeid ( SnmpOrNode ) )
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Right ) == typeid ( SnmpNotNode ) )
		{
		}
		else
		{
		}
	}

	return FALSE ;
}

BOOL QueryPreprocessor :: EvaluateOrExpression ( SnmpTreeNode *&a_Node )
{
	return FALSE ;
}

BOOL QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( SnmpTreeNode *&a_Node )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			if ( EvaluateAndExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				SnmpTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}

				SnmpTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
			if ( EvaluateOrExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				SnmpTreeNode *t_Left = a_Node->GetLeft () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}

				}

				SnmpTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Right  )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpNotNode ) )
		{
			if ( EvaluateNotExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				SnmpTreeNode *t_Left = a_Node->GetLeft () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;

					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}

				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorNotEqualNode ) )
		{
			if ( EvaluateNotEqualExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				SnmpTreeNode *t_Left = a_Node->GetLeft () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;

					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}
			}
		}
		else
		{
		}
	}

	return t_Status ;
}

void QueryPreprocessor :: DisjunctiveNormalForm ( SnmpTreeNode *&a_Root ) 
{
	RecursiveDisjunctiveNormalForm ( a_Root ) ;
}

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	SnmpTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	SnmpTreeNode *&a_Node , 
	SnmpTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	SnmpTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

void QueryPreprocessor :: TransformOperatorToRange ( 

	SnmpTreeNode *&a_Node 
)
{
	SnmpTreeNode *t_Parent = a_Node->GetParent () ;

	SnmpOperatorNode *t_OperatorNode = ( SnmpOperatorNode * ) a_Node ;
	SnmpTreeNode *t_Range = t_OperatorNode->GetRange () ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Range ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Range) ;
		}	

	}

	t_Range->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = t_Range ;
}

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( SnmpTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			SnmpTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			SnmpTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorEqualNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorNotEqualNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorEqualOrGreaterNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorEqualOrLessNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorLessNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorGreaterNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorLikeNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorNotLikeNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants ( SnmpTreeNode *&a_Root )
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: RecursiveInsertNode ( SnmpTreeNode *&a_Node , SnmpTreeNode *&a_Insertion )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status == TRUE )
				{
					return t_Status ;
				}
			}

			SnmpTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status == TRUE )
				{
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else
		{
// Operator

			SnmpValueNode *t_CompareValue = ( SnmpValueNode * ) a_Node->GetLeft () ;
			SnmpValueNode *t_InsertionValue = ( SnmpValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				SnmpTreeNode *t_Parent = a_Node->GetParent () ;
				SnmpTreeNode *t_NewAndNode = new SnmpAndNode ( a_Insertion , a_Node , t_Parent ) ;
				a_Node->SetParent ( t_NewAndNode ) ;
				a_Insertion->SetParent ( t_NewAndNode ) ;

				if ( t_Parent )
				{
					if ( t_Parent->GetLeft () == a_Node )
					{
						t_Parent->SetLeft ( t_NewAndNode ) ;
					}
					else
					{
						t_Parent->SetRight ( t_NewAndNode ) ;
					}
				}
				else
				{
// Must have parent !!!!
				}

				a_Node = t_NewAndNode ;

				t_Status = TRUE ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;
		t_Status = TRUE ;
	}

	return t_Status ;
}

// Note, linear search to retain 'And', change later for logn search

BOOL QueryPreprocessor :: InsertNode ( SnmpTreeNode *&a_NewRoot , SnmpTreeNode *&a_Insertion )
{
	BOOL t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == FALSE )
	{
// Insert to right

		SnmpTreeNode *t_Parent = a_NewRoot->GetParent () ;
		SnmpTreeNode *t_NewAndNode = new SnmpAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		a_NewRoot->SetParent ( t_NewAndNode ) ;
		a_Insertion->SetParent ( t_NewAndNode ) ;

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_NewRoot )
			{
				t_Parent->SetLeft ( t_NewAndNode ) ;
			}
			else
			{
				t_Parent->SetRight ( t_NewAndNode ) ;
			}
		}
		else
		{
// Must have parent !!!!
		}

		a_NewRoot = t_NewAndNode ;
	}

	return TRUE ;
}

BOOL QueryPreprocessor :: RecursiveSortConditionals ( SnmpTreeNode *&a_NewRoot , SnmpTreeNode *&a_Node )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			SnmpTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else
		{
// Operator

			SnmpTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;

		}		
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: SortConditionals ( SnmpTreeNode *&a_Root )
{
	SnmpTreeNode *t_NewRoot = NULL ;
	BOOL t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

	SnmpTreeNode *t_Parent = a_Root->GetParent () ;
	if ( t_Parent ) 
	{
		if ( t_Parent->GetLeft () == a_Root )
		{
			t_Parent->SetLeft ( t_NewRoot ) ;
		}
		else
		{
			t_Parent->SetRight ( t_NewRoot ) ;
		}
	}

	t_NewRoot->SetParent ( t_Parent ) ;

	delete a_Root ;
	a_Root = t_NewRoot ;

	return t_Status ;
}

BOOL QueryPreprocessor :: RecursiveSort ( SnmpTreeNode *&a_Node )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			SnmpTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSort ( t_Right ) ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: Sort ( SnmpTreeNode *&a_Root )
{
	BOOL t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

BOOL QueryPreprocessor :: RecursiveConvertToRanges ( SnmpTreeNode *&a_Node )
{
	BOOL t_Status = TRUE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			SnmpTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			SnmpTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorEqualNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorEqualOrGreaterNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorEqualOrLessNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorLessNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorGreaterNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorLikeNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpOperatorNotLikeNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: ConvertToRanges ( SnmpTreeNode *&a_Root )
{
	BOOL t_Status = RecursiveConvertToRanges ( a_Root ) ;
	return t_Status ;
}

void QueryPreprocessor :: TransformIntersectingRange (

	SnmpTreeNode *&a_Node ,
	SnmpTreeNode *a_Compare ,
	SnmpTreeNode *a_Intersection
)
{
	SnmpTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}
	}

	delete a_Compare ;
}

void QueryPreprocessor :: TransformNonIntersectingRange (

	SnmpTreeNode *&a_Node ,
	SnmpTreeNode *a_Compare
) 
{
}

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( SnmpTreeNode *&a_Node , SnmpTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					SnmpTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			SnmpTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					SnmpTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					SnmpTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			SnmpTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					SnmpTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}

			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpNullRangeNode ) )
		{
			SnmpRangeNode *t_Node = ( SnmpRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				SnmpRangeNode *t_Range = ( SnmpRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( SnmpNullRangeNode ) )
					{
						SnmpTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;

					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpStringRangeNode ) )
		{
			SnmpStringRangeNode *t_Node = ( SnmpStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				SnmpRangeNode *t_Range = ( SnmpRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( SnmpStringRangeNode ) )
					{
						SnmpStringRangeNode *t_StringRange = ( SnmpStringRangeNode * ) t_Range ;

						SnmpStringRangeNode *t_Intersection = NULL ;
						BOOL t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						if ( t_Intersected )
						{
							TransformIntersectingRange (

								a_Node ,
								a_Compare ,
								t_Intersection
							) ;

							a_Compare = t_Intersection ;

							t_Status = QueryPreprocessor :: QuadState :: State_True ;
						}
						else
						{
							TransformNonIntersectingRange (

								a_Node ,
								a_Compare
							) ;

							a_Compare = NULL ;

							t_Status = QueryPreprocessor :: QuadState :: State_False ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpUnsignedIntegerRangeNode ) )
		{
			SnmpUnsignedIntegerRangeNode *t_Node = ( SnmpUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				SnmpRangeNode *t_Range = ( SnmpRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( SnmpUnsignedIntegerRangeNode ) )
					{
						SnmpUnsignedIntegerRangeNode *t_IntegerRange = ( SnmpUnsignedIntegerRangeNode * ) t_Range ;

						SnmpUnsignedIntegerRangeNode *t_Intersection = NULL ;
						BOOL t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						if ( t_Intersected )
						{
							TransformIntersectingRange (

								a_Node ,
								a_Compare ,
								t_Intersection
							) ;

							a_Compare = t_Intersection ;

							t_Status = QueryPreprocessor :: QuadState :: State_True ;
						}
						else
						{
							TransformNonIntersectingRange (

								a_Node ,
								a_Compare
							) ;

							a_Compare = NULL ;

							t_Status = QueryPreprocessor :: QuadState :: State_False ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpSignedIntegerRangeNode ) )
		{
			SnmpSignedIntegerRangeNode *t_Node = ( SnmpSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				SnmpRangeNode *t_Range = ( SnmpRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( SnmpSignedIntegerRangeNode ) )
					{
						SnmpSignedIntegerRangeNode *t_IntegerRange = ( SnmpSignedIntegerRangeNode * ) t_Range ;

						SnmpSignedIntegerRangeNode *t_Intersection = NULL ;
						BOOL t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						if ( t_Intersected )
						{
							TransformIntersectingRange (

								a_Node ,
								a_Compare ,
								t_Intersection
							) ;

							a_Compare = t_Intersection ;

							t_Status = QueryPreprocessor :: QuadState :: State_True ;

						}
						else
						{
							TransformNonIntersectingRange (

								a_Node ,
								a_Compare
							) ;

							a_Compare = NULL ;

							t_Status = QueryPreprocessor :: QuadState :: State_False ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}


QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( SnmpTreeNode *&a_Root )
{
	SnmpTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	
	}

	return t_Status ;
}

void QueryPreprocessor :: CountDisjunctions ( SnmpTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
			a_Count ++ ;

			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			SnmpTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}

void QueryPreprocessor :: CreateDisjunctions ( 

	SnmpTreeNode *a_Node , 
	Disjunctions *a_Disjunctions , 
	ULONG a_PropertiesToPartitionCount ,
	BSTR *a_PropertiesToPartition ,
	ULONG &a_DisjunctionIndex
) 
{
	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( SnmpOrNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CreateDisjunctions ( 

					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex 
				) ;
			}

			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( t_Disjunction->GetRange ( t_Index ) == NULL )
				{
					SnmpRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

						a_PropertiesToPartition [ t_Index ] 
					) ;

					t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
				}
			}

			a_DisjunctionIndex ++ ;

			SnmpTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right )
			{
				CreateDisjunctions ( 

					t_Right , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

			for ( t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( t_Disjunction->GetRange ( t_Index ) == NULL )
				{
					SnmpRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

						a_PropertiesToPartition [ t_Index ] 
					) ;

					t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( SnmpAndNode ) )
		{
			SnmpTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CreateDisjunctions ( 

					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			SnmpTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CreateDisjunctions ( 

					t_Right , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}
		}
		else
		{
			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;
			SnmpRangeNode *t_Node = ( SnmpRangeNode * ) a_Node ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;
			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( _wcsicmp ( t_PropertyName , a_PropertiesToPartition [ t_Index ] ) == 0 )
				{
					t_Disjunction->SetRange ( t_Index , ( SnmpRangeNode * ) t_Node->Copy () ) ;
					break ;
				}
			}			
		}
	}
}

BOOL QueryPreprocessor :: CreateDisjunctionContainer ( SnmpTreeNode *a_Root , Disjunctions *&a_Disjunctions )
{
	BOOL t_Status = TRUE ;

	ULONG t_PropertiesToPartitionCount = 0 ;
	BSTR *t_PropertiesToPartition = NULL ;

	GetPropertiesToPartition ( t_PropertiesToPartitionCount , t_PropertiesToPartition ) ;
	if ( t_PropertiesToPartitionCount )
	{
		ULONG t_Count = 1 ;
		CountDisjunctions ( a_Root , t_Count ) ;
		a_Disjunctions = new Disjunctions ( t_Count , t_PropertiesToPartitionCount ) ;

		t_Count = 0 ; 
		CreateDisjunctions ( 

			a_Root , 
			a_Disjunctions ,
			t_PropertiesToPartitionCount ,
			t_PropertiesToPartition ,
			t_Count
		) ;

/*
 *	Deallocate array
 */

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( 0 ) ;

		for ( ULONG t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
		{
			if ( t_Disjunction->GetRange ( t_Index ) == NULL )
			{
				SnmpRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

					t_PropertiesToPartition [ t_Index ] 
				) ;

				t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
			}
		}

		for ( t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
		{
			SysFreeString ( t_PropertiesToPartition [ t_Index ] ) ;
		}

		delete [] t_PropertiesToPartition ;
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG t_ConjunctionCount = a_Disjunctions->GetConjunctionCount () ;

	if ( a_KeyIndex < t_ConjunctionCount )
	{
		ULONG *t_OverlappingIndex = new ULONG [ t_DisjunctionCount ] ;
		ULONG *t_SortedDisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
		SnmpRangeNode **t_RangeTable = new SnmpRangeNode * [ t_DisjunctionCount ] ;

		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_OverlappingIndex [ t_Index ] = t_Index ;

			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
			t_RangeTable [ t_Index ] = ( SnmpRangeNode * ) ( t_Disjunction->GetRange ( a_KeyIndex )->Copy () ) ;
			t_SortedDisjunctionSetToTest [ t_Index ] = t_Index ;
		}

// Sort Partitions

		for ( ULONG t_OuterIndex = 0 ; t_OuterIndex < t_DisjunctionCount ; t_OuterIndex ++ )
		{
			for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < t_DisjunctionCount ; t_InnerIndex ++ )
			{
				if ( CompareLessRangeNode ( t_RangeTable [ t_InnerIndex ] , t_RangeTable [ t_OuterIndex ] ) == FALSE )
				{
					SnmpRangeNode *t_Range = t_RangeTable [ t_InnerIndex ] ;
					t_RangeTable [ t_InnerIndex ] = t_RangeTable [ t_OuterIndex ] ;
					t_RangeTable [ t_OuterIndex ] = t_Range ;

					ULONG t_Overlap = t_OverlappingIndex [ t_InnerIndex ] ;
					t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
					t_OverlappingIndex [ t_OuterIndex ] = t_Overlap ;

					ULONG t_ToTest = t_SortedDisjunctionSetToTest [ t_InnerIndex ] ;
					t_SortedDisjunctionSetToTest [ t_InnerIndex ] = t_SortedDisjunctionSetToTest [ t_OuterIndex ] ;
					t_SortedDisjunctionSetToTest [ t_OuterIndex ] = t_ToTest ;
				}	
			}
		}

		for ( t_OuterIndex = 0 ; t_OuterIndex < t_DisjunctionCount ; t_OuterIndex ++ )
		{
			for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < t_DisjunctionCount ; t_InnerIndex ++ )
			{
				ULONG t_OuterToTest = a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_OuterIndex ] ] ;
				ULONG t_InnerToTest = a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_InnerIndex ] ] ;

				if ( t_OuterToTest == t_InnerToTest )
				{
					if ( t_OverlappingIndex [ t_OuterIndex ] != t_OverlappingIndex [ t_InnerIndex ] )
					{
						SnmpRangeNode *t_LeftRange = t_RangeTable [ t_OuterIndex ] ;
						SnmpRangeNode *t_RightRange = t_RangeTable [ t_InnerIndex ] ;

						if ( t_LeftRange && t_RightRange )
						{
							if ( typeid ( *t_LeftRange ) == typeid ( SnmpStringRangeNode ) && typeid ( *t_RightRange ) == typeid ( SnmpStringRangeNode ) )
							{
								SnmpStringRangeNode *t_LeftString = ( SnmpStringRangeNode * ) t_LeftRange ;
								SnmpStringRangeNode *t_RightString = ( SnmpStringRangeNode * ) t_RightRange ;

								SnmpStringRangeNode *t_OverLap = NULL ;

								if ( t_LeftString->GetOverlappingRange ( *t_RightString, t_OverLap ) )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = t_OverLap ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = NULL ;
										
										t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
									}
									else
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = NULL ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = t_OverLap ;

										t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
									}
								}
								else
								{
								}
							}
							else if ( typeid ( *t_LeftRange ) == typeid ( SnmpSignedIntegerRangeNode ) && typeid ( *t_RightRange ) == typeid ( SnmpSignedIntegerRangeNode ) )
							{
								SnmpSignedIntegerRangeNode *t_LeftInteger = ( SnmpSignedIntegerRangeNode * ) t_LeftRange ;
								SnmpSignedIntegerRangeNode *t_RightInteger = ( SnmpSignedIntegerRangeNode * ) t_RightRange ;

								SnmpSignedIntegerRangeNode *t_OverLap = NULL ;

								if ( t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = t_OverLap ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = NULL ;

										t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
									}
									else
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = NULL ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = t_OverLap ;

										t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
									}
								}
								else
								{
								}
							}
							else if ( typeid ( *t_LeftRange ) == typeid ( SnmpUnsignedIntegerRangeNode ) && typeid ( *t_RightRange ) == typeid ( SnmpUnsignedIntegerRangeNode ) )
							{
								SnmpUnsignedIntegerRangeNode *t_LeftInteger = ( SnmpUnsignedIntegerRangeNode * ) t_LeftRange ;
								SnmpUnsignedIntegerRangeNode *t_RightInteger = ( SnmpUnsignedIntegerRangeNode * ) t_RightRange ;

								SnmpUnsignedIntegerRangeNode *t_OverLap = NULL ;

								if ( t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = t_OverLap ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = NULL ;

										t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
									}
									else
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = NULL ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = t_OverLap ;

										t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
									}
								}
								else
								{
								}
							}
							else if ( typeid ( *t_LeftRange ) == typeid ( SnmpNullRangeNode ) && typeid ( *t_RightRange ) == typeid ( SnmpNullRangeNode ) )
							{
								SnmpRangeNode *t_OverLap = ( SnmpRangeNode * ) t_LeftRange->Copy () ;

								if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
								{
									delete t_RangeTable [ t_OuterIndex ] ;
									t_RangeTable [ t_OuterIndex ] = t_OverLap ;

									delete t_RangeTable [ t_InnerIndex ] ;
									t_RangeTable [ t_InnerIndex ] = NULL ;

									t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
								}
								else
								{
									delete t_RangeTable [ t_OuterIndex ] ;
									t_RangeTable [ t_OuterIndex ] = NULL ;

									delete t_RangeTable [ t_InnerIndex ] ;
									t_RangeTable [ t_InnerIndex ] = t_OverLap ;

									t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
								}
							}
							else
							{
	// Failure
								t_Status = FALSE ;
							}
						}
					}
				}
			}
		}

		ULONG t_PartitionCount = 0 ;
		for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			if ( a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_Index ] ] && t_RangeTable [ t_Index ] )
			{
				t_PartitionCount ++ ;
			}
		}

		a_Partition->CreatePartitions ( t_PartitionCount ) ;

		ULONG t_PartitionIndex = 0 ;
		for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			SnmpRangeNode *t_Range = t_RangeTable [ t_Index ] ;
			if ( a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_Index ] ] && t_Range )
			{
				PartitionSet *t_Partition = new PartitionSet ;
				a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

				t_Partition->SetRange ( ( SnmpRangeNode * ) t_Range->Copy () ) ;
				t_Partition->SetKeyIndex ( a_KeyIndex ) ;
				t_PartitionIndex ++ ;
			}
		}

		ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;

		t_PartitionIndex = 0 ;
		for ( t_OuterIndex = 0 ; t_OuterIndex < t_DisjunctionCount ; t_OuterIndex ++ )
		{
			BOOL t_Found = FALSE ;

			for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
			{
				t_DisjunctionSetToTest [ t_Index ] = 0 ;
			}

			for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < t_DisjunctionCount ; t_InnerIndex ++ )
			{
				if ( a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_InnerIndex ] ] && ( t_OverlappingIndex [ t_InnerIndex ] == t_OuterIndex ) )
				{
					t_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_InnerIndex ] ] = 1 ;
					t_Found = TRUE ;
				}
			}

			if ( t_Found )
			{
				PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
				t_Status = RecursivePartitionSet (

					a_Disjunctions ,
					t_Partition ,
					t_DisjunctionCount ,
					t_DisjunctionSetToTest ,
					a_KeyIndex + 1
				) ;

				t_PartitionIndex ++ ;
			}
		}

		delete [] t_DisjunctionSetToTest ;

		for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			delete t_RangeTable [ t_Index ] ;
		}

		delete [] t_RangeTable ;
		delete [] t_OverlappingIndex ;
		delete [] t_SortedDisjunctionSetToTest ;
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	BOOL t_Status = FALSE ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
	{
		t_DisjunctionSetToTest [ t_Index ] = 1 ;
	}

	a_Partition = new PartitionSet ;

	t_Status = RecursivePartitionSet (

		a_Disjunctions ,
		a_Partition ,
		t_DisjunctionCount ,
		t_DisjunctionSetToTest ,
		0
	) ;

//

	delete [] t_DisjunctionSetToTest ;
	return t_Status;
}

QueryPreprocessor :: QuadState QueryPreprocessor :: Preprocess ( 

	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression ,
	PartitionSet *&a_Partition
)
{
	QuadState t_State = State_Error ;

	SnmpTreeNode *t_Root = NULL ;
	BOOL t_Status = Evaluate ( a_Expression , &t_Root ) ;
	if ( t_Status )
	{
		PrintTree ( t_Root ) ;

		DisjunctiveNormalForm ( t_Root ) ;

		PrintTree ( t_Root ) ;

		switch ( t_State = RemoveInvariants ( t_Root ) )
		{
			case QueryPreprocessor :: QuadState :: State_True:
			{		
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Expression = TRUE "
	) ;
)

			}
			break ;

			case QueryPreprocessor :: QuadState :: State_False:
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Expression = FALSE "
	) ;
)
			}
			break ;

			case QueryPreprocessor :: QuadState :: State_Undefined:
			{
				PrintTree ( t_Root ) ;
					
				Sort ( t_Root ) ;

				PrintTree ( t_Root ) ;

				ConvertToRanges ( t_Root ) ;

				PrintTree ( t_Root ) ;

				switch ( t_State = RemoveNonOverlappingRanges ( t_Root ) )
				{
					case QueryPreprocessor :: QuadState :: State_True:
					{		
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Expression = TRUE"
	) ;
)
					}
					break ;

					case QueryPreprocessor :: QuadState :: State_False:
					{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Expression = FALSE"
	) ;
)
					}
					break ;

					case QueryPreprocessor :: QuadState :: State_Undefined:
					{
						PrintTree ( t_Root ) ;

						Disjunctions *t_Disjunctions = NULL ;
						if ( CreateDisjunctionContainer ( t_Root , t_Disjunctions ) )
						{
							PartitionSet *t_Partition = NULL ;
							if ( CreatePartitionSet ( t_Disjunctions , t_Partition ) )
							{
								a_Partition = t_Partition ;
							}
							else
							{
								delete t_Partition ;
							}

							delete t_Disjunctions ;
						}
					}
					break ;

					case QueryPreprocessor :: QuadState :: State_ReEvaluate:
					{
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
			break ;

			case QueryPreprocessor :: QuadState :: State_ReEvaluate:
			{
			}
			break ;

			default:
			{
			}
			break ;
		}
	}
	else
	{
	}

	delete t_Root ;

	return t_State ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\evtencap.cpp ===
//***************************************************************************

//

//  EVTENCAP.CPP

//

//  Module: WBEM MS SNMP EVENT PROVIDER

//

//  Purpose: Contains the encapsulated mapping class

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <smir.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtencap.h>


CEncapMapper::CEncapMapper()
{
	m_WbemSnmpObj = NULL;
}


HRESULT CEncapMapper::GetSpecificPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	//all specific properties have one element, the property name...
	if ((lNumElements != 1) || (0 != aElements[0].m_nType))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue invalid parameters\r\n");
)
		return WBEM_E_FAILED;
	}

	BOOL bContinue = TRUE;

	if (NULL == m_WbemSnmpObj)
	{
		m_WbemSnmpObj = new WbemSnmpClassObject;
		IWbemClassObject *pObj = NULL;
		GetClassInstance(&pObj);

		if (NULL != pObj)
		{
			WbemSnmpErrorObject errorObj;

			if (!m_WbemSnmpObj->Set(errorObj, pObj))
			{
				bContinue = FALSE;
			}
		}
		else
		{
			bContinue = FALSE;
		}
	}

	if (bContinue)
	{
		WbemSnmpProperty *snmpProp = m_WbemSnmpObj->FindProperty(aElements[0].Element.m_wszPropertyName);

		if (NULL != snmpProp)
		{
			//set the property value using the snmp varbind
			//and get the property value and return TRUE...
			if (SetAndGetProperty(snmpProp, pvValue))
			{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue successful\r\n");
)
				return NOERROR;
			}
		}
	}
	else if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
		m_WbemSnmpObj = NULL;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue failed\r\n");
)

	return WBEM_E_FAILED;
}


CEncapMapper::~CEncapMapper()
{
	if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
	}
}


BOOL CEncapMapper::SetAndGetProperty(WbemSnmpProperty *wbemSnmpProp, VARIANT *pvValue)
{
	//Get the varbind qualifier value, set the keyvalues qualifier and set the
	//property value using the snmp varbind.
	//Get the property value and return TRUE;
	WbemSnmpQualifier *vbQual = wbemSnmpProp->FindQualifier(EVENT_VBINDEX_QUAL);

	if (NULL == vbQual)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty missing parameter's vbindex qualifier\r\n");
)
		return FALSE;
	}

	VARIANT v;
	VariantInit(&v);
	ULONG vbindex;

	//has to be at least 3, i.e. third vb, to be a specific property...
	if (!vbQual->GetValue(v) || (VT_I4 != v.vt) || (2 > v.lVal))
	{
		VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty invalid index qual\r\n");
)
		return FALSE;
	}

	if (v.lVal >= m_vbs.length)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty no value return TRUE\r\n");
)
		return TRUE;
	}

	vbindex = v.lVal - 1; //zero based in our array
	VariantClear(&v);

	if (m_vbs.vbs[vbindex].fDone)
	{
		//we've done this one already,
		//just get the property value and return it..
		CIMTYPE cimType;

		if (!wbemSnmpProp->GetValue(*pvValue, cimType))
		{
			pvValue->vt = VT_NULL;
		}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty return value\r\n");
)		
		return TRUE;
	}

	const SnmpObjectIdentifier& vb_OID = m_vbs.vbs[vbindex].pVarBind->GetInstance();
	WbemSnmpQualifier *oidQual = wbemSnmpProp->FindQualifier(WBEM_QUALIFIER_OBJECT_IDENTIFIER);
	BOOL bMatchedOID = FALSE;
	m_vbs.vbs[vbindex].fDone = TRUE;		

	if (NULL == oidQual)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty missing parameter's OID qualifier\r\n");
)
	}
	else
	{
		SnmpInstanceType *oid_valuetype = oidQual->GetValue () ;

		if ( typeid ( *oid_valuetype ) == typeid ( SnmpObjectIdentifierType ) )
		{
			SnmpObjectIdentifier oid_value = *(SnmpObjectIdentifier *) oid_valuetype->GetValueEncoding () ; 
			
			//compare without the instance info
			if (oid_value.GetValueLength() < vb_OID.GetValueLength())
			{
				SnmpObjectIdentifier* common = vb_OID.Cut(oid_value);

				if (NULL != common)
				{
					if ((*common) == oid_value)
					{
						bMatchedOID = TRUE;
					}

					delete common;
				}
			}
		}
		else
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty parameter's OID is of wrong type\r\n");
)
		}

	}

	if (wbemSnmpProp->SetValue(&(m_vbs.vbs[vbindex].pVarBind->GetValue())))
	{
		CIMTYPE cimType;

		if (wbemSnmpProp->GetValue(*pvValue, cimType))
		{
		}
	}
	else
	{
		bMatchedOID = FALSE;
	}

	if (!bMatchedOID)
	{
		WbemSnmpQualifier *qualifier = NULL ;
		wbemSnmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

		if ( qualifier = wbemSnmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
		{
			IWbemQualifierSet *t_QualifierSet = NULL;
			IWbemClassObject *pObj = NULL;
			GetClassInstance(&pObj);

			HRESULT result = pObj->GetPropertyQualifierSet ( wbemSnmpProp->GetName () , & t_QualifierSet ) ;

			if ( SUCCEEDED ( result ) )
			{
				SnmpIntegerType integer ( 1 , NULL ) ;
				qualifier->SetValue ( t_QualifierSet , integer ) ;
			}

			t_QualifierSet->Release () ;
		}
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty returning TRUE\r\n");
)
	return TRUE;
}

void CEncapMapper::GenerateInstance(IWbemClassObject** ppInst)
{
	if (NULL == ppInst)
	{
		//invalid out parameter
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance invalid parameter\r\n");
)
		return;
	}

	//set out parameter to NULL;
	*ppInst = NULL;
	IWbemClassObject *pObj = NULL;
	GetClassInstance(&pObj);

	if (NULL == pObj)
	{
		//failed to get class instance
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get class defn\r\n");
)
		return;
	}

	//get all the property names and set their values...
	SAFEARRAY* pPropNames;
	HRESULT result = pObj->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pPropNames);

	if (FAILED(result))
	{
		//failed to get the property names
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get parameter list\r\n");
)

		return;
	}
	
	//time to <insert expletive> around with a safearray...
	//work out the size of the safearray and access the data
	if(SafeArrayGetDim(pPropNames) != 1)
	{
		//wrong dimensions in this array
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance parameter array is WRONG!\r\n");
)
		return;
	}


	LONG arraylen = pPropNames->rgsabound[0].cElements;
	BSTR *pbstr;
	result = SafeArrayAccessData(pPropNames, (void **)&pbstr);

	if(FAILED(result))
	{
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to access parameter array\r\n");
)
		return;
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting properties\r\n");
)
	//iterate through the names and set the properties...
	for (LONG i = 0; i < arraylen; i++)
	{
		VARIANT v;
		MYWBEM_NAME_ELEMENT property_struct;
		property_struct.m_nType = 0; //string value
		property_struct.Element.m_wszPropertyName = pbstr[i];
		result = GetPropertyValue(1, &property_struct, 0, &v);

		if (FAILED(result))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get value for %s\r\n",
		pbstr[i]);
)
			continue;
		}
		
		if ((v.vt != VT_NULL) && (v.vt != VT_EMPTY))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting property %s\r\n",
		pbstr[i]);
)
			result = pObj->Put(pbstr[i], 0, &v, 0);
DebugMacro9( 
			if (FAILED(result))
			{
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting property %s\r\n",
		pbstr[i]);
			}
)
			
		}
		
		VariantClear(&v);
	}
	
	SafeArrayUnaccessData(pPropNames);
	SafeArrayDestroy(pPropNames);

	if (SUCCEEDED(result))
	{
		if (FAILED(pObj->Clone(ppInst)))
		{
			*ppInst = NULL;
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to clone result\r\n");
)
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance returning\r\n");
)
}


void CEncapMapper::ResetData()
{
	//do class specific stuff then call parent class's reset
	if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
		m_WbemSnmpObj = NULL;
	}

	CMapToEvent::ResetData();
}


BOOL CEncapMapper::GetSpecificClass()
{
	//Build path of mapper instance...
	CString path(MAPPER_CLASS_PATH_PREFIX);
	path += m_oid;
	path += '\"';
	BSTR pathstr = path.AllocSysString();
	IWbemClassObject *pObj = NULL;
	LPUNKNOWN pInterrogativeInt = NULL;

	HRESULT result = CoCreateInstance (CLSID_SMIR_Database,
					NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
					IID_ISMIR_Interrogative, (void**)&pInterrogativeInt);

	if ((result != S_OK) || (NULL == pInterrogativeInt))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass failed to connect to SMIR\r\n");
)
		return FALSE;
	}

	result = ((ISmirInterrogator*)pInterrogativeInt)->GetWBEMClass(&pObj, pathstr);
	pInterrogativeInt->Release();
	SysFreeString(pathstr);

	if (result == S_OK)
	{
		VARIANT v;
		VariantInit(&v);
		result = pObj->Get(MAPPER_CLASS_EVENTCLASSPROP, 0, &v, NULL, NULL);
		pObj->Release();
		
		if (SUCCEEDED(result) && (VT_BSTR == v.vt))
		{
			m_class = v.bstrVal;
			VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass got class defn\r\n");
)
			return TRUE;
		}
		else
		{
			VariantClear(&v);
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass failed to get class defn\r\n");
)

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\evtreft.cpp ===
//***************************************************************************

//

//  EVTREFT.CPP

//

//  Module: WBEM MS SNMP EVENT PROVIDER

//

//  Purpose: Contains the referent mapping class

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <smir.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtreft.h>


CReferentMapper::CReferentMapper()
{
}


CReferentMapper::~CReferentMapper()
{
}

HRESULT CReferentMapper::GetTypeAndIndexQuals(const wchar_t* prop, CIMTypeStruct& type, ULONG& index)
{
	IWbemClassObject* propObj = NULL;
	GetClassInstance(&propObj);

	if (NULL == propObj)
	{
		return WBEM_E_FAILED;
	}

	IWbemQualifierSet* pQuals = NULL;
	HRESULT result = propObj->GetPropertyQualifierSet((wchar_t*)prop, &pQuals);

	if (FAILED(result))
	{
		return result;
	}

	VARIANT v;
	result = pQuals->Get(EVENT_VBINDEX_QUAL, 0, &v, NULL);

	if (FAILED(result))
	{
		pQuals->Release();
		return result;
	}

	if (VT_I4 != v.vt)
	{
		VariantClear(&v);
		return WBEM_E_FAILED;
	}

	index = v.lVal;
	VariantClear(&v);
	result = pQuals->Get(EVENT_CIMTYPE_QUAL, 0, &v, NULL);
	pQuals->Release();

	if (FAILED(result))
	{
		return result;
	}

	if (VT_BSTR != v.vt)
	{
		VariantClear(&v);
		return WBEM_E_FAILED;
	}

#ifdef WHITESPACE_IN_CIMTYPE
	//Get rid of whitespace...
	CString cimtype;
	wchar_t* tmp = wcstok(v.bstrVal, WHITE_SPACE_CHARS);

	while (NULL != tmp)
	{
		cimtype += tmp;
		tmp = wcstok(NULL, WHITE_SPACE_CHARS);
	}
#else //WHITESPACE_IN_CIMTYPE
	CString cimtype = v.bstrVal;
#endif //WHITESPACE_IN_CIMTYPE

	VariantClear(&v);

	//determine if we're an object. If so get the classname...
	CString temp = cimtype.Left(OBJECT_STR_LEN);
	temp.MakeLower();

	if (temp == OBJECT_STR)
	{
		type.strType = cimtype.Mid(OBJECT_STR_LEN, cimtype.GetLength());
		type.fObject = TRUE;
	}
	else
	{
		type.fObject = FALSE;
	}

	return WBEM_NO_ERROR;
}

HRESULT CReferentMapper::GetSpecificPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	if ((lNumElements <= 0) || (NULL == aElements) || (NULL == pvValue))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invalid parms\r\n");
)

		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT status = WBEM_E_FAILED;

	//specific properties after first two varbinds
	if ((0 == aElements[0].m_nType) && (m_vbs.length > 2))
	{
		//first check it has the correct VBIndex and CIMType qualifiers...
		CIMTypeStruct proptype;
		ULONG propvbindex;

		if (FAILED(GetTypeAndIndexQuals(aElements[0].Element.m_wszPropertyName,
																	proptype, propvbindex)))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue failed to get index quals\r\n");
)
			return status;
		}

		if (propvbindex >= m_vbs.length)
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invalid index return TRUE\r\n");
)
			return WBEM_NO_ERROR;
		}

		//we're zero indexed in this world!
		propvbindex--;

		if (lNumElements == 1)
		{
			if (m_vbs.vbs[propvbindex].fDone)
			{
				//we've done this one already,
				//just get the property value and return it...
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue return value\r\n");
)
				return m_object->Get(aElements[0].Element.m_wszPropertyName, 0, pvValue, 0, 0);
			}

			if (proptype.fObject)
			{
				//get the embedded class object in full for the property asked for
				IWbemClassObject* pObj = NULL;
				if (SUCCEEDED(CreateEmbeddedProperty(&pObj, propvbindex,
								aElements[0].Element.m_wszPropertyName, proptype.strType)))
				{
					//created the property, set the variant value and return successfully
					//NOTE: as soon as the variant is cleared, the object will be released
					pvValue->vt = VT_UNKNOWN;
					pvValue->punkVal = pObj;
				}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue return value\r\n");
)
				return WBEM_NO_ERROR;
			}
			else
			{
				//MUST be an embedded property otherwise fail!
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invlaid params\r\n");
)
				return WBEM_E_FAILED;
			}
		}
#ifdef FILTERING

will not compile as there are still a couple of TO DOs left undone...

		else if (0 == aElements[1].m_nType)
		{
			if (lNumElements == 2)
			{
//TO DO:
//======
				//get a single property value of the embedded object
			}
			else if ((lNumElements == 3) && (1 == aElements[1].m_nType))
			{
//TO DO:
//======
				//only if we're an array property of the embedded object
			}
		}
#endif //FILTERING

	}

	return status;
}


HRESULT CReferentMapper::CreateEmbeddedProperty(IWbemClassObject** ppObj,
											ULONG index,
											const wchar_t* propertyName,
											const wchar_t* className)
{
	if (NULL == ppObj)
	{
		//invalid out parameter
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::CreateEmbeddedProperty invalid parameter\r\n");
)
		return WBEM_E_INVALID_PARAMETER;
	}

	IWbemClassObject* pClass = NULL;

	//specify no correlation to the class provider
	IWbemContext *pCtx = NULL;

	HRESULT result = CoCreateInstance(CLSID_WbemContext, NULL,
						CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						IID_IWbemContext, (void**)&pCtx);
	
	if (SUCCEEDED(result))
	{
		VARIANT vCtx;
		VariantInit (&vCtx);
		vCtx.vt = VT_BOOL;
		vCtx.boolVal = VARIANT_FALSE;
		result = pCtx->SetValue(WBEM_CLASS_CORRELATE_CONTEXT_PROP, 0, &vCtx);
		VariantClear(&vCtx);

		if (FAILED(result))
		{
			pCtx->Release();
			pCtx = NULL;
		}
	}
	else
	{
		pCtx = NULL;
	}

	result = m_nspace->GetObject((wchar_t*)className, 0, pCtx, &pClass, NULL);

	if (pCtx != NULL)
	{
		pCtx->Release();
	}

	if (FAILED(result))
	{
		return result;
	}

	result = pClass->SpawnInstance(0, ppObj);

	if (FAILED(result))
	{
		pClass->Release();
		return result;
	}

	//set the varbind as decoded and make sure the notification instance has been created...
	IWbemClassObject* ptmpObj = NULL;
	GetClassInstance(&ptmpObj);

	if (NULL == m_object)
	{
		pClass->Release();
		return WBEM_E_FAILED;
	}

	m_vbs.vbs[index].fDone = TRUE;
	WbemSnmpClassObject snmpObj;
	WbemSnmpErrorObject errorObj;

	if (!snmpObj.Set(errorObj, pClass))
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	snmpObj.SetIsClass(FALSE);
	snmpObj.ResetProperty () ;
	WbemSnmpProperty *snmpProp = snmpObj.NextProperty ();

	//set all properties to NULL...
	while (snmpProp != NULL)
	{
		snmpProp->SetValue(*ppObj, (SnmpValue*)NULL);
		snmpProp = snmpObj.NextProperty ();
	}

	snmpProp = snmpObj.FindProperty((wchar_t*)propertyName);

	if (NULL == snmpProp)
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	BOOL bSetKeyValue = FALSE;

	if (!snmpProp->SetValue(&(m_vbs.vbs[index].pVarBind->GetValue())))
	{
		snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

		if ( qualifier )
		{
			VARIANT tmp_V;
			VariantInit(&tmp_V);
			tmp_V.vt = VT_BOOL;
			tmp_V.boolVal = VARIANT_TRUE;
			qualifier->SetValue(tmp_V);
			VariantClear(&tmp_V);
		}
	}
	else
	{
		WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_KEY ) ;

		if ( qualifier )
		{
			VARIANT tmp_V;
			VariantInit(&tmp_V);
			
			if (qualifier->GetValue(tmp_V))
			{
				if ((tmp_V.vt = VT_BOOL) && (tmp_V.boolVal == VARIANT_TRUE))
				{
					bSetKeyValue = TRUE;
				}
			}

			VariantClear(&tmp_V);
		}
	}

	//have set the property, now set the key properties...
	//first get the instance info...
	const SnmpObjectIdentifier& id = m_vbs.vbs[index].pVarBind->GetInstance();
	IWbemQualifierSet* pQuals = NULL;
	result = pClass->GetPropertyQualifierSet((wchar_t*)propertyName, &pQuals);

	if (FAILED(result))
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	VARIANT v;
	result = pQuals->Get(OID_ATTRIBUTE, 0, &v, NULL);
	pQuals->Release();

	if ((FAILED(result)) || (VT_BSTR != v.vt))
	{
		pClass->Release();
		VariantClear(&v);
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	SnmpObjectIdentifierType propoidtype(v.bstrVal); 
	VariantClear(&v);

	if (!propoidtype.IsValid())
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	SnmpObjectIdentifier propoid(propoidtype.GetValue(), propoidtype.GetValueLength());
	SnmpObjectIdentifier* prefix = id.Cut(propoid);
	BOOL fsuccess = FALSE;
	SnmpObjectIdentifier* instinfo = new SnmpObjectIdentifier ( NULL , 0 ) ;

	if ((prefix != NULL) && (*prefix == propoid))
	{
		fsuccess = id.Suffix(propoid.GetValueLength(),*instinfo);
		
		if (instinfo->GetValue() == NULL)
		{
			fsuccess = FALSE;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier )
			{
				VARIANT tmp_V;
				VariantInit(&tmp_V);
				tmp_V.vt = VT_BOOL;
				tmp_V.boolVal = VARIANT_TRUE;
				qualifier->SetValue(tmp_V);
				VariantClear(&tmp_V);
			}
		}
	}

	if (prefix != NULL)
	{
		delete prefix;
	}

	if ( fsuccess )
	{
		if (snmpObj.IsKeyed())
		{
			snmpObj.ResetKeyProperty() ;
			
			while ( fsuccess && (snmpProp = snmpObj.NextKeyProperty()) )
			{
				//set all the key properties using the instance info...
				SnmpInstanceType *decodeValue = snmpProp->GetValue()->Copy();
				SnmpObjectIdentifier *decodedObject = new SnmpObjectIdentifier(decodeValue->Decode(*instinfo)) ;
				
				if (*decodeValue)
				{
					if (!snmpProp->SetValue(decodeValue))
					{
						fsuccess = FALSE;
					}
				}
				else
				{
					fsuccess = FALSE;
				}

				delete decodeValue ;
				delete instinfo ;
				instinfo = decodedObject ;
				snmpProp = snmpObj.NextKeyProperty();
			}

			if (fsuccess && instinfo->GetValueLength())
			{
				//instance info left after keys have been set
				fsuccess = FALSE;
			}
		}
		else
		{
			if ( (0 != *(instinfo->GetValue())) || (1 != instinfo->GetValueLength()) )
			{
				//invalid instance info for scalar...
				fsuccess = FALSE;
			}
		}
	}

	delete instinfo;
	pClass->Release();

	if (!fsuccess)
	{
		snmpObj.ResetKeyProperty () ;
		VARIANT tmp_V;
		VariantInit(&tmp_V);
		tmp_V.vt = VT_BOOL;
		tmp_V.boolVal = VARIANT_TRUE;

		while ( snmpProp = snmpObj.NextKeyProperty () )
		{
			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
			{
				qualifier->SetValue(tmp_V);
			}
			else
			{
				// Problem Here
			}
		}

		if (snmpProp = snmpObj.FindProperty((wchar_t*)propertyName))
		{
			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
			{
				qualifier->SetValue(tmp_V);
			}
			else
			{
				// Problem Here
			}
		}

		VariantClear(&tmp_V);
	}

	//check that setting the key values hasn't altered our value, it may be a key
	if ( bSetKeyValue && (snmpProp = snmpObj.FindProperty((wchar_t*)propertyName)) )
	{
		if (*(snmpProp->GetValue()->GetValueEncoding()) != m_vbs.vbs[index].pVarBind->GetValue())
		{
			//set it back to the varbind value and set the error qualifier on the property
			snmpProp->SetValue(&(m_vbs.vbs[index].pVarBind->GetValue()));

			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_VALUE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_VALUE_MISMATCH ) )
			{
				VARIANT tmp_V;
				VariantInit(&tmp_V);
				tmp_V.vt = VT_BOOL;
				tmp_V.boolVal = VARIANT_TRUE;
				qualifier->SetValue(tmp_V);
				VariantClear(&tmp_V);
			}
			else
			{
				// Problem Here
			}

		}
	}

	//generate class object from snmpObj and return success
	if (snmpObj.Get(errorObj, *ppObj))
	{
		//add the property to the notification object...
		VARIANT vObj;
		vObj.vt = VT_UNKNOWN;
		vObj.punkVal = *ppObj;
		(*ppObj)->AddRef();
		result = m_object->Put((wchar_t*)propertyName, 0, &vObj, 0);

		if (SUCCEEDED(result))
		{
			VariantClear(&vObj);
DebugMacro9( 
SnmpDebugLog :: s_SnmpDebugLog->Write (  
	__FILE__,__LINE__,
	L"CReferentMapper::CreateEmbeddedProperty succeeded\r\n");
)
			return WBEM_NO_ERROR;
		}
		else
		{
			VariantClear(&vObj);
			(*ppObj)->Release();
			*ppObj = NULL;
			return WBEM_E_FAILED;
		}
		
	}

	return WBEM_E_FAILED;
}


void CReferentMapper::GenerateInstance(IWbemClassObject** ppInst)
{
	if (NULL == ppInst)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance invalid parameter\r\n");
)

		//invalid out parameter
		return;
	}

	//set out parameter to NULL;
	*ppInst = NULL;
	IWbemClassObject *pObj = NULL;
	GetClassInstance(&pObj);

	if (NULL == pObj)
	{
		//failed to get class instance
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get class defn\r\n");
)
		return;
	}

	//get all the property names and set their values...
	SAFEARRAY* pPropNames;
	HRESULT result = pObj->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pPropNames);

	if (FAILED(result))
	{
		//failed to get the property names
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get property array\r\n");
)
		return;
	}
	
	//time to <insert expletive> around with a safearray...
	//work out the size of the safearray and access the data
	if(SafeArrayGetDim(pPropNames) != 1)
	{
		//wrong dimensions in this array
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance property array has wrong DIM\r\n");
)
		return;
	}


	LONG arraylen = pPropNames->rgsabound[0].cElements;
	BSTR *pbstr;
	result = SafeArrayAccessData(pPropNames, (void **)&pbstr);

	if(FAILED(result))
	{
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to access property array\r\n");
)
		return;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance set properties\r\n");
)

	//iterate through the names and set the properties...
	for (LONG i = 0; i < arraylen; i++)
	{
		VARIANT v;
		MYWBEM_NAME_ELEMENT property_struct;
		property_struct.m_nType = 0; //string value
		property_struct.Element.m_wszPropertyName = pbstr[i];
		result = GetPropertyValue(1, &property_struct, 0, &v);

		if (FAILED(result))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get value for %s\r\n",
		pbstr[i]);
)
			continue;
		}
		
		if ((v.vt != VT_NULL) && (v.vt != VT_EMPTY))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance setting value for %s\r\n",
		pbstr[i]);
)
			result = pObj->Put(pbstr[i], 0, &v, 0);
DebugMacro9( 
			if (FAILED(result))
			{
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed setting value for %s\r\n",
		pbstr[i]);
			}
)
		}
		
		VariantClear(&v);
	}
	
	SafeArrayUnaccessData(pPropNames);
	SafeArrayDestroy(pPropNames);

	if (SUCCEEDED(result))
	{
		if (FAILED(pObj->Clone(ppInst)))
		{
			*ppInst = NULL;
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to clone specific instance\r\n");
)
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance finished\r\n");
)
}


void CReferentMapper::ResetData()
{
	//do class specific stuff then call parent class's reset

	CMapToEvent::ResetData();
}


BOOL CReferentMapper::GetSpecificClass()
{
	//Build path of mapper instance...
	CString path(EXTMAPPER_CLASS_PATH_PREFIX);
	path += m_oid;
	path += '\"';
	BSTR pathstr = path.AllocSysString();
	IWbemClassObject *pObj = NULL;
	LPUNKNOWN pInterrogativeInt = NULL;

	HRESULT result = CoCreateInstance (CLSID_SMIR_Database,
					NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
					IID_ISMIR_Interrogative, (void**)&pInterrogativeInt);

	if ((result != S_OK) || (NULL == pInterrogativeInt))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificClass failed to get to SMIR\r\n");
)

		return FALSE;
	}

	result = ((ISmirInterrogator*)pInterrogativeInt)->GetWBEMClass(&pObj, pathstr);
	pInterrogativeInt->Release();
	SysFreeString(pathstr);

	if (result == S_OK)
	{
		VARIANT v;
		VariantInit(&v);
		result = pObj->Get(MAPPER_CLASS_EVENTCLASSPROP, 0, &v, NULL, NULL);
		pObj->Release();
		
		if (SUCCEEDED(result) && (VT_BSTR == v.vt))
		{
			m_class = v.bstrVal;
			VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificClass got the specific class defn\r\n");
)
			return TRUE;
		}
		else
		{
			VariantClear(&v);
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificClass failed to get specific class defn\r\n");
)
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\evtprov.cpp ===
//***************************************************************************

//

//  EVTPROV.CPP

//

//  Module: WBEM MS SNMP EVENT PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <classfac.h>
#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

STDMETHODIMP CTrapEventProvider::Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
				)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"Entering CTrapEventProvider::Initialize\n");
)

	m_pNamespace = pCIMOM;
	m_pNamespace->AddRef();
	pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 );
	

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
			L"Leaving CTrapEventProvider::Initialize with SUCCEEDED\n");
)

	return WBEM_NO_ERROR;
}


STDMETHODIMP CTrapEventProvider::ProvideEvents(IWbemObjectSink* pSink, LONG lFlags)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"Entering CTrapEventProvider::ProvideEvents\n");
)

	m_pEventSink = pSink;
	m_pEventSink->AddRef();
	
	if (!m_thrd->Register(this))
	{

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
			L"Leaving CTrapEventProvider::ProvideEvents with FAILED\n");
)

		return WBEM_E_FAILED;
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
			L"Leaving CNTEventProvider::ProvideEvents with SUCCEEDED\n");
)

	return WBEM_NO_ERROR;
}


CTrapEventProvider::~CTrapEventProvider()
{
	m_thrd->UnRegister(this);
}


CTrapEventProvider::CTrapEventProvider(DWORD mapperType, CEventProviderThread* thrd)
{
	m_thrd = thrd;
	m_MapType = mapperType;
	m_ref = 0;
}


IWbemServices* CTrapEventProvider::GetNamespace()
{
	m_pNamespace->AddRef();
	return m_pNamespace;
}

IWbemObjectSink* CTrapEventProvider::GetEventSink()
{
	m_pEventSink->AddRef();
	return m_pEventSink;
}
void CTrapEventProvider::ReleaseAll()
{
	//release dependencies
	m_pNamespace->Release();
	m_pEventSink->Release();

    if ( 0 != InterlockedDecrement(&m_ref) )
	{
        return;
	}

	delete this;
	InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	return;
}

void  CTrapEventProvider::AddRefAll()
{
	//addref dependencies
	m_pNamespace->AddRef();
	m_pEventSink->AddRef();

	InterlockedIncrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	InterlockedIncrement ( &m_ref ) ;
}

STDMETHODIMP_( ULONG ) CTrapEventProvider::AddRef()
{
	InterlockedIncrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	return InterlockedIncrement ( &m_ref ) ;
}

STDMETHODIMP_(ULONG) CTrapEventProvider::Release()
{
	long ret;

    if ( 0 != (ret = InterlockedDecrement(&m_ref)) )
	{
		InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
        return ret;
	}

	delete this;
	InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	return 0;
}

STDMETHODIMP CTrapEventProvider::QueryInterface(REFIID riid, PVOID* ppv)
{
	*ppv = NULL;

    if (IID_IUnknown == riid)
	{
        *ppv= (IWbemEventProvider*)this;
	}
	else if (IID_IWbemEventProvider == riid)
	{
        *ppv=(IWbemEventProvider*)this;
	}
	else if (IID_IWbemProviderInit == riid)
	{
        *ppv=(IWbemProviderInit*)this;
	}

    if (NULL==*ppv)
	{
		return E_NOINTERFACE;
	}

    //AddRef any interface we'll return.
    ((LPUNKNOWN)*ppv)->AddRef();	
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\evtmap.cpp ===
//***************************************************************************

//

//  EVTMAP.CPP

//

//  Module: WBEM MS SNMP EVENT PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>


CMapToEvent::CMapToEvent()
{
	m_vbdefn = NULL;
	m_btriedGeneric = FALSE;
	m_btryGeneric = FALSE;
	m_bCheckedVersion = FALSE;
	m_vbs.vbs = NULL;
	m_vbs.length = 0;
	m_object = NULL;
	m_nspace = NULL;
}

CMapToEvent::~CMapToEvent()
{
	if (m_vbs.vbs)
	{
		delete [] m_vbs.vbs;
	}

	if (m_vbdefn)
	{
		m_vbdefn->Release();
	}
}


void CMapToEvent::ResetData()
{
	m_btriedGeneric = FALSE;
	m_btryGeneric = FALSE;
	m_bCheckedVersion = FALSE;
	m_class.Empty();

	if(m_vbs.vbs)
	{
		delete [] m_vbs.vbs;
		m_vbs.vbs = NULL;
		m_vbs.length = 0;
	}

	if (m_object)
	{
		m_object->Release();
		m_object = NULL;
	}
}


void CMapToEvent::SetTryGeneric()
{
	m_btriedGeneric = TRUE;
	m_btryGeneric = TRUE;
}

BOOL CMapToEvent::IsSNMPv1()
{
	if (!m_bCheckedVersion)
	{
		m_bCheckedVersion = TRUE;
		m_bSNMPv1 = FALSE;

		//is v1 if the last varbind has objid = snmpTrapEnterprise.0
		//and the trapOID truncated by it last sub-id equals the last
		//varbind's value with a .0 appended.

		//Get the last varbind's oid and make sure it's the enterpriseOid
		const SnmpObjectIdentifier& id = m_vbs.vbs[m_vbs.length - 1].pVarBind->GetInstance();
		const SnmpValue& snmp_val = m_vbs.vbs[m_vbs.length - 1].pVarBind->GetValue();

		if ((id != SNMP_ENT_OID) || (typeid(SnmpObjectIdentifier) != typeid(snmp_val)))
		{
			return FALSE;
		}

		//create the trapoid and truncate the last subid
		SnmpObjectIdentifierType trapid(m_oid);
		SnmpObjectIdentifier trunctrapid(trapid.GetValue(), trapid.GetValueLength() - 1);
		
		//now add .0 to the value of the enterpriseOid
		ULONG val[1] = {0};
		SnmpObjectIdentifier zeroid(val, 1);
		SnmpObjectIdentifier extendoid((const SnmpObjectIdentifier&)snmp_val + zeroid);

		m_bSNMPv1 = (extendoid == trunctrapid);
	}

	return m_bSNMPv1;
}

void CMapToEvent::SetData(const char* sender_addr, const char* security_Context,
					const char* snmpTrapOid, const char* transport,
					SnmpVarBindList& vbList, IWbemServices* nspace)
{
	m_nspace = nspace;
	m_addr = sender_addr;
	m_ctxt = security_Context;
	m_oid = snmpTrapOid;
	m_transport = transport;
	UINT length = vbList.GetLength();

	if (length >= 2) //must have at least two varbinds!
	{
		m_vbs.vbs = new VarBindObjectStruct[length];
		m_vbs.length = length;
		vbList.Reset();
		
		for (UINT i=0; i < length; i++)
		{
			vbList.Next () ;
			m_vbs.vbs[i].fDone = FALSE;
			m_vbs.vbs[i].pVarBind = (SnmpVarBind*) vbList.Get();
		}
	}
	else
	{
		m_vbs.vbs = NULL;
		m_vbs.length = 0;
	}
}

void CMapToEvent::GetClassInstance(IWbemClassObject** ppObj)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance getting class object\r\n");
)

	if (m_object != NULL)
	{
		*ppObj = m_object;
		return;
	}

	if (m_class.IsEmpty())
	{
		if (!GetClass() || m_class.IsEmpty())
		{
			*ppObj = NULL;
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance failed to get class name\r\n");
)
			return;
		}
	}
	
	BSTR path = m_class.AllocSysString();

	if (SUCCEEDED(m_nspace->GetObject(path, 0, NULL, ppObj, NULL)))
	{
		if (FAILED((*ppObj)->SpawnInstance(0, &m_object)))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance failed to spawn instance\r\n");
)
			m_object = NULL;
		}
		else
		{
DebugMacro9(
		SnmpDebugLog :: s_SnmpDebugLog->Write (  
			__FILE__,__LINE__,
			L"CMapToEvent::GetClassInstance got instance\r\n");
)		
		}

		(*ppObj)->Release();
	}
	else
	{
DebugMacro9(
		SnmpDebugLog :: s_SnmpDebugLog->Write (  
			__FILE__,__LINE__,
			L"CMapToEvent::GetClassInstance failed to get class definition\r\n");
)		
	}

	SysFreeString(path);
	*ppObj = m_object;
}

HRESULT CMapToEvent::GetPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	VariantInit(pvValue);

	if ((lNumElements == 0) || (NULL == aElements) || (NULL == pvValue) || (pvValue->vt != VT_EMPTY))
	{
		return E_INVALIDARG;
	}

	if (m_vbs.length == 0)
	{
		return WBEM_E_FAILED;
	}

	//try the standard properties first
	HRESULT result = GetStandardProperty(lNumElements, aElements, lFlags, pvValue);

	if (SUCCEEDED(result))
	{
		return result;
	}

	if (m_class.IsEmpty())
	{
		if (!GetClass() || m_class.IsEmpty())
		{
			return WBEM_E_FAILED;
		}
	}

	if (TriedGeneric())
	{
		//if we are generic, check the varbind properties
		return GetVBProperty(lNumElements, aElements, lFlags, pvValue);
	}
	else
	{
		//else check the specific properties...
		return GetSpecificPropertyValue(lNumElements, aElements, lFlags, pvValue);
	}
	
	return WBEM_E_FAILED;
}


HRESULT CMapToEvent::GetStandardProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue)
{
	if ((lNumElements == 1) && (0 == aElements[0].m_nType)) //the property name!
	{
		if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, WBEMS_CLASS_PROP))
		{
			if (m_class.IsEmpty())
			{
				if (!GetClass() || m_class.IsEmpty())
				{
					return E_FAIL;
				}
			}
			
			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_class.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_SOID_PROP))
		{
			if (m_oid.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_oid.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_ADDR_PROP))
		{
			if (m_addr.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_addr.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TADDR_PROP))
		{
			if (m_addr.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_addr.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TRANS_PROP))
		{
			if (m_transport.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_transport.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_COMM_PROP))
		{
			if (m_ctxt.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_ctxt.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TIME_PROP))
		{
			const SnmpObjectIdentifier& id = m_vbs.vbs[0].pVarBind->GetInstance();

			if (id != SNMP_SYS_UP_OID)
			{
				return E_FAIL;
			}

			const SnmpValue& val = m_vbs.vbs[0].pVarBind->GetValue();

			if (typeid(SnmpTimeTicks) == typeid(val))
			{
				pvValue->vt = VT_I4;
				pvValue->lVal = ((const SnmpTimeTicks&)val).GetValue();
			}
			else
			{
				return E_FAIL;
			}
		}
		else
		{
			return E_FAIL;
		}
	}
	else
	{
		return E_FAIL; //no standard property has more than one element to its name
	}
				
	return S_OK; //got the property!
}

HRESULT CMapToEvent::GetVBProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue)
{
	if ((lNumElements <= 0) || (NULL == aElements) || (NULL == pvValue))
	{
		return E_INVALIDARG;
	}

	HRESULT status = E_FAIL;

	if ((0 == aElements[0].m_nType) && (m_vbs.length > 2) &&
		(0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_VBL_PROP)) ) 
	{
		//the property name is correct...

		if (lNumElements == 1)
		{
			//all the varbinds except 1 and 2...
			//create the classobjects stick 'em in a safearray and send 'em back!
			SAFEARRAYBOUND rgsabound[1];
			SAFEARRAY* psa;
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = m_vbs.length - 2;
			psa = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
			LONG ix;
			BOOL berror = FALSE;

			for (UINT i = 2; i < m_vbs.length; i++)
			{
				IWbemClassObject* vbobj = GetVBClassObjectByIndex(i);

				if (NULL != vbobj)
				{
					 ix = i-2;

					if ( S_OK != SafeArrayPutElement(psa, &ix, (IUnknown *)vbobj))
					{
						vbobj->Release ();
						berror = TRUE;
						break;
					}

					vbobj->Release ();
				}
				else
				{
					berror = TRUE;
					break;
				}
			}

			if (berror)
			{
				SafeArrayDestroy(psa);
			}
			else
			{
				status = WBEM_NO_ERROR;
				pvValue->vt = VT_ARRAY | VT_UNKNOWN;
				pvValue->parray = psa;
			}
		}
		else if ((1 == aElements[1].m_nType) && (m_vbs.length  > (aElements[1].Element.m_lArrayIndex + 2)))
		{
			if (lNumElements == 2)
			{
				//get the n(= aElements[1].Element.m_lArrayIndex + 2)th varbind
				//create a classobject with it and send back the class object
				IWbemClassObject* vbobj = GetVBClassObjectByIndex(aElements[1].Element.m_lArrayIndex + 2);
				
				if (NULL != vbobj)
				{
					status = WBEM_NO_ERROR;
					pvValue->vt = VT_UNKNOWN;
					pvValue->punkVal = (IUnknown*) vbobj;
				}
			}
			else if (0 == aElements[2].m_nType)
			{
				if (lNumElements == 3)
				{
					//get the single property value
					int cmpval = _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_OBJID_PROP2);

					if (0 == cmpval)
					{
						//get the objectid
						if (GetVBPropOIDByIndex((aElements[1].Element.m_lArrayIndex + 2), *pvValue))
						{
							status = WBEM_NO_ERROR;
						}

					}
					else if ((cmpval > 0) &&
						(0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_ENCODING_PROP1)))
					{
						//get the ASNType (Encoding < ObjectIdentifier)
						CString t;

						if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, *pvValue))
						{
							VariantClear(pvValue);
							status = WBEM_NO_ERROR;
							pvValue->vt = VT_BSTR;
							pvValue->bstrVal = t.AllocSysString();
						}
					}
					else if (0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_VALUE_PROP3))
					{
						//get the Value (Value < ObjectID)
						CString t;

						if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, *pvValue))
						{
							status = WBEM_NO_ERROR;
						}
					}
				}
				else if ((lNumElements == 4) && (1 == aElements[3].m_nType) &&
					(0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_VALUE_PROP3)) )
				{
					//get the byte value of Value[x]
					CString t;
					VARIANT v;

					if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, v))
					{
						if ((VT_ARRAY | VT_UI1) == v.vt)
						{
							LONG ix = aElements[3].Element.m_lArrayIndex;
							UCHAR datum;

							if (S_OK == SafeArrayGetElement(v.parray, &ix, (void*)&datum))
							{
								status = WBEM_NO_ERROR;
								pvValue->vt = VT_UI1;
								pvValue->bVal = datum;
							}
						}

						VariantClear(&v);
					}
				}
			}
		}
	}

	return status;
}

IWbemClassObject* CMapToEvent::GetVBClassDefn()
{
	if (NULL == m_vbdefn)
	{
		BSTR path = SysAllocString(VB_CLASS_PATH);
		m_nspace->GetObject(path, 0, NULL, &m_vbdefn, NULL);
		SysFreeString(path);
	}

	return m_vbdefn;
}

IWbemClassObject* CMapToEvent::GetVBClassObjectByIndex(UINT index)
{
	IWbemClassObject* ret = NULL;

	if (NULL != GetVBClassDefn())
	{
		if (SUCCEEDED(m_vbdefn->SpawnInstance(0, &ret)))
		{
			CString type;
			VARIANT vV;

			if (GetVBPropValueByIndex(index, type, vV))
			{
				BSTR asntypeprop = SysAllocString(VB_ENCODING_PROP1);
				VARIANT vT;
				vT.vt = VT_BSTR;
				vT.bstrVal = type.AllocSysString();

				//set the type and value.
				if (SUCCEEDED(ret->Put(asntypeprop, 0, &vT, 0)))
				{
					BSTR valueprop = SysAllocString(VB_VALUE_PROP3);
					VARIANT* pV = &vV;
					VARTYPE Vtype = 0;

					if ((VT_EMPTY == vV.vt) || (VT_EMPTY == vV.vt))
					{
						Vtype = VT_ARRAY|VT_UI1; //default type
						pV = NULL;
					}

					if (SUCCEEDED(ret->Put(valueprop, 0, pV, Vtype)))
					{
						VARIANT vID;

						//get the oid
						if(GetVBPropOIDByIndex(index, vID))
						{
							BSTR oidprop = SysAllocString(VB_OBJID_PROP2);

							//set the oid
							if (FAILED(ret->Put(oidprop, 0, &vID, 0)))
							{
								ret->Release();
								ret = NULL;
							}

							SysFreeString(oidprop);
							VariantClear(&vID);
						}
						else
						{
							ret->Release();
							ret = NULL;
						}
					}
					else
					{
						ret->Release();
						ret = NULL;
					}
					
					SysFreeString(valueprop);
				}
				else //failed to put the type property
				{
					ret->Release();
					ret = NULL;
				}

				VariantClear(&vT);
				SysFreeString(asntypeprop);
				VariantClear(&vV);
			}
			else //failed to SpawnInstance
			{
				ret->Release();
				ret = NULL;
			}
		}
	}

	return ret;
}


//index assumed to be in valid range
BOOL CMapToEvent::GetVBPropValueByIndex(UINT index, CString& type, VARIANT& vval)
{
	const SnmpValue& val = m_vbs.vbs[index].pVarBind->GetValue();
	
	//the data is an array of bytes...
	SAFEARRAYBOUND rgsabound[1];
	SAFEARRAY* psa;
	rgsabound[0].lLbound = 0;
	VariantInit(&vval);

	if (typeid(SnmpNull) == typeid(val))
	{
		type = ASN_NULL;
	}
	else if (typeid(SnmpNoSuchObject) == typeid(val))
	{
		type = ASN_NSO;
	}
	else if (typeid(SnmpNoSuchInstance) == typeid(val))
	{
		type = ASN_NSI;
	}
	else if (typeid(SnmpEndOfMibView) == typeid(val))
	{
		type = ASN_EOMV;
	}
	else if (typeid(SnmpInteger) == typeid(val))
	{
		type = ASN_INTEGER;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpInteger&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpGauge) == typeid(val))
	{
		type = ASN_GUAGE;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpGauge&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpCounter) == typeid(val))
	{
		type = ASN_COUNTER;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpCounter&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpTimeTicks) == typeid(val))
	{
		type = ASN_TIME;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpTimeTicks&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpOctetString) == typeid(val))
	{
		type = ASN_OCTET;
		UCHAR* pdata;
		UINT datalen = (((const SnmpOctetString&)val).GetValueLength()) * sizeof(UCHAR);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UCHAR* data = ((const SnmpOctetString&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpOpaque) == typeid(val))
	{
		type = ASN_OPAQUE;
		UCHAR* pdata;
		UINT datalen = (((const SnmpOpaque&)val).GetValueLength()) * sizeof(UCHAR);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UCHAR* data = ((const SnmpOpaque&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpObjectIdentifier) == typeid(val))
	{
		type = ASN_OID;
		UCHAR* pdata;
		UINT datalen = (((const SnmpObjectIdentifier&)val).GetValueLength()) * sizeof(ULONG);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		ULONG* data = ((const SnmpObjectIdentifier&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpIpAddress) == typeid(val))
	{
		type = ASN_ADDR;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpIpAddress&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpUInteger32) == typeid(val))
	{
		type = ASN_UINT32;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpUInteger32&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpCounter64) == typeid(val))
	{
		type = ASN_COUNTER64;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = (datalen * 2);
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpCounter64&)val).GetHighValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		pdata += datalen;
		data = ((const SnmpCounter64&)val).GetLowValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else
	{
		//should not get here!
		return FALSE;
	}

	return TRUE;
}


//index assumed to be in valid range
BOOL CMapToEvent::GetVBPropOIDByIndex(UINT index, VARIANT& vOid)
{
	const SnmpObjectIdentifier& id = m_vbs.vbs[index].pVarBind->GetInstance();
	char * oid = id.GetAllocatedString();

	if (NULL != oid)
	{
		VariantInit(&vOid);
		CString oidstr(oid);
		delete [] oid;
		vOid.vt = VT_BSTR;
		vOid.bstrVal = oidstr.AllocSysString();
		return TRUE;
	}

	return FALSE;
}


//sets the m_class variable. if btryGeneric is set gets the generic class.
//if m_btryGeneric is not set and a generic class is returned m_btriedGeneric
//must be set to true.
BOOL CMapToEvent::GetClass()
{
	if (!m_btryGeneric)
	{
		if (GetSpecificClass())
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass got specific class\r\n");
)
			return TRUE;
		}
	}

	SetTryGeneric();

	if (IsSNMPv1())
	{
		m_class = GetV1Class();
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass getting V1 class\r\n");
)
	}
	else
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass getting V2 class\r\n");
)
		m_class = GetV2Class();
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\evtthrd.cpp ===
//***************************************************************************

//

//  EVTHRD.CPP

//

//  Module: WBEM MS SNMP EVENT PROVIDER

//

//  Purpose: Contains the thread which listens for traps and processes

//				them.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <cominit.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtencap.h>
#include <evtreft.h>

extern CEventProviderWorkerThread* g_pWorkerThread;


CTrapListener::CTrapListener(CEventProviderThread* parentptr)
{
	m_pParent = parentptr;
	m_Ref = 1;
}


void CTrapListener::Destroy()
{
	if (InterlockedDecrement(&m_Ref) == 0)
	{
		DestroyReceiver();
	}
}


void CTrapListener::Receive (SnmpTransportAddress &sender_addr,
							SnmpSecurity &security_context,
							SnmpVarBindList &vbList)
{
	InterlockedIncrement(&m_Ref);
	MySnmpV1Security context((const SnmpV1Security&)security_context);
	const char *security = context.GetName();
	const char *addr = sender_addr.GetAddress();

	if ((NULL == security) || (NULL == addr))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid community or address\r\n");
)
		return;
	}

	const char* transport = NULL;

	if(typeid(SnmpTransportIpAddress) == typeid(sender_addr))
	{
		transport = "IP";
	}
	else if(typeid(SnmpTransportIpxAddress) == typeid(sender_addr))
	{
		transport = "IPX";
	}
	else
	{
		transport = "UNKNOWN";
	}

	char *oid = NULL;

	// reset the list
	vbList.Reset();
	UINT x = 0;

	// Get the SnmpTrapOid call process trap.
	vbList.Next(); //the timestamp
	vbList.Next(); //the snmpTrapOID
	const SnmpVarBind *var_bind = vbList.Get();
	const SnmpObjectIdentifier& id = var_bind->GetInstance();

	if (id != SNMP_TRAP_OID)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid trap oid varbind\r\n");
)
		return;
	}

	const SnmpValue& val = var_bind->GetValue();

	if(typeid(SnmpObjectIdentifier) == typeid(val))
	{
		oid = ((const SnmpObjectIdentifier&)val).GetAllocatedString();
	}

	if (NULL == oid)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid oid\r\n");
)
		return;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive trap to process\r\n");
)
	m_pParent->ProcessTrap(addr, security, oid, transport, vbList);
	delete [] oid;
	Destroy();
}

void CEventProviderThread::Initialise()
{
	InitializeCom();

	SnmpThreadObject :: Startup () ;
	SnmpDebugLog :: Startup () ;
	SnmpClassLibrary :: Startup () ;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		L"\r\n");

	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Initialise ()\r\n");
)

	m_Ear = NULL;
}


void CEventProviderThread::Uninitialise()
{
	if (NULL != m_Ear)
	{
		m_Ear->Destroy();
		m_Ear = NULL;
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Uninitialise ()\r\n");
)

	delete this;

	SnmpThreadObject :: Closedown () ;
	SnmpDebugLog :: Closedown () ;
	SnmpClassLibrary :: Closedown () ;

	CoUninitialize();
}


void CEventProviderThread::UnRegister(CTrapEventProvider* prov)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderThread::UnRegister\r\n");
)

	if (m_ControlObjects.Lock())
	{
		if (m_ControlObjects.RemoveKey((UINT)prov) 
			&& m_ControlObjects.IsEmpty() && (NULL != m_Ear))
		{
			m_Ear->Destroy();
			m_Ear = NULL;
		}
		
		m_ControlObjects.Unlock();
	}
}

BOOL CEventProviderThread::Register(CTrapEventProvider* prov)
{
	if (m_ControlObjects.Lock())
	{
		m_ControlObjects.SetAt((UINT)prov, prov);
		m_ControlObjects.Unlock();

		if (NULL == m_Ear)
		{
			m_Ear = new CTrapListener(this);
		}
	
		if (m_Ear->IsRegistered())
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Register returning TRUE\r\n");
)
			return TRUE;
		}
		else
		{
			delete m_Ear;
			m_Ear = NULL;
		}
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Register returning FALSE\r\n");
)
	
	return FALSE;
}

void CEventProviderThread::ProcessTrap(const char* sender_addr, const char* security_Context,
										const char* snmpTrapOid, const char* trnsp,
										SnmpVarBindList& vbList)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"Entering CEventProviderThread::ProcessTrap\r\n");
)

	CList<CTrapEventProvider*, CTrapEventProvider*> controlObjects;

	if (m_ControlObjects.Lock())
	{
		POSITION pos = m_ControlObjects.GetStartPosition();

		while (NULL != pos)
		{
			CTrapEventProvider* pCntrl;
			UINT key;
			m_ControlObjects.GetNextAssoc(pos, key, pCntrl);
			pCntrl->AddRefAll();
			controlObjects.AddTail(pCntrl);
		}

		m_ControlObjects.Unlock();
	}
	else
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderThread::ProcessTrap Failed to lock Control objects\r\n");
)

		return;
	}


	//loop through the different control objects to see if an event class
	//should be sent. if yes, then generate the event class. if generating
	//the specific class fails try the generic case.
	CTrapData *pTrapData = new CTrapData(sender_addr,  security_Context, snmpTrapOid, trnsp, vbList);
	pTrapData->AddRef();

	while (!controlObjects.IsEmpty())
	{
		CTrapEventProvider* pCntrl = controlObjects.RemoveTail();
		CTrapProcessTaskObject* asyncTrapTask = new CTrapProcessTaskObject(pTrapData, pCntrl);
		g_pWorkerThread->ScheduleTask(*asyncTrapTask);
		asyncTrapTask->Exec();
		asyncTrapTask->Acknowledge();
		pCntrl->ReleaseAll();
	}

	pTrapData->Release();

DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderThread::ProcessTrap done!\r\n");
)

}

CTrapData::CTrapData (const char* sender_addr,
					const char* security_Context,
					const char* snmpTrapOid,
					const char* trnsp,
					SnmpVarBindList& vbList
):m_variable_bindings(vbList), m_Ref(0)
{
	if (sender_addr)
	{
		m_sender_addr = new char[strlen(sender_addr) + 1];
		strcpy(m_sender_addr, sender_addr);
	}
	else
	{
		m_sender_addr = NULL;
	}

	if (security_Context)
	{
		m_security_context = new char[strlen(security_Context) + 1];
		strcpy(m_security_context, security_Context);
	}
	else
	{
		m_security_context = NULL;
	}

	if (snmpTrapOid)
	{
		m_trap_oid = new char[strlen(snmpTrapOid) + 1];
		strcpy(m_trap_oid, snmpTrapOid);
	}
	else
	{
		m_trap_oid = NULL;
	}

	if (trnsp)
	{
		m_transport = new char[strlen(trnsp) + 1];
		strcpy(m_transport, trnsp);
	}
	else
	{
		m_transport = NULL;
	}
}

CTrapData::~CTrapData()
{
	if (m_sender_addr)
	{
		delete [] m_sender_addr;
	}

	if (m_security_context)
	{
		delete [] m_security_context;
	}

	if (m_trap_oid)
	{
		delete [] m_trap_oid;
	}

	if (m_transport)
	{
		delete [] m_transport;
	}
}

LONG CTrapData::AddRef()
{
	return InterlockedIncrement ( &m_Ref ) ;
}

LONG CTrapData::Release()
{
	long ret;

    if ( 0 != (ret = InterlockedDecrement(&m_Ref)) )
	{
        return ret;
	}

	delete this;
	return 0;
}

CTrapProcessTaskObject::CTrapProcessTaskObject (CTrapData *pTData, CTrapEventProvider* pCntrl)
{
	if (pCntrl)
	{
		m_Cntrl = pCntrl;
		m_Cntrl->AddRefAll();
	}
	else
	{
		m_Cntrl = NULL;
	}

	if (pTData)
	{
		m_trap_data = pTData;
		m_trap_data->AddRef();
	}
	else
	{
		m_trap_data = NULL;
	}
}

CTrapProcessTaskObject::~CTrapProcessTaskObject()
{

	if (m_Cntrl)
	{
		m_Cntrl->ReleaseAll();
	}

	if (m_trap_data)
	{
		m_trap_data->Release();
	}

}

void CTrapProcessTaskObject::Process()
{
	IWbemServices* ns = m_Cntrl->GetNamespace();
	IWbemObjectSink* es = m_Cntrl->GetEventSink();

	CMapToEvent* mapper = NULL;

	if (m_Cntrl->m_MapType == CMapToEvent::EMappingType::ENCAPSULATED_MAPPER)
	{
		mapper = new CEncapMapper;
	}
	else //must be referent
	{
		mapper = new CReferentMapper;
	}

	mapper->SetData(m_trap_data->m_sender_addr, m_trap_data->m_security_context,
					m_trap_data->m_trap_oid, m_trap_data->m_transport, m_trap_data->m_variable_bindings, ns);

#ifdef FILTERING
		//is the specific filter set?
	if (SUCCEEDED(es->CheckObject(mapper, NULL, NULL)))
#endif //FILTERING

	{
		IWbemClassObject* Evt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating specific instance\r\n");
)
		mapper->GenerateInstance(&Evt);

		//only indicate if specific worked
		if (Evt != NULL) 
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating specific instance\r\n");
)

			es->Indicate(1, &Evt);
			Evt->Release();
		}
		else if (!mapper->TriedGeneric()) //have we tried the generic filter
		{
			mapper->ResetData();
			mapper->SetTryGeneric();
			mapper->SetData(m_trap_data->m_sender_addr, m_trap_data->m_security_context,
					m_trap_data->m_trap_oid, m_trap_data->m_transport, m_trap_data->m_variable_bindings, ns);

			//is the generic filter set?
#ifdef FILTERING
			if (SUCCEEDED(es->CheckObject(m_Map, NULL, NULL)))
#endif //FILTERING
			{
				IWbemClassObject* stdEvt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating general instance\r\n");
)
				mapper->GenerateInstance(&stdEvt);
				
				//if we generated the class indicate
				if (NULL != stdEvt)
				{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating general instance\r\n");
)
					es->Indicate(1, &stdEvt);
					stdEvt->Release();
				}
				else
				{
DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating generic instance failed\r\n");
)
				}
			}
		}
		else
		{
			//the specific case was the generic case
		}
	}
	
	mapper->ResetData();
	delete mapper;
	es->Release();
	ns->Release();

	g_pWorkerThread->ReapTask ( *this ) ;
	delete this ;
}

void CEventProviderWorkerThread::Initialise()
{
	InitializeCom();

	SnmpThreadObject :: Startup () ;
	SnmpDebugLog :: Startup () ;
	SnmpClassLibrary :: Startup () ;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		L"\r\n");

	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderWorkerThread::Initialise ()\r\n");
)

}


void CEventProviderWorkerThread::Uninitialise()
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		__FILE__,__LINE__,
		L"CEventProviderWorkerThread::Uninitialise ()\r\n");
)

	delete this;

	SnmpThreadObject :: Closedown () ;
	SnmpDebugLog :: Closedown () ;
	SnmpClassLibrary :: Closedown () ;

	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks.  

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>
#include <olectl.h>
#include <corafx.h>

#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include "classfac.h"
#include "clasprov.h"
#include "propprov.h"
#include "guids.h"
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>
#include <cormap.h>
#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

ISmirDatabase*		g_pNotifyInt = NULL;
CCorrCacheNotify*	gp_notify = NULL;
CCorrCacheWrapper*	g_CacheWrapper = NULL;
CCorrelatorMap*		g_Map = NULL;

//OK we need this one
HINSTANCE   g_hInst=NULL;

CEventProviderThread* g_pProvThrd = NULL;
CEventProviderWorkerThread* g_pWorkerThread = NULL;
CCriticalSection g_ProvLock;

CRITICAL_SECTION s_ProviderCriticalSection ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		DeleteCriticalSection ( & s_ProviderCriticalSection ) ;

		status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		InitializeCriticalSection ( & s_ProviderCriticalSection ) ;
		DisableThreadLibraryCalls(hInstance);			// 158024 
		status = TRUE ;
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }


    return TRUE ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_CClasProvClassFactory ) 
	{
		CClasProvClassFactory *lpunk = new CClasProvClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_CPropProvClassFactory ) 
	{
		CPropProvClassFactory *lpunk = new CPropProvClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_CSNMPReftEventProviderClassFactory ) 
	{
		CSNMPRefEventProviderClassFactory *lpunk = new CSNMPRefEventProviderClassFactory;

		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;

			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
		}
	}
	else if ( rclsid == CLSID_CSNMPEncapEventProviderClassFactory ) 
	{
		CSNMPEncapEventProviderClassFactory *lpunk = new CSNMPEncapEventProviderClassFactory;

		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;

			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
		}
	}
	else	
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}
	
	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	EnterCriticalSection ( & s_ProviderCriticalSection ) ;

	BOOL unload = (
					CClasProvClassFactory :: locksInProgress ||
					CClasProvClassFactory :: objectsInProgress ||
					CPropProvClassFactory :: locksInProgress ||
					CPropProvClassFactory :: objectsInProgress ||
					CSNMPEventProviderClassFactory :: locksInProgress ||
					CSNMPEventProviderClassFactory :: objectsInProgress 
					) ;

	unload = ! unload ;

	if ( unload )
	{
		if ( CImpClasProv :: s_defaultThreadObject )
		{
			CImpClasProv :: s_defaultThreadObject->SignalThreadShutdown() ;
			CImpClasProv :: s_defaultThreadObject = NULL ;

			CCorrelator :: TerminateCorrelator () ;

			SnmpClassLibrary :: Closedown () ;
			SnmpDebugLog :: Closedown () ;
			SnmpThreadObject :: Closedown () ;
		}

		if ( CImpPropProv :: s_defaultThreadObject )
		{
			CImpPropProv :: s_defaultThreadObject->SignalThreadShutdown() ;
			CImpPropProv :: s_defaultThreadObject = NULL ;
			CImpPropProv :: s_defaultPutThreadObject->SignalThreadShutdown() ;
			CImpPropProv :: s_defaultPutThreadObject = NULL ;


			SnmpClassLibrary :: Closedown () ;
			SnmpDebugLog :: Closedown () ;
			SnmpThreadObject :: Closedown () ;
		}

		if ( g_pProvThrd )
		{
			g_pProvThrd->SignalThreadShutdown();
			g_pProvThrd = NULL;
			g_pWorkerThread->SignalThreadShutdown();
			g_pWorkerThread = NULL;
		}

	}

	LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define PROGID_STR				L"ProgID"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define CLSID_STR				L"Software\\Classes\\CLSID\\"

#define CLASS_PROVIDER_NAME_STR			L"Microsoft WBEM SNMP Class Provider"
#define INSTANCE_PROVIDER_NAME_STR		L"Microsoft WBEM SNMP Instance Provider"
#define EVENT_PROVIDER_NAME_STR			L"Microsoft WBEM SNMP Event Provider"

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

	wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI RegisterServer( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI UnregisterServer( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

STDAPI DllRegisterServer()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( CLSID_CPropProvClassFactory , INSTANCE_PROVIDER_NAME_STR ) ;
	t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CClasProvClassFactory , CLASS_PROVIDER_NAME_STR  ) ;
	t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CSNMPReftEventProviderClassFactory , EVENT_PROVIDER_NAME_STR ) ;
	t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CSNMPEncapEventProviderClassFactory , EVENT_PROVIDER_NAME_STR ) ;

	return t_Result ;
}

STDAPI DllUnregisterServer(void)
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( CLSID_CPropProvClassFactory ) ;
	t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CClasProvClassFactory ) ;
	t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CSNMPReftEventProviderClassFactory ) ;
	t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CSNMPEncapEventProviderClassFactory ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\propdel.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS  Property Provider

//

//  Purpose: Implementation for the GetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

void DeleteInstanceAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	BOOL t_Status = TRUE ;

	if ( m_SnmpTooBig )
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Update Succeeded" 
	) ;
)
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	CImpPropProv :: s_defaultPutThreadObject->ReapTask ( *this ) ;

	SetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	delete this ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: ReceiveComplete ()" 
	) ;
)
}

void DeleteInstanceAsyncEventObject :: SnmpTooBig () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"DeleteInstanceAsyncEventObject :: SnmpTooBig ()" 
	) ;
)

	m_SnmpTooBig = TRUE ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: SnmpTooBig ()" 
	) ;
)
}

BOOL DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	IWbemClassObject *t_ClassObject = NULL ;
	IWbemCallResult *errorObject = NULL ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	variant.bstrVal = SysAllocString ( m_ObjectPath ) ;

	HRESULT result = provider->GetServer()->GetObject (

		variant.bstrVal ,
		0 ,
		m_Context ,
		& t_ClassObject ,
		& errorObject 
	) ;

	if ( errorObject )
		errorObject->Release () ;

	VariantClear ( & variant ) ;

	if ( SUCCEEDED ( result ) )
	{
		if ( status = GetNamespaceObject ( a_errorObject ) )
		{
			status = snmpObject.Set ( a_errorObject , t_ClassObject ) ;
			if ( status )
			{
				status = snmpObject.Check ( a_errorObject ) ;
				if ( status )
				{
					if ( ! snmpObject.RowStatusSpecified () )
					{
						WbemSnmpProperty *t_Property ;

						snmpObject.ResetProperty () ;
						while ( t_Property = snmpObject.NextProperty () )
						{
							if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
							{
								t_Property->SetTag ( FALSE ) ;
								SnmpRowStatusType *t_RowStatus = new SnmpRowStatusType ( SnmpRowStatusType :: SnmpRowStatusEnum :: destroy  ) ;
								t_Property->SetValue ( t_RowStatus ) ;
							}
						}

						status = SendSnmp ( m_errorObject , 0 ) ;
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Deletion of an instance requires the specification of a RowStatus class definition" ) ;

					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Merge : Class definition did not conform to mapping"
) ;
)
				}
			}
			else
			{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
			}
		}

		t_ClassObject->Release () ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject ) with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

BOOL DeleteInstanceAsyncEventObject :: DeleteInstance ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( t_Status )
	{
		t_Status = Delete ( a_ErrorObject ) ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

DeleteInstanceAsyncEventObject :: DeleteInstanceAsyncEventObject (

	CImpPropProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : SnmpSetResponseEventObject ( a_Provider , NULL , a_Ctx , 0 ) ,
	m_NotificationHandler ( a_NotificationHandler ) , 
	m_Class ( NULL ) ,
	m_State ( 0 )
{
	m_NotificationHandler->AddRef () ;
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

DeleteInstanceAsyncEventObject :: ~DeleteInstanceAsyncEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetSnmpNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
		else
		{
			HRESULT result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void DeleteInstanceAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	CImpPropProv:: s_defaultPutThreadObject->ReapTask ( *this ) ;

	delete this ;
}

void DeleteInstanceAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = DeleteInstance ( m_errorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\notify.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <notify.h>

#include <corstore.h>

extern CCorrCacheWrapper*	g_CacheWrapper;

CCorrCacheNotify::CCorrCacheNotify()
{
    m_cRef=0;
    m_dwCookie=0;
}

CCorrCacheNotify::~CCorrCacheNotify()
{
}

/*
 * CCorrCacheNotify::QueryInterface
 * CCorrCacheNotify::AddRef
 * CCorrCacheNotify::Release
 *
 * Purpose:
 *  Non-delegating IUnknown members for CCorrCacheNotify.
 */

STDMETHODIMP CCorrCacheNotify::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown == riid || IID_ISMIR_Notify == riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CCorrCacheNotify::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCorrCacheNotify::Release()
{
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP CCorrCacheNotify::ChangeNotify()
{
	(g_CacheWrapper->GetCache())->InvalidateCache();
	CCorrCache* cache = new CCorrCache();
	g_CacheWrapper->SetCache(cache);
	g_CacheWrapper->ReleaseCache();
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\propinst.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <tree.h>
#include "dnf.h"
#include "propprov.h"
#include "propsnmp.h"
#include "propinst.h"
#include "snmpnext.h"

SnmpClassObject :: SnmpClassObject ( 

	const SnmpClassObject & snmpClassObject 

) : WbemSnmpClassObject ( snmpClassObject ) , 
	snmpVersion ( snmpClassObject.snmpVersion ) , 
	m_accessible ( snmpClassObject.m_accessible )
{
}

SnmpClassObject :: SnmpClassObject () : snmpVersion ( 1 ) , m_accessible ( FALSE )
{
}

SnmpClassObject :: ~SnmpClassObject ()
{
}

SnmpResponseEventObject :: SnmpResponseEventObject ( 

	CImpPropProv *providerArg ,
	IWbemContext *a_Context 

) : provider ( providerArg ) , m_namespaceObject ( NULL ) , m_Context ( a_Context ) , m_ReferenceCount ( 1 )
{
	if ( m_Context ) 
	{
		m_Context->AddRef () ;

		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Variant.vt = VT_BOOL ;
		t_Variant.boolVal = VARIANT_FALSE ;
		m_Context->SetValue ( WBEM_CLASS_CORRELATE_CONTEXT_PROP , 0 , &t_Variant ) ;

		VariantClear ( &t_Variant ) ;
	}

	if ( provider )
		provider->AddRef () ;
}

SnmpResponseEventObject :: ~SnmpResponseEventObject ()
{
	if ( m_Context )
		m_Context->Release () ;

	if ( provider )
		provider->Release () ;

	if ( m_namespaceObject )
		m_namespaceObject->Release () ;
}

BOOL SnmpResponseEventObject :: HasNonNullKeys ( IWbemClassObject *a_Obj ) 
{
	HRESULT hr = a_Obj->BeginEnumeration ( WBEM_FLAG_KEYS_ONLY ) ;

	if ( SUCCEEDED ( hr ) )
	{
		VARIANT t_vVal ;
		VariantInit ( &t_vVal ) ;

		//returns WBEM_S_NO_ERROR or WBEM_S_NO_MORE_DATA on success
		hr = a_Obj->Next( 0, NULL, &t_vVal, NULL, NULL ) ;

		while ( hr == WBEM_S_NO_ERROR )
		{
			if ( t_vVal.vt == VT_NULL )
			{
				hr = WBEM_E_FAILED ;
			}

			VariantClear ( &t_vVal ) ;
			VariantInit ( &t_vVal ) ;
			
			if ( hr != WBEM_E_FAILED )
			{
				hr = a_Obj->Next( 0, NULL, &t_vVal, NULL, NULL ) ;
			}
		}

		VariantClear ( &t_vVal ) ;
		a_Obj->EndEnumeration () ;
	}

	return SUCCEEDED ( hr ) ;
}

ULONG SnmpResponseEventObject::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

ULONG SnmpResponseEventObject::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

BOOL SnmpResponseEventObject :: GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	IWbemServices *t_Server = provider->GetServer () ;

	IWbemCallResult *errorObject = NULL ;
	HRESULT result = t_Server->GetObject ( 

		WBEM_SNMP_TRANSPORTCONTEXT_OBJECT ,
		0  ,
		m_Context ,
		&m_namespaceObject ,
		&errorObject 
	) ;

	if ( SUCCEEDED ( result ) )
	{
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to obtain namespace object" ) ;
	}

	t_Server->Release () ;

	if ( errorObject )
		errorObject->Release () ;

	return status ;
}

BOOL SnmpResponseEventObject  :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = provider->GetSnmpNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			VariantClear ( &variant ) ;

			if ( SUCCEEDED ( result ) )
			{
				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( m_errorObject.GetMessage () ) 
					{
						variant.vt = VT_BSTR ;
						variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

						result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
						VariantClear ( &variant ) ;

						if ( ! SUCCEEDED ( result ) )
						{
							(*notifyObject)->Release () ;
							status = GetNotifyStatusObject ( notifyObject ) ;
						}
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				status = GetNotifyStatusObject ( notifyObject ) ;
			}

			notificationClassObject->Release () ;
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}
	else
	{
		status = GetNotifyStatusObject ( notifyObject ) ;
	}

	return status ;
}

BOOL SnmpResponseEventObject  :: GetNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = provider->GetNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			if ( SUCCEEDED ( result ) )
			{
				if ( m_errorObject.GetMessage () ) 
				{
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( ! SUCCEEDED ( result ) )
					{
						status = FALSE ;
						(*notifyObject)->Release () ;
						(*notifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				(*notifyObject)=NULL ;
				status = FALSE ;
			}

			VariantClear ( &variant ) ;

			notificationClassObject->Release () ;
		}
		else
		{
			status = FALSE ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentTransport ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentTransport 
)
{
	BOOL status = TRUE ;
	agentTransport = NULL ;
	BSTR t_Transport = NULL ;
	wchar_t *t_QualifierTransport = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTTRANSPORT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT , 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
		else
		{
			t_Transport = WBEM_AGENTIPTRANSPORT ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Transport , WBEM_AGENTIPTRANSPORT ) == 0 ) || ( _wcsicmp ( t_Transport , WBEM_AGENTIPXTRANSPORT ) == 0 ) )
		{
			agentTransport = UnicodeStringDuplicate ( t_Transport ) ;
		}
		else
		{
/*
*	Transport type != IP || != IPX
*/
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
		}

	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierTransport ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentTransport ( %s ) " , agentTransport 
	) ;
)

	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentVersion ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentVersion 
)
{
	BOOL status = TRUE ;
	agentVersion = NULL ;
	BSTR t_Version = NULL ;
	wchar_t *t_QualifierVersion = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTSNMPVERSION , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
	}

	if ( status & ! t_Version )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTSNMPVERSION  , 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
		else
		{
			t_Version = WBEM_AGENTSNMPVERSION_V1 ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V1 ) == 0 ) || ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V2C ) == 0 ) )
		{
			agentVersion = UnicodeStringDuplicate ( t_Version ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
		}
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierVersion ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentVersion ( %s ) " , agentVersion 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentAddress ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentAddress 
)
{
	BOOL status = TRUE ;
	agentAddress = NULL ;
	BSTR t_Address = NULL ;
	wchar_t *t_QualifierAddress = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTADDRESS , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTADDRESS, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Namespace must specify valid qualifier for: AgentAddress" ) ;
		}
	}

	if ( status )
	{
		agentAddress = UnicodeStringDuplicate ( t_Address ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierAddress ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentAddress ( %s ) " , agentAddress 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentReadCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentReadCommunityName 
)
{
	BOOL status = TRUE ;
	agentReadCommunityName = NULL ;
	BSTR t_Community = NULL ;
	wchar_t *t_QualifierCommunity = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentReadCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierCommunity ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentReadCommunityName ( %s ) " , agentReadCommunityName 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentWriteCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	wchar_t *&agentWriteCommunityName 
)
{
	BOOL status = TRUE ;
	agentWriteCommunityName = NULL ;
	BSTR t_Community = NULL ;
	wchar_t *t_QualifierCommunity = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentWriteCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierCommunity ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentWriteCommunityName ( %s ) " , agentWriteCommunityName 
	) ;
)
	}

	return status ;
}


BOOL SnmpResponseEventObject :: GetAgentRetryCount ( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentRetryCount 
)
{
	BOOL status = TRUE ;
	agentRetryCount = 1 ;
	BOOL t_RetryCount = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYCOUNT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryCount = TRUE ;
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYCOUNT, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentRetryCount ( %ld ) " , agentRetryCount 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentRetryTimeout( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentRetryTimeout 
)
{
	BOOL status = TRUE ;
	agentRetryTimeout = 0 ;
	BOOL t_RetryTimeout = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryTimeout = TRUE ;
 
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYTIMEOUT, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentRetryTimeout ( %ld ) " , agentRetryTimeout 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentMaxVarBindsPerPdu ( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentVarBindsPerPdu 
)
{
	BOOL status = TRUE ;
	agentVarBindsPerPdu = 0 ;
	BOOL t_VarBinds = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_VarBinds = TRUE ;
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTVARBINDSPERPDU, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{		
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentVarBindsPerPdu ( %ld ) " , agentVarBindsPerPdu 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentFlowControlWindowSize ( 

	WbemSnmpErrorObject &a_errorObject ,
	ULONG &agentFlowControlWindowSize 
)
{
	BOOL status = TRUE ;
	agentFlowControlWindowSize = 0 ;
	BOOL t_WindowSize = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_WindowSize = TRUE ;
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		LONG flavour;
		CIMTYPE cimType ;

		HRESULT result = m_namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE, 
			0,	
			&t_Variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Using AgentFlowControlWindowSize ( %ld ) " , agentFlowControlWindowSize 
	) ;
)
	}

	return status ;
}

SnmpInstanceClassObject :: SnmpInstanceClassObject ( 

	const SnmpInstanceClassObject & snmpInstanceClassObject 

) : SnmpClassObject ( snmpInstanceClassObject ) 
{
}

SnmpInstanceClassObject :: SnmpInstanceClassObject () 
{
}

SnmpInstanceClassObject :: ~SnmpInstanceClassObject ()
{
}

BOOL SnmpInstanceClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
	BOOL status = TRUE ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_AGENTSNMPVERSION ) ;
	if ( qualifier )
	{
		SnmpInstanceType *value = qualifier->GetValue () ;
		if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
		{
			SnmpDisplayStringType *displayStringType = ( SnmpDisplayStringType * ) value ;
			wchar_t *t_snmpVersion = displayStringType->GetValue () ;
			if ( _wcsicmp ( t_snmpVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
			{
				snmpVersion = 1 ;
			}
			else if ( _wcsicmp ( t_snmpVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
			{
				snmpVersion = 2 ;
			}
			else
			{
// Problem Here

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
		else
		{
// Problem Here

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
		}
	}

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

	if ( ! m_accessible ) 
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOREADABLEPROPERTIES ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
	}

	return status ;
}

BOOL SnmpInstanceClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
	BOOL status = TRUE ;

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpInstanceResponseEventObject :: SnmpInstanceResponseEventObject ( 

	CImpPropProv *providerArg ,
	IWbemContext *a_Context 

) : SnmpResponseEventObject ( providerArg , a_Context ) ,
	classObject ( NULL ) ,
	instanceObject ( NULL ) ,
#if 0
	instanceAccessObject ( NULL ) ,
#endif
	session ( NULL ) ,
	operation ( NULL ) ,
	m_PartitionSet ( NULL )
{
}

SnmpInstanceResponseEventObject :: ~SnmpInstanceResponseEventObject ()
{
#if 0
	if ( instanceAccessObject )
		instanceAccessObject->Release ();
#endif

	if ( instanceObject ) 
		instanceObject->Release () ;

	if ( classObject ) 
		classObject->Release () ;

	if ( m_PartitionSet )
		delete m_PartitionSet ;
}

BOOL SnmpInstanceResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpInstanceResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	wchar_t *agentVersion = NULL ;
	wchar_t *agentAddress = NULL ;
	wchar_t *agentTransport = NULL ;
	wchar_t *agentReadCommunityName = NULL ;
	ULONG agentRetryCount ;
	ULONG agentRetryTimeout ;
	ULONG agentMaxVarBindsPerPdu ;
	ULONG agentFlowControlWindowSize ;

	status = GetAgentVersion ( m_errorObject , agentVersion ) ;
	if ( status ) status = GetAgentAddress ( m_errorObject , agentAddress ) ;
	if ( status ) status = GetAgentTransport ( m_errorObject , agentTransport ) ;
	if ( status ) status = GetAgentReadCommunityName ( m_errorObject , agentReadCommunityName ) ;
	if ( status ) status = GetAgentRetryCount ( m_errorObject , agentRetryCount ) ;
	if ( status ) status = GetAgentRetryTimeout ( m_errorObject , agentRetryTimeout ) ;
	if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , agentMaxVarBindsPerPdu ) ;
	if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , agentFlowControlWindowSize ) ;

	if ( status )
	{
		char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
		if ( dbcsAgentAddress )
		{
			char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
			if ( dbcsAgentReadCommunityName )
			{
				if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
				{
					char *t_Address ;
					if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
					{
						t_Address = provider->GetIpAddressValue () ;
					}
					else
					{
						if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
						{
							t_Address = dbcsAgentAddress ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else							
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;

							}
						}
					}

					if ( status )
					{
						if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
						{
							session = new SnmpV1OverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
						{
							session = new SnmpV2COverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
				}
				else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
				{
					if ( ! SnmpTransportIpxAddress :: ValidateAddress ( dbcsAgentAddress  ) )
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
					}

					if ( status )
					{
						if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)
								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}

				delete [] dbcsAgentReadCommunityName ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
			}

			delete [] dbcsAgentAddress ;

			if ( status )
			{
				operation = new AutoRetrieveOperation(*session,this);
				operation->Send () ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
		}
	}
	else
	{
DebugMacro1( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L" TransportInformation settings invalid"
) ;
)
	}

	delete [] agentTransport ;
	delete [] agentAddress ;
	delete [] agentVersion ;
	delete [] agentReadCommunityName ;


	return status ;
}

SnmpInstanceEventObject :: SnmpInstanceEventObject ( 

	CImpPropProv *providerArg , 
	BSTR ClassArg ,
	IWbemContext *a_Context 

) : SnmpInstanceResponseEventObject ( providerArg , a_Context ) 
{
	Class = new wchar_t [ wcslen ( ClassArg ) + 1 ] ;
	wcscpy ( Class , ClassArg  ) ;
}

SnmpInstanceEventObject :: ~SnmpInstanceEventObject ()
{
	delete [] Class ;
}

BOOL SnmpInstanceEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpInstanceEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	IWbemClassObject *t_ClassObject = NULL ;
	IWbemCallResult *errorObject = NULL ;

	HRESULT result = provider->GetServer()->GetObject (

		Class ,
		0  ,
		m_Context ,
		& classObject ,
		& errorObject 
	) ;

	if ( errorObject )
		errorObject->Release () ;

	if ( SUCCEEDED ( result ) )
	{
		result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
				if ( status = snmpObject.Set ( a_errorObject , classObject , FALSE ) )
				{
					if ( status = snmpObject.Check ( a_errorObject ) )
					{
						status = SendSnmp ( a_errorObject ) ;
					}
					else
					{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)
					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
				}
			}
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;
)

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return status ;
}

SnmpInstanceAsyncEventObject :: SnmpInstanceAsyncEventObject (

	CImpPropProv *providerArg , 
	BSTR Class ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpInstanceEventObject ( providerArg , Class , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: SnmpInstanceAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{

// Get Status object

		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	ULONG t_Ref = notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject ()" 
	) ;
)

}

void SnmpInstanceAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Enumeration Succeeded" 
	) ;
)

	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Enumeration Failed" 
	) ;
)

	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	CImpPropProv :: s_defaultThreadObject->ReapTask ( *this ) ;

	AutoRetrieveOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	delete this ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

}

void SnmpInstanceAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL status = Instantiate ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpInstanceAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpInstanceAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

	notificationHandler->Indicate ( 1 , & snmpObject ) ;
	if ( ! HasNonNullKeys ( snmpObject ) )
	{
		if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
		}
	}
}

void SnmpInstanceAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;

	IWbemClassObject *cloneObject ;
	if ( SUCCEEDED ( result = classObject->SpawnInstance ( 0 , & cloneObject ) ) ) 
	{
		WbemSnmpErrorObject errorObject ;
		if ( snmpObject->Get ( errorObject , cloneObject ) )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)

			notificationHandler->Indicate ( 1 , & cloneObject ) ;
			if ( ! HasNonNullKeys ( cloneObject ) )
			{
				if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
				}
			}			
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Failed to Convert WbemSnmpClassObject to IWbemClassObject" 
	) ;
)
		}
		cloneObject->Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\propget.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "snmpget.h"

SnmpGetClassObject :: SnmpGetClassObject () 
{
}

SnmpGetClassObject :: ~SnmpGetClassObject ()
{
}

BOOL SnmpGetClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
// Check Class Object, used in a Get Request, for validity

	BOOL status = TRUE ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_AGENTSNMPVERSION ) ;
	if ( qualifier )
	{
		SnmpInstanceType *value = qualifier->GetValue () ;
		if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
		{
			SnmpDisplayStringType *displayStringType = ( SnmpDisplayStringType * ) value ;
			wchar_t *t_snmpVersion = displayStringType->GetValue () ;
			SnmpIntegerType integerType ( t_snmpVersion , NULL ) ;
			if ( integerType.SnmpInstanceType :: IsValid () )
			{
				snmpVersion = integerType.GetValue () ;
			}
			else
			{
// Problem Here

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
		else
		{
// Problem Here

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
		}
	}

// Check all Properties for validity

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

// Check properties defined as keys have valid key order
 
	if ( status )
	{
		if ( ! m_accessible ) 
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_NOREADABLEPROPERTIES ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
		}
	}

	return status ;
}

BOOL SnmpGetClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
// Check property validity

	BOOL status = TRUE ;

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpGetResponseEventObject :: SnmpGetResponseEventObject ( 

	CImpPropProv *providerArg , 
	IWbemClassObject *classObjectArg ,
	IWbemContext *a_Context 

) : SnmpResponseEventObject ( providerArg , a_Context ) , 
	classObject ( classObjectArg ) , 
	instanceObject ( NULL ) ,	
	session ( NULL ) , 
	operation ( NULL ) , 
	processComplete ( FALSE ) 
{
	if ( classObject )
		classObject->AddRef () ;
}

SnmpGetResponseEventObject :: ~SnmpGetResponseEventObject ()
{
	if ( instanceObject )
		instanceObject->Release () ;

	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpGetResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	wchar_t *agentVersion = NULL ;
	wchar_t *agentAddress = NULL ;
	wchar_t *agentTransport = NULL ;
	wchar_t *agentReadCommunityName = NULL ;
	ULONG agentRetryCount ;
	ULONG agentRetryTimeout ;
	ULONG agentMaxVarBindsPerPdu ;
	ULONG agentFlowControlWindowSize ;

	status = GetAgentVersion ( m_errorObject , agentVersion ) ;
	if ( status ) status = GetAgentAddress ( m_errorObject , agentAddress ) ;
	if ( status ) status = GetAgentTransport ( m_errorObject , agentTransport ) ;
	if ( status ) status = GetAgentReadCommunityName ( m_errorObject , agentReadCommunityName ) ;
	if ( status ) status = GetAgentRetryCount ( m_errorObject , agentRetryCount ) ;
	if ( status ) status = GetAgentRetryTimeout ( m_errorObject , agentRetryTimeout ) ;
	if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , agentMaxVarBindsPerPdu ) ;
	if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , agentFlowControlWindowSize ) ;

	if ( status )
	{
		char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
		if ( dbcsAgentAddress )
		{
			char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
			if ( dbcsAgentReadCommunityName )
			{
				if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
				{
					char *t_Address ;
					if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
					{
						t_Address = provider->GetIpAddressValue () ;
					}
					else
					{
						t_Address = dbcsAgentAddress ;
					}

					if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
					{
						session = new SnmpV1OverIp (

							t_Address ,
							SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
							dbcsAgentReadCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
					{
						session = new SnmpV2COverIp (

							t_Address ,
							SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
							dbcsAgentReadCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

					}
				}
				else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
				{
					if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
					{
						session = new SnmpV1OverIpx (

							dbcsAgentAddress ,
							dbcsAgentReadCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
					{
						session = new SnmpV2COverIpx (

							dbcsAgentAddress  ,
							dbcsAgentReadCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}

				delete [] dbcsAgentReadCommunityName ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
			}

			delete [] dbcsAgentAddress ;

			if ( status )
			{
				operation = new GetOperation(*session,this);
				operation->Send () ;

			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
		}
	}
	else
	{
DebugMacro1( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L" TransportInformation settings invalid"
) ;
)
	}

	delete [] agentTransport ;
	delete [] agentAddress ;
	delete [] agentVersion ;
	delete [] agentReadCommunityName ;

	return status ;

}

SnmpGetEventObject :: SnmpGetEventObject (

	CImpPropProv *providerArg , 
	wchar_t *ObjectPathArg ,
	IWbemContext *a_Context 

) : SnmpGetResponseEventObject ( providerArg , NULL , a_Context ) 
{
	ULONG length = wcslen ( ObjectPathArg ) ;
	objectPath = new wchar_t [ length + 1 ] ;
	wcscpy ( objectPath , ObjectPathArg ) ;
}

SnmpGetEventObject :: ~SnmpGetEventObject ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: ~SnmpGetEventObject()"
	) ;
)

	delete [] objectPath ;
}

BOOL SnmpGetEventObject :: ParseObjectPath ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: ParseObjectPath ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

// Check Validity of instance path

	ParsedObjectPath *t_ParsedObjectPath = NULL ;
	CObjectPathParser t_ObjectPathParser ;

	BOOL status = t_ObjectPathParser.Parse ( objectPath , &t_ParsedObjectPath ) ;
	if ( status == 0 )
	{
// Check validity of path

		status = DispatchObjectPath ( a_errorObject , t_ParsedObjectPath ) ;
	}
	else
	{
// Parse Failure

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to parse object path" ) ;
	}

	delete t_ParsedObjectPath ;

	return status ;
}

BOOL SnmpGetEventObject :: DispatchObjectPath ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) 
{
// Check validity of server/namespace path and validity of request

	BOOL status = TRUE ;

	status = DispatchObjectReference ( a_errorObject , t_ParsedObjectPath ) ;

	return status ;
}

BOOL SnmpGetEventObject :: DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath )"
	) ;
)

// Check validity of request

	BOOL status = TRUE ;

// Get type of request

	if ( t_ParsedObjectPath->m_bSingletonObj )
	{
// Class requested

		status = DispatchKeyLessClass ( a_errorObject , t_ParsedObjectPath->m_pClass ) ;
	}
	else if ( t_ParsedObjectPath->m_dwNumKeys == 0 )
	{
// Class requested

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_NOT_CAPABLE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
		a_errorObject.SetMessage ( L"Unexpected Path parameter" ) ;

	}
	else 
	{
// General instance requested

		status = DispatchInstanceSpec ( a_errorObject , t_ParsedObjectPath ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class (%s) )" ,
		Class
	) ;
)

// Get OLE MS class definition

	BOOL status = TRUE ;

	IWbemCallResult *errorObject = NULL ;
	HRESULT result = provider->GetServer()->GetObject (

		Class ,
		0 ,
		m_Context ,
		& classObject ,
		& errorObject
	) ;

	if ( errorObject )
		errorObject->Release () ;

// Clone object

	if ( SUCCEEDED ( result ) )
	{
		result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
			}
		}
	}
	else
	{
// Class definition unknown

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unexpected Path parameter" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class (%s) )",
		a_Class
	) ;
)

	BOOL status = TRUE ;

	status = GetInstanceClass ( a_errorObject , a_Class ) ;
	if ( status )
	{
		status = snmpObject.Set ( a_errorObject , GetClassObject () , FALSE ) ;
		if ( status )
		{
			status = snmpObject.Check ( a_errorObject ) ;
			if ( status )
			{
				status = SendSnmp ( a_errorObject ) ;
			}
			else
			{
// Class definition syntactically incorrect
			}
		}
		else
		{
// Class definition syntactically incorrect
		}
	}
	else
	{
// Class definition unknown
	}

	return status ;
}

BOOL SnmpGetEventObject :: SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property , KeyRef *a_KeyReference )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property (%s) , KeyRef *a_KeyReference )",
		property->GetName () 
	) ;
)

// Set keyed property value used for instance retrieval using path specification

	BOOL status = TRUE ;

	if ( a_KeyReference->m_vValue.vt == VT_I4 )
	{
// property value is an integer type

		SnmpIntegerType integerType ( a_KeyReference->m_vValue.lVal , NULL ) ;
		if ( property->SetValue ( & integerType ) ) 
		{
		}
		else
		{
// Property value doesn't correspond with property syntax

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Path parameter is inconsistent with keyed property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}
	}
	else if ( a_KeyReference->m_vValue.vt == VT_BSTR )
	{
// property value is an string type

		if ( property->SetValue ( a_KeyReference->m_vValue.bstrVal ) )
		{
		}
		else
		{
// Property value doesn't correspond with property syntax

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Path parameter is inconsistent with keyed property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 

		}
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Path parameter is inconsistent with keyed property" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath )"
	) ;
)

// Get Instance based on general request

	BOOL status = TRUE ;

// Clear Tag for all keyed properties

	WbemSnmpProperty *property ;
	snmpObject.ResetKeyProperty () ;
	while ( property = snmpObject.NextKeyProperty () )
	{
		property->SetTag ( FALSE ) ;
	}

// Check request doesn't contain duplicate property names

	if ( snmpObject.GetKeyPropertyCount () == 1 )
	{
// Class contains exactly one keyed property

		WbemSnmpProperty *property ;
		snmpObject.ResetKeyProperty () ;
		if ( property = snmpObject.NextKeyProperty () )
		{
// Set Key property value

			KeyRef *t_PropertyReference = a_ParsedObjectPath->m_paKeys [ 0 ] ;
			status = SetProperty ( a_errorObject , property , t_PropertyReference ) ;
		}
	}
	else if ( snmpObject.GetKeyPropertyCount () != 0 )
	{
// Iterate through list of key assignments in request

		ULONG t_Index = 0 ;
		while ( t_Index < a_ParsedObjectPath->m_dwNumKeys )
		{
			KeyRef *t_PropertyReference = a_ParsedObjectPath->m_paKeys [ t_Index ] ;
			WbemSnmpProperty *property ;
			if ( property = snmpObject.FindKeyProperty ( t_PropertyReference->m_pName ) )
			{
				if ( property->GetTag () )
				{
// key value already specified in request

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Path definition specified duplicate key parameter" ) ;

					break ;
				}
				else
				{
// Set property based on request value

					property->SetTag () ;
					status = SetProperty ( a_errorObject , property , t_PropertyReference ) ;
					if ( status )
					{
					}
					else
					{
// Illegal key value specified

						break ;
					}
				}
			}
			else
			{
// Property request is not a valid keyed property

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Path definition specified invalid key parameter name" ) ;

				break ;
			}

			t_Index ++ ;
		}

// Check all keyed properties values have been specified

		if ( status )
		{
			WbemSnmpProperty *property ;
			snmpObject.ResetKeyProperty () ;
			while ( status && ( property = snmpObject.NextKeyProperty () ) )
			{
				if ( property->GetTag () ) 
				{
				}
				else
				{
// One of the keyed properties has not been specified

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_MISSINGPATHKEYPARAMETER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Path definition did not specify all key parameter values" ) ;

					break ;
				}
			}
		}
	}
	else
	{
// Class contains zero keyed properties, has already have been checked

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Path definition specified key parameters for keyless class" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath )"
	) ;
)

	BOOL status = TRUE ;

	status = GetInstanceClass ( a_errorObject , a_ParsedObjectPath->m_pClass ) ;
	if ( status )
	{
		status = snmpObject.Set ( a_errorObject , GetClassObject () , FALSE ) ;
		if ( status )
		{
			status = snmpObject.Check ( a_errorObject ) ;
			if ( status )
			{
				status = SetInstanceSpecKeys ( a_errorObject , a_ParsedObjectPath ) ;
				if ( status )
				{
					status = SendSnmp ( a_errorObject ) ;
				}
				else
				{
// Requested Property value definitions illegal

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Key Specification was illegal"
	) ;
)
				}
			}
			else
			{
// Class definition syntactically incorrect

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Failed During Check :Class definition did not conform to mapping"
	) ;
)

			}
		}
		else
		{
// Class definition syntactically incorrect

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Failed During Set : Class definition did not conform to mapping"
	) ;
)
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unknown Class" ) ;

)

// Class definition unknown
	}

	return status ;
}

SnmpGetAsyncEventObject :: SnmpGetAsyncEventObject (

	CImpPropProv *providerArg , 
	wchar_t *ObjectPathArg ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpGetEventObject ( providerArg , ObjectPathArg , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: SnmpGetAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{

// Get Status object

		IWbemClassObject *notifyStatus = NULL ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject ()" 
	) ;
)

}

void SnmpGetAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
		if ( notificationHandler )
		{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)

			notificationHandler->Indicate ( 1 , & instanceObject ) ;

			if ( ! HasNonNullKeys ( instanceObject ) )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
			}
		}
		else
		{
		}
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	CImpPropProv :: s_defaultThreadObject->ReapTask ( *this ) ;

	GetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	delete this ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

}

void SnmpGetAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL status = ParseObjectPath ( m_errorObject ) ;
			if ( status )
			{
				if ( processComplete )
				{
					ReceiveComplete () ;
				}
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: Process ()" 
	) ;
)

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\propprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpPropProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include "classfac.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <cominit.h>
#include <tree.h>
#include "dnf.h"
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "propinst.h"
#include "propquery.h"
#include "proprefr.h"
#include "guids.h"


void SnmpInstanceDefaultThreadObject::Initialise ()
{
	InitializeCom () ;
}


/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpPropProv::CImpPropProv
// CImpPropProv::~CImpPropProv
//
//***************************************************************************

SnmpInstanceDefaultThreadObject *CImpPropProv :: s_defaultThreadObject = NULL ;
SnmpInstanceDefaultThreadObject *CImpPropProv :: s_defaultPutThreadObject = NULL ;

CImpPropProv::CImpPropProv ()
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::CImpPropProv ( this = ( %lx ) ) " , 
		this 
	) ;
)

	m_referenceCount = 0 ;
	 
    InterlockedIncrement ( & CPropProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	initialised = FALSE ;
	m_InitSink = NULL ;
	server = NULL ;
	thisNamespace = NULL ;
	ipAddressString = NULL ;	
	ipAddressValue = NULL ;	
	m_notificationClassObject = NULL ;
	m_snmpNotificationClassObject = NULL ;
	m_getNotifyCalled = FALSE ;
	m_getSnmpNotifyCalled = FALSE ;
	m_localeId = NULL ;
}

CImpPropProv::~CImpPropProv(void)
{
	delete [] m_localeId ;
	delete [] thisNamespace ;
	delete [] ipAddressString ;

	free ( ipAddressValue ) ;

	if ( server ) 
		server->Release () ;

	if ( m_InitSink )
		m_InitSink->Release () ;

	if ( m_notificationClassObject )
		m_notificationClassObject->Release () ;

	if ( m_snmpNotificationClassObject )
		m_snmpNotificationClassObject->Release () ;

/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CPropProvClassFactory :: objectsInProgress ) ;

}

//***************************************************************************
//
// CImpPropProv::QueryInterface
// CImpPropProv::AddRef
// CImpPropProv::Release
//
// Purpose: IUnknown members for CImpPropProv object.
//***************************************************************************

STDMETHODIMP CImpPropProv::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemHiPerfProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpPropProv::AddRef(void)
{
    return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpPropProv::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

IWbemServices *CImpPropProv :: GetServer () 
{ 
	if ( server )
		server->AddRef () ; 

	return server ; 
}

IWbemClassObject *CImpPropProv :: GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_notificationClassObject )
	{
		m_notificationClassObject->AddRef () ;
	}

	return m_notificationClassObject ; 
}

IWbemClassObject *CImpPropProv :: GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_snmpNotificationClassObject )
	{
		m_snmpNotificationClassObject->AddRef () ;
	}

	return m_snmpNotificationClassObject ; 
}

void CImpPropProv :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpPropProv :: GetThisNamespace () 
{
	return thisNamespace ; 
}

void CImpPropProv :: SetThisNamespace ( wchar_t *thisNamespaceArg ) 
{
	thisNamespace = UnicodeStringDuplicate ( thisNamespaceArg ) ; 
}

BOOL CImpPropProv:: FetchSnmpNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	if ( m_getSnmpNotifyCalled )
	{
		if ( m_snmpNotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_getSnmpNotifyCalled = TRUE ;

	BOOL status = TRUE ;

	IWbemCallResult *errorObject = NULL ;

	HRESULT result = server->GetObject (

		WBEM_CLASS_SNMPNOTIFYSTATUS ,
		0 ,
		a_Ctx,
		& m_snmpNotificationClassObject ,
		& errorObject 
	) ;

	if ( errorObject )
		errorObject->Release () ;

	if ( ! SUCCEEDED ( result ) )
	{
		status = FALSE ;
		m_snmpNotificationClassObject = NULL ;
	}

	return status ;
}

BOOL CImpPropProv:: FetchNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx
)
{
	if ( m_getNotifyCalled )
	{
		if ( m_notificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_getNotifyCalled = TRUE ;

	BOOL status = TRUE ;

	IWbemCallResult *errorObject = NULL ;

	HRESULT result = server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx ,
		& m_notificationClassObject ,
		& errorObject 
	) ;

	if ( errorObject )
		errorObject->Release () ;

	if ( ! SUCCEEDED ( result ) )
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
	}

	return status ;
}

BOOL CImpPropProv::ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::ObtainCachedIpAddress ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemClassObject *namespaceObject = NULL ;
	IWbemCallResult *errorObject = NULL ;

	HRESULT result = server->GetObject ( 

		WBEM_SNMP_TRANSPORTCONTEXT_OBJECT ,		
		0 ,
		NULL ,
		&namespaceObject ,
		&errorObject 
	) ;

	if ( errorObject )
			errorObject->Release () ;

	if ( SUCCEEDED ( result ) )
	{
		VARIANT variant ;
		VariantInit ( & variant ) ;

		LONG flavour;
		CIMTYPE cimType ;

		result = namespaceObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT, 
			0,	
			& variant ,
			& cimType,
			& flavour
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( variant.vt == VT_BSTR ) 
			{
				if ( _wcsicmp ( variant.bstrVal , L"IP" ) == 0 )
				{
					VARIANT variant ;
					VariantInit ( & variant ) ;

					result = namespaceObject->Get ( 

						WBEM_QUALIFIER_AGENTADDRESS, 
						0,	
						& variant ,
						& cimType,
						& flavour
					) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( variant.vt == VT_BSTR ) 
						{
							ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
							if ( ipAddressString )
							{						

								SnmpTransportIpAddress transportAddress ( 
		
									ipAddressString , 
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
								) ;

								if ( transportAddress () )
								{	
									ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
								}
								else
								{
									delete [] ipAddressString ;
									ipAddressString = NULL ;

/*
 *	Invalid Transport Address.
 */

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
								}
 							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
						}

						VariantClear ( &variant ) ;
					}
					else
					{
/*
*	Transport Address not specified, ignore it
*/
					}
				}
				else if ( _wcsicmp ( variant.bstrVal , L"IPX" ) == 0 )
				{
				}
				else
				{
// Unknown transport type

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}
			}
			else
			{
/*
*	Transport qualifier was not a string value
*/

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}

			VariantClear ( & variant ) ;
		}
		else
		{
			VARIANT variant ;
			VariantInit ( & variant ) ;

			result = namespaceObject->Get ( 

				WBEM_QUALIFIER_AGENTADDRESS, 
				0,	
				& variant ,
				& cimType,
				& flavour
			) ;

			if ( SUCCEEDED ( result ) )
			{
				if ( variant.vt == VT_BSTR ) 
				{
					ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
					if ( ipAddressString )
					{
						SnmpTransportIpAddress transportAddress ( 

							ipAddressString , 
							SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
						) ;

						if ( transportAddress () )
						{	
							ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
						}
						else
						{
							delete [] ipAddressString ;
							ipAddressString = NULL ;

/*
 *	Invalid Transport Address.
 */

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}

				VariantClear ( & variant );
			}
			else
			{
/*
*	Transport Address not specified, ignore it
*/
			}
		}

		namespaceObject->Release () ;
	}

DebugMacro2( 

	wchar_t *t_UnicodeString = ipAddressValue ? DbcsToUnicodeString ( ipAddressValue ) : NULL ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from CImpPropProv::ObtainCachedIpAddress () with IP Address (%s)",
		t_UnicodeString ? t_UnicodeString : L"NULL"
	) ;

	delete [] t_UnicodeString ;
)

	return status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpPropProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::GetObjectAsync ( (%s) )" ,
		ObjectPath
	) ;
)

	HRESULT result = S_OK ;

/*
 * Create Asynchronous GetObjectByPath object
 */

	SnmpGetAsyncEventObject *aSyncEvent = new SnmpGetAsyncEventObject ( this , ObjectPath , pHandler , pCtx ) ;

	CImpPropProv :: s_defaultThreadObject->ScheduleTask ( *aSyncEvent ) ;

	aSyncEvent->Exec () ;

	aSyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from CImpPropProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		result 
	) ;
)

	return result ;
}

HRESULT CImpPropProv :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

 HRESULT CImpPropProv :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

SCODE CImpPropProv :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::PutInstanceAsync ()" 
	) ;
)

	HRESULT result = S_OK ;

/*
 * Create Synchronous UpdateInstance object
 */

	SnmpUpdateAsyncEventObject *aSyncEvent = new SnmpUpdateAsyncEventObject ( this , pInst , pHandler , pCtx , lFlags ) ;

	CImpPropProv :: s_defaultPutThreadObject->ScheduleTask ( *aSyncEvent ) ;

	aSyncEvent->Exec () ;

	aSyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from CImpPropProv::PutInstanceAsync () with Result = (%lx)" ,
		result 
	) ;
)

	return result ;
}

HRESULT CImpPropProv :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT CImpPropProv :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

#if 0
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::DeleteInstance ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Asynchronous GetObjectByPath object
 */

	DeleteInstanceAsyncEventObject *t_AsyncEvent = new DeleteInstanceAsyncEventObject ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

	CImpPropProv :: s_defaultPutThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec () ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from CImpPropProv::DeleteInstanceAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		t_Result 
	) ;
)

	return t_Result ;

}
#endif


HRESULT CImpPropProv :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::CreateInstanceEnumAsync ( (%s) )" ,
		Class
	) ;
)

	HRESULT result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	SnmpInstanceAsyncEventObject *aSyncEvent = new SnmpInstanceAsyncEventObject ( this , Class , pHandler , pCtx ) ;

	CImpPropProv :: s_defaultThreadObject->ScheduleTask ( *aSyncEvent ) ;

	aSyncEvent->Exec () ;

	aSyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"ReturningFrom CImpPropProv::CreateInstanceEnum ( (%s) ) with Result = (%lx)" ,
		Class ,
		result
	) ;
)

	return result ;

}

HRESULT CImpPropProv :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::ExecQueryAsync ( this = ( %lx ) , (%s),(%s) )" ,
		this ,
		QueryFormat ,
		Query 
	) ;
)

	HRESULT result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, 0, NULL, NULL);

	SnmpQueryAsyncEventObject *aSyncEvent = new SnmpQueryAsyncEventObject ( this , QueryFormat , Query , pHandler , pCtx ) ;

	CImpPropProv :: s_defaultThreadObject->ScheduleTask ( *aSyncEvent ) ;

	aSyncEvent->Exec () ;

	aSyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from CImpPropProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" ,
		QueryFormat,
		Query,
		result 
	) ;
)

	return result ;
}

HRESULT CImpPropProv :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT CImpPropProv :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpPropProv :: ExecMethod( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT STDMETHODCALLTYPE CImpPropProv :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
       
HRESULT CImpPropProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::Initialize ( this = ( %lx ) )" , this
	) ;
)

	EnterCriticalSection ( & s_ProviderCriticalSection ) ;

	BOOL status = TRUE ;

	server = pCIMOM ;
	server->AddRef () ;

	namespacePath.SetNamespacePath ( pszNamespace ) ;

	if ( ! CImpPropProv :: s_defaultThreadObject )
	{
		SnmpThreadObject :: Startup () ;
		SnmpDebugLog :: Startup () ;
		SnmpClassLibrary :: Startup () ;

 		CImpPropProv :: s_defaultThreadObject = new SnmpInstanceDefaultThreadObject ( "SNMP Instance Provider" ) ;
		CImpPropProv :: s_defaultThreadObject->WaitForStartup () ;
 		CImpPropProv :: s_defaultPutThreadObject = new SnmpInstanceDefaultThreadObject ( "SNMP Put Instance Provider" ) ;
		CImpPropProv :: s_defaultPutThreadObject->WaitForStartup () ;

	}

	WbemSnmpErrorObject errorObject ;

	ObtainCachedIpAddress ( errorObject ) ;

	status = FetchSnmpNotificationObject ( errorObject , pCtx ) ;
	status = FetchNotificationObject ( errorObject , pCtx ) ;

	HRESULT result = errorObject.GetWbemStatus () ;

	pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning From CImpPropProv::Initiliaze ( this = ( %lx ) ) with Result = (%lx)" , 
		this , result
	) ;
)

	LeaveCriticalSection ( & s_ProviderCriticalSection ) ;

	return result ;
}

HRESULT STDMETHODCALLTYPE CImpPropProv::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

//***************************************************************************
//
//  CImpPropProv::QueryInstances
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (not used here).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//***************************************************************************
        
HRESULT CImpPropProv :: QueryInstances ( 

    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *Class,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pHandler
)
{
    if (pNamespace == 0 || Class == 0 || pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpPropProv::QueryInstances ( (%s) )" ,
		Class
	) ;
)

	HRESULT result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	SnmpInstanceAsyncEventObject *aSyncEvent = new SnmpInstanceAsyncEventObject ( this , Class , pHandler , pCtx ) ;

	CImpPropProv :: s_defaultThreadObject->ScheduleTask ( *aSyncEvent ) ;

	aSyncEvent->Exec () ;

	aSyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"ReturningFrom CImpPropProv::QueryInstances ( (%s) ) with Result = (%lx)" ,
		Class ,
		result
	) ;
)

	return result ;

}    

//***************************************************************************
//
//  CNt5Refresher::CreateRefresher
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//***************************************************************************        

HRESULT CImpPropProv::CreateRefresher ( 

     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
)
{
    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

	IWbemRefresher *t_Refresher = new CImpRefresher ( this ) ;
	t_Refresher->AddRef () ;
	*ppRefresher = t_Refresher ;

    return S_OK ;
}

//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in CIMOM.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        

HRESULT CImpPropProv :: CreateRefreshableObject ( 

    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
)
{
	CImpRefresher *t_Refresher = ( CImpRefresher * ) pRefresher ;
	HRESULT t_Result = t_Refresher->AddObject ( pTemplate , ppRefreshable , plId , pContext ) ;

	return t_Result ;
}
    
//***************************************************************************
//
//  CNt5Refresher::StopRefreshing
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//***************************************************************************        
        
HRESULT CImpPropProv::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags
    )
{
	CImpRefresher *t_Refresher = ( CImpRefresher * ) pRefresher ;
	HRESULT t_Result = t_Refresher->RemoveObject ( lId ) ;

	return t_Result ;
}

CImpRefresher :: CImpRefresher ( CImpPropProv *a_Provider ) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"CImpRefresher::CImpRefresher ( this = ( %lx ) ) " , 
		this 
	) ;
)

	m_Provider = a_Provider ;
	m_Provider->AddRef () ;

	m_referenceCount = 0 ;

	m_ContainerLength = 20 ;
	m_Container = ( void ** ) new SnmpRefreshEventObject * [ m_ContainerLength ] ; 

	for ( ULONG t_Index = 0 ; t_Index < m_ContainerLength ; t_Index ++ )
	{
		m_Container [ t_Index ] = NULL ;
	}

	InitializeCriticalSection ( &m_CriticalSection ) ;
	 
    InterlockedIncrement ( & CPropProvClassFactory :: objectsInProgress ) ;

}

CImpRefresher::~CImpRefresher(void)
{
	m_Provider->Release () ;

	DeleteCriticalSection ( &m_CriticalSection ) ;

	for ( ULONG t_Index = 0 ; t_Index < m_ContainerLength ; t_Index ++ )
	{
		SnmpRefreshEventObject *t_AsyncEvent = ( SnmpRefreshEventObject * )	m_Container [ t_Index ] ;
		if ( t_AsyncEvent )
		{
			CImpPropProv :: s_defaultThreadObject->ReapTask ( *t_AsyncEvent ) ;	

			t_AsyncEvent->Release () ;
		}
	}

	delete [] m_Container ;

/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CPropProvClassFactory :: objectsInProgress ) ;
}

//***************************************************************************
//
// CImpRefresher::QueryInterface
// CImpRefresher::AddRef
// CImpRefresher::Release
//
// Purpose: IUnknown members for CImpRefresher object.
//***************************************************************************

STDMETHODIMP CImpRefresher::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( IWbemRefresher * ) this ;
	}
	else if ( iid == IID_IWbemRefresher )
	{
		*iplpv = ( LPVOID ) ( IWbemRefresher * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpRefresher::AddRef(void)
{
    return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpRefresher::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

HRESULT CImpRefresher :: Refresh (

	/* [in] */ long lFlags
)
{

	HRESULT t_Result = S_OK ;

	EnterCriticalSection ( & m_CriticalSection ) ;

	for ( ULONG t_Index = 0 ; t_Index < m_ContainerLength ; t_Index ++ )
	{
		SnmpRefreshEventObject *t_AsyncEvent = ( SnmpRefreshEventObject * )	m_Container [ t_Index ] ;
		if ( t_AsyncEvent )
		{
			t_AsyncEvent->Exec () ;
			t_AsyncEvent->Acknowledge () ;
			t_AsyncEvent->Wait () ;
		}
	}

	LeaveCriticalSection ( & m_CriticalSection ) ;

	return S_OK ;
}

HRESULT CImpRefresher :: AddObject ( IWbemObjectAccess *a_Template , IWbemObjectAccess **a_RefreshObject , long *a_Id , IWbemContext *pContext )
{
	EnterCriticalSection ( & m_CriticalSection ) ;

	SnmpRefreshEventObject *t_AsyncEvent = new SnmpRefreshEventObject ( m_Provider , a_Template , pContext ) ;

	HRESULT t_Result = t_AsyncEvent->Validate () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Found = FALSE ;

		for ( ULONG t_Index = 0 ; t_Index < m_ContainerLength ; t_Index ++ )
		{
			if ( m_Container [ t_Index ] == NULL )
			{
				m_Container [ t_Index ] = t_AsyncEvent ;
				*a_Id = t_Index ;
				t_Found = TRUE ;
				break ;
			}
		}

		if ( ! t_Found )
		{
			ULONG t_ContainerLength = m_ContainerLength + 20 ;
			void **t_Container = ( void ** ) new SnmpRefreshEventObject * [ m_ContainerLength ] ;

			for ( ULONG t_Index = 0 ; t_Index < t_ContainerLength ; t_Index ++ )
			{
				if ( t_Index < m_ContainerLength )
				{
					t_Container [ t_Index ] = m_Container [ t_Index ] ;
				}
				else
				{
					t_Container [ t_Index ] = NULL ;
				}
			}

			m_Container [ m_ContainerLength ] = t_AsyncEvent ;
			*a_Id = t_ContainerLength ;

			delete [] m_Container ;
			m_Container = t_Container ;
			m_ContainerLength = t_ContainerLength ;

		}

		CImpPropProv :: s_defaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
		*a_RefreshObject = t_AsyncEvent->GetRefreshedObjectAccess () ;

	}

	LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_Result ;
}

HRESULT CImpRefresher :: RemoveObject ( long a_Id )
{
	EnterCriticalSection ( & m_CriticalSection ) ;

	if ( a_Id < m_ContainerLength )
	{
		SnmpRefreshEventObject *t_AsyncEvent = ( SnmpRefreshEventObject * ) m_Container [ a_Id ] ;
		if ( t_AsyncEvent )
		{
			t_AsyncEvent->SetState ( 2 ) ;
			t_AsyncEvent->Exec () ;
			m_Container [ a_Id ] = NULL ;
		}
	}
	
	LeaveCriticalSection ( & m_CriticalSection ) ;

	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\proprefr.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "proprefr.h"
#include "snmpget.h"
#include "snmprefr.h"

BOOL SnmpRefreshEventObject :: CreateResources ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	wchar_t *agentVersion = NULL ;
	wchar_t *agentAddress = NULL ;
	wchar_t *agentTransport = NULL ;
	wchar_t *agentReadCommunityName = NULL ;
	ULONG agentRetryCount ;
	ULONG agentRetryTimeout ;
	ULONG agentMaxVarBindsPerPdu ;
	ULONG agentFlowControlWindowSize ;

	status = GetAgentVersion ( m_errorObject , agentVersion ) ;
	if ( status ) status = GetAgentAddress ( m_errorObject , agentAddress ) ;
	if ( status ) status = GetAgentTransport ( m_errorObject , agentTransport ) ;
	if ( status ) status = GetAgentReadCommunityName ( m_errorObject , agentReadCommunityName ) ;
	if ( status ) status = GetAgentRetryCount ( m_errorObject , agentRetryCount ) ;
	if ( status ) status = GetAgentRetryTimeout ( m_errorObject , agentRetryTimeout ) ;
	if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , agentMaxVarBindsPerPdu ) ;
	if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , agentFlowControlWindowSize ) ;

	if ( status )
	{
		char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
		if ( dbcsAgentAddress )
		{
			char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
			if ( dbcsAgentReadCommunityName )
			{
				if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
				{
					char *t_Address ;
					if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
					{
						t_Address = provider->GetIpAddressValue () ;
					}
					else
					{
						if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
						{
							t_Address = dbcsAgentAddress ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else							
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
							}
						}
					}

					if ( status )
					{
						if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
						{
							session = new SnmpV1OverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
						{
							session = new SnmpV2COverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
				}
				else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
				{
					if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
					{
						session = new SnmpV1OverIpx (

							dbcsAgentAddress ,
							dbcsAgentReadCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
					{
						session = new SnmpV2COverIpx (

							dbcsAgentAddress  ,
							dbcsAgentReadCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}

				delete [] dbcsAgentReadCommunityName ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
			}

			delete [] dbcsAgentAddress ;

			if ( status )
			{
				operation = new RefreshOperation(*session,this);
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
		}
	}
	else
	{
DebugMacro1( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L" TransportInformation settings invalid"
) ;
)
	}

	delete [] agentTransport ;
	delete [] agentAddress ;
	delete [] agentVersion ;
	delete [] agentReadCommunityName ;

	return status ;

}

HRESULT SnmpRefreshEventObject :: Validate ()
{
	IWbemClassObject *t_ClassObject = NULL ;
	WbemSnmpErrorObject t_errorObject ;

	HRESULT result = m_Template->QueryInterface ( IID_IWbemClassObject , (void **)&t_ClassObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		result = t_ClassObject->Clone ( & m_RefreshedObject ) ;
		if ( SUCCEEDED ( result ) )
		{
DebugMacro3( 

	wchar_t *t_Text = NULL ;
	m_RefreshedObject->GetObjectText ( 0 , & t_Text ) ;

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"%s" , t_Text 
	) ;

	SysFreeString ( t_Text ) ;
)

			HRESULT result = m_RefreshedObject->QueryInterface ( IID_IWbemObjectAccess , (void **)&m_RefreshedObjectAccess ) ;
			if ( SUCCEEDED ( result ) )
			{
				VARIANT variant ;
				VariantInit ( & variant ) ;

				result = t_ClassObject->Get ( WBEM_PROPERTY_CLASS , 0 , &variant , NULL , NULL ) ;
				if ( SUCCEEDED ( result ) )
				{
					IWbemClassObject *t_Class = NULL ;

					result = provider->GetServer ()->GetObject ( 

						variant.bstrVal ,
						0 ,
						m_Context ,
						& t_Class  ,
						NULL
					) ;

					VariantClear ( & variant ) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( GetNamespaceObject ( t_errorObject ) )
						{
							if ( m_SnmpObject.Set ( t_errorObject , t_Class , FALSE ) )
							{
								if ( m_SnmpObject.Merge ( t_errorObject , t_ClassObject ) )
								{
									if ( m_SnmpObject.Check ( t_errorObject ) )
									{
									}
									else
									{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)
									}
								}
							}
							else
							{
		DebugMacro3( 

			SnmpDebugLog :: s_SnmpDebugLog->Write (  

				__FILE__,__LINE__,
				L"Failed During Set : Class definition did not conform to mapping"
			) ;
		)

							}

							t_Class->Release () ;

						}
					}
					else
					{
						t_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
						t_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						t_errorObject.SetMessage ( L"Unknown Class" ) ;
					}
				}
			}
		}

		t_ClassObject->Release () ;
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;
)

		t_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		t_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		t_errorObject.SetMessage ( L"Unknown Class" ) ;
	}

    return t_errorObject.GetWbemStatus () ;
}

SnmpRefreshEventObject :: SnmpRefreshEventObject (

	CImpPropProv *providerArg ,
	IWbemObjectAccess *a_Template ,
	IWbemContext *a_Context  

) : SnmpResponseEventObject ( providerArg , a_Context ) , state ( 0 ) , 
	m_Template ( a_Template ) , 
	m_RefreshedObject ( NULL ) , 
	m_RefreshedObjectAccess ( NULL )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpRefreshEventObject :: SnmpRefreshEventObject ()" 
	) ;
)

}

SnmpRefreshEventObject :: ~SnmpRefreshEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpRefreshEventObject :: ~SnmpRefreshEventObject ()" 
	) ;
)

	delete operation ;
	delete session ;

	if ( m_RefreshedObject )
		m_RefreshedObject->Release () ;

	if ( m_RefreshedObjectAccess )
		m_RefreshedObjectAccess->Release () ;

}

void SnmpRefreshEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpRefreshEventObject :: ReceiveComplete ()" 
	) ;
)

	Complete () ;
	WaitAcknowledgement () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpRefreshEventObject :: ReceiveComplete ()" 
	) ;
)

	Release () ;
}

void SnmpRefreshEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpRefreshEventObject :: Process ()" 
	) ;
)

	AddRef () ;

	switch ( state )
	{
		case 0:
		{
			WbemSnmpErrorObject a_errorObject ;
			CreateResources ( a_errorObject ) ;

			state = 1 ;	
			operation->Send () ;
		}
		break ;

		case 1:
		{
			operation->Send () ;
		}
		break ;

		case 2:
		{
			CImpPropProv :: s_defaultThreadObject->ReapTask ( *this ) ;	
			Release () ;
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpRefreshEventObject :: Process ()" 
	) ;
)

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\propset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propset.h"
#include "snmpset.h"
#include "snmpqset.h"

SnmpSetClassObject :: SnmpSetClassObject () : m_RowStatusSpecified ( FALSE ) , m_RowStatusPresent ( FALSE )
{
}

SnmpSetClassObject :: ~SnmpSetClassObject ()
{
}

ULONG SnmpSetClassObject :: NumberOfWritable ()
{
	ULONG t_NumberOfWritable = 0 ;

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( property = NextProperty () )
	{
		if ( ! property->GetTag () )
		{
			BOOL t_Status = ( GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
			t_Status = t_Status || ( ( GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;
			if ( t_Status )
			{
				if ( property->IsVirtualKey () == FALSE )
				{
					if ( property->IsWritable () )
					{
						t_NumberOfWritable ++ ;
					}
				}
			}
		}
	}

	return t_NumberOfWritable ;
}

BOOL SnmpSetClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
// Check Class Object, used in a Get Request, for validity

	BOOL status = TRUE ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ROWSTATUS ) ;
	if ( qualifier )
	{
		SnmpInstanceType *value = qualifier->GetValue () ;
		if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
		{
			SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
			m_RowStatusSpecified = integerType->GetValue () ;
		}
		else
		{
// Problem Here

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: RowStatus" ) ;
		}
	}

	qualifier = FindQualifier ( WBEM_QUALIFIER_AGENTSNMPVERSION ) ;
	if ( qualifier )
	{
		SnmpInstanceType *value = qualifier->GetValue () ;
		if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
		{
			SnmpDisplayStringType *displayStringType = ( SnmpDisplayStringType * ) value ;
			wchar_t *t_snmpVersion = displayStringType->GetValue () ;
			SnmpIntegerType integerType ( t_snmpVersion , NULL ) ;
			if ( integerType.SnmpInstanceType :: IsValid () )
			{
				snmpVersion = integerType.GetValue () ;
			}
			else
			{
// Problem Here

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
		else
		{
// Problem Here

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
		}
	}

// Check all Properties for validity

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

	if ( ! m_accessible ) 
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOWRITABLEPROPERTIES ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
	}

	if ( m_RowStatusSpecified && ! m_RowStatusPresent )
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is of type RowStatus" ) ;
	}

	return status ;
}

BOOL SnmpSetClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
// Check property validity

	BOOL status = TRUE ;

	if ( typeid ( *property->GetValue () ) == typeid ( SnmpObjectIdentifierType ) )
	{
		SnmpObjectIdentifierType *t_ObjectIdentifier = ( SnmpObjectIdentifierType * ) property->GetValue () ;
		if ( t_ObjectIdentifier->GetValueLength () < 2 ) 
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}
	}

	if ( typeid ( *property->GetValue () ) == typeid ( SnmpRowStatusType ) )
	{
		if ( m_RowStatusPresent )
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class contains more than one property with RowStatus type definition" ) ;

		}
		else
		{
			m_RowStatusPresent = TRUE ;
		}
	}

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && property->IsWritable () )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && property->IsWritable  () )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpSetResponseEventObject :: SnmpSetResponseEventObject ( 

	CImpPropProv *providerArg , 
	IWbemClassObject *classObjectArg ,
	IWbemContext *a_Context ,
	long lflags

) : SnmpResponseEventObject ( providerArg , a_Context ) , 
	classObject ( classObjectArg ) , 
	session ( NULL ) , 
	operation ( NULL ) , 
	processComplete ( FALSE ) , 
	m_lflags ( lflags ) ,
	state ( 0 ) ,
	m_SnmpTooBig ( FALSE ) ,
	m_VarBindsLeftBeforeTooBig ( 0 ) 
{
	if ( classObject )
		classObject->AddRef () ;
}

SnmpSetResponseEventObject :: ~SnmpSetResponseEventObject ()
{
	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpSetResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject , const ULONG &a_NumberToSend )
{
	m_SnmpTooBig = FALSE ;

	BOOL status = TRUE ;

	wchar_t *agentVersion = NULL ;
	wchar_t *agentAddress = NULL ;
	wchar_t *agentTransport = NULL ;
	wchar_t *agentWriteCommunityName = NULL ;
	ULONG agentRetryCount ;
	ULONG agentRetryTimeout ;
	ULONG agentMaxVarBindsPerPdu ;
	ULONG agentFlowControlWindowSize ;

	status = GetAgentVersion ( m_errorObject , agentVersion ) ;
	if ( status ) status = GetAgentAddress ( m_errorObject , agentAddress ) ;
	if ( status ) status = GetAgentTransport ( m_errorObject , agentTransport ) ;
	if ( status ) status = GetAgentWriteCommunityName ( m_errorObject , agentWriteCommunityName ) ;
	if ( status ) status = GetAgentRetryCount ( m_errorObject , agentRetryCount ) ;
	if ( status ) status = GetAgentRetryTimeout ( m_errorObject , agentRetryTimeout ) ;
	if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , agentMaxVarBindsPerPdu ) ;
	if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , agentFlowControlWindowSize ) ;

	if ( status )
	{
		char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
		if ( dbcsAgentAddress )
		{
			char *dbcsagentWriteCommunityName = UnicodeToDbcsString ( agentWriteCommunityName ) ;
			if ( dbcsagentWriteCommunityName )
			{
				if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
				{
					char *t_Address ;
					if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
					{
						t_Address = provider->GetIpAddressValue () ;
					}
					else
					{
						if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
						{
							t_Address = dbcsAgentAddress ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else							
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
							}
						}
					}

					if ( status )
					{
						if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
						{
							session = new SnmpV1OverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
						{
							session = new SnmpV2COverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
				}
				else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
				{
					if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
					{
						session = new SnmpV1OverIpx (

							dbcsAgentAddress ,
							dbcsagentWriteCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
					{
						session = new SnmpV2COverIpx (

							dbcsAgentAddress  ,
							dbcsagentWriteCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentMaxVarBindsPerPdu ,
							agentFlowControlWindowSize 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}

				delete [] dbcsagentWriteCommunityName ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: agentWriteCommunityName" ) ;
			}

			delete [] dbcsAgentAddress ;

			if ( status )
			{
				operation = new SetOperation(*session,this);
				operation->Send ( a_NumberToSend ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
		}
	}
	else
	{
DebugMacro1( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L" TransportInformation settings invalid"
) ;
)
	}

	delete [] agentTransport ;
	delete [] agentAddress ;
	delete [] agentVersion ;
	delete [] agentWriteCommunityName ;

	return status ;
}

SnmpUpdateEventObject :: SnmpUpdateEventObject (

	CImpPropProv *providerArg , 
	IWbemClassObject *classObject ,
	IWbemContext *a_Context ,
	long lflags 

) : SnmpSetResponseEventObject ( providerArg , classObject , a_Context , lflags ) 
{
}

SnmpUpdateEventObject :: ~SnmpUpdateEventObject ()
{
}

BOOL SnmpUpdateEventObject :: CheckForRowExistence ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: CheckForRowExistence ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)


	BOOL t_Status = FALSE ;

	BOOL status = TRUE ;

	wchar_t *agentVersion = NULL ;
	wchar_t *agentAddress = NULL ;
	wchar_t *agentTransport = NULL ;
	wchar_t *agentWriteCommunityName = NULL ;
	ULONG agentRetryCount ;
	ULONG agentRetryTimeout ;
	ULONG agentMaxVarBindsPerPdu ;
	ULONG agentFlowControlWindowSize ;

	status = GetAgentVersion ( m_errorObject , agentVersion ) ;
	if ( status ) status = GetAgentAddress ( m_errorObject , agentAddress ) ;
	if ( status ) status = GetAgentTransport ( m_errorObject , agentTransport ) ;
	if ( status ) status = GetAgentWriteCommunityName ( m_errorObject , agentWriteCommunityName ) ;
	if ( status ) status = GetAgentRetryCount ( m_errorObject , agentRetryCount ) ;
	if ( status ) status = GetAgentRetryTimeout ( m_errorObject , agentRetryTimeout ) ;
	if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , agentMaxVarBindsPerPdu ) ;
	if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , agentFlowControlWindowSize ) ;

	if ( status )
	{
		char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
		if ( dbcsAgentAddress )
		{
			char *dbcsagentWriteCommunityName = UnicodeToDbcsString ( agentWriteCommunityName ) ;
			if ( dbcsagentWriteCommunityName )
			{
				if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
				{
					char *t_Address ;
					if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
					{
						t_Address = provider->GetIpAddressValue () ;
					}
					else
					{
						if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
						{
							t_Address = dbcsAgentAddress ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else							
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
							}
						}
					}

					if ( status )
					{
						if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
						{
							session = new SnmpV1OverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
						{
							session = new SnmpV2COverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
				}
				else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
				{
					if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
					{
						session = new SnmpV1OverIpx (

							dbcsAgentAddress ,
							dbcsagentWriteCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentFlowControlWindowSize ,
							agentMaxVarBindsPerPdu 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
					{
						session = new SnmpV2COverIpx (

							dbcsAgentAddress  ,
							dbcsagentWriteCommunityName ,
							agentRetryCount , 
							agentRetryTimeout ,
							agentFlowControlWindowSize ,
							agentMaxVarBindsPerPdu 
						);

						if ( ! (*session)() )
						{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

							delete session ;
							session = NULL ;

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
				}

				delete [] dbcsagentWriteCommunityName ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: agentWriteCommunityName" ) ;
			}

			delete [] dbcsAgentAddress ;

			if ( status )
			{
				m_QueryOperation = new SetQueryOperation(*session,this);
				operation->Send () ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
		}
	}
	else
	{
DebugMacro1( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L" TransportInformation settings invalid"
) ;
)
	}

	delete [] agentTransport ;
	delete [] agentAddress ;
	delete [] agentVersion ;
	delete [] agentWriteCommunityName ;

	return status ;
}

BOOL SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	IWbemClassObject *t_ClassObject = NULL ;
	IWbemCallResult *errorObject = NULL ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	t_WBEM_result = classObject->Get ( WBEM_PROPERTY_CLASS , 0 , &variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_WBEM_result ) )
	{
		HRESULT result = provider->GetServer()->GetObject (

			variant.bstrVal ,
			0 ,
			m_Context ,
			& t_ClassObject ,
			& errorObject 
		) ;

		if ( errorObject )
			errorObject->Release () ;

		VariantClear ( & variant ) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
				status = snmpObject.Set ( a_errorObject , t_ClassObject , FALSE ) ;
				if ( status )
				{
					status = snmpObject.Merge ( a_errorObject , GetClassObject () ) ;
					if ( status )
					{
						status = snmpObject.Check ( a_errorObject ) ;
						if ( status )
						{
							status = HandleSnmpVersion ( a_errorObject ) ;
						}
						else
						{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)

						}
					}
					else
					{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Merge : Class definition did not conform to mapping"
) ;
)
					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
				}
			}

			t_ClassObject->Release () ;
		}
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject ) with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)
	return status ;
}

SnmpUpdateAsyncEventObject :: SnmpUpdateAsyncEventObject (

	CImpPropProv *providerArg , 
	IWbemClassObject *classObject ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context ,
	long lflags 

) : SnmpUpdateEventObject ( providerArg , classObject , a_Context , lflags ) , notificationHandler ( notify ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SnmpUpdateAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject ()" 
	) ;
)

	// Get Status object

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject ()" 
	) ;
)

}

void SnmpUpdateAsyncEventObject :: SetComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Update Succeeded" 
	) ;
)

		WbemSnmpErrorObject errorObject ;
		IWbemClassObject *classObject = GetClassObject () ;
		BOOL status = snmpObject.Get ( errorObject , classObject ) ;
		if ( status )
		{
			if ( notificationHandler )
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)

				notificationHandler->Indicate ( 1 , & classObject ) ;
			}
		}
		else
		{
		}
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	CImpPropProv :: s_defaultPutThreadObject->ReapTask ( *this ) ;

	SetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	delete this ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

}

void SnmpUpdateAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL status = Update ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: Process ()" 
	) ;
)

}

BOOL SnmpUpdateEventObject :: HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject )" 
	) ;
)

	BOOL t_Status = FALSE ;

	if ( snmpObject.RowStatusSpecified () )
	{
		if ( snmpObject.GetSnmpVersion () == 1 )
		{
			if ( m_lflags == WBEM_FLAG_CREATE_OR_UPDATE )
			{
				t_Status = Create_Or_Update () ;
			}
			else if ( m_lflags == WBEM_FLAG_CREATE_ONLY )
			{
				t_Status = Create_Only () ;
			}
			else if ( m_lflags == WBEM_FLAG_UPDATE_ONLY )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			if ( m_lflags == WBEM_FLAG_CREATE_OR_UPDATE )
			{
				t_Status = Create_Or_Update () ;
			}
			else if ( m_lflags == WBEM_FLAG_CREATE_ONLY )
			{
				t_Status = Create_Only () ;
			}
			else if ( m_lflags == WBEM_FLAG_UPDATE_ONLY )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}	
	}
	else
	{
		if ( m_lflags == WBEM_FLAG_CREATE_OR_UPDATE )
		{
			state = 0 ;
			t_Status = SendSnmp ( a_ErrorObject ) ;
		}
		else if ( m_lflags == WBEM_FLAG_CREATE_ONLY )
		{
			state = 1 ;
			t_Status = CheckForRowExistence ( a_ErrorObject ) ;
		}
		else if ( m_lflags == WBEM_FLAG_UPDATE_ONLY )
		{
			state = 2 ;
			t_Status = CheckForRowExistence ( a_ErrorObject ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

void SnmpUpdateAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	BOOL t_Status = TRUE ;

	switch ( state )
	{
		case 0:
		{
/*
 *	V1 SMI - CREATE_OR_UPDATE
 */

			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
			}

			SetComplete () ;
			return ;
		}
		break ;

		case 1:
		{
/*
*	V1 SMI - CREATE_ONLY
*/

			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			state = 3 ;
			if ( m_QueryOperation->GetRowReceived () == 0 )
			{
				t_Status = SendSnmp ( m_errorObject ) ;
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_ALREADY_EXISTS  ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_ALREADY_EXISTS ) ;
				m_errorObject.SetMessage ( L"Instance already exists" ) ;

				t_Status = FALSE ;
			}

			if ( m_QueryOperation )
				m_QueryOperation->DestroyOperation () ;

		}
		break ;

		case 2:
		{
/*
*	V1 SMI - UPDATE_ONLY
*/
			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			state = 3 ;
			if ( m_QueryOperation->GetRowReceived () )
			{
				t_Status = SendSnmp ( m_errorObject ) ;
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				m_errorObject.SetMessage ( L"Instance does not exist" ) ;

				t_Status = FALSE ;
			}

			if ( m_QueryOperation )
				m_QueryOperation->DestroyOperation () ;

		}
		break ;

		case 3:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
			}
			
			t_Status = FALSE ;
		}
		break ;

		case 4:
		{
/*
*	V2C SMI ROWSTATUS - CREATE_OR_UPDATE
*/

			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE  ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"UNKNOWN STATE TRANSITION" ) ;

			t_Status = FALSE ;

		}
		break ;

		case 10:
		{
/*
 *	V2C SMI ROWSTATUS - CREATE_ONLY
 */

			WbemSnmpProperty *t_Property ;
			snmpObject.ResetProperty () ;
			while ( t_Property = snmpObject.NextProperty () )
			{
				t_Property->SetTag ( FALSE ) ;
			}

			ULONG t_VarBindsPerPdu = 0 ;

			t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
			if ( t_Status ) 
			{
				m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

				ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

/*
 * Check to see if we can fit all vbs in to one pdu
 */
				if ( t_NumberOfWritable < t_VarBindsPerPdu )
				{

// Does fit
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						t_NumberOfWritable , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndGo 
					) ;

					state = 11 ;
				}
				else
				{
// Does not fit, therefore decompose

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
					) ;

					state = 12 ;
				}
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Internal Error" ) ;
				t_Status = FALSE ;
			}
		}
		break ;

		case 11:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */

/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

				m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
				) ;

				state = 12 ;
			}
			else
			{
/*
 *	We've either succeeded or totally failed.
 */
				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
				}
				else
				{
				}
			}
		}
		break ;

		case 12:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

					m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
					) ;

					state = 12 ;
				}
			}
			else
			{
/*
 *	We've either succeeded or totally failed to set the row as createAndWait
 */

				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
/*
 *	Now send a non row status variable binding list
 */
					ULONG t_VarBindsPerPdu = 0 ;

					t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
					if ( t_Status ) 
					{
						m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig
						) ;

						state = 13 ;
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
				else
				{
				}
			}
		}
		break ;

		case 13:
		{
/*
 * check to see if we succeeded in sending a non row status variable binding list
 */

			if ( m_SnmpTooBig )
			{
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
					m_VarBindsLeftBeforeTooBig -- ;

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
					) ;

					state = 13 ;
				}
			}
			else
			{
				if ( snmpObject.NumberOfWritable () == 0 )
				{
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						0 , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: active 
					) ;

					state = 14 ;
				}
				else
				{
					ULONG t_VarBindsPerPdu = 0 ;

					t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
					if ( t_Status ) 
					{
						m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig 
						) ;

						state = 13 ;
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case 14:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;

				t_Status = FALSE ;
			}
			else
			{
				SetComplete () ;
				return ;
			}
		}
		break ;

		case 20:
		{
/*
 *	V2C SMI ROWSTATUS - UPDATE_ONLY
 */

			WbemSnmpProperty *t_Property ;
			snmpObject.ResetProperty () ;
			while ( t_Property = snmpObject.NextProperty () )
			{
				t_Property->SetTag ( FALSE ) ;
			}

			ULONG t_VarBindsPerPdu = 0 ;

			t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
			if ( t_Status ) 
			{
				m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

				ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

/*
 * Check to see if we can fit all vbs in to one pdu
 */
				if ( t_NumberOfWritable < t_VarBindsPerPdu )
				{

// Does fit
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						t_NumberOfWritable , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: active 
					) ;

					state = 21 ;
				}
				else
				{
// Does not fit, therefore decompose

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
					) ;

					state = 22 ;
				}
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Internal Error" ) ;
				t_Status = FALSE ;
			}
		}
		break ;

		case 21:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */

/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

				m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
				) ;

				state = 22 ;
			}
			else
			{
/*
 *	We've either succeeded or totally failed.
 */
				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
				}
				else
				{
				}
			}
		}
		break ;

		case 22:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

					m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
					) ;

					state = 22 ;
				}
			}
			else
			{
/*
 *	We've either succeeded or totally failed to set the row as notInService
 */

				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
/*
 *	Now send a non row status variable binding list
 */
					ULONG t_VarBindsPerPdu = 0 ;

					t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
					if ( t_Status ) 
					{
						m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig
						) ;

						state = 23 ;
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
				else
				{
				}
			}
		}
		break ;

		case 23:
		{
/*
 * check to see if we succeeded in sending a non row status variable binding list
 */

			if ( m_SnmpTooBig )
			{
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
					m_VarBindsLeftBeforeTooBig -- ;

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
					) ;

					state = 23 ;
				}
			}
			else
			{
				ULONG t_VarBindsPerPdu = 0 ;

				if ( snmpObject.NumberOfWritable () == 0 )
				{
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						0 , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: active 
					) ;

					state = 24 ;
				}
				else
				{
					ULONG t_VarBindsPerPdu = 0 ;

					t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
					if ( t_Status ) 
					{
						m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig 
						) ;

						state = 23 ;
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case 24:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;

				t_Status = FALSE ;
			}
			else
			{
				SetComplete () ;
				return ;
			}
		}
		break ;

		case 30:
		{
			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			if ( m_QueryOperation->GetRowReceived () == 0 )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = Create_Only () ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE  ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"UNKNOWN STATE TRANSITION" ) ;

			t_Status = FALSE ;
		}
		break ;
	}

	if ( t_Status == FALSE ) 
	{
		SetComplete () ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)
}

void SnmpUpdateAsyncEventObject :: SnmpTooBig () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SnmpTooBig ()" 
	) ;
)

	m_SnmpTooBig = TRUE ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: SnmpTooBig ()" 
	) ;
)
}

BOOL SnmpUpdateEventObject :: Create_Only ()
{
	BOOL t_Status = TRUE ;

/*
 *	V2C SMI ROWSTATUS - CREATE_ONLY
 */

	WbemSnmpProperty *t_Property ;
	snmpObject.ResetProperty () ;
	while ( t_Property = snmpObject.NextProperty () )
	{
		t_Property->SetTag ( FALSE ) ;
	}

	ULONG t_VarBindsPerPdu = 0 ;

	t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
	if ( t_Status ) 
	{
		m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

		ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

/*
* Check to see if we can fit all vbs in to one pdu
*/
		if ( t_NumberOfWritable < t_VarBindsPerPdu )
		{

// Does fit
			t_Status = Send_Variable_Binding_List ( 

				snmpObject , 
				t_NumberOfWritable , 
				SnmpRowStatusType :: SnmpRowStatusEnum :: createAndGo 
			) ;

			state = 7 ;
		}
		else
		{
// Does not fit, therefore decompose

			t_Status = Send_Variable_Binding_List ( 

				snmpObject , 
				m_VarBindsLeftBeforeTooBig , 
				SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
			) ;

			state = 8 ;
		}
	}
	else
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Internal Error" ) ;
		t_Status = FALSE ;
	}


	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Update_Only ()
{
	BOOL t_Status = TRUE ;

/*
 *	V2C SMI ROWSTATUS - UPDATE_ONLY
 */

	WbemSnmpProperty *t_Property ;
	snmpObject.ResetProperty () ;
	while ( t_Property = snmpObject.NextProperty () )
	{
		t_Property->SetTag ( FALSE ) ;
	}

	ULONG t_VarBindsPerPdu = 0 ;

	t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , t_VarBindsPerPdu ) ;
	if ( t_Status ) 
	{
		m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

		ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

/*
 * Check to see if we can fit all vbs in to one pdu
 */
		if ( t_NumberOfWritable < t_VarBindsPerPdu )
		{

// Does fit
			t_Status = Send_Variable_Binding_List ( 

				snmpObject , 
				t_NumberOfWritable , 
				SnmpRowStatusType :: SnmpRowStatusEnum :: active 
			) ;

			state = 7 ;
		}
		else
		{
// Does not fit, therefore decompose

			t_Status = Send_Variable_Binding_List ( 

				snmpObject , 
				m_VarBindsLeftBeforeTooBig , 
				SnmpRowStatusType :: SnmpRowStatusEnum :: notInService
			) ;

			state = 8 ;
		}
	}
	else
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Internal Error" ) ;
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Create_Or_Update ()
{
	BOOL t_Status = FALSE ;

	state = 30 ;
	t_Status = CheckForRowExistence ( m_errorObject ) ;

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Send_Variable_Binding_List ( 

	SnmpSetClassObject &a_SnmpSetClassObject , 
	ULONG a_NumberToSend 
)
{
/*
 * Find Property of RowStatus type and make sure we don't send in request
 */

	BOOL t_Status = FALSE ;

	WbemSnmpProperty *t_Property ;

	a_SnmpSetClassObject.ResetProperty () ;
	while ( t_Property = a_SnmpSetClassObject.NextProperty () )
	{
		if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
		{
			t_Property->SetTag ( TRUE ) ;
		}
	}

	t_Status = SendSnmp ( m_errorObject , a_NumberToSend ) ;

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Send_Variable_Binding_List ( 

	SnmpSetClassObject &a_SnmpSetClassObject , 
	ULONG a_NumberToSend ,
	SnmpRowStatusType :: SnmpRowStatusEnum a_SnmpRowStatusEnum
)
{
	BOOL t_Status = FALSE ;

	WbemSnmpProperty *t_Property ;

	a_SnmpSetClassObject.ResetProperty () ;
	while ( t_Property = a_SnmpSetClassObject.NextProperty () )
	{
		if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
		{
			t_Property->SetTag ( FALSE ) ;
			SnmpRowStatusType *t_RowStatus = new SnmpRowStatusType ( a_SnmpRowStatusEnum ) ;
			t_Property->SetValue ( t_RowStatus ) ;
		}
	}

	t_Status = SendSnmp ( m_errorObject , a_NumberToSend ) ;

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snmpclas.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\propquery.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <tree.h>
#include "dnf.h"
#include "propprov.h"
#include "propsnmp.h"
#include "propinst.h"
#include "propquery.h"
#include "snmpnext.h"

QueryPreprocessor :: QuadState SnmpQueryEventObject :: Compare ( 

	LONG a_Operand1 , 
	LONG a_Operand2 , 
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	SnmpTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	switch ( a_Operand1Func ) 
	{
		case SnmpValueNode :: SnmpValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case SnmpValueNode :: SnmpValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: Compare ( 

	wchar_t *a_Operand1 , 
	wchar_t *a_Operand2 , 
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	SnmpTreeNode &a_OperatorType 
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Compare ()"
	) ;
)

	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	wchar_t *a_Operand1AfterFunc = NULL ;
	wchar_t *a_Operand2AfterFunc = NULL ; 

	switch ( a_Operand1Func ) 
	{
		case SnmpValueNode :: SnmpValueFunction :: Function_None:
		{
		}
		break ;

		case SnmpValueNode :: SnmpValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand1 ) ;
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand1AfterFunc [ index ] = toupper ( a_Operand1 [ index ] ) ;
			}
		}
		break ;

		case SnmpValueNode :: SnmpValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand1 ) ;
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand1AfterFunc [ index ] = tolower ( a_Operand1 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case SnmpValueNode :: SnmpValueFunction :: Function_None:
		{
		}
		break ;

		case SnmpValueNode :: SnmpValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand2 ) ;
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand2AfterFunc [ index ] = toupper ( a_Operand2 [ index ] ) ;
			}
		}
		break ;

		case SnmpValueNode :: SnmpValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand2 ) ;
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand2AfterFunc [ index ] = tolower ( a_Operand2 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc ? a_Operand1AfterFunc : a_Operand1 ;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc ? a_Operand2AfterFunc : a_Operand2 ;

	if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorEqualNode ) )
	{
		t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorNotEqualNode ) )
	{
		t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorEqualOrGreaterNode ) )
	{
		t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorEqualOrLessNode ) )
	{
		t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorLessNode ) )
	{
		t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorGreaterNode ) )
	{
		t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( SnmpOperatorNotLikeNode ) )
	{
	}

	delete [] a_Operand1AfterFunc ;
	delete [] a_Operand2AfterFunc ;

	return t_Status ;
}

SnmpTreeNode *SnmpQueryEventObject :: AllocTypeNode ( 

	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	SnmpValueNode :: SnmpValueFunction a_PropertyFunction ,
	SnmpValueNode :: SnmpValueFunction a_ConstantFunction ,
	SnmpTreeNode *a_Parent 
)
{
	SnmpTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Node = new SnmpStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Node = new SnmpStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
		{
			t_Node = new SnmpSignedIntegerNode ( 

				a_PropertyName , 
				a_Variant.boolVal == VARIANT_TRUE ? 1 : 0 , 
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
		{
			t_Node = new SnmpStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
		{
			t_Node = new SnmpStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
		{
			t_Node = new SnmpSignedIntegerNode ( 

				a_PropertyName , 
				a_Variant.lVal , 
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
		{
			t_Node = new SnmpStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
		{
			t_Node = new SnmpStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
		{
			t_Node = new SnmpStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		WbemSnmpProperty *t_Property ;
		if ( t_Property = snmpObject.FindProperty ( a_PropertyName ) )
		{
			t_VarType = t_Property->GetValueVariantEncodedType () ;
		}

		switch ( t_VarType )
		{
			case VT_I4:
			{
				t_Node = new SnmpSignedIntegerNode ( 

					a_PropertyName , 
					a_Variant.lVal , 
					t_Property->GetKeyOrder () ,
					a_Parent 
				) ;
			}
			break ;

			case VT_UI4:
			{
				t_Node = new SnmpUnsignedIntegerNode ( 

					a_PropertyName , 
					a_Variant.lVal , 
					t_Property->GetKeyOrder () ,
					a_Parent 
				) ;
			}
			break ;

			case VT_BSTR:
			{
				t_Node = new SnmpStringNode ( 

					a_PropertyName , 
					a_Variant.bstrVal , 
					a_PropertyFunction ,
					a_ConstantFunction ,
					t_Property->GetKeyOrder () ,
					a_Parent 
				) ;
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	return t_Node ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: CompareString ( 

	BSTR a_PropertyName , 
	SnmpTreeNode *a_Operator ,
	SnmpTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	SnmpStringNode *t_StringNode = ( SnmpStringNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = GetInstanceObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_StringNode->GetValue () ,
			t_Variant.bstrVal ,
			t_StringNode->GetPropertyFunction () ,
			t_StringNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: CompareInteger ( 

	BSTR a_PropertyName , 
	SnmpTreeNode *a_Operator ,
	SnmpTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	SnmpSignedIntegerNode *t_IntegerNode = ( SnmpSignedIntegerNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = GetInstanceObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_IntegerNode->GetValue () ,
			t_Variant.lVal ,
			t_IntegerNode->GetPropertyFunction () ,
			t_IntegerNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: InvariantEvaluate ( 

	SnmpTreeNode *a_Operator ,
	SnmpTreeNode *a_Operand 
)
{
	SnmpValueNode *t_Node = ( SnmpValueNode * ) a_Operand ;
	BSTR t_PropertyName = t_Node->GetPropertyName () ;
	if ( *t_PropertyName == L'_' )
	{
// System property, must check values

		QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

		if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Status = CompareString ( 

				SYSTEM_PROPERTY_CLASS ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Status = CompareString ( 

				SYSTEM_PROPERTY_SUPERCLASS ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
		{
			t_Status = CompareInteger ( 

				SYSTEM_PROPERTY_GENUS ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
		{
			t_Status = CompareString ( 

				SYSTEM_PROPERTY_SERVER ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
		{
			t_Status = CompareString ( 

				SYSTEM_PROPERTY_NAMESPACE ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
		{
			t_Status = CompareInteger ( 

				SYSTEM_PROPERTY_PROPERTY_COUNT ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
		{
			t_Status = CompareString ( 

				SYSTEM_PROPERTY_DYNASTY ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
		{
			t_Status = CompareString ( 

				SYSTEM_PROPERTY_RELPATH ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
		{
			t_Status = CompareString ( 

				SYSTEM_PROPERTY_PATH ,
				a_Operator ,
				a_Operand
			) ;
		}
		else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}

		return t_Status ;
	}
	else
	{
		WbemSnmpProperty *t_Property ;
		if ( t_Property = snmpObject.FindKeyProperty ( t_PropertyName ) )
		{
			return QueryPreprocessor :: QuadState :: State_Undefined ;
		}
		else
		{
			return QueryPreprocessor :: QuadState :: State_True ;
		}
	}

	if ( typeid ( *a_Operand ) == typeid ( SnmpNullNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpStringNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpUnsignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpSignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}

	if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorEqualNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorNotEqualNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorEqualOrGreaterNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorEqualOrLessNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorLessNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorGreaterNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorLikeNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( SnmpOperatorNotLikeNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}

	return QueryPreprocessor :: QuadState :: State_Undefined ;
}

SnmpRangeNode *SnmpQueryEventObject :: AllocInfiniteRangeNode (

	BSTR a_PropertyName 
)
{
	SnmpRangeNode *t_RangeNode = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	WbemSnmpProperty *t_Property ;
	if ( t_Property = snmpObject.FindKeyProperty ( a_PropertyName ) )
	{
		t_VarType = t_Property->GetValueVariantEncodedType () ;
	}

	switch ( t_VarType )
	{
		case VT_I4:
		{
			t_RangeNode = new SnmpSignedIntegerRangeNode ( 

				a_PropertyName , 
				0xFFFFFFFF , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				0 ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		case VT_UI4:
		{
			t_RangeNode = new SnmpUnsignedIntegerRangeNode ( 

				a_PropertyName , 
				0xFFFFFFFF , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				0 ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		case VT_BSTR:
		{
			t_RangeNode = new SnmpStringRangeNode ( 

				a_PropertyName , 
				0x0 , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				NULL ,
				NULL ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		default:
		{
		}
		break ;
	}

	return t_RangeNode ;
}


void SnmpQueryEventObject :: GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container )
{
	a_Count = snmpObject.GetKeyPropertyCount () ;
	a_Container = new BSTR [ a_Count ] ;

	ULONG t_PropertyIndex = 0 ;

	WbemSnmpProperty *t_Property = NULL ;
	snmpObject.ResetKeyProperty () ;
	while ( t_Property = snmpObject.NextKeyProperty () )
	{
		a_Container [ t_PropertyIndex ] = SysAllocString ( t_Property->GetName () ) ;
		t_PropertyIndex ++ ;
	}
}

SnmpQueryEventObject :: SnmpQueryEventObject ( 

	CImpPropProv *providerArg , 
	BSTR QueryFormatArg , 
	BSTR QueryArg , 
	IWbemContext *a_Context 

) : SnmpInstanceResponseEventObject ( providerArg , a_Context ) ,
	Query ( UnicodeStringDuplicate ( QueryArg ) ) ,
	QueryFormat ( UnicodeStringDuplicate ( QueryFormatArg ) ) ,
	source ( Query ) , 
	parser ( &source ) ,
	requestObject ( NULL ) ,
	rpnExpression ( NULL )
{
}

SnmpQueryEventObject :: ~SnmpQueryEventObject ()
{
	delete [] Query ;
	delete [] QueryFormat ;
	delete rpnExpression ;
	delete requestObject ;
}

BOOL SnmpQueryEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;

	if ( _wcsicmp ( QueryFormat , WBEM_QUERY_LANGUAGE_WQL ) == 0 )
	{
		status = parser.Parse ( & rpnExpression ) ;
		if ( status == FALSE )
		{
			IWbemCallResult *errorObject = NULL ;

			HRESULT result = provider->GetServer()->GetObject (

				rpnExpression->bsClassName,
				0 ,
				m_Context ,
				& classObject ,
				& errorObject 
			) ;

			if ( errorObject )
				errorObject->Release () ;

			if ( SUCCEEDED ( result ) )
			{
				result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
				if ( SUCCEEDED ( result ) )
				{
					if ( status = GetNamespaceObject ( a_errorObject ) )
					{
						if ( status = snmpObject.Set ( a_errorObject , classObject , FALSE ) )
						{
							if ( status = snmpObject.Check ( a_errorObject ) )
							{
								if ( status = PreEvaluate ( a_errorObject ) )
								{
									QueryPreprocessor :: QuadState t_State ;
									t_State = Preprocess ( *rpnExpression , m_PartitionSet ) ;
									switch ( t_State )
									{
										case QueryPreprocessor :: QuadState :: State_True:
										{
											delete m_PartitionSet ;
											m_PartitionSet = NULL ;
											status = SendSnmp ( a_errorObject ) ;
										}
										break ;

										case QueryPreprocessor :: QuadState :: State_False:
										{
											status = FALSE ;
											delete m_PartitionSet ;
											m_PartitionSet = NULL ;

											a_errorObject.SetStatus ( WBEM_SNMP_NO_ERROR ) ;
											a_errorObject.SetWbemStatus ( WBEM_S_NO_ERROR ) ;
											a_errorObject.SetMessage ( L"" ) ;
										}
										break ;

										case QueryPreprocessor :: QuadState :: State_Undefined:
										{
											status = SendSnmp ( a_errorObject ) ;
										}
										break ;

										default:
										{
											status = FALSE ;
											a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
											a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
											a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
										}
										break ;
									}
								}
							}
							else
							{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)

							}
						}
						else
						{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
						}
					}
				}
			}
			else
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;
)
			}
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Illegal SQL 1 Query"
	) ;
)

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Query format not known"
	) ;
)

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY_TYPE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		a_errorObject.SetMessage ( L"Query Language not supported" ) ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: IsSystemProperty (const wchar_t *propertyName )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: SnmpQueryEventObject :: IsSystemProperty (const wchar_t *propertyName )"
	) ;
)

	//Only SYSTEM properties may start with an '_' character.

	return ( *propertyName == SYTEM_PROPERTY_START_CHARACTER ) ;
}

BOOL SnmpQueryEventObject :: PreEvaluate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PreEvaluate ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	if ( rpnExpression->nNumberOfProperties == 0 )
	{
// Get All Properties

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Get All Properties"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( snmpObject ) ;
	}
	else if ( snmpObject.IsVirtual () )
	{
// Get All Properties since some keys are virtuals

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Get All Properties because some keys are virtual"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( snmpObject ) ;
	}
	else
	{
// Get List of Properties for return and list of properties for filter evaluation

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Get Subset of Properties"
	) ;
)

		requestObject = new SnmpInstanceClassObject ;

		status = FilterSelectProperties ( a_errorObject ) ;
	}

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Check Where Clause is legal"
	) ;
)

		status = PreEvaluateWhereClause ( a_errorObject ) ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	LONG varType = 0 ;
	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier = NULL ;

	snmpObject.ResetQualifier () ;
	while ( status && ( qualifier = snmpObject.NextQualifier () ) )
	{
		WbemSnmpQualifier *copy = new WbemSnmpQualifier ( *qualifier ) ;
		status = requestObject->AddQualifier ( copy ) ;
	}

	int index = 0 ;
	BOOL has_system_property = FALSE ;

	while ( status && ( index <  rpnExpression->nNumberOfProperties ) )
	{
		wchar_t *propertyName = rpnExpression->pbsRequestedPropertyNames [ index ] ;

		WbemSnmpProperty *property ;
		if ( property = snmpObject.FindProperty ( propertyName ) )	
		{
			requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;
		}
		else if ( IsSystemProperty ( propertyName ) )
		{
			has_system_property = TRUE;
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Property in SELECT clause is not a valid class property"
	) ;
)

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"SELECT properties of WQL query were invalid" ) ;
		}

		index ++ ;
	}

	if ( status && has_system_property )
	{
		delete requestObject ;
		requestObject = new SnmpInstanceClassObject ( snmpObject ) ;
	}
	
	return status ;
}

BOOL SnmpQueryEventObject :: CheckWhereCondition ( 

	WbemSnmpErrorObject &a_errorObject , 
	WbemSnmpProperty *property ,
	SQL_LEVEL_1_TOKEN *token
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: SnmpQueryEventObject :: CheckWhereCondition ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ,	SQL_LEVEL_1_TOKEN *token)"
	) ;
)

	BOOL status = TRUE ;

	switch ( property->GetValueVariantEncodedType () )
	{
		case VT_I4:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				case VT_I4:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		case VT_BSTR:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				case VT_BSTR:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		case VT_NULL:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
		}
		break ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	int index = 0 ;
	while ( status && ( index <  rpnExpression->nNumTokens ) )
	{
		SQL_LEVEL_1_TOKEN *propertyValue = &rpnExpression->pArrayOfTokens [ index ] ;
		if ( propertyValue->nTokenType == SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
		{	
			wchar_t *propertyName = propertyValue->pPropertyName ;

			WbemSnmpProperty *property ;
			if ( property = snmpObject.FindProperty ( propertyName ) )	
			{
				status = CheckWhereCondition ( a_errorObject , property , propertyValue ) ;
				if ( status )
				{
					if ( ! snmpObject.FindKeyProperty ( propertyName ) )
					{
						requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;
					}
				}
				else
				{
				}
			}
			else if ( ! IsSystemProperty ( propertyName ) ) 
			{
// Property Not Found

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_SUPPORTED ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_SUPPORTED ) ;
				a_errorObject.SetMessage ( L"WHERE clause of WQL query specified unknown property name" ) ;
			}
		}

		index ++ ;
	}

	return status ;
}

SnmpQueryAsyncEventObject :: SnmpQueryAsyncEventObject (

	CImpPropProv *providerArg , 
	BSTR QueryFormat , 
	BSTR Query,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpQueryEventObject ( providerArg , QueryFormat , Query , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: SnmpQueryAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
// Get Status object

		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
			{
				//let CIMOM do the post filtering!
				WBEMSTATUS t_wbemStatus = WBEM_S_FALSE ;
				VARIANT t_variant ;
				VariantInit( & t_variant ) ;
				t_variant.vt = VT_I4 ;
				t_variant.lVal = WBEM_S_FALSE ;

				HRESULT result = notifyStatus->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_variant , 0 ) ;
				VariantClear ( &t_variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					result = notificationHandler->SetStatus ( 0 , t_wbemStatus , NULL , notifyStatus ) ;
				}
				else
				{
					result = notificationHandler->SetStatus ( 0 , WBEM_E_PROVIDER_FAILURE , NULL , NULL ) ;
				}
			}
			else
			{
				HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			}

			notifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject ()" 
	) ;
)

}

void SnmpQueryAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Query Succeeded" 
	) ;
)

	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Query Failed" 
	) ;
)

	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	CImpPropProv :: s_defaultThreadObject->ReapTask ( *this ) ;

	AutoRetrieveOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	delete this ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;
}

void SnmpQueryAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;

			BOOL status = Instantiate ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"Returning from SnmpQueryAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

	notificationHandler->Indicate ( 1 , & snmpObject ) ;
	if ( ! HasNonNullKeys ( snmpObject ) )
	{
		if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
		}
	}			
}

void SnmpQueryAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject*snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

	IWbemClassObject *cloneObject ;
	if ( SUCCEEDED ( result = classObject->SpawnInstance ( 0 , & cloneObject ) ) ) 
	{
		WbemSnmpErrorObject errorObject ;
		if ( status = snmpObject->Get ( errorObject , cloneObject ) )
		{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Sending Object" 
) ;
)
			notificationHandler->Indicate ( 1 , & cloneObject ) ;
			if ( ! HasNonNullKeys ( cloneObject ) )
			{
				if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
				}
			}			
		}	
		else
		{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->Write (  

	__FILE__,__LINE__,
	L"Failed to Convert WbemSnmpClassObject to IWbemClassObject" 
) ;
)

		}

		cloneObject->Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\snmpget.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "snmpget.h"

GetOperation :: GetOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpGetResponseEventObject *eventObjectArg 

) :	SnmpGetOperation ( sessionArg ) , 
	session ( & sessionArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,
	eventObject ( eventObjectArg ) ,
	virtuals ( FALSE ) ,
	virtualsInitialised ( FALSE ) ,	
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 
{
}

GetOperation :: ~GetOperation ()
{
	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void GetOperation :: ReceiveResponse () 
{
// Inform creator all is done

	if ( varBindsReceived == 0 )
	{
/*
 *	Don't mask errors encountered previously
 */

		if ( eventObject->GetErrorObject ().GetWbemStatus () == S_OK )
		{
			eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			eventObject->GetErrorObject ().SetMessage ( L"Instance unknown" ) ;
		}
	}
	else
	{
		if ( FAILED ( eventObject->GetErrorObject ().GetWbemStatus () ) ) 
		{
			if ( eventObject->GetErrorObject ().GetStatus () == WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) 
			{
				eventObject->GetErrorObject ().SetWbemStatus ( WBEM_S_TIMEDOUT ) ;
			}
		}
	}

	eventObject->ReceiveComplete () ;
}

void GetOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,	
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;

	IWbemClassObject *snmpObject = eventObject->GetInstanceObject () ;

	if ( ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchObject ) ) || ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchInstance ) ) )
	{
	}
	else
	{
	// Set Property value

		WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;
		SnmpValue &value = replyVarBind.GetValue () ;

		// Set Property value

		if ( property->SetValue ( snmpObject , &value , SetValueRegardlessReturnCheck ) )
		{
		// Set worked
		}
		else
		{
	// Type Mismatch

			property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			if ( qualifier )
			{
				IWbemQualifierSet *t_QualifierSet = NULL;
				HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
				if ( SUCCEEDED ( result ) )
				{
					SnmpIntegerType integer ( 1 , NULL ) ;
					qualifier->SetValue ( t_QualifierSet , integer ) ;
				}

				t_QualifierSet->Release () ;
			}
		}

		if ( virtuals && virtualsInitialised == FALSE )
		{
// Get Phantom Key properties from first Variable Binding of Row

			BOOL status = TRUE ;
			SnmpObjectIdentifier decodeObject = replyVarBind.GetInstance () ;

			SnmpClassObject *t_SnmpObject = ( SnmpClassObject * ) eventObject->GetSnmpClassObject () ;

			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( status && ( property = t_SnmpObject->NextKeyProperty () ) )
			{
// For each Phantom Key in Key Order consume instance information

				SnmpInstanceType *decodeValue = property->GetValue () ;
				decodeObject = decodeValue->Decode ( decodeObject ) ;
				if ( *decodeValue )
				{
// Decode worked correctly

					const SnmpValue *value = decodeValue->GetValueEncoding () ;
// Set Property value for Phantom Key
					property->SetValue ( snmpObject , value , SetValueRegardlessReturnCheck ) ;
				}
				else
				{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

					WbemSnmpProperty *property ;
					t_SnmpObject->ResetKeyProperty () ;
					while ( property = t_SnmpObject->NextKeyProperty () )
					{
						WbemSnmpQualifier *qualifier = NULL ;
						property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
						{
// Property which is a phantom key could not be decoded correctly.

							IWbemQualifierSet *t_QualifierSet = NULL;
							HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
							if ( SUCCEEDED ( result ) )
							{
								SnmpIntegerType integer ( 1 , NULL ) ;
								qualifier->SetValue ( t_QualifierSet , integer ) ;
							}

							t_QualifierSet->Release () ;
						}
						else
						{
// Problem Here
						}
					}

					status = FALSE ;
				}
			}

// Check we have consumed all instance information

			if ( decodeObject.GetValueLength () )
			{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

				WbemSnmpProperty *property ;
				t_SnmpObject->ResetKeyProperty () ;
				while ( property = t_SnmpObject->NextKeyProperty () )
				{
					WbemSnmpQualifier *qualifier = NULL ;
					property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
					{
// Property which is a phantom key could not be decoded correctly.

						IWbemQualifierSet *t_QualifierSet = NULL;
						HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
						if ( SUCCEEDED ( result ) )
						{
							SnmpIntegerType integer ( 1 , NULL ) ;
							qualifier->SetValue ( t_QualifierSet , integer ) ;
						}

						t_QualifierSet->Release () ;
					}
					else
					{
// Problem Here
					}
				}
			}

// No need to set Phantom keys for further columns of row
			
			virtualsInitialised = TRUE ;
		}
	}
}

#pragma warning (disable:4065)

void GetOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// Invalid property requested
				}
				break ;

				case Snmp_Bad_Value:
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Bad Value for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
				}
				break ;

				case Snmp_Read_Only:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Read Only for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Gen_Error:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported General Error for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Too_Big:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Too Big for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void GetOperation :: FrameTooBig () 
{
}

void GetOperation :: FrameOverRun () 
{
}

void GetOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;
	SnmpNull snmpNull ;

	SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

	IWbemClassObject *snmpObject = eventObject->GetInstanceObject () ;

	SnmpClassObject *t_SnmpObject = eventObject->GetSnmpClassObject () ;
	if ( t_SnmpObject )
	{
// Encode Variable Binding instance for all key properties

		if ( t_SnmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( property = t_SnmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		virtuals = FALSE ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsKey () && property->IsVirtualKey () )
			{
// There are some properties which are phantom

				virtuals = TRUE ;
			}

			if ( property->IsReadable () )
			{
				if ( property->IsSNMPV1Type () )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						m_PropertyContainerLength ++ ;
					}
				}
			}
		}

		m_PropertyContainer = new WbemSnmpProperty * [ m_PropertyContainerLength ] ;

// Add Variable binding to Variable binding list
// Insert new Object Identifier / Property Hash entries for newly created object

		ULONG t_Index = 0 ;

		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;
				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE ) 
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
								SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
								SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

								SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

								m_PropertyContainer [ t_Index ] = property ;

								SnmpVarBind varBind ( requestIdentifier , snmpNull ) ;
								varBindList.Add ( varBind ) ;

								t_Index ++ ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
		// Problem Here
						}
					}
					else
					{
	// Don't retrieve properties marked as virtual keys.
					}
				}
			}

/*
 *	Initialise value to NULL
 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
// Problem Here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\snmpqset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

SetQueryOperation :: SetQueryOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpSetResponseEventObject *eventObjectArg 

) :	SnmpGetOperation ( sessionArg ) , 
	session ( &sessionArg ) ,
	eventObject ( eventObjectArg ) ,
	rowReceived ( FALSE )
{
}

SetQueryOperation :: ~SetQueryOperation ()
{
	session->DestroySession () ;
}

void SetQueryOperation :: ReceiveResponse () 
{
	eventObject->ReceiveComplete () ;
}

void SetQueryOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	if ( ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchObject ) ) || ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchInstance ) ) )
	{
	}
	else
	{
		rowReceived = TRUE ;
	}
}

#pragma warning (disable:4065)

void SetQueryOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// Invalid property requested
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void SetQueryOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;
	SnmpNull snmpNull ;

// Create class object for subsequent receipt of response

// Add Variable binding to Variable binding list

	SnmpClassObject *snmpObject = eventObject->GetSnmpClassObject () ;
	if ( snmpObject )
	{
// Encode Variable Binding instance for all key properties

		SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

		if ( snmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetKeyProperty () ;
			while ( property = snmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}	
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		WbemSnmpProperty *property ;
		snmpObject->ResetProperty () ;
		while ( property = snmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				if ( property->IsSNMPV1Type () )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
								SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
								SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

								SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

		// Add Variable binding to list

								SnmpVarBind varBind ( requestIdentifier , snmpNull ) ;
								varBindList.Add ( varBind ) ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
		// Problem Here
						}
					}
					else
					{
	// Don't Send properties marked as virtual key
					} 
				}
			} 
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\snmpset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propset.h"
#include "snmpset.h"

SetOperation :: SetOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpSetResponseEventObject *eventObjectArg 

) :	SnmpSetOperation ( sessionArg ) , 
	session ( & sessionArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,
	eventObject ( eventObjectArg ) ,
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 

{
}

SetOperation :: ~SetOperation ()
{
	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void SetOperation :: ReceiveResponse () 
{
// Inform creator all is done

	eventObject->ReceiveComplete () ;
}

void SetOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;
}

#pragma warning (disable:4065)

void SetOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported No Such Name for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

// Invalid property requested

					property->AddQualifier ( WBEM_QUALIFIER_NOT_AVAILABLE ) ;
					WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_NOT_AVAILABLE ) ;
					if ( qualifier )
					{
						SnmpIntegerType integer ( 1 , NULL ) ;
						if ( qualifier->SetValue ( &integer ) )
						{
						}
						else
						{
// Problem Here
						}
					}
					else
					{
// Problem Here
					}
				}
				break ;

				case Snmp_Bad_Value:
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Bad Value for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
				}
				break ;

				case Snmp_Read_Only:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Read Only for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Gen_Error:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported General Error for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Too_Big:
				{
					property->SetTag ( FALSE ) ;
					eventObject->SnmpTooBig () ;
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void SetOperation :: FrameTooBig () 
{
	eventObject->SnmpTooBig () ;
	CancelRequest () ;
}

void SetOperation :: FrameOverRun () 
{
	eventObject->SnmpTooBig () ;

#if 0
	eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
	eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
	eventObject->GetErrorObject ().SetMessage ( L"Set Request could not fit into single SNMP PDU" ) ;
#endif

	CancelRequest () ;
}

void SetOperation :: Send ( const ULONG &a_NumberToSend )
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;

	SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

	SnmpClassObject *snmpObject = eventObject->GetSnmpClassObject () ;
	if ( snmpObject )
	{
// Encode Variable Binding instance for all key properties

		if ( snmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetKeyProperty () ;
			while ( property = snmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}	
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		if ( ! m_PropertyContainer )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetProperty () ;
			while ( property = snmpObject->NextProperty () )
			{
				if ( property->IsWritable () )
				{
					if ( property->IsSNMPV1Type () )
					{
						if ( property->IsVirtualKey () == FALSE )
						{
							m_PropertyContainerLength ++ ;
						}
					}
				}
			}

			m_PropertyContainer = new WbemSnmpProperty * [ m_PropertyContainerLength ] ;
		}


// Add Variable binding to Variable binding list

		ULONG t_Count = 0 ;

/*
 * First add row status property
 */

		WbemSnmpProperty *property ;
		snmpObject->ResetProperty () ;
		while ( property = snmpObject->NextProperty () ) 
		{
			if ( ( typeid ( *property->GetValue () ) == typeid ( SnmpRowStatusType ) ) & ( ! property->GetTag () ) )
			{
				property->SetTag ( TRUE ) ;

				WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
				if ( qualifier )
				{
					SnmpInstanceType *value = qualifier->GetValue () ;
					if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
					{
						SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
						SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
						SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

						SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

// Create queue of properties which have duplicate object identifiers

						m_PropertyContainer [ t_Count ] = property ;

						const SnmpValue *snmpValue = property->GetValue()->GetValueEncoding () ;
						SnmpVarBind varBind ( requestIdentifier , *snmpValue ) ;
						varBindList.Add ( varBind ) ;

						t_Count ++ ;
					}
				}
			}
		}

		snmpObject->ResetProperty () ;
		while ( ( property = snmpObject->NextProperty () ) && ( a_NumberToSend == 0xffffffff ) || ( ( a_NumberToSend != 0xffffffff ) && ( t_Count < a_NumberToSend ) ) )
		{
			if ( ! property->GetTag () )
			{
				property->SetTag ( TRUE ) ;

				BOOL t_Status = ( snmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( snmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						if ( property->IsWritable () )
						{
							WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
							if ( qualifier )
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
								{
									SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
									SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
									SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

									SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

// Create queue of properties which have duplicate object identifiers

									m_PropertyContainer [ t_Count ] = property ;

									const SnmpValue *snmpValue = property->GetValue()->GetValueEncoding () ;
									SnmpVarBind varBind ( requestIdentifier , *snmpValue ) ;
									varBindList.Add ( varBind ) ;

									t_Count ++ ;
								}
								else
								{
// Problem Here
								}
							}
							else
							{
// Problem Here
							}
						}
					}
				}
			}
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
// Problem Here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\snmprefr.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "proprefr.h"
#include "snmpget.h"
#include "snmprefr.h"

RefreshOperation :: RefreshOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpRefreshEventObject *eventObjectArg 

) :	SnmpGetOperation ( sessionArg ) , 
	session ( & sessionArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,
	eventObject ( eventObjectArg ) ,
	virtuals ( FALSE ) ,
	virtualsInitialised ( FALSE ) ,	
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 
{
	SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

	SnmpClassObject *t_SnmpObject = eventObject->GetSnmpClassObject () ;
	if ( t_SnmpObject )
	{
// Encode Variable Binding instance for all key properties

		if ( t_SnmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( property = t_SnmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		virtuals = FALSE ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsKey () && property->IsVirtualKey () )
			{
// There are some properties which are phantom

				virtuals = TRUE ;
			}

			if ( property->IsReadable () )
			{
				if ( property->IsSNMPV1Type () )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						m_PropertyContainerLength ++ ;
					}
				}
			}
		}

		m_PropertyContainer = new WbemSnmpProperty * [ m_PropertyContainerLength ] ;

// Add Variable binding to Variable binding list
// Insert new Object Identifier / Property Hash entries for newly created object

		ULONG t_Index = 0 ;

		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;
				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE ) 
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
								SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
								SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

								SnmpNull snmpNull;
								SnmpVarBind varBind ( requestIdentifier , snmpNull ) ;
								m_VarBindList.Add ( varBind ) ;

								m_PropertyContainer [ t_Index ] = property ;

								t_Index ++ ;

							}
							else
							{
		// Problem Here
							}
						}
						else
						{
		// Problem Here
						}
					}
					else
					{
	// Don't retrieve properties marked as virtual keys.
					}
				}
			}

		}
	}
}

RefreshOperation :: ~RefreshOperation ()
{
	delete [] m_PropertyContainer ;
}

void RefreshOperation :: ReceiveResponse () 
{
// Inform creator all is done

	if ( varBindsReceived == 0 )
	{
/*
 *	Don't mask errors encountered previously
 */

		if ( eventObject->GetErrorObject ().GetWbemStatus () == S_OK )
		{
			eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			eventObject->GetErrorObject ().SetMessage ( L"Instance unknown" ) ;
		}
	}
	else
	{
		if ( FAILED ( eventObject->GetErrorObject ().GetWbemStatus () ) ) 
		{
			if ( eventObject->GetErrorObject ().GetStatus () == WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) 
			{
				eventObject->GetErrorObject ().SetWbemStatus ( WBEM_S_TIMEDOUT ) ;
			}
		}
	}

	eventObject->ReceiveComplete () ;
}

void RefreshOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,	
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;

	IWbemClassObject *snmpObject = eventObject->GetRefreshedObject () ;

	if ( ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchObject ) ) || ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchInstance ) ) )
	{
	}
	else
	{
	// Set Property value

		WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;
		SnmpValue &value = replyVarBind.GetValue () ;

		// Set Property value

		if ( property->SetValue ( snmpObject , &value , SetValueRegardlessReturnCheck ) )
		{
		// Set worked
		}
		else
		{
	// Type Mismatch

			property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			if ( qualifier )
			{
				IWbemQualifierSet *t_QualifierSet = NULL;
				HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
				if ( SUCCEEDED ( result ) )
				{
					SnmpIntegerType integer ( 1 , NULL ) ;
					qualifier->SetValue ( t_QualifierSet , integer ) ;
				}

				t_QualifierSet->Release () ;
			}
		}

		if ( virtuals && virtualsInitialised == FALSE )
		{
// Get Phantom Key properties from first Variable Binding of Row

			BOOL status = TRUE ;
			SnmpObjectIdentifier decodeObject = replyVarBind.GetInstance () ;

			SnmpClassObject *t_SnmpObject = ( SnmpClassObject * ) eventObject->GetSnmpClassObject () ;

			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( status && ( property = t_SnmpObject->NextKeyProperty () ) )
			{
// For each Phantom Key in Key Order consume instance information

				SnmpInstanceType *decodeValue = property->GetValue () ;
				decodeObject = decodeValue->Decode ( decodeObject ) ;
				if ( *decodeValue )
				{
// Decode worked correctly

					const SnmpValue *value = decodeValue->GetValueEncoding () ;
// Set Property value for Phantom Key
					property->SetValue ( snmpObject , value , SetValueRegardlessReturnCheck ) ;
				}
				else
				{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

					WbemSnmpProperty *property ;
					t_SnmpObject->ResetKeyProperty () ;
					while ( property = t_SnmpObject->NextKeyProperty () )
					{
						WbemSnmpQualifier *qualifier = NULL ;
						property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
						{
// Property which is a phantom key could not be decoded correctly.

							IWbemQualifierSet *t_QualifierSet = NULL;
							HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
							if ( SUCCEEDED ( result ) )
							{
								SnmpIntegerType integer ( 1 , NULL ) ;
								qualifier->SetValue ( t_QualifierSet , integer ) ;
							}

							t_QualifierSet->Release () ;
						}
						else
						{
// Problem Here
						}
					}

					status = FALSE ;
				}
			}

// Check we have consumed all instance information

			if ( decodeObject.GetValueLength () )
			{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

				WbemSnmpProperty *property ;
				t_SnmpObject->ResetKeyProperty () ;
				while ( property = t_SnmpObject->NextKeyProperty () )
				{
					WbemSnmpQualifier *qualifier = NULL ;
					property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
					{
// Property which is a phantom key could not be decoded correctly.

						IWbemQualifierSet *t_QualifierSet = NULL;
						HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
						if ( SUCCEEDED ( result ) )
						{
							SnmpIntegerType integer ( 1 , NULL ) ;
							qualifier->SetValue ( t_QualifierSet , integer ) ;
						}

						t_QualifierSet->Release () ;
					}
					else
					{
// Problem Here
					}
				}
			}

// No need to set Phantom keys for further columns of row
			
			virtualsInitialised = TRUE ;
		}
	}
}

#pragma warning (disable:4065)

void RefreshOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// Invalid property requested
				}
				break ;

				case Snmp_Bad_Value:
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Bad Value for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
				}
				break ;

				case Snmp_Read_Only:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Read Only for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Gen_Error:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported General Error for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Too_Big:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Too Big for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void RefreshOperation :: FrameTooBig () 
{
}

void RefreshOperation :: FrameOverRun () 
{
}

void RefreshOperation :: Send ()
{
// Send Variable Bindings for requested properties

	varBindsReceived = erroredVarBindsReceived = 0 ;

// Finally Send request

	SendRequest ( m_VarBindList ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\snmpnext.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <tree.h>
#include "dnf.h"
#include "propprov.h"
#include "propsnmp.h"
#include "propinst.h"
#include "snmpnext.h"

BOOL DecrementObjectIdentifier ( 

	SnmpObjectIdentifier &a_Object , 
	SnmpObjectIdentifier &a_DecrementedObject 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_ObjectLength = a_Object.GetValueLength () ;
	ULONG *t_ObjectValue = a_Object.GetValue () ;

	ULONG *t_DecrementedValue = new ULONG [ t_ObjectLength ] ;

	BOOL t_Decrement = TRUE ;

	for ( ULONG t_Index = t_ObjectLength ; t_Index > 0 ; t_Index -- )
	{
		ULONG t_Component = t_ObjectValue [ t_Index - 1 ] ;

		if ( t_Decrement )
		{
			if ( t_Component == 0 ) 
			{
				t_Component -- ;
			}
			else
			{
				t_Decrement = FALSE ;
				t_Component -- ;
			}
		}

		t_DecrementedValue [ t_Index - 1 ] = t_Component ;
	}
	
	a_DecrementedObject.SetValue ( t_DecrementedValue , t_ObjectLength ) ;

	t_Status = t_Decrement == FALSE ;

	return t_Status ;
}

BOOL IncrementObjectIdentifier ( 

	SnmpObjectIdentifier &a_Object , 
	SnmpObjectIdentifier &a_IncrementedObject 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_ObjectLength = a_Object.GetValueLength () ;
	ULONG *t_ObjectValue = a_Object.GetValue () ;

	ULONG *t_IncrementedValue = new ULONG [ t_ObjectLength ] ;

	BOOL t_Increment = TRUE ;

	for ( ULONG t_Index = t_ObjectLength ; t_Index > 0 ; t_Index -- )
	{
		ULONG t_Component = t_ObjectValue [ t_Index - 1 ] ;

		if ( t_Increment )
		{
			if ( t_Component == 0xFFFFFFFF ) 
			{
				t_Component ++ ;
			}
			else
			{
				t_Component ++ ;
				t_Increment = FALSE ;
			}
		}

		t_IncrementedValue [ t_Index - 1 ] = t_Component ;
	}
	
	a_IncrementedObject.SetValue ( t_IncrementedValue , t_ObjectLength ) ;

	t_Status = t_Increment == FALSE ;

	return t_Status ;
}

AutoRetrieveOperation :: AutoRetrieveOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpInstanceResponseEventObject *eventObjectArg 

) :	SnmpAutoRetrieveOperation ( sessionArg ) , 
	session ( &sessionArg ) ,
	eventObject ( eventObjectArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,	
	rowVarBindsReceived ( 0 ) ,
	rowsReceived ( 0 ) ,
	snmpObject ( NULL ) ,
	virtuals ( FALSE ) ,
	virtualsInitialised ( FALSE ) ,
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 
{
}

AutoRetrieveOperation :: ~AutoRetrieveOperation ()
{
	if ( snmpObject ) 
	{
		snmpObject->Release () ;
	}

	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void AutoRetrieveOperation :: ReceiveResponse () 
{
// Inform creator all is done

	eventObject->ReceiveComplete () ;
}

void AutoRetrieveOperation :: ReceiveRowResponse () 
{
// Receive of Row is not complete

	rowsReceived ++ ;

// Inform Creator row has been received

	eventObject->ReceiveRow ( snmpObject ) ;
	snmpObject->Release () ;

// Insert new Object Identifier / Property Hash entries for newly created object

	IWbemClassObject *t_ClassObject = eventObject->GetInstanceObject () ;
	HRESULT t_Result = t_ClassObject->Clone ( & snmpObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{

	/*
	 *	Initialise value to NULL
	 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;

		}
	}
	else
	{
// Problem Here
	}

	virtualsInitialised = FALSE ;
}

void AutoRetrieveOperation :: ReceiveRowVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	rowVarBindsReceived ++ ;

// Set Variable Binding Value for property

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ].m_Property ;
	SnmpValue &value = replyVarBind.GetValue () ;
	if ( property->SetValue ( snmpObject , &value , SetValueRegardlessReturnCheck ) )
	{
	// Set worked
	}
	else
	{
// Type Mismatch

		property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		if ( qualifier )
		{
			IWbemQualifierSet *t_QualifierSet = NULL;
			HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
			if ( SUCCEEDED ( result ) )
			{
				SnmpIntegerType integer ( 1 , NULL ) ;
				qualifier->SetValue ( t_QualifierSet , integer ) ;
			}

			t_QualifierSet->Release () ;
		}
	}

	if ( virtuals && virtualsInitialised == FALSE )
	//if ( virtualsInitialised == FALSE )
	{
// Get Phantom Key properties from first Variable Binding of Row

		BOOL status = TRUE ;
		SnmpObjectIdentifier decodeObject = replyVarBind.GetInstance () ;

		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( status && ( property = t_SnmpObject->NextKeyProperty () ) )
		{
// For each Phantom Key in Key Order consume instance information

			SnmpInstanceType *decodeValue = property->GetValue () ;
			decodeObject = decodeValue->Decode ( decodeObject ) ;
			if ( *decodeValue )
			{
// Decode worked correctly

				const SnmpValue *value = decodeValue->GetValueEncoding () ;
// Set Property value for Key
				property->SetValue ( snmpObject , value , SetValueRegardlessReturnCheck ) ;
			}
			else
			{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

				WbemSnmpProperty *property ;
				t_SnmpObject->ResetKeyProperty () ;
				while ( property = t_SnmpObject->NextKeyProperty () )
				{
					WbemSnmpQualifier *qualifier = NULL ;
					property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
					{
// Property which is a phantom key could not be decoded correctly.

						IWbemQualifierSet *t_QualifierSet = NULL;
						HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
						if ( SUCCEEDED ( result ) )
						{
							SnmpIntegerType integer ( 1 , NULL ) ;
							qualifier->SetValue ( t_QualifierSet , integer ) ;
						}

						t_QualifierSet->Release () ;
					}
					else
					{
// Problem Here
					}
				}

				status = FALSE ;
			}
		}

// Check we have consumed all instance information

		if ( decodeObject.GetValueLength () )
		{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( property = t_SnmpObject->NextKeyProperty () )
			{
				WbemSnmpQualifier *qualifier = NULL ;
				property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
				if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
				{
// Property which is a phantom key could not be decoded correctly.

					IWbemQualifierSet *t_QualifierSet = NULL;
					HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
					if ( SUCCEEDED ( result ) )
					{
						SnmpIntegerType integer ( 1 , NULL ) ;
						qualifier->SetValue ( t_QualifierSet , integer ) ;
					}

					t_QualifierSet->Release () ;
				}
				else
				{
// Problem Here
				}
			}
		}

// No need to set Phantom keys for further columns of row
		
		virtualsInitialised = TRUE ;
	}
}

void AutoRetrieveOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;
}

#pragma warning (disable:4065)

void AutoRetrieveOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// End of MIB tree.
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}

	erroredVarBindsReceived ++ ;
}

#pragma warning (default:4065)

void AutoRetrieveOperation :: FrameTooBig () 
{
}

void AutoRetrieveOperation :: FrameOverRun () 
{
}

void AutoRetrieveOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpNull snmpNull ;
	SnmpVarBindList varBindList ;
	SnmpVarBindList startVarBindList ;

// Create class object for subsequent receipt of response

	IWbemClassObject *t_ClassObject = eventObject->GetInstanceObject () ;
	HRESULT t_Result = t_ClassObject->Clone ( & snmpObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		SnmpInstanceClassObject *t_RequestSnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpRequestClassObject () ;

// Check for properties which are phantom

		virtualsInitialised = FALSE ;
		virtuals = FALSE ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( property = t_SnmpObject->NextKeyProperty () )
		{
			if ( property->IsVirtualKey () )
			{
// There are some properties which are phantom

				virtuals = TRUE ;
			}

			if ( ! t_RequestSnmpObject->FindProperty ( property->GetName () ) ) 
			{
				virtuals = TRUE ;
			}
		}

		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				if ( property->IsSNMPV1Type () )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						m_PropertyContainerLength ++ ;
					}
				}
			}
		}

		m_PropertyContainer = new PropertyDefinition [ m_PropertyContainerLength ] ;

// Add Variable binding to Variable binding list
// Insert new Object Identifier / Property Hash entries for newly created object

		ULONG t_Index = 0 ;
		t_RequestSnmpObject->ResetProperty () ;
		while ( property = t_RequestSnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				if ( property->IsSNMPV1Type () )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifier t_CurrentIdentifier ( 0 , NULL ) ;
								SnmpObjectIdentifier t_StartIdentifier ( 0 , NULL ) ;
								LONG t_Scoped = EvaluateInitialVarBind ( 

									t_Index , 
									t_CurrentIdentifier , 
									t_StartIdentifier 
								) ;

								m_PropertyContainer [ t_Index ].m_Property = property ;

								SnmpObjectIdentifierType requestIdentifierType ( * ( SnmpObjectIdentifierType * ) value ) ;

								SnmpObjectIdentifier t_RequestIdentifier = * ( SnmpObjectIdentifier * ) requestIdentifierType.GetValueEncoding () ; 

								SnmpVarBind t_VarBind ( t_RequestIdentifier , snmpNull ) ;
								varBindList.Add ( t_VarBind ) ;

								if ( t_Scoped > 0 )
								{
									t_RequestIdentifier = t_RequestIdentifier + t_StartIdentifier ;
								}

// Add Variable binding to list

								SnmpVarBind t_StartVarBind ( t_RequestIdentifier , snmpNull ) ;
								startVarBindList.Add ( t_StartVarBind ) ;

								t_Index ++ ;
							}
						}
					}
					else
					{
// Don't Send properties marked as virtual key
					} 
				}
			} 
/*
 *	Initialise value to NULL
 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;

		}

// Finally Send request

		SendRequest ( varBindList , startVarBindList ) ;
	}
	else
	{
	}
}

LONG AutoRetrieveOperation :: EvaluateNextRequest (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN SnmpVarBind &sendVarBind
)
{
	LONG t_Evaluation = 0 ;

	PartitionSet *t_Partition = eventObject->GetPartitionSet () ;
	if ( t_Partition )
	{
		BOOL t_Status = TRUE ;

		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;
		SnmpObjectIdentifier t_DecodeObject = replyVarBind.GetInstance () ;

		ULONG t_Index = 0 ;
		WbemSnmpProperty *t_Property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( t_Status && ( t_Property = t_SnmpObject->NextKeyProperty () ) )
		{
// For each Key in Key Order consume instance information

			SnmpInstanceType *t_DecodeValue = t_Property->GetValue () ;
			t_DecodeObject = t_DecodeValue->Decode ( t_DecodeObject ) ;

			SnmpObjectIdentifier t_Encode ( 0 , NULL ) ;
			t_Encode = t_DecodeValue->Encode ( t_Encode ) ;

			m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index + 1 ] = ( SnmpObjectIdentifier * ) t_Encode.Copy () ;
			t_Index ++ ;
		}

		SnmpObjectIdentifier t_AdvanceObjectIdentifier ( 0 , NULL ) ;

		t_Evaluation = EvaluateResponse (

			var_bind_index - 1 ,
			t_KeyCount ,
			t_AdvanceObjectIdentifier
		) ;

		if ( t_Evaluation > 0 )
		{
			SnmpNull t_SnmpNull ;
			SnmpVarBind t_VarBind ( t_AdvanceObjectIdentifier , t_SnmpNull ) ;
			sendVarBind = t_VarBind ;
		}

		for ( t_Index = 0 ; t_Index < m_PropertyContainer [ var_bind_index - 1 ].m_KeyCount ; t_Index ++ )
		{
			delete m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index ] ;
			m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index ] = NULL ;
		}
	}

	return t_Evaluation ;
}

LONG AutoRetrieveOperation :: EvaluateResponse (

	IN ULONG a_PropertyIndex ,
	IN ULONG &a_CurrentIndex ,
	IN SnmpObjectIdentifier &a_AdvanceObjectIdentifier 
)
{
	LONG t_Evaluation = 0 ;
	BOOL t_UseStartAsAdvance = FALSE ;

	for ( ULONG t_Index = 0 ; t_Index < m_PropertyContainer [ a_PropertyIndex ].m_KeyCount ; t_Index ++ )
	{
		SnmpObjectIdentifier *t_Encode = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ t_Index + 1 ] ;
		SnmpObjectIdentifier *t_Start = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index + 1 ] ;
		if ( t_Start )
		{
/*
 *	We have a start which is not negatively infinite
 */
			if ( *t_Encode > *t_Start )
			{
/*
 *	The encoded object from the device is greater than the start value, so add the encoded value
 *  to the running total.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}			
			else if ( *t_Encode == *t_Start )
			{
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}
			else
			{

/*
 * Encoded value is less than start value so we need to advance to the start value
 */

				t_UseStartAsAdvance = TRUE ;

/*
 *	The encoded object from the device is less than the start value, so add the encoded value
 *  to the running total.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Start ;
			}
		}
		else
		{
/*
 * Start is negatively infinite
 */
			if ( t_UseStartAsAdvance )
			{
/*
 *	We have already identified a starting position which is greater than the encoded value.
 *  The new value is a negative infinite so we should stop here
 */
				t_Index ++ ;
				break ;
			}
			else
			{
/*
 *	The start position is negatively infinite and we haven't had to use a different value from the one
 *  returned from the device.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}
		}


/*
 * The value was not taken from the start value with an 
 * infinite range on next key index, so we must check to see if the range is less than the 'end'
 */

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index + 1 ] ;
		SnmpRangeNode *t_Range = t_KeyPartition->GetRange () ;
		SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index + 1 ] ;
		if ( t_End )
		{
			BOOL t_InRange = ( ( t_Range->ClosedUpperBound () && ( *t_Encode <= *t_End ) ) ||
							 ( ! t_Range->ClosedUpperBound () && ( *t_Encode < *t_End ) ) ) ;

			
			if ( t_InRange )
			{
/*
 *	We are still within the boundaries
 */
			}
			else
			{
/*
*  Move to new partition because we have moved past end 
*/

				SnmpObjectIdentifier t_StartObjectIdentifier ( 0 , NULL ) ;

/*
 *	Advance to the next partition, we will use the next partition starting point for next request
 */
				t_Evaluation = EvaluateSubsequentVarBind ( 

					a_PropertyIndex , 
					a_CurrentIndex ,
					a_AdvanceObjectIdentifier ,
					t_StartObjectIdentifier 
				) ;

				if ( t_Evaluation >= 0 )
				{
					a_AdvanceObjectIdentifier = t_StartObjectIdentifier ;
				}

				t_UseStartAsAdvance = FALSE ;

				t_Index ++ ;
				break ;
			}
		}
		else
		{
/*
 *	Range is infinite so go on to next
 */
		}
	}

	if ( t_UseStartAsAdvance ) 
	{
/*
 *	We have got all the way to the end without move to the end of a partition and have used new start position
 */

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		SnmpRangeNode *t_Range = t_KeyPartition->GetRange () ;

		if( t_Range->ClosedLowerBound () )
		{
			if ( ! DecrementObjectIdentifier ( a_AdvanceObjectIdentifier , a_AdvanceObjectIdentifier ) )
			{
				t_Evaluation = -1 ;
				return t_Evaluation ;
			}
		}

		t_Evaluation = 1 ;
	}

	return t_Evaluation ;
}

LONG AutoRetrieveOperation :: EvaluateInitialVarBind ( 

	ULONG a_PropertyIndex ,
	SnmpObjectIdentifier &a_CurrentIdentifier ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = -1 ;

	PartitionSet *t_Partition = eventObject->GetPartitionSet () ;
	if ( t_Partition )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

		if ( ! m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex )
		{
			m_PropertyContainer [ a_PropertyIndex ].m_KeyCount = t_KeyCount ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition  = new PartitionSet * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex = new ULONG [ t_KeyCount + 1 ] ;

			for ( ULONG t_Index = 0 ; t_Index <= t_KeyCount ; t_Index ++ ) 
			{
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ t_Index ] = 0 ;
				m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] = t_Partition ;
				t_Partition = t_Partition->GetPartition ( 0 ) ;
			}

			t_Scoped = EvaluateVarBind ( a_PropertyIndex , a_StartIdentifier ) ;
		}
	}

	return t_Scoped ;
}

LONG AutoRetrieveOperation :: EvaluateSubsequentVarBind ( 

	ULONG a_PropertyIndex ,
	ULONG &a_CurrentIndex ,
	SnmpObjectIdentifier &a_CurrentIdentifier ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = -1 ;

	SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
	ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

	BOOL t_Complete = FALSE ;

	BOOL t_AdvanceInsidePartition = FALSE ;

	while ( ! t_Complete )
	{
		if ( a_CurrentIndex > 0 )
		{
			if ( t_AdvanceInsidePartition )
			{
				SnmpObjectIdentifier *t_Encode = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ a_CurrentIndex ] ;

				BOOL t_Incremented = IncrementObjectIdentifier ( *t_Encode , *t_Encode ) ;
				if ( t_Incremented )
				{
					t_Scoped = EvaluateResponse ( 

						a_PropertyIndex ,
						a_CurrentIndex ,
						a_StartIdentifier
					) ;

					t_Complete = TRUE ;
				}
				else
				{
/*
*	Increment failed so next time around loop to next partition
*/
					t_AdvanceInsidePartition = FALSE ;
				}
			}
			else
			{
/*
*	Get the current partition index and increment to get next possible partition index
*/
				ULONG t_PartitionIndex = m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ a_CurrentIndex - 1 ] + 1 ;

/*
* Get the parent partition set associated with the current key partition
*/

				PartitionSet *t_ParentPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition  [ a_CurrentIndex - 1 ] ;

/*
*	Check there are more partitions left to scan
*/
				if ( t_PartitionIndex >= t_ParentPartition->GetPartitionCount () )
				{
					if ( ! t_AdvanceInsidePartition )
					{
/*
*	Reset the current partition value to NULL object identifier
*/

						*m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ a_CurrentIndex ] = SnmpObjectIdentifier ( 0 , NULL ) ;

/*
* No more partitions for this key, move to previous key and attempt to get next value for that key
*/
						t_AdvanceInsidePartition = TRUE ;
						a_CurrentIndex -- ;
					}
				}
				else
				{
/*
* More partitions for this key
*
* Set the partition for the current ( keyindex == t_CurrentIndex - 1 ) to t_PartitionIndex 
*/

					m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ a_CurrentIndex - 1 ] = t_PartitionIndex ;
/*
* Move to the next partition for ( keyIndex == t_CurrentIndex - 1 ) and t_PartitionIndex
*/
					m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ a_CurrentIndex ] = t_ParentPartition->GetPartition ( t_PartitionIndex ) ;

					for ( ULONG t_Index = a_CurrentIndex + 1 ; t_Index < t_KeyCount ; t_Index ++ )
					{
						m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ t_Index ] = 0 ;
					}

					t_Scoped = EvaluateVarBind ( a_PropertyIndex , a_StartIdentifier ) ;
					if ( a_StartIdentifier >= a_CurrentIdentifier ) 
					{
						t_Complete = TRUE ;
					}
				}
			}
		}
		else
		{
			t_Scoped = -1 ;
			t_Complete = TRUE ;
		}
	}

	return t_Scoped ;
}

LONG AutoRetrieveOperation :: EvaluateVarBind ( 

	ULONG a_PropertyIndex ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = 0 ;

	SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
	ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

	BOOL t_FoundInfinite = FALSE ;

	WbemSnmpProperty *t_KeyProperty = NULL ;
	t_SnmpObject->ResetKeyProperty () ;
	for ( ULONG t_Index = 1 ; t_Index <= t_KeyCount ; t_Index ++ ) 
	{
		t_KeyProperty = t_SnmpObject->NextKeyProperty () ;

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		SnmpRangeNode *t_Range = t_KeyPartition->GetRange () ;
		
		if ( t_Range->InfiniteLowerBound () )
		{
			t_FoundInfinite = TRUE ;
		}
		else
		{
			t_Scoped = 1 ;

			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] = new SnmpObjectIdentifier ( 0 , NULL ) ;

			if ( typeid ( *t_Range ) == typeid ( SnmpUnsignedIntegerRangeNode ) )
			{
				SnmpUnsignedIntegerRangeNode *t_Node = ( SnmpUnsignedIntegerRangeNode * ) t_Range ;
				ULONG t_Integer = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
			else if ( typeid ( *t_Range ) == typeid ( SnmpSignedIntegerRangeNode ) )
			{
				SnmpSignedIntegerRangeNode *t_Node = ( SnmpSignedIntegerRangeNode * ) t_Range  ;
				LONG t_Integer = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
			if ( typeid ( *t_Range ) == typeid ( SnmpStringRangeNode ) )
			{
				SnmpStringRangeNode *t_Node = ( SnmpStringRangeNode * ) t_Range ;
				BSTR t_String = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( t_String ) ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}

		if ( ( t_Index == t_KeyCount ) && t_Range->ClosedLowerBound () )
		{
			BOOL t_Decremented = DecrementObjectIdentifier ( 

				a_StartIdentifier , 
				a_StartIdentifier
			) ;
			
			t_Scoped = t_Decremented ? 1 : 0 ;
		}
	}

	t_SnmpObject->ResetKeyProperty () ;
	for ( t_Index = 1 ; t_Index <= t_KeyCount ; t_Index ++ ) 
	{
		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		SnmpRangeNode *t_Range = t_KeyPartition->GetRange () ;

		t_KeyProperty = t_SnmpObject->NextKeyProperty () ;

		if ( ! t_Range->InfiniteUpperBound () )
		{
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = new SnmpObjectIdentifier ( 0 , NULL ) ;
			
			if ( typeid ( *t_Range ) == typeid ( SnmpUnsignedIntegerRangeNode ) )
			{
				SnmpUnsignedIntegerRangeNode *t_Node = ( SnmpUnsignedIntegerRangeNode * ) t_Range ;
				ULONG t_Integer = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ]  ) ;

				VariantClear ( & t_Variant ) ;
			}
			else if ( typeid ( *t_Range ) == typeid ( SnmpSignedIntegerRangeNode ) )
			{
				SnmpSignedIntegerRangeNode *t_Node = ( SnmpSignedIntegerRangeNode * ) t_Range  ;
				LONG t_Integer = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ]  ) ;

				VariantClear ( & t_Variant ) ;
			}
			if ( typeid ( *t_Range ) == typeid ( SnmpStringRangeNode ) )
			{
				SnmpStringRangeNode *t_Node = ( SnmpStringRangeNode * ) t_Range ;
				BSTR t_String = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( t_String ) ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ) ;

				VariantClear ( & t_Variant ) ;
			}

			if ( t_Range->ClosedUpperBound () )
			{
				SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ;
				if ( IncrementObjectIdentifier ( * t_End , * t_End ) )
				{
				}
				else
				{
					delete m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ;
					m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL ;
				}
			}
		}
	}

	return t_Scoped ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\snmpobj.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <winerror.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpobj.h>

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> mibTypeMap ;

BOOL InitialiseMibTypeMap ()
{
	mibTypeMap [ WBEM_TYPE_INTEGER ]			= WBEM_INDEX_TYPE_INTEGER ;
	mibTypeMap [ WBEM_TYPE_INTEGER32 ]			= WBEM_INDEX_TYPE_INTEGER32 ;
	mibTypeMap [ WBEM_TYPE_OCTETSTRING ]		= WBEM_INDEX_TYPE_OCTETSTRING ;
	mibTypeMap [ WBEM_TYPE_OBJECTIDENTIFIER ]	= WBEM_INDEX_TYPE_OBJECTIDENTIFIER ;
	mibTypeMap [ WBEM_TYPE_NULL ]				= WBEM_INDEX_TYPE_NULL ;
	mibTypeMap [ WBEM_TYPE_IPADDRESS ]			= WBEM_INDEX_TYPE_IPADDRESS ;
	mibTypeMap [ WBEM_TYPE_COUNTER ]			= WBEM_INDEX_TYPE_COUNTER ;
	mibTypeMap [ WBEM_TYPE_GAUGE ]				= WBEM_INDEX_TYPE_GAUGE ;
	mibTypeMap [ WBEM_TYPE_TIMETICKS ]			= WBEM_INDEX_TYPE_TIMETICKS ;
	mibTypeMap [ WBEM_TYPE_OPAQUE ]			= WBEM_INDEX_TYPE_OPAQUE ;
	mibTypeMap [ WBEM_TYPE_NETWORKADDRESS ]	= WBEM_INDEX_TYPE_NETWORKADDRESS ;
	mibTypeMap [ WBEM_TYPE_COUNTER32 ]			= WBEM_INDEX_TYPE_COUNTER32 ;
	mibTypeMap [ WBEM_TYPE_COUNTER64 ]			= WBEM_INDEX_TYPE_COUNTER64 ;
	mibTypeMap [ WBEM_TYPE_GAUGE32 ]			= WBEM_INDEX_TYPE_GAUGE32 ;
	mibTypeMap [ WBEM_TYPE_UNSIGNED32 ]		= WBEM_INDEX_TYPE_UNSIGNED32;

	return TRUE ;
}

BOOL initialisedMibTypeMap = InitialiseMibTypeMap () ;

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> textualConventionMap ;

BOOL InitialiseTextualConventionMap ()
{
	textualConventionMap [ WBEM_TYPE_INTEGER ]				= WBEM_INDEX_TYPE_INTEGER ;
	textualConventionMap [ WBEM_TYPE_INTEGER32 ]			= WBEM_INDEX_TYPE_INTEGER32 ;
	textualConventionMap [ WBEM_TYPE_OCTETSTRING ]			= WBEM_INDEX_TYPE_OCTETSTRING ;
	textualConventionMap [ WBEM_TYPE_OBJECTIDENTIFIER ]	= WBEM_INDEX_TYPE_OBJECTIDENTIFIER ;
	textualConventionMap [ WBEM_TYPE_NULL ]				= WBEM_INDEX_TYPE_NULL ;
	textualConventionMap [ WBEM_TYPE_IPADDRESS ]			= WBEM_INDEX_TYPE_IPADDRESS ;
	textualConventionMap [ WBEM_TYPE_COUNTER ]				= WBEM_INDEX_TYPE_COUNTER ;
	textualConventionMap [ WBEM_TYPE_GAUGE ]				= WBEM_INDEX_TYPE_GAUGE ;
	textualConventionMap [ WBEM_TYPE_TIMETICKS ]			= WBEM_INDEX_TYPE_TIMETICKS ;
	textualConventionMap [ WBEM_TYPE_OPAQUE ]				= WBEM_INDEX_TYPE_OPAQUE ;
	textualConventionMap [ WBEM_TYPE_NETWORKADDRESS ]		= WBEM_INDEX_TYPE_NETWORKADDRESS ;
	textualConventionMap [ WBEM_TYPE_DISPLAYSTRING ]		= WBEM_INDEX_TYPE_DISPLAYSTRING ;
	textualConventionMap [ WBEM_TYPE_MACADDRESS ]			= WBEM_INDEX_TYPE_MACADDRESS ;
	textualConventionMap [ WBEM_TYPE_PHYSADDRESS ]			= WBEM_INDEX_TYPE_PHYSADDRESS ;
	textualConventionMap [ WBEM_TYPE_ENUMERATEDINTEGER ]	= WBEM_INDEX_TYPE_ENUMERATEDINTEGER ;
	textualConventionMap [ WBEM_TYPE_COUNTER32 ]			= WBEM_INDEX_TYPE_COUNTER32 ;
	textualConventionMap [ WBEM_TYPE_COUNTER64 ]			= WBEM_INDEX_TYPE_COUNTER64 ;
	textualConventionMap [ WBEM_TYPE_GAUGE32 ]				= WBEM_INDEX_TYPE_GAUGE32 ;
	textualConventionMap [ WBEM_TYPE_UNSIGNED32 ]			= WBEM_INDEX_TYPE_UNSIGNED32 ;
	textualConventionMap [ WBEM_TYPE_DATETIME ]			= WBEM_INDEX_TYPE_DATETIME ;
	textualConventionMap [ WBEM_TYPE_BITS ]				= WBEM_INDEX_TYPE_BITS ;
	textualConventionMap [ WBEM_TYPE_SNMPOSIADDRESS ]		= WBEM_INDEX_TYPE_SNMPOSIADDRESS ;
	textualConventionMap [ WBEM_TYPE_SNMPUDPADDRESS ]		= WBEM_INDEX_TYPE_SNMPUDPADDRESS ;
	textualConventionMap [ WBEM_TYPE_SNMPIPXADDRESS ]		= WBEM_INDEX_TYPE_SNMPIPXADDRESS ;
	textualConventionMap [ WBEM_TYPE_ROWSTATUS ]		= WBEM_INDEX_TYPE_ROWSTATUS ;
	return TRUE ;
}

BOOL initialisedTextualConventionMap = InitialiseTextualConventionMap () ;

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> validQualifierMap ;

BOOL InitialiseQualifierMap ()
{
	validQualifierMap [ WBEM_QUALIFIER_TEXTUAL_CONVENTION ]			= WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION ;
	validQualifierMap [ WBEM_QUALIFIER_SYNTAX ]						= WBEM_INDEX_QUALIFIER_SYNTAX ;
	validQualifierMap [ WBEM_QUALIFIER_OBJECT_IDENTIFIER ]				= WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER ;
	validQualifierMap [ WBEM_QUALIFIER_ENCODING ]						= WBEM_INDEX_QUALIFIER_ENCODING ;
	validQualifierMap [ WBEM_QUALIFIER_FIXED_LENGTH ]					= WBEM_INDEX_QUALIFIER_FIXED_LENGTH ;
	validQualifierMap [ WBEM_QUALIFIER_VARIABLE_LENGTH ]				= WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH ;
	validQualifierMap [ WBEM_QUALIFIER_VARIABLE_VALUE ]				= WBEM_INDEX_QUALIFIER_VARIABLE_VALUE ;
	validQualifierMap [ WBEM_QUALIFIER_ENUMERATION ]					= WBEM_INDEX_QUALIFIER_ENUMERATION ;
	validQualifierMap [ WBEM_QUALIFIER_BITS ]							= WBEM_INDEX_QUALIFIER_BITS ;
	validQualifierMap [ WBEM_QUALIFIER_DISPLAY_HINT ]					= WBEM_INDEX_QUALIFIER_DISPLAY_HINT ;
	validQualifierMap [ WBEM_QUALIFIER_KEY ]							= WBEM_INDEX_QUALIFIER_KEY ;
	validQualifierMap [ WBEM_QUALIFIER_KEY_ORDER ]						= WBEM_INDEX_QUALIFIER_KEY_ORDER ;
	validQualifierMap [ WBEM_QUALIFIER_VIRTUAL_KEY ]					= WBEM_INDEX_QUALIFIER_VIRTUAL_KEY ;
	validQualifierMap [ WBEM_QUALIFIER_READ ]							= WBEM_INDEX_QUALIFIER_READ ;
	validQualifierMap [ WBEM_QUALIFIER_WRITE ]							= WBEM_INDEX_QUALIFIER_WRITE ;
	validQualifierMap [ WBEM_QUALIFIER_NOT_AVAILABLE ]					= WBEM_INDEX_QUALIFIER_NOT_AVAILABLE ;
	validQualifierMap [ WBEM_QUALIFIER_TYPE_MISMATCH ]					= WBEM_INDEX_QUALIFIER_TYPE_MISMATCH ;
	validQualifierMap [ WBEM_QUALIFIER_VALUE_MISMATCH ]					= WBEM_INDEX_QUALIFIER_VALUE_MISMATCH ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTSNMPVERSION ]				= WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTTRANSPORT ]				= WBEM_INDEX_QUALIFIER_AGENTTRANSPORT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTADDRESS ]					= WBEM_INDEX_QUALIFIER_AGENTADDRESS ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME ]		= WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME ]		= WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTRETRYCOUNT ]				= WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTRETRYTIMEOUT ]				= WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTVARBINDSPERPDU ]			= WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ]	= WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ;
	validQualifierMap [ WBEM_QUALIFIER_SINGLETON ]					= WBEM_INDEX_QUALIFIER_SINGLETON ;
	validQualifierMap [ WBEM_QUALIFIER_TABLECLASS ]					= WBEM_INDEX_QUALIFIER_TABLECLASS;
	validQualifierMap [ WBEM_QUALIFIER_KEYTYPES ]					= WBEM_INDEX_QUALIFIER_KEYTYPES;
	validQualifierMap [ WBEM_QUALIFIER_KEYVALUES ]					= WBEM_INDEX_QUALIFIER_KEYVALUES;
	validQualifierMap [ WBEM_QUALIFIER_VARBINDINDEX ]				= WBEM_INDEX_QUALIFIER_VARBINDINDEX;
	validQualifierMap [ WBEM_QUALIFIER_ROWSTATUS ]				= WBEM_INDEX_QUALIFIER_ROWSTATUS;

	return TRUE ;
}

BOOL initialisedQualifierMap = InitialiseQualifierMap () ;

WbemSnmpQualifier  :: WbemSnmpQualifier (

	const wchar_t *qualifierNameArg ,
	const SnmpInstanceType *typeValueArg 

) : typeValue ( NULL ) 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValueArg ) ? typeValueArg->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: WbemSnmpQualifier ( const wchar_t *qualifierNameArg = (%s) , const SnmpInstanceType *typeValueArg = (%lx),(%s) )" ,
			qualifierNameArg ,
			typeValueArg ,
			t_StringValue
		) ;
	}
	else
	{ 
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: WbemSnmpQualifier ( const wchar_t *qualifierNameArg = (%s) , const SnmpInstanceType *typeValueArg = (NULL) )" ,
			qualifierNameArg ,
			typeValueArg
		) ;
	}
	delete [] t_StringValue ;


)

	qualifierName = new wchar_t [ wcslen ( qualifierNameArg ) + 1 ] ;
	wcscpy ( qualifierName , qualifierNameArg ) ;

	if ( typeValueArg )
	{
		typeValue = typeValueArg->Copy () ;
	}
}

WbemSnmpQualifier :: WbemSnmpQualifier ( const WbemSnmpQualifier &copy ) 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( copy.typeValue ) ? copy.typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: const WbemSnmpQualifier &copy (%s),(%s) )" , 
			copy.qualifierName ,
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: const WbemSnmpQualifier &copy (%s),(NULL)" ,
			copy.qualifierName 
		) ;
	}

	delete [] t_StringValue ;
)

	qualifierName = new wchar_t [ wcslen ( copy.qualifierName ) + 1 ] ;
	wcscpy ( qualifierName , copy.qualifierName ) ;

	if ( copy.typeValue )
	{
		typeValue = copy.typeValue->Copy () ;
	}
}

WbemSnmpQualifier :: ~WbemSnmpQualifier () 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,L"WbemSnmpQualifier :: ~WbemSnmpQualifier ( (%s),(%s) )" ,
			qualifierName ,
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,L"WbemSnmpQualifier :: ~WbemSnmpQualifier ( (%s),(NULL) )" ,
			qualifierName 
		) ;
	}

	delete [] t_StringValue ;
)

	delete [] qualifierName ;
	delete typeValue ;
}

wchar_t *WbemSnmpQualifier :: GetName () const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpQualifier :: GetName ( %s )" ,
		qualifierName
	) 
)

	return qualifierName ;
}

SnmpInstanceType *WbemSnmpQualifier :: GetValue () const 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( (%s), (%s) )" ,
			qualifierName ,
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( (%s) , (NULL) )" ,
			qualifierName
		) ;
	}

	delete [] t_StringValue ;
) 

	return typeValue ;
}

BOOL WbemSnmpQualifier :: GetValue ( VARIANT &variant ) const
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( VARIANT &variant ( (%s),(%s) )" ,
			qualifierName ,
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( VARIANT &variant ( (%s),(NULL) )" ,
			qualifierName
		) ;
	}

	delete [] t_StringValue ;
) 

	BOOL status = TRUE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpObjectIdentifierType ) ) 
				{
					SnmpObjectIdentifierType *objectIdentifier = ( SnmpObjectIdentifierType * ) typeValue ;
					wchar_t *string = objectIdentifier ->GetStringValue () ;
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( string ) ;
					delete [] string ;
				}	
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( string ) ;
					delete [] string ;
				}	
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) ) 
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					variant.vt = VT_BOOL ;
					variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) ) 
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					variant.vt = VT_I4 ;
					variant.lVal = integer->GetValue () ;
				}
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}
			break ;

			default:
			{
				status = FALSE ;
				variant.vt = VT_NULL ;
			}
		}
	}
	else
	{
		status = FALSE ;
		variant.vt = VT_NULL ;
	}

	return status ;
}

VARTYPE WbemSnmpQualifier :: GetValueVariantType () const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpQualifier :: GetValueVariantType ()" ) ) 

	VARTYPE varType = VT_NULL ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				varType = VT_BSTR ;
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				varType = VT_BOOL ;
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				varType = VT_I4 ;
			}
			break ;

			default:
			{
				varType = VT_NULL ;
			}
		}
	}
	else
	{
		varType = VT_NULL ;
	}

	return varType ;
}

BOOL WbemSnmpQualifier :: IsPropagatable () const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpQualifier :: IsPropagatable ()" ) ) 

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				status = FALSE ;
			}
			break ;

			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			{
				status = TRUE ;
			}
			break ;

			default:
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( IWbemQualifierSet *a_Qualifier , const SnmpInstanceType &value ) 
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	t_Variant.vt = VT_NULL ;

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( (typeid ( value ) == typeid ( SnmpDisplayStringType )) && typeValue) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) & value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
						SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *string = displayString->GetValue () ;
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( string ) ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( ( typeid ( value ) == typeid ( SnmpDisplayStringType ) ) && typeValue ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) & value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
						SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *string = displayString->GetValue () ;
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( string ) ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( (typeid ( value ) == typeid ( SnmpObjectIdentifierType ) ) && typeValue )
				{
					status = TRUE ;
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( string ) ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( ( typeid ( value ) == typeid ( SnmpDisplayStringType ) ) && typeValue) 
				{
					status = TRUE ;
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( string ) ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			{
				if ( typeid ( value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = typeValue ? ( SnmpIntegerType * ) typeValue : ( SnmpIntegerType * ) &value;
					t_Variant.vt = VT_BOOL ;
					t_Variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( ( typeid ( value ) == typeid ( SnmpIntegerType ) ) && typeValue) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					t_Variant.vt = VT_BOOL ;
					t_Variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( ( typeid ( value ) == typeid ( SnmpIntegerType ) ) && typeValue ) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					t_Variant.vt = VT_I4 ;
					t_Variant.lVal = integer->GetValue () ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value.IsValid () )
		{
			a_Qualifier->Put ( qualifierName , &t_Variant , WBEM_CLASS_PROPAGATION ) ;
		}
		else
		{
			status = FALSE ;
		}

		VariantClear ( &t_Variant ) ;
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ) 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ( (%s),(%s) ) )" ,
			qualifierName , 
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ( (%s),(NULL) ) )" ,
			qualifierName 
		) ;
	}

	delete [] t_StringValue ;
) 

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
					}

					delete [] string ;
				}
			}
			break ;


			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
				{
					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value && value->IsValid () )
		{
			delete typeValue  ;
			typeValue = value->Copy () ;
		}
		else
		{
			status = FALSE ;
		}
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( const VARIANT &variant ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpQualifier :: SetValue ( const VARIANT &variant )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( variant.vt == VT_BSTR )
				{
					ULONG stringItem ;
					wchar_t *string = variant.bstrVal ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						value = new SnmpDisplayStringType ( string , NULL ) ;
						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( variant.vt == VT_BSTR )
				{
					ULONG stringItem ;
					wchar_t *string = variant.bstrVal ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						value = new SnmpDisplayStringType ( string , NULL ) ;
						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( variant.vt == VT_BSTR )
				{
					value = new SnmpObjectIdentifierType ( variant.bstrVal ) ;
					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_BITS:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( variant.vt == VT_BSTR )
				{
					value = new SnmpDisplayStringType ( variant.bstrVal , NULL ) ;
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( variant.vt == VT_UI1 )
				{
					value = new SnmpIntegerType ( variant.bVal , NULL ) ;
					status = TRUE ;
				}
				else if ( variant.vt == VT_I4 )
				{
					value = new SnmpIntegerType ( variant.lVal , NULL ) ;
					status = TRUE ;

				}
				else if ( variant.vt == VT_BOOL )
				{
					value = new SnmpIntegerType ( (variant.boolVal == VARIANT_FALSE) ? 0 : 1, NULL ) ;
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( variant.vt == VT_UI1 )
				{
					value = new SnmpIntegerType ( variant.bVal , NULL ) ;
					status = TRUE ;
				}
				else if ( variant.vt == VT_I4 )
				{
					value = new SnmpIntegerType ( variant.lVal , NULL ) ;
					status = TRUE ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value && value->IsValid () ) 
		{
			typeValue = value ;
		}
		else
		{
			status = FALSE ;
			delete value ;
		}
	}
	else
	{
		delete value ;
	}

	return status ;
}

WbemSnmpProperty :: WbemSnmpProperty ( const wchar_t *propertyNameArg ) : propertyValue ( NULL ) ,  
																		qualifierPosition ( NULL ) , 
																		tagged ( FALSE ) ,
																		m_IsNull ( TRUE ) ,
																		m_isKey ( FALSE ) ,
																		m_isVirtualKey ( FALSE ) ,
																		m_isReadable ( FALSE ) ,
																		m_isWritable ( FALSE ) ,
																		m_keyOrder ( 0 ) ,
																		m_TextualConvention ( 0 ) ,
																		m_Handle ( 0 ) 

{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: WbemSnmpProperty ( const wchar_t *propertyNameArg (%s) )" ,
		propertyNameArg
	) ;
) 

	propertyValue = new SnmpNullType ;
	propertyName = new wchar_t [ wcslen ( propertyNameArg ) + 1 ] ;
	wcscpy ( propertyName , propertyNameArg ) ;
}

WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ) :	propertyValue ( NULL ) , 
																		qualifierPosition ( NULL ) , 
																		tagged ( FALSE ) ,
																		m_IsNull ( TRUE ) ,
																		m_isKey ( FALSE ) ,
																		m_isVirtualKey ( FALSE ) ,
																		m_isReadable ( FALSE ) ,
																		m_isWritable ( FALSE ) ,
																		m_TextualConvention ( 0 ) ,
																		m_Handle ( 0 ) 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ( (%s),(%s)) )" ,
			copy.propertyName ,
			t_StringValue 
		) ; 
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ( (%s),(NULL))" ,
			copy.propertyName 
		) ; 
	}
	
	delete [] t_StringValue ;
) 

	m_isReadable = copy.m_isReadable ;
	m_isWritable = copy.m_isWritable ;
	m_isKey = copy.m_isKey ;
	m_isVirtualKey = copy.m_isVirtualKey ;
	m_IsNull = copy.m_IsNull ;
	tagged = copy.tagged ;
	m_keyOrder = copy.m_keyOrder ;
	m_TextualConvention = copy.m_TextualConvention ;
	m_Handle = copy.m_Handle ;

	if ( copy.propertyValue )
	{
		propertyValue = copy.propertyValue->Copy () ;
	}

	if ( copy.propertyName )
	{
		propertyName = new wchar_t [ wcslen ( copy.propertyName ) + 1 ] ;
		wcscpy ( propertyName , copy.propertyName ) ;
	}

	POSITION position = copy.qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		copy.qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		WbemSnmpQualifier *copyQualifier = new WbemSnmpQualifier ( *qualifier ) ;
		qualifierMap [ copyQualifier->GetName () ] = copyQualifier ;
	}
}

WbemSnmpProperty :: ~WbemSnmpProperty () 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: ~WbemSnmpProperty ( ((%s),(%s)) )" ,
			propertyName ,
			t_StringValue 
		) ; 
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: ~WbemSnmpProperty ( ((%s),(NULL)) )" ,
			propertyName 
		) ; 
	}
	
	delete [] t_StringValue ;
) 

	delete [] propertyName ;
	delete propertyValue ;

	POSITION position = qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		delete qualifier ;
	}

	qualifierMap.RemoveAll () ;
}

void WbemSnmpProperty :: SetTag ( BOOL tag )
{
	tagged = tag ;
}

BOOL WbemSnmpProperty :: GetTag ()
{
	return tagged ;
}

BOOL WbemSnmpProperty :: IsNull ()
{
	if ( propertyValue )
		return propertyValue->IsNull () ;
	else
		return TRUE ;
}

BOOL WbemSnmpProperty :: IsKey () 
{ 
	return m_isKey ; 
}

BOOL WbemSnmpProperty :: IsVirtualKey () 
{ 
	return m_isVirtualKey ; 
}

void WbemSnmpProperty :: SetKey ( BOOL a_isKey )
{
	m_isKey = a_isKey ; 
}

void WbemSnmpProperty :: SetVirtualKey ( BOOL a_isVirtualKey ) 
{
	m_isVirtualKey = a_isVirtualKey ; 
}

BOOL WbemSnmpProperty :: IsWritable () 
{ 
	return m_isWritable ; 
}

BOOL WbemSnmpProperty :: IsReadable () 
{ 
	return m_isReadable ; 
}

ULONG WbemSnmpProperty :: GetKeyOrder () 
{ 
	return m_keyOrder ; 
}

void WbemSnmpProperty :: SetWritable ( BOOL a_isWritable )
{
	m_isWritable = a_isWritable ; 
}

void WbemSnmpProperty :: SetReadable ( BOOL a_isReadable ) 
{
	m_isReadable = a_isReadable ; 
}

void WbemSnmpProperty :: SetKeyOrder ( ULONG a_keyOrder ) 
{
	m_keyOrder = a_keyOrder ;
}

void WbemSnmpProperty :: SetTextualConvention ( ULONG a_TextualConvention ) 
{
	m_TextualConvention = a_TextualConvention ; 
}

ULONG WbemSnmpProperty :: GetTextualConvention () 
{
	return m_TextualConvention ; 
}

long WbemSnmpProperty :: GetHandle ()
{
	return m_Handle ;
}

void WbemSnmpProperty :: SetHandle ( long a_Handle ) 
{
	m_Handle = a_Handle ;
}

BOOL WbemSnmpProperty :: SetValue ( const VARIANT &variant , const CIMTYPE & type , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const VARIANT &variant )" ) ) 

	SnmpInstanceType *value = NULL ;
	if ( type == CIM_EMPTY )
	{
		value = new SnmpNullType ;
	}
	else
	{
		WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
		if ( qualifier )
		{	
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
			wchar_t *textualConvention = displayString->GetValue () ;
			if ( textualConvention )
			{ 
				ULONG qualifierIndex ;
				if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
				{
					switch ( qualifierIndex )
					{
						case WBEM_INDEX_TYPE_INTEGER:
						case WBEM_INDEX_TYPE_INTEGER32:
						{		
							if ( type == CIM_SINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpIntegerType ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIntegerType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER:
						case WBEM_INDEX_TYPE_COUNTER32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpCounterType ( variant.lVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpCounterType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER64:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpCounter64Type ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpCounter64Type ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_GAUGE:
						case WBEM_INDEX_TYPE_GAUGE32:
						case WBEM_INDEX_TYPE_UNSIGNED32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpGaugeType ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpGaugeType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OCTETSTRING:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthOctetStringType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthOctetStringType ( fixed ) ;
										}
									}
									else
									{
// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpOctetStringType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{											
												value = new SnmpOctetStringType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpOctetStringType ( variant.bstrVal , NULL ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpOctetStringType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpObjectIdentifierType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpObjectIdentifierType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NULL:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_NULL )
								{
									value = new SnmpNullType ;
								}
								else if ( variant.vt == VT_BSTR )
								{
									value = new SnmpNullType ;
								}
							}
						}
						break;

						case WBEM_INDEX_TYPE_IPADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpIpAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIpAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_TIMETICKS:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpTimeTicksType ( variant.lVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpTimeTicksType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OPAQUE:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthOpaqueType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthOpaqueType ( fixed ) ;
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpOpaqueType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{
												value = new SnmpOpaqueType ( rangeValues ) ;
												
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpOpaqueType ( variant.bstrVal , NULL ) ;
										}
										else
										{
											value = new SnmpOpaqueType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NETWORKADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpNetworkAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpNetworkAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DISPLAYSTRING:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthDisplayStringType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthDisplayStringType ( fixed ) ;
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpDisplayStringType ( variant.bstrVal , rangeValues ) ;
											}
											else
											{
												value = new SnmpDisplayStringType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpDisplayStringType ( variant.bstrVal , NULL ) ;
										}
										else
										{
											value = new SnmpDisplayStringType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_MACADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpMacAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpMacAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_PHYSADDRESS:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthPhysAddressType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthPhysAddressType ( fixed ) ;	
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpPhysAddressType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{
												value = new SnmpPhysAddressType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpPhysAddressType ( variant.bstrVal , NULL ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpPhysAddressType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *enumerationValues = string->GetStringValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpEnumeratedType ( enumerationValues , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpEnumeratedType ( enumerationValues ) ;
										}

										delete [] enumerationValues ;
									}
								}
							}
						}	
						break ;

						case WBEM_INDEX_TYPE_BITS:
						{
							if ( type == ( CIM_STRING | CIM_FLAG_ARRAY ) )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *bitStringValues = string->GetStringValue () ;

										if ( variant.vt == ( VT_BSTR | VT_ARRAY ) )
										{
											if ( SafeArrayGetDim ( variant.parray ) == 1 )
											{
												LONG dimension = 1 ; 
												LONG lower ;
												SafeArrayGetLBound ( variant.parray , dimension , & lower ) ;
												LONG upper ;
												SafeArrayGetUBound ( variant.parray , dimension , & upper ) ;
												LONG count = ( upper - lower ) + 1 ;

												wchar_t **array = new wchar_t * [ count ] ;

												for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
												{
													BSTR element ;
													SafeArrayGetElement ( variant.parray , &elementIndex , & element ) ;

													array [ elementIndex - lower ] = element ;
												}

												value = new SnmpBitStringType ( bitStringValues , ( const wchar_t ** ) array , count ) ;

												for ( elementIndex = 0 ; elementIndex < count ; elementIndex ++ )
												{
													SysFreeString ( array [ elementIndex ] ) ;
												}

												delete [] array ;
											}
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpBitStringType ( bitStringValues ) ;
										}

										delete [] bitStringValues ;
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DATETIME:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpDateTimeType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpDateTimeType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpOSIAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpOSIAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpUDPAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpUDPAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpIPXAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIPXAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ROWSTATUS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpRowStatusType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpRowStatusType ;
								}
							}
						}
						break ;

						default:
						{
						}
						break ;

					}
				}
			}

			delete [] textualConvention ;
		}
	}

	BOOL status = TRUE ;

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( const wchar_t *valueString , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const wchar_t *valueString )" ) ) 

	SnmpInstanceType *value = NULL ;
	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{
						value = new SnmpIntegerType ( valueString , NULL ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						value = new SnmpCounterType ( valueString ) ;
					}
					break ;


					case WBEM_INDEX_TYPE_COUNTER64:
					{
						value = new SnmpCounter64Type ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						value = new SnmpGaugeType ( valueString , NULL ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthOctetStringType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}
						}	
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpOctetStringType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpOctetStringType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						value = new SnmpObjectIdentifierType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
						value = new SnmpNullType ;
					}
					break ;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						value = new SnmpIpAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						value = new SnmpTimeTicksType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthOpaqueType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpOpaqueType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpOpaqueType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						value = new SnmpNetworkAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthDisplayStringType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}	
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpDisplayStringType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpDisplayStringType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						value = new SnmpMacAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthPhysAddressType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}	
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpPhysAddressType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpPhysAddressType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *enumerationValues = string->GetStringValue () ;
								value = new SnmpEnumeratedType ( enumerationValues , valueString ) ;
								delete [] enumerationValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *bitStringValues = string->GetStringValue () ;

								value = new SnmpBitStringType ( bitStringValues , NULL , 0 ) ;

								delete [] bitStringValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:
					{
						value = new SnmpDateTimeType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						value = new SnmpOSIAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						value = new SnmpUDPAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						value = new SnmpIPXAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						value = new SnmpRowStatusType ( valueString ) ;
					}
					break ;

					default:
					{
					}
					break ;

				}
			}
		}

		delete [] textualConvention ;
	}

	BOOL status = TRUE ;

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( const SnmpInstanceType *value , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpInstanceType *value )" ) ) 

	BOOL status = FALSE ;
	BOOL validValue = FALSE ;

	if ( value ) 
	{
		WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
		if ( qualifier )
		{	
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
			wchar_t *textualConvention = displayString->GetValue () ;
			if ( textualConvention )
			{ 
				ULONG qualifierIndex ;
				if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
				{
					switch ( qualifierIndex )
					{
						case WBEM_INDEX_TYPE_INTEGER:
						case WBEM_INDEX_TYPE_INTEGER32:
						{
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER:
						case WBEM_INDEX_TYPE_COUNTER32:
						{
							if ( typeid ( *value ) == typeid ( SnmpCounterType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER64:
						{
							if ( typeid ( *value ) == typeid ( SnmpCounter64Type ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_GAUGE:
						case WBEM_INDEX_TYPE_GAUGE32:
						case WBEM_INDEX_TYPE_UNSIGNED32:
						{
							if ( typeid ( *value ) == typeid ( SnmpGaugeType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OCTETSTRING:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthOctetStringType ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										validValue = TRUE ;

										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthOctetStringType *octetString = ( SnmpFixedLengthOctetStringType * ) value ;
										LONG octetStringFixed = octetString->GetValueLength () ;
										if ( fixed == octetStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpOctetStringType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
						{
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NULL:
						{
							if ( typeid ( *value ) == typeid ( SnmpNullType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_IPADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpIpAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_TIMETICKS:
						{
							if ( typeid ( *value ) == typeid ( SnmpTimeTicksType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OPAQUE:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthOpaqueType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthOpaqueType *opaque = ( SnmpFixedLengthOpaqueType * ) value ;
										LONG opaqueFixed = opaque->GetValueLength () ;
										if ( fixed == opaqueFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpOpaqueType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NETWORKADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpNetworkAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DISPLAYSTRING:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthDisplayStringType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthDisplayStringType *displayString = ( SnmpFixedLengthDisplayStringType * ) value ;
										LONG displayStringFixed = displayString->GetValueLength () ;
										if ( fixed == displayStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_MACADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpMacAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_PHYSADDRESS:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthPhysAddressType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthPhysAddressType *displayString = ( SnmpFixedLengthPhysAddressType * ) value ;
										LONG displayStringFixed = displayString->GetValueLength () ;
										if ( fixed == displayStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpPhysAddressType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
						{
							if ( typeid ( *value ) == typeid ( SnmpEnumeratedType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_BITS:
						{
							if ( typeid ( *value ) == typeid ( SnmpBitStringType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DATETIME:
						{
							if ( typeid ( *value ) == typeid ( SnmpDateTimeType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpOSIAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpUDPAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpIPXAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ROWSTATUS:
						{
							if ( typeid ( *value ) == typeid ( SnmpRowStatusType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						default:
						{
						}
						break ;

					}
				}

				if ( validValue )
				{
					switch ( check )
					{
						case SetValueRegardlessReturnCheck:
						{
							if ( value->IsValid () ) 
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
							}
							else
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
								status = FALSE ;
							}
						}
						break ;

						case SetValueRegardlessDontReturnCheck:
						{
							delete propertyValue ;
							propertyValue = value->Copy () ;
						}
						break ;

						case DontSetValueReturnCheck:
						{
							if ( value->IsValid () ) 
							{
							}
							else
							{
								status = FALSE ;
							}

						}
						break ;

						case SetValueIfCheckOk:
						{
							if ( value->IsValid () ) 
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
							}
							else
							{
								status = FALSE ;
							}
						}
						break ;
					}
				}
				else
				{
					status = FALSE ;
				}
			}

			delete [] textualConvention ;
		}
	}

	return status ;

}

BOOL WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{
						if ( ! valueArg )
						{
							value = new SnmpIntegerType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							value = new SnmpIntegerType ( *integer , NULL ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpCounterType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
						{
							SnmpCounter *counter = ( SnmpCounter * ) valueArg ;
							value = new SnmpCounterType ( *counter ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER64:
					{
						if ( ! valueArg )
						{
							value = new SnmpCounter64Type ;
						}
						else
						{
							SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
							value = new SnmpCounter64Type ( *counter ) ;
						}

						status = TRUE ;
					}
					break ;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						if ( ! valueArg )
						{
							value = new SnmpGaugeType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
						{
							SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
							value = new SnmpGaugeType ( *gauge , NULL ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthOctetStringType ( fixed ) ;
									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthOctetStringType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg ) 
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOctetStringType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOctetStringType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg ) 
								{
									value = new SnmpOctetStringType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpOctetStringType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpObjectIdentifierType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
						{
							SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
							value = new SnmpObjectIdentifierType ( *objectIdentifier ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
						if ( ! valueArg )
						{
							value = new SnmpNullType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpNull ) ) 
						{
							value = new SnmpNullType ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpIpAddressType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
						{
							SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
							value = new SnmpIpAddressType ( *ipAddress ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						if ( ! valueArg )
						{	
							value = new SnmpTimeTicksType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
						{
							SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
							value = new SnmpTimeTicksType ( *timeTicks ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthOpaqueType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;

									value = new SnmpFixedLengthOpaqueType ( fixed , *opaque ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOpaqueType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOpaqueType ( *opaque , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpOpaqueType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) ) 
								{
									SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
									value = new SnmpOpaqueType ( *opaque , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpNetworkAddressType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
						{
							SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
							value = new SnmpNetworkAddressType ( *ipAddress ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthDisplayStringType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthDisplayStringType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpDisplayStringType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpDisplayStringType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpDisplayStringType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpDisplayStringType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpMacAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpMacAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthPhysAddressType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthPhysAddressType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpPhysAddressType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpPhysAddressType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpPhysAddressType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpPhysAddressType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						if ( ! valueArg )
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *enumerationValues = string->GetStringValue () ;
									value = new SnmpEnumeratedType ( enumerationValues ) ;
									delete [] enumerationValues ;
									status = TRUE ;
								}
							}
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *enumerationValues = string->GetStringValue () ;
									value = new SnmpEnumeratedType ( enumerationValues , integer->GetValue () ) ;
									delete [] enumerationValues ;
									status = TRUE ;
								}
							}
						}		
					}
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						if ( ! valueArg )
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *bitStringValues = string->GetStringValue () ;

									value = new SnmpBitStringType ( bitStringValues ) ;
									status = TRUE ;

									delete [] bitStringValues ;
								}
							}
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *bitStringValues = string->GetStringValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpBitStringType ( bitStringValues , *octetString ) ;
									status = TRUE ;

									delete [] bitStringValues ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:					
					{
						if ( ! valueArg )
						{
							value = new SnmpDateTimeType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpDateTimeType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpOSIAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpOSIAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpUDPAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpUDPAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpIPXAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpIPXAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						if ( ! valueArg )
						{
							value = new SnmpRowStatusType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							value = new SnmpRowStatusType ( *integer ) ;
							status = TRUE ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

			delete [] textualConvention ;
		}
	}

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;

}

BOOL WbemSnmpProperty :: Encode ( const VARIANT &variant , SnmpObjectIdentifier &a_Encode )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: Encode ( const VARIANT &variant )" ) ) 

	BOOL t_Status = FALSE ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{		
						if ( variant.vt == VT_I4 )
						{
							SnmpIntegerType t_Integer ( variant.lVal , NULL ) ;
							a_Encode = t_Integer.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpCounterType t_Counter ( variant.lVal ) ;
							a_Encode = t_Counter.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER64:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpCounter64Type t_Counter ( variant.bstrVal ) ;
							a_Encode = t_Counter.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpGaugeType t_Gauge ( variant.lVal , NULL ) ;
							a_Encode = t_Gauge.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthOctetStringType t_Octet ( fixed , variant.bstrVal ) ;
									a_Encode = t_Octet.Encode ( a_Encode ) ;
								}
							}
							else
							{
// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpOctetStringType t_Octet ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_Octet.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpOctetStringType t_Octet ( variant.bstrVal , NULL ) ;
									a_Encode = t_Octet.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpObjectIdentifierType t_ObjectIdentifier ( variant.bstrVal ) ;
							a_Encode = t_ObjectIdentifier.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
					}
					break;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpIpAddressType t_IpAddress ( variant.bstrVal ) ;
							a_Encode = t_IpAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpTimeTicksType t_TimeTicks ( variant.lVal ) ;
							a_Encode = t_TimeTicks.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthOpaqueType t_Opaque ( fixed , variant.bstrVal ) ;
									a_Encode = t_Opaque.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpOpaqueType t_Opaque ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_Opaque.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpOpaqueType t_Opaque ( variant.bstrVal , NULL ) ;
									a_Encode = t_Opaque.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpNetworkAddressType t_NetworkAddress ( variant.bstrVal ) ;
							a_Encode = t_NetworkAddress.Encode ( a_Encode ) ;

						}
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthDisplayStringType t_DisplayString ( fixed , variant.bstrVal ) ;
									a_Encode = t_DisplayString.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpDisplayStringType t_DisplayString ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_DisplayString.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpDisplayStringType t_DisplayString ( variant.bstrVal , NULL ) ;
									a_Encode = t_DisplayString.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpMacAddressType t_MacAddress ( variant.bstrVal ) ;
							a_Encode = t_MacAddress.Encode ( a_Encode ) ;

						}
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthPhysAddressType t_PhysAddress ( fixed , variant.bstrVal ) ;
									a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpPhysAddressType t_PhysAddress ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpPhysAddressType t_PhysAddress ( variant.bstrVal , NULL ) ;
									a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *enumerationValues = string->GetStringValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpEnumeratedType t_Enumeration ( enumerationValues , variant.bstrVal ) ;
									a_Encode = t_Enumeration.Encode ( a_Encode ) ;
;								}

								delete [] enumerationValues ;
							}
						}
					}	
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *bitStringValues = string->GetStringValue () ;

								if ( variant.vt == ( VT_BSTR | VT_ARRAY ) )
								{
									if ( SafeArrayGetDim ( variant.parray ) == 1 )
									{
										LONG dimension = 1 ; 
										LONG lower ;
										SafeArrayGetLBound ( variant.parray , dimension , & lower ) ;
										LONG upper ;
										SafeArrayGetUBound ( variant.parray , dimension , & upper ) ;
										LONG count = ( upper - lower ) + 1 ;

										wchar_t **array = new wchar_t * [ count ] ;

										for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
										{
											BSTR element ;
											SafeArrayGetElement ( variant.parray , &elementIndex , & element ) ;

											array [ elementIndex - lower ] = element ;
										}

										SnmpBitStringType t_BitString ( bitStringValues , ( const wchar_t ** ) array , count ) ;
										a_Encode = t_BitString.Encode ( a_Encode ) ;

										for ( elementIndex = 0 ; elementIndex < count ; elementIndex ++ )
										{
											SysFreeString ( array [ elementIndex ] ) ;
										}

										delete [] array ;
									}
								}

								delete [] bitStringValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpDateTimeType t_DateTime ( variant.bstrVal ) ;
							a_Encode = t_DateTime.SnmpOctetStringType :: Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpOSIAddressType t_OSIAddress ( variant.bstrVal ) ;
							a_Encode = t_OSIAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpUDPAddressType t_UDPAddress ( variant.bstrVal ) ;
							a_Encode = t_UDPAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpIPXAddressType t_IPXAddress ( variant.bstrVal ) ;
							a_Encode = t_IPXAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpRowStatusType t_RowStatus ( variant.bstrVal ) ;
							a_Encode = t_RowStatus.Encode ( a_Encode ) ;
						}
					}
					break ;

					default:
					{
					}
					break ;

				}
			}
		}

		delete [] textualConvention ;
	}

	return t_Status ;

}

HRESULT SetStringProp ( IWbemClassObject *a_Object , BSTR propertyName , VARIANT &t_Variant ) 
{
	HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
	return t_Result ;
}

HRESULT SetProp ( IWbemClassObject *a_Object , BSTR propertyName , VARIANT &t_Variant ) 
{
	HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
	return t_Result ;
}

#if 0

BOOL WbemSnmpProperty :: SetDWORD ( BOOL a_Status , IWbemObjectAccess *a_Object , DWORD a_Value , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WriteDWORD (

					GetHandle (),
					a_Value
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WriteDWORD (

				GetHandle (),
				a_Value
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WriteDWORD (

					GetHandle (),
					a_Value
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetNULL ( BOOL a_Status , IWbemObjectAccess *a_Object , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					0 ,
					NULL
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				0 ,
				NULL
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					0 ,
					NULL
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetSTRING ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t *t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				t_Value ,
				t_ValueLength
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetSTRINGARRAY ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t **t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				t_Value ,
				t_ValueLength
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( IWbemObjectAccess *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	switch ( GetTextualConvention () )
	{
		case WBEM_INDEX_TYPE_INTEGER:
		case WBEM_INDEX_TYPE_INTEGER32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)integer->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER:
		case WBEM_INDEX_TYPE_COUNTER32:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
			{
				SnmpCounter *counter = ( SnmpCounter * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)counter->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER64:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
				SnmpCounter64Type t_Counter ( *counter ) ;
				wchar_t *value = t_Counter.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;

				status = TRUE ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_GAUGE:
		case WBEM_INDEX_TYPE_GAUGE32:
		case WBEM_INDEX_TYPE_UNSIGNED32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
			{
				SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)gauge->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OCTETSTRING:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthOctetStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOctetStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpOctetStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
				else
				{
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
			{
				SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
				SnmpObjectIdentifierType objectIdentifierType ( *objectIdentifier ) ;
				wchar_t *value = objectIdentifierType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NULL:
		{
			status = SetNull ( status , a_Object , check ) ;
		}
		break ;

		case WBEM_INDEX_TYPE_IPADDRESS:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpIpAddressType ipAddressType ( *ipAddress ) ;

				wchar_t *value = ipAddressType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_TIMETICKS:
		{
			if ( ! valueArg )
			{	
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
			{
				SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)timeTicks->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OPAQUE:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpFixedLengthOpaqueType opaqueType ( fixed , *opaque ) ;
							wchar_t *value = opaqueType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOpaqueType opaqueType ( *opaque , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = opaqueType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpOpaqueType opaqueType ( *opaque , NULL ) ;

							wchar_t *value = opaqueType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NETWORKADDRESS:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpNetworkAddressType ipAddressType ( *ipAddress ) ;
				wchar_t *value = ipAddressType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DISPLAYSTRING:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthDisplayStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpDisplayStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpDisplayStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_MACADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpMacAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_PHYSADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthPhysAddressType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpPhysAddressType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;

								status = TRUE ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpPhysAddressType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;

			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *enumerationValues = string->GetStringValue () ;
						SnmpEnumeratedType integerType ( enumerationValues , integer->GetValue () ) ;
						delete [] enumerationValues ;

						wchar_t *value = integerType.GetStringValue () ;
						status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
						delete [] value ;
					}
				}
			}		
		}
		break ;

		case WBEM_INDEX_TYPE_BITS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *bitStringValues = string->GetStringValue () ;

						SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
						SnmpBitStringType octetStringType ( bitStringValues , *octetString ) ;
						delete [] bitStringValues ;

						wchar_t **array ;
						LONG count = octetStringType.GetValue ( array ) ;

						SAFEARRAY *safeArray ;
						SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
						safeArrayBounds[0].lLbound = 0 ;
						safeArrayBounds[0].cElements = count ;

						safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

						for ( LONG index = 0 ; index < count ; index ++ )
						{
							BSTR element = SysAllocString ( array [ index ] ) ;
							SafeArrayPutElement ( safeArray , & index , element ) ;
							SysFreeString ( element ) ;
							delete [] ( array [ index ] ) ;
						}

						delete [] array ;

						t_Variant.vt = t_VarType = VT_ARRAY | VT_BSTR ;
						t_Variant.parray = safeArray ; 

						status = TRUE ;
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DATETIME:					
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpDateTimeType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpOSIAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;				
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpUDPAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpIPXAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ROWSTATUS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				SnmpRowStatusType integerType ( *integer ) ;

				wchar_t *value = integerType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	return status ;
}

#endif

BOOL WbemSnmpProperty :: SetValue ( IWbemClassObject *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	VARTYPE t_VarType = VT_NULL ;

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	switch ( GetTextualConvention () )
	{
		case WBEM_INDEX_TYPE_INTEGER:
		case WBEM_INDEX_TYPE_INTEGER32:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_I4 ;
				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
				if ( qualifier ) 
				{
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *rangeValues = string->GetStringValue () ;
						SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
						SnmpIntegerType integerType ( *integer , rangeValues ) ;
						delete [] rangeValues ;

						t_Variant.vt = t_VarType = VT_I4 ;
						t_Variant.lVal = integer->GetValue () ;

						status = integerType.SnmpInstanceType :: IsValid () ;
					}
				}
				else
				{
					SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
					t_Variant.vt = t_VarType = VT_I4 ;
					t_Variant.lVal = integer->GetValue () ;
					status = TRUE ;
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER:
		case WBEM_INDEX_TYPE_COUNTER32:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_I4 ;
				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
			{
				SnmpCounter *counter = ( SnmpCounter * ) valueArg ;

				t_Variant.vt = VT_I4 ;
				t_VarType = VT_UI4 ;
				t_Variant.lVal = counter->GetValue () ;

				status = TRUE ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER64:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;
			}
			else
			{
				SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
				SnmpCounter64Type t_Counter ( *counter ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = t_Counter.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = TRUE ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_GAUGE:
		case WBEM_INDEX_TYPE_GAUGE32:
		case WBEM_INDEX_TYPE_UNSIGNED32:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_UI4 ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
				if ( qualifier ) 
				{
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *rangeValues = string->GetStringValue () ;
						SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
						SnmpGaugeType gaugeType ( *gauge , rangeValues ) ;
						delete [] rangeValues ;

						t_Variant.vt = VT_I4 ;
						t_VarType = VT_UI4 ;
						t_Variant.lVal = gauge->GetValue () ;

						status = gaugeType.SnmpInstanceType :: IsValid () ;
					}
				}
				else
				{
					SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
					SnmpGaugeType gaugeType ( *gauge , NULL ) ;
					t_Variant.vt = VT_I4 ;
					t_VarType = VT_UI4 ;
					t_Variant.lVal = gauge->GetValue () ;

					status = TRUE ;
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OCTETSTRING:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthOctetStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOctetStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpOctetStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
				else
				{
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
			{
				SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
				SnmpObjectIdentifierType objectIdentifierType ( *objectIdentifier ) ;
				wchar_t *value = objectIdentifierType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				delete [] value ;

				status = objectIdentifierType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NULL:
		{
			t_Variant.vt = t_VarType = VT_NULL ;
			status = TRUE ;
		}
		break ;

		case WBEM_INDEX_TYPE_IPADDRESS:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpIpAddressType ipAddressType ( *ipAddress ) ;

				wchar_t *value = ipAddressType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				delete [] value ;

				status = ipAddressType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_TIMETICKS:
		{
			if ( ! valueArg )
			{	
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_UI4 ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
			{
				SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
				SnmpTimeTicksType timeTicksType ( *timeTicks ) ;
				t_Variant.vt = VT_I4 ;
				t_VarType = VT_UI4 ;
				t_Variant.lVal = timeTicksType.GetValue () ;

				status = timeTicksType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OPAQUE:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpFixedLengthOpaqueType opaqueType ( fixed , *opaque ) ;
							wchar_t *value = opaqueType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;

							delete [] value ;

							status = opaqueType.SnmpInstanceType :: IsValid () ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOpaqueType opaqueType ( *opaque , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = opaqueType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;

								delete [] value ;

								status = opaqueType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpOpaqueType opaqueType ( *opaque , NULL ) ;

							wchar_t *value = opaqueType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;

							delete [] value ;

							status = opaqueType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NETWORKADDRESS:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpNetworkAddressType ipAddressType ( *ipAddress ) ;
				wchar_t *value = ipAddressType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				delete [] value ;

				status = ipAddressType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DISPLAYSTRING:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthDisplayStringType octetStringType ( fixed , *octetString ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpDisplayStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpDisplayStringType octetStringType ( *octetString , NULL ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_MACADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpMacAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_PHYSADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthPhysAddressType octetStringType ( fixed , *octetString ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpPhysAddressType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpPhysAddressType octetStringType ( *octetString , NULL ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;

			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *enumerationValues = string->GetStringValue () ;
						SnmpEnumeratedType integerType ( enumerationValues , integer->GetValue () ) ;
						delete [] enumerationValues ;

						t_Variant.vt = t_VarType = VT_BSTR ;
						wchar_t *value = integerType.GetStringValue () ;
						t_Variant.bstrVal = SysAllocString ( value ) ;
						delete [] value ;

						status = integerType.SnmpInstanceType :: IsValid () ;
					}
				}
			}		
		}
		break ;

		case WBEM_INDEX_TYPE_BITS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *bitStringValues = string->GetStringValue () ;

						SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
						SnmpBitStringType octetStringType ( bitStringValues , *octetString ) ;
						delete [] bitStringValues ;

						wchar_t **array ;
						LONG count = octetStringType.GetValue ( array ) ;

						SAFEARRAY *safeArray ;
						SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
						safeArrayBounds[0].lLbound = 0 ;
						safeArrayBounds[0].cElements = count ;

						safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

						for ( LONG index = 0 ; index < count ; index ++ )
						{
							BSTR element = SysAllocString ( array [ index ] ) ;
							SafeArrayPutElement ( safeArray , & index , element ) ;
							SysFreeString ( element ) ;
							delete [] ( array [ index ] ) ;
						}

						delete [] array ;

						t_Variant.vt = t_VarType = VT_ARRAY | VT_BSTR ;
						t_Variant.parray = safeArray ; 

						status = octetStringType.SnmpInstanceType :: IsValid () ;
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DATETIME:					
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpDateTimeType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpOSIAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpUDPAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpIPXAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ROWSTATUS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				SnmpRowStatusType integerType ( *integer ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = integerType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = integerType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
#if 0
			switch ( GetTextualConvention () )
			{
				case WBEM_INDEX_TYPE_OCTETSTRING:
				{
					HRESULT t_Result = SetStringProp ( a_Object , propertyName , t_Variant ) ;
					if ( FAILED ( t_Result ) )
					{
						status = FALSE ;
					}
				}
				break ;

				default:
				{
					HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
					if ( FAILED ( t_Result ) )
					{
						status = FALSE ;
					}
				}
				break ;
			}
#else
			HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
			if ( FAILED ( t_Result ) )
			{
				status = FALSE ;
			}
#endif
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
#if 1 
			HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
#else
			HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
#endif

			status = SUCCEEDED ( t_Result ) ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
#if 1 
				HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
#else
				HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
#endif
				status = SUCCEEDED ( t_Result ) ;
			}
		}
		break ;
	}

	VariantClear ( & t_Variant ) ;

	return status ;

}

wchar_t *WbemSnmpProperty :: GetName () const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write ( 

		__FILE__,__LINE__,L"WbemSnmpProperty :: GetName ( (%s) )" ,
		propertyName 
	) 
) 

	return propertyName ;
}

SnmpInstanceType *WbemSnmpProperty :: GetValue () const 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: GetValue ( (%s),(%s) )" ,
			propertyName ,
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: GetValue ( (%s),(NULL) )" ,
			propertyName 
		) ;
	}	

	delete [] t_StringValue ;
) 

	return propertyValue ;
}

BOOL WbemSnmpProperty :: GetValue ( VARIANT &variant , CIMTYPE& cimType ) const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: GetValue ( VARIANT &variant )" ) ) 

	BOOL status = FALSE ;

	if ( propertyValue )
	{
		if ( typeid ( *propertyValue ) == typeid ( SnmpIntegerType ) )
		{
			SnmpIntegerType *integer = ( SnmpIntegerType * ) propertyValue ;
			if ( integer->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = integer->GetValue () ;
			}

			cimType = CIM_SINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpCounterType ) )
		{
			SnmpCounterType *counter = ( SnmpCounterType * ) propertyValue ;
			if ( counter->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = counter->GetValue () ;
			}
			
			cimType = CIM_UINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpCounter64Type ) )
		{
			SnmpCounter64Type *counter = ( SnmpCounter64Type * ) propertyValue ;
			if ( counter->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = counter->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpGaugeType ) )
		{
			SnmpGaugeType *gauge = ( SnmpGaugeType * ) propertyValue ;
			if ( gauge->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = gauge->GetValue () ;
			}

			cimType = CIM_UINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthOctetStringType ) )
		{
			SnmpFixedLengthOctetStringType *octetString = ( SnmpFixedLengthOctetStringType * ) propertyValue ;
			if ( octetString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = octetString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOctetStringType ) ) 
		{
			SnmpOctetStringType *octetString = ( SnmpOctetStringType * ) propertyValue ;
			if ( octetString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = octetString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpObjectIdentifierType ) ) 
		{
			SnmpObjectIdentifierType *objectIdentifier = ( SnmpObjectIdentifierType * ) propertyValue ;
			if ( objectIdentifier->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = objectIdentifier->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpNullType ) ) 
		{
			variant.vt = VT_NULL ;
			cimType = CIM_EMPTY;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpIpAddressType ) ) 
		{
			SnmpIpAddressType *ipAddress = ( SnmpIpAddressType * ) propertyValue ;
			if ( ipAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}			
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = ipAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpTimeTicksType ) ) 
		{
			SnmpTimeTicksType *timeTicks = ( SnmpTimeTicksType * ) propertyValue ;
			if ( timeTicks->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = timeTicks->GetValue () ;
			}

			cimType = CIM_SINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthOpaqueType ) )
		{
			SnmpFixedLengthOpaqueType *opaque = ( SnmpFixedLengthOpaqueType * ) propertyValue ;
			if ( opaque->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = opaque->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOpaqueType ) ) 
		{
			SnmpOpaqueType *opaque = ( SnmpOpaqueType * ) propertyValue ;
			if ( opaque->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = opaque->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpNetworkAddressType ) ) 
		{
			SnmpNetworkAddressType *networkAddress = ( SnmpNetworkAddressType * ) propertyValue ;
			if ( networkAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = networkAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthDisplayStringType ) )
		{
			SnmpFixedLengthDisplayStringType *displayString = ( SnmpFixedLengthDisplayStringType * ) propertyValue ;
			if ( displayString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = displayString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpDisplayStringType ) ) 
		{
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) propertyValue ;
			if ( displayString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = displayString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpMacAddressType ) ) 
		{
			SnmpMacAddressType *macAddress = ( SnmpMacAddressType * ) propertyValue ;
			if ( macAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = macAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}
				
			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpPhysAddressType ) ) 
		{
			SnmpPhysAddressType *physAddress = ( SnmpPhysAddressType * ) propertyValue ;
			if ( physAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = physAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpEnumeratedType ) ) 
		{
			SnmpEnumeratedType *enumeration = ( SnmpEnumeratedType * ) propertyValue ;
			if ( enumeration->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = enumeration->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpBitStringType ) ) 
		{
			SnmpBitStringType *bitString = ( SnmpBitStringType * ) propertyValue ;
			if ( bitString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				wchar_t **array ;
				LONG count = bitString->GetValue ( array ) ;

				SAFEARRAY *safeArray ;
				SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
				safeArrayBounds[0].lLbound = 0 ;
				safeArrayBounds[0].cElements = count ;

				safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

				for ( LONG index = 0 ; index < count ; index ++ )
				{
					BSTR element = SysAllocString ( array [ index ] ) ;
					SafeArrayPutElement ( safeArray , & index , element ) ;
					SysFreeString ( element ) ;
					delete [] ( array [ index ] ) ;
				}

				delete [] array ;

				variant.vt = VT_ARRAY | VT_BSTR ;
				variant.parray = safeArray ; 
			}
			
			cimType = CIM_STRING | CIM_FLAG_ARRAY;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpDateTimeType ) ) 
		{
			SnmpDateTimeType *dateTime = ( SnmpDateTimeType * ) propertyValue ;
			if ( dateTime->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = dateTime->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOSIAddressType ) ) 
		{
			SnmpOSIAddressType *osiAddress = ( SnmpOSIAddressType * ) propertyValue ;
			if ( osiAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = osiAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpUDPAddressType ) ) 
		{
			SnmpUDPAddressType *udpAddress = ( SnmpUDPAddressType * ) propertyValue ;
			if ( udpAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = udpAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpIPXAddressType ) ) 
		{
			SnmpIPXAddressType *ipxAddress = ( SnmpIPXAddressType * ) propertyValue ;
			if ( ipxAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{		
				variant.vt = VT_BSTR ;
				wchar_t *value = ipxAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpRowStatusType ) ) 
		{
			SnmpRowStatusType *rowStatus = ( SnmpRowStatusType * ) propertyValue ;
			if ( rowStatus->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{		
				variant.vt = VT_BSTR ;
				wchar_t *value = rowStatus->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
	}

	return status ;
}

VARTYPE WbemSnmpProperty :: GetValueVariantType () const
{
	VARTYPE varType = VT_NULL ;

	if ( propertyValue && ! ( propertyValue->IsNull () ) )
	{
		varType = GetValueVariantEncodedType () ;
	}
	else
	{
		VT_NULL ;
	}

	return varType ;
}

VARTYPE WbemSnmpProperty :: GetValueVariantEncodedType () const
{
	VARTYPE varType = VT_NULL ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			if ( _wcsicmp ( textualConvention , WBEM_TYPE_INTEGER ) == 0 )
			{
				varType = VT_I4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_INTEGER32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER64 ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_GAUGE ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_GAUGE32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_UNSIGNED32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OCTETSTRING ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OBJECTIDENTIFIER ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_NULL ) == 0 )
			{
				varType = VT_NULL ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_IPADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_TIMETICKS ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OPAQUE ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_NETWORKADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_DISPLAYSTRING ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_MACADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_PHYSADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_ENUMERATEDINTEGER ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_BITS ) == 0 )
			{
				varType = VT_BSTR | VT_ARRAY ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_DATETIME ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPOSIADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPIPXADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPUDPADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_ROWSTATUS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENCODING ) ;
				if ( qualifier )
				{	
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
					wchar_t *encoding = displayString->GetValue () ;
					if ( encoding )
					{ 
						if ( _wcsicmp ( encoding , WBEM_TYPE_INTEGER ) == 0 )
						{
							varType = VT_I4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_INTEGER32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER64 ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_GAUGE ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_GAUGE ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_UNSIGNED32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OCTETSTRING ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OBJECTIDENTIFIER ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_NULL ) == 0 )
						{
							varType = VT_NULL ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_IPADDRESS ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_TIMETICKS ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OPAQUE ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_NETWORKADDRESS ) == 0 )
						{
							varType = VT_BSTR ;
						}
					}

					delete [] encoding ;
				}
			}

			delete [] textualConvention ;
		}
	}

	return varType ;
}

BOOL WbemSnmpProperty :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{ 
	return FALSE  ; 
} 

BOOL WbemSnmpProperty :: AddQualifier ( WbemSnmpQualifier *a_qualifier )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: AddQualifier ( (%s) )" ,
		a_qualifier->GetName ()
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( a_qualifier->GetName () , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( a_qualifier->GetName () , qualifier ) )
		{
		}
		else
		{
			qualifierMap [ a_qualifier->GetName () ] = a_qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: AddQualifier ( wchar_t *qualifierName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: AddQualifier ( (%s) )" ,
		qualifierName
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( qualifierName , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
		{
		}
		else
		{
			qualifier = new WbemSnmpQualifier ( qualifierName , NULL ) ;
			qualifierMap [ qualifier->GetName () ] = qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

ULONG WbemSnmpProperty :: GetQualifierCount () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: GetQualifierCount" ) )

	return qualifierMap.GetCount () ;
}

void WbemSnmpProperty :: ResetQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: ResetQualifier" ) )

	qualifierPosition = qualifierMap.GetStartPosition () ;
}

WbemSnmpQualifier *WbemSnmpProperty :: NextQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpProperty :: NextQualifier" ) )

	wchar_t *qualifierKey ;
	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierPosition )
	{
		qualifierMap.GetNextAssoc ( qualifierPosition , qualifierKey , qualifier ) ;
	}

	return qualifier ;
}

WbemSnmpQualifier *WbemSnmpProperty :: FindQualifier ( wchar_t *qualifierName ) const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: FindQualifier (%s)" ,
		qualifierName
	) 
)

	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
	{
	}

	return qualifier ;
}

WbemSnmpClassObject :: WbemSnmpClassObject ( 

	const wchar_t *classNameArg ,
	const BOOL isClass 

) : qualifierPosition ( NULL ) , 
	propertyPosition ( NULL ) , 
	keyedPropertyPosition ( 1 ) , 
	m_isClass ( isClass ) , 
	m_isKeyed ( FALSE ) , 
	m_isSingleton ( FALSE ) , 
	m_isVirtual ( FALSE ) , 
	m_isReadable ( FALSE ) ,
	m_isWritable ( FALSE ) ,
	m_numberOfAccessible ( 0 )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

	className = new wchar_t [ wcslen ( classNameArg ) + 1 ] ;
	wcscpy ( className , classNameArg ) ;
}

WbemSnmpClassObject :: WbemSnmpClassObject () :	className ( NULL ) , 
													qualifierPosition ( NULL ) , 
													propertyPosition ( NULL ) , 
													keyedPropertyPosition ( 1 ) ,
													m_isClass ( TRUE ) ,
													m_isKeyed ( FALSE ) ,
													m_isSingleton ( FALSE ) ,
													m_isVirtual ( FALSE ) ,
													m_isReadable ( FALSE ) ,
													m_isWritable ( FALSE ) ,
													m_numberOfAccessible ( 0 )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

}

WbemSnmpClassObject :: WbemSnmpClassObject ( 

	const WbemSnmpClassObject & copy 

) :	className ( NULL ) , 
	qualifierPosition ( NULL ) , 
	propertyPosition ( NULL ) , 
	keyedPropertyPosition ( 1 ) ,
	m_isClass ( copy.m_isClass ) ,
	m_isKeyed ( copy.m_isKeyed ) ,
	m_isSingleton ( copy.m_isSingleton ) ,
	m_isVirtual ( copy.m_isVirtual ) ,
	m_isReadable ( copy.m_isReadable ) ,
	m_isWritable ( copy.m_isWritable ) ,
	m_numberOfAccessible ( copy.m_numberOfAccessible )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

	if ( copy.className ) 
	{
		className = new wchar_t [ wcslen ( copy.className ) + 1 ] ;
		wcscpy ( className , copy.className ) ;
	}

	POSITION position = copy.propertyMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *propertyName ;
		WbemSnmpProperty *property ;
		copy.propertyMap.GetNextAssoc ( position , propertyName , property ) ;
		
		WbemSnmpProperty *copyProperty = new WbemSnmpProperty ( *property ) ;
		propertyMap [ copyProperty->GetName () ] = copyProperty ;
	}

	position = copy.qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		copy.qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		WbemSnmpQualifier *copyQualifier = new WbemSnmpQualifier ( *qualifier ) ;
		qualifierMap [ copyQualifier->GetName () ] = copyQualifier ;
	}

	position = copy.keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *keyProperty = copy.keyedPropertyList.GetNext ( position ) ;
		WbemSnmpProperty *property ;
		if ( propertyMap.Lookup ( keyProperty->GetName () , property ) )
		{
			keyedPropertyList.AddTail ( property ) ;
		}
	}
}

WbemSnmpClassObject :: ~WbemSnmpClassObject ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ~WbemSnmpClassObject ()" ) )

	delete [] className ;

	keyedPropertyList.RemoveAll () ;

	POSITION position = propertyMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *propertyName ;
		WbemSnmpProperty *property ;
		propertyMap.GetNextAssoc ( position , propertyName , property ) ;
		
		delete property ;
	}

	propertyMap.RemoveAll () ;

	position = qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		delete qualifier ;
	}

	qualifierMap.RemoveAll () ;
}

void WbemSnmpClassObject :: SetKeyed ( BOOL a_isKeyed )
{
	m_isKeyed = a_isKeyed ;
}

BOOL WbemSnmpClassObject :: IsKeyed ()
{
	return m_isKeyed ;
}

void WbemSnmpClassObject :: SetSingleton ( BOOL a_isSingleton )
{
	m_isSingleton = a_isSingleton ;
}

BOOL WbemSnmpClassObject :: IsSingleton ()
{
	return m_isSingleton ;
}

void WbemSnmpClassObject :: SetVirtual ( BOOL a_isVirtual )
{
	m_isVirtual = a_isVirtual ;
}

BOOL WbemSnmpClassObject :: IsVirtual ()
{
	return m_isVirtual ;
}

BOOL WbemSnmpClassObject :: IsWritable () 
{ 
	return m_isWritable ; 
}

BOOL WbemSnmpClassObject :: IsReadable () 
{ 
	return m_isReadable ; 
}

ULONG WbemSnmpClassObject :: GetNumberOfAccessible ()
{
	return m_numberOfAccessible ;
} 

void WbemSnmpClassObject :: SetWritable ( BOOL a_isWritable )
{
	m_isWritable = a_isWritable ; 
}

void WbemSnmpClassObject :: SetReadable ( BOOL a_isReadable ) 
{
	m_isReadable = a_isReadable ; 
}

void WbemSnmpClassObject :: SetNumberOfAccessible ( ULONG a_numberOfAccessible )
{
	m_numberOfAccessible = a_numberOfAccessible ;
}

wchar_t *WbemSnmpClassObject :: GetClassName () const
{
	return className ;
}

BOOL WbemSnmpClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{ 
	return FALSE ; 
} 

void WbemSnmpClassObject :: AddKeyedProperty ( WbemSnmpProperty *snmpProperty ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddKeyedProperty ( (%s) )" ,
		snmpProperty->GetName ()
	) ;
)

	WbemSnmpProperty *t_snmpProperty = FindProperty ( snmpProperty->GetName () ) ;
	if ( t_snmpProperty ) 
	{
		keyedPropertyList.AddTail ( snmpProperty ) ;
	}
}

BOOL WbemSnmpClassObject :: AddKeyedProperty ( wchar_t *propertyName ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddKeyedProperty ( (%s) )" ,
		propertyName
	) ;
)

	WbemSnmpProperty *snmpProperty = FindProperty ( propertyName ) ;
	if ( snmpProperty ) 
	{
		AddKeyedProperty ( snmpProperty ) ;
	}

	return snmpProperty ? TRUE : FALSE ;
}

ULONG WbemSnmpClassObject :: GetKeyPropertyCount ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetKeyPropertyCount" ) )

	return keyedPropertyList.GetCount () ;
}

void WbemSnmpClassObject :: ResetKeyProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetKeyProperty" ) )

	keyedPropertyPosition = 1 ;
}

WbemSnmpProperty *WbemSnmpClassObject :: NextKeyProperty () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextKeyProperty" ) )

	WbemSnmpProperty *property = NULL ;
	POSITION position = keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *value = keyedPropertyList.GetNext ( position ) ;
		WbemSnmpQualifier *qualifier ;
		if ( qualifier = value->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) ) 
		{
			SnmpInstanceType *typeValue = qualifier->GetValue () ;
			if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integer = ( SnmpIntegerType * ) qualifier->GetValue () ;
				if ( integer->GetValue () == keyedPropertyPosition )
				{
					property = value ;
					break ;
				}
			}
			else
			{
// Problem Here

			}
		}
		else
		{
// Problem Here
		}
	}

	keyedPropertyPosition ++ ;

	return property ;
}

WbemSnmpProperty *WbemSnmpClassObject :: FindKeyProperty ( wchar_t *propertyName ) const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: FindKeyProperty ( (%s)" ,
		propertyName
	) ;
)

	WbemSnmpProperty *property = NULL ;
	POSITION position = keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *value = keyedPropertyList.GetNext ( position ) ;
		if ( _wcsicmp ( value->GetName () , propertyName ) == 0 )
		{
			property = value ;
			break ;
		}
	}

	return property ;
}

ULONG WbemSnmpClassObject :: GetPropertyCount () 
{
	return propertyMap.GetCount () ;
}

BOOL WbemSnmpClassObject :: AddProperty ( WbemSnmpProperty *property )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddProperty ( (%s) )" ,
		property->GetName () 
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *propertyValue ;
	if ( propertyMap.Lookup ( property->GetName () , propertyValue ) ) 
	{
	}
	else
	{
		propertyMap [ property->GetName () ] = property ;
	}

	return TRUE ;
}

BOOL WbemSnmpClassObject :: AddProperty ( wchar_t *propertyName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddProperty ( (%s) )" ,
		propertyName
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *property ;
	if ( propertyMap.Lookup ( propertyName , property ) ) 
	{
	}
	else
	{
		property = new WbemSnmpProperty ( propertyName ) ;
		propertyMap [ property->GetName () ] = property ;
	}

	return TRUE ;
}

void WbemSnmpClassObject :: DeleteProperty ( wchar_t *propertyName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: DeleteProperty ( (%s) )" ,
		propertyName
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *property ;
	if ( propertyMap.Lookup ( propertyName , property ) ) 
	{
		propertyMap.RemoveKey ( propertyName ) ;
		POSITION keyPosition = keyedPropertyList.Find ( property ) ;
		if ( keyPosition )
		{
			keyedPropertyList.RemoveAt ( keyPosition ) ;
		}
		else
		{
// Problem Here
		}

		delete property ;
	}
}

void WbemSnmpClassObject :: ResetProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetProperty ()" ) )

	propertyPosition = propertyMap.GetStartPosition () ;
}

WbemSnmpProperty *WbemSnmpClassObject :: NextProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextProperty ()" ) )

	wchar_t *propertyKey ;
	WbemSnmpProperty *property = NULL ;
	if ( propertyPosition )
	{
		propertyMap.GetNextAssoc ( propertyPosition , propertyKey , property ) ;
	}

	return property ;
}

WbemSnmpProperty *WbemSnmpClassObject :: FindProperty ( wchar_t *propertyName ) const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: FindProperty (%s) " ,
		propertyName
	) ;
)

	WbemSnmpProperty *property = NULL ;
	if ( propertyMap.Lookup ( propertyName , property ) )
	{
	}

	return property ;
}

ULONG WbemSnmpClassObject :: GetQualifierCount () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetQualifierCount ()" ) )

	return qualifierMap.GetCount () ;
}

BOOL WbemSnmpClassObject :: AddQualifier ( WbemSnmpQualifier *a_qualifier )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddQualifier ( (%s) )" ,
		a_qualifier->GetName ()
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( a_qualifier->GetName () , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( a_qualifier->GetName () , qualifier ) )
		{
		}
		else
		{
			qualifierMap [ a_qualifier->GetName () ] = a_qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpClassObject :: AddQualifier ( wchar_t *qualifierName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddQualifier ( (%s) )" ,
		qualifierName
	) ;
)


	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( qualifierName , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
		{
		}
		else
		{
			qualifier = new WbemSnmpQualifier ( qualifierName , NULL ) ;
			qualifierMap [ qualifier->GetName () ] = qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

void WbemSnmpClassObject :: ResetQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetQualifier" ) )

	qualifierPosition = qualifierMap.GetStartPosition () ;
}

WbemSnmpQualifier *WbemSnmpClassObject :: NextQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextQualifier" ) )

	wchar_t *qualifierKey ;
	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierPosition )
	{
		qualifierMap.GetNextAssoc ( qualifierPosition , qualifierKey , qualifier ) ;
	}

	return qualifier ;
}

WbemSnmpQualifier *WbemSnmpClassObject :: FindQualifier ( wchar_t *qualifierName ) const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: FindQualifier ( (%s) )",
		qualifierName
	) ;
)

	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
	{
	}

	return qualifier ;
}

BOOL WbemSnmpClassObject :: Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write ( 

		__FILE__,__LINE__,
		L"BOOL WbemSnmpClassObject :: Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) ;
)

	BOOL result = SetMosClassObject ( a_errorObject , mosClassObject , rigorous ) ;

	return result ;
}

BOOL WbemSnmpClassObject :: SetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write ( 

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) 
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	
	VARIANT variant ;
	VariantInit ( & variant ) ;

	t_WBEM_result = mosClassObject->Get ( WBEM_PROPERTY_GENUS , 0 , &variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_WBEM_result ) )
	{
		m_isClass = ( ( variant.lVal ) == WBEM_GENUS_CLASS ) ? TRUE : FALSE ;

		t_WBEM_result = mosClassObject->Get ( WBEM_PROPERTY_CLASS , 0 , &variant , NULL , NULL ) ;
		if ( SUCCEEDED ( t_WBEM_result ) )
		{
			className = new wchar_t [ wcslen ( variant.bstrVal ) + 1 ] ;
			wcscpy ( className , variant.bstrVal ) ;

			IWbemQualifierSet *classQualifierObject ;
			if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
			{
				status = SetMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
				if ( status )
				{
					status = SetMosClassObjectProperties ( a_errorObject , mosClassObject , rigorous ) ;
				}

				classQualifierObject->Release () ;
			}
			else
			{
/*
 *	Failed to get qualifier set. WBEM error
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;
			}
		}
		else
		{
/*
 *	Failed to get __Class property. WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to get __Class property" ) ;
		}
	}
	else
	{
/*
 * Failed to get __Genus property. WBEM error
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get __Genus property" ) ;
	}


/*
 *
 */

	if ( status )
	{
		if ( IsKeyed () )
		{
// Iterate through keys checking order is as expected

			ULONG keyPropertyCount = 0 ;

			ULONG keyOrder = 1 ;
			while ( keyOrder <= GetKeyPropertyCount () )
			{
				WbemSnmpProperty *property ;
				ResetProperty () ;
				while ( status && ( property = NextProperty () ) )
				{
					if ( property->IsKey () )
					{
						if ( keyOrder != property->GetKeyOrder () )
						{
						}
						else 
						{
	// Key order good
							keyPropertyCount ++ ;
							break ;
						}
					}
				}

				keyOrder ++ ;
			}

			if ( keyPropertyCount != GetKeyPropertyCount () )
			{
// Invalid key ordering
				status = FALSE ;

				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Class specified invalid key ordering" ) ;
			}
		}
		else
		{
// Class has no key properties 
		}
	}

	if ( status )
	{
		ULONG t_numberOfVirtuals = 0 ;
		if ( IsKeyed () && IsVirtual () )
		{
			WbemSnmpProperty *property ;
			ResetProperty () ;
			while ( property = NextProperty () )
			{
				if ( property->IsVirtualKey () )
				{
					t_numberOfVirtuals ++ ;
				}
			}
		}

		m_numberOfAccessible = GetPropertyCount () - t_numberOfVirtuals ;

		if ( m_numberOfAccessible == 0 )
		{
	// All properties are keyed,virtual

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain atleast one property which is not a virtual key or inaccessible" ) ;
		}
	}

	VariantClear ( & variant ) ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	
	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;

	classQualifierObject->BeginEnumeration ( 0 ) ;
	while ( classQualifierObject->Next ( 0 , & qualifierName , & variant , 	& qualifierFlavour ) == WBEM_NO_ERROR )
	{
		AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED  ) ;

				wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for class qualifier: " ) ;
				wchar_t *stringBuffer = UnicodeStringAppend ( temp , qualifierName ) ;
				delete [] temp ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}

			if ( qualifier = FindQualifier ( WBEM_QUALIFIER_SINGLETON ) )
			{
				SnmpInstanceType *value = qualifier->GetValue () ;
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
					SetSingleton ( integer->GetValue () ) ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for class qualifier: singleton" ) ;
				}
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}

	classQualifierObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write ( 

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	BSTR propertyName = NULL ;
	
	CIMTYPE cimType;
	mosClassObject->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
	while ( status && ( mosClassObject->Next ( 0 , &propertyName , &variant , &cimType , NULL ) == WBEM_NO_ERROR ) )
	{
		IWbemQualifierSet *propertyQualifierSet ;
		if ( ( t_WBEM_result = mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierSet ) ) == WBEM_NO_ERROR ) 
		{
			VARIANT textualConventionVariant ;
			VariantInit ( &textualConventionVariant ) ;

			LONG flag;
			if ( SUCCEEDED ( propertyQualifierSet->Get ( WBEM_QUALIFIER_TEXTUAL_CONVENTION , 0 , &textualConventionVariant , &flag ) ) )
			{
				AddProperty ( propertyName ) ;
				WbemSnmpProperty *property = FindProperty ( propertyName ) ;
				if ( property )
				{
					status = SetMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierSet ) ;
					if ( status )
					{
						WbemSnmpQualifier *qualifier ;
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									AddKeyedProperty ( propertyName ) ;
									property->SetKey () ;
									SetKeyed () ;

									if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) )
									{
										SnmpInstanceType *value = qualifier->GetValue () ;
										if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
										{
											SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
											property->SetKeyOrder ( integer->GetValue () ) ;
										}
										else
										{
											wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
											wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: key_order") ;
											delete [] prefix ;
											a_errorObject.SetMessage ( stringBuffer ) ;
											delete [] stringBuffer ; 

											status = FALSE ;
											a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
											a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										}
									}
									else
									{
// Keyed property contains no key order

										wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
										wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' is defined as a key but contains no key_order qualifier") ;
										delete [] prefix ;
										a_errorObject.SetMessage ( stringBuffer ) ;
										delete [] stringBuffer ; 

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									}
								}

								if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_VIRTUAL_KEY ) )
								{
									SnmpInstanceType *value = qualifier->GetValue () ;
									if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
										if ( integer->GetValue () )
										{
											property->SetVirtualKey () ;
											SetVirtual () ;
										}
									}							
									else
									{
										wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
										wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: virtual_key") ;
										delete [] prefix ;
										a_errorObject.SetMessage ( stringBuffer ) ;
										delete [] stringBuffer ; 

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									}
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: key") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}
						
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_READ ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									property->SetReadable () ;
									SetReadable () ;
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: read") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_WRITE ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									property->SetWritable () ;
									SetWritable () ;
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: write") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( ! property->IsVirtualKey () )
						{
							// Check Object Identifier Present

							if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ) 
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
								{
								}
								else
								{
// Problem Here
									wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
									wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: object_identifier") ;
									delete [] prefix ;
									a_errorObject.SetMessage ( stringBuffer ) ;
									delete [] stringBuffer ; 

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								}
							}
							else
							{
// No Object Identifier present
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' must specify valid qualifier for: object_identifier" ) ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
								wchar_t *string = displayString->GetValue () ;

								ULONG stringItem ;
								if ( textualConventionMap.Lookup ( string , stringItem ) )
								{
									property->SetTextualConvention ( stringItem ) ;
								}

								delete [] string ;

							}							
						}

						if ( rigorous )
						{
							if ( property->SetValue ( variant , cimType , SetValueIfCheckOk ) )
							{
								IWbemObjectAccess *t_Access = NULL ;
								HRESULT result = mosClassObject->QueryInterface (

									IID_IWbemObjectAccess ,
									(void**)&t_Access 
								) ;

								if ( SUCCEEDED ( result ) )
								{
									long t_Handle ;

									
									HRESULT result = t_Access->GetPropertyHandle (

										propertyName ,
										NULL ,
										& t_Handle 
									);

									if ( SUCCEEDED ( result ) )
									{
										property->SetHandle ( t_Handle ) ;
									}

	
									t_Access->Release () ;
								}
							}
							else
							{
/*
 *	Property Expected Type and property Value Type were not the same
 */

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

								wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
								delete [] temp ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

							}
						}
						else
						{
							if ( property->SetValue ( variant , cimType , SetValueRegardlessDontReturnCheck ) )
							{
							}
							else
							{
/*
 *	Property Expected Type and property Value Type were not the same. Should not happen.
 */

								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for property value" ) ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 


								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
							}
						}
					}
				}
				else
				{
				}
			}

			VariantClear ( & textualConventionVariant ) ;

			propertyQualifierSet->Release () ;

		}
		else
		{
/*
 * Failed to get qualifier set . WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Failed to get qualifier set for: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}

		SysFreeString ( propertyName ) ;

		VariantClear ( & variant ) ;
	}

	mosClassObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
	DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObjectPropertyQualifiers (WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;
	propertyQualifierSet->BeginEnumeration ( 0 ) ;
	while ( status && ( propertyQualifierSet->Next ( 0 , & qualifierName , & variant , & qualifierFlavour ) == WBEM_NO_ERROR ) )
	{
		snmpProperty->AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = snmpProperty->FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

				wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , snmpProperty->GetName () ) ;
				wchar_t *suffix = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: ") ;
				delete [] prefix ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , qualifierName ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 

			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}
	
	propertyQualifierSet->EndEnumeration () ;
	
	return status ;
}

BOOL WbemSnmpClassObject :: Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )"
	) ;
)
	BOOL result = MergeMosClassObject ( a_errorObject , mosClassObject , rigorous ) ;

	return result ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObject (WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )"
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	
	IWbemQualifierSet *classQualifierObject ;
	if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
	{
		status = MergeMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
		if ( status )
		{
			status = MergeMosClassObjectProperties ( a_errorObject , mosClassObject , rigorous ) ;
		}

		classQualifierObject->Release () ;
	}
	else
	{
/*
 *	Failed to get qualifier set. WBEM error
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;
	}

/*
 *
 */

	if ( status )
	{
		if ( IsKeyed () )
		{
// Iterate through keys checking order is as expected

			ULONG keyPropertyCount = 0 ;

			ULONG keyOrder = 1 ;
			while ( keyOrder <= GetKeyPropertyCount () )
			{
				WbemSnmpProperty *property ;
				ResetProperty () ;
				while ( status && ( property = NextProperty () ) )
				{
					if ( property->IsKey () )
					{
						if ( keyOrder != property->GetKeyOrder () )
						{
						}
						else 
						{
	// Key order good
							keyPropertyCount ++ ;
							break ;
						}
					}
				}

				keyOrder ++ ;
			}

			if ( keyPropertyCount != GetKeyPropertyCount () )
			{
// Invalid key ordering
				status = FALSE ;

				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Class specified invalid key ordering" ) ;
			}
		}
		else
		{
// Class has no key properties 
		}
	}

	if ( status )
	{
		ULONG t_numberOfVirtuals = 0 ;
		if ( IsKeyed () && IsVirtual () )
		{
			WbemSnmpProperty *property ;
			ResetProperty () ;
			while ( property = NextProperty () )
			{
				if ( property->IsVirtualKey () )
				{
					t_numberOfVirtuals ++ ;
				}
			}
		}

		m_numberOfAccessible = GetPropertyCount () - t_numberOfVirtuals ;

		if ( m_numberOfAccessible == 0 )
		{
// All properties are keyed,virtual

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain atleast one property which is not a virtual key or inaccessible" ) ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectProperties (WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	
	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;

	classQualifierObject->BeginEnumeration ( 0 ) ;
	while ( classQualifierObject->Next ( 0 , & qualifierName , & variant , & qualifierFlavour) == WBEM_NO_ERROR )
	{
		AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED  ) ;

				wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for class qualifier: " ) ;
				wchar_t *stringBuffer = UnicodeStringAppend ( temp , qualifierName ) ;
				delete [] temp ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}

	classQualifierObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectProperties" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	BSTR propertyName = NULL ;
	
	CIMTYPE cimType ;
	mosClassObject->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
	while ( status && ( mosClassObject->Next ( 0 , &propertyName , &variant , &cimType , NULL ) == WBEM_NO_ERROR ) )
	{
		IWbemQualifierSet *propertyQualifierSet ;
		if ( ( t_WBEM_result = mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierSet ) ) == WBEM_NO_ERROR ) 
		{
			WbemSnmpProperty *property = FindProperty ( propertyName ) ;
			if ( property )
			{
				status = MergeMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierSet ) ;
				if ( status )
				{
					WbemSnmpQualifier *qualifier ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								if ( ! FindKeyProperty ( propertyName ) )
								{
									AddKeyedProperty ( propertyName ) ;
								}

								property->SetKey () ;
								SetKeyed () ;

								if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) )
								{
									SnmpInstanceType *value = qualifier->GetValue () ;
									if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
										property->SetKeyOrder ( integer->GetValue () ) ;
									}
									else
									{
										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_errorObject.SetMessage ( L"Type mismatch for qualifier: key_order" ) ;
									}
								}
								else
								{
		// Keyed property contains no key order

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Property is defined as a key but contains no key_order qualifier" ) ;
								}
							}

							if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_VIRTUAL_KEY ) )
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
									if ( integer->GetValue () )
									{
										property->SetVirtualKey () ;
										SetVirtual () ;
									}
								}							
								else
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Type mismatch for qualifier: virtual_key" ) ;
								}
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: key" ) ;
						}
					}
					
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_READ ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								property->SetReadable () ;
								SetReadable () ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: read" ) ;
						}

					}

					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_WRITE ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								property->SetWritable () ;
								SetWritable () ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: write" ) ;
						}

					}

					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_SINGLETON ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							SetSingleton ( integer->GetValue () ) ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: singleton" ) ;
						}
					}

					if ( ! property->IsVirtualKey () )
					{
						// Check Object Identifier Present

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ) 
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
							}
							else
							{
		// Problem Here
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Type mismatch for qualifier: object_identifier" ) ;
							}
						}
						else
						{
		// No Object Identifier present
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Property must specify valid qualifier for: object_identifier" ) ;
						}
					}

					if ( rigorous )
					{
						if ( property->SetValue ( variant , cimType , SetValueIfCheckOk ) )
						{
						}
						else
						{
/*
*	Property Expected Type and property Value Type were not the same
*/

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

							wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
							wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
							delete [] temp ;
							a_errorObject.SetMessage ( stringBuffer ) ;
							delete [] stringBuffer ; 

						}
					}
					else
					{
						if ( property->SetValue ( variant , cimType , SetValueRegardlessDontReturnCheck ) )
						{
						}
						else
						{
/*
*	Property Expected Type and property Value Type were not the same. Should not happen.
*/

							wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
							wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for property value" ) ;
							delete [] prefix ;
							a_errorObject.SetMessage ( stringBuffer ) ;
							delete [] stringBuffer ; 


							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
						}
					}
				}
			}
			else
			{
			}

			propertyQualifierSet->Release () ;

		}
		else
		{
/*
 * Failed to get qualifier set . WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Failed to get qualifier set for: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}

		SysFreeString ( propertyName ) ;

		VariantClear ( & variant ) ;
	}

	mosClassObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;
	propertyQualifierSet->BeginEnumeration ( 0 ) ;
	while ( status && ( propertyQualifierSet->Next ( 0 , & qualifierName , & variant , & qualifierFlavour ) == WBEM_NO_ERROR ) )
	{
		snmpProperty->AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = snmpProperty->FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

				wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , snmpProperty->GetName () ) ;
				wchar_t *suffix = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: ") ;
				delete [] prefix ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , qualifierName ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}
	
	propertyQualifierSet->EndEnumeration () ;
	
	return status ;
}

BOOL WbemSnmpClassObject :: Get ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: Get" ) )

	BOOL status = GetMosClassObject ( a_errorObject , mosClassObject ) ;

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObject" ) )

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	IWbemQualifierSet *classQualifierObject ;
	if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
	{
		status = GetMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
		if ( status )
		{
			status = GetMosClassObjectProperties ( a_errorObject , mosClassObject ) ;
		}
		else
		{
		}

		classQualifierObject->Release () ;
	}
	else
	{
/*
 *	Couldn't get object qualifier set.
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;

	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectQualifiers" ) )

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier ;
	ResetQualifier () ;
	while ( status && ( qualifier = NextQualifier () ) )
	{
		if ( qualifier->IsPropagatable () )
		{
			wchar_t *qualifierName = qualifier->GetName () ;

			if ( qualifier->GetValue ( variant ) )
			{
				t_WBEM_result = classQualifierObject->Put ( qualifierName , &variant , WBEM_CLASS_PROPAGATION ) ;
				if ( SUCCEEDED ( t_WBEM_result ) )
				{
				}
				else
				{
	/*
	 *	Failed to set qualifier value. Should not happen.
	 */
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetMessage ( L"Failed to set class qualifier value" ) ;

				}
			}
			else
			{
	/*
	 *	Failed to get qualifier value. Should not happen.
	 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to get class qualifier value" ) ;
			}

			VariantClear ( & variant ) ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectProperties" ) )

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		wchar_t *propertyName = property->GetName () ;

		IWbemQualifierSet *propertyQualifierObject ;
		if ( SUCCEEDED ( mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierObject ) ) )
		{
			status = GetMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierObject ) ;
			if ( status )
			{
				CIMTYPE cimType ;
				if ( property->GetValue ( variant , cimType ) )
				{
					if ( IsClass () )
					{
						if ( property->IsNull () )
						{
							t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , cimType ) ;
						}
						else
						{
							t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , 0 ) ;
						}
					}
					else
					{
						t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , 0 ) ;
					}

					if ( SUCCEEDED ( t_WBEM_result ) )
					{
					}
					else
					{
/*
 *	Failed to set property value. Should not happen.
 */

						
						wchar_t *prefix = UnicodeStringAppend ( L"Failed to set property value for property \'" , propertyName ) ;
						wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
						delete [] prefix ;
						a_errorObject.SetMessage ( stringBuffer ) ;
						delete [] stringBuffer ; 

						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
						a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
					}
				}
				else
				{
		/*
		 *	Failed to get property value. Should not happen.
		 */

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Failed to get property value for property \'" , propertyName ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					a_errorObject.SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}

				VariantClear ( & variant ) ;
			}

			propertyQualifierObject->Release () ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->Write (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectPropertyQualifiers" ) )

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier ;
	snmpProperty->ResetQualifier () ;
	while ( status && ( qualifier = snmpProperty->NextQualifier () ) )
	{
		if ( qualifier->IsPropagatable () )
		{
			wchar_t *qualifierName = qualifier->GetName () ;

			if ( qualifier->GetValue ( variant ) )
			{
				t_WBEM_result = ( WBEMSTATUS ) propertyQualifierSet->Put ( qualifierName , &variant , WBEM_CLASS_PROPAGATION ) ;
				if ( SUCCEEDED ( t_WBEM_result ) )
				{
				}
				else
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Failed to set property qualifier \'" , qualifierName ) ;
					wchar_t *middle = UnicodeStringAppend ( prefix , L"\' for property \'" ) ;
					delete [] prefix ;
					wchar_t *suffix = UnicodeStringAppend ( middle , snmpProperty->GetName () ) ;
					delete [] middle ;
					wchar_t *stringBuffer = UnicodeStringAppend ( suffix , L"\'" ) ;
					delete [] suffix ;
					a_errorObject.SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				}
			}
			else
			{

				wchar_t *prefix = UnicodeStringAppend ( L"Failed to get property qualifier \'" , qualifierName ) ;
				wchar_t *middle = UnicodeStringAppend ( prefix , L"\' for property \'" ) ;
				delete [] prefix ;
				wchar_t *suffix = UnicodeStringAppend ( middle , snmpProperty->GetName () ) ;
				delete [] middle ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , L"\'" ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 


				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			}

			VariantClear ( & variant ) ;
		}
	}

	return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\clasprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: Sample Mini Server for Ole MS 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPClassProvider_H_
#define _SNMPClassProvider_H_

extern CRITICAL_SECTION s_ProviderCriticalSection ;

class SnmpClassDefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpClassDefaultThreadObject ( const char *threadName = NULL ) : SnmpThreadObject ( threadName ) {} ;
	~SnmpClassDefaultThreadObject () {} ;

	void Initialise () ;
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpClasProv : public IWbemServices , public IWbemProviderInit
{
private:

	LONG m_referenceCount ;         //Object reference count

private:

	BOOL initialised ;
	IWbemServices *propertyProvider ;
	IWbemServices *server ;
	IWbemProviderInitSink *m_InitSink ;
	char *ipAddressString ;
	char *ipAddressValue ;

	wchar_t *thisNamespace ;
	WbemNamespacePath namespacePath ;

	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_snmpNotificationClassObject ;
	BOOL m_getNotifyCalled ;
	BOOL m_getSnmpNotifyCalled ;
 
private:

	void SetServer ( IWbemServices *serverArg ) ;

	BOOL ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject ) ;

protected:

public:

	CImpClasProv () ;
    ~CImpClasProv () ;

	void SetProvider ( IWbemServices *provider ) ;
	IWbemServices *GetServer () ;
	WbemNamespacePath *GetNamespacePath () ;
	wchar_t *GetThisNamespace () ;
	void SetThisNamespace ( wchar_t *thisNamespaceArg ) ;
	char *GetIpAddressString () { return ipAddressString ; }
	char *GetIpAddressValue () { return ipAddressValue ; }

	BOOL FetchSnmpNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL FetchNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;
	IWbemClassObject *GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	static SnmpClassDefaultThreadObject *s_defaultThreadObject ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

public:

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize (
			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
		);
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\storage.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <cordefs.h>
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <notify.h>
#include <snmplog.h>

extern ISmirDatabase* g_pNotifyInt;
extern CCorrCacheNotify *gp_notify;

CCorrGroupArray::CCorrGroupArray()
{
	SetSize(0, 10000);
}

int compare( const void *arg1, const void *arg2 )
{
	CCorrObjectID tmp1;
	(*(CCorrGroupIdItem**)arg1)->GetGroupID(tmp1);
	CCorrObjectID tmp2;	
	(*(CCorrGroupIdItem**)arg2)->GetGroupID(tmp2);
	
	switch (tmp1.CompareWith(tmp2))
	{
		case ECorrAreEqual:
		break;

		case ECorrFirstLess:
		return -1;

		case ECorrFirstGreater:
		return 1;
	}
	
	return 0;
}

void CCorrGroupArray::Sort()
{
	if (GetSize())
	{
		//CObject** temp = GetData();
		qsort((void *)GetData(), (size_t)GetSize(),
				sizeof( CCorrGroupIdItem * ), compare );
	}

	FreeExtra();
}


//============================================================================
//  CCorrGroupArray::~CCorrGroupArray
//
//  This is the CCorrGroupArray class's only desstructor. If there are any items in
//	the queue they are deleted.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupArray::~CCorrGroupArray()
{
	for (int x = 0; x < GetSize(); x++)
	{
		CCorrGroupIdItem * item = GetAt(x);
		delete item;
	}

	RemoveAll();
}


//============================================================================
//  CCorrGroupIdItem::CCorrGroupIdItem
//
//  This is the CCorrGroupIdItem class's only constructor. This class is derived from
//	the CObject class. This is so the MFC template storage classes can be
//	used. It is used to store a CString value in a list.
//
//
//  Parameters:
//
//      CString * str  	A pointer to the CString object to be stored.
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupIdItem::CCorrGroupIdItem(IN const CCorrObjectID& ID, IN ISmirGroupHandle*	grpH)
				: m_groupId(ID)
{
	m_index = 0;

	if (grpH)
	{
		m_groupHandles.AddHead(grpH);
	}
}


void CCorrGroupIdItem::GetGroupID(OUT CCorrObjectID& ID) const
{
	m_groupId.ExtractOID(ID);
}


void CCorrGroupIdItem::DebugOutputItem(CString* msg) const
{
	CString debugstr;
	CCorrObjectID tmp;
	m_groupId.ExtractOID(tmp);
	tmp.GetString(debugstr);

	if (!debugstr.GetLength())
	{
		debugstr = L"Error retrieving Group Object OID";
	}

	if (msg)
	{
		debugstr += L"\t\t:\t";
		debugstr += *msg;
	}

	debugstr += L"\n";
DebugMacro6( 
	SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
		debugstr);
)

}


//============================================================================
//  CCorrGroupIdItem::~CCorrGroupIdItem
//
//  This is the CCorrGroupIdItem class's only destructor. It frees the memory used
//	to store the CString members.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupIdItem::~CCorrGroupIdItem()
{
	while (!m_groupHandles.IsEmpty())
	{
		(m_groupHandles.RemoveHead())->Release();
	}
}


CCorrObjectID::CCorrObjectID(IN const CCorrObjectID& ID)
{
	m_length = ID.m_length;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ID.m_Ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}
}


CCorrObjectID::CCorrObjectID(IN const char* str)
{
	m_length = 0;
	m_Ids = NULL;

	if (NULL != str)
	{
		char temp[MAX_OID_STRING + 1];
		strncpy(temp, str, MAX_OID_STRING+1);
		
		if ('\0' != temp[MAX_OID_STRING]) //string is too long.
		{
			return;
		}

		BOOL bad = FALSE;
		char* temp1 = temp;
		UINT temp2[MAX_OID_LENGTH];
		CString dot(".");

		if (dot.GetAt(0) == temp[0])
		{
			temp1++;
		}

		istrstream istr(temp1);
		char d;

		istr >> temp2[0];
		m_length++;

  		if (istr.bad() || istr.fail())
		{
			bad = TRUE;
		}

		while(!istr.eof() && !bad)
		{
			istr >> d;

  			if (istr.bad() || istr.fail())
			{
				bad = TRUE;
			}

			if (d != dot.GetAt(0))
			{
				bad = TRUE;
			}

			if (m_length < MAX_OID_LENGTH)
			{
				istr >> temp2[m_length++];

				if (istr.bad() || istr.fail())
				{
					bad = TRUE;
				}			

			}
			else
			{
				bad = TRUE;
			}
		}

		if (!bad)
		{
			m_Ids = new UINT[m_length];
			memcpy(m_Ids, temp2, m_length*sizeof(UINT));
		}
		else
		{
			m_length = 0;
		}
	}
}

CCorrObjectID::CCorrObjectID(IN const UINT* ids, IN const UINT len)
{
	m_length = len;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}
}


void CCorrObjectID::Set(IN const UINT* ids, IN const UINT len)
{
	if (m_length)
	{
		delete [] m_Ids;
	}

	m_length = len;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}
}


char* CCorrObjectID::GetString() const
{
	char * ret = NULL;

	if (m_length)
	{
		ostrstream s;
		s << m_Ids[0];
		UINT i = 1;
		char dot = '.';

		while (i < m_length)
		{
			s << dot << m_Ids[i++];
		}
		
		s << ends;

		ret = s.str();
	}

	return ret;
}

void CCorrObjectID::GetString(CString& str) const
{
	char* oid = GetString();
	wchar_t temp[MAX_OID_STRING + 1];
	
	if (0 != MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, oid, -1, temp, MAX_OID_STRING + 1))
	{
		str = temp;
	}

	delete [] oid;
}

ECorrCompResult CCorrObjectID::CompareWith(IN const CCorrObjectID& second) const
{
	if (0 == m_length)
	{
		if (0 == second.m_length)
		{
			return ECorrAreEqual;
		}
		else
		{
			return ECorrFirstLess;
		}
	}

	if (0 == second.m_length)
	{
		return ECorrFirstGreater;
	}
	
	ECorrCompResult res = ECorrAreEqual;
	
	if (m_length <= second.m_length)
	{
		for (UINT i = 0; i < m_length; i++)
		{
			if (m_Ids[i] != second.m_Ids[i])
			{
				if (m_Ids[i] < second.m_Ids[i])
				{
					return ECorrFirstLess;
				}
				else
				{
					return ECorrFirstGreater;
				}
			}
		}

		if (m_length < second.m_length)
		{
			res = ECorrFirstLess;
		}
	}
	else
	{
		for (UINT i = 0; i < second.m_length; i++)
		{
			if (m_Ids[i] != second.m_Ids[i])
			{
				if (m_Ids[i] < second.m_Ids[i])
				{
					return ECorrFirstLess;
				}
				else
				{
					return ECorrFirstGreater;
				}
			}
		}

		res = ECorrFirstGreater;
	}

	return res;
}


BOOL CCorrObjectID::IsSubRange(IN const CCorrObjectID& child) const
{
	if (m_length >= child.m_length)
	{
		return FALSE;
	}

	for (UINT i=0; i<m_length; i++)
	{
		if (m_Ids[i] != child.m_Ids[i])
		{
			return FALSE;
		}
	}

	return TRUE;
}


BOOL CCorrObjectID::operator ==(IN const CCorrObjectID& second) const
{
	if (ECorrAreEqual == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator !=(IN const CCorrObjectID& second) const
{
	if (ECorrAreEqual == CompareWith(second))
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

BOOL CCorrObjectID::operator <(IN const CCorrObjectID& second) const
{
	if (ECorrFirstLess == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator >(IN const CCorrObjectID& second) const
{
	if (ECorrFirstGreater == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator <=(IN const CCorrObjectID& second) const
{
	ECorrCompResult res = CompareWith(second);
	
	if ((ECorrAreEqual == res) || (ECorrFirstLess == res))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


BOOL CCorrObjectID::operator >=(IN const CCorrObjectID& second) const
{
	ECorrCompResult res = CompareWith(second);
	
	if ((ECorrAreEqual == res) || (ECorrFirstGreater == res))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

CCorrObjectID& CCorrObjectID::operator =(IN const CCorrObjectID& ID)
{
	if (m_length)
	{
		delete [] m_Ids;
	}

	m_length = ID.m_length;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ID.m_Ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator +=(IN const CCorrObjectID& ID)
{
	if (ID.m_length)
	{
		UINT* newIds = new UINT[m_length + ID.m_length];
		
		if(m_length)
		{
			memcpy(newIds, m_Ids, m_length*sizeof(UINT));
			delete [] m_Ids;
		}

		memcpy(&(newIds[m_length]), ID.m_Ids, ID.m_length*sizeof(UINT));
		m_Ids = newIds;
		m_length += ID.m_length;
	}
	
	return *this;
}

CCorrObjectID& CCorrObjectID::operator ++()
{
	if (m_length)
	{
		m_Ids[m_length - 1]++;
	}
	
	return *this;
}

CCorrObjectID& CCorrObjectID::operator --()
{
	if (m_length)
	{
		m_Ids[m_length - 1]--;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator -=(IN const UINT sub)
{
	if (sub && (m_length > sub))
	{
		m_length -= sub;
		UINT* newIds = new UINT[m_length];
		memcpy(newIds, m_Ids, m_length*sizeof(UINT));
		delete [] m_Ids;
		m_Ids = newIds;
	}
	else if (sub == m_length)
	{
		m_length = 0;
		delete [] m_Ids;
		m_Ids = NULL;
	}
	
	return *this;
}

CCorrObjectID& CCorrObjectID::operator /=(IN const UINT sub)
{
	if (sub && (m_length > sub))
	{
		m_length -= sub;
		UINT* newIds = new UINT[m_length];
		memcpy(newIds, &(m_Ids[sub]), m_length*sizeof(UINT));
		delete [] m_Ids;
		m_Ids = newIds;
	}
	else if (sub == m_length)
	{
		m_length = 0;
		delete [] m_Ids;
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID::~CCorrObjectID()
{
	if (m_length)
	{
		delete [] m_Ids;
	}
}




//============================================================================
//  CCorrRangeTableItem::CCorrRangeTableItem
//
//  This is the CCorrRangeTableItem class's only constructor. This class is derived from
//	the CObject class. This is so the MFC template storage classes can be
//	used. It is used to store a CString value in a list.
//
//
//  Parameters:
//
//      CString * str  	A pointer to the CString object to be stored.
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeTableItem::CCorrRangeTableItem(IN const CCorrObjectID& startID,
										 IN const CCorrObjectID& endID,
										 IN CCorrGroupIdItem*	grpID)
{
	m_groupId = grpID;
	CCorrObjectID temp;
	m_groupId->GetGroupID(temp);
	CCorrObjectID startRange = startID;
	startRange /= temp.GetLength();
	CCorrObjectID endRange = endID;
	endRange /= (temp.GetLength() - 1);
	m_startRange.Set(startRange);
	m_endRange.Set(endRange);
}


//============================================================================
//  CCorrRangeTableItem::~CCorrRangeTableItem
//
//  This is the CCorrRangeTableItem class's only destructor. It frees the memory used
//	to store the CString members.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeTableItem::~CCorrRangeTableItem()
{

}


BOOL CCorrRangeTableItem::GetStartRange(OUT CCorrObjectID& start) const
{
	if (!m_groupId)
		return FALSE;

	m_groupId->GetGroupID(start);
	CCorrObjectID tmp;
	m_startRange.ExtractOID(tmp);
	start += tmp;
	return TRUE;
}


BOOL CCorrRangeTableItem::GetEndRange(OUT CCorrObjectID& end) const
{
	if (!m_groupId)
		return FALSE;

	m_groupId->GetGroupID(end);
	end -= 1;
	CCorrObjectID tmp;
	m_endRange.ExtractOID(tmp);
	end += tmp;
	return TRUE;
}

CCorrRangeTableItem::ECorrRangeResult CCorrRangeTableItem::
									IsInRange(IN const CCorrObjectID& ID) const
{
	CCorrObjectID a;
	
	GetStartRange(a);

	if (ID == a)
	{
		return ECorrEqualToStart;
	}

	if (ID < a)
	{
		return ECorrBeforeStart;
	}

	CCorrObjectID b;
	GetEndRange(b);

	if (ID == b)
	{
		return ECorrEqualToEnd;
	}
	
	if (ID > b)
	{
		return ECorrAfterEnd;
	}

	return ECorrInRange;
}


void CCorrRangeTableItem::DebugOutputRange() const
{
DebugMacro6( 
	if (m_groupId)
	{
		CString debugstr;
		CCorrObjectID tmp;
		m_groupId->GetGroupID(tmp);
		tmp.GetString(debugstr);
		CString out1;
		CCorrObjectID start;
		GetStartRange(start);
		start.GetString(out1);
		CString out2;
		CCorrObjectID end;
		GetEndRange(end);
		end.GetString(out2);
		debugstr += "\t\t:\t\t";
		debugstr += out1;
		debugstr += "\t\t:\t\t";
		debugstr += out2;
		debugstr += "\t\tGroup : Start : End\n";
		SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
			debugstr);
	}
	else
	{
		SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
			L"Attempt to output empty RangeTableItem\n");
	}
)
}


//============================================================================
//  CCorrRangeList::~CCorrRangeList
//
//  This is the CCorrRangeList class's only desstructor. If there are any items in
//	the queue they are deleted.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeList::~CCorrRangeList()
{
	while(!IsEmpty())
	{
		CCorrRangeTableItem * item = RemoveHead();
		delete item;
	}
}


//============================================================================
//  CCorrRangeList::Add
//
//  This public method is called to add a CCorrRangeTableItem into this CCorrRangeList. The
//	CCorrRangeTableItem is not added if it is already present in the list. If this is the
//	case a pointer to the matching item in the list is returned.
//
//
//  Parameters:
//
//		CCorrRangeTableItem * newItem	A pointer to the CCorrRangeTableItem to be added. 
//
//  Returns:
//
//      CCorrRangeTableItem *			A pointer to the item if is in the list. NULL if
//							the item was not found and was added.
//
//============================================================================

BOOL CCorrRangeList::Add(IN CCorrRangeTableItem* newItem)
{
	AddTail(newItem); //empty or all items smaller
	return TRUE;
}


BOOL CCorrRangeList::GetLastEndOID(OUT CCorrObjectID& end) const
{
	if (IsEmpty())
	{
		return FALSE;
	}
	
	return (GetTail()->GetEndRange(end));
}


CCorrGroupMask::CCorrGroupMask(IN const TCorrMaskLength sze) 
{
	m_size = sze;
	
	if (m_size)
	{
		TCorrMaskLength x = m_size / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);

		if (m_size % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE))
		{
			x++;
		}

		m_mask = new TCorrMaskUnit[x];
		ZeroMemory((PVOID)m_mask, (DWORD)(sizeof(TCorrMaskUnit)*x));
	}
	else
	{
		m_mask = NULL;
	}
}

BOOL CCorrGroupMask::IsBitSet(IN const TCorrMaskLength bit)const
{
	TCorrMaskLength x = bit / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
	TCorrMaskLength val = bit % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);

	return (((m_mask[x] >> val) & 1) == 1);
}

void CCorrGroupMask::SetBit(IN const TCorrMaskLength bit, IN const BOOL On)
{
	BOOL IsBit = IsBitSet(bit);

	if ((IsBit && On) || (!IsBit && !On))
	{
		return;
	}
	else
	{
		TCorrMaskLength x = bit / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
		TCorrMaskLength val = bit % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
		TCorrMaskLength maskval = 1;
		maskval <<= val;
		
		if (On)
		{
			m_mask[x] += maskval;
		}
		else
		{
			m_mask[x] -= maskval;
		}
	}
}

CCorrGroupMask::~CCorrGroupMask() 
{
	if (m_mask)
	{
		delete [] m_mask;
	}
}

CCorrCache::CCorrCache( ISmirInterrogator *a_ISmirInterrogator ) 
{
	m_ValidCache = TRUE;
	m_Groups = NULL;
	m_Ref_Count = 0;
	m_size = 0;
	BuildCacheAndSetNotify( a_ISmirInterrogator );
	
	if (m_groupTable.GetSize())
	{
		m_Groups = new CCorrGroupMask(m_size);
		BuildRangeTable();
	}
}

CCorrCache::~CCorrCache() 
{
	if (m_Groups)
	{
		delete m_Groups;
	}
}

void CCorrCache::InvalidateCache()
{
	m_Lock.Lock();

	if (!m_Ref_Count)
	{
		delete this;
	}
	else
	{
		m_ValidCache = FALSE;
		m_Lock.Unlock();
	}
}

BOOL CCorrCache::BuildCacheAndSetNotify( ISmirInterrogator *a_ISmirInterrogator )
{
	LPUNKNOWN pInterrogativeInt = NULL;

//	===============================================================
//	The following relies on the current thread having been
//	initialised for OLE (i.e. by the use of CoInitialize)
//	===============================================================

	HRESULT hr = S_OK ;

	if ( a_ISmirInterrogator )
	{
		hr = a_ISmirInterrogator->QueryInterface (

			IID_ISMIR_Interrogative, (void**)&pInterrogativeInt
		);
	}
	else
	{
		HRESULT hr = CoCreateInstance (CLSID_SMIR_Database,
						NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						IID_ISMIR_Interrogative, (void**)&pInterrogativeInt);
	}

	if (NULL == pInterrogativeInt)
	{
		return FALSE;
	}

	IEnumGroup  *pTEnumSmirGroup = NULL;
	
	//enum all groups
	hr = ((ISmirInterrogator*)pInterrogativeInt)->EnumGroups(&pTEnumSmirGroup, NULL);
	
	//now use the enumerator
	if(NULL == pTEnumSmirGroup)
	{
		pInterrogativeInt->Release();
		return FALSE;
	}

	ISmirGroupHandle *phModule=NULL;

DebugMacro6( 
		SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
			L"CCorrCache::BuildCacheAndSetNotify - Accessing SMIR Getting Groups\n");
)

	
	for(int iCount=0; S_OK == pTEnumSmirGroup->Next(1, &phModule, NULL); iCount++)
	{
		//DO SOMETHING WITH THE GROUP HANDLE

		//eg get the name
		BSTR szName=NULL;
		char buff[1024];
		LPSTR pbuff = buff;
		int lbuff = sizeof(buff);
		phModule->GetGroupOID(&szName);

		if (FALSE == WideCharToMultiByte(CP_ACP, 0,
						szName, -1, pbuff, lbuff, NULL, NULL))
		{
			DWORD lasterr = GetLastError();
			SysFreeString(szName);
			phModule->Release();
DebugMacro6( 
			SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
				L"CCorrCache::BuildCacheAndSetNotify - Error bad BSTR conversion\n");
)
			continue;
		}

		SysFreeString(szName);
		CCorrObjectID grpId(buff);
		CCorrObjectID zero;

		if (zero != grpId)
		{
			CCorrGroupIdItem* groupId = new CCorrGroupIdItem(grpId, phModule);
			m_groupTable.Add(groupId);
			m_size++;
		}

DebugMacro6( 
		SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
			L"%s\n", buff);
)
	}

DebugMacro6( 
	SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
		L"CCorrCache::BuildCacheAndSetNotify - Finished accessing SMIR Getting Groups\n");
)
	pTEnumSmirGroup->Release();

	if (NULL == g_pNotifyInt)
	{
		hr = pInterrogativeInt->QueryInterface(IID_ISMIR_Database,
			(void **) &g_pNotifyInt);

		if(SUCCEEDED(hr))
		{
			if( gp_notify== NULL)
			{
				DWORD dw;
				gp_notify = new CCorrCacheNotify();
				gp_notify->AddRef();
				hr = g_pNotifyInt->AddNotify(gp_notify, &dw);

				if(SUCCEEDED(hr))
				{
					gp_notify->SetCookie(dw);
				}
			}
		}
	}
	else
	{
		if( gp_notify== NULL)
		{
			DWORD dw;
			gp_notify = new CCorrCacheNotify();
			gp_notify->AddRef();
			hr = g_pNotifyInt->AddNotify(gp_notify, &dw);

			if(SUCCEEDED(hr))
			{
				gp_notify->SetCookie(dw);
			}
		}
	}

	pInterrogativeInt->Release();

	if ((NULL == gp_notify) || (0 == gp_notify->GetCookie()))
	{
		return FALSE;
	}

	return TRUE;
}

#pragma warning (disable:4018)

BOOL CCorrCache::BuildRangeTable() 
{
	UINT pos = 0;
	TCorrMaskLength posIndex = 0;
	TCorrMaskLength nextIndex = 1;
	m_groupTable.Sort();

DebugMacro6( 
	SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
		L"CCorrCache::BuildRangeTable - Printing sorted group table...\n");

	for (int x = 0; x < m_groupTable.GetSize(); x++) 
	{
		CCorrGroupIdItem * i = m_groupTable.GetAt(x);
		i->DebugOutputItem();
	}

	SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
		L"CCorrCache::BuildRangeTable - Finished printing sorted group table...\n");
)

	while (pos < m_groupTable.GetSize())
	{
		UINT nextpos = pos + 1;
		DoGroupEntry(&pos, &nextpos, &posIndex, &nextIndex);
		pos = nextpos;
		posIndex = nextIndex++;
	}

	return TRUE;
}

#pragma warning (default:4018)

#pragma warning (disable:4018)

void CCorrCache::DoGroupEntry(UINT* current, UINT* next,
							 TCorrMaskLength* cIndex, TCorrMaskLength* nIndex)
{
	CCorrGroupIdItem* alpha = m_groupTable.GetAt(*current);
	CCorrObjectID a;
	alpha->GetGroupID(a);
	CCorrObjectID End(a);
	++End;

	if (*next < m_groupTable.GetSize())
	{
		CCorrGroupIdItem* beta = m_groupTable.GetAt(*next);
		CCorrObjectID b;
		beta->GetGroupID(b);

		//check for duplicates
		while ((a == b) && (*next < m_groupTable.GetSize()))
		{
DebugMacro6( 
			SnmpDebugLog::s_SnmpDebugLog->Write(__FILE__,__LINE__,
				L"Deleting duplicate non MIB2 group... ");
			beta->DebugOutputItem();
)

			//add the group handles to the one not being deleted
			while (!beta->m_groupHandles.IsEmpty())
			{
				alpha->m_groupHandles.AddTail(beta->m_groupHandles.RemoveHead());
			}

			m_groupTable.RemoveAt(*next);
			delete beta;
			beta = m_groupTable.GetAt(*next);
			beta->GetGroupID(b);
		}

		//after checking for duplicates, check we still meet the initial condition
		if (*next < m_groupTable.GetSize())
		{
			
			//if the next item is not a child of this
			if ((a.GetLength() >= b.GetLength()) || (!a.IsSubRange(b)))
			{
				CCorrObjectID c;
				CCorrRangeTableItem* newEntry;

				if (!m_rangeTable.GetLastEndOID(c) || !a.IsSubRange(c))
				{
					//add whole of a-range to rangetable
					newEntry = new CCorrRangeTableItem(a, End, alpha);
				}
				else
				{
					//add from c to end of a-range to rangetable
					newEntry = new CCorrRangeTableItem(c, End, alpha);
				}

				newEntry->DebugOutputRange();

				m_rangeTable.Add(newEntry);
				alpha->SetIndex(*cIndex);
				m_Groups->SetBit(*cIndex);
			}
			else //the next item is a child so add a subrange and do the child - recurse!
			{
				CCorrObjectID c;
				CCorrRangeTableItem* newEntry;

				if (!m_rangeTable.GetLastEndOID(c) || !a.IsSubRange(c))
				{
					//add start of a-range to start of b to rangetable
					newEntry = new CCorrRangeTableItem(a, b, alpha);
				}
				else
				{
					//add from c to start of b to rangetable
					newEntry = new CCorrRangeTableItem(c, b, alpha);
				}

				newEntry->DebugOutputRange();

				m_rangeTable.Add(newEntry);
				UINT temp = (*next)++;
				TCorrMaskLength tempIndex = (*nIndex)++;
				DoGroupEntry(&temp, next, &tempIndex, nIndex);

				if (*next >= m_groupTable.GetSize())
				{
					m_rangeTable.GetLastEndOID(c);
					////add from c to end of a-range to rangetable
					newEntry = new CCorrRangeTableItem(c, End, alpha);
					m_rangeTable.Add(newEntry);
					alpha->SetIndex(*cIndex);
					m_Groups->SetBit(*cIndex);
					newEntry->DebugOutputRange();
				}

				//while the new next one(s) is a child add it first - recurse AGAIN!
				while(!m_Groups->IsBitSet(*cIndex))
				{
					DoGroupEntry(current, next, cIndex, nIndex);
				}
			}
		}
	}

	//if this is the last item then add it.
	if (*current == m_groupTable.GetUpperBound())
	{
		//add whole of a-range to rangetable
		CCorrRangeTableItem* newEntry = new CCorrRangeTableItem(a, End, alpha);
		m_rangeTable.Add(newEntry);
		alpha->SetIndex(*cIndex);
		m_Groups->SetBit(*cIndex);
		newEntry->DebugOutputRange();
	}
}

#pragma warning (default:4018)

void CCorrCache::AddRef()
{
	m_Lock.Lock();
	m_Ref_Count++;
	m_Lock.Unlock();
}

void CCorrCache::DecRef()
{
	m_Lock.Lock();

	if (m_Ref_Count)
		m_Ref_Count--;

	if (!m_Ref_Count && !m_ValidCache)
	{
		delete this;
		return;
	}
	
	m_Lock.Unlock();

}



CCorrEncodedOID::CCorrEncodedOID(IN const CCorrObjectID& src_oid)
{
	Set(src_oid);
}

void CCorrEncodedOID::Set(IN const CCorrObjectID& src_oid)
{
	m_chopped = 0;
	UINT x = 0;
	UINT oidlength = src_oid.GetLength();

	if (oidlength)
	{
		UCHAR buff[MAX_OID_LENGTH*MAX_BYTES_PER_FIELD];
		const UINT* oid_ids = src_oid.GetIds();
		
		for (UINT i = 0; i < oidlength; i++)
		{
			UINT val = oid_ids[i];

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT28)
			{
				buff[x++] = BIT7 + ((val & HI4BITS) >> 28);
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT21)
			{
				buff[x++] = BIT7 + ((val & HIMID7BITS) >> 21);
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT14)
			{
				buff[x++] = BIT7 + ((val & MID7BITS) >> 14);
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT7)
			{
				buff[x++] = BIT7 + ((val & LOMID7BITS) >> 7);
			}

			//get the next seven bits and store in byte
			buff[x++] = (val & LO7BITS);
		}
		
		//Remove the standard 1.3.6.1 if necessary...
		if ((1 == buff[0]) && (3 == buff[1]) &&
			(6 == buff[2]) && (1 == buff[3]))
		{
			m_chopped = 1;
			m_ids = new UCHAR[x-4];
			m_length = x-4;
			memcpy(m_ids, &buff[4], m_length*sizeof(UCHAR));
		}
		else
		{
			m_ids = new UCHAR[x];
			m_length = x;
			memcpy(m_ids, buff, m_length*sizeof(UCHAR));
		}
	}
	else
	{
		m_ids = NULL;
	}
}


void CCorrEncodedOID::ExtractOID(OUT CCorrObjectID& src_oid) const
{
	if (m_length)
	{
		UINT buff[MAX_OID_LENGTH];
		UINT x = 0;
		
		//Add the standard 1.3.6.1 if necessary...
		if (m_chopped == 1)
		{
			buff[0] = 1;
			buff[1] = 3;
			buff[2] = 6;
			buff[3] = 1;
			x = 4;
		}

		for (UINT i = 0; i < m_length; i++)
		{
			//extract the value of the byte
			buff[x] = m_ids[i] & LO7BITS;

			//are there more bytes for this UINT
			while ((i < m_length) && (m_ids[i] & 128))
			{
				//shift the value by a "byte" and extract tbe next byte.
				buff[x] = buff[x] << 7;
				buff[x] += m_ids[++i] & LO7BITS;
			}

			x++;
		}

		src_oid.Set(buff, x);
	}
	else
	{
		src_oid.Set(NULL, 0);
	}

}


CCorrEncodedOID::~CCorrEncodedOID()
{
	delete [] m_ids;
}

CCorrCacheWrapper::CCorrCacheWrapper(IN CCorrCache* cachePtr)
{
	m_lockit = new CCriticalSection();
	m_CachePtr = cachePtr;
}

CCorrCache* CCorrCacheWrapper::GetCache()
{
	m_lockit->Lock();
	return m_CachePtr;
}

CCorrCacheWrapper::~CCorrCacheWrapper()
{
	delete m_lockit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\corafx.h ===
//****************************************************************************

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  corafx.h
//
//  SNMP MIB CORRELATOR MFC INCLUDES - SNMPCORR.DLL
//
//****************************************************************************

#ifndef _SNMPCORR_CORAFX
#define _SNMPCORR_CORAFX 




// corafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <snmpstd.h>
#include <snmpcoll.h>
#include <snmptempl.h>
#include <fstream.h>		// File Streams
#include <snmpmt.h>			// MFC Critical Sections

//#include <afx.h>
#include <strstrea.h>
#endif //_SNMPCORR_CORAFX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\classfac.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMPProvClassFactory_H
#define _SNMPProvClassFactory_H

class CClasProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CClasProvClassFactory () ;
    ~CClasProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CPropProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CPropProvClassFactory () ;
    ~CPropProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CSNMPEventProviderClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CSNMPEventProviderClassFactory () ;
    ~CSNMPEventProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP LockServer ( BOOL ) ;
};

class CSNMPEncapEventProviderClassFactory : public CSNMPEventProviderClassFactory
{
public:

	//IClassFactory member
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

class CSNMPRefEventProviderClassFactory : public CSNMPEventProviderClassFactory
{
public:

	//IClassFactory member
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

#endif // _SNMPProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\cormap.h ===
//****************************************************************************

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  cormap.h
//
//  SNMP MIB CORRELATOR MAP CLASS - SNMPCORR.DLL
//
//****************************************************************************
#ifndef _SNMPCORR_CORMAP
#define _SNMPCORR_CORMAP


class CCorrelatorMap : public CMap< DWORD, DWORD, CCorrelator*, CCorrelator* >
{
private:

	CCriticalSection	m_MapLock;
	UINT HashKey(DWORD key) { return (UINT)key; }


public:

	void Register(CCorrelator *key);
	void UnRegister(CCorrelator *key);
	~CCorrelatorMap();


};


#endif //_SNMPCORR_CORSTORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\cordefs.h ===
//****************************************************************************

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  cordefs.h
//
//  SNMP MIB CORRELATOR DEFINITIONS - SNMPCORR.DLL
//
//****************************************************************************
#ifndef _SNMPCORR_CORDEFS
#define _SNMPCORR_CORDEFS

#define BITS_PER_BYTE		8
#define BYTES_PER_FIELD		4
#define FIELD_SEPARATOR		'.'
#define EOS					'\0'
#define CORRELATOR_KEY		L"Software\\Microsoft\\WBEM\\Providers\\SNMP\\Correlator"
#define CORRELATOR_VALUE	L"MaxVarBinds"
#define VARBIND_COUNT		6
#define MIB2				"RFC1213-MIB"
#define MAX_MODULE_LENGTH	1024
#define MAX_OID_STRING		519 //xxx. to a max of 128 components 4*128 plus a little extra
#define MAX_OID_LENGTH		128
#define MAX_BYTES_PER_FIELD 5
#define BIT28				268435456	// 1 << 28
#define BIT21				2097152		// 1 << 21
#define BIT14				16384		// 1 << 14
#define BIT7				128			// 1 << 7
#define HI4BITS				4026531840	// 15 << 28
#define HIMID7BITS			266338304	// 127 << 21
#define MID7BITS			2080768		// 127 << 14
#define LOMID7BITS			16256		// 127 << 7
#define LO7BITS				127


#endif //_SNMPCORR_CORDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\corrsnmp.h ===
//****************************************************************************

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  corrsnmp.h
//
//  SNMP MIB CORRELATOR SNMP CLASS LIBRARY INTERACTION - SNMPCORR.DLL
//
//****************************************************************************
#ifndef _SNMPCORR_CORRSNMP
#define _SNMPCORR_CORRSNMP 

#include "snmpcl.h"

class CCorrResult
{
public:

	SnmpObjectIdentifier m_In;
	CCorrObjectID m_Out;
	SnmpErrorReport m_report;

	CCorrResult();
	~CCorrResult();
	void	DebugOutputSNMPResult() const;

};


class  CCorrNextId : public SnmpGetNextOperation
{
private:
	
	void ReceiveResponse();
	
	char *GetString(IN const SnmpObjectIdentifier &id);

	// the following two methods from SnmpGetNextOperation are 
	// over-ridden.

	void ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error);

	void ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error);

protected:

	CCorrResult	*m_Results;
	UINT		m_ResultsCnt;
	UINT		m_NextResult;

	// this is a callback through which the CCorrNextId class returns the next_id
	// the callee must make a copy of the "next_id"
	// the Correlator_Info may take a value Local_Error
	virtual void ReceiveNextId(OUT const SnmpErrorReport &error,
			    			   OUT const CCorrObjectID &next_id) = 0;

	BOOL GetNextResult();

public:

	// constructor - creates an operation and passes the snmp_session to it
	CCorrNextId(IN SnmpSession &snmp_session);

	// frees the m_object_id_string if required
	~CCorrNextId();

	// in case of an error encountered while the method executes, 
	// ReceiveNextId(LocalError, NULL) will be called synchronously
	// otherwise, an asynchronous call to ReceiveNextId provides the next_id	
	void GetNextId(IN const CCorrObjectID const *object_ids, IN UINT len);

	void *operator()(void) const
	{
		return SnmpGetNextOperation::operator()();
	}
};



#endif // _SNMPCORR_CORRSNMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\dnf.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __DNF_TREE_H
#define __DNF_TREE_H

class SnmpOrNode : public SnmpTreeNode
{
private:
protected:
public:

	SnmpOrNode ( 

		SnmpTreeNode *a_Left = NULL , 
		SnmpTreeNode *a_Right = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpTreeNode ( NULL , a_Left , a_Right , a_Parent ) {}

	~SnmpOrNode () ;

	SnmpTreeNode *Copy () ;

	void Print () ;
} ;

class SnmpAndNode : public SnmpTreeNode
{
private:
protected:
public:

	SnmpAndNode ( 

		SnmpTreeNode *a_Left = NULL , 
		SnmpTreeNode *a_Right = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpTreeNode ( NULL , a_Left , a_Right , a_Parent ) {}

	~SnmpAndNode () ;

	SnmpTreeNode *Copy () ;

	void Print () ;

} ;

class SnmpNotNode : public SnmpTreeNode
{
private:
protected:
public:

	SnmpNotNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpTreeNode ( NULL , a_Node , NULL , a_Parent ) {}

	~SnmpNotNode () ;

	SnmpTreeNode *Copy () ;

	void Print () ;

} ;

class SnmpRangeNode ;

class SnmpOperatorNode : public SnmpTreeNode
{
private:
protected:
public:

	SnmpOperatorNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpTreeNode ( NULL , a_Node , NULL , a_Parent ) {}

	~SnmpOperatorNode () {} ;

	virtual SnmpRangeNode *GetRange () = 0 ;
} ;

class SnmpOperatorEqualNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorEqualNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorEqualNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () ;

	void Print () ;

} ;

class SnmpOperatorNotEqualNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorNotEqualNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorNotEqualNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () { return NULL ; }

	void Print () ;

} ;

class SnmpOperatorEqualOrGreaterNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorEqualOrGreaterNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorEqualOrGreaterNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () ;

	void Print () ;

} ;

class SnmpOperatorEqualOrLessNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorEqualOrLessNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorEqualOrLessNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () ;

	void Print () ;

} ;

class SnmpOperatorGreaterNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorGreaterNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorGreaterNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () ;

	void Print () ;

} ;

class SnmpOperatorLessNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorLessNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorLessNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () ;

	void Print () ;

} ;

class SnmpOperatorLikeNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorLikeNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorLikeNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () ;

	void Print () ;

} ;

class SnmpOperatorNotLikeNode : public SnmpOperatorNode
{
private:
protected:
public:

	SnmpOperatorNotLikeNode ( 

		SnmpTreeNode *a_Node = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpOperatorNode ( a_Node , a_Parent ) {}

	~SnmpOperatorNotLikeNode () ;

	SnmpTreeNode *Copy () ;

	SnmpRangeNode *GetRange () ;

	void Print () ;

} ;

class SnmpValueNode : public SnmpTreeNode
{
public:

	enum SnmpValueFunction
	{
		Function_None = SQL_LEVEL_1_TOKEN :: IFUNC_NONE ,
		Function_Upper = SQL_LEVEL_1_TOKEN :: IFUNC_UPPER ,
		Function_Lower = SQL_LEVEL_1_TOKEN :: IFUNC_LOWER
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	SnmpValueFunction m_PropertyFunction ;
	SnmpValueFunction m_ConstantFunction ;

public:

	SnmpValueNode ( 

		BSTR a_PropertyName ,
		SnmpValueFunction a_PropertyFunction ,
		SnmpValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpTreeNode ( NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
		else
			m_PropertyName = NULL ;
	}

	~SnmpValueNode ()
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	SnmpValueNode :: SnmpValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	SnmpValueNode :: SnmpValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( SnmpValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

class SnmpSignedIntegerNode : public SnmpValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	SnmpSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpValueNode ( 

			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	SnmpTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
			return FALSE ;
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
			return FALSE ;
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;

} ;

class SnmpUnsignedIntegerNode : public SnmpValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	SnmpUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpValueNode ( 

			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	SnmpTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
			return FALSE ;
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
			return FALSE ;
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;

} ;

class SnmpStringNode : public SnmpValueNode
{
private:
protected:

	BSTR m_String ;

public:

	SnmpStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		SnmpValueNode :: SnmpValueFunction a_PropertyFunction ,
		SnmpValueNode :: SnmpValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpValueNode ( 

			a_PropertyName , 
			a_PropertyFunction , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
		if ( a_String ) 
		{
			if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = tolower ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = toupper ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else
			{
				m_String = SysAllocString ( a_String ) ;
			}
		}
		else
			m_String = NULL ;
	}

	~SnmpStringNode ()
	{
		if ( m_String )
			SysFreeString ( m_String ) ;
	} ;

	SnmpTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( BSTR &a_String )
	{
		if ( wcscmp ( L"" , m_String ) == 0 )
			return FALSE ;
		else
		{
			ULONG t_StringLen = wcslen ( m_String ) ;
			wchar_t *t_String = NULL ;

			if ( m_String [ t_StringLen - 1 ] == 0x01 )
			{
				t_String = new wchar_t [ t_StringLen ] ;
				wcsncpy ( t_String , m_String , t_StringLen - 1 ) ;
				t_String [ t_StringLen ] = 0 ;
			}
			else
			{
				t_String = new wchar_t [ t_StringLen + 1 ] ;
				wcscpy ( t_String , m_String ) ;
				t_String [ t_StringLen - 1 ] = t_String [ t_StringLen - 1 ] - 1 ;
			}			
			
			a_String = SysAllocString ( t_String ) ;
			delete [] t_String ;

			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( BSTR &a_String )
	{
		ULONG t_StringLen = wcslen ( m_String ) ;
		wchar_t *t_String = new wchar_t [ t_StringLen + 2 ] ;
		wcscpy ( t_String , m_String ) ;
		t_String [ t_StringLen ] = 0x01 ;
		t_String [ t_StringLen ] = 0x00 ;

		a_String = SysAllocString ( t_String ) ;

		delete [] t_String ;

		return TRUE ;
	}

	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;

} ;

class SnmpNullNode : public SnmpValueNode
{
private:
protected:
public:

	SnmpNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpValueNode ( 

			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	SnmpTreeNode *Copy () ;

	void Print () ;

} ;

class SnmpRangeNode : public SnmpTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	SnmpRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		SnmpTreeNode *a_NextNode = NULL ,
		SnmpTreeNode *a_Parent = NULL 
		
	) : SnmpTreeNode ( NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
		else
			m_PropertyName = NULL ;
	} ;

	~SnmpRangeNode () 
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	LONG ComparePropertyName ( SnmpRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }

} ;

class SnmpUnsignedIntegerRangeNode : public SnmpRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	SnmpUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		SnmpTreeNode *a_NextNode = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpRangeNode ( 

			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	SnmpTreeNode *Copy () ;
	
	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;

	BOOL GetIntersectingRange (

		SnmpUnsignedIntegerRangeNode &a_Range ,
		SnmpUnsignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetOverlappingRange (

		SnmpUnsignedIntegerRangeNode &a_Range ,
		SnmpUnsignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetNonIntersectingRange (

		SnmpUnsignedIntegerRangeNode &a_Range ,
		SnmpUnsignedIntegerRangeNode *&a_Before ,
		SnmpUnsignedIntegerRangeNode *&a_Intersection ,
		SnmpUnsignedIntegerRangeNode *&a_After 
	) ;

} ;

class SnmpSignedIntegerRangeNode : public SnmpRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	SnmpSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		SnmpTreeNode *a_NextNode = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpRangeNode ( 

			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	SnmpTreeNode *Copy () ;
	
	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;

	BOOL GetIntersectingRange (

		SnmpSignedIntegerRangeNode &a_Range ,
		SnmpSignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetOverlappingRange (

		SnmpSignedIntegerRangeNode &a_Range ,
		SnmpSignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetNonIntersectingRange (

		SnmpSignedIntegerRangeNode &a_Range ,
		SnmpSignedIntegerRangeNode *&a_Before ,
		SnmpSignedIntegerRangeNode *&a_Intersection ,
		SnmpSignedIntegerRangeNode *&a_After 
	) ;
} ;

class SnmpStringRangeNode : public SnmpRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	SnmpStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		SnmpTreeNode *a_NextNode = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpRangeNode ( 

			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
			m_LowerBound = SysAllocString ( a_LowerBound ) ;
		else
			m_LowerBound = NULL ;

		if ( a_UpperBound )
			m_UpperBound = SysAllocString ( a_UpperBound ) ;
		else
			m_UpperBound = NULL ;
	}

	~SnmpStringRangeNode ()
	{
		if ( m_LowerBound )
			SysFreeString ( m_LowerBound ) ;

		if ( m_UpperBound )
			SysFreeString ( m_UpperBound ) ;
	} ;

	SnmpTreeNode *Copy () ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;

	BOOL GetIntersectingRange (

		SnmpStringRangeNode &a_Range ,
		SnmpStringRangeNode *&a_Intersection
	) ;

	BOOL GetOverlappingRange (

		SnmpStringRangeNode &a_Range ,
		SnmpStringRangeNode *&a_Intersection
	) ;

	BOOL GetNonIntersectingRange (

		SnmpStringRangeNode &a_Range ,
		SnmpStringRangeNode *&a_Before ,
		SnmpStringRangeNode *&a_Intersection ,
		SnmpStringRangeNode *&a_After 
	) ;
} ;

class SnmpNullRangeNode : public SnmpRangeNode
{
private:
protected:
public:

	SnmpNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		SnmpTreeNode *a_NextNode = NULL ,
		SnmpTreeNode *a_Parent = NULL 

	) : SnmpRangeNode ( 

			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~SnmpNullRangeNode ()
	{
	} ;

	SnmpTreeNode *Copy () ;

	void Print () ;

} ;

class Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	SnmpRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount )
	{
		m_RangeContainer = new SnmpRangeNode * [ a_RangeContainerCount ] ;
		for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
		{
			m_RangeContainer [ t_Index ] = NULL ;
		}
	}

	~Conjunctions () 
	{
		for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
		{
			delete m_RangeContainer [ t_Index ] ;
		}

		delete [] m_RangeContainer ;
	} ;	

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	SnmpRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
			return NULL ;
	}

	void SetRange ( ULONG a_Index , SnmpRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
				delete m_RangeContainer [ a_Index ] ;

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

class Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount )
	{
		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
		{
			Conjunctions *t_Disjunction = new Conjunctions ( a_ConjunctionCount ) ;
			m_Disjunction [ t_Index ] = t_Disjunction ;
		}
	}

	~Disjunctions () 
	{
		for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
		{
			Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
			delete t_Disjunction ;
		}
		
		delete [] m_Disjunction ;
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
			return NULL ;
	}
} ;

class PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	SnmpRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;
		for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
		{
			delete m_NonOverlappingPartitions [ t_Index ] ;
		}

		delete [] m_NonOverlappingPartitions ;
	}

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }


	void SetRange ( SnmpRangeNode *a_Range ) { m_Range = a_Range ; }
	SnmpRangeNode *GetRange () { return m_Range ; }

	void CreatePartitions ( ULONG a_Count ) 
	{
		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
		{
			m_NonOverlappingPartitions [ t_Index ] = NULL ;
		}
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
	}

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
			return m_NonOverlappingPartitions [ a_Index ] ;
		else
			return NULL ;
	}

} ;

class QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL EvaluateNotEqualExpression ( SnmpTreeNode *&a_Node ) ;

	BOOL EvaluateNotExpression ( SnmpTreeNode *&a_Node ) ;

	BOOL EvaluateAndExpression ( SnmpTreeNode *&a_Node ) ;

	BOOL EvaluateOrExpression ( SnmpTreeNode *&a_Node ) ;

	BOOL RecursiveEvaluate ( 

		SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
		SnmpTreeNode *a_Parent , 
		SnmpTreeNode **a_Node , 
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_AndChild , 
		SnmpTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	BOOL RecursiveDisjunctiveNormalForm ( SnmpTreeNode *&a_Node ) ;

	void TransformAndTrueEvaluation ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		SnmpTreeNode *&a_Node , 
		SnmpTreeNode *a_Child 
	) ;

	QuadState RecursiveRemoveInvariants ( SnmpTreeNode *&a_Root ) ;

	BOOL RecursiveInsertNode ( SnmpTreeNode *&a_Root , SnmpTreeNode *&a_Node ) ;
	BOOL InsertNode ( SnmpTreeNode *&a_Root , SnmpTreeNode *&a_Node ) ;

	BOOL RecursiveSortConditionals ( SnmpTreeNode *&a_Root , SnmpTreeNode *&a_NewRoot ) ;
	BOOL SortConditionals ( SnmpTreeNode *&a_Root ) ;
	BOOL RecursiveSort ( SnmpTreeNode *&a_Root ) ;

	void TransformOperatorToRange ( 

		SnmpTreeNode *&a_Node
	) ;

	BOOL RecursiveConvertToRanges ( SnmpTreeNode *&a_Root ) ;

	void TransformIntersectingRange (

		SnmpTreeNode *&a_Node ,
		SnmpTreeNode *a_Compare ,
		SnmpTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		SnmpTreeNode *&a_Node ,
		SnmpTreeNode *a_Compare
	) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( SnmpTreeNode *&a_Root , SnmpTreeNode *&a_Compare ) ;

	void CountDisjunctions ( SnmpTreeNode *a_Root , ULONG &a_Count ) ;
	void CreateDisjunctions ( 

		SnmpTreeNode *a_Node , 
		Disjunctions *a_Disjunctions , 
		ULONG a_PropertiesToPartitionCount ,
		BSTR *a_PropertiesToPartition ,
		ULONG &a_DisjunctionIndex 
	) ;

	BOOL RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an SnmpUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual SnmpTreeNode *AllocTypeNode ( 

		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		SnmpValueNode :: SnmpValueFunction a_PropertyFunction ,
		SnmpValueNode :: SnmpValueFunction a_ConstantFunction ,
		SnmpTreeNode *a_Parent 

	) = 0 ;

	virtual QuadState InvariantEvaluate ( 

		SnmpTreeNode *a_Operator ,
		SnmpTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual SnmpRangeNode *AllocInfiniteRangeNode (

		BSTR a_PropertyName 

	) = 0 ;

	virtual void GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container ) = 0 ;

protected:

	BOOL Evaluate ( SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , SnmpTreeNode **a_Root ) ;
	void DisjunctiveNormalForm ( SnmpTreeNode *&a_Root ) ;
	QuadState RemoveInvariants ( SnmpTreeNode *&a_Root ) ;
	BOOL Sort ( SnmpTreeNode *&a_Root ) ;
	BOOL ConvertToRanges ( SnmpTreeNode *&a_Root ) ;
	QuadState RemoveNonOverlappingRanges ( SnmpTreeNode *&a_Root ) ;
	BOOL CreateDisjunctionContainer ( SnmpTreeNode *a_Root , Disjunctions *&a_Disjunctions ) ;
	BOOL CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition ) ;

	void PrintTree ( SnmpTreeNode *a_Root ) ;

public:

	QuadState Preprocess ( SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , PartitionSet *&a_Partition ) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\evtdefs.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMP_EVT_PROV_EVTDEFS_H
#define _SNMP_EVT_PROV_EVTDEFS_H

//common strings
#define WBEMS_CLASS_PROP		L"__CLASS"
#define EVENT_ADDR_PROP		L"AgentAddress"
#define EVENT_TADDR_PROP	L"AgentTransportAddress"
#define EVENT_TRANS_PROP	L"AgentTransportProtocol"
#define EVENT_TIME_PROP		L"TimeStamp"
#define EVENT_SOID_PROP		L"Identification"
#define EVENT_COMM_PROP		L"Community"
#define EVENT_VBL_PROP		L"VarBindList"
#define EVENT_VBINDEX_QUAL	L"VarBindIndex"
#define ASN_OPAQUE			(CString(L"OPAQUE"))
#define ASN_NULL			(CString(L"NULL VALUE"))
#define ASN_INTEGER			(CString(L"INTEGER"))
#define ASN_TIME			(CString(L"TimeTicks"))
#define ASN_GUAGE			(CString(L"Guage"))
#define ASN_COUNTER			(CString(L"Counter"))
#define ASN_OID				(CString(L"OBJECT IDENTIFIER"))
#define ASN_ADDR			(CString(L"IpAddress"))
#define ASN_OCTET			(CString(L"OCTET STRING"))
#define ASN_UINT32			(CString(L"Unsigned32"))
#define ASN_COUNTER64		(CString(L"Counter64"))
#define ASN_NSI				(CString(L"noSuchInstance"))
#define ASN_EOMV			(CString(L"endOfMibView"))
#define ASN_NSO				(CString(L"noSuchObject"))
#define SNMP_ENT_OID		(SnmpObjectIdentifier("1.3.6.1.6.3.1.1.4.3.0"))
#define SNMP_TRAP_OID		(SnmpObjectIdentifier("1.3.6.1.6.3.1.1.4.1.0"))
#define SNMP_SYS_UP_OID		(SnmpObjectIdentifier("1.3.6.1.2.1.1.3.0"))
#define VB_ENCODING_PROP1	L"Encoding"
#define VB_OBJID_PROP2		L"ObjectIdentifier"
#define VB_VALUE_PROP3		L"Value"
#define VB_CLASS_PATH		L"SnmpVarBind"

#define MAPPER_CLASS_EVENTCLASSPROP	L"EventClassName"


//Encapsulated strings
#define MAPPER_CLASS_PATH_PREFIX	L"NotificationMapper.SnmpTrapOID=\""
#define V2CLASS_NAME				L"SnmpV2Notification"
#define V1CLASS_NAME				L"SnmpV1Notification"

//Referent strings
#define EXTMAPPER_CLASS_PATH_PREFIX	L"ExtendedNotificationMapper.SnmpTrapOID=\""
#define V2EXTCLASS_NAME				L"SnmpV2ExtendedNotification"
#define V1EXTCLASS_NAME				L"SnmpV1ExtendedNotification"
#define EVENT_CIMTYPE_QUAL			L"CIMTYPE"
#define OBJECT_STR					L"object:"
#define OBJECT_STR_LEN				7
#define WHITE_SPACE_CHARS			L" \t\r\n"
#define FIXED_LENGTH_ATTRIBUTE		L"fixed_length"
#define KEY_ATTRIBUTE				L"key"
#define KEY_ORDER_ATTRIBUTE			L"key_order"
#define TEXT_CNVN_ATTRIBUTE			L"textual_convention"
#define OID_ATTRIBUTE				L"object_identifier"
#define TEXT_CNVN_INTEGER_VAL		L"INTEGER"
#define TEXT_CNVN_IP_ADDR_VAL		L"IpAddress"
#define TEXT_CNVN_OID_VAL			L"OBJECTIDENTIFIER"
#define TEXT_CNVN_OCTSTR_VAL		L"OCTETSTRING"

#endif //_SNMP_EVT_PROV_EVTDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\evtencap.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMP_EVT_PROV_EVTENCAP_H
#define _SNMP_EVT_PROV_EVTENCAP_H

class CEncapMapper : public CMapToEvent
{
private:

	BOOL GetSpecificClass();
	const wchar_t*	GetV1Class() { return V1CLASS_NAME; }
	const wchar_t*	GetV2Class() { return V2CLASS_NAME; }
	WbemSnmpClassObject* m_WbemSnmpObj;
	BOOL SetAndGetProperty(WbemSnmpProperty *hmmSnmpProp, VARIANT *pvValue);

public:

	CEncapMapper();

	HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);
	
	void GenerateInstance(IWbemClassObject** ppInst);
	void ResetData();

	~CEncapMapper();

};


#endif //_SNMP_EVT_PROV_EVTENCAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\creclass.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
class SnmpClassEventObject ;
class SnmpCorrelation : public CCorrelator
{
private:
protected:

	SnmpSession *m_session ;
	SnmpClassEventObject *m_eventObject ;

public:

#ifdef CORRELATOR_INIT
	SnmpCorrelation ( SnmpSession &session , SnmpClassEventObject *eventObject ) ;
#else //CORRELATOR_INIT
	SnmpCorrelation ( SnmpSession &session , SnmpClassEventObject *eventObject , ISmirInterrogator *a_ISmirInterrogator ) ;
#endif //CORRELATOR_INIT
	~SnmpCorrelation () ;

	void Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phModule , IN const char* objectId = NULL ) ;
	void Finished ( IN const BOOL Complete ) ;
} ;

class SnmpClassEventObject : public SnmpTaskObject
{
private:
protected:

	BOOL m_inCallstack ;
	BOOL m_correlate ;
	BOOL m_synchronousComplete ;
	ULONG m_State;
	ULONG m_GroupsReceived ;
	WbemSnmpErrorObject m_errorObject ;
	CImpClasProv *m_provider ;
	IWbemClassObject *m_namespaceObject ;
	SnmpCorrelation *m_correlator ;
	IWbemContext *m_Context ;
	ISmirInterrogator *m_Interrogator ;

	BOOL GetAgentTransport ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentTransport ) ;
	BOOL GetAgentVersion ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentVersion ) ;
	BOOL GetAgentAddress ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentAddress ) ;
	BOOL GetAgentReadCommunityName ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentRetryCount ( WbemSnmpErrorObject &a_errorObject , ULONG &agentRetryCount ) ;
	BOOL GetAgentRetryTimeout( WbemSnmpErrorObject &a_errorObject , ULONG &agentRetryTimeout ) ;
	BOOL GetAgentMaxVarBindsPerPdu ( WbemSnmpErrorObject &a_errorObject , ULONG &agentVarBindsPerPdu ) ;
	BOOL GetAgentFlowControlWindowSize ( WbemSnmpErrorObject &a_errorObject , ULONG &agentFlowControlWindowSize ) ;
	BOOL GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL GetTransportInformation ( WbemSnmpErrorObject &a_errorObject , SnmpSession *&session ) ;

	BOOL GetClass ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject **classObject , BSTR a_Class ) ;
	virtual BOOL GetNotifyStatusObject ( IWbemClassObject **notifyObject ) ;
	virtual BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

public:

	SnmpClassEventObject ( CImpClasProv *provider , IWbemContext *a_Context ) ;
	~SnmpClassEventObject () ;

	WbemSnmpErrorObject &GetErrorObject () { return m_errorObject ; }

	virtual void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) = 0 ;
	virtual void ReceiveClass ( IN IWbemClassObject *classObject ) = 0 ;
	virtual void ReceiveError ( IN const SnmpErrorReport &errorReport ) = 0 ;
	virtual void ReceiveComplete () = 0 ;

} ;

class SnmpClassGetEventObject : public SnmpClassEventObject
{
private:
protected:

	BOOL m_Received ;
	wchar_t *m_Class ;
	IWbemClassObject *m_classObject ;

	BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

public:

	SnmpClassGetEventObject ( CImpClasProv *provider , BSTR Class , IWbemContext *a_Context ) ;
	~SnmpClassGetEventObject () ;

	void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) ;

	BOOL ProcessClass ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL ProcessCorrelatedClass ( WbemSnmpErrorObject &a_errorObject ) ;

	IWbemClassObject *GetClassObject () { m_classObject->AddRef () ; return m_classObject ; }

} ;

class SnmpClassGetAsyncEventObject : public SnmpClassGetEventObject
{
private:

	IWbemObjectSink *m_notificationHandler ;

protected:
public:

	SnmpClassGetAsyncEventObject ( CImpClasProv *provider , BSTR Class , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpClassGetAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void ReceiveClass ( IWbemClassObject *classObject ) ;
	void ReceiveError ( IN const SnmpErrorReport &errorReport ) ;
} ;

class SnmpClassEnumEventObject : public SnmpClassEventObject 
{
private:
protected:

	wchar_t *m_Parent ;
	ULONG m_Flags ;

	BOOL ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class ) ;
	BOOL GetEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL GetCorrelatedEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpClassEnumEventObject ( CImpClasProv *provider , wchar_t *Parent , ULONG flags , IWbemContext *a_Context ) ;
	~SnmpClassEnumEventObject () ;

	void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) ;

	BOOL ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpClassEnumAsyncEventObject : public SnmpClassEnumEventObject
{
private:

	IWbemObjectSink *m_notificationHandler ;

protected:
public:

	SnmpClassEnumAsyncEventObject ( CImpClasProv *provider , wchar_t *Parent , ULONG flags , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpClassEnumAsyncEventObject () ;

	void Process () ;
	void ReceiveClass ( IWbemClassObject *classObject ) ;
	void ReceiveError ( IN const SnmpErrorReport &errorReport ) ;
	void ReceiveComplete () ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\correlat.h ===
//****************************************************************************

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  correlat.h
//
//  SNMP MIB CORRELATOR API - SNMPCORR.DLL
//
//****************************************************************************
#ifndef _SNMPCORR_CORELAT
#define _SNMPCORR_CORELAT 

#include <corafx.h>
#include <cordefs.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>



//=================================================================================
//
//	class CCorrelator_Info
//
//	This class is used to return information about the correlation. An instance
//	of this class is passed as a parameter in the CCorrelator::Correlated call
//	back method. This class is derived from SnmpErrorReport. If there is an SNMP
//	error during correlation then this class will indicate an SNMP error and the
//	SnmpErrorReport methods can be used to determine what the error was. If there
//	is not an SNMP error the SnmpErrorReport methods will indicate success. However
//	there may still be a correlation error, so GetInfo should be called first to
//	see the nature of the correlation result.
//
//=================================================================================

class CCorrelator_Info : public 	SnmpErrorReport
{
public:


//	The following enumeration gives the error codes that the correlation
//	process can return. This is public so that we can see what's returned!
//	======================================================================

enum ECorrelationInfo
{	
	ECorrSuccess = 0,	//No errors occurred
	ECorrSnmpError,		//An SNMP session error, read the SnmpErrorReport
	ECorrInvalidGroup,	//An Invalid group has been found
	ECorrEmptySMIR,		//The SMIR contains no groups
	ECorrBadSession,	//The SNMP Session passed is invalid
	ECorrNoSuchGroup,	//The group passed is not in the SMIR (one shot correlation)
	ECorrGetNextError,	//Unexpected value returned from the SNMP operation
	ECorrSomeError		//Never used - place holder for further error codes.
};


private:
	
	
	//	Private Members
	//	===============

	ECorrelationInfo m_info; //Correlation error indication


public:
	

	//	Public Constructor
	//	==================

	CCorrelator_Info(IN const ECorrelationInfo& i, IN const SnmpErrorReport& snmpi) 
		: SnmpErrorReport(snmpi) { m_info = i;	}

	
	//	Public Methods
	//	==============

	//	Returns the error code for this object
	ECorrelationInfo	GetInfo() const { return m_info; }

	//	Sets the error code for this object 
	void				SetInfo(IN const ECorrelationInfo& info) { m_info = info; }

};

//=================================================================================
//
//	class CCorrelator
//
//	This class is used to correlate an agent on the network. It is derived from an
//	SnmpOperation class. It's constructor takes one parameter, an SnmpSession. This
//	parameter is used to create the SnmpOperation parent class and the correlation
//	will be performed in the context of this session. To perform correlation derive
//	from this class and override the Correlated method. The Correlated method will
//	be called asynchronously when a group has been found to be supported by the
//	agent. To start the correlation procedure off after creating a CCorrelator
//	object you have to call the Start method. This takes an optional parameter, if
//	the parameter is specified then a single shot correlation is performed for the
//	object id passed as the parameter (as a string). If the parameter is not used
//	then all the groups supported by the agent that exist in the SMIR will be
//	returned.
//
//=================================================================================

class CCorrelator : public CCorrNextId
{
private:


	//	Private Members
	//	===============

	BOOL					m_inProg;		//Is correlation in progress
	CCorrCache*				m_pCache;		//Pointer to the global cache
	POSITION				m_rangePos;		//The current position in the range list
	CCorrRangeTableItem*	m_pItem;		//Pointer to the current range list item
	CCorrGroupMask*			m_Groups;		//A mask used to indicate groups found
	BOOL					m_NoEntries;	//Is the SMIR empty
	CCorrObjectID*			m_group_OID;	//Single correlation group id
	UINT					m_VarBindCnt;	//Max number of VarBinds per GetNext op

	//	Private Methods
	//	===============

	void		Initialise();
	void		Reset();
	BOOL		ProcessOID(IN const SnmpErrorReport& error, IN const CCorrObjectID& OID);
	void		ReceiveNextId(IN const SnmpErrorReport &error,
								IN const CCorrObjectID &next_id);
	void		ReadRegistry();
	void		GetNextOIDs();
	BOOL		IsItemFromGroup() const;
	void		ScanAndSkipResults();

protected:

	//	Protected Constructor
	//	=====================

#ifdef CORRELATOR_INIT
	CCorrelator(IN SnmpSession &session);
#else //CORRELATOR_INIT
	CCorrelator(IN SnmpSession &session, IN ISmirInterrogator *a_ISmirInterrogator);
#endif //CORRELATOR_INIT


	//	Protected Methods
	//	=================

	//Call backs
	virtual void	Correlated(IN const CCorrelator_Info &info, IN ISmirGroupHandle *phModule,
								IN const char* objectId = NULL) = 0;
	virtual void	Finished(IN const BOOL Complete) = 0;


public:


	//	Public Methods
	//	==============

	BOOL	Start(IN const char* groupId = NULL);
	void	DestroyCorrelator();
	static void	TerminateCorrelator();
	static void StartUp(ISmirInterrogator *a_ISmirInterrogator = NULL );

	//	Public Destructor
	//	=================

	virtual	~CCorrelator();
};


#endif //_SNMPCORR_CORELAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\evtmap.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMP_EVT_PROV_EVTMAP_H
#define _SNMP_EVT_PROV_EVTMAP_H

typedef enum tag_MyNameElementType
    {	MYWBEM_NAME_ELEMENT_TYPE_PROPERTY	= 0,
		MYWBEM_NAME_ELEMENT_TYPE_INDEX	= 1
    }	MYWBEM_NAME_ELEMENT_TYPE;

typedef union tag_MyNameElementUnion
    {
		WCHAR* m_wszPropertyName;
		long m_lArrayIndex;
    }	MYWBEM_NAME_ELEMENT_UNION;

typedef struct  tag_MyNameElement
    {
		short m_nType;
		MYWBEM_NAME_ELEMENT_UNION Element;
    }	MYWBEM_NAME_ELEMENT;

typedef struct  _tag_MyWbemPropertyName
    {
		long m_lNumElements;
		MYWBEM_NAME_ELEMENT __RPC_FAR *m_aElements;
    }	MYWBEM_PROPERTY_NAME;

struct VarBindObjectStruct
{
	BOOL fDone;
	SnmpVarBind* pVarBind;
};

struct VarBindObjectArrayStruct
{
	VarBindObjectStruct* vbs;
	UINT length;
};


class CMapToEvent
{
protected:

	CString				m_addr;				//sending address
	CString				m_ctxt;				//sending context
	CString				m_oid;				//snmptrap OID
	CString				m_transport;		//the transport protocol
	CString				m_class;			//the event class name
	IWbemClassObject	*m_object;			//the actual event instance which has been "spawned"
	IWbemServices		*m_nspace;			//the namespace we are working in
	IWbemClassObject	*m_vbdefn;			//the snmpvarbind class object
	BOOL				m_btriedGeneric;	//indicates if the generic class has been tried
	BOOL				m_btryGeneric;		//indicates that the generic class should be tried
	BOOL				m_bCheckedVersion;	//indicates whether the version has been determined
	BOOL				m_bSNMPv1;			//indicates the SNMP version
	VarBindObjectArrayStruct	m_vbs;		//the varbinds

	CMapToEvent();
	
	//sets the m_class variable. if btryGeneric is set gets the generic class.
	//if m_btryGeneric is not set and a generic class is returned m_btriedGeneric
	//must be set to true.
	virtual BOOL GetClass();

	virtual BOOL GetSpecificClass() = 0;
	virtual const wchar_t* GetV1Class() = 0;
	virtual const wchar_t* GetV2Class() = 0;

	void GetClassInstance(IWbemClassObject** ppObj);

	virtual HRESULT GetStandardProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	virtual HRESULT GetPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	virtual HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue) = 0;

	virtual HRESULT GetVBProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	BOOL IsSNMPv1();

	IWbemClassObject*	GetVBClassDefn();
	IWbemClassObject*	GetVBClassObjectByIndex(UINT index);
	BOOL				GetVBPropValueByIndex(UINT index, CString& type, VARIANT& vval);
	BOOL				GetVBPropOIDByIndex(UINT index, VARIANT& vOid);

public:

	enum EMappingType
	{
		REFERENT_MAPPER = 0,
		ENCAPSULATED_MAPPER = 1
	};

	virtual void ResetData();

	virtual void GenerateInstance(IWbemClassObject** ppInst) = 0;

	BOOL TriedGeneric() { return m_btriedGeneric; }

	void SetTryGeneric();

	void SetData(const char* sender_addr,
					const char* security_Context,
					const char* snmpTrapOid,
					const char* transport,
					SnmpVarBindList& vbList,
					IWbemServices* nspace);

	virtual ~CMapToEvent();
};


#endif //_SNMP_EVT_PROV_EVTMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\evtreft.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMP_EVT_PROV_EVTREFT_H
#define _SNMP_EVT_PROV_EVTREFT_H

struct CIMTypeStruct
{
	BOOL fObject;
	CString strType;
};


class CReferentMapper : public CMapToEvent
{
private:

	BOOL			GetSpecificClass();
	const wchar_t*	GetV1Class() { return V1EXTCLASS_NAME; }
	const wchar_t*	GetV2Class() { return V2EXTCLASS_NAME; }
	HRESULT			GetTypeAndIndexQuals(const wchar_t* prop,
											CIMTypeStruct& type,
											ULONG& index);

	HRESULT			CreateEmbeddedProperty(IWbemClassObject** ppObj,
											ULONG index,
											const wchar_t* propertyName,
											const wchar_t* className);

public:

	CReferentMapper();

	HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);
	
	void GenerateInstance(IWbemClassObject** ppInst);
	void ResetData();

	~CReferentMapper();

};


#endif //_SNMP_EVT_PROV_EVTREFT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\propdel.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROPDEL_H
#define __PROPDEL_H

class DeleteInstanceAsyncEventObject : public SnmpSetResponseEventObject 
{
private:

	SnmpSession *session ;
	SetOperation *operation ;

	ULONG m_State ;
	IWbemObjectSink *m_NotificationHandler ;
	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	SnmpSetClassObject snmpObject ;

protected:

	void ProcessComplete () ;
	BOOL Delete ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL DeleteInstance ( WbemSnmpErrorObject &a_ErrorObject ) ;

public:

	DeleteInstanceAsyncEventObject ( 

		CImpPropProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~DeleteInstanceAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void SnmpTooBig () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
} ;

#endif // __PROPDEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\evtprov.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMP_EVT_PROV_EVTPROV_H
#define _SNMP_EVT_PROV_EVTPROV_H


class CTrapEventProvider : public IWbemEventProvider, public IWbemProviderInit
{

private:

	IWbemServices*			m_pNamespace;
	IWbemObjectSink*			m_pEventSink;
	CEventProviderThread*	m_thrd;
	LONG					m_ref;
	
	//copy constuctor not defined so not allowed!
	CTrapEventProvider(CTrapEventProvider&);
	void operator=(const CTrapEventProvider&);


public:

	DWORD			m_MapType;

		CTrapEventProvider(DWORD mapperType, CEventProviderThread* thrd);

	IWbemServices*		GetNamespace();
	IWbemObjectSink*	GetEventSink();
    void				AddRefAll();
    void				ReleaseAll();

		~CTrapEventProvider();

	//interface methods
	//==================
    STDMETHODIMP ProvideEvents(
                IWbemObjectSink* pSink,
                LONG lFlags
            );

    STDMETHODIMP         QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);

};

#endif //_SNMP_EVT_PROV_EVTPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\evtthrd.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMP_EVT_PROV_EVTTHRD_H
#define _SNMP_EVT_PROV_EVTTHRD_H

class CTrapEventProvider;
class CEventProviderThread;
class CMapToEvent;

class MySnmpV1Security : public SnmpV1Security
{
public:
	MySnmpV1Security(const SnmpV1Security& sec) : SnmpV1Security(sec){}
	const char* GetName()const {return GetCommunityName();}
};


class CControlObjectMap : public CMap< UINT, UINT, CTrapEventProvider*, CTrapEventProvider* >
{
private:

	UINT HashKey(UINT key) { return key; }
	CCriticalSection m_Lock;

public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
};

					
class CTrapListener : public SnmpTrapReceiver
{

private:

	CEventProviderThread*	m_pParent;
	LONG					m_Ref;


public:

			CTrapListener(CEventProviderThread* parentptr);
	
	void	Receive(SnmpTransportAddress &sender_addr,
						SnmpSecurity &security_context,
						SnmpVarBindList &vbList);
	void	Destroy();

			~CTrapListener() {}
};

class CTrapData
{
private:
	LONG m_Ref;

public:

	char			*m_sender_addr;
	char			*m_security_context;
	char			*m_trap_oid;
	char			*m_transport;
	SnmpVarBindList	m_variable_bindings;

		CTrapData (const char* sender_addr,
					const char* security_Context,
					const char* snmpTrapOid,
					const char* trnsp,
					SnmpVarBindList& vbList);
	LONG AddRef();
	LONG Release();

		~CTrapData();

};


class CTrapProcessTaskObject : public SnmpTaskObject
{
private:

	CTrapData			*m_trap_data;
	CTrapEventProvider	*m_Cntrl;

protected:
public:

	CTrapProcessTaskObject (CTrapData *pTData, CTrapEventProvider* pCntrl) ;

	~CTrapProcessTaskObject();

	void Process () ;

} ;

class CEventProviderWorkerThread : public SnmpThreadObject
{
private:

	void Initialise();
	void Uninitialise();

};

class CEventProviderThread : public SnmpThreadObject
{
private:

	CTrapListener*					m_Ear;
	CControlObjectMap				m_ControlObjects;

	void Initialise ();
	void Uninitialise ();

public:

	BOOL Register(CTrapEventProvider* prov);
	void UnRegister(CTrapEventProvider* prov);

	virtual void	ProcessTrap(const char* sender_addr,
						const char* security_Context,
						const char* snmpTrapOid,
						const char* trnsp,
						SnmpVarBindList& vbList);

};



#endif //_SNMP_EVT_PROV_EVTTHRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\corstore.h ===
//****************************************************************************

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  corstore.h
//
//  SNMP MIB CORRELATOR STORAGE CLASSES - SNMPCORR.DLL
//
//****************************************************************************
#ifndef _SNMPCORR_CORSTORE
#define _SNMPCORR_CORSTORE 

class CCorrelator;

typedef ULONG TCorrMaskLength;
typedef ULONG TCorrMaskUnit;

enum ECorrCompResult
{
	ECorrAreEqual = 0,
	ECorrFirstLess,
	ECorrFirstGreater,
	ECorrNotEqual
};

class CCorrGroupMask
{

private:

	TCorrMaskLength	m_size;
	TCorrMaskUnit*	m_mask;

public:

			CCorrGroupMask(IN const TCorrMaskLength sze);
	BOOL	IsBitSet(IN const TCorrMaskLength bit) const;
	void	SetBit(IN const TCorrMaskLength bit, IN const BOOL On = TRUE);
			~CCorrGroupMask();
};

class CCorrObjectID
{

private:

	UINT	m_length;
	UINT*	m_Ids;

public:

	//Creates a CCorrObjectID from dotted string
				CCorrObjectID(IN const char* str);

	//Creates a copy of an existing CCorrObjectID
				CCorrObjectID(IN const CCorrObjectID& ID);

	//Creates a CCorrObjectID from an array of UINTS and a length
	//also defaults to constructing an empty CCorrObjectID
				CCorrObjectID(IN const UINT* ids = NULL,
					IN const UINT len = 0);

	ECorrCompResult	CompareWith(IN const CCorrObjectID& second) const;
	BOOL			IsSubRange(IN const CCorrObjectID& child) const;
	char*			GetString()const; //a newly allocated char* is returned caller must free!!
	void			GetString(CString& str) const;
	UINT			GetLength() const { return m_length; }
	const UINT*		GetIds() const { return m_Ids; }
	void			Set(IN const UINT* ids = NULL, IN const UINT len = 0);
	
	//Deletes any memory used for Ids
				virtual ~CCorrObjectID();

//boolean operators
	BOOL			operator ==(IN const CCorrObjectID& second) const;
	BOOL			operator !=(IN const CCorrObjectID& second) const;
	BOOL			operator <=(IN const CCorrObjectID& second) const;
	BOOL			operator >=(IN const CCorrObjectID& second) const;
	BOOL			operator >(IN const CCorrObjectID& second) const;
	BOOL			operator <(IN const CCorrObjectID& second) const;
//assignment operators
	CCorrObjectID&	operator =(IN const CCorrObjectID& ID);
	CCorrObjectID&	operator +=(IN const CCorrObjectID& ID);
//unary
	CCorrObjectID&	operator ++();
	CCorrObjectID&	operator --();
	CCorrObjectID&	operator -=(IN const UINT sub);
	CCorrObjectID&	operator /=(IN const UINT sub);
};


class CCorrEncodedOID
{

private:

	UINT	m_length;
	UCHAR*	m_ids;
	UCHAR	m_chopped;

public:

	CCorrEncodedOID(IN const CCorrObjectID& src_oid);
	CCorrEncodedOID(){ m_length = 0; m_ids = NULL; m_chopped = 0; }
	void ExtractOID(OUT CCorrObjectID& oid) const;
	void Set(IN const CCorrObjectID& src_oid);

	~CCorrEncodedOID();
};


class CCorrGroupIdItem : public CObject
{

private:

	CCorrEncodedOID		m_groupId;
	TCorrMaskLength		m_index;

public:
							CCorrGroupIdItem(IN const CCorrObjectID& ID,
												IN ISmirGroupHandle* grpH); 
	void					GetGroupID(OUT CCorrObjectID& ID) const;
	void					SetIndex(IN const TCorrMaskLength i) { m_index = i; }
	const TCorrMaskLength&	GetIndex()const { return m_index; }
	virtual					~CCorrGroupIdItem(); 

	CList<ISmirGroupHandle*, ISmirGroupHandle*> m_groupHandles;

	void					DebugOutputItem(CString* msg = NULL) const;

};


class CCorrRangeTableItem : public CObject
{

private:

	CCorrEncodedOID		m_startRange;
	CCorrEncodedOID		m_endRange;
	CCorrGroupIdItem*	m_groupId;


public:
	
enum ECorrRangeResult
{
	ECorrInRange = 0,
	ECorrBeforeStart,
	ECorrAfterEnd,
	ECorrEqualToStart,
	ECorrEqualToEnd
};


						CCorrRangeTableItem(IN const CCorrObjectID& startID,
											IN const CCorrObjectID& endID,
											IN CCorrGroupIdItem* grpID); 
	BOOL				GetStartRange(OUT CCorrObjectID& start) const;
	BOOL				GetEndRange(OUT CCorrObjectID& end) const;
	CCorrGroupIdItem*	GetGroupIdPtr() { return m_groupId; }
	ECorrRangeResult	IsInRange(IN const CCorrObjectID& ID) const;
	virtual				~CCorrRangeTableItem();

	void				DebugOutputRange() const;

};


class CCorrGroupArray : public CTypedPtrArray< CObArray, CCorrGroupIdItem* >
{

public:

			CCorrGroupArray();

	void	Sort();

			~CCorrGroupArray();
};

class CCorrRangeList : public CTypedPtrList< CObList, CCorrRangeTableItem* >
{

public:


	BOOL					Add(IN CCorrRangeTableItem* newItem);
	BOOL					GetLastEndOID(OUT CCorrObjectID& end) const;

							~CCorrRangeList();
};


class CCorrCache
{

private:

	CCriticalSection	m_Lock;
	DWORD				m_Ref_Count;
	BOOL				m_ValidCache;
	CCorrRangeList		m_rangeTable;
	CCorrGroupArray		m_groupTable;
	CCorrGroupMask*		m_Groups;
	TCorrMaskLength		m_size;


	BOOL		BuildCacheAndSetNotify( ISmirInterrogator *a_ISmirInterrogator );
	BOOL		BuildRangeTable();
	//the last two parameters are defunct now we're using a CObArray!!
	//get rid of them.
	void		DoGroupEntry(UINT* current, UINT* next,
								TCorrMaskLength* cIndex, TCorrMaskLength* nIndex);


public:

							CCorrCache( ISmirInterrogator *p_ISmirInterrogator = NULL );

	TCorrMaskLength&		GetSize() { return m_size; }
	void					AddRef();
	void					DecRef();
	POSITION				GetHeadRangeTable() { return m_rangeTable.GetHeadPosition(); }
	CCorrRangeTableItem*	GetNextRangeTable(POSITION* rPos)
													{ return m_rangeTable.GetNext(*rPos); }
	void					InvalidateCache();

							~CCorrCache();

};

class CCorrCacheWrapper
{

private:

	CCorrCache* m_CachePtr;
	CCriticalSection* m_lockit;


public:

	CCorrCacheWrapper(IN CCorrCache* cachePtr = NULL);
	~CCorrCacheWrapper();

	CCorrCache* GetCache();
	void SetCache(IN CCorrCache* cachePtr){ m_CachePtr = cachePtr; }
	void ReleaseCache() { m_lockit->Unlock(); }
};


#endif //_SNMPCORR_CORSTORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\notify.h ===
//****************************************************************************

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  notify.h
//
//  SNMP MIB CORRELATOR NOTIFICATION CLASS - SNMPCORR.DLL
//
//****************************************************************************
#ifndef _SNMPCORR_NOTIFY
#define _SNMPCORR_NOTIFY

class CCorrCacheNotify : public ISMIRNotify
{

    private:
        ULONG	m_cRef;     //Reference count
        UINT	m_uID;      //Sink identifier
		DWORD	m_dwCookie;	//Returned by ADVISE used for UNADVISE


    public:
				CCorrCacheNotify();
        virtual	~CCorrCacheNotify();

        //IUnknown members
        STDMETHODIMP			QueryInterface(REFIID, void **);
        STDMETHODIMP_(DWORD)	AddRef();
        STDMETHODIMP_(DWORD)	Release();
        STDMETHODIMP			ChangeNotify();

		void SetCookie(DWORD c)	{ m_dwCookie = c; }
		DWORD GetCookie()		{ return m_dwCookie; }
};


#endif //_SNMPCORR_NOTIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\propget.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROPGET_H
#define __PROPGET_H

class SnmpGetResponseEventObject : public SnmpResponseEventObject
{
private:
protected:

	SnmpSession *session ;
	GetOperation *operation ;

	IWbemClassObject *classObject ;
	IWbemClassObject *instanceObject ;
	SnmpGetClassObject snmpObject ;
	BOOL processComplete ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpGetResponseEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context ) ;
	~SnmpGetResponseEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	IWbemClassObject *GetClassObject () { return classObject ; }
	IWbemClassObject *GetInstanceObject () { return instanceObject ; }
} ;

class SnmpGetEventObject : public SnmpGetResponseEventObject
{
private:
protected:

	wchar_t *objectPath ;
	
	BOOL GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class ) ;
	BOOL DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property , KeyRef *a_KeyReference ) ;
	BOOL SetClassKeySpecKey ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL DispatchClassKeySpec ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchObjectPath ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL ParseObjectPath ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpGetEventObject ( CImpPropProv *provider , wchar_t *ObjectPath , IWbemContext *a_Context ) ;
	~SnmpGetEventObject () ;

} ;

class SnmpGetAsyncEventObject : public SnmpGetEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpGetAsyncEventObject ( CImpPropProv *provider , wchar_t *ObjectPath , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpGetAsyncEventObject () ;

	void Process () ;

	void ReceiveComplete () ;
} ;

#endif // __PROPGET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\guids.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// {1F517A23-B29C-11cf-8C8D-00AA00A4086C}
DEFINE_GUID(CLSID_CPropProvClassFactory, 
0x1f517a23, 0xb29c, 0x11cf, 0x8c, 0x8d, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {70426720-F78F-11cf-9151-00AA00A4086C}
DEFINE_GUID(CLSID_CClasProvClassFactory,
0x70426720, 0xf78f, 0x11cf, 0x91, 0x51, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {9D5BED16-0765-11d1-AB2C-00C04FD9159E}
DEFINE_GUID(CLSID_CSNMPReftEventProviderClassFactory, 
0x9d5bed16, 0x765, 0x11d1, 0xab, 0x2c, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

// {19C813AC-FEE7-11d0-AB22-00C04FD9159E}
DEFINE_GUID(CLSID_CSNMPEncapEventProviderClassFactory, 
0x19c813ac, 0xfee7, 0x11d0, 0xab, 0x22, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\propinst.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROPINST_H
#define __PROPINST_H

class SnmpInstanceClassObject : public SnmpClassObject
{
private:

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:

public:

	SnmpInstanceClassObject () ;
	SnmpInstanceClassObject ( const SnmpInstanceClassObject & snmpInstanceClassObject ) ;
	~SnmpInstanceClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;

} ;

class SnmpInstanceResponseEventObject : public SnmpResponseEventObject 
{
private:
protected:

	SnmpSession *session ;
	AutoRetrieveOperation *operation ;

	IWbemClassObject *classObject ;
	IWbemClassObject *instanceObject ;
#if 0
	IWbemObjectAccess *instanceAccessObject ;
#endif
	SnmpInstanceClassObject snmpObject ;

	PartitionSet *m_PartitionSet ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpInstanceResponseEventObject ( CImpPropProv *provider , IWbemContext *a_Context ) ;
	~SnmpInstanceResponseEventObject () ;

	IWbemClassObject *GetClassObject () { return classObject ; }
	IWbemClassObject *GetInstanceObject () { return instanceObject ; }
#if 0
	IWbemObjectAccess *GetInstanceAccessObject () { return instanceAccessObject ; }
#endif

	PartitionSet *GetPartitionSet () { return m_PartitionSet ; }

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	SnmpClassObject *GetSnmpRequestClassObject () { return & snmpObject ; }

	virtual void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) = 0 ;
	virtual void ReceiveRow ( IWbemClassObject *snmpObject ) {}
} ;

class SnmpInstanceEventObject : public SnmpInstanceResponseEventObject
{
private:
protected:

	wchar_t *Class ;

public:

	SnmpInstanceEventObject ( CImpPropProv *provider , BSTR Class , IWbemContext *a_Context ) ;
	~SnmpInstanceEventObject () ;

	BOOL Instantiate ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpInstanceAsyncEventObject : public SnmpInstanceEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpInstanceAsyncEventObject ( CImpPropProv *provider , BSTR Class , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpInstanceAsyncEventObject () ;

	void Process () ;
	void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) ;
	void ReceiveRow ( IWbemClassObject *snmpObject ) ;
	void ReceiveComplete () ;
} ;

#endif // __PROPINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\propset.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROPSET_H
#define __PROPSET_H

class SnmpSetClassObject : public SnmpClassObject
{
private:

	BOOL m_RowStatusSpecified ;
	BOOL m_RowStatusPresent ;

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:
public:

	SnmpSetClassObject () ;
	~SnmpSetClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL RowStatusSpecified () { return m_RowStatusSpecified ; }
	BOOL RowStatusPresent () { return m_RowStatusPresent ; }

	ULONG NumberOfWritable () ;
} ;

class SnmpSetResponseEventObject : public SnmpResponseEventObject 
{
private:
protected:

/*
 * State variables for event based processing.
 */

	ULONG state ;
	ULONG m_VarBindsLeftBeforeTooBig ;
	BOOL m_SnmpTooBig ;

	long m_lflags ;
	IWbemClassObject *classObject ;
	SnmpSetClassObject snmpObject ;
	BOOL processComplete ;

	SnmpSession *session ;
	SetOperation *operation ;
	SetQueryOperation *m_QueryOperation ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject , const ULONG &a_NumberToSend = 0xffffffff ) ;

public:

	SnmpSetResponseEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context , long lflags ) ;
	~SnmpSetResponseEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	IWbemClassObject *GetClassObject () { return classObject ; }
} ;

class SnmpUpdateEventObject : public SnmpSetResponseEventObject
{
private:
protected:

	BOOL Create_Only () ;
	BOOL Update_Only () ;
	BOOL Create_Or_Update () ;

	BOOL Send_Variable_Binding_List ( 

		SnmpSetClassObject &a_SnmpSetClassObject ,
		ULONG a_NumberToSend 
	) ;

	BOOL Send_Variable_Binding_List ( 

		SnmpSetClassObject &a_SnmpSetClassObject , 
		ULONG a_NumberToSend ,
		SnmpRowStatusType :: SnmpRowStatusEnum a_SnmpRowStatusEnum
	) ;

	BOOL CheckForRowExistence ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL Update ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpUpdateEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context , long lflags ) ;
	~SnmpUpdateEventObject () ;
} ;

class SnmpUpdateAsyncEventObject : public SnmpUpdateEventObject
{
private:

	IWbemObjectSink *notificationHandler ;

protected:

	void SetComplete () ;

public:

	SnmpUpdateAsyncEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemObjectSink *notify , IWbemContext *a_Context , long lflags ) ;
	~SnmpUpdateAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void SnmpTooBig () ;
} ;

#endif // __PROPSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\propsnmp.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROPSNMP_H
#define __PROPSNMP_H

#define SYTEM_PROPERTY_START_CHARACTER	L'_'

class SnmpV1OverIp ;
class GetOperation ;
class SetOperation ;
class RefreshOperation ;
class SetQueryOperation ;
class AutoRetrieveOperation ;

class SnmpClassObject : public WbemSnmpClassObject
{
private:
protected:

	BOOL m_accessible ;
	ULONG snmpVersion ;

public:

	SnmpClassObject () ;
	SnmpClassObject ( const SnmpClassObject &a_SnmpClassObject ) ;
	~SnmpClassObject () ;

	ULONG GetSnmpVersion () { return snmpVersion ; } 

} ;

class SnmpGetClassObject : public SnmpClassObject
{
private:

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:
public:

	SnmpGetClassObject () ;
	~SnmpGetClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpResponseEventObject : public SnmpTaskObject
{
private:

	LONG m_ReferenceCount ;

protected:

	//HRESULT completionCode ;
	WbemSnmpErrorObject m_errorObject ;
	CImpPropProv *provider ;
	IWbemClassObject *m_namespaceObject ;
	IWbemContext *m_Context ;

	BOOL GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL GetAgentTransport ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentTransport ) ;
	BOOL GetAgentVersion ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentVersion ) ;
	BOOL GetAgentAddress ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentAddress ) ;
	BOOL GetAgentReadCommunityName ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentWriteCommunityName ( WbemSnmpErrorObject &a_errorObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentRetryCount ( WbemSnmpErrorObject &a_errorObject , ULONG &agentRetryCount ) ;
	BOOL GetAgentRetryTimeout( WbemSnmpErrorObject &a_errorObject , ULONG &agentRetryTimeout ) ;
	BOOL GetAgentMaxVarBindsPerPdu ( WbemSnmpErrorObject &a_errorObject , ULONG &agentVarBindsPerPdu ) ;
	BOOL GetAgentFlowControlWindowSize ( WbemSnmpErrorObject &a_errorObject , ULONG &agentFlowControlWindowSize ) ;

	BOOL GetNotifyStatusObject ( IWbemClassObject **notifyObject ) ;
	BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

	BOOL HasNonNullKeys ( IWbemClassObject *a_Obj ) ;

public:

	SnmpResponseEventObject ( CImpPropProv *provider , IWbemContext *a_Context ) ;
	~SnmpResponseEventObject () ;

	//HRESULT GetCompletionCode () { return completionCode ; }
	WbemSnmpErrorObject &GetErrorObject () { return m_errorObject ; }
	virtual SnmpClassObject *GetSnmpClassObject () = 0 ;
	virtual SnmpClassObject *GetSnmpRequestClassObject () { return NULL ; }
	virtual void ReceiveComplete () = 0 ;
	virtual void SnmpTooBig () {} ;

    ULONG AddRef () ;
    ULONG Release () ;
} ;

#endif // __PROPSNMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\propprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPPropertyProvider_H_
#define _SNMPPropertyProvider_H_

extern CRITICAL_SECTION s_ProviderCriticalSection ;

class SnmpInstanceDefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpInstanceDefaultThreadObject ( const char *threadName = NULL ) : SnmpThreadObject ( threadName ) {} ;
	~SnmpInstanceDefaultThreadObject () {} ;

	void Initialise () ;
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpPropProv : public IWbemServices , public IWbemHiPerfProvider , public IWbemProviderInit
{
private:

	BOOL initialised ;
	LONG m_referenceCount ;         //Object reference count

	CCriticalSection criticalSection ;

	WbemNamespacePath namespacePath ;
	wchar_t *thisNamespace ;

	IWbemServices *server ;
	IWbemProviderInitSink *m_InitSink ;
	char *ipAddressString ;
	char *ipAddressValue ;

	wchar_t *m_localeId ;

	BOOL m_getNotifyCalled ;
	BOOL m_getSnmpNotifyCalled ;
	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_snmpNotificationClassObject ;

private:
	
	void SetServer ( IWbemServices *serverArg ) { server = serverArg ; }

	BOOL ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject ) ;

protected:
public:

	CImpPropProv () ;
    ~CImpPropProv () ;

	static SnmpInstanceDefaultThreadObject *s_defaultThreadObject ;
	static SnmpInstanceDefaultThreadObject *s_defaultPutThreadObject ;

	// Implementation

	IWbemServices *GetServer () ;
	WbemNamespacePath *GetNamespacePath () { return & namespacePath ; }
	wchar_t *GetThisNamespace () ;
	void SetThisNamespace ( wchar_t *thisNamespaceArg ) ;
	void SetLocaleId ( wchar_t *localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	char *GetIpAddressString () { return ipAddressString ; }
	char *GetIpAddressValue () { return ipAddressValue ; }

	BOOL FetchSnmpNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL FetchNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;
	IWbemClassObject *GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize(

			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
			);        

    // IWbemHiPerfProvider methods.
    // ============================
            
        virtual HRESULT STDMETHODCALLTYPE QueryInstances( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ WCHAR __RPC_FAR *wszClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefresher( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ long lFlags,
            /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [out] */ long __RPC_FAR *plId
            );
        
        virtual HRESULT STDMETHODCALLTYPE StopRefreshing( 
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lId,
            /* [in] */ long lFlags
            );

         
};

class CImpRefresher : public IWbemRefresher
{
private:

	CImpPropProv *m_Provider ;

	void **m_Container ;
	ULONG m_ContainerLength ;

	CRITICAL_SECTION m_CriticalSection ;

    LONG m_referenceCount;

public:

    CImpRefresher ( CImpPropProv *a_Provider );
   ~CImpRefresher ();

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);

	HRESULT AddObject ( IWbemObjectAccess *a_Template , IWbemObjectAccess **a_RefreshObject , long *a_Id , IWbemContext *a_Context ) ;
	HRESULT RemoveObject ( long a_Id ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\proprefr.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
class SnmpV1OverIp ;
class GetOperation ;
class SetOperation ;
class RefreshOperation ;
class SetQueryOperation ;
class AutoRetrieveOperation ;

class SnmpRefreshEventObject : public SnmpResponseEventObject
{
private:

	ULONG state ;
	SnmpSession *session ;
	RefreshOperation *operation ;
	SnmpGetClassObject m_SnmpObject ;
	IWbemObjectAccess *m_Template ;
	IWbemObjectAccess *m_RefreshedObjectAccess ;
	IWbemClassObject *m_RefreshedObject ;

	BOOL CreateResources ( WbemSnmpErrorObject &a_errorObject ) ;

protected:
public:

	SnmpRefreshEventObject ( CImpPropProv *provider , IWbemObjectAccess *a_Template , IWbemContext *a_Context ) ;
	~SnmpRefreshEventObject () ;

	void Process () ;

	void ReceiveComplete () ;

	HRESULT Validate () ;

	SnmpClassObject *GetSnmpClassObject () { return & m_SnmpObject ; }
	IWbemObjectAccess *GetRefreshedObjectAccess () { m_RefreshedObjectAccess->AddRef () ; return m_RefreshedObjectAccess ; }
	IWbemClassObject *GetRefreshedObject () { return m_RefreshedObject ; }

	void SetState ( ULONG a_State ) { state = a_State ; }


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\snmpnext.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SNMPNEXT_H
#define __SNMPNEXT_H

class PropertyDefinition
{
private:
protected:
public:

	WbemSnmpProperty *m_Property ;

	ULONG m_KeyCount ;
	SnmpObjectIdentifier **m_ObjectIdentifierComponent ;
	SnmpObjectIdentifier **m_ObjectIdentifierStart ;
	SnmpObjectIdentifier **m_ObjectIdentifierEnd ;
	ULONG *m_PartitionIndex ;
	PartitionSet **m_KeyPartition ;

public:

	PropertyDefinition () 
	{
		m_KeyCount = 0 ;
		m_Property = NULL ;
		m_ObjectIdentifierStart = NULL ;
		m_ObjectIdentifierEnd = NULL ;
		m_KeyPartition = NULL ;
		m_PartitionIndex = NULL ;
		m_ObjectIdentifierComponent = NULL ;
	}

	~PropertyDefinition () 
	{
		for ( ULONG t_Index = 0 ; t_Index < m_KeyCount ; t_Index ++ )
		{
			if ( m_ObjectIdentifierStart ) 
				delete m_ObjectIdentifierStart [ t_Index ] ;

			if ( m_ObjectIdentifierEnd ) 
				delete m_ObjectIdentifierEnd [ t_Index ] ;

			if ( m_ObjectIdentifierComponent )
			delete m_ObjectIdentifierComponent [ t_Index ] ;
		}

		delete [] m_ObjectIdentifierStart ;
		delete [] m_ObjectIdentifierEnd ;
		delete [] m_ObjectIdentifierComponent ;

		delete [] m_KeyPartition ;
		delete [] m_PartitionIndex ;
 	}
} ;

class AutoRetrieveOperation : public SnmpAutoRetrieveOperation
{
private:

	PropertyDefinition *m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	BOOL virtuals ;
	BOOL virtualsInitialised ;
	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;
	ULONG rowsReceived ;
	ULONG rowVarBindsReceived ;

	SnmpSession *session ;

	SnmpInstanceResponseEventObject *eventObject ;
	IWbemClassObject *snmpObject ;

	LONG EvaluateInitialVarBind ( 

		ULONG a_PropertyIndex ,
		SnmpObjectIdentifier &a_CurrentIdentifier ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateSubsequentVarBind ( 

		ULONG a_PropertyIndex ,
		IN ULONG &a_CurrentIndex ,
		SnmpObjectIdentifier &a_CurrentIdentifier ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateVarBind ( 

		ULONG a_PropertyIndex ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateResponse (

		ULONG a_PropertyIndex ,
		IN ULONG &a_CurrentIndex ,
		SnmpObjectIdentifier &a_AdvanceIdentifier 
	) ;

protected:

	void ReceiveResponse () ;

	void ReceiveRowResponse () ;

	void ReceiveRowVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	LONG EvaluateNextRequest (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN SnmpVarBind &sendVarBind
	) ;

	void FrameTooBig() ;
	void FrameOverRun() ;

public:

	AutoRetrieveOperation (IN SnmpSession &session,	IN SnmpInstanceResponseEventObject *eventObjectArg ) ;
	~AutoRetrieveOperation () ;

	void Send () ;
	
	void DestroyOperation () { SnmpAutoRetrieveOperation :: DestroyOperation () ; }
};

#endif // __SNMPNEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\propquery.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROPQUERY_H
#define __PROPQUERY_H

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

class SnmpQueryEventObject : public SnmpInstanceResponseEventObject , public QueryPreprocessor
{
protected:

	SnmpTreeNode *AllocTypeNode ( 

		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		SnmpValueNode :: SnmpValueFunction a_PropertyFunction ,
		SnmpValueNode :: SnmpValueFunction a_ConstantFunction ,
		SnmpTreeNode *a_Parent 
	) ;

	QuadState InvariantEvaluate ( 

		SnmpTreeNode *a_Operator ,
		SnmpTreeNode *a_Operand 
	) ;

	SnmpRangeNode *AllocInfiniteRangeNode (

		BSTR a_PropertyName 

	) ;

	QueryPreprocessor :: QuadState Compare ( 

		wchar_t *a_Operand1 , 
		wchar_t *a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		SnmpTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		LONG a_Operand1 , 
		LONG a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		SnmpTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState CompareString ( 

		BSTR a_PropertyName , 
		SnmpTreeNode *a_Operator ,
		SnmpTreeNode *a_Operand 
	) ;

	QueryPreprocessor :: QuadState CompareInteger ( 

		BSTR a_PropertyName , 
		SnmpTreeNode *a_Operator ,
		SnmpTreeNode *a_Operand 
	) ;

	void GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container ) ;

	SnmpInstanceClassObject *requestObject ;
	wchar_t *Query ;
	wchar_t *QueryFormat ;
	wchar_t *Class ;

	BOOL CheckWhereCondition ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ,	SQL_LEVEL_1_TOKEN *token ) ;
	BOOL PreEvaluate ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL IsSystemProperty (const wchar_t *propertyName ) ;

private:

	CTextLexSource source ;
	SQL_LEVEL_1_RPN_EXPRESSION *rpnExpression ;
	SQL1_Parser parser ;

public:

	SnmpQueryEventObject ( CImpPropProv *provider , BSTR QueryFormat , BSTR Query , IWbemContext *a_Context ) ;
	~SnmpQueryEventObject () ;

	SnmpClassObject *GetSnmpRequestClassObject () { return requestObject ; }

	BOOL Instantiate ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpQueryAsyncEventObject : public SnmpQueryEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpQueryAsyncEventObject ( CImpPropProv *provider , BSTR QueryFormat , BSTR Query , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpQueryAsyncEventObject () ;

	void Process () ;
	void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) ;
	void ReceiveRow ( IWbemClassObject *snmpObject ) ;
	void ReceiveComplete () ;
} ;

#endif // __PROPQUERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\snmpget.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SNMPGET_H
#define __SNMPGET_H

class GetOperation : public SnmpGetOperation
{
private:

	WbemSnmpProperty **m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	SnmpGetResponseEventObject *eventObject ;

	BOOL virtuals ;
	BOOL virtualsInitialised ;
	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;

	SnmpSession *session ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

public:

	GetOperation (IN SnmpSession &session , IN SnmpGetResponseEventObject *eventObject ) ;
	~GetOperation () ;

	void Send () ;

	void DestroyOperation () { SnmpGetOperation :: DestroyOperation () ; }
};

#endif // __SNMPGET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\snmpobj.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define WBEM_NAMESPACE_EQUALS L"__Namespace = \""
#define WBEM_NAMESPACE_QUOTE L"\""

#define WBEM_CLASS_NAMESPACE			L"__Namespace"
#define WBEM_CLASS_NOTIFYSTATUS		L"__NotifyStatus"
#define WBEM_CLASS_EXTENDEDSTATUS		L"__ExtendedStatus"
#define WBEM_CLASS_SNMPNOTIFYSTATUS	L"SnmpNotifyStatus"
#define WBEM_CLASS_SNMPMACRO			L"SnmpMacro"
#define WBEM_CLASS_SNMPOBJECTTYPE	L"SnmpObjectType"
#define WBEM_CLASS_EXTRINSICEVENT	L"__ExtrinsicEvent"
#define WBEM_CLASS_SNMPNOTIFICATION L"SnmpNotification"
#define WBEM_CLASS_SNMPEXTENDEDNOTIFICATION L"SnmpExtendedNotification"
#define WBEM_CLASS_SNMPVARBIND L"SnmpVarBind"
#define WBEM_CLASS_NULL	L""

#define WBEM_PROPERTY_CLASS		L"__class"
#define WBEM_PROPERTY_SUPERCLASS	L"__superclass"
#define WBEM_PROPERTY_KEY			L"__key"
#define WBEM_PROPERTY_GENUS		L"__genus"
#define WBEM_PROPERTY_DYNASTY		L"__dynasty"
#define WBEM_PROPERTY_STATUSCODE   L"StatusCode"
#define WBEM_PROPERTY_SNMPSTATUSCODE   L"SnmpStatusCode"
#define WBEM_PROPERTY_SNMPSTATUSMESSAGE   L"Description"

#define WBEM_QUALIFIER_DYNAMIC						L"dynamic"
#define WBEM_QUALIFIER_PROVIDER						L"provider"
#define WBEM_QUALIFIER_KEY							L"key"
#define WBEM_QUALIFIER_KEY_ORDER					L"key_order"
#define WBEM_QUALIFIER_READ							L"read"
#define WBEM_QUALIFIER_WRITE						L"write"
#define WBEM_QUALIFIER_AGENTSNMPVERSION				L"AgentSNMPVersion"
#define WBEM_QUALIFIER_AGENTTRANSPORT				L"AgentTransport"
#define WBEM_QUALIFIER_AGENTADDRESS					L"AgentAddress"
#define WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME		L"AgentReadCommunityName"
#define WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME		L"AgentWriteCommunityName"
#define WBEM_QUALIFIER_AGENTRETRYCOUNT				L"AgentRetryCount"
#define WBEM_QUALIFIER_AGENTRETRYTIMEOUT			L"AgentRetryTimeout"
#define WBEM_QUALIFIER_AGENTVARBINDSPERPDU			L"AgentVarBindsPerPdu"
#define WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE	L"AgentFlowControlWindowSize"
#define WBEM_QUALIFIER_TYPE				L"type"
#define WBEM_QUALIFIER_NAME				L"name"
#define WBEM_QUALIFIER_DESCRIPTION			L"description"
#define WBEM_QUALIFIER_DYNASTY				L"dynasty"
#define WBEM_QUALIFIER_MODULE_NAME			L"module_name"
#define WBEM_QUALIFIER_GROUP_OBJECTID		L"group_objectid"
#define WBEM_QUALIFIER_VIRTUAL_KEY			L"virtual_key"
#define WBEM_QUALIFIER_OBJECT_IDENTIFIER	L"object_identifier"
#define WBEM_QUALIFIER_TEXTUAL_CONVENTION	L"textual_convention"
#define WBEM_QUALIFIER_ENCODING			L"encoding"
#define WBEM_QUALIFIER_SYNTAX				L"syntax"
#define WBEM_QUALIFIER_ENUMERATION			L"enumeration"
#define WBEM_QUALIFIER_BITS				L"bits"
#define WBEM_QUALIFIER_FIXED_LENGTH		L"fixed_length"
#define WBEM_QUALIFIER_VARIABLE_VALUE		L"variable_value"
#define WBEM_QUALIFIER_VARIABLE_LENGTH		L"variable_length"
#define WBEM_QUALIFIER_DISPLAY_HINT		L"display_hint"
#define WBEM_QUALIFIER_TYPE_MISMATCH		L"type_mismatch"
#define WBEM_QUALIFIER_VALUE_MISMATCH		L"value_mismatch"
#define WBEM_QUALIFIER_NOT_AVAILABLE		L"not_available"
#define WBEM_QUALIFIER_SINGLETON 		L"singleton"
#define WBEM_QUALIFIER_TABLECLASS		L"TableClass"
#define WBEM_QUALIFIER_KEYTYPES			L"KeyTypes"
#define WBEM_QUALIFIER_KEYVALUES			L"KeyValues"
#define WBEM_QUALIFIER_VARBINDINDEX		L"VarBindIndex"
#define WBEM_QUALIFIER_ROWSTATUS					L"rowstatus"

#define WBEM_INDEX_QUALIFIER_KEY							1
#define WBEM_INDEX_QUALIFIER_KEY_ORDER						2
#define WBEM_INDEX_QUALIFIER_READ							3
#define WBEM_INDEX_QUALIFIER_WRITE							4
#define WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION				5
#define WBEM_INDEX_QUALIFIER_AGENTTRANSPORT				6
#define WBEM_INDEX_QUALIFIER_AGENTADDRESS					7
#define WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME		8
#define WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME		9
#define WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT				10
#define WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT				11
#define WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU			12	
#define WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE	13	
#define WBEM_INDEX_QUALIFIER_TYPE							14
#define WBEM_INDEX_QUALIFIER_NAME							15
#define WBEM_INDEX_QUALIFIER_DESCRIPTION					16
#define WBEM_INDEX_QUALIFIER_DYNASTY						17
#define WBEM_INDEX_QUALIFIER_MODULE_NAME					18
#define WBEM_INDEX_QUALIFIER_GROUP_OBJECTID				19
#define WBEM_INDEX_QUALIFIER_VIRTUAL_KEY					20
#define WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER				21
#define WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION			22
#define WBEM_INDEX_QUALIFIER_ENCODING						23
#define WBEM_INDEX_QUALIFIER_SYNTAX						24
#define WBEM_INDEX_QUALIFIER_ENUMERATION					25
#define WBEM_INDEX_QUALIFIER_BITS							26
#define WBEM_INDEX_QUALIFIER_FIXED_LENGTH					27
#define WBEM_INDEX_QUALIFIER_VARIABLE_VALUE				28
#define WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH				29
#define WBEM_INDEX_QUALIFIER_DISPLAY_HINT					30
#define WBEM_INDEX_QUALIFIER_TYPE_MISMATCH					31
#define WBEM_INDEX_QUALIFIER_VALUE_MISMATCH					32
#define WBEM_INDEX_QUALIFIER_NOT_AVAILABLE					33
#define WBEM_INDEX_QUALIFIER_SINGLETON					34
#define WBEM_INDEX_QUALIFIER_TABLECLASS					35
#define WBEM_INDEX_QUALIFIER_KEYTYPES					36
#define WBEM_INDEX_QUALIFIER_KEYVALUES					37
#define WBEM_INDEX_QUALIFIER_VARBINDINDEX					38
#define WBEM_INDEX_QUALIFIER_ROWSTATUS					39

#define WBEM_TYPE_NULL					L"NULL"
#define WBEM_TYPE_INTEGER				L"INTEGER"
#define WBEM_TYPE_INTEGER32				L"INTEGER32"
#define WBEM_TYPE_COUNTER				L"Counter"
#define WBEM_TYPE_GAUGE				L"Gauge"
#define WBEM_TYPE_TIMETICKS			L"TimeTicks"
#define WBEM_TYPE_UNSIGNED32			L"UNSIGNED32"
#define WBEM_TYPE_COUNTER32			L"Counter32"
#define WBEM_TYPE_COUNTER64			L"Counter64"
#define WBEM_TYPE_GAUGE32				L"Gauge32"
#define WBEM_TYPE_OCTETSTRING			L"OCTETSTRING"
#define WBEM_TYPE_OPAQUE				L"Opaque"
#define WBEM_TYPE_IPADDRESS			L"IpAddress"
#define WBEM_TYPE_NETWORKADDRESS		L"NetworkAddress"
#define WBEM_TYPE_OBJECTIDENTIFIER		L"OBJECTIDENTIFIER"
#define WBEM_TYPE_DISPLAYSTRING		L"DisplayString"
#define WBEM_TYPE_MACADDRESS			L"MacAddress"
#define WBEM_TYPE_PHYSADDRESS			L"PhysAddress" 
#define WBEM_TYPE_ENUMERATEDINTEGER	L"EnumeratedInteger"
#define WBEM_TYPE_BITS					L"BITS"
#define WBEM_TYPE_DATETIME				L"DateAndTime"
#define WBEM_TYPE_SNMPOSIADDRESS		L"SnmpOSIAddress"
#define WBEM_TYPE_SNMPUDPADDRESS		L"SnmpUDPAddress"
#define WBEM_TYPE_SNMPIPXADDRESS		L"SnmpIPXAddress"
#define WBEM_TYPE_ROWSTATUS		L"RowStatus"


#define WBEM_INDEX_TYPE_NULL				1
#define WBEM_INDEX_TYPE_INTEGER			2
#define WBEM_INDEX_TYPE_INTEGER32			3
#define WBEM_INDEX_TYPE_COUNTER			4
#define WBEM_INDEX_TYPE_GAUGE				5
#define WBEM_INDEX_TYPE_TIMETICKS			6
#define WBEM_INDEX_TYPE_OCTETSTRING		7
#define WBEM_INDEX_TYPE_OPAQUE				8
#define WBEM_INDEX_TYPE_IPADDRESS			9
#define WBEM_INDEX_TYPE_NETWORKADDRESS		10
#define WBEM_INDEX_TYPE_OBJECTIDENTIFIER	11
#define WBEM_INDEX_TYPE_DISPLAYSTRING		12
#define WBEM_INDEX_TYPE_MACADDRESS			13
#define WBEM_INDEX_TYPE_PHYSADDRESS		14
#define WBEM_INDEX_TYPE_ENUMERATEDINTEGER	15
#define WBEM_INDEX_TYPE_UNSIGNED32			16
#define WBEM_INDEX_TYPE_COUNTER32			17
#define WBEM_INDEX_TYPE_COUNTER64			18
#define WBEM_INDEX_TYPE_GAUGE32			19
#define WBEM_INDEX_TYPE_BITS				20
#define WBEM_INDEX_TYPE_DATETIME			21
#define WBEM_INDEX_TYPE_SNMPOSIADDRESS		22
#define WBEM_INDEX_TYPE_SNMPUDPADDRESS		23
#define WBEM_INDEX_TYPE_SNMPIPXADDRESS		24
#define WBEM_INDEX_TYPE_ROWSTATUS		25

#define WBEM_SNMP_TRANSPORTCONTEXT_OBJECT L"SnmpTransportObject=@"
#define WBEM_AGENTSNMPVERSION_DBCS_V1	"1"		
#define WBEM_AGENTSNMPVERSION_DBCS_V2C	"2C"		
#define WBEM_AGENTIPTRANSPORT_DBCS		"IP"
#define WBEM_AGENTIPXTRANSPORT_DBCS		"IPX"

#define WBEM_AGENTSNMPVERSION_V1	L"1"		
#define WBEM_AGENTSNMPVERSION_V2C	L"2C"		
#define WBEM_AGENTIPTRANSPORT		L"IP"
#define WBEM_AGENTIPXTRANSPORT		L"IPX"
#define WBEM_AGENTCOMMUNITYNAME  L"public"

#define WBEM_GENUS_INSTANCE		2
#define WBEM_GENUS_CLASS			1

#define WBEM_CLASS_NOCORRELATE 0x1000
#define WBEM_CLASS_CORRELATE_CONTEXT_PROP L"Correlate"

#define WBEM_QUERY_LANGUAGE_WQL			L"WQL"

#define WBEM_ERROR_CRITICAL_ERROR		WBEM_E_PROVIDER_FAILURE
#define WBEM_SNMP_ERROR_CRITICAL_ERROR	WBEM_SNMP_E_PROVIDER_FAILURE

#define WBEM_CLASS_PROPAGATION	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

typedef 
enum tag_WBEMSNMPSTATUS
{

	WBEM_SNMP_NO_ERROR							= 0,
	WBEM_SNMP_S_NO_ERROR							= 0,
	WBEM_SNMP_S_NO_MORE_DATA						= 0x40001,
	WBEM_SNMP_S_ALREADY_EXISTS					= WBEM_SNMP_S_NO_MORE_DATA + 1,
	WBEM_SNMP_S_NOT_FOUND						= WBEM_SNMP_S_ALREADY_EXISTS + 1,
	WBEM_SNMP_S_RESET_TO_DEFAULT					= WBEM_SNMP_S_NOT_FOUND + 1,
	WBEM_SNMP_E_FAILED							= 0x80041001,
	WBEM_SNMP_E_NOT_FOUND						= WBEM_SNMP_E_FAILED + 1,
	WBEM_SNMP_E_ACCESS_DENIED					= WBEM_SNMP_E_NOT_FOUND + 1,
	WBEM_SNMP_E_PROVIDER_FAILURE					= WBEM_SNMP_E_ACCESS_DENIED + 1,
	WBEM_SNMP_E_TYPE_MISMATCH					= WBEM_SNMP_E_PROVIDER_FAILURE + 1,
	WBEM_SNMP_E_OUT_OF_MEMORY					= WBEM_SNMP_E_TYPE_MISMATCH + 1,
	WBEM_SNMP_E_INVALID_CONTEXT					= WBEM_SNMP_E_OUT_OF_MEMORY + 1,
	WBEM_SNMP_E_INVALID_PARAMETER				= WBEM_SNMP_E_INVALID_CONTEXT + 1,
	WBEM_SNMP_E_NOT_AVAILABLE					= WBEM_SNMP_E_INVALID_PARAMETER + 1,
	WBEM_SNMP_E_CRITICAL_ERROR					= WBEM_SNMP_E_NOT_AVAILABLE + 1,
	WBEM_SNMP_E_INVALID_STREAM					= WBEM_SNMP_E_CRITICAL_ERROR + 1,
	WBEM_SNMP_E_NOT_SUPPORTED					= WBEM_SNMP_E_INVALID_STREAM + 1,
	WBEM_SNMP_E_INVALID_SUPERCLASS				= WBEM_SNMP_E_NOT_SUPPORTED + 1,
	WBEM_SNMP_E_INVALID_NAMESPACE				= WBEM_SNMP_E_INVALID_SUPERCLASS + 1,
	WBEM_SNMP_E_INVALID_OBJECT					= WBEM_SNMP_E_INVALID_NAMESPACE + 1,
	WBEM_SNMP_E_INVALID_CLASS					= WBEM_SNMP_E_INVALID_OBJECT + 1,
	WBEM_SNMP_E_PROVIDER_NOT_FOUND				= WBEM_SNMP_E_INVALID_CLASS + 1,
	WBEM_SNMP_E_INVALID_PROVIDER_REGISTRATION	= WBEM_SNMP_E_PROVIDER_NOT_FOUND + 1,
	WBEM_SNMP_E_PROVIDER_LOAD_FAILURE			= WBEM_SNMP_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_SNMP_E_INITIALIZATION_FAILURE			= WBEM_SNMP_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_SNMP_E_TRANSPORT_FAILURE				= WBEM_SNMP_E_INITIALIZATION_FAILURE + 1,
	WBEM_SNMP_E_INVALID_OPERATION				= WBEM_SNMP_E_TRANSPORT_FAILURE + 1,
	WBEM_SNMP_E_INVALID_QUERY					= WBEM_SNMP_E_INVALID_OPERATION + 1,
	WBEM_SNMP_E_INVALID_QUERY_TYPE				= WBEM_SNMP_E_INVALID_QUERY + 1,
	WBEM_SNMP_E_ALREADY_EXISTS					= WBEM_SNMP_E_INVALID_QUERY_TYPE + 1,
	WBEM_SNMP_E_OVERRIDE_NOT_ALLOWED				= WBEM_SNMP_E_ALREADY_EXISTS + 1,
	WBEM_SNMP_E_PROPAGATED_QUALIFIER				= WBEM_SNMP_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_SNMP_E_UNEXPECTED						= WBEM_SNMP_E_PROPAGATED_QUALIFIER + 1,
	WBEM_SNMP_E_ILLEGAL_OPERATION				= WBEM_SNMP_E_UNEXPECTED + 1,
	WBEM_SNMP_E_CANNOT_BE_KEY					= WBEM_SNMP_E_ILLEGAL_OPERATION + 1,
	WBEM_SNMP_E_INCOMPLETE_CLASS					= WBEM_SNMP_E_CANNOT_BE_KEY + 1,
	WBEM_SNMP_E_INVALID_SYNTAX					= WBEM_SNMP_E_INCOMPLETE_CLASS + 1,
	WBEM_SNMP_E_NONDECORATED_OBJECT				= WBEM_SNMP_E_INVALID_SYNTAX + 1,
	WBEM_SNMP_E_READ_ONLY						= WBEM_SNMP_E_NONDECORATED_OBJECT + 1,
	WBEM_SNMP_E_PROVIDER_NOT_CAPABLE				= WBEM_SNMP_E_READ_ONLY + 1,
	WBEM_SNMP_E_CLASS_HAS_CHILDREN				= WBEM_SNMP_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_SNMP_E_CLASS_HAS_INSTANCES				= WBEM_SNMP_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_SNMP_E_INVALID_PROPERTY					= WBEM_SNMP_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_SNMP_E_INVALID_QUALIFIER				= WBEM_SNMP_E_INVALID_PROPERTY + 1 ,
	WBEM_SNMP_E_INVALID_PATH						= WBEM_SNMP_E_INVALID_QUALIFIER + 1 ,
	WBEM_SNMP_E_INVALID_PATHKEYPARAMETER			= WBEM_SNMP_E_INVALID_PATH + 1 ,
	WBEM_SNMP_E_MISSINGPATHKEYPARAMETER 			= WBEM_SNMP_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_SNMP_E_INVALID_KEYORDERING				= WBEM_SNMP_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER		= WBEM_SNMP_E_INVALID_KEYORDERING + 1 ,
	WBEM_SNMP_E_MISSINGKEY						= WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_SNMP_E_INVALID_TRANSPORT				= WBEM_SNMP_E_MISSINGKEY + 1 ,
	WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT			= WBEM_SNMP_E_INVALID_TRANSPORT + 1 ,
	WBEM_SNMP_E_TRANSPORT_ERROR					= WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_SNMP_E_TRANSPORT_NO_RESPONSE			= WBEM_SNMP_E_TRANSPORT_ERROR + 1 ,
	WBEM_SNMP_E_NOWRITABLEPROPERTIES				= WBEM_SNMP_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_SNMP_E_NOREADABLEPROPERTIES				= WBEM_SNMP_E_NOWRITABLEPROPERTIES + 1 

} WBEMSNMPSTATUS;

enum WbemPropertyValueCheck
{
	SetValueRegardlessReturnCheck = 0 ,
	SetValueRegardlessDontReturnCheck ,
	SetValueIfCheckOk ,
	DontSetValueReturnCheck
} ;

#if _MSC_VER >= 1100
template <> __declspec ( dllexport ) UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
__declspec ( dllexport ) UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> __declspec ( dllexport ) BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 ) ;
#else
__declspec ( dllexport ) BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif

class __declspec ( dllexport ) WbemSnmpErrorObject 
{
private:

	wchar_t *m_snmpErrorMessage ;
	WBEMSNMPSTATUS m_snmpErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;

protected:
public:

	WbemSnmpErrorObject () : m_snmpErrorMessage ( NULL ) , m_wbemErrorStatus ( WBEM_NO_ERROR ) , m_snmpErrorStatus ( WBEM_SNMP_NO_ERROR ) {} ;
	virtual ~WbemSnmpErrorObject () { delete [] m_snmpErrorMessage ; } ;

	void SetStatus ( WBEMSNMPSTATUS a_snmpErrorStatus )
	{
		m_snmpErrorStatus = a_snmpErrorStatus ;
	} ;

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	} ;

	void SetMessage ( wchar_t *a_snmpErrorMessage )
	{
		DebugMacro1 ( 

			if ( a_snmpErrorMessage )
			{
				SnmpDebugLog :: s_SnmpDebugLog->Write ( 

					L"\r\nWbemSnmpErrorObject :: SetMessage ( (%s) )" , a_snmpErrorMessage 
				) ; 
			}
		)

		delete [] m_snmpErrorMessage ;
		m_snmpErrorMessage = UnicodeStringDuplicate ( a_snmpErrorMessage ) ;
	} ;

	wchar_t *GetMessage () { return m_snmpErrorMessage ; } ;
	WBEMSNMPSTATUS GetStatus () { return m_snmpErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
} ;

class __declspec ( dllexport ) WbemSnmpQualifier 
{
private:

	wchar_t *qualifierName ;
	SnmpInstanceType *typeValue ;

protected:
public:

	WbemSnmpQualifier ( const WbemSnmpQualifier &copy ) ;

	WbemSnmpQualifier (

		const wchar_t *qualifierName ,
		const SnmpInstanceType *typeValue 
	) ;

	virtual ~WbemSnmpQualifier () ;

	BOOL IsPropagatable () const ;

	wchar_t *GetName () const ;

	SnmpInstanceType *GetValue () const ;
	BOOL GetValue ( VARIANT &variant ) const ;
	VARTYPE GetValueVariantType () const ;

	BOOL SetValue ( const VARIANT &variant ) ;
	BOOL SetValue ( const SnmpInstanceType *value ) ;
	BOOL SetValue ( const wchar_t *value ) ;
	BOOL SetValue ( IWbemQualifierSet *a_Qualifier , const SnmpInstanceType &value ) ;
} ;

class __declspec ( dllexport ) WbemSnmpProperty 
{
private:

/* 
 * Qualifier Information
 */

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpQualifier *,WbemSnmpQualifier *

	> qualifierMap ;

	POSITION qualifierPosition ;

/* 
 * Property Information
 */

	BOOL m_isWritable ;
	BOOL m_isReadable ;
	BOOL m_isKey ;
	BOOL m_isVirtualKey ;
	BOOL m_IsNull ;
	BOOL tagged ;

	ULONG m_keyOrder ;
	ULONG m_TextualConvention ;

	wchar_t *propertyName ;
	SnmpInstanceType *propertyValue ;

	long m_Handle ;

protected:
public:

	WbemSnmpProperty ( const wchar_t *propertyName ) ;
	WbemSnmpProperty ( const WbemSnmpProperty &copy ) ;
	virtual ~WbemSnmpProperty () ;

	void SetTag ( BOOL tag = TRUE ) ;
	BOOL GetTag () ;

	BOOL IsKey () ;
	BOOL IsVirtualKey () ;
	BOOL IsWritable () ;
	BOOL IsReadable () ;
	ULONG GetKeyOrder () ;
	ULONG GetTextualConvention () ;
	long GetHandle () ;

	void SetKey ( BOOL a_isKey = TRUE ) ;
	void SetKeyOrder ( ULONG a_keyOrder ) ;
	void SetVirtualKey ( BOOL a_isVirtualKey = TRUE ) ;
	void SetReadable ( BOOL a_isReadable = TRUE ) ;
	void SetWritable ( BOOL a_isWritable = TRUE ) ;
	void SetTextualConvention ( ULONG a_TextualConvention ) ;
	void SetHandle ( long a_Handle ) ;

	wchar_t *GetName () const ;

	BOOL IsNull () ;
	BOOL IsSNMPV1Type () { return propertyValue->IsSNMPV1Type () ; }
	BOOL IsSNMPV2CType () { return propertyValue->IsSNMPV2CType () ; }

	SnmpInstanceType *GetValue () const ;
	BOOL GetValue ( VARIANT &variant , CIMTYPE &type ) const ;
	VARTYPE GetValueVariantType () const ;
	VARTYPE GetValueVariantEncodedType () const ;

	BOOL SetValue ( const VARIANT &variant , const CIMTYPE &type , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const wchar_t *value , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const SnmpInstanceType *propertyValue , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const SnmpValue *propertyValue , WbemPropertyValueCheck check = SetValueIfCheckOk  ) ;
	BOOL SetValue ( IWbemClassObject *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;

	BOOL Encode ( const VARIANT &a_EncodeValue , SnmpObjectIdentifier &a_Encode ) ;

#if 0
	BOOL SetValue ( IWbemObjectAccess *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetDWORD ( BOOL a_Status , IWbemObjectAccess *a_Object , DWORD a_Value , WbemPropertyValueCheck check ) ;
	BOOL SetNULL ( BOOL a_Status , IWbemObjectAccess *a_Object , WbemPropertyValueCheck check ) ;
	BOOL SetSTRING ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t *t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check ) ;

#endif

	ULONG GetQualifierCount () ;
	BOOL AddQualifier ( wchar_t *qualifierName ) ;
	BOOL AddQualifier ( WbemSnmpQualifier *qualifier ) ;
	void ResetQualifier () ;
	WbemSnmpQualifier *NextQualifier () ;
	WbemSnmpQualifier *FindQualifier ( wchar_t *qualifierName ) const ;

	virtual BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class __declspec ( dllexport ) WbemSnmpClassObject 
{
private:

/* 
 * Object Information
 */

	BOOL m_isClass ;
	BOOL m_isKeyed ;
	BOOL m_isSingleton ;
	BOOL m_isVirtual ;
	BOOL m_isReadable ;
	BOOL m_isWritable ;
	ULONG m_numberOfAccessible ;

	wchar_t *className ;

/*
 * Qualifier Information
 */

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpQualifier *,WbemSnmpQualifier *

	> qualifierMap ;

	POSITION qualifierPosition ;

/*
 * Property Information
 */

	SnmpList <WbemSnmpProperty *,WbemSnmpProperty *> keyedPropertyList ;

	LONG keyedPropertyPosition ;

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpProperty *,WbemSnmpProperty *

	> propertyMap ;

	POSITION propertyPosition ;

private:

	BOOL SetMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL SetMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL SetMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL SetMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	BOOL  GetMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject 
	) ;

	BOOL GetMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL MergeMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject , 
		IWbemClassObject *mosClassObject , 
		BOOL rigorous 
	) ;

	BOOL GetMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject 
	) ;

	BOOL GetMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	BOOL MergeMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL MergeMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL MergeMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	void AddKeyedProperty ( WbemSnmpProperty *snmpProperty ) ;

protected:
public:

	WbemSnmpClassObject () ;
	WbemSnmpClassObject ( const WbemSnmpClassObject &copy ) ;
	WbemSnmpClassObject ( const wchar_t *className , const BOOL isClass = TRUE ) ;
	~WbemSnmpClassObject () ;

	BOOL IsReadable () ;
	void SetReadable ( BOOL a_isReadable = TRUE ) ;

	BOOL IsWritable () ;
	void SetWritable ( BOOL a_isWritable = TRUE ) ;

	BOOL IsKeyed () ;
	void SetKeyed ( BOOL a_isKeyed = TRUE ) ;

	BOOL IsVirtual () ;
	void SetVirtual ( BOOL a_isVirtual = TRUE ) ;

	BOOL IsSingleton () ;
	void SetSingleton ( BOOL a_isSingleton = TRUE ) ;

	ULONG GetNumberOfAccessible () ;
	void SetNumberOfAccessible ( ULONG m_numberOfAccessible ) ;

	void SetIsClass ( const BOOL isClass ) { m_isClass = isClass ; }

	BOOL IsClass () { return m_isClass ; }

	wchar_t *GetClassName () const ;

	ULONG GetPropertyCount () ;
	BOOL AddProperty ( wchar_t *propertyName ) ;
	BOOL AddProperty ( WbemSnmpProperty *property ) ;
	void ResetProperty () ;
	void DeleteProperty ( wchar_t *propertyName ) ;
	WbemSnmpProperty *NextProperty () ;
	WbemSnmpProperty *FindProperty ( wchar_t *propertyName ) const ;

	BOOL AddKeyedProperty ( wchar_t *propertyName ) ;
	ULONG GetKeyPropertyCount () ;
	void ResetKeyProperty () ;
	WbemSnmpProperty *NextKeyProperty () ;
	WbemSnmpProperty *FindKeyProperty ( wchar_t *propertyName ) const ;

	ULONG GetQualifierCount () ;
	BOOL AddQualifier ( wchar_t *qualifierName ) ;
	BOOL AddQualifier ( WbemSnmpQualifier *qualifier ) ;
	void ResetQualifier () ;
	WbemSnmpQualifier *NextQualifier () ;
	WbemSnmpQualifier *FindQualifier ( wchar_t *qualifierName ) const ;

	BOOL Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous = TRUE ) ;
	BOOL Get ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) ;
	BOOL Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous = TRUE ) ;

	virtual BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\snmpset.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SNMPSET_H
#define __SNMPSET_H

class SetOperation : public SnmpSetOperation
{
private:

	WbemSnmpProperty **m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	SnmpSetResponseEventObject *eventObject ;

	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;

	SnmpSession *session ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

public:

	SetOperation (IN SnmpSession &session , IN SnmpSetResponseEventObject *eventObject ) ;
	~SetOperation () ;

	void Send ( const ULONG &a_NumberToSend = 0xffffffff ) ;

	void DestroyOperation () { SnmpSetOperation :: DestroyOperation () ; }
};

#endif // __SNMPSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\snmprefr.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SNMPREFR_H
#define __SNMPREFR_H

class RefreshOperation : public SnmpGetOperation
{
private:

	SnmpVarBindList m_VarBindList ;
	WbemSnmpProperty **m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	SnmpRefreshEventObject *eventObject ;

	BOOL virtuals ;
	BOOL virtualsInitialised ;
	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;

	SnmpSession *session ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

public:

	RefreshOperation (IN SnmpSession &session , IN SnmpRefreshEventObject *eventObject ) ;
	~RefreshOperation () ;

	void Send () ;

	void DestroyOperation () { SnmpGetOperation :: DestroyOperation () ; }

};

#endif // __SNMPREFR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: OLE MS SNMP PROPERTY PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <instpath.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcont.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <classfac.h>
#include "proxyprov.h"
#include "guids.h"

LONG CProxyLocatorClassFactory :: objectsInProgress = 0 ;
LONG CProxyLocatorClassFactory :: locksInProgress = 0 ;

LONG CProxyProvClassFactory :: objectsInProgress = 0 ;
LONG CProxyProvClassFactory :: locksInProgress = 0 ;

//***************************************************************************
//
// CProxyLocatorClassFactory::CProxyLocatorClassFactory
// CProxyLocatorClassFactory::~CProxyLocatorClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProxyLocatorClassFactory :: CProxyLocatorClassFactory ()
{
	m_referenceCount = 0 ;
}

CProxyLocatorClassFactory::~CProxyLocatorClassFactory ()
{
}

//***************************************************************************
//
// CProxyLocatorClassFactory::QueryInterface
// CProxyLocatorClassFactory::AddRef
// CProxyLocatorClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CProxyLocatorClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CProxyLocatorClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CProxyLocatorClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CProxyLocatorClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProxyLocatorClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemLocator *lpunk = ( IWbemLocator * ) new CImpProxyLocator ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}
	}

	return status ;
}

//***************************************************************************
//
// CProxyLocatorClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CProxyLocatorClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & locksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & locksInProgress ) ;
	}

	return S_OK	;
}


//***************************************************************************
//
// CProxyProvClassFactory::CProxyProvClassFactory
// CProxyProvClassFactory::~CProxyProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProxyProvClassFactory :: CProxyProvClassFactory ()
{
	m_referenceCount = 0 ;
}

CProxyProvClassFactory::~CProxyProvClassFactory ()
{
}

//***************************************************************************
//
// CProxyProvClassFactory::QueryInterface
// CProxyProvClassFactory::AddRef
// CProxyProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CProxyProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CProxyProvClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CProxyProvClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CProxyProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProxyProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemServices *lpunk = ( IWbemServices * ) new CImpProxyProv ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

//***************************************************************************
//
// CProxyProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CProxyProvClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & locksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & locksInProgress ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\perf\include\snmpqset.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SNMPQSET_H
#define __SNMPQSET_H

class SetQueryOperation : public SnmpGetOperation
{
private:

	BOOL rowReceived ;

	SnmpSession *session ;

	SnmpSetResponseEventObject *eventObject ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

public:

	SetQueryOperation  (IN SnmpSession &session,	IN SnmpSetResponseEventObject *eventObjectArg ) ;
	~SetQueryOperation  () ;

	void Send () ;
	
	ULONG GetRowReceived () { return rowReceived ; }

	void DestroyOperation () { SnmpGetOperation :: DestroyOperation () ; }
};

#endif // __SNMPQSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\proxy.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpClasProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

#include <wbemidl.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpobj.h>
#include "classfac.h"
#include "proxyprov.h"
#include "proxy.h"
#include "guids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\include\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks.  

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>
#include <olectl.h>

#include <wbemidl.h>
#include <instpath.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcont.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include "classfac.h"
#include "proxyprov.h"
#include "guids.h"

//OK we need this one
HINSTANCE   g_hInst=NULL;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		status = TRUE ;
		DisableThreadLibraryCalls(hInstance);			// 158024 
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }


    return TRUE ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_CProxyLocatorClassFactory ) 
	{
		CProxyLocatorClassFactory *lpunk = new CProxyLocatorClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_CProxyProvClassFactory ) 
	{
		CProxyProvClassFactory *lpunk = new CProxyProvClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else	
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}
	
	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */

	BOOL unload = ( CProxyLocatorClassFactory :: locksInProgress || CProxyLocatorClassFactory :: objectsInProgress )	;
	unload = unload || ( CProxyProvClassFactory :: locksInProgress || CProxyProvClassFactory :: objectsInProgress )	;	
	unload = ! unload ;

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

//Strings used during self registeration

#define REG_FORMAT_STR			L"%s\\%s"
#define VER_IND_STR				L"VersionIndependentProgID"
#define NOT_INTERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define INPROC_STR				L"InprocServer"
#define PROGID_STR				L"ProgID"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"

#define CLSID_STR				L"CLSID\\"
#define CLSID2_STR				L"CLSID"
#define CVER_STR				L"CurVer"

#define LOCATOR_NAME_STR		L"Microsoft HMM Proxy Locator"
#define LOCATOR_STR				L"OLEMS.SNMP.CLASS.LOCATOR"
#define LOCATOR_CVER_STR		L"OLEMS.SNMP.CLASS.LOCATOR\\CurVer"
#define LOCATOR_CLSID_STR		L"OLEMS.SNMP.CLASS.LOCATOR\\CLSID"
#define LOCATOR_VER_CLSID_STR	L"OLEMS.SNMP.CLASS.LOCATOR.0\\CLSID"
#define LOCATOR_VER_STR			L"OLEMS.SNMP.CLASS.LOCATOR.0"

#define PROVIDER_NAME_STR		L"Microsoft HMM Proxy Provider"
#define PROVIDER_STR			L"OLEMS.SNMP.CLASS.PROVIDER"
#define PROVIDER_CVER_STR		L"OLEMS.SNMP.CLASS.PROVIDER\\CurVer"
#define PROVIDER_CLSID_STR		L"OLEMS.SNMP.CLASS.PROVIDER\\CLSID"
#define PROVIDER_VER_CLSID_STR	L"OLEMS.SNMP.CLASS.PROVIDER.0\\CLSID"
#define PROVIDER_VER_STR		L"OLEMS.SNMP.CLASS.PROVIDER.0"

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

    wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_CLASSES_ROOT
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI DllRegisterServer()
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szLocatorClassID[128];
	wchar_t szLocatorCLSIDClassID[128];

	int iRet = StringFromGUID2(CLSID_CProxyLocatorClassFactory,szLocatorClassID, 128);

	wcscpy(szLocatorCLSIDClassID,CLSID_STR);
	wcscat(szLocatorCLSIDClassID,szLocatorClassID);

#if 0 
	//Create ProgID keys
	if (FALSE ==SetKeyAndValue(LOCATOR_VER_STR, NULL, NULL, LOCATOR_NAME_STR))
		return SELFREG_E_CLASS;
		
	if (FALSE ==SetKeyAndValue(LOCATOR_VER_STR, CLSID2_STR, NULL,szLocatorClassID))
		return SELFREG_E_CLASS;

	//Create VersionIndependentProgID keys
	if (FALSE ==SetKeyAndValue(LOCATOR_STR, NULL , NULL, LOCATOR_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(LOCATOR_STR, CVER_STR,NULL, LOCATOR_VER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(LOCATOR_STR, CLSID2_STR, NULL, szLocatorClassID))
		return SELFREG_E_CLASS;

#endif

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, NULL, NULL, LOCATOR_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, PROGID_STR, NULL, LOCATOR_VER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, VER_IND_STR, NULL, LOCATOR_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	iRet = StringFromGUID2(CLSID_CProxyProvClassFactory,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

#if 0
	//Create ProgID keys
	if (FALSE ==SetKeyAndValue(PROVIDER_VER_STR, NULL, NULL, PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
		
	if (FALSE ==SetKeyAndValue(PROVIDER_VER_STR, CLSID2_STR, NULL,szProviderClassID))
		return SELFREG_E_CLASS;

	//Create VersionIndependentProgID keys
	if (FALSE ==SetKeyAndValue(PROVIDER_STR, NULL , NULL, PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(PROVIDER_STR, CVER_STR,NULL, PROVIDER_VER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(PROVIDER_STR, CLSID2_STR, NULL, szProviderClassID))
		return SELFREG_E_CLASS;

#endif

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
	wchar_t szTemp[128];

	wchar_t szLocatorClassID[128];
	wchar_t szLocatorCLSIDClassID[128];

	int iRet = StringFromGUID2(CLSID_CProxyLocatorClassFactory,szLocatorClassID, 128);

	wcscpy(szLocatorCLSIDClassID,CLSID_STR);
	wcscat(szLocatorCLSIDClassID,szLocatorClassID);

	//Delete ProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, LOCATOR_CVER_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, LOCATOR_CLSID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, LOCATOR_STR);

	//Delete VersionIndependentProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, LOCATOR_VER_CLSID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, LOCATOR_VER_STR);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szLocatorCLSIDClassID, PROGID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szLocatorCLSIDClassID, VER_IND_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szLocatorCLSIDClassID, NOT_INTERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR,szLocatorCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szLocatorCLSIDClassID);

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	iRet = StringFromGUID2(CLSID_CProxyProvClassFactory,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szLocatorClassID);

	//Delete ProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, PROVIDER_CVER_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, PROVIDER_CLSID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, PROVIDER_STR);

	//Delete VersionIndependentProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, PROVIDER_VER_CLSID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, PROVIDER_VER_STR);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, PROGID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, VER_IND_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INTERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ProxyProvider.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\include\proxy.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define WBEM_QUALIFIER_PROXYNAMESPACE						L"ProxyNamespace"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\include\guids.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// {CEAE974C-D862-11d0-82D3-00A0C9038B34}
DEFINE_GUID(CLSID_CProxyLocatorClassFactory,  
0xceae974c, 0xd862, 0x11d0, 0x82, 0xd3, 0x0, 0xa0, 0xc9, 0x3, 0x8b, 0x34);

// {CEAE974D-D862-11d0-82D3-00A0C9038B34}
DEFINE_GUID(CLSID_CProxyProvClassFactory, 
0xceae974d, 0xd862, 0x11d0, 0x82, 0xd3, 0x0, 0xa0, 0xc9, 0x3, 0x8b, 0x34);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\proxyprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpProxyProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>
#include <typeinfo.h>
#include <wbemidl.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <genlex.h>
#include <objpath.h>

#include "classfac.h"
#include "proxyprov.h"
#include "proxy.h"
#include "guids.h"

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

SnmpDefaultThreadObject *CImpProxyProv :: s_defaultThreadObject = NULL ;

// {1F517A23-B29C-11cf-8C8D-00AA00A4086C}
DEFINE_GUID(CLSID_CPropProvClassFactory, 
0x1f517a23, 0xb29c, 0x11cf, 0x8c, 0x8d, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpProxyProv::CImpProxyProv
// CImpProxyProv::~CImpProxyProv
//
//***************************************************************************

CImpProxyProv::CImpProxyProv ()
{
	m_referenceCount = 0 ; 

/* 
 * Place code in critical section
 */

    InterlockedIncrement ( & CProxyProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	initialised = FALSE ;
	server = NULL ;
	parentServer = NULL ;
	proxiedProvider = NULL ;
	proxiedNamespaceString = NULL ;
	thisNamespace = NULL ;
	
}

CImpProxyProv::~CImpProxyProv(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CProxyProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	delete [] proxiedNamespaceString ;
 
	if ( parentServer )
		parentServer->Release () ;

	if ( server )
		server->Release () ;

	if ( proxiedProvider )
		proxiedProvider->Release () ;

	delete [] thisNamespace ;
}

//***************************************************************************
//
// CImpProxyProv::QueryInterface
// CImpProxyProv::AddRef
// CImpProxyProv::Release
//
// Purpose: IUnknown members for CImpProxyProv object.
//***************************************************************************

STDMETHODIMP CImpProxyProv::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

STDMETHODIMP_(ULONG) CImpProxyProv::AddRef(void)
{
    return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpProxyProv::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

void CImpProxyProv :: SetServer ( IWbemServices *serverArg ) 
{
	server = serverArg ; 
	server-AddRef () ; 
}

void CImpProxyProv :: SetParentServer ( IWbemServices *parentServerArg ) 
{
	parentServer = parentServerArg ; 
	parentServer->AddRef () ; 
}

void CImpProxyProv :: SetProvider ( IWbemServices *provider ) 
{ 
	proxiedProvider = provider ; 
}

IWbemServices *CImpProxyProv :: GetParentServer () 
{ 
	return ( IWbemServices * ) parentServer ; 
}

IWbemServices *CImpProxyProv :: GetServer () 
{ 
	return ( IWbemServices * ) server ; 
}


wchar_t *CImpProxyProv :: GetThisNamespace () 
{
	return thisNamespace ; 
}

void CImpProxyProv :: SetThisNamespace ( wchar_t *thisNamespaceArg ) 
{
	thisNamespace = UnicodeStringDuplicate ( thisNamespaceArg ) ; 
}

BOOL CImpProxyProv:: AttachProxyProvider ( 

	WbemSnmpErrorObject &a_errorObject ,
	BSTR ObjectPath, 
	long lFlags, 
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	BOOL status = TRUE ;

	IWbemLocator *remoteServer = NULL ;

	HRESULT result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & remoteServer
	);

	if ( SUCCEEDED ( result ) )
	{
		IWbemServices *proxiedProvider = NULL ;

		result = remoteServer->ConnectServer (

			ObjectPath ,
			NULL ,
			NULL ,
			NULL ,
			0 ,
			NULL,
			NULL,
			&proxiedProvider 
		) ;

		if ( SUCCEEDED ( result ) )
		{
			IWbemConfigure* t_Configure = NULL ;
			result = proxiedProvider->QueryInterface ( IID_IWbemConfigure , ( void ** ) & t_Configure ) ;
			if ( SUCCEEDED ( result ) )
			{
				t_Configure->SetConfigurationFlags(WBEM_CONFIGURATION_FLAG_CRITICAL_USER);
				t_Configure->Release();
			}

			( ( * ( CImpProxyProv** ) pNewContext ) )->SetProvider ( proxiedProvider ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to get IWbemServices object from instance provider" ) ;
		}

		remoteServer->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemServices" ) ;
	}

	return status;
}

BOOL CImpProxyProv::AttachParentServer ( 

	WbemSnmpErrorObject &a_errorObject ,
	BSTR ObjectPath, 
	long lFlags, 
	IWbemServices FAR* FAR* pNewContext ,
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	BOOL status = TRUE ;

	CImpProxyProv *classProvider = * ( CImpProxyProv ** ) pNewContext ;

	IWbemLocator *locator = NULL ;
	IWbemServices *server = NULL ;

// Get Parent Namespace Path

	WbemNamespacePath *namespacePath = classProvider->GetNamespacePath () ;

	ULONG count = namespacePath->GetCount () ;
	wchar_t *path = NULL ;

	if ( namespacePath->GetServer () )
	{
		path = UnicodeStringDuplicate ( L"\\\\" ) ;
		wchar_t *concatPath = UnicodeStringAppend ( path , namespacePath->GetServer () ) ;
		delete [] path ;
		path = concatPath ;
	}

	if ( ! namespacePath->Relative () )
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , L"\\" ) ;
		delete [] path ;
		path = concatPath ;
	}

	ULONG pathIndex = 0 ;		
	wchar_t *pathComponent ;
	namespacePath->Reset () ;
	while ( ( pathIndex < count - 1 ) && ( pathComponent = namespacePath->Next () ) ) 
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , pathComponent ) ;
		delete [] path ;
		path = concatPath ;
		if ( pathIndex < count - 2 )
		{
			concatPath = UnicodeStringAppend ( path , L"\\" ) ;
			delete [] path ;
			path = concatPath ;
		}

		pathIndex ++ ;
	}

// Get Name of child namespace relative to parent namespace

	if ( pathComponent = namespacePath->Next () )
	{
		( ( * ( CImpProxyProv ** ) pNewContext ) )->SetThisNamespace ( pathComponent ) ; 
	}

// Connect to parent namespace
	
	HRESULT result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & locator
	);

	if ( SUCCEEDED ( result ) )
	{
		result = locator->ConnectServer (

			path ,
			NULL ,
			NULL ,
			NULL  ,
			0 ,
			NULL,
			NULL,
			( IWbemServices ** ) & parentServer
		) ;

		if ( result == WBEM_NO_ERROR )
		{
// Mark this interface pointer as "critical"

			IWbemConfigure* pConfigure = NULL ;
			result= parentServer->QueryInterface(IID_IWbemConfigure, (void**)&pConfigure);
			if(SUCCEEDED(result))
			{
				pConfigure->SetConfigurationFlags(WBEM_CONFIGURATION_FLAG_CRITICAL_USER);
				pConfigure->Release();

				( ( * ( CImpProxyProv ** ) pNewContext ) )->SetParentServer ( parentServer ) ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to configure" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace's parent namespace" ) ;
		}

		locator->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	delete [] path ;
	return status ;
}

BOOL CImpProxyProv::AttachServer ( 

	WbemSnmpErrorObject &a_errorObject ,
	BSTR ObjectPath, 
	long lFlags, 
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	BOOL status = TRUE ;

	IWbemLocator *locator = NULL ;
	IWbemServices *server = NULL ;

	HRESULT result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & locator
	);

	if ( SUCCEEDED ( result ) )
	{
		result = locator->ConnectServer (

			ObjectPath ,
			NULL ,
			NULL ,
			NULL ,
			0 ,
			NULL,
			NULL,
			( IWbemServices ** ) & server 
		) ;

		if ( result == WBEM_NO_ERROR )
		{
// Mark this interface pointer as "critical"

			IWbemConfigure* pConfigure = NULL ;
			result= server->QueryInterface(IID_IWbemConfigure, (void**)&pConfigure);
			if(SUCCEEDED(result))
			{
				pConfigure->SetConfigurationFlags(WBEM_CONFIGURATION_FLAG_CRITICAL_USER);
				pConfigure->Release();

				( ( * ( CImpProxyProv ** ) pNewContext ) )->SetServer ( server ) ;

				status = AttachParentServer ( 

					a_errorObject ,
					ObjectPath ,
					0 ,
					pNewContext ,
					ppErrorObject
				) ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to configure" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace" ) ;
		}

		locator->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	return status ;
}

BOOL CImpProxyProv::ObtainProxiedNamespace ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	IWbemClassObject *namespaceObject = NULL ;
	IWbemCallResult *errorObject = NULL ;

	wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , GetThisNamespace () ) ;
	wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

	delete [] objectPathPrefix ;

	HRESULT result = parentServer->GetObject ( 

		objectPath ,		
		0 ,
		NULL,
		&namespaceObject ,
		&errorObject 
	) ;

	if ( errorObject )
		errorObject->Release () ;

	delete [] objectPath ;

	if ( SUCCEEDED ( result ) )
	{
		IWbemQualifierSet *classQualifierObject ;
		result = namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( & variant ) ;

			LONG attributeType ;
			result = classQualifierObject->Get ( 

				WBEM_QUALIFIER_PROXYNAMESPACE , 
				0,	
				&variant ,
				& attributeType 

			) ;

			if ( SUCCEEDED ( result ) )
			{
				if ( variant.vt == VT_BSTR ) 
				{
					proxiedNamespaceString = UnicodeStringDuplicate ( variant.bstrVal ) ;
				}
				else
				{
/*
 *	Transport qualifier was not a string value
 */

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
				}
			}

			VariantClear ( & variant );
		}

		namespaceObject->Release () ;
	}

	return status ;
}

SCODE CImpProxyProv::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext *pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	if ( ppErrorObject )
		*ppErrorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorObject ;

	wchar_t *openPath = NULL ;

	if ( initialised )
	{
		WbemNamespacePath openNamespacePath ( namespacePath ) ;

		WbemNamespacePath objectPathArg ;
		if ( objectPathArg.SetNamespacePath ( ObjectPath ) )
		{
			if ( objectPathArg.Relative () )
			{
				if ( openNamespacePath.ConcatenatePath ( objectPathArg ) )
				{
					openPath = openNamespacePath.GetNamespacePath () ;
				}
				else
				{
					status = FALSE ;
					errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
					errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					errorObject.SetMessage ( L"Path specified was not relative to current namespace" ) ;
				}
			}
			else
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
				errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				errorObject.SetMessage ( L"Path specified was not relative to current namespace" ) ;
			}
		}
	}
	else
	{
		openPath = UnicodeStringDuplicate ( ObjectPath ) ;
	}

	if ( status ) 
	{
		HRESULT result = CoCreateInstance (
  
			CLSID_CProxyProvClassFactory ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
			IID_IWbemServices ,
			( void ** ) pNewContext
		);

		if ( SUCCEEDED ( result ) )
		{
			CImpProxyProv *provider = * ( CImpProxyProv ** ) pNewContext ;

			if ( provider->GetNamespacePath ()->SetNamespacePath ( openPath ) )
			{
				IWbemCallResult *t_ErrorObject = NULL ;

				status = AttachServer ( 

					errorObject ,
					ObjectPath ,
					lFlags, 
					pNewContext, 
					&t_ErrorObject
				) ;

				if ( t_ErrorObject )
					t_ErrorObject->Release () ;

				if ( status ) 
				{
					status = provider->ObtainProxiedNamespace ( errorObject ) ;
					if ( status )
					{
						t_ErrorObject = NULL ;

						status = AttachProxyProvider (

							errorObject ,
							provider->GetProxiedNamespaceString () ,
							lFlags, 
							pNewContext, 
							&t_ErrorObject
						) ;			

						if ( t_ErrorObject )
							t_ErrorObject->Release () ;

					}
				}
			}
			else
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemServicesr" ) ;
			}
		}
		else
		{
			status = FALSE ;
			errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
		}

	}

	delete [] openPath ;

	HRESULT result = errorObject.GetWbemStatus () ;

	return result ;
}


HRESULT CImpProxyProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return proxiedProvider->CancelAsyncCall(

		pSink
	) ;
}

HRESULT CImpProxyProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpProxyProv :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpProxyProv :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;

	Notification *t_Notification = new Notification ( this , pHandler ) ;

	if ( ObjectPath [ 0 ] == L'\\' )
	{
		wchar_t *t_RelativePath = CObjectPathParser::GetRelativePath ( ObjectPath );
		t_Result = proxiedProvider->GetObjectAsync (

			t_RelativePath , 
			lFlags, 
			pCtx,
			t_Notification
		) ;
	}
	else
	{
		t_Result = proxiedProvider->GetObjectAsync (

			ObjectPath , 
			lFlags, 
			pCtx,
			t_Notification
		) ;
	}

	t_Notification->Release () ;

	return t_Result ;

}

HRESULT CImpProxyProv :: PutClass ( 
		
	IWbemClassObject FAR* pClass , 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpProxyProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pClass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	Notification *t_Notification = new Notification ( this , pHandler ) ;

	HRESULT t_Result = proxiedProvider->PutClassAsync (

		pClass ,
		lFlags ,
		pCtx,
		t_Notification
	) ;

	t_Notification->Release () ;

	return t_Result ;

}

 HRESULT CImpProxyProv :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpProxyProv :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	Notification *t_Notification = new Notification ( this , pHandler ) ;

	HRESULT t_Result = proxiedProvider->DeleteClassAsync (

		Class  ,
		lFlags ,
		pCtx,
		t_Notification
	) ;

	t_Notification->Release () ;

	return t_Result ;
}

HRESULT CImpProxyProv :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpProxyProv :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	Notification *t_Notification = new Notification ( this , pHandler ) ;

	HRESULT t_Result = proxiedProvider->CreateClassEnumAsync (

		Superclass ,
		lFlags ,
		pCtx,
		t_Notification
	) ;

	t_Notification->Release () ;

	return t_Result ;
}

HRESULT CImpProxyProv :: PutInstance (

    IWbemClassObject FAR *pInstance,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpProxyProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInstance, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	Notification *t_Notification = new Notification ( this , pHandler ) ;

	HRESULT t_Result = proxiedProvider->PutInstanceAsync (	

		pInstance, 
		lFlags, 
		pCtx,
		t_Notification
	) ;

	t_Notification->Release () ;

	return t_Result ;

}

HRESULT CImpProxyProv :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpProxyProv :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	Notification *t_Notification = new Notification ( this , pHandler ) ;

	HRESULT t_Result = proxiedProvider->DeleteInstanceAsync (

		ObjectPath ,
		lFlags ,
		pCtx,
		t_Notification
	) ;

	t_Notification->Release () ;

	return t_Result ;

}

HRESULT CImpProxyProv :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpProxyProv :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	Notification *t_Notification = new Notification ( this , pHandler ) ;

	HRESULT t_Result = proxiedProvider->CreateInstanceEnumAsync  (

		Class, 
		lFlags, 
		pCtx,
		t_Notification
	) ;

	t_Notification->Release () ;
	
	return t_Result ;
}

HRESULT CImpProxyProv :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpProxyProv :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	Notification *t_Notification = new Notification ( this , pHandler ) ;

	HRESULT t_Result = proxiedProvider->ExecQueryAsync (

		QueryFormat, 
		Query, 
		lFlags,
		pCtx,
		t_Notification 
	) ;

	t_Notification->Release () ;

	return t_Result ;
}

HRESULT CImpProxyProv :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpProxyProv :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpProxyProv :: ExecMethod( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpProxyProv :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpProxyLocator::CImpProxyLocator
// CImpProxyLocator::~CImpProxyLocator
//
//***************************************************************************

CImpProxyLocator::CImpProxyLocator ()
{
	m_referenceCount = 0 ; 

/* 
 * Place code in critical section
 */

    InterlockedIncrement ( & CProxyLocatorClassFactory :: objectsInProgress ) ;
}

CImpProxyLocator::~CImpProxyLocator(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CProxyLocatorClassFactory :: objectsInProgress ) ;
}

//***************************************************************************
//
// CImpProxyLocator::QueryInterface
// CImpProxyLocator::AddRef
// CImpProxyLocator::Release
//
// Purpose: IUnknown members for CImpProxyLocator object.
//***************************************************************************

STDMETHODIMP CImpProxyLocator::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemLocator )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

STDMETHODIMP_(ULONG) CImpProxyLocator::AddRef(void)
{
    return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpProxyLocator::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

STDMETHODIMP_( SCODE ) CImpProxyLocator :: ConnectServer ( 

	BSTR ObjectPath , 
	BSTR User, 
	BSTR Password, 
	BSTR lLocaleId, 
	long lFlags, 
	BSTR Authority,
	IWbemContext FAR *pCtx ,
	IWbemServices FAR* FAR* ppNamespace
) 
{
	if ( ! CImpProxyProv :: s_defaultThreadObject )
	{
		CImpProxyProv :: s_defaultThreadObject = new SnmpDefaultThreadObject ;
	}

	IWbemServices FAR* gateway ;

	HRESULT result = CoCreateInstance (
  
		CLSID_CProxyProvClassFactory ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemServices ,
		( void ** ) & gateway
	) ;

	if ( SUCCEEDED ( result ) )
	{
		IWbemCallResult *t_ErrorObject = NULL ;

		result = gateway->OpenNamespace (

			ObjectPath ,
			0 ,
			NULL,
			( IWbemServices ** ) ppNamespace ,
			&t_ErrorObject 
		) ;

		if ( t_ErrorObject )
			t_ErrorObject->Release () ;

		if ( result == WBEM_NO_ERROR )
		{
/* 
 * Connected to OLE MS Server
 */

		}
		else
		{
/*
 *	Failed to connect to OLE MS Server.
 */
		}

		gateway->Release () ;
	}

	return result ;
}

Notification::Notification ( 

	CImpProxyProv *a_Provider , 
	IWbemObjectSink *a_ProviderNotification 

) : m_Provider ( a_Provider ) , 
	m_ProviderNotification ( a_ProviderNotification ) ,
	m_ReferenceCount ( 1 )
{
	m_Provider->AddRef () ;
	m_ProviderNotification->AddRef () ;
}

Notification::~Notification ()
{
	m_Provider->Release () ;
	m_ProviderNotification->Release () ;
}

STDMETHODIMP_(ULONG) Notification::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) Notification::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

STDMETHODIMP Notification::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

HRESULT Notification :: SetStatus (

	long lFlags,
	long lParam,
	BSTR strParam,
	IWbemClassObject __RPC_FAR *pObjParam
)
{
	return m_ProviderNotification->SetStatus (

		lFlags,
		lParam,
		strParam,
		pObjParam
	) ;
}


HRESULT Notification :: Indicate ( 
							  
	long a_ObjectCount, 
	IWbemClassObject FAR* FAR* a_ObjectArray
)
{

	ULONG t_Index = 0 ;
	while ( t_Index < a_ObjectCount ) 
	{
		IWbemClassObject *t_Object = a_ObjectArray [ t_Index ] ;
		IWbemClassObject *t_CloneObject = NULL ;

		HRESULT t_Result = t_Object->Clone ( &t_CloneObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = TRUE ;

			BSTR t_PropertyName = NULL ;
			VARTYPE t_VarType ;

			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			t_CloneObject->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
			while ( t_Status && ( t_CloneObject->Next ( 0 , & t_PropertyName , &t_Variant , &t_VarType , NULL ) == WBEM_NO_ERROR ) )
			{
				IWbemQualifierSet *t_PropertyQualifierSet ;
				if ( SUCCEEDED ( t_Result = t_CloneObject->GetPropertyQualifierSet ( t_PropertyName , &t_PropertyQualifierSet ) ) ) 
				{

					VARIANT t_CimType ;
					VariantInit ( &t_CimType ) ;

					LONG t_Flag;
					if ( SUCCEEDED ( t_PropertyQualifierSet->Get ( L"CIMTYPE" , 0 , &t_CimType , &t_Flag ) ) )
					{
						wchar_t *t_Type = t_CimType.bstrVal ;

						if ( wcsnicmp ( t_Type , L"ref" , 3 ) == 0 )
						{
							wchar_t *t_ObjectPath = t_Variant.bstrVal ;

							if ( t_ObjectPath [ 0 ] == L'\\' )
							{
								wchar_t *t_RelativePath = CObjectPathParser::GetRelativePath ( t_ObjectPath );

								VARIANT t_PutVariant ;
								VariantInit ( & t_PutVariant ) ;

								t_PutVariant.vt = VT_BSTR ;
								t_PutVariant.bstrVal = SysAllocString ( t_RelativePath ) ;

								t_Result = t_CloneObject->Put ( t_PropertyName , 0 , &t_PutVariant , 0 ) ;

								VariantClear ( &t_PutVariant ) ;
							}
						}
						
						VariantClear ( & t_CimType ) ;
					}

					t_PropertyQualifierSet->Release () ;
				}
				
				VariantClear ( & t_Variant ) ;
				SysFreeString ( t_PropertyName ) ;
			}

			m_ProviderNotification->Indicate ( 1 , &t_CloneObject ) ;
			t_CloneObject->Release () ;
		}

		t_Index ++ ;
	}

	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\include\classfac.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMPPropProvClassFactory_H
#define _SNMPPropProvClassFactory_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for both types of providers.

class CProxyLocatorClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CProxyLocatorClassFactory () ;
    ~CProxyLocatorClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CProxyProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CProxyProvClassFactory () ;
    ~CProxyProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};
#endif // _SNMPProxyProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\proxyprovider\include\proxyprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: Sample Mini Server for Ole MS 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _ProxyProvider_H_
#define _ProxyProvider_H_

class SnmpDefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpDefaultThreadObject () {} ;
	~SnmpDefaultThreadObject () {} ;

	void Initialise () { CoInitialize ( NULL ) ; }
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpProxyProv : public IWbemServices
{
private:

	LONG m_referenceCount ;         //Object reference count

private:

	BOOL initialised ;
	IWbemServices *proxiedProvider ;
	IWbemServices *server ;
	IWbemServices *parentServer ;
	wchar_t *proxiedNamespaceString ;

	wchar_t *thisNamespace ;
	WbemNamespacePath namespacePath ;

 
private:

	void SetServer ( IWbemServices *serverArg ) ;
	void SetParentServer ( IWbemServices *parentServerArg ) ;

	BOOL AttachServer (

		WbemSnmpErrorObject &a_errorObject ,
		BSTR ObjectPath, 
		long lFlags, 
		IWbemServices FAR* FAR* ppNewContext, 
		IWbemCallResult FAR* FAR* ppErrorObject
	) ;

	BOOL AttachParentServer ( 

		WbemSnmpErrorObject &a_errorObject ,
		BSTR ObjectPath, 
		long lFlags, 
		IWbemServices FAR* FAR* ppNewContext, 
		IWbemCallResult FAR* FAR* ppErrorObject
	) ;

	BOOL AttachProxyProvider ( 

		WbemSnmpErrorObject &a_errorObject ,
		BSTR ObjectPath, 
		long lFlags, 
		IWbemServices FAR* FAR* ppNewContext, 
		IWbemCallResult FAR* FAR* ppErrorObject
	) ;

	BOOL ObtainProxiedNamespace ( WbemSnmpErrorObject &a_errorObject ) ;

protected:

public:

	CImpProxyProv () ;
    ~CImpProxyProv () ;

	void SetProvider ( IWbemServices *provider ) ;
	IWbemServices *GetParentServer () ;
	IWbemServices *GetServer () ;
	WbemNamespacePath *GetNamespacePath () { return & namespacePath ; }
	wchar_t *GetThisNamespace () ;
	void SetThisNamespace ( wchar_t *thisNamespaceArg ) ;
	wchar_t *GetProxiedNamespaceString () { return proxiedNamespaceString ; }

public:

	static SnmpDefaultThreadObject *s_defaultThreadObject ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

public:

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        

} ;

///////////////////////////////////////////////////////////////////
// This class is used to enumerate instances

class CEnumInst : public IEnumWbemClassObject
{
private:

	ULONG m_referenceCount ;

protected:
public:

    CEnumInst (

		HANDLE hContext  ,
		WCHAR * pClass  ,
		IWbemServices FAR* pWbemGateway  ,
		CImpProxyProv *pProvider
	) ;

	~CEnumInst () ;

  // IUnknown members

	STDMETHODIMP QueryInterface ( REFIID  , LPVOID FAR * ) ;
	STDMETHODIMP_( ULONG ) AddRef () ;
	STDMETHODIMP_( ULONG ) Release () ;
      
  // IEnumWbemClassObject methods 

	STDMETHODIMP Reset () ;

	STDMETHODIMP Next (

		ULONG uCount  ,
		IWbemClassObject FAR* FAR* pProp  ,
		ULONG FAR* puReturned
	) ;

	STDMETHODIMP Clone (

		IEnumWbemClassObject FAR* FAR* pEnum 
	) ;

	STDMETHODIMP Skip (

		ULONG nNum
	) ;

} ;

class CImpProxyLocator : public IWbemLocator
{
private:

	LONG m_referenceCount ;         //Object reference count

protected:
public:

	CImpProxyLocator () ;
    ~CImpProxyLocator () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemLocator methods */

    STDMETHODIMP ConnectServer ( 
		
		BSTR NetworkResource, 
		BSTR User, 
		BSTR Password, 
		BSTR lLocaleId, 
		long lFlags, 
		BSTR Authority,
		IWbemContext FAR *pCtx ,
		IWbemServices FAR* FAR* ppNamespace
	) ;

};

class Notification : public IWbemObjectSink
{
private:

	LONG m_ReferenceCount ;
	CImpProxyProv *m_Provider ;
	IWbemObjectSink *m_ProviderNotification ;

protected:
public:

	Notification ( CImpProxyProv *a_Provider , IWbemObjectSink *a_ProviderNotification ) ;
	virtual ~Notification () ;

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    STDMETHOD_(SCODE, Indicate)(THIS_ long lObjectCount, IWbemClassObject FAR* FAR* pObjArray) ;
    STDMETHOD_(SCODE, SetStatus)(THIS_ long lFlags,long lParam,BSTR strParam,IWbemClassObject __RPC_FAR *pObjParam) ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: OLE MS SNMP PROPERTY PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>

#include <objbase.h>

#include <wbemidl.h>
#include <instpath.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcont.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include "classfac.h"
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "guids.h"

LONG CTraceRouteLocatorClassFactory :: s_ObjectsInProgress = 0 ;
LONG CTraceRouteLocatorClassFactory :: s_LocksInProgress = 0 ;

LONG CTraceRouteProvClassFactory :: s_ObjectsInProgress = 0 ;
LONG CTraceRouteProvClassFactory :: s_LocksInProgress = 0 ;

//***************************************************************************
//
// CTraceRouteLocatorClassFactory::CTraceRouteLocatorClassFactory
// CTraceRouteLocatorClassFactory::~CTraceRouteLocatorClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CTraceRouteLocatorClassFactory :: CTraceRouteLocatorClassFactory ()
{
	m_ReferenceCount = 0 ;
}

CTraceRouteLocatorClassFactory::~CTraceRouteLocatorClassFactory ()
{
}

//***************************************************************************
//
// CTraceRouteLocatorClassFactory::QueryInterface
// CTraceRouteLocatorClassFactory::AddRef
// CTraceRouteLocatorClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CTraceRouteLocatorClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CTraceRouteLocatorClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CTraceRouteLocatorClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CTraceRouteLocatorClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CTraceRouteLocatorClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else 
	{
		IWbemLocator *lpunk = ( IWbemLocator * ) new CImpTraceRouteLocator ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

//***************************************************************************
//
// CTraceRouteLocatorClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CTraceRouteLocatorClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & s_LocksInProgress ) ;
	}

	return S_OK	;
}

//***************************************************************************
//
// CTraceRouteProvClassFactory::CTraceRouteProvClassFactory
// CTraceRouteProvClassFactory::~CTraceRouteProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CTraceRouteProvClassFactory :: CTraceRouteProvClassFactory ()
{
	m_ReferenceCount = 0 ;
}

CTraceRouteProvClassFactory::~CTraceRouteProvClassFactory ()
{
}

//***************************************************************************
//
// CTraceRouteProvClassFactory::QueryInterface
// CTraceRouteProvClassFactory::AddRef
// CTraceRouteProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CTraceRouteProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CTraceRouteProvClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CTraceRouteProvClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CTraceRouteProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CTraceRouteProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemServices *lpunk = ( IWbemServices * ) new CImpTraceRouteProv ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

//***************************************************************************
//
// CTraceRouteProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CTraceRouteProvClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & s_LocksInProgress ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks.  

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <process.h>
#include <objbase.h>
#include <olectl.h>
#include <wbemidl.h>
#include <instpath.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcont.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include "classfac.h"
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "guids.h"

//OK we need this one
HINSTANCE   g_hInst=NULL;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		DisableThreadLibraryCalls(hInstance);			// 158024 
		status = TRUE ;
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }

    return TRUE ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_CTraceRouteLocatorClassFactory ) 
	{
		CTraceRouteLocatorClassFactory *lpunk = new CTraceRouteLocatorClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_CTraceRouteProvClassFactory ) 
	{
		CTraceRouteProvClassFactory *lpunk = new CTraceRouteProvClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */

	BOOL unload = ( CTraceRouteLocatorClassFactory :: s_LocksInProgress || CTraceRouteLocatorClassFactory :: s_ObjectsInProgress ) ;
	unload = ! unload ;

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

//Strings used during self registeration

#define REG_FORMAT_STR			L"%s\\%s"
#define VER_IND_STR				L"VersionIndependentProgID"
#define NOT_INTERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define INPROC_STR				L"InprocServer"
#define PROGID_STR				L"ProgID"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"

#define CLSID_STR				L"CLSID\\"
#define CLSID2_STR				L"CLSID"
#define CVER_STR				L"CurVer"

#define LOCATOR_NAME_STR		L"Microsoft WBEM Trace Route Locator"
#define LOCATOR_STR				L"OLEMS.SNMP.PROPERTY.LOCATOR"
#define LOCATOR_VER_STR			L"OLEMS.SNMP.PROPERTY.LOCATOR.0"

#define PROVIDER_NAME_STR		L"Microsoft WBEM Trace Route Provider"
#define PROVIDER_STR			L"OLEMS.SNMP.PROPERTY.PROVIDER"
#define PROVIDER_VER_STR		L"OLEMS.SNMP.PROPERTY.PROVIDER.0"

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

    wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_CLASSES_ROOT
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI InstanceDllRegisterServer()
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szLocatorClassID[128];
	wchar_t szLocatorCLSIDClassID[128];

	int iRet = StringFromGUID2(CLSID_CTraceRouteLocatorClassFactory,szLocatorClassID, 128);

	wcscpy(szLocatorCLSIDClassID,CLSID_STR);
	wcscat(szLocatorCLSIDClassID,szLocatorClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, NULL, NULL, LOCATOR_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, PROGID_STR, NULL, LOCATOR_VER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, VER_IND_STR, NULL, LOCATOR_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szLocatorCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	iRet = StringFromGUID2(CLSID_CTraceRouteProvClassFactory,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}


STDAPI DllRegisterServer()
{
	return InstanceDllRegisterServer () ;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI InstanceDllUnregisterServer(void)
{
	wchar_t szTemp[128];

	wchar_t szLocatorClassID[128];
	wchar_t szLocatorCLSIDClassID[128];

	int iRet = StringFromGUID2(CLSID_CTraceRouteLocatorClassFactory,szLocatorClassID, 128);

	wcscpy(szLocatorCLSIDClassID,CLSID_STR);
	wcscat(szLocatorCLSIDClassID,szLocatorClassID);

	//Delete ProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, LOCATOR_STR);

	//Delete VersionIndependentProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, LOCATOR_VER_STR);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szLocatorCLSIDClassID, PROGID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szLocatorCLSIDClassID, VER_IND_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szLocatorCLSIDClassID, NOT_INTERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR,szLocatorCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szLocatorCLSIDClassID);

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	iRet = StringFromGUID2(CLSID_CTraceRouteProvClassFactory,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szLocatorClassID);

	//Delete ProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, PROVIDER_STR);

	//Delete VersionIndependentProgID keys

	RegDeleteKey(HKEY_CLASSES_ROOT, PROVIDER_VER_STR);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, PROGID_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, VER_IND_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INTERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	return InstanceDllUnregisterServer () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\rmon.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"


#define NUMBER_OF_RMON_INTERFACES	3

#define SYSTEM_INST				L"MS_SNMP_RFC1213_MIB_system=@"
#define SYS_DESCR_PROP			L"sysDescr"
#define SYS_DESCR_VAL			L"SuperStack II Enterprise Monitor - Multi (2.95)"
#define PROVTOPN_CLASS			L"MS_SNMP_RFC1271_MIB_ProvidedhostTopNTable"
#define TOPN_CLASS				L"MS_SNMP_RFC1271_MIB_hostTopNTable"
#define TOPNINDEX_PROP			L"hostTopNIndex"
#define TOPNREPORT_PROP			L"hostTopNReport"
#define TOPNADDRESS_PROP		L"hostTopNAddress"
#define TOPNRATE_PROP			L"hostTopNRate"
#define CONFIGPATH				L"RmonConfigClass = @"
#define FIRSTPOLL_PROP			L"FirstDataPollPeriodSecs"
#define DATAPOLL_PROP			L"DataPollPeriodSecs"
#define DATAOFFSET_PROP			L"GetDataOffsetTenthSecs"
#define RETRYPOLL_PROP			L"GetDataRetryTenthSecs"
#define SIZEN_PROP				L"TopNSize"
#define STATSTYPE_PROP			L"TopNStatisticType"
#define START_INDEX_PROP		L"startingIndex"
#define SETCONF_CLASS			L"MS_SNMP_RFC1271_MIB_hostTopNControlTableSetStatus"
#define CONF_CLASS				L"MS_SNMP_RFC1271_MIB_hostTopNControlTable"
#define DURATIONCONF_CLASS		L"MS_SNMP_RFC1271_MIB_hostTopNControlTableSetDuration"
#define CONFINDEX_PROP			L"hostTopNControlIndex"
#define CONFHOSTINDEX_PROP		L"hostTopNHostIndex"
#define CONFSTATUS_PROP			L"hostTopNStatus"
#define CONFDURATION_PROP		L"hostTopNTimeRemaining"
#define CONFOWNER_PROP			L"hostTopNOwner"
#define CONFRATE_PROP			L"hostTopNRateBase"
#define CONFSIZE_PROP			L"hostTopNRequestedSize"
#define CRQ_CONFSTATUS_PROP_VAL	L"createRequest"
#define VAL_CONFSTATUS_PROP_VAL	L"valid"
#define DEL_CONFSTATUS_PROP_VAL	L"invalid"
#define CONFOWNER_PROP_VAL		L"Steve & Nadir's Demonstration"
#define HOST_CLASS				L"MS_SNMP_RFC1271_MIB_hostTable"
#define HOSTINDEX_PROP			L"hostIndex"
#define HOSTADDRESS_PROP		L"hostAddress"
#define HOSTINOCT_PROP			L"hostInOctets"
#define HOSTINPKT_PROP			L"hostInPkts"
#define HOSTOUTBCAST_PROP		L"hostOutBroadcastPkts"
#define HOSTOUTERROR_PROP		L"hostOutErrors"
#define HOSTOUTMCAST_PROP		L"hostOutMulticastPkts"
#define HOSTOUTOCT_PROP			L"hostOutOctets"
#define HOSTOUTPKT_PROP			L"hostOutPkts"
#define DOT_CHAR				L'.'
#define EQUALS_CHAR				L'='
#define QUOTE_CHAR				L'\"'
#define COMMA_CHAR				L','


RmonConfigData::RmonConfigData(const ULONG poll, const ULONG firstpoll, const ULONG data,
					const ULONG dataretry, const ULONG size, BSTR stats, const ULONG index)
{
	SetPollPeriod(poll);
	SetInitialPeriod(firstpoll);
	SetDataOffset(data);
	SetDataRetry(dataretry);
	SetNSize(size);
	SetIndex(index);
	m_statstype = stats;
}

void RmonConfigData::SetStatsType(BSTR val)
{
	if (NULL != m_statstype)
	{
		SysFreeString(m_statstype);
	}
	
	m_statstype = val;
}


ULONG TopNTableStore::GetKey(IWbemClassObject *obj)
{
	ULONG ret = 0;

	VARIANT v;

	BSTR propstr =  SysAllocString(TOPNREPORT_PROP);

	if (NULL != propstr)
	{
		HRESULT result = obj->Get(propstr, 0, &v, NULL, NULL);
		SysFreeString(propstr);

		if ((WBEM_NO_ERROR == result) && (VT_I4 == v.vt))
		{
			propstr =  SysAllocString(TOPNINDEX_PROP);

			if (NULL != propstr)
			{
				ULONG topNr = v.lVal;
				result = obj->Get(propstr, 0, &v, NULL, NULL);
				SysFreeString(propstr);

				if((WBEM_NO_ERROR == result) && (VT_I4 == v.vt))
				{
					ret = GetKey(topNr, v.lVal);
				}
				else if (WBEM_NO_ERROR == result)
				{
					VariantClear(&v);
				}
			}
		}
		else if (WBEM_NO_ERROR == result)
		{
			VariantClear(&v);
		}
	}

	return ret;
}

ULONG TopNTableStore::GetKey(ULONG topNReport, ULONG topNIndex)
{
	return ( (topNReport << 16) | (topNIndex & 65535) );
}


BOOL TopNTableProv::InitializeRmon()
{
	BOOL ret = FALSE;

	if (!GetRmonConfData())
	{
		//set error object
	}
	else
	{
		if (!DeleteRmonConfiguration())
		{
			//set error object?? or write a message somewhere??
		}

		LONG status = SetRmonConfiguration();

		if (status != 0) //at least one subnet being monitored
		{
			if (status == -1)
			{
				//not all subnets being monitored
			}

			ret = TRUE;
		}
	}

	return ret;
}


BOOL TopNTableProv::GetWBEMEnumerator(IEnumWbemClassObject **ppEnum, wchar_t *strclass)
{
	BOOL ret = FALSE;

	HRESULT result = m_wbemServ->CreateInstanceEnum(strclass, 0, NULL, ppEnum);

	if ( (WBEM_NO_ERROR == result) && (WBEM_NO_ERROR == (*ppEnum)->Reset()) )
	{
		ret = TRUE;
	}

	return ret;
}


void TopNTableProv::Poll()
{
	BOOL retry = FALSE;
	IEnumWbemClassObject* pEnum;

	if (GetWBEMEnumerator(&pEnum, TOPN_CLASS))
	{
		ULONG returned;
		IWbemClassObject* pObj;
		HRESULT result = pEnum->Next(-1,1, &pObj, &returned);
		
		if (WBEM_NO_ERROR != result)
		{
			pEnum->Release();
			pEnum = NULL;
			retry = TRUE;
		}
		else
		{
			GetData(pEnum, pObj);
		}
	}
	else
	{
		retry = TRUE;
	}

	if (retry)
	{
		m_Status = RETRY_ENUM_STATUS;
		m_Strobing = TRUE;
	}
}

void TopNTableProv::RetryPoll()
{

	BOOL reset = FALSE;
	IEnumWbemClassObject* pEnum;

	if (GetWBEMEnumerator(&pEnum, TOPN_CLASS))
	{
		ULONG returned;
		IWbemClassObject* pObj;
		HRESULT result = pEnum->Next(-1,1, &pObj, &returned);

		if (WBEM_NO_ERROR != result)
		{
			pEnum->Release();
			pEnum = NULL;
			reset = TRUE;
		}
		else
		{
			GetData(pEnum, pObj);
		}
	}
	else
	{
		reset = TRUE;
	}

	if (reset)
	{
		m_CacheAge++;

		if (NULL != m_FirstTimeWait)
		{
			m_FirstTimeWait->Set();
		}
		
		ResetRmonDuration();
		m_Status = POLL_ENUM_STATUS;
		m_Strobing = TRUE;
	}
}


BOOL TopNTableProv::CopyEntry(IWbemClassObject** pDest, IWbemClassObject* pSource)
{
	VARIANT v;
	ULONG topNReport = 0;

	if (*pDest == NULL)
	{
		//create the class as pDest and add the two indices..., 
		if (WBEM_NO_ERROR != m_pObjProv->SpawnInstance(0, pDest))
		{
			return FALSE;
		}
		else
		{
			if (!GetWBEMProperty(pSource, v, TOPNREPORT_PROP))
			{
				return FALSE;
			}

			//only want results for entries we configured
			if ( (v.vt == VT_I4) &&
				 (v.lVal < (m_Confdata.GetIndex() + NUMBER_OF_RMON_INTERFACES)) &&
				 (v.lVal >= m_Confdata.GetIndex()) )
			{
				if (!PutWBEMProperty(*pDest, v, TOPNREPORT_PROP))
				{
					VariantClear(&v);
					return FALSE;
				}
				else
				{
					topNReport = v.lVal;
				}
				
				VariantClear(&v);
			}
			else
			{
				VariantClear(&v);
				return FALSE;
			}

			if (!GetWBEMProperty(pSource, v, TOPNINDEX_PROP))
			{
				return FALSE;
			}

			if ((v.vt != VT_I4) ||!PutWBEMProperty(*pDest, v, TOPNINDEX_PROP))
			{
				VariantClear(&v);
				return FALSE;
			}
			
			VariantClear(&v);
		}
	}

	//set the remaining properties from the TopNTable instance...
	if (!GetWBEMProperty(pSource, v, TOPNRATE_PROP))
	{
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(*pDest, v, TOPNRATE_PROP))
	{
		VariantClear(&v);
		return FALSE;
	}

	VariantClear(&v);

	if (!GetWBEMProperty(pSource, v, TOPNADDRESS_PROP))
	{
		return FALSE;
	}

	if ((v.vt != VT_BSTR) || !PutWBEMProperty(*pDest, v, TOPNADDRESS_PROP))
	{
		VariantClear(&v);
		return FALSE;
	}

	CString addrstr(v.bstrVal);
	VariantClear(&v);

	if (0 == topNReport) //only set if we spawned instance in this call
	{
		if (!GetWBEMProperty(pSource, v, TOPNREPORT_PROP))
		{
			return FALSE;
		}
		else 
		{
			if (v.vt != VT_I4)
			{
				VariantClear(&v);
				return FALSE;
			}
			else
			{
				topNReport = v.lVal;
			}
			
			VariantClear(&v);
		}
	}

	return AddHostProperties(*pDest, topNReport, addrstr);
}


void TopNTableProv::GetData(IEnumWbemClassObject* pEnum, IWbemClassObject* psrcObj)
{
	m_CacheAge = 0;
	BOOL LoopOn = TRUE; 
	TopNCache *t_NoLockedStore = new TopNCache ;

	m_CachedResults.Lock();

	POSITION pos = m_CachedResults.m_pTopNCache->GetStartPosition();
	while (NULL != pos)
	{
		IWbemClassObject *pObj;
		ULONG keyval;
		m_CachedResults.m_pTopNCache->GetNextAssoc(pos, keyval, pObj);

		IWbemClassObject *t_Clone = NULL ;
		HRESULT t_Result = pObj->Clone ( &t_Clone ) ;
		t_NoLockedStore->SetAt ( keyval , t_Clone ) ;
	}

	m_CachedResults.Unlock () ;

	TopNCache* tmpStore = new TopNCache;

	while (LoopOn)
	{
		//copy pObj over to the store...
		ULONG keyval = TopNTableStore::GetKey(psrcObj);

		if (0 != keyval)
		{
			IWbemClassObject *pObj;

			if (t_NoLockedStore->Lookup(keyval, pObj))
			{
				t_NoLockedStore->RemoveKey(keyval);
			}
			else
			{
				pObj = NULL;
			}

			if (CopyEntry(&pObj, psrcObj))
			{
				tmpStore->SetAt(keyval, pObj);
			}
			else
			{
				if (pObj != NULL)
				{
					pObj->Release();
				}
			}
		}

		psrcObj->Release();	
		psrcObj = NULL;
		ULONG returned;
		HRESULT result = pEnum->Next(-1,1, &psrcObj, &returned);
		LoopOn = (WBEM_NO_ERROR == result);
	}

	pEnum->Release();

	pos = t_NoLockedStore->GetStartPosition();
	while (NULL != pos)
	{
		IWbemClassObject *pObj;
		ULONG keyval;
		t_NoLockedStore->GetNextAssoc(pos, keyval, pObj);
		pObj->Release();
	}

	t_NoLockedStore->RemoveAll();
	delete t_NoLockedStore ;

	m_CachedResults.Lock () ;

	pos = m_CachedResults.m_pTopNCache->GetStartPosition();
	while (NULL != pos)
	{
		IWbemClassObject *pObj;
		ULONG keyval;
		m_CachedResults.m_pTopNCache->GetNextAssoc(pos, keyval, pObj);
		pObj->Release();
	}

	m_CachedResults.m_pTopNCache->RemoveAll () ;
	delete m_CachedResults.m_pTopNCache ;

	m_CachedResults.m_pTopNCache = tmpStore;

	m_CachedResults.Unlock();

	if (NULL != m_FirstTimeWait)
	{
		m_FirstTimeWait->Set();
	}

	ResetRmonDuration();
	m_Status = POLL_ENUM_STATUS;
	m_Strobing = TRUE;
}


BOOL TopNTableProv::DeleteRmonConfiguration()
{
	BOOL ret = FALSE;
	BSTR classstr = SysAllocString(SETCONF_CLASS);
	BSTR propstr = SysAllocString(CONFSTATUS_PROP);
	VARIANT v;
	VariantInit(&v);
	v.vt = VT_BSTR;
	v.bstrVal = SysAllocString(DEL_CONFSTATUS_PROP_VAL);

	if ((NULL != classstr) && (NULL != propstr) && (NULL != v.bstrVal))
	{
		IEnumWbemClassObject *pEnum;
		HRESULT result = m_wbemServ->CreateInstanceEnum(classstr, 0, NULL, &pEnum);
		SysFreeString(classstr);

		if ( (WBEM_NO_ERROR == result) && (WBEM_NO_ERROR == pEnum->Reset()) )
		{
			ret = TRUE;
			ULONG returned;
			IWbemClassObject* pObj =  NULL;

			result = pEnum->Next(-1,1, &pObj, &returned);

			while ( (WBEM_NO_ERROR == result) && (1 == returned) )
			{
				VARIANT vIndex;
				
				if (GetWBEMProperty(pObj, vIndex, CONFINDEX_PROP))
				{
					if (VT_I4 == vIndex.vt)
					{
						if ( (vIndex.lVal < (m_Confdata.GetIndex() + NUMBER_OF_RMON_INTERFACES))
							&& (vIndex.lVal >= m_Confdata.GetIndex()) )
						{
							if (WBEM_NO_ERROR == pObj->Put(propstr, 0, &v, 0))
							{
								if (WBEM_NO_ERROR != m_wbemServ->PutInstance(pObj, 0, NULL,NULL))
								{
									ret = FALSE;
								}
							}
							else
							{
								ret = FALSE;
							}
						}
					}
					else
					{
						VariantClear(&vIndex);
						ret =  FALSE;
					}
				}
				else
				{
					ret = FALSE;
				}

				pObj->Release();	
				pObj = NULL;
				result = pEnum->Next(-1,1, &pObj, &returned);
			}

			pEnum->Release();
		}

		SysFreeString(propstr);
		VariantClear(&v);
	}

	return ret;
}


LONG TopNTableProv::SetRmonConfiguration()
{
	LONG ret = 0;
	BSTR classstr = SysAllocString(CONF_CLASS);

	if (NULL != classstr)
	{
		IWbemClassObject* pClass = NULL;
		HRESULT result = m_wbemServ->GetObject(classstr, 0, NULL, &pClass, NULL);
		SysFreeString(classstr);

		if (WBEM_NO_ERROR == result)
		{
			IWbemClassObject* pInst = NULL;

			if (WBEM_NO_ERROR == pClass->SpawnInstance(0, &pInst))
			{
				VARIANT v;
				VariantInit(&v);
				v.vt = VT_BSTR;
				v.bstrVal = m_Confdata.GetStatsType();
				
				if (!PutWBEMProperty(pInst, v, CONFRATE_PROP))
				{
					pInst->Release();
					return 0;
				}

				v.bstrVal = SysAllocString(CONFOWNER_PROP_VAL);

				if ((NULL == v.bstrVal) || !PutWBEMProperty(pInst, v, CONFOWNER_PROP))
				{
					pInst->Release();
					SysFreeString(v.bstrVal);
					return 0;
				}
				
				SysFreeString(v.bstrVal);
				v.vt = VT_I4;
				v.lVal = m_Confdata.GetInitialPeriodSecs();
				
				if (!PutWBEMProperty(pInst, v, CONFDURATION_PROP))
				{
					pInst->Release();
					return 0;
				}

				v.lVal = m_Confdata.GetNSize();
				
				if (!PutWBEMProperty(pInst, v, CONFSIZE_PROP))
				{
					pInst->Release();
					return 0;
				}

				UINT count = m_Confdata.GetIndex() + NUMBER_OF_RMON_INTERFACES;
				UINT done = 1;

				VARIANT vValidstatus;
				VariantInit(&vValidstatus);
				vValidstatus.vt = VT_BSTR;
				vValidstatus.bstrVal = SysAllocString(VAL_CONFSTATUS_PROP_VAL);
				VARIANT vCreatestatus;
				VariantInit(&vCreatestatus);
				vCreatestatus.vt = VT_BSTR;
				vCreatestatus.bstrVal = SysAllocString(CRQ_CONFSTATUS_PROP_VAL);

				if ((NULL == vCreatestatus.bstrVal) || (NULL == vValidstatus.bstrVal))
				{
					pInst->Release();
					return 0;
				}

				ULONG y = 1;

				for (UINT x = m_Confdata.GetIndex(); x < count; x++)
				{
					v.lVal = x;
					
					if (!PutWBEMProperty(pInst, v, CONFINDEX_PROP))
					{
						continue;
					}

					v.lVal = y++;

					if (!PutWBEMProperty(pInst, v, CONFHOSTINDEX_PROP))
					{
						continue;
					}

					if (!PutWBEMProperty(pInst, vCreatestatus, CONFSTATUS_PROP))
					{
						continue;
					}


					if (WBEM_NO_ERROR == m_wbemServ->PutInstance(pInst, 0, NULL, NULL))
					{
						if (PutWBEMProperty(pInst, vValidstatus, CONFSTATUS_PROP))
						{
							if (WBEM_NO_ERROR == m_wbemServ->PutInstance(pInst, 0, NULL, NULL))
							{						
								done++;
							}
						}

						VariantClear(&v);
						v.vt = VT_I4;
					}
				}
				
				VariantClear(&vValidstatus);
				VariantClear(&vCreatestatus);

				if (done == count)
				{
					ret = 1;
				}
				else if (done > 1)
				{
					ret = -1;
				}
				
				pInst->Release();
			}
		}
	}

	return ret;
}


BOOL TopNTableProv::GetRmonConfData()
{
	BSTR inststr = SysAllocString(CONFIGPATH);
	BOOL ret = FALSE;

	if (NULL != inststr)
	{
		IWbemClassObject *pConfInst;
		HRESULT result = m_wbemServ->GetObject(inststr, 0, NULL, &pConfInst, NULL);
		SysFreeString(inststr);

		if (WBEM_NO_ERROR == result)
		{
			VARIANT v;

			if (GetWBEMProperty(pConfInst, v, DATAPOLL_PROP))
			{
				if (VT_I4 == v.vt)
				{
					m_Confdata.SetPollPeriod(v.lVal);
					
					if (GetWBEMProperty(pConfInst, v, FIRSTPOLL_PROP))
					{
						if (VT_I4 == v.vt)
						{
							m_Confdata.SetInitialPeriod(v.lVal);

							if (GetWBEMProperty(pConfInst, v, DATAOFFSET_PROP))
							{
								if (VT_I4 == v.vt)
								{
									m_Confdata.SetDataOffset(v.lVal);

									if (GetWBEMProperty(pConfInst, v, DATAOFFSET_PROP))
									{
										if (VT_I4 == v.vt)
										{
											m_Confdata.SetDataOffset(v.lVal);

											if (GetWBEMProperty(pConfInst, v, RETRYPOLL_PROP))
											{
												if (VT_I4 == v.vt)
												{
													m_Confdata.SetDataRetry(v.lVal);

													if (GetWBEMProperty(pConfInst, v, SIZEN_PROP))
													{
														if (VT_I4 == v.vt)
														{
															m_Confdata.SetNSize(v.lVal);

															if (GetWBEMProperty(pConfInst, v, STATSTYPE_PROP))
															{
																if (VT_BSTR == v.vt)
																{
																	m_Confdata.SetStatsType(v.bstrVal);

																	if (GetWBEMProperty(pConfInst, v, START_INDEX_PROP))
																	{
																		if (VT_I4 == v.vt)
																		{
																			m_Confdata.SetIndex(v.lVal);
																			ret = TRUE;
																		}
																		else
																		{
																			VariantClear(&v);
																		}
																	}
																}
																else
																{
																	VariantClear(&v);
																}
															}
														}
														else
														{
															VariantClear(&v);
														}
													}
												}
												else
												{
													VariantClear(&v);
												}
											}
										}
										else
										{
											VariantClear(&v);
										}
									}
								}
								else
								{
									VariantClear(&v);
								}
							}
						}
						else
						{
							VariantClear(&v);
						}
					}
				}
				else
				{
					VariantClear(&v);
				}
			}

			pConfInst->Release();
		}
	}

	return ret;
}

BOOL TopNTableProv::GetWBEMProperty(IWbemClassObject* obj, VARIANT& val, wchar_t* prop)
{
	return (WBEM_NO_ERROR == obj->Get(prop, 0, &val, NULL, NULL));
}

BOOL TopNTableProv::PutWBEMProperty(IWbemClassObject* obj, VARIANT& val, wchar_t* prop)
{
	return (WBEM_NO_ERROR == obj->Put(prop, 0, &val, 0));
}

TopNTableProv::TopNTableProv(IWbemServices*	wbemServ, ProviderStore& timer)
{
	m_CacheAge = 0;
	m_IsValid = FALSE;
	m_wbemServ = wbemServ;
	m_Status = CREATE_ENUM_STATUS;
	m_timer = &timer;
	m_Strobing = FALSE;
	m_StrobeCount = 0;
	m_FirstTimeWait = NULL;


	if (NULL == m_wbemServ)
	{
		return;
	}
	else
	{
		m_wbemServ->AddRef();
	}

	BSTR class_str = SysAllocString(PROVTOPN_CLASS);

	if (NULL != class_str)
	{
		m_pObjProv = NULL;
		HRESULT result = m_wbemServ->GetObject(class_str, 0, NULL, &m_pObjProv, NULL);
		SysFreeString(class_str);

		if (WBEM_NO_ERROR != result)
		{
			m_pObjProv = NULL;
		}
		else
		{
			if (InitializeRmon())
			{
				if (m_timer->RegisterProviderWithTimer(this))
				{
					m_FirstTimeWait = new SnmpEventObject;
					m_IsValid = TRUE;
					m_Strobing = TRUE;
				}
			}
		}
	}
	else
	{
		m_pObjProv = NULL;
	}
}

TopNTableProv::~TopNTableProv()
{
	if (m_IsValid)
	{
		m_timer->UnregisterProviderWithTimer(this);
	}

	if (NULL != m_pObjProv)
	{
		m_pObjProv->Release();
	}

	
	if (NULL != m_FirstTimeWait)
	{
		delete m_FirstTimeWait;
	}

	if (NULL != m_wbemServ)
	{
		m_wbemServ->Release();
	}

	m_CachedResults.Lock () ;
	POSITION pos = m_CachedResults.m_pTopNCache->GetStartPosition();

	while (NULL != pos)
	{
		IWbemClassObject *pObj;
		ULONG keyval;
		m_CachedResults.m_pTopNCache->GetNextAssoc(pos, keyval, pObj);
		pObj->Release();
	}

	m_CachedResults.m_pTopNCache->RemoveAll () ;
	m_CachedResults.Unlock () ;
}


void TopNTableProv::Strobe()
{
	if (m_Strobing)
	{
		m_StrobeCount++;

		switch (m_Status)
		{
			case CREATE_ENUM_STATUS:
			{
				if (m_StrobeCount ==
					((m_Confdata.GetInitialPeriod() + m_Confdata.GetDataOffset()) / WINDOW_TIMER_STROBE_PERIOD))
				{
					m_Strobing = FALSE;
					m_StrobeCount = 0;
					Poll();
				}
			}
			break;

			case POLL_ENUM_STATUS:
			{
				if (m_StrobeCount == 
					((m_Confdata.GetPollPeriod() + m_Confdata.GetDataOffset()) / WINDOW_TIMER_STROBE_PERIOD))
				{
					m_Strobing = FALSE;
					m_StrobeCount = 0;
					Poll();
				}
			}
			break;

			case RETRY_ENUM_STATUS:
			{
				if (m_StrobeCount == (m_Confdata.GetDataRetry() / WINDOW_TIMER_STROBE_PERIOD))
				{
					m_Strobing = FALSE;
					m_StrobeCount = 0;
					RetryPoll();
				}
			}
			break;
		}
	}
}

TopNCache *TopNTableProv::LockTopNCache ()
{
	TopNCache *t_TopNCache = NULL ;

	if (NULL != m_FirstTimeWait)
	{
		//wait twice the maximum initial time length or at least ten seconds...
		DWORD timeout = ( m_Confdata.GetInitialPeriod() 
							+ m_Confdata.GetDataOffset()
							+ m_Confdata.GetDataRetry() ) * 2;
		
		if (timeout < 10000)
		{
			timeout = 10000;
		}

		WaitForSingleObject(m_FirstTimeWait->GetHandle(), timeout);
		delete m_FirstTimeWait;
		m_FirstTimeWait = NULL;
	}

	if ( m_CachedResults.Lock () )
	{
		return m_CachedResults.m_pTopNCache ;
	}
	else
	{
	}

	return t_TopNCache ;
}

void TopNTableProv::UnlockTopNCache ()
{
	m_CachedResults.Unlock () ;
}


void TopNTableProv::ResetRmonDuration()
{
	BOOL ret = FALSE;

	IEnumWbemClassObject *pEnum;
	HRESULT result = m_wbemServ->CreateInstanceEnum(DURATIONCONF_CLASS, 0, NULL,&pEnum);

	if ( (WBEM_NO_ERROR == result) && (WBEM_NO_ERROR == pEnum->Reset()) )
	{
		ret = TRUE;
		ULONG returned;
		IWbemClassObject* pObj =  NULL;
		VARIANT v;
		VariantInit(&v);
		v.vt = VT_I4;
		v.lVal = m_Confdata.GetPollPeriodSecs();

		result = pEnum->Next(-1,1, &pObj, &returned);

		while ( (WBEM_NO_ERROR == result) && (1 == returned) )
		{
			VARIANT vIndex;
			
			if (GetWBEMProperty(pObj, vIndex, CONFINDEX_PROP))
			{
				if (VT_I4 == vIndex.vt)
				{
					if ( (vIndex.lVal < (m_Confdata.GetIndex() + NUMBER_OF_RMON_INTERFACES))
						&& (vIndex.lVal >= m_Confdata.GetIndex()) )
					{
						if (WBEM_NO_ERROR == pObj->Put(CONFDURATION_PROP, 0, &v, 0))
						{
							if (WBEM_NO_ERROR != m_wbemServ->PutInstance(pObj, 0, NULL,NULL))
							{
								ret = FALSE;
							}
						}
						else
						{
							ret = FALSE;
						}
					}
				}
				else
				{
					VariantClear(&vIndex);
					ret =  FALSE;
				}
			}
			else
			{
				ret = FALSE;
			}

			pObj->Release();	
			pObj = NULL;
			result = pEnum->Next(-1,1, &pObj, &returned);
		}

		VariantClear(&v);
		pEnum->Release();
	}

	//return ret;
}


BOOL TopNTableProv::AddHostProperties(IWbemClassObject* pDest, ULONG topNR, const CString& addrStr)
{
	BOOL ret = FALSE;

	//first get the config instance...
	//build the path...
	wchar_t buff[128]; //should be way big enough
	wsprintf(buff, L"%s%lc%s%lc%lu", CONF_CLASS, DOT_CHAR, CONFINDEX_PROP,EQUALS_CHAR, topNR);
	IWbemClassObject *pConfInst;
	HRESULT result = m_wbemServ->GetObject(buff, 0, NULL,&pConfInst, NULL);

	if (WBEM_NO_ERROR != result)
	{
		return FALSE;
	}

	VARIANT v;

	if (!GetWBEMProperty(pConfInst, v, CONFHOSTINDEX_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	pConfInst->Release();

	if (v.vt != VT_I4)
	{
		VariantClear(&v);
		return FALSE;
	}

	//now get the hostTable entry...
	//build the path again...
	wsprintf(buff, L"%s%lc%s%lc%lc%s%lc%lc%s%lc%lu", HOST_CLASS, DOT_CHAR, HOSTADDRESS_PROP,
						EQUALS_CHAR, QUOTE_CHAR, addrStr, QUOTE_CHAR,
						COMMA_CHAR, HOSTINDEX_PROP, EQUALS_CHAR, v.lVal);

	result = m_wbemServ->GetObject(buff, 0, NULL,&pConfInst, NULL);

	if (WBEM_NO_ERROR != result)
	{
		return FALSE;
	}

	//now copy all the properties...
	if (!PutWBEMProperty(pDest, v, HOSTINDEX_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}
	
	VariantClear(&v);
	
	if (!GetWBEMProperty(pConfInst, v, HOSTOUTPKT_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(pDest, v, HOSTOUTPKT_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}

	VariantClear(&v);

	if (!GetWBEMProperty(pConfInst, v, HOSTOUTOCT_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(pDest, v, HOSTOUTOCT_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}

	VariantClear(&v);

	if (!GetWBEMProperty(pConfInst, v, HOSTOUTMCAST_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(pDest, v, HOSTOUTMCAST_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}

	VariantClear(&v);

	if (!GetWBEMProperty(pConfInst, v, HOSTOUTERROR_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(pDest, v, HOSTOUTERROR_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}

	VariantClear(&v);

	if (!GetWBEMProperty(pConfInst, v, HOSTOUTBCAST_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(pDest, v, HOSTOUTBCAST_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}

	VariantClear(&v);

	if (!GetWBEMProperty(pConfInst, v, HOSTINOCT_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(pDest, v, HOSTINOCT_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}

	VariantClear(&v);

	if (!GetWBEMProperty(pConfInst, v, HOSTINPKT_PROP))
	{
		pConfInst->Release();
		return FALSE;
	}

	if ((v.vt != VT_I4) || !PutWBEMProperty(pDest, v, HOSTINPKT_PROP))
	{
		VariantClear(&v);
		pConfInst->Release();
		return FALSE;
	}

	VariantClear(&v);

	//succeeded in getting and setting all properties!
	pConfInst->Release();
	ret = TRUE;
	
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrtclas.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL CreateClassEnumAsyncEventObject :: Instantiate ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_SuperClass ) ;
	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

CreateClassEnumAsyncEventObject :: CreateClassEnumAsyncEventObject (

	CImpTraceRouteProv *a_Provider , 
	BSTR a_SuperClass ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Context

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag )
{
	m_SuperClass = UnicodeStringDuplicate ( a_SuperClass ) ;
}

CreateClassEnumAsyncEventObject :: ~CreateClassEnumAsyncEventObject () 
{
// Get Status object

	delete [] m_SuperClass ;

	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->Indicate ( 1 , & t_NotifyStatus ) ;
		t_NotifyStatus->Release () ;
	}
}

void CreateClassEnumAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	if ( CImpTraceRouteProv:: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv:: s_BackupThreadObject->ReapTask ( *this ) ;
	}
	else
	{
		CImpTraceRouteProv:: s_DefaultThreadObject->ReapTask ( *this ) ;
	}

	delete this ;
}

void CreateClassEnumAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			BOOL t_Status = Instantiate ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrt.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"
#include "guids.h"

SnmpMap <wchar_t *,wchar_t *,IWbemServices *,IWbemServices *> WbemTaskObject :: s_ConnectionPool ;

SnmpMap <wchar_t *,wchar_t *,wchar_t *,wchar_t *> WbemTaskObject :: s_AddressPool ;
SnmpMap <wchar_t *,wchar_t *,wchar_t *,wchar_t *> WbemTaskObject :: s_NamePool ;
SnmpMap <wchar_t *,wchar_t *,wchar_t *,wchar_t *> WbemTaskObject :: s_QualifiedNamePool ;

BOOL WbemTaskObject :: GetProxy ( WbemSnmpErrorObject &a_ErrorObject , IWbemServices *a_RootService , wchar_t *a_Proxy , IWbemServices **a_ProxyService )
{
	BOOL t_Status = TRUE ;

	if ( a_ProxyService )
	{
		*a_ProxyService = NULL ;
		IWbemServices *t_Service = NULL ;
		if ( ! s_ConnectionPool.Lookup ( a_Proxy , t_Service ) )
		{
			IWbemCallResult *t_ErrorObject = NULL ;

			HRESULT t_Result = a_RootService->OpenNamespace (

				a_Proxy ,
				0 ,
				NULL,
				( IWbemServices ** ) & t_Service ,
				&t_ErrorObject 
			) ;

			if ( t_Result == WBEM_NO_ERROR )
			{
				IWbemConfigure* t_Configure;
				t_Result = t_Service->QueryInterface ( IID_IWbemConfigure , ( void ** ) & t_Configure ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Configure->SetConfigurationFlags(WBEM_CONFIGURATION_FLAG_CRITICAL_USER);
					t_Configure->Release();

					s_ConnectionPool [ UnicodeStringDuplicate ( a_Proxy ) ] = t_Service ;
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}

		if ( t_Service )
		{
			t_Service->AddRef () ;
			*a_ProxyService = t_Service ;
		}

	}

	return t_Status ;
}

WbemTaskObject :: WbemTaskObject (

	CImpTraceRouteProv *a_Provider ,
	IWbemObjectSink *a_NotificationHandler ,
	ULONG a_OperationFlag 

) :	m_State ( WBEM_TASKSTATE_START ) ,
	m_OperationFlag ( a_OperationFlag ) ,
	m_Provider ( a_Provider ) ,
	m_NotificationHandler ( a_NotificationHandler ) ,
	m_Context ( 0 ) ,
	m_ClassObject ( NULL ) 
{
	m_Provider->AddRef () ;
	m_NotificationHandler->AddRef () ;
}

WbemTaskObject :: ~WbemTaskObject ()
{
	m_Provider->Release () ;
	m_NotificationHandler->Release () ;

	if ( m_Context )
		m_Context->Release () ;

	if ( m_ClassObject )
		m_ClassObject->Release () ;
}

ULONG WbemTaskObject :: GetState ()
{
	return m_State ;
}

void WbemTaskObject :: SetState ( ULONG a_State ) 
{
	m_State = a_State ;
}

WbemSnmpErrorObject &WbemTaskObject :: GetErrorObject ()
{
	return m_ErrorObject ; 
}	

BOOL WbemTaskObject :: GetClassObject ( wchar_t *a_Class )
{
	if ( m_ClassObject )
		m_ClassObject->Release () ;

	IWbemCallResult *t_ErrorObject = NULL ;

	IWbemServices *t_Server = m_Provider->GetServer() ;

	HRESULT t_Result = t_Server->GetObject (

		a_Class ,
		0 ,
		NULL,
		& m_ClassObject ,
		& t_ErrorObject 
	) ;

	t_Server->Release () ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	return SUCCEEDED ( t_Result ) ;
}


BOOL WbemTaskObject :: GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;
	IWbemCallResult *t_ErrorObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemSnmpErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetExtendedNotificationObject ( t_ErrorStatusObject ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
			VariantClear ( &t_Variant ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = m_ErrorObject.GetStatus () ;

				t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( m_ErrorObject.GetMessage () ) 
					{
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

						t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
						VariantClear ( &t_Variant ) ;

						if ( ! SUCCEEDED ( t_Result ) )
						{
							(*a_NotifyObject)->Release () ;
							t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
						}
					}
				}
				else
				{
					(*a_NotifyObject)->Release () ;
					t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
			}

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
		}
	}
	else
	{
		t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
	}

	return t_Status ;
}

BOOL WbemTaskObject :: GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemSnmpErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetNotificationObject ( t_ErrorStatusObject ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_ErrorObject.GetMessage () ) 
				{
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

					t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
					VariantClear ( &t_Variant ) ;

					if ( ! SUCCEEDED ( t_Result ) )
					{
						t_Status = FALSE ;
						(*a_NotifyObject)->Release () ;
						(*a_NotifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				(*a_NotifyObject)=NULL ;
				t_Status = FALSE ;
			}

			VariantClear ( &t_Variant ) ;

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

wchar_t *WbemTaskObject :: GetHostNameByAddress ( wchar_t *a_HostAddress )
{
	wchar_t *t_HostName = NULL ;

	if ( a_HostAddress )
	{
		wchar_t *t_Name = NULL ;
		if ( ! s_NamePool.Lookup ( a_HostAddress , t_Name ) )
		{
			t_HostName = GetUncachedHostNameByAddress ( a_HostAddress ) ;
			s_NamePool [ UnicodeStringDuplicate ( a_HostAddress ) ] = t_HostName ;
		}
		else
		{
			t_HostName = t_Name ;
		}
	}

	return UnicodeStringDuplicate ( t_HostName ) ;
}

wchar_t *WbemTaskObject :: GetQualifiedHostNameByAddress ( wchar_t *a_HostAddress )
{
	wchar_t *t_HostName = NULL ;

	if ( a_HostAddress )
	{
		wchar_t *t_Name = NULL ;
		if ( ! s_QualifiedNamePool.Lookup ( a_HostAddress , t_Name ) )
		{
			t_HostName = GetUncachedQualifiedHostNameByAddress ( a_HostAddress ) ;
			s_QualifiedNamePool [ UnicodeStringDuplicate ( a_HostAddress ) ] = t_HostName ;
		}
		else
		{
			t_HostName = t_Name ;
		}
	}

	return UnicodeStringDuplicate ( t_HostName ) ;
}

wchar_t *WbemTaskObject :: GetHostAddressByName ( wchar_t *a_HostName )
{
	wchar_t *t_HostAddress = NULL ;

	if ( a_HostName )
	{
		wchar_t *t_Address = NULL ;
		if ( ! s_AddressPool.Lookup ( a_HostName , t_Address ) )
		{
			t_HostAddress = GetUncachedHostAddressByName ( a_HostName ) ;
			s_AddressPool [ UnicodeStringDuplicate ( a_HostName ) ] = t_HostAddress ;
		}
		else
		{
			t_HostAddress = t_Address ;
		}
	}

	return UnicodeStringDuplicate ( t_HostAddress ) ;
}

wchar_t *WbemTaskObject :: GetUncachedHostAddressByName ( wchar_t *a_HostName )
{
	wchar_t *t_Address = NULL ;
	if ( a_HostName ) 
	{
		char *t_DbcsString = UnicodeToDbcsString ( a_HostName ) ;
		if ( t_DbcsString )
		{
			hostent FAR *t_HostEntry = gethostbyname ( t_DbcsString );	
			if ( t_HostEntry )
			{
				ULONG t_HostAddress = ntohl ( * ( ( ULONG * ) t_HostEntry->h_addr ) ) ;
				SnmpIpAddressType t_IpAddress ( t_HostAddress ) ;
				t_Address = t_IpAddress.GetStringValue () ;
			}
		}

		delete [] t_DbcsString ;
	}
	
	return t_Address ;
}

wchar_t *WbemTaskObject :: GetUncachedHostNameByAddress ( wchar_t *a_HostAddress )
{
	wchar_t *t_Name = NULL ;
	SnmpIpAddressType t_IpAddress ( a_HostAddress ) ;
	if ( t_IpAddress )
	{
		ULONG t_Address = htonl ( t_IpAddress.GetValue () ) ;
		hostent FAR *t_HostEntry = gethostbyaddr ( ( char * ) & t_Address , sizeof ( ULONG ) , IPPROTO_IP ) ;
		if ( t_HostEntry )
		{
			ULONG t_Index = 0;
			ULONG t_HostEntryLength = strlen ( t_HostEntry->h_name ) ;
			for ( t_Index = 0 ; t_Index < t_HostEntryLength ; t_Index ++ )
			{
				if ( t_HostEntry->h_name [ t_Index ] == '.' )
					break ;
			}

			char *t_Machine = new char [ t_Index + 1 ] ;
			strncpy ( t_Machine , t_HostEntry->h_name , t_Index ) ;
			t_Machine [ t_Index ] = 0 ;
			t_Name = DbcsToUnicodeString ( t_Machine ) ;
			delete [] t_Machine ;
		}
	}

	return t_Name ;
}

wchar_t *WbemTaskObject :: GetUncachedQualifiedHostNameByAddress ( wchar_t *a_HostAddress )
{
	wchar_t *t_Name = NULL ;
	SnmpIpAddressType t_IpAddress ( a_HostAddress ) ;
	if ( t_IpAddress )
	{
		ULONG t_Address = htonl ( t_IpAddress.GetValue () ) ;
		hostent FAR *t_HostEntry = gethostbyaddr ( ( char * ) & t_Address , sizeof ( ULONG ) , IPPROTO_IP ) ;
		if ( t_HostEntry )
		{
			t_Name = DbcsToUnicodeString ( t_HostEntry->h_name ) ;
		}
	}

	return t_Name ;
}

wchar_t *WbemTaskObject :: GetHostName ()
{
	wchar_t buffer [MAX_COMPUTERNAME_LENGTH + 1];
	DWORD t_Length = ( DWORD ) ( sizeof ( buffer ) / sizeof ( wchar_t ) ) ;

	GetComputerName ( buffer ,  & t_Length ) ;

	return UnicodeStringDuplicate ( buffer ) ;
}

wchar_t *WbemTaskObject :: QuoteAndEscapeString ( wchar_t *a_String )
{
	ULONG t_StringLength = wcslen ( a_String ) ;
	ULONG t_NumberOfEscaped = 0 ;

	for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ ) 
	{
		if ( ( a_String [ t_Index ] == '\"' ) || ( a_String [ t_Index ] == '\\' ) )
		{
			t_NumberOfEscaped ++ ;
		}
	}

	wchar_t *t_QuotedString = new wchar_t [ t_StringLength + t_NumberOfEscaped + 3 ] ;

	t_QuotedString [ 0 ] = '\"' ;

	ULONG t_QuotedIndex = 1 ;
	for ( t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ ) 
	{
		if ( ( a_String [ t_Index ] == '\"' ) || ( a_String [ t_Index ] == '\\' ) )
		{
			t_QuotedString [ t_QuotedIndex ] = '\\' ;
			t_QuotedIndex ++ ;
		}

		t_QuotedString [ t_QuotedIndex ] = a_String [ t_Index ] ;

		t_QuotedIndex ++ ;
	}

	t_QuotedString [ t_QuotedIndex ] = '\"' ;
	t_QuotedString [ t_QuotedIndex + 1 ] = 0 ;

	return t_QuotedString ;
}

wchar_t *WbemTaskObject :: QuoteString ( wchar_t *a_String )
{
	ULONG t_StringLength = wcslen ( a_String ) ;

	wchar_t *t_QuotedString = new wchar_t [ t_StringLength + 3 ] ;

	t_QuotedString [ 0 ] = '\"' ;
	memcpy  ( & t_QuotedString [ 1 ] , a_String , sizeof ( wchar_t ) * t_StringLength ) ;
	t_QuotedString [ t_StringLength + 1 ] = '\"' ;
	t_QuotedString [ t_StringLength + 2 ] = 0 ;

	return t_QuotedString ;
}


BOOL WbemTaskObject :: FindAddressEntryByIndex ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	IEnumWbemClassObject *a_AddressTableEnumerator ,
	wchar_t *&a_ipAdEntAddr ,
	wchar_t *&a_ipAdEntNetMask ,
	ULONG a_ipAdEntIfIndex 
)
{
	BOOL t_ReturnStatus = FALSE ;

	a_ipAdEntAddr = NULL ;
	a_ipAdEntNetMask = NULL ;

	IWbemClassObject *t_AddressTableEntry = NULL ;
	ULONG t_Returned = 0 ;
	a_AddressTableEnumerator->Reset () ;

	HRESULT t_Result ;
	while ( ( t_Result = a_AddressTableEnumerator->Next ( -1 , 1 , &t_AddressTableEntry , & t_Returned ) ) == WBEM_NO_ERROR ) 
	{
		wchar_t *t_ipAdEntAddr = NULL ;
		wchar_t *t_ipAdEntNetMask = NULL ;
		ULONG t_ipAdEntIfIndex = 0 ;

		BOOL t_Status = GetAddressEntry (

			a_ErrorObject ,
			t_AddressTableEntry ,
			t_ipAdEntAddr ,
			t_ipAdEntNetMask ,
			t_ipAdEntIfIndex 
		) ;

		if ( t_Status ) 
		{
			if ( t_ipAdEntIfIndex == a_ipAdEntIfIndex )
			{
				t_AddressTableEntry->Release () ;

				a_ipAdEntAddr = t_ipAdEntAddr ;
				a_ipAdEntNetMask = t_ipAdEntNetMask ;
				t_ReturnStatus = TRUE ;

				break ;
			}
		}

		delete [] t_ipAdEntAddr ;
		delete [] t_ipAdEntNetMask ;
		t_AddressTableEntry->Release () ;
	}

	return t_ReturnStatus ;
}

BOOL WbemTaskObject :: FindAddressEntryByAddress ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	IEnumWbemClassObject *a_AddressTableEnumerator ,
	wchar_t *a_ipAdEntAddr ,
	wchar_t *&a_ipAdEntNetMask ,
	ULONG &a_ipAdEntIfIndex 
)
{
	BOOL t_ReturnStatus = FALSE ;

	a_ipAdEntNetMask = NULL ;
	a_ipAdEntIfIndex = 0 ;

	IWbemClassObject *t_AddressTableEntry = NULL ;
	ULONG t_Returned = 0 ;
	a_AddressTableEnumerator->Reset () ;

	HRESULT t_Result ;
	while ( ( t_Result = a_AddressTableEnumerator->Next ( -1 , 1 , &t_AddressTableEntry , & t_Returned ) ) == WBEM_NO_ERROR ) 
	{
		wchar_t *t_ipAdEntAddr = NULL ;
		wchar_t *t_ipAdEntNetMask = NULL ;
		ULONG t_ipAdEntIfIndex = 0 ;

		BOOL t_Status = GetAddressEntry (

			a_ErrorObject ,
			t_AddressTableEntry ,
			t_ipAdEntAddr ,
			t_ipAdEntNetMask ,
			t_ipAdEntIfIndex 
		) ;

		if ( t_Status ) 
		{
			if ( wcscmp ( t_ipAdEntAddr , a_ipAdEntAddr ) == 0 )
			{
				t_AddressTableEntry->Release () ;

				a_ipAdEntIfIndex = t_ipAdEntIfIndex ;
				a_ipAdEntNetMask = t_ipAdEntNetMask ;
				t_ReturnStatus = TRUE ;

				break ;
			}
		}

		delete [] t_ipAdEntAddr ;
		delete [] t_ipAdEntNetMask ;
		t_AddressTableEntry->Release () ;
	}

	return t_ReturnStatus ;
}

BOOL WbemTaskObject :: GetAddressEntry ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	IWbemClassObject *a_AddressTableEntry ,
	wchar_t *&a_ipAdEntAddr ,
	wchar_t *&a_ipAdEntNetMask ,
    ULONG &a_ipAdEntIfIndex 
)
{
	BOOL t_Status ;

	a_ipAdEntAddr = NULL ;
	a_ipAdEntNetMask = NULL ;
    a_ipAdEntIfIndex = 0 ;

	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	LONG t_PropertyFlavour = 0 ;
	VARTYPE t_PropertyType = 0 ;

	HRESULT t_Result = a_AddressTableEntry->Get (

		L"ipAdEntIfIndex" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;
		
	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_I4 )
		{
			a_ipAdEntIfIndex = t_Variant.lVal ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;

	t_Result = a_AddressTableEntry->Get (

		L"ipAdEntAddr" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;
		
	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( ( t_Variant.vt == VT_BSTR ) && ( t_Variant.bstrVal ) )
		{
			a_ipAdEntAddr = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;

	t_Result = a_AddressTableEntry->Get (

		L"ipAdEntNetMask" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;
		
	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( ( t_Variant.vt == VT_BSTR ) && ( t_Variant.bstrVal ) )
		{
			a_ipAdEntNetMask = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;


	return t_Status ;
}

BOOL WbemTaskObject :: GetRouteEntry ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	IWbemClassObject *a_RoutingTableEntry ,
	wchar_t *&a_ipRouteDest ,
	wchar_t *&a_ipRouteNextHop ,
	wchar_t *&a_ipRouteMask ,
    ULONG &a_ipRouteIfIndex ,
	ULONG &a_ipRouteMetric1 
)
{
	BOOL t_Status ;

	a_ipRouteDest = NULL ;
	a_ipRouteNextHop = NULL ;
	a_ipRouteMask = NULL ;
    a_ipRouteIfIndex = 0 ;
	a_ipRouteMetric1 = 0 ;

	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	LONG t_PropertyFlavour = 0 ;
	VARTYPE t_PropertyType = 0 ;

	HRESULT t_Result = a_RoutingTableEntry->Get (

		L"ipRouteIfIndex" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;
		
	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_I4 )
		{
			a_ipRouteIfIndex = t_Variant.lVal ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;

	t_Result = a_RoutingTableEntry->Get (

		L"ipRouteMetric1" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;
		
	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_I4 )
		{
			a_ipRouteMetric1 = t_Variant.lVal ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;

	t_Result = a_RoutingTableEntry->Get (

		L"ipRouteDest" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;
		
	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( ( t_Variant.vt == VT_BSTR ) && ( t_Variant.bstrVal ) )
		{
			a_ipRouteDest = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;

	t_Result = a_RoutingTableEntry->Get (

		L"ipRouteNextHop" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( ( t_Variant.vt == VT_BSTR ) && ( t_Variant.bstrVal ) )
		{
			a_ipRouteNextHop = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;			

	t_Result = a_RoutingTableEntry->Get (

		L"ipRouteMask" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		if ( ( t_Variant.vt == VT_BSTR ) && ( t_Variant.bstrVal ) )
		{
			a_ipRouteMask = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	VariantClear ( &t_Variant ) ;			

	return t_Status ;
}

BOOL WbemTaskObject :: CalculateRoute ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	IWbemServices *a_Proxy ,
	ULONG a_SourceAddress ,
	ULONG a_DestinationAddress ,
	wchar_t *&a_SubnetAddress ,
	wchar_t *&a_SubnetMask ,
	ULONG &a_InterfaceIndex ,
	wchar_t *&a_GatewayAddress ,
	wchar_t *&a_GatewaySubnetAddress ,
	wchar_t *&a_GatewaySubnetMask ,
	ULONG &a_GatewayInterfaceIndex ,
	wchar_t *&a_DestinationRouteAddress ,
	wchar_t *&a_DestinationRouteMask
) 
{
	BOOL t_Status = TRUE ;
	BOOL t_RouteInitialised = FALSE ;

	ULONG t_BestDestinationRouteAddress = 0 ;
	ULONG t_BestDestinationRouteMask = 0 ;

	ULONG t_BestSubnetAddress = 0 ;
	ULONG t_BestSubnetMask = 0 ;
	ULONG t_BestInterfaceIndex = 0 ;

	ULONG t_BestGatewayAddress = 0 ;
	ULONG t_BestGatewaySubnetAddress = 0 ;
	ULONG t_BestGatewaySubnetMask = 0 ;
	ULONG t_BestGatewayInterfaceIndex = 0 ;

	IEnumWbemClassObject *t_AddressTableEnumerator = NULL ;

	HRESULT t_Result = a_Proxy->CreateInstanceEnum (

		L"MS_SNMP_RFC1213_MIB_ipAddrTable" ,
		0 ,
		NULL ,
		& t_AddressTableEnumerator
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		SnmpIpAddressType t_SourceAddressType ( a_SourceAddress ) ;
		wchar_t *t_SourceipAdEntAddr = t_SourceAddressType.GetStringValue () ;
		wchar_t *t_SourceipAdEntNetMask = NULL ;
		ULONG t_SourceipAdEntIfIndex = 0 ;

		t_Status = FindAddressEntryByAddress (

			a_ErrorObject ,
			t_AddressTableEnumerator ,
			t_SourceipAdEntAddr ,
			t_SourceipAdEntNetMask ,
			t_SourceipAdEntIfIndex 
		) ;

		if ( t_Status ) 
		{
			SnmpIpAddressType t_SourceipAdEntNetMaskType ( t_SourceipAdEntNetMask ) ;
			SnmpIpAddressType t_SubNetworkAddress ( t_SourceipAdEntNetMaskType.GetValue () & a_SourceAddress ) ;
			SnmpIpAddressType t_DestinationSubNetworkAddress ( t_SourceipAdEntNetMaskType.GetValue () & a_DestinationAddress ) ;

			IEnumWbemClassObject *t_RoutingTableEnumerator = NULL ;

			HRESULT t_Result = a_Proxy->CreateInstanceEnum (

				L"MS_SNMP_RFC1213_MIB_ipRouteTable" ,
				0 ,
				NULL ,
				& t_RoutingTableEnumerator
			) ;

			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				IWbemClassObject *t_RoutingTableEntry = NULL ;
				ULONG t_Returned = 0 ;
				t_RoutingTableEnumerator->Reset () ;
				while ( ( t_Result = t_RoutingTableEnumerator->Next ( -1 , 1 , &t_RoutingTableEntry , & t_Returned ) ) == WBEM_NO_ERROR ) 
				{
					wchar_t *t_ipRouteDest = NULL ;
					wchar_t *t_ipRouteNextHop = NULL ;
					wchar_t *t_ipRouteMask = NULL ;
					ULONG t_ipRouteIfIndex = 0 ;
					ULONG t_ipRouteMetric1 = 0 ;

					t_Status = GetRouteEntry ( 

						a_ErrorObject ,
						t_RoutingTableEntry ,
						t_ipRouteDest ,
						t_ipRouteNextHop ,
						t_ipRouteMask ,
						t_ipRouteIfIndex ,
						t_ipRouteMetric1 
					) ;

					if ( t_Status )
					{
						SnmpIpAddressType t_ipRouteDestType ( t_ipRouteDest ) ;
						SnmpIpAddressType t_ipRouteMaskType ( t_ipRouteMask ) ;
						SnmpIpAddressType t_ipNextHopType ( t_ipRouteNextHop ) ;

						if ( t_ipRouteDestType && t_ipRouteMaskType && t_ipNextHopType )
						{
							wchar_t *t_ipAdEntAddr = NULL ;
							wchar_t *t_ipAdEntNetMask = NULL ;

							t_Status = FindAddressEntryByIndex (

								a_ErrorObject ,
								t_AddressTableEnumerator ,
								t_ipAdEntAddr ,
								t_ipAdEntNetMask ,
								t_ipRouteIfIndex
							) ;

							if ( t_Status )
							{
								SnmpIpAddressType t_ipAdEntNetMaskType ( t_ipAdEntNetMask ) ;
								SnmpIpAddressType t_ipAdEntAddrType ( t_ipAdEntAddr ) ;

								if ( ! t_RouteInitialised )
								{
									if ( ( a_DestinationAddress & t_ipRouteMaskType.GetValue () ) == t_ipRouteDestType.GetValue () )
									{
										t_BestInterfaceIndex = t_ipRouteIfIndex ;
										t_BestSubnetMask = t_SourceipAdEntNetMaskType.GetValue () ;
										t_BestSubnetAddress = t_SubNetworkAddress.GetValue () ;

										t_BestGatewayInterfaceIndex = t_SourceipAdEntIfIndex ;
										t_BestGatewayAddress = t_ipNextHopType.GetValue () ;
										t_BestGatewaySubnetMask = t_ipAdEntNetMaskType.GetValue () ;
										t_BestGatewaySubnetAddress = t_ipAdEntNetMaskType.GetValue () & t_ipNextHopType.GetValue () ;
										t_BestDestinationRouteAddress = t_ipRouteDestType.GetValue () ;
										t_BestDestinationRouteMask = t_ipRouteMaskType.GetValue () ;
										
										t_RouteInitialised = TRUE ;	
									}
								}
								else
								{
									if ( ( a_DestinationAddress & t_ipRouteMaskType.GetValue () ) == t_ipRouteDestType.GetValue () )
									{
										if ( t_ipRouteMaskType.GetValue () > t_BestDestinationRouteMask )
										{
											t_BestInterfaceIndex = t_ipRouteIfIndex ;
											t_BestSubnetMask = t_SourceipAdEntNetMaskType.GetValue () ;
											t_BestSubnetAddress = t_SubNetworkAddress.GetValue () ;

											t_BestGatewayInterfaceIndex = t_SourceipAdEntIfIndex ;
											t_BestGatewayAddress = t_ipNextHopType.GetValue () ;
											t_BestGatewaySubnetMask = t_ipAdEntNetMaskType.GetValue () ;
											t_BestGatewaySubnetAddress = t_ipAdEntNetMaskType.GetValue () & t_ipNextHopType.GetValue () ;
											t_BestDestinationRouteAddress = t_ipRouteDestType.GetValue () ;
											t_BestDestinationRouteMask = t_ipRouteMaskType.GetValue () ;
										}
									}
								}
							}

							delete [] t_ipAdEntAddr ;
							delete [] t_ipAdEntNetMask ;
						}
						else
						{
							t_Status = FALSE ;
						}
					}

					delete [] t_ipRouteDest ;
					delete [] t_ipRouteMask ;
					delete [] t_ipRouteNextHop ;

					t_RoutingTableEntry->Release () ;
				}
			}
		}

		delete [] t_SourceipAdEntAddr ;
		delete [] t_SourceipAdEntNetMask ;

	}

	if ( t_RouteInitialised )
	{
		a_InterfaceIndex = t_BestInterfaceIndex ;
		a_GatewayInterfaceIndex = t_BestGatewayInterfaceIndex ;

		SnmpIpAddressType t_GatewayAddressType ( t_BestGatewayAddress ) ;
		SnmpIpAddressType t_GatewaySubnetAddressType ( t_BestGatewaySubnetAddress ) ;
		SnmpIpAddressType t_GatewaySubnetMaskType ( t_BestGatewaySubnetMask ) ;

		SnmpIpAddressType t_SubnetMaskType ( t_BestSubnetMask ) ;
		SnmpIpAddressType t_SubnetAddressType ( t_BestSubnetAddress ) ;

		SnmpIpAddressType t_DestinationRouteAddressType ( t_BestDestinationRouteAddress ) ;
		SnmpIpAddressType t_DestinationRouteMaskType ( t_BestDestinationRouteMask ) ;

		a_GatewayAddress = t_GatewayAddressType.GetStringValue () ;
		a_GatewaySubnetAddress = t_GatewaySubnetAddressType.GetStringValue () ;
		a_GatewaySubnetMask = t_GatewaySubnetMaskType.GetStringValue () ;

		a_SubnetMask = t_SubnetMaskType.GetStringValue () ;
		a_SubnetAddress = t_SubnetAddressType.GetStringValue () ;
		a_DestinationRouteAddress = t_DestinationRouteAddressType.GetStringValue () ;
		a_DestinationRouteMask = t_DestinationRouteMaskType.GetStringValue () ;
	}

	return t_RouteInitialised ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\nadir.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

#define ASSOCQUERY_STR1		L"associators of {Subnetwork.m_IpSubnetAddress=\""
#define ASSOCQUERY_STR2		L"\"} where AssocClass=Subnetwork_ProxyRmonSystem_Assoc"

int W2A(const wchar_t* wstr, char* buff, int bufflen)
{
	return WideCharToMultiByte(CP_ACP, 0, wstr, -1, buff, bufflen, NULL, NULL);
}

BOOL ExecQueryAsyncEventObject :: Dispatch_SubnetworkToTopNAssoc ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 1 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Subnetwork" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				if ( t_Key1 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpSubnetAddress" ) == 0 )
					{
						if ( t_Key1->m_vValue.vt == VT_BSTR )
						{
							t_Status = SubnetworkToTopN_Association ( a_ErrorObject , a_ObjectPath , t_Key1 ) ;
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}


BOOL ExecQueryAsyncEventObject :: SubnetworkToTopN_Association ( 
	WbemSnmpErrorObject &a_ErrorObject ,
	wchar_t *a_ObjectPath ,
	KeyRef *a_IpSubnetAddrKey
)
{
	BOOL t_Status ;

	IWbemServices *t_Server = m_Provider->GetServer();
	IWbemClassObject *t_SubnetObject = NULL;
	IWbemCallResult *t_ErrorObject = NULL;
	HRESULT t_Result = t_Server->GetObject (

		a_ObjectPath ,
		0 ,
		NULL,
		& t_SubnetObject ,
		& t_ErrorObject 
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( &t_Variant ) ;

		LONG t_PropertyFlavour = 0 ;
		VARTYPE t_PropertyType = 0 ;

		HRESULT t_Result = t_SubnetObject->Get (

			L"m_IpSubnetMask" ,
			0 ,
			& t_Variant ,
			& t_PropertyType ,
			& t_PropertyFlavour
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			BSTR t_type = SysAllocString(L"WQL");
			wchar_t buff[256]; //roughly double the size neccessary...
			wsprintf(buff, L"%s%s%s", 
				ASSOCQUERY_STR1, a_IpSubnetAddrKey->m_vValue.bstrVal, ASSOCQUERY_STR2);
			BSTR t_query = SysAllocString(buff);

			IEnumWbemClassObject *pEnum;
			HRESULT result = t_Server->ExecQuery(t_type, t_query, 0, NULL, &pEnum);

			SysFreeString(t_type);
			SysFreeString(t_query);
			CList<IWbemClassObject*, IWbemClassObject*> resultsList;

			if ( (WBEM_NO_ERROR == result) && (WBEM_NO_ERROR == pEnum->Reset()) )
			{
				ULONG returned;
				IWbemClassObject* pObj =  NULL;

				result = pEnum->Next(-1,1, &pObj, &returned);
				
				if ( (WBEM_NO_ERROR == result) && (1 == returned) )
				{
					BSTR name = SysAllocString(L"m_Name");
					VARIANT v;
					result = pObj->Get(name, 0, &v, NULL, NULL);

					if ((result == WBEM_NO_ERROR) && (v.vt == VT_BSTR))
					{
						IWbemServices *rmonserv ;
						t_Status = GetProxy ( a_ErrorObject , t_Server , v.bstrVal , &rmonserv ) ;
						if ( t_Status ) 
						{
							BSTR classstr = SysAllocString(L"MS_SNMP_RFC1213_MIB_ipAddrTable");
							IEnumWbemClassObject *pAddrEnum;
							HRESULT result = rmonserv->CreateInstanceEnum(classstr, 0, NULL, &pAddrEnum);
							SysFreeString(classstr);

							if ( (WBEM_NO_ERROR == result) && (WBEM_NO_ERROR == pAddrEnum->Reset()) )
							{
								ULONG rtrnd;
								IWbemClassObject* pAddrObj =  NULL;
								ULONG ifIndex = 0;

								result = pAddrEnum->Next(-1,1, &pAddrObj, &rtrnd);
								char buffer[64]; //should be way big enough
								W2A(t_Variant.bstrVal, buffer, 64);
								SnmpIpAddress ipMask(buffer);
								W2A(a_IpSubnetAddrKey->m_vValue.bstrVal, buffer, 64);
								SnmpIpAddress ipSubnet(buffer);

								while ( (WBEM_NO_ERROR == result) && (1 == rtrnd) )
								{
									VARIANT vAddr;
									BSTR addrprop = SysAllocString(L"ipAdEntAddr");
									result = pAddrObj->Get(addrprop, 0, &vAddr, NULL, NULL);
									SysFreeString(addrprop);

									if ( (WBEM_NO_ERROR == result) && (VT_BSTR == vAddr.vt) )
									{
										W2A(vAddr.bstrVal, buffer, 64);
										SnmpIpAddress ipAddr(buffer);

										if ((ipMask.GetValue() & ipAddr.GetValue()) == ipSubnet.GetValue())
										{
											VARIANT vIndex;
											BSTR iprop = SysAllocString(L"ipAdEntIfIndex");
											result = pAddrObj->Get(iprop, 0, &vIndex , NULL, NULL);
											SysFreeString(iprop);

											if ( (WBEM_NO_ERROR == result) && (VT_I4 == vIndex.vt) )
											{
												ifIndex = vIndex.lVal;
											}

											VariantClear(&vIndex);
											VariantClear(&vAddr);
											pAddrObj->Release();
											break;
										}
									}
									
									VariantClear(&vAddr);
									pAddrObj->Release();
									result = pAddrEnum->Next(-1,1, &pAddrObj, &rtrnd);
								}

								if (0 != ifIndex)
								{
									CImpTraceRouteProv :: s_DefaultThreadObject->SetActive () ;

									BSTR clstr = SysAllocString(L"MS_SNMP_RFC1271_MIB_ProvidedhostTopNTable");
									IEnumWbemClassObject *pTopNEnum = NULL;
									HRESULT result = rmonserv->CreateInstanceEnum(clstr, 0, NULL, &pTopNEnum);
									SysFreeString(clstr);

									CImpTraceRouteProv :: s_DefaultThreadObject->SetActive ( FALSE ) ;

									if ( (WBEM_NO_ERROR == result) && (WBEM_NO_ERROR == pTopNEnum->Reset()) )
									{
										ULONG irtrnd;
										IWbemClassObject* pTopNObj =  NULL;

										result = pTopNEnum->Next(-1,1, &pTopNObj, &irtrnd);

										while ( (WBEM_NO_ERROR == result) && (1 == irtrnd) )
										{
											VARIANT vHostIndex;
											BSTR addrprop = SysAllocString(L"hostIndex");
											result = pTopNObj->Get(addrprop, 0, &vHostIndex, NULL, NULL);
											SysFreeString(addrprop);

											if ( (WBEM_NO_ERROR == result) 
												&& (VT_I4 == vHostIndex.vt) 
												&& (vHostIndex.lVal == ifIndex))
											{
												pTopNObj->AddRef();
												resultsList.AddTail(pTopNObj);
											}

											VariantClear(&vHostIndex);
											pTopNObj->Release();
											result = pTopNEnum->Next(-1,1, &pTopNObj, &irtrnd);
										}

										pTopNEnum->Release();
									}
								}
							}

							rmonserv->Release();
						}

					}

					SysFreeString(name);
					VariantClear(&v);
					pObj->Release();
				}
				
				pEnum->Release();
			}

			while (!resultsList.IsEmpty())
			{
				IWbemClassObject* pTOPN = resultsList.RemoveTail();
				BSTR pathprop = SysAllocString(L"__PATH");
				VARIANT vtopnPath;
				result = pTOPN->Get(pathprop, 0, &vtopnPath, NULL, NULL);
				SysFreeString(pathprop);

				if ( (WBEM_NO_ERROR == result) && (VT_BSTR == vtopnPath.vt) )
				{
					IWbemClassObject *t_Association = NULL ;
					HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						//put the paths in...
						VARIANT t_V;
						VariantInit(&t_V) ;
						t_V.vt = VT_BSTR ;
						t_V.bstrVal = SysAllocString ( a_ObjectPath ) ;

						t_Result = t_Association->Put(L"m_Subnet", 0, & t_V, 0);
						VariantClear(&t_V);

						if (SUCCEEDED(t_Result))
						{
							t_Result = t_Association->Put( L"m_TopN" , 0, &vtopnPath, 0);

							if ( WBEM_NO_ERROR == t_Result )
							{
								m_NotificationHandler->Indicate ( 1 , & t_Association ) ;
								t_Status = TRUE;
							}
						}

						t_Association->Release () ;
					}
				}

				VariantClear(&vtopnPath);
				pTOPN->Release();
			}
		}

		VariantClear ( &t_Variant ) ;
		t_SubnetObject->Release () ;

	}
	
	t_Server->Release () ;

	return t_Status ;
}


BOOL ExecQueryAsyncEventObject :: Dispatch_TopNToMacAddressAssoc (
	WbemSnmpErrorObject &a_ErrorObject ,
	wchar_t *a_ObjectPath
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"MS_SNMP_RFC1271_MIB_ProvidedhostTopNTable" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"hostTopNIndex" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"hostTopNReport" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_I4 ) && ( t_Key2->m_vValue.vt == VT_I4 ) )
							{
								t_Status = TopNToMacAddress_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"hostTopNIndex" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"hostTopNReport" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_I4 ) && ( t_Key2->m_vValue.vt == VT_I4 ) )
							{
								t_Status = TopNToMacAddress_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;

}


BOOL ExecQueryAsyncEventObject :: TopNToMacAddress_Association (
	WbemSnmpErrorObject &a_ErrorObject ,
	wchar_t *a_ObjectPath ,
	KeyRef *a_IndexKey ,
	KeyRef *a_ReportKey 
)
{
	BOOL t_Status = TRUE ;
	IWbemServices *t_Server = m_Provider->GetServer();
	IWbemClassObject *t_topNObject = NULL;
	IWbemCallResult *t_ErrorObject = NULL;

	HRESULT t_Result = t_Server->GetObject (

		a_ObjectPath ,
		0 ,
		NULL,
		& t_topNObject ,
		& t_ErrorObject 
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		VARIANT t_VMacAddr ;
		VariantInit ( &t_VMacAddr ) ;

		LONG t_PropertyFlavour = 0 ;
		VARTYPE t_PropertyType = 0 ;

		HRESULT t_Result = t_topNObject->Get (

			L"hostTopNAddress" ,
			0 ,
			& t_VMacAddr ,
			& t_PropertyType ,
			& t_PropertyFlavour
		) ;

		if ( (SUCCEEDED(t_Result)) && (t_VMacAddr.vt == VT_BSTR) )
		{
			IWbemClassObject* t_Association;
			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;

			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_TopN" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					wchar_t buffer[64]; //should be big enough
					wsprintf(buffer, L"MacAddress.m_MacAddress = \"%s\"", t_VMacAddr.bstrVal);
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( buffer ) ;
					
					//check the mac object exists...
					IWbemClassObject *t_macObject = NULL;

					HRESULT Result = t_Server->GetObject(

						t_Variant.bstrVal,
						0 ,	
						NULL,
						&t_macObject, 
						NULL
					);

					if ( t_Status = SUCCEEDED ( Result ) )
					{
						t_macObject->Release();
						t_Result = t_Association->Put ( L"m_MacAddress" , 0 , & t_Variant , 0 ) ;

						if ( t_Status = SUCCEEDED ( t_Result ) )
						{
							m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
						}
					}

					VariantClear ( &t_Variant ) ;
				}
			}

			t_Association->Release () ;
		}

		VariantClear(&t_VMacAddr);
		t_topNObject->Release();
	}
	
	t_Server->Release();
	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrtinst.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL CreateInstanceEnumAsyncEventObject :: Dispatch_ProvidedhostTopNTable ( WbemSnmpErrorObject &a_ErrorObject ) 
{
	BOOL t_Status = FALSE ;

	TopNTableProv *t_TopNTableProv = m_Provider->GetTopNTableProv () ;
	TopNCache *t_TopNCache = t_TopNTableProv->LockTopNCache () ;

	POSITION position = t_TopNCache->GetStartPosition () ;
	while ( position )
	{
		IWbemClassObject *t_TopNTableObject = NULL ;
		ULONG t_Key = 0 ;
		t_TopNCache->GetNextAssoc ( position , t_Key , t_TopNTableObject ) ;
		IWbemClassObject* t_pClone = NULL;
		t_TopNTableObject->Clone(&t_pClone);
		m_NotificationHandler->Indicate ( 1 , & t_pClone ) ;
		t_pClone->Release();
		t_Status = TRUE ;

	}

	t_TopNTableProv->UnlockTopNCache () ;
	return t_Status ;
}

BOOL CreateInstanceEnumAsyncEventObject :: Instantiate ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_Class ) ;
	if ( t_Status )
	{
		if ( wcscmp ( m_Class , L"MS_SNMP_RFC1271_MIB_ProvidedhostTopNTable" ) == 0 )	
		{
			t_Status = Dispatch_ProvidedhostTopNTable ( a_ErrorObject ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

CreateInstanceEnumAsyncEventObject :: CreateInstanceEnumAsyncEventObject (

	CImpTraceRouteProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Context

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag )
{
	m_Class = UnicodeStringDuplicate ( a_Class ) ;
}

CreateInstanceEnumAsyncEventObject :: ~CreateInstanceEnumAsyncEventObject () 
{
// Get Status object

	delete [] m_Class ;

	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->Indicate ( 1 , & t_NotifyStatus ) ;
		t_NotifyStatus->Release () ;
	}
}

void CreateInstanceEnumAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	if ( CImpTraceRouteProv:: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv:: s_BackupThreadObject->ReapTask ( *this ) ;
	}
	else
	{
		CImpTraceRouteProv:: s_DefaultThreadObject->ReapTask ( *this ) ;
	}

	delete this ;
}

void CreateInstanceEnumAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			BOOL t_Status = Instantiate ( m_ErrorObject ) ;
			if ( t_Status )
			{
				if ( GetState () == WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE )
				{
					ProcessComplete () ;
				}
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\steve.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL ExecQueryAsyncEventObject :: ConnectionSource_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	wchar_t *t_SourceAddress = GetHostAddressByName ( a_SourceKey->m_vValue.bstrVal ) ;
	wchar_t *t_DestinationAddress = GetHostAddressByName ( a_DestinationKey->m_vValue.bstrVal ) ;
	
	if ( t_SourceAddress && t_DestinationAddress )
	{
		SnmpIpAddressType t_SourceIpAddress ( t_SourceAddress ) ;
		SnmpIpAddressType t_DestinationIpAddress ( t_DestinationAddress ) ;

		if ( t_SourceIpAddress && t_DestinationIpAddress )
		{
			IWbemServices *t_Server = m_Provider->GetServer () ;
			IWbemServices *t_Proxy ;
			t_Status = GetProxy ( a_ErrorObject , t_Server , a_SourceKey->m_vValue.bstrVal , &t_Proxy ) ;
			if ( t_Status ) 
			{
				wchar_t *t_DestinationRouteAddress = 0 ;
				wchar_t *t_DestinationRouteMask = 0 ;
				wchar_t *t_SubnetAddress = 0 ;
				wchar_t *t_SubnetMask = 0 ;
				ULONG t_InterfaceIndex = 0 ;
				wchar_t *t_GatewayAddress = 0 ;
				wchar_t *t_GatewaySubnetAddress = 0 ;
				wchar_t *t_GatewaySubnetMask = 0 ;
				ULONG t_GatewayInterfaceIndex = 0 ;

				t_Status = CalculateRoute ( 

					a_ErrorObject ,
					t_Proxy ,
					t_SourceIpAddress.GetValue () ,
					t_DestinationIpAddress.GetValue () ,
					t_SubnetAddress ,
					t_SubnetMask ,
					t_InterfaceIndex ,
					t_GatewayAddress ,
					t_GatewaySubnetAddress ,
					t_GatewaySubnetMask ,
					t_GatewayInterfaceIndex ,
					t_DestinationRouteAddress ,
					t_DestinationRouteMask 
				) ;

				if ( t_Status )
				{
					SnmpIpAddressType t_HopDestinationType ( t_GatewayAddress ) ;

					IWbemClassObject *t_Association = NULL ;

					HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						VARIANT t_Variant ;
						VariantInit ( &t_Variant ) ;

						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

						t_Result = t_Association->Put ( L"m_Connection" , 0 , & t_Variant , 0 ) ;
						VariantClear ( &t_Variant ) ;

						if ( t_Status = SUCCEEDED ( t_Result ) )
						{						
							wchar_t *t_String1 = UnicodeStringDuplicate ( L"Hop.m_DestinationIpAddress  =\"" ) ;
							wchar_t *t_StringDestination = t_DestinationAddress ;
							wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , t_StringDestination ) ;
							delete [] t_String1 ;
							wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , L"\",m_IpAddress = \"" ) ;
							wchar_t *t_StringHop = t_SourceAddress ;
							wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , t_StringHop ) ;
							wchar_t *t_String5 = UnicodeStringAppend ( t_String4 , L"\"" ) ;
							delete [] t_String4 ;

							t_Variant.vt = VT_BSTR ;
							t_Variant.bstrVal = SysAllocString ( t_String5 ) ;
							delete [] t_String5 ;
							
							t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
							if ( t_Status = SUCCEEDED ( t_Result ) )
							{
								m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
							}
						}
					}

					t_Association->Release () ;
				}

				delete [] t_DestinationRouteAddress ;
				delete [] t_DestinationRouteMask ;
				delete [] t_GatewayAddress ;
				delete [] t_SubnetAddress ;
				delete [] t_SubnetMask ;

				t_Proxy->Release () ;
			}

			t_Server->Release () ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	delete [] t_SourceAddress ;
	delete [] t_DestinationAddress ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_ConnectionSource ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Connection" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_Source" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_Destination" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = ConnectionSource_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_Source" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_Destination" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = ConnectionSource_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: NextHop_Put ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	IWbemClassObject *a_NextHop ,
	wchar_t *a_ObjectPath ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask 
)
{
	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	wchar_t *t_String1 = UnicodeStringDuplicate ( L"Hop.m_DestinationIpAddress =\"" ) ;
	wchar_t *t_StringDestination = a_DestinationAddress ;
	wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , t_StringDestination ) ;
	delete [] t_String1 ;
	wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , L"\",m_IpAddress = \"" ) ;
	wchar_t *t_StringHop = a_GatewayAddress ;
	wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , t_StringHop ) ;
	wchar_t *t_String5 = UnicodeStringAppend ( t_String4 , L"\"" ) ;
	delete [] t_String4 ;

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( t_String5 ) ;
	delete [] t_String5 ;
	
	HRESULT t_Result = a_NextHop->Put ( L"m_Gateway" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

	t_Result = a_NextHop->Put ( L"m_Source" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_DestinationRouteAddress ) ;

	t_Result = a_NextHop->Put ( L"m_RouteAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_DestinationRouteMask ) ;

	t_Result = a_NextHop->Put ( L"m_RouteMask" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewayAddress ) ;

	t_Result = a_NextHop->Put ( L"m_GatewayIpAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewaySubnetMask ) ;

	t_Result = a_NextHop->Put ( L"m_GatewayIpSubnetMask" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewaySubnetAddress ) ;

	t_Result = a_NextHop->Put ( L"m_GatewayIpSubnetAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_I4 ;
	t_Variant.lVal = a_GatewayInterfaceIndex ;

	t_Result = a_NextHop->Put ( L"m_GatewayInterfaceIndex" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	return TRUE ;
}

BOOL ExecQueryAsyncEventObject :: NextHop_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	wchar_t *t_SourceAddress = a_SourceKey->m_vValue.bstrVal ;
	wchar_t *t_DestinationAddress = a_DestinationKey->m_vValue.bstrVal ;

	IWbemServices *t_Server = m_Provider->GetServer () ;

	wchar_t *t_SourceName = GetHostNameByAddress ( t_SourceAddress ) ;
	if ( t_SourceAddress && t_DestinationAddress )
	{
		SnmpIpAddressType t_SourceIpAddress ( t_SourceAddress ) ;
		SnmpIpAddressType t_DestinationIpAddress ( t_DestinationAddress ) ;

		if ( t_SourceIpAddress && t_DestinationIpAddress )
		{
			if ( t_SourceIpAddress.GetValue () != t_DestinationIpAddress.GetValue () )
			{	
				IWbemServices *t_Proxy ;
				t_Status = GetProxy ( a_ErrorObject , t_Server , t_SourceName , &t_Proxy ) ;
				if ( t_Status ) 
				{
					wchar_t *t_DestinationRouteAddress = 0 ;
					wchar_t *t_DestinationRouteMask = 0 ;
					wchar_t *t_SubnetAddress = 0 ;
					wchar_t *t_SubnetMask = 0 ;
					ULONG t_InterfaceIndex = 0 ;
					wchar_t *t_GatewayAddress = 0 ;
					wchar_t *t_GatewaySubnetAddress = 0 ;
					wchar_t *t_GatewaySubnetMask = 0 ;
					ULONG t_GatewayInterfaceIndex = 0 ;

					t_Status = CalculateRoute ( 

						a_ErrorObject ,
						t_Proxy ,
						t_SourceIpAddress.GetValue () ,
						t_DestinationIpAddress.GetValue () ,
						t_SubnetAddress ,
						t_SubnetMask ,
						t_InterfaceIndex ,
						t_GatewayAddress ,
						t_GatewaySubnetAddress ,
						t_GatewaySubnetMask ,
						t_GatewayInterfaceIndex ,
						t_DestinationRouteAddress ,
						t_DestinationRouteMask 
					) ;

					if ( t_Status )
					{
						SnmpIpAddressType t_HopDestinationType ( t_GatewayAddress ) ;
						if ( t_HopDestinationType.GetValue () != t_SourceIpAddress.GetValue () )
						{
							IWbemClassObject *t_Association = NULL ;

							HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
							if ( t_Status = SUCCEEDED ( t_Result ) )
							{
								t_Status = NextHop_Put ( 

									a_ErrorObject , 
									t_Association ,
									a_ObjectPath ,
									t_SourceAddress ,
									t_DestinationAddress ,
									t_GatewayAddress ,
									t_GatewaySubnetAddress ,
									t_GatewaySubnetMask ,
									t_GatewayInterfaceIndex ,
									t_DestinationRouteAddress ,
									t_DestinationRouteMask 
								) ;
	
								if ( t_Status )
								{
									m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
								}
							}

							t_Association->Release () ;
						}
						else
						{
						}
					}

					delete [] t_DestinationRouteAddress ;
					delete [] t_DestinationRouteMask ;
					delete [] t_GatewayAddress ;
					delete [] t_SubnetAddress ;
					delete [] t_SubnetMask ;

					t_Proxy->Release () ;
				}
			}
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	delete [] t_SourceName ;

	t_Server->Release () ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_NextHop ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = NextHop_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = NextHop_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: HopToProxySystem_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	wchar_t *t_SourceName = GetHostNameByAddress ( a_SourceKey->m_vValue.bstrVal ) ;
	SnmpIpAddressType t_SourceAddressType ( a_SourceKey->m_vValue.bstrVal ) ;

	if ( t_SourceName )
	{
		WbemNamespacePath *t_Path = m_Provider->GetNamespacePath () ;
		wchar_t *t_Namespace = t_Path->GetNamespacePath () ;

		wchar_t *t_String1 = UnicodeStringAppend ( L"\\\\" ,  GetHostName () ) ;
		wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\\" ) ;
		delete [] t_String1 ;
		wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , t_Namespace ) ;
		delete [] t_String2 ;
		wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , L"\\" ) ;
		delete [] t_String3 ;
		wchar_t *t_String5 = UnicodeStringAppend ( t_String4 , t_SourceName ) ;
		delete [] t_String4 ;
		wchar_t *t_String6 = UnicodeStringAppend ( t_String5 , L":" ) ;
		delete [] t_String5 ;
		wchar_t *t_String7 = UnicodeStringAppend ( t_String6 , L"ProxySystem.m_Name =\"" ) ;
		delete [] t_String6 ;
		wchar_t *t_String8 = UnicodeStringAppend ( t_String7 , t_SourceName ) ;
		delete [] t_String7 ;
		wchar_t *t_String9 = UnicodeStringAppend ( t_String8 , L"\"" ) ;
		delete [] t_String8 ;

		IWbemClassObject *t_Association = NULL ;

		HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
		if ( t_Status = SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_BSTR ;
			t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

			t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
			VariantClear ( &t_Variant ) ;

			if ( t_Status = SUCCEEDED ( t_Result ) )
			{						
				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( t_String9 ) ;
				
				t_Result = t_Association->Put ( L"m_ProxySystem" , 0 , & t_Variant , 0 ) ;
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
				}
			}
		}

		t_Association->Release () ;

		delete [] t_String9 ;
	}

	delete [] t_SourceName ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_HopToProxySystemAssoc ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToProxySystem_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToProxySystem_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: HopToInterfaceTable_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	IWbemServices *t_Server = m_Provider->GetServer () ;		

	IWbemClassObject *t_HopObject = NULL ;
	IWbemCallResult *t_ErrorObject = NULL ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive () ;

	HRESULT t_Result = t_Server->GetObject (

		a_ObjectPath ,
		0 ,
		NULL,
		& t_HopObject ,
		& t_ErrorObject 
	) ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive ( FALSE ) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( &t_Variant ) ;

		LONG t_PropertyFlavour = 0 ;
		VARTYPE t_PropertyType = 0 ;

		ULONG t_InterfaceIndex = 0 ;

		HRESULT t_Result = t_HopObject->Get (

			L"m_InterfaceIndex" ,
			0 ,
			& t_Variant ,
			& t_PropertyType ,
			& t_PropertyFlavour
		) ;

		if ( t_Status = SUCCEEDED ( t_Result ) )
		{
			t_InterfaceIndex = t_Variant.lVal ;

			wchar_t *t_SourceName = GetHostNameByAddress ( a_SourceKey->m_vValue.bstrVal ) ;
			SnmpIpAddressType t_SourceAddressType ( a_SourceKey->m_vValue.bstrVal ) ;

			if ( t_SourceName )
			{
				WbemNamespacePath *t_Path = m_Provider->GetNamespacePath () ;
				wchar_t *t_Namespace = t_Path->GetNamespacePath () ;

				wchar_t *t_String1 = UnicodeStringAppend ( L"\\\\" ,  GetHostName () ) ;
				wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\\" ) ;
				delete [] t_String1 ;
				wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , t_Namespace ) ;
				delete [] t_String2 ;
				wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , L"\\" ) ;
				delete [] t_String3 ;
				wchar_t *t_String5 = UnicodeStringAppend ( t_String4 , t_SourceName ) ;
				delete [] t_String4 ;
				wchar_t *t_String6 = UnicodeStringAppend ( t_String5 , L":" ) ;
				delete [] t_String5 ;
				wchar_t *t_String7 = UnicodeStringAppend ( t_String6 , L"MS_SNMP_RFC1213_MIB_ifTable.ifIndex =" ) ;
				delete [] t_String6 ;
				SnmpIntegerType t_InterfaceIndexType ( t_InterfaceIndex , NULL ) ;
				wchar_t *t_String8 = t_InterfaceIndexType.GetStringValue () ;
				wchar_t *t_String9 = UnicodeStringAppend ( t_String7 , t_String8 ) ;
				delete [] t_String7 ;
				delete [] t_String8 ;
				
				IWbemClassObject *t_Association = NULL ;

				HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					VARIANT t_Variant ;
					VariantInit ( &t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

					t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
					VariantClear ( &t_Variant ) ;

					if ( t_Status = SUCCEEDED ( t_Result ) )
					{						
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( t_String9 ) ;
						
						t_Result = t_Association->Put ( L"m_InterfaceTable" , 0 , & t_Variant , 0 ) ;
						if ( t_Status = SUCCEEDED ( t_Result ) )
						{
							m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
						}
					}
				}

				t_Association->Release () ;

				delete [] t_String9 ;
				delete [] t_SourceName ;
			}
		}

		VariantClear ( &t_Variant ) ;

		t_HopObject->Release () ;

		t_Server->Release () ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_HopToInterfaceTableAssoc ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToInterfaceTable_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToInterfaceTable_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}


BOOL ExecQueryAsyncEventObject :: HopToGatewayInterfaceTable_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	IWbemServices *t_Server = m_Provider->GetServer () ;		

	IWbemClassObject *t_HopObject = NULL ;
	IWbemCallResult *t_ErrorObject = NULL ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive () ;

	HRESULT t_Result = t_Server->GetObject (

		a_ObjectPath ,
		0 ,
		NULL,
		& t_HopObject ,
		& t_ErrorObject 
	) ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive ( FALSE ) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( &t_Variant ) ;

		LONG t_PropertyFlavour = 0 ;
		VARTYPE t_PropertyType = 0 ;

		ULONG t_InterfaceIndex = 0 ;

		HRESULT t_Result = t_HopObject->Get (

			L"m_GatewayInterfaceIndex" ,
			0 ,
			& t_Variant ,
			& t_PropertyType ,
			& t_PropertyFlavour
		) ;

		if ( t_Status = SUCCEEDED ( t_Result ) )
		{
			t_InterfaceIndex = t_Variant.lVal ;

			wchar_t *t_SourceName = GetHostNameByAddress ( a_SourceKey->m_vValue.bstrVal ) ;
			SnmpIpAddressType t_SourceAddressType ( a_SourceKey->m_vValue.bstrVal ) ;

			if ( t_SourceName )
			{
				WbemNamespacePath *t_Path = m_Provider->GetNamespacePath () ;
				wchar_t *t_Namespace = t_Path->GetNamespacePath () ;

				wchar_t *t_String1 = UnicodeStringAppend ( L"\\\\" ,  GetHostName () ) ;
				wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\\" ) ;
				delete [] t_String1 ;
				wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , t_Namespace ) ;
				delete [] t_String2 ;
				wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , L"\\" ) ;
				delete [] t_String3 ;
				wchar_t *t_String5 = UnicodeStringAppend ( t_String4 , t_SourceName ) ;
				delete [] t_String4 ;
				wchar_t *t_String6 = UnicodeStringAppend ( t_String5 , L":" ) ;
				delete [] t_String5 ;
				wchar_t *t_String7 = UnicodeStringAppend ( t_String6 , L"MS_SNMP_RFC1213_MIB_ifTable.ifIndex =" ) ;
				delete [] t_String6 ;
				SnmpIntegerType t_InterfaceIndexType ( t_InterfaceIndex , NULL ) ;
				wchar_t *t_String8 = t_InterfaceIndexType.GetStringValue () ;
				wchar_t *t_String9 = UnicodeStringAppend ( t_String7 , t_String8 ) ;
				delete [] t_String7 ;
				delete [] t_String8 ;
				
				IWbemClassObject *t_Association = NULL ;

				HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					VARIANT t_Variant ;
					VariantInit ( &t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

					t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
					VariantClear ( &t_Variant ) ;

					if ( t_Status = SUCCEEDED ( t_Result ) )
					{						
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( t_String9 ) ;
						
						t_Result = t_Association->Put ( L"m_InterfaceTable" , 0 , & t_Variant , 0 ) ;
						if ( t_Status = SUCCEEDED ( t_Result ) )
						{
							m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
						}
					}
				}

				t_Association->Release () ;

				delete [] t_String9 ;
				delete [] t_SourceName ;
			}
		}

		VariantClear ( &t_Variant ) ;

		t_HopObject->Release () ;

		t_Server->Release () ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_HopToGatewayInterfaceTableAssoc ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToGatewayInterfaceTable_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToGatewayInterfaceTable_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: ConnectionDestination_Put ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	IWbemClassObject *a_ConnectionDestination ,
	wchar_t *a_ObjectPath ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask 
)
{
	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	wchar_t *t_DestinationName = GetHostNameByAddress ( a_DestinationAddress ) ;
	if ( t_DestinationName )
	{
		WbemNamespacePath *t_Path = m_Provider->GetNamespacePath () ;
		wchar_t *t_Namespace = t_Path->GetNamespacePath () ;

		wchar_t *t_String1 = UnicodeStringAppend ( L"\\\\" ,  GetHostName () ) ;
		wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\\" ) ;
		delete [] t_String1 ;
		wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , t_Namespace ) ;
		delete [] t_String2 ;
		wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , L"\\" ) ;
		delete [] t_String3 ;
		wchar_t *t_String5 = UnicodeStringAppend ( t_String4 , t_DestinationName ) ;
		delete [] t_String4 ;
		wchar_t *t_String6 = UnicodeStringAppend ( t_String5 , L":" ) ;
		delete [] t_String5 ;
		wchar_t *t_String7 = UnicodeStringAppend ( t_String6 , L"ProxySystem.m_Name =\"" ) ;
		delete [] t_String6 ;
		wchar_t *t_String8 = UnicodeStringAppend ( t_String7 , t_DestinationName ) ;
		delete [] t_String7 ;
		wchar_t *t_String9 = UnicodeStringAppend ( t_String8 , L"\"" ) ;
		delete [] t_String8 ;

		t_Variant.vt = VT_BSTR ;
		t_Variant.bstrVal = SysAllocString ( t_String9 ) ;
		delete [] t_String9 ;
		
		HRESULT t_Result = a_ConnectionDestination->Put ( L"m_ProxySystem" , 0 , & t_Variant , 0 ) ;
		VariantClear ( &t_Variant ) ;

		if ( ! SUCCEEDED ( t_Result ) )
		{
			return FALSE ;
		}
	}
	else
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

	HRESULT t_Result = a_ConnectionDestination->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_DestinationRouteAddress ) ;

	t_Result = a_ConnectionDestination->Put ( L"m_RouteAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_DestinationRouteMask ) ;

	t_Result = a_ConnectionDestination->Put ( L"m_RouteMask" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewayAddress ) ;

	t_Result = a_ConnectionDestination->Put ( L"m_GatewayIpAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewaySubnetMask ) ;

	t_Result = a_ConnectionDestination->Put ( L"m_GatewayIpSubnetMask" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewaySubnetAddress ) ;

	t_Result = a_ConnectionDestination->Put ( L"m_GatewayIpSubnetAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_I4 ;
	t_Variant.lVal = a_GatewayInterfaceIndex ;

	t_Result = a_ConnectionDestination->Put ( L"m_GatewayInterfaceIndex" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	return TRUE ;
}

BOOL ExecQueryAsyncEventObject :: ConnectionDestination_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	wchar_t *t_SourceAddress = a_SourceKey->m_vValue.bstrVal ;
	wchar_t *t_DestinationAddress = a_DestinationKey->m_vValue.bstrVal ;

	IWbemServices *t_Server = m_Provider->GetServer () ;

	wchar_t *t_SourceName = GetHostNameByAddress ( t_SourceAddress ) ;
	if ( t_SourceAddress && t_DestinationAddress )
	{
		SnmpIpAddressType t_SourceIpAddress ( t_SourceAddress ) ;
		SnmpIpAddressType t_DestinationIpAddress ( t_DestinationAddress ) ;

		if ( t_SourceIpAddress && t_DestinationIpAddress )
		{
			if ( t_SourceIpAddress.GetValue () != t_DestinationIpAddress.GetValue () )
			{	
				IWbemServices *t_Proxy ;
				t_Status = GetProxy ( a_ErrorObject , t_Server , t_SourceName , &t_Proxy ) ;
				if ( t_Status ) 
				{
					wchar_t *t_DestinationRouteAddress = 0 ;
					wchar_t *t_DestinationRouteMask = 0 ;
					wchar_t *t_SubnetAddress = 0 ;
					wchar_t *t_SubnetMask = 0 ;
					ULONG t_InterfaceIndex = 0 ;
					wchar_t *t_GatewayAddress = 0 ;
					wchar_t *t_GatewaySubnetAddress = 0 ;
					wchar_t *t_GatewaySubnetMask = 0 ;
					ULONG t_GatewayInterfaceIndex = 0 ;

					t_Status = CalculateRoute ( 

						a_ErrorObject ,
						t_Proxy ,
						t_SourceIpAddress.GetValue () ,
						t_DestinationIpAddress.GetValue () ,
						t_SubnetAddress ,
						t_SubnetMask ,
						t_InterfaceIndex ,
						t_GatewayAddress ,
						t_GatewaySubnetAddress ,
						t_GatewaySubnetMask ,
						t_GatewayInterfaceIndex ,
						t_DestinationRouteAddress ,
						t_DestinationRouteMask 
					) ;

					if ( t_Status )
					{
						SnmpIpAddressType t_HopDestinationType ( t_GatewayAddress ) ;

						if ( t_HopDestinationType.GetValue () == t_SourceIpAddress.GetValue () )
						{
							SnmpIpAddressType t_HopDestinationType ( t_GatewayAddress ) ;
							SnmpIpAddressType t_HopDestinationSubnetType ( t_GatewaySubnetAddress ) ;
							SnmpIpAddressType t_HopDestinationSubnetMaskType ( t_GatewaySubnetMask ) ;
							SnmpIpAddressType t_DestinationSubnetType ( t_DestinationIpAddress.GetValue () & t_HopDestinationSubnetMaskType.GetValue () ) ;

							if ( t_DestinationSubnetType.GetValue () == t_HopDestinationSubnetType.GetValue () )
							{
								IWbemClassObject *t_Association = NULL ;

								HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
								if ( t_Status = SUCCEEDED ( t_Result ) )
								{
									t_Status = ConnectionDestination_Put ( 

										a_ErrorObject , 
										t_Association ,
										a_ObjectPath ,
										t_SourceAddress ,
										t_DestinationAddress ,
										t_GatewayAddress ,
										t_GatewaySubnetAddress ,
										t_GatewaySubnetMask ,
										t_GatewayInterfaceIndex ,
										t_DestinationRouteAddress ,
										t_DestinationRouteMask 
									) ;

									if ( t_Status )
									{
										m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
									}
								}
								else
								{
									t_Status = FALSE ;
								}

								t_Association->Release () ;
							}
						}
						else
						{
						}
					}

					delete [] t_DestinationRouteAddress ;
					delete [] t_DestinationRouteMask ;
					delete [] t_GatewayAddress ;
					delete [] t_SubnetAddress ;
					delete [] t_SubnetMask ;

					t_Proxy->Release () ;
				}
			}
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	delete [] t_SourceName ;

	t_Server->Release () ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_ConnectionDestination ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = ConnectionDestination_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = ConnectionDestination_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: HopToSubnetwork_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	IWbemServices *t_Server = m_Provider->GetServer () ;		

	IWbemClassObject *t_HopObject = NULL ;
	IWbemCallResult *t_ErrorObject = NULL ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive () ;

	HRESULT t_Result = t_Server->GetObject (

		a_ObjectPath ,
		0 ,
		NULL,
		& t_HopObject ,
		& t_ErrorObject 
	) ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive ( FALSE ) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( &t_Variant ) ;

		LONG t_PropertyFlavour = 0 ;
		VARTYPE t_PropertyType = 0 ;

		HRESULT t_Result = t_HopObject->Get (

			L"m_IpSubnetAddress" ,
			0 ,
			& t_Variant ,
			& t_PropertyType ,
			& t_PropertyFlavour
		) ;

		if ( t_Status = SUCCEEDED ( t_Result ) )
		{
			wchar_t *t_SubnetAddress = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;

			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_String1 = UnicodeStringAppend ( L"Subnetwork.m_IpSubnetAddress=\"" , t_SubnetAddress ) ;
					wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\"" ) ;
					delete [] t_String1 ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_String2 ) ;
					delete t_String2 ;

					t_Result = t_Association->Put ( L"m_Subnetwork" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;
				}

				t_Association->Release () ;

			}
		}

		VariantClear ( &t_Variant ) ;

		t_HopObject->Release () ;

		t_Server->Release () ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_HopToSubnetworkAssoc ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToSubnetwork_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToSubnetwork_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: HopToGatewaySubnetwork_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	IWbemServices *t_Server = m_Provider->GetServer () ;		

	IWbemClassObject *t_HopObject = NULL ;
	IWbemCallResult *t_ErrorObject = NULL ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive () ;

	HRESULT t_Result = t_Server->GetObject (

		a_ObjectPath ,
		0 ,
		NULL,
		& t_HopObject ,
		& t_ErrorObject 
	) ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive ( FALSE ) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( &t_Variant ) ;

		LONG t_PropertyFlavour = 0 ;
		VARTYPE t_PropertyType = 0 ;

		HRESULT t_Result = t_HopObject->Get (

			L"m_GatewayIpSubnetAddress" ,
			0 ,
			& t_Variant ,
			& t_PropertyType ,
			& t_PropertyFlavour
		) ;

		if ( t_Status = SUCCEEDED ( t_Result ) )
		{
			wchar_t *t_SubnetAddress = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;

			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_String1 = UnicodeStringAppend ( L"Subnetwork.m_IpSubnetAddress=\"" , t_SubnetAddress ) ;
					wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\"" ) ;
					delete [] t_String1 ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_String2 ) ;
					delete t_String2 ;

					t_Result = t_Association->Put ( L"m_Subnetwork" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;
				}

				t_Association->Release () ;

			}
		}

		VariantClear ( &t_Variant ) ;

		t_HopObject->Release () ;

		t_Server->Release () ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_HopToGatewaySubnetworkAssoc ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToGatewaySubnetwork_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = HopToGatewaySubnetwork_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
 		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: All_Hop_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey , 
	KeyRef *a_DestinationKey 
) 
{
	BOOL t_Status = TRUE ;

	IWbemServices *t_Server = m_Provider->GetServer () ;		

	IWbemClassObject *t_HopObject = NULL ;
	IWbemCallResult *t_ErrorObject = NULL ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive () ;

	HRESULT t_Result = t_Server->GetObject (

		a_ObjectPath ,
		0 ,
		NULL,
		& t_HopObject ,
		& t_ErrorObject 
	) ;

	CImpTraceRouteProv :: s_DefaultThreadObject->SetActive ( FALSE ) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_SourceAddress = a_SourceKey->m_vValue.bstrVal ;
		wchar_t *t_DestinationAddress = a_DestinationKey->m_vValue.bstrVal ;

		wchar_t *t_SourceName = GetHostNameByAddress ( t_SourceAddress ) ;
		if ( t_SourceAddress && t_DestinationAddress )
		{
			SnmpIpAddressType t_SourceIpAddress ( t_SourceAddress ) ;
			SnmpIpAddressType t_DestinationIpAddress ( t_DestinationAddress ) ;

			if ( t_SourceIpAddress && t_DestinationIpAddress )
			{
				SnmpIpAddressType t_SourceIpAddress ( t_SourceAddress ) ;
				SnmpIpAddressType t_DestinationIpAddress ( t_DestinationAddress ) ;

				if ( t_SourceIpAddress && t_DestinationIpAddress )
				{
					IWbemServices *t_Server = m_Provider->GetServer () ;
					IWbemServices *t_Proxy ;
					t_Status = GetProxy ( a_ErrorObject , t_Server , t_SourceName , &t_Proxy ) ;
					if ( t_Status ) 
					{
						wchar_t *t_DestinationRouteAddress = 0 ;
						wchar_t *t_DestinationRouteMask = 0 ;
						wchar_t *t_SubnetAddress = 0 ;
						wchar_t *t_SubnetMask = 0 ;
						ULONG t_InterfaceIndex = 0 ;
						wchar_t *t_GatewayAddress = 0 ;
						wchar_t *t_GatewaySubnetAddress = 0 ;
						wchar_t *t_GatewaySubnetMask = 0 ;
						ULONG t_GatewayInterfaceIndex = 0 ;

						t_Status = CalculateRoute ( 

							a_ErrorObject ,
							t_Proxy ,
							t_SourceIpAddress.GetValue () ,
							t_DestinationIpAddress.GetValue () ,
							t_SubnetAddress ,
							t_SubnetMask ,
							t_InterfaceIndex ,
							t_GatewayAddress ,
							t_GatewaySubnetAddress ,
							t_GatewaySubnetMask ,
							t_GatewayInterfaceIndex ,
							t_DestinationRouteAddress ,
							t_DestinationRouteMask 
						) ;

						if ( t_Status )
						{
							t_Status = All_NextHop_Association ( 

								a_ErrorObject , 
								a_ObjectPath , 
								a_SourceKey , 
								a_DestinationKey , 
								t_Proxy ,
								t_HopObject ,
								t_SourceName ,
								t_SourceAddress ,
								t_DestinationAddress ,
								t_SourceIpAddress.GetValue () ,
								t_DestinationIpAddress.GetValue () ,
								t_SubnetAddress ,
								t_SubnetMask ,
								t_InterfaceIndex ,
								t_GatewayAddress ,
								t_GatewaySubnetAddress ,
								t_GatewaySubnetMask ,
								t_GatewayInterfaceIndex ,
								t_DestinationRouteAddress ,
								t_DestinationRouteMask 
							) ;

							t_Status = t_Status && All_ConnectionDestination_Association (

								a_ErrorObject , 
								a_ObjectPath , 
								a_SourceKey , 
								a_DestinationKey , 
								t_Proxy ,
								t_HopObject ,
								t_SourceName ,
								t_SourceAddress ,
								t_DestinationAddress ,
								t_SourceIpAddress.GetValue () ,
								t_DestinationIpAddress.GetValue () ,
								t_SubnetAddress ,
								t_SubnetMask ,
								t_InterfaceIndex ,
								t_GatewayAddress ,
								t_GatewaySubnetAddress ,
								t_GatewaySubnetMask ,
								t_GatewayInterfaceIndex ,
								t_DestinationRouteAddress ,
								t_DestinationRouteMask 
							) ;

							t_Status = t_Status && All_HopToProxySystem_Association ( 

								a_ErrorObject , 
								a_ObjectPath , 
								a_SourceKey , 
								a_DestinationKey , 
								t_Proxy ,
								t_HopObject ,
								t_SourceName ,
								t_SourceAddress ,
								t_DestinationAddress ,
								t_SourceIpAddress.GetValue () ,
								t_DestinationIpAddress.GetValue () ,
								t_SubnetAddress ,
								t_SubnetMask ,
								t_InterfaceIndex ,
								t_GatewayAddress ,
								t_GatewaySubnetAddress ,
								t_GatewaySubnetMask ,
								t_GatewayInterfaceIndex ,
								t_DestinationRouteAddress ,
								t_DestinationRouteMask 
							) ;

							t_Status = t_Status && All_HopToInterfaceTable_Association ( 

								a_ErrorObject , 
								a_ObjectPath , 
								a_SourceKey , 
								a_DestinationKey , 
								t_Proxy ,
								t_HopObject ,
								t_SourceName ,
								t_SourceAddress ,
								t_DestinationAddress ,
								t_SourceIpAddress.GetValue () ,
								t_DestinationIpAddress.GetValue () ,
								t_SubnetAddress ,
								t_SubnetMask ,
								t_InterfaceIndex ,
								t_GatewayAddress ,
								t_GatewaySubnetAddress ,
								t_GatewaySubnetMask ,
								t_GatewayInterfaceIndex ,
								t_DestinationRouteAddress ,
								t_DestinationRouteMask 
							) ;

							t_Status = t_Status && All_HopToGatewayInterfaceTable_Association (

								a_ErrorObject , 
								a_ObjectPath , 
								a_SourceKey , 
								a_DestinationKey , 
								t_Proxy ,
								t_HopObject ,
								t_SourceName ,
								t_SourceAddress ,
								t_DestinationAddress ,
								t_SourceIpAddress.GetValue () ,
								t_DestinationIpAddress.GetValue () ,
								t_SubnetAddress ,
								t_SubnetMask ,
								t_InterfaceIndex ,
								t_GatewayAddress ,
								t_GatewaySubnetAddress ,
								t_GatewaySubnetMask ,
								t_GatewayInterfaceIndex ,
								t_DestinationRouteAddress ,
								t_DestinationRouteMask 
							) ;

							t_Status = t_Status && All_HopToSubnetwork_Association (

								a_ErrorObject , 
								a_ObjectPath , 
								a_SourceKey , 
								a_DestinationKey , 
								t_Proxy ,
								t_HopObject ,
								t_SourceName ,
								t_SourceAddress ,
								t_DestinationAddress ,
								t_SourceIpAddress.GetValue () ,
								t_DestinationIpAddress.GetValue () ,
								t_SubnetAddress ,
								t_SubnetMask ,
								t_InterfaceIndex ,
								t_GatewayAddress ,
								t_GatewaySubnetAddress ,
								t_GatewaySubnetMask ,
								t_GatewayInterfaceIndex ,
								t_DestinationRouteAddress ,
								t_DestinationRouteMask 
							) ;

							t_Status = t_Status && All_HopToGatewaySubnetwork_Association (

								a_ErrorObject , 
								a_ObjectPath , 
								a_SourceKey , 
								a_DestinationKey , 
								t_Proxy ,
								t_HopObject ,
								t_SourceName ,
								t_SourceAddress ,
								t_DestinationAddress ,
								t_SourceIpAddress.GetValue () ,
								t_DestinationIpAddress.GetValue () ,
								t_SubnetAddress ,
								t_SubnetMask ,
								t_InterfaceIndex ,
								t_GatewayAddress ,
								t_GatewaySubnetAddress ,
								t_GatewaySubnetMask ,
								t_GatewayInterfaceIndex ,
								t_DestinationRouteAddress ,
								t_DestinationRouteMask 
							) ;
						}
					}
				}
			}
		}

		t_HopObject->Release () ;

		t_Server->Release () ;
	}

	return t_Status ;
}



BOOL ExecQueryAsyncEventObject :: Dispatch_AllAssoc ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 2 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Connection" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_Source" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_Destination" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = ConnectionSource_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_Source" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_Destination" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = ConnectionSource_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				KeyRef *t_Key2 = t_ParsedObjectPath->m_paKeys [ 1 ] ;
				if ( t_Key1 && t_Key2 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = All_Hop_Association ( a_ErrorObject , a_ObjectPath , t_Key1 , t_Key2 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
					{
						if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
						{
							if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
							{
								t_Status = All_Hop_Association ( a_ErrorObject , a_ObjectPath , t_Key2 , t_Key1 ) ;
							}
							else
							{
								t_Status = FALSE ;
							}
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: All_NextHop_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath , 
	KeyRef *a_SourceKey , 
	KeyRef *DestinationKey ,
	IWbemServices *a_Proxy ,
	IWbemClassObject *a_HopObject ,
	wchar_t *a_SourceName ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	ULONG a_SourceIpAddress ,
	ULONG a_DestinationIpAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask
) 
{
	BOOL t_Status = TRUE ;

	SnmpIpAddressType t_HopDestinationType ( a_GatewayAddress ) ;
	if ( t_HopDestinationType.GetValue () != a_SourceIpAddress )
	{
		t_Status = GetClassObject ( L"NextHop" ) ;
		if ( t_Status )
		{
			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				t_Status = NextHop_Put ( 

					a_ErrorObject , 
					t_Association ,
					a_ObjectPath ,
					a_SourceAddress ,
					a_DestinationAddress ,
					a_GatewayAddress ,
					a_GatewaySubnetAddress ,
					a_GatewaySubnetMask ,
					a_GatewayInterfaceIndex ,
					a_DestinationRouteAddress ,
					a_DestinationRouteMask 
				) ;

				if ( t_Status )
				{
					m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
				}
			}

			t_Association->Release () ;
		}
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: All_ConnectionDestination_Association ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath , 
	KeyRef *a_SourceKey , 
	KeyRef *DestinationKey ,
	IWbemServices *a_Proxy ,
	IWbemClassObject *a_HopObject ,
	wchar_t *a_SourceName ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	ULONG a_SourceIpAddress ,
	ULONG a_DestinationIpAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask
) 
{
	BOOL t_Status = TRUE ;

	SnmpIpAddressType t_HopDestinationType ( a_GatewayAddress ) ;

	if ( t_HopDestinationType.GetValue () == a_SourceIpAddress )
	{
		SnmpIpAddressType t_HopDestinationType ( a_GatewayAddress ) ;
		SnmpIpAddressType t_HopDestinationSubnetType ( a_GatewaySubnetAddress ) ;
		SnmpIpAddressType t_HopDestinationSubnetMaskType ( a_GatewaySubnetMask ) ;
		SnmpIpAddressType t_DestinationSubnetType ( a_DestinationIpAddress & t_HopDestinationSubnetMaskType.GetValue () ) ;

		if ( t_DestinationSubnetType.GetValue () == t_HopDestinationSubnetType.GetValue () )
		{
			t_Status = GetClassObject ( L"ConnectionDestination" ) ;
			if ( t_Status )
			{
				IWbemClassObject *t_Association = NULL ;

				HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					t_Status = ConnectionDestination_Put ( 

						a_ErrorObject , 
						t_Association ,
						a_ObjectPath ,
						a_SourceAddress ,
						a_DestinationAddress ,
						a_GatewayAddress ,
						a_GatewaySubnetAddress ,
						a_GatewaySubnetMask ,
						a_GatewayInterfaceIndex ,
						a_DestinationRouteAddress ,
						a_DestinationRouteMask 
					) ;

					if ( t_Status )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}
				}
				else
				{
					t_Status = FALSE ;
				}

				t_Association->Release () ;
			}
		}
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: All_HopToProxySystem_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath , 
	KeyRef *a_SourceKey , 
	KeyRef *DestinationKey ,
	IWbemServices *a_Proxy ,
	IWbemClassObject *a_HopObject ,
	wchar_t *a_SourceName ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	ULONG a_SourceIpAddress ,
	ULONG a_DestinationIpAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask
) 
{
	BOOL t_Status ;

	wchar_t *t_SourceName = GetHostNameByAddress ( a_SourceKey->m_vValue.bstrVal ) ;
	SnmpIpAddressType t_SourceAddressType ( a_SourceKey->m_vValue.bstrVal ) ;

	if ( t_SourceName )
	{
		WbemNamespacePath *t_Path = m_Provider->GetNamespacePath () ;
		wchar_t *t_Namespace = t_Path->GetNamespacePath () ;

		wchar_t *t_String1 = UnicodeStringAppend ( L"\\\\" ,  GetHostName () ) ;
		wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\\" ) ;
		delete [] t_String1 ;
		wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , t_Namespace ) ;
		delete [] t_String2 ;
		wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , L"\\" ) ;
		delete [] t_String3 ;
		wchar_t *t_String5 = UnicodeStringAppend ( t_String4 , t_SourceName ) ;
		delete [] t_String4 ;
		wchar_t *t_String6 = UnicodeStringAppend ( t_String5 , L":" ) ;
		delete [] t_String5 ;
		wchar_t *t_String7 = UnicodeStringAppend ( t_String6 , L"ProxySystem.m_Name =\"" ) ;
		delete [] t_String6 ;
		wchar_t *t_String8 = UnicodeStringAppend ( t_String7 , a_SourceName ) ;
		delete [] t_String7 ;
		wchar_t *t_String9 = UnicodeStringAppend ( t_String8 , L"\"" ) ;
		delete [] t_String8 ;
			
		t_Status = GetClassObject ( L"HopToProxySystem_Assoc" ) ;
		if ( t_Status )
		{
			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{						
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_String9 ) ;
							
					t_Result = t_Association->Put ( L"m_ProxySystem" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}
				}
			}

			t_Association->Release () ;
		}

		delete [] t_String9 ;
	}
	
	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: All_HopToInterfaceTable_Association ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath , 
	KeyRef *a_SourceKey , 
	KeyRef *DestinationKey ,
	IWbemServices *a_Proxy ,
	IWbemClassObject *a_HopObject ,
	wchar_t *a_SourceName ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	ULONG a_SourceIpAddress ,
	ULONG a_DestinationIpAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask
)
{
	BOOL t_Status = TRUE ;

	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	LONG t_PropertyFlavour = 0 ;
	VARTYPE t_PropertyType = 0 ;

	ULONG t_InterfaceIndex = 0 ;

	HRESULT t_Result = a_HopObject->Get (

		L"m_InterfaceIndex" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		t_Status = GetClassObject ( L"HopToInterfaceTable_Assoc" ) ;
		if ( t_Status )
		{
			t_InterfaceIndex = t_Variant.lVal ;

			WbemNamespacePath *t_Path = m_Provider->GetNamespacePath () ;
			wchar_t *t_Namespace = t_Path->GetNamespacePath () ;
			wchar_t *t_String1 = UnicodeStringAppend ( t_Namespace, L"\\" ) ;
			wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , a_SourceName ) ;
			delete [] t_String1 ;
			wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , L":" ) ;
			delete [] t_String2 ;
			wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , L"MS_SNMP_RFC1213_MIB_ifTable.ifIndex =" ) ;
			delete [] t_String3 ;
			SnmpIntegerType t_InterfaceIndexType ( a_InterfaceIndex , NULL ) ;
			wchar_t *t_String5 = t_InterfaceIndexType.GetStringValue () ;
			wchar_t *t_String6 = UnicodeStringAppend ( t_String4 , t_String5 ) ;
			delete [] t_String5 ;
			
			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{						
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_String6 ) ;
					
					t_Result = t_Association->Put ( L"m_InterfaceTable" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}
				}

				t_Association->Release () ;
			}

			delete [] t_String6 ;
		}
	}

	VariantClear ( &t_Variant ) ;

	return t_Status ;

}

BOOL ExecQueryAsyncEventObject :: All_HopToGatewayInterfaceTable_Association ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath , 
	KeyRef *a_SourceKey , 
	KeyRef *DestinationKey ,
	IWbemServices *a_Proxy ,
	IWbemClassObject *a_HopObject ,
	wchar_t *a_SourceName ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	ULONG a_SourceIpAddress ,
	ULONG a_DestinationIpAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask
)
{
	BOOL t_Status = TRUE ;

	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	LONG t_PropertyFlavour = 0 ;
	VARTYPE t_PropertyType = 0 ;

	ULONG t_InterfaceIndex = 0 ;

	HRESULT t_Result = a_HopObject->Get (

		L"m_GatewayInterfaceIndex" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		t_Status = GetClassObject ( L"HopToGatewayInterfaceTable_Assoc" ) ;
		if ( t_Status )
		{
			t_InterfaceIndex = t_Variant.lVal ;

			WbemNamespacePath *t_Path = m_Provider->GetNamespacePath () ;
			wchar_t *t_Namespace = t_Path->GetNamespacePath () ;
			wchar_t *t_String1 = UnicodeStringAppend ( t_Namespace, L"\\" ) ;
			wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , a_SourceName ) ;
			delete [] t_String1 ;
			wchar_t *t_String3 = UnicodeStringAppend ( t_String2 , L":" ) ;
			delete [] t_String2 ;
			wchar_t *t_String4 = UnicodeStringAppend ( t_String3 , L"MS_SNMP_RFC1213_MIB_ifTable.ifIndex =" ) ;
			delete [] t_String3 ;
			SnmpIntegerType t_InterfaceIndexType ( a_InterfaceIndex , NULL ) ;
			wchar_t *t_String5 = t_InterfaceIndexType.GetStringValue () ;
			wchar_t *t_String6 = UnicodeStringAppend ( t_String4 , t_String5 ) ;
			delete [] t_String5 ;
			
			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{						
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_String6 ) ;
					
					t_Result = t_Association->Put ( L"m_InterfaceTable" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}
				}

				t_Association->Release () ;
			}

			delete [] t_String6 ;
		}
	}

	VariantClear ( &t_Variant ) ;

	return t_Status ;

}

BOOL ExecQueryAsyncEventObject :: All_HopToSubnetwork_Association ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath , 
	KeyRef *a_SourceKey , 
	KeyRef *DestinationKey ,
	IWbemServices *a_Proxy ,
	IWbemClassObject *a_HopObject ,
	wchar_t *a_SourceName ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	ULONG a_SourceIpAddress ,
	ULONG a_DestinationIpAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask
)
{
	BOOL t_Status ;

	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	LONG t_PropertyFlavour = 0 ;
	VARTYPE t_PropertyType = 0 ;

	HRESULT t_Result = a_HopObject->Get (

		L"m_IpSubnetAddress" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		t_Status = GetClassObject ( L"HopToSubnetwork_Assoc" ) ;
		if ( t_Status )
		{
			wchar_t *t_SubnetAddress = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;

			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_String1 = UnicodeStringAppend ( L"Subnetwork.m_IpSubnetAddress=\"" , a_SubnetAddress ) ;
					wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\"" ) ;
					delete [] t_String1 ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_String2 ) ;
					delete t_String2 ;

					t_Result = t_Association->Put ( L"m_Subnetwork" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;
				}

				t_Association->Release () ;

			}

			delete [] t_SubnetAddress ;
		}
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: All_HopToGatewaySubnetwork_Association ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath , 
	KeyRef *a_SourceKey , 
	KeyRef *DestinationKey ,
	IWbemServices *a_Proxy ,
	IWbemClassObject *a_HopObject ,
	wchar_t *a_SourceName ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	ULONG a_SourceIpAddress ,
	ULONG a_DestinationIpAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask
)
{
	BOOL t_Status ;

	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	LONG t_PropertyFlavour = 0 ;
	VARTYPE t_PropertyType = 0 ;

	HRESULT t_Result = a_HopObject->Get (

		L"m_GatewayIpSubnetAddress" ,
		0 ,
		& t_Variant ,
		& t_PropertyType ,
		& t_PropertyFlavour
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		t_Status = GetClassObject ( L"HopToGatewaySubnetwork_Assoc" ) ;
			if ( t_Status )
			{
			wchar_t *t_SubnetAddress = UnicodeStringDuplicate ( t_Variant.bstrVal ) ;

			IWbemClassObject *t_Association = NULL ;

			HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				t_Result = t_Association->Put ( L"m_Hop" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_String1 = UnicodeStringAppend ( L"Subnetwork.m_IpSubnetAddress=\"" , a_SubnetAddress ) ;
					wchar_t *t_String2 = UnicodeStringAppend ( t_String1 , L"\"" ) ;
					delete [] t_String1 ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_String2 ) ;
					delete t_String2 ;

					t_Result = t_Association->Put ( L"m_Subnetwork" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;
				}

				t_Association->Release () ;

			}

			delete [] t_SubnetAddress ;
		}
	}

	return t_Status ;
}


BOOL ExecQueryAsyncEventObject :: ProxyToWin32Service_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey 
) 
{
	BOOL t_Status = TRUE ;
	IWbemServices *t_Server = m_Provider->GetServer () ;

	IEnumWbemClassObject *t_Enumeration = NULL ;
	HRESULT t_Result = t_Server->CreateInstanceEnum (

		L"Win32Service" ,
		0 ,
		NULL ,
		& t_Enumeration
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Service = NULL ;
		ULONG t_Returned = 0 ;
		t_Enumeration->Reset () ;
		while ( ( t_Result = t_Enumeration->Next ( -1, 1 , &t_Service, & t_Returned ) ) == WBEM_NO_ERROR ) 
		{
			IWbemClassObject *t_Association = NULL ;

			t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{

				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				HRESULT t_Result = t_Association->Put ( L"m_Proxy" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				LONG t_PropertyFlavour = 0 ;
				VARTYPE t_PropertyType = 0 ;

				t_Result = t_Service->Get (

					L"__PATH" ,
					0 ,
					& t_Variant ,
					& t_PropertyType ,
					& t_PropertyFlavour
				) ;
					
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					BSTR t_ServicePath = SysAllocString ( t_Variant.bstrVal ) ;
					VariantClear ( & t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = t_ServicePath  ;

					t_Result = t_Association->Put ( L"m_Win32Service" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{

						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;

					t_Association->Release () ;
				}
			}

			t_Service->Release () ;
		}
	}

	t_Server->Release () ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_ProxyToWin32Service ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 1 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"ProxySystem" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				if ( t_Key1 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_Name" ) == 0 )
					{
						if ( t_Key1->m_vValue.vt == VT_BSTR ) 
						{
							t_Status = ProxyToWin32Service_Association ( a_ErrorObject , a_ObjectPath , t_Key1 ) ;
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: ProxyToProcessStats_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey 
) 
{
	BOOL t_Status = TRUE ;
	IWbemServices *t_Server = m_Provider->GetServer () ;

	IEnumWbemClassObject *t_Enumeration = NULL ;
	HRESULT t_Result = t_Server->CreateInstanceEnum (

		L"NT_Process_Statistics" ,
		0 ,
		NULL ,
		& t_Enumeration
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Service = NULL ;
		ULONG t_Returned = 0 ;
		t_Enumeration->Reset () ;
		while ( ( t_Result = t_Enumeration->Next ( -1 , 1 , &t_Service, & t_Returned ) ) == WBEM_NO_ERROR ) 
		{
			IWbemClassObject *t_Association = NULL ;

			t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{

				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				HRESULT t_Result = t_Association->Put ( L"m_Proxy" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				LONG t_PropertyFlavour = 0 ;
				VARTYPE t_PropertyType = 0 ;

				t_Result = t_Service->Get (

					L"__PATH" ,
					0 ,
					& t_Variant ,
					& t_PropertyType ,
					& t_PropertyFlavour
				) ;
					
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					BSTR t_ServicePath = SysAllocString ( t_Variant.bstrVal ) ;
					VariantClear ( & t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = t_ServicePath  ;

					t_Result = t_Association->Put ( L"m_ProcessStats" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{

						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;

					t_Association->Release () ;
				}
			}

			t_Service->Release () ;
		}
	}

	t_Server->Release () ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_ProxyToProcessStats ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 1 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"ProxySystem" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				if ( t_Key1 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_Name" ) == 0 )
					{
						if ( t_Key1->m_vValue.vt == VT_BSTR ) 
						{
							t_Status = ProxyToProcessStats_Association ( a_ErrorObject , a_ObjectPath , t_Key1 ) ;
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: ProxyToNetworkStats_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey 
) 
{
	BOOL t_Status = TRUE ;
	IWbemServices *t_Server = m_Provider->GetServer () ;

	IEnumWbemClassObject *t_Enumeration = NULL ;
	HRESULT t_Result = t_Server->CreateInstanceEnum (

		L"NT_Network_Segment_Statistics" ,
		0 ,
		NULL ,
		& t_Enumeration
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Service = NULL ;
		ULONG t_Returned = 0 ;
		t_Enumeration->Reset () ;
		while ( ( t_Result = t_Enumeration->Next ( -1 , 1 , &t_Service, & t_Returned ) ) == WBEM_NO_ERROR ) 
		{
			IWbemClassObject *t_Association = NULL ;

			t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{

				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				HRESULT t_Result = t_Association->Put ( L"m_Proxy" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				LONG t_PropertyFlavour = 0 ;
				VARTYPE t_PropertyType = 0 ;

				t_Result = t_Service->Get (

					L"__PATH" ,
					0 ,
					& t_Variant ,
					& t_PropertyType ,
					& t_PropertyFlavour
				) ;
					
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					BSTR t_ServicePath = SysAllocString ( t_Variant.bstrVal ) ;
					VariantClear ( & t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = t_ServicePath  ;

					t_Result = t_Association->Put ( L"m_NetworkStats" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{

						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;

					t_Association->Release () ;
				}
			}

			t_Service->Release () ;
		} 
	}

	t_Server->Release () ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_ProxyToNetworkStats ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 1 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"ProxySystem" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				if ( t_Key1 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_Name" ) == 0 )
					{
						if ( t_Key1->m_vValue.vt == VT_BSTR ) 
						{
							t_Status = ProxyToNetworkStats_Association ( a_ErrorObject , a_ObjectPath , t_Key1 ) ;
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: ProxyToInterfaceStats_Association ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath ,
	KeyRef *a_SourceKey 
) 
{
	BOOL t_Status = TRUE ;
	IWbemServices *t_Server = m_Provider->GetServer () ;

	IEnumWbemClassObject *t_Enumeration = NULL ;
	HRESULT t_Result = t_Server->CreateInstanceEnum (

		L"NT_Network_Interface_Statistics" ,
		0 ,
		NULL ,
		& t_Enumeration
	) ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Service = NULL ;
		ULONG t_Returned = 0 ;
		t_Enumeration->Reset () ;
		while ( ( t_Result = t_Enumeration->Next ( -1 , 1 , &t_Service, & t_Returned ) ) == WBEM_NO_ERROR ) 
		{
			IWbemClassObject *t_Association = NULL ;

			t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Association ) ;
			if ( t_Status = SUCCEEDED ( t_Result ) )
			{

				VARIANT t_Variant ;
				VariantInit ( &t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( a_ObjectPath ) ;

				HRESULT t_Result = t_Association->Put ( L"m_Proxy" , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				LONG t_PropertyFlavour = 0 ;
				VARTYPE t_PropertyType = 0 ;

				t_Result = t_Service->Get (

					L"__PATH" ,
					0 ,
					& t_Variant ,
					& t_PropertyType ,
					& t_PropertyFlavour
				) ;
					
				if ( t_Status = SUCCEEDED ( t_Result ) )
				{
					BSTR t_ServicePath = SysAllocString ( t_Variant.bstrVal ) ;
					VariantClear ( & t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = t_ServicePath  ;

					t_Result = t_Association->Put ( L"m_InterfaceStats" , 0 , & t_Variant , 0 ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{

						m_NotificationHandler->Indicate ( 1 , & t_Association ) ;								
					}

					VariantClear ( & t_Variant ) ;

					t_Association->Release () ;
				}
			}

			t_Service->Release () ;
		}
	}

	t_Server->Release () ;

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Dispatch_ProxyToInterfaceStats ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t *a_ObjectPath 
)
{
	BOOL t_Status = TRUE ;

	ParsedObjectPath *t_ParsedObjectPath ;
	CObjectPathParser t_ObjectPathParser ;

	t_Status = ! t_ObjectPathParser.Parse ( a_ObjectPath , &t_ParsedObjectPath ) ;
	if ( t_Status )
	{
		if ( t_ParsedObjectPath->m_paKeys && ( t_ParsedObjectPath->m_dwNumKeys == 1 ) )
		{
			if ( wcscmp ( t_ParsedObjectPath->m_pClass , L"ProxySystem" ) == 0 )
			{
				KeyRef *t_Key1 = t_ParsedObjectPath->m_paKeys [ 0 ] ;
				if ( t_Key1 )
				{
					if ( wcscmp ( t_Key1->m_pName , L"m_Name" ) == 0 )
					{
						if ( t_Key1->m_vValue.vt == VT_BSTR ) 
						{
							t_Status = ProxyToInterfaceStats_Association ( a_ErrorObject , a_ObjectPath , t_Key1 ) ;
						}
						else
						{
							t_Status = FALSE ;
						}
					}
					else
					{
						t_Status = FALSE ;
					}
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		delete t_ParsedObjectPath ;
	}

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrtprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpTraceRouteProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"
#include "guids.h"


/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpTraceRouteProv ::CImpTraceRouteProv
// CImpTraceRouteProv ::~CImpTraceRouteProv
//
//***************************************************************************

SnmpDefaultThreadObject *CImpTraceRouteProv :: s_DefaultThreadObject = NULL ;
SnmpDefaultThreadObject *CImpTraceRouteProv :: s_BackupThreadObject = NULL ;

ProviderStore CImpTraceRouteProv :: s_ProviderStore ;

CImpTraceRouteProv ::CImpTraceRouteProv ()
{
	m_ReferenceCount = 0 ;
	 
    InterlockedIncrement ( & CTraceRouteLocatorClassFactory :: s_ObjectsInProgress ) ;

/*
 * Implementation
 */

	m_Initialised = FALSE ;
	m_Parent = NULL ;
	m_Server = NULL ;
	m_Namespace = NULL ;

	m_NotificationClassObject = NULL ;
	m_ExtendedNotificationClassObject = NULL ;
	m_GetNotifyCalled = FALSE ;
	m_GetExtendedNotifyCalled = FALSE ;

	m_localeId = NULL ;

	m_TopNTableProv = NULL ;

}

CImpTraceRouteProv ::~CImpTraceRouteProv(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CTraceRouteLocatorClassFactory :: s_ObjectsInProgress ) ;

	delete [] m_localeId ;
	delete [] m_Namespace ;

	if ( m_TopNTableProv )
		delete m_TopNTableProv ;

	if ( m_Parent )
		m_Parent->Release () ;

	if ( m_Server ) 
		m_Server->Release () ;

	if ( m_NotificationClassObject )
		m_NotificationClassObject->Release () ;

	if ( m_ExtendedNotificationClassObject )
		m_ExtendedNotificationClassObject->Release () ;

}

//***************************************************************************
//
// CImpTraceRouteProv ::QueryInterface
// CImpTraceRouteProv ::AddRef
// CImpTraceRouteProv ::Release
//
// Purpose: IUnknown members for CImpTraceRouteProv object.
//***************************************************************************

STDMETHODIMP CImpTraceRouteProv ::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpTraceRouteProv ::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpTraceRouteProv ::Release(void)
{
	LONG t_Ref ;
	if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

void CImpTraceRouteProv :: SetParent ( IWbemServices *a_Parent ) 
{
	m_Parent = a_Parent ; 
	m_Parent->AddRef () ; 
}

void CImpTraceRouteProv :: SetServer ( IWbemServices *a_Server ) 
{
	m_Server = a_Server ; 
	m_Server->AddRef () ; 
}

IWbemServices *CImpTraceRouteProv :: GetServer () 
{ 
	if ( m_Server )
		m_Server->AddRef () ; 

	return m_Server ; 
}

IWbemServices *CImpTraceRouteProv :: GetParent () 
{ 
	if ( m_Parent )
		m_Parent->AddRef () ;

	return ( IWbemServices * ) m_Parent ; 
}

void CImpTraceRouteProv :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpTraceRouteProv :: GetNamespace () 
{
	return m_Namespace ; 
}

void CImpTraceRouteProv :: SetNamespace ( wchar_t *a_Namespace ) 
{
	m_Namespace = UnicodeStringDuplicate ( a_Namespace ) ; 
}

void CImpTraceRouteProv :: EnableRmonPolling () 
{
	IWbemServices *t_Server = GetServer () ;
	m_TopNTableProv = new TopNTableProv ( t_Server , s_ProviderStore ) ;
	t_Server->Release () ;
}

IWbemClassObject *CImpTraceRouteProv :: GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_NotificationClassObject )
	{
		m_NotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateNotificationObject ( a_errorObject ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_NotificationClassObject->AddRef () ;
		}

	}

	return m_NotificationClassObject ; 
}

IWbemClassObject *CImpTraceRouteProv :: GetExtendedNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_ExtendedNotificationClassObject )
	{
		m_ExtendedNotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateExtendedNotificationObject ( a_errorObject ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_ExtendedNotificationClassObject->AddRef () ;
		}
	}

	return m_ExtendedNotificationClassObject ; 
}

BOOL CImpTraceRouteProv :: CreateExtendedNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject 
)
{
	if ( m_GetExtendedNotifyCalled )
	{
		if ( m_ExtendedNotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetExtendedNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	IWbemCallResult *t_ErrorObject = NULL ;
	
	HRESULT t_Result = m_Server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		NULL,
		& m_ExtendedNotificationClassObject ,
		& t_ErrorObject 
	) ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;

		m_ExtendedNotificationClassObject = NULL ;
	}

	return t_Status ;
}

BOOL CImpTraceRouteProv :: CreateNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject 
)
{
	if ( m_GetNotifyCalled )
	{
		if ( m_NotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	IWbemCallResult *t_ErrorObject = NULL ;

	HRESULT t_Result = m_Server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		NULL,
		& m_NotificationClassObject ,
		& t_ErrorObject 
	) ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
	}

	return t_Status ;
}

BOOL CImpTraceRouteProv ::AttachServer ( 

	WbemSnmpErrorObject &a_errorObject , 
	BSTR ObjectPath, 
	IWbemContext FAR* pCtx,
	long lFlags, 
	IWbemServices FAR* FAR* ppNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	BOOL t_Status = TRUE ;

	IWbemLocator *t_Locator = NULL ;
	IWbemServices *t_Server = NULL ;

	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Locator->ConnectServer (

			ObjectPath ,
			NULL,
			NULL,
			NULL ,
			0 ,
			NULL,
			NULL,
			( IWbemServices ** ) & t_Server 
		) ;

		if ( t_Result == WBEM_NO_ERROR )
		{
// Mark this interface pointer as "critical"

			IWbemConfigure* t_Configure;
			t_Result = t_Server->QueryInterface ( IID_IWbemConfigure , ( void ** ) & t_Configure ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Configure->SetConfigurationFlags(WBEM_CONFIGURATION_FLAG_CRITICAL_USER);
				t_Configure->Release();

				( ( * ( CImpTraceRouteProv ** ) ppNewContext ) )->SetServer ( t_Server ) ;

				t_Status = AttachParentServer ( 

					a_errorObject , 
					ObjectPath ,
					pCtx ,
					lFlags, 
					ppNewContext, 
					ppErrorObject
				) ;
			}
			else
			{
				t_Status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to configure" ) ;
			}

			t_Server->Release () ;
		}
		else
		{
			t_Status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace" ) ;
		}

		t_Locator->Release () ;
	}
	else
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	return t_Status ;
}

BOOL CImpTraceRouteProv ::AttachParentServer ( 

	WbemSnmpErrorObject &a_errorObject , 
	BSTR ObjectPath, 
	IWbemContext FAR* pCtx,
	long lFlags, 
	IWbemServices FAR* FAR* ppNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	BOOL t_Status = TRUE ;

	CImpTraceRouteProv *propertyProvider = * ( CImpTraceRouteProv ** ) ppNewContext ;

	IWbemLocator *t_Locator = NULL ;
	IWbemServices *t_Server = NULL ;

// Get Parent Namespace Path

	WbemNamespacePath *t_NamespacePath = propertyProvider->GetNamespacePath () ;

	ULONG t_Count = t_NamespacePath->GetCount () ;
	wchar_t *t_Path = NULL ;

	if ( t_NamespacePath->GetServer () )
	{
		t_Path = UnicodeStringDuplicate ( L"\\\\" ) ;
		wchar_t *t_ConcatPath = UnicodeStringAppend ( t_Path , t_NamespacePath->GetServer () ) ;
		delete [] t_Path ;
		t_Path = t_ConcatPath ;
	}

	if ( ! t_NamespacePath->Relative () )
	{
		wchar_t *t_ConcatPath = UnicodeStringAppend ( t_Path , L"\\" ) ;
		delete [] t_Path ;
		t_Path = t_ConcatPath ;
	}

	ULONG t_PathIndex = 0 ;		
	wchar_t *t_PathComponent ;
	t_NamespacePath->Reset () ;
	while ( ( t_PathIndex < t_Count - 1 ) && ( t_PathComponent = t_NamespacePath->Next () ) ) 
	{
		wchar_t *t_ConcatPath = UnicodeStringAppend ( t_Path , t_PathComponent ) ;
		delete [] t_Path ;
		t_Path = t_ConcatPath ;
		if ( t_PathIndex < t_Count - 2 )
		{
			t_ConcatPath = UnicodeStringAppend ( t_Path , L"\\" ) ;
			delete [] t_Path ;
			t_Path = t_ConcatPath ;
		}

		t_PathIndex ++ ;
	}

// Get Name of child namespace relative to parent namespace

	if ( t_PathComponent = t_NamespacePath->Next () )
	{
		( ( * ( CImpTraceRouteProv ** ) ppNewContext ) )->SetNamespace ( t_PathComponent ) ; 
	}

// Connect to parent namespace
	
	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemServices *t_Parent = NULL ;

		t_Result = t_Locator->ConnectServer (

			t_Path ,
			NULL,
			NULL,
			NULL ,
			0 ,
			NULL,
			NULL,
			( IWbemServices ** ) & t_Parent 
		) ;

		if ( t_Result == WBEM_NO_ERROR )
		{
// Mark this interface pointer as "critical"

			
			IWbemConfigure* t_Configure ;
			t_Result = t_Parent->QueryInterface ( IID_IWbemConfigure , (void ** ) & t_Configure ) ;
			if( SUCCEEDED ( t_Result ) )
			{
				t_Configure->SetConfigurationFlags ( WBEM_CONFIGURATION_FLAG_CRITICAL_USER ) ;
				t_Configure->Release() ;

				( ( * ( CImpTraceRouteProv ** ) ppNewContext ) )->SetParent ( t_Parent ) ;
			}
			else
			{
				t_Status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to configure" ) ;
			}

			t_Parent->Release () ;
		}
		else
		{
			t_Status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace's parent namespace" ) ;
		}

		t_Locator->Release () ;
	}
	else
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	delete [] t_Path ;

	return t_Status ;
}


/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpTraceRouteProv ::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* ppNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	BOOL t_Status = TRUE ;
	HRESULT t_Result = S_OK ;

	WbemSnmpErrorObject t_ErrorObject ;

	if ( ppErrorObject )
		*ppErrorObject = NULL ;

	wchar_t *t_OpenPath = NULL ;

	if ( m_Initialised )
	{
		WbemNamespacePath t_OpenNamespacePath ( m_NamespacePath ) ;

		WbemNamespacePath t_ObjectPathArg ;
		if ( t_ObjectPathArg.SetNamespacePath ( ObjectPath ) )
		{
			if ( t_ObjectPathArg.Relative () )
			{
				if ( t_OpenNamespacePath.ConcatenatePath ( t_ObjectPathArg ) )
				{
					t_OpenPath = t_OpenNamespacePath.GetNamespacePath () ;
				}
				else
				{
					t_Status = FALSE ;
					t_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
					t_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					t_ErrorObject.SetMessage ( L"Path specified was not relative to current namespace" ) ;
				}
			}
			else
			{
				t_Status = FALSE ;
				t_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
				t_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				t_ErrorObject.SetMessage ( L"Path specified was not relative to current namespace" ) ;
			}
		}
	}
	else
	{
		t_OpenPath = UnicodeStringDuplicate ( ObjectPath ) ;
	}

	if ( t_Status )
	{
		t_Result = CoCreateInstance (
  
			CLSID_CTraceRouteProvClassFactory ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
			IID_IWbemServices ,
			( void ** ) ppNewContext
		);

		if ( SUCCEEDED ( t_Result ) )
		{
			CImpTraceRouteProv *t_Provider = * ( CImpTraceRouteProv ** ) ppNewContext ;

			if ( t_Provider->GetNamespacePath ()->SetNamespacePath ( t_OpenPath ) )
			{
				t_Status = AttachServer ( 

					t_ErrorObject ,
					t_OpenPath , 
					pCtx,
					lFlags, 
					ppNewContext, 
					ppErrorObject
				) ;

				if ( t_Status )
				{
					t_Provider->EnableRmonPolling () ;
					t_Status = t_Provider->GetTopNTableProv ()->IsValid () ;
				}
			}
		}
		else
		{
			t_Status = FALSE ;
			t_ErrorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			t_ErrorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			t_ErrorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemServices" ) ;
		}
	}

	delete [] t_OpenPath ;

	t_Result = t_ErrorObject.GetWbemStatus () ;
	
	return t_Result ;
}

HRESULT CImpTraceRouteProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"CImpTraceRouteProv::GetObjectAsync ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Asynchronous GetObjectByPath object
 */

	GetObjectAsyncEventObject *t_AsyncEvent = new GetObjectAsyncEventObject ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

	if ( CImpTraceRouteProv :: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv :: s_BackupThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}
	else
	{
		CImpTraceRouteProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}


	t_AsyncEvent->Exec () ;

/*
 *	Wait for worker object to complete processing
 */

	if ( t_AsyncEvent->Wait ( FALSE  ) )
	{
		t_Result = t_AsyncEvent->GetErrorObject ().GetWbemStatus () ;
	}
	else
	{
		t_Result = WBEM_ERROR_CRITICAL_ERROR ;
	}

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"Returning from CImpTraceRouteProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		t_Result 
	) ;
)

	return t_Result ;
}

HRESULT CImpTraceRouteProv :: PutClass ( 
		
	IWbemClassObject FAR* pClass , 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pClass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"CImpTraceRouteProv::PutClassAsync ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous UpdateInstance object
 */

	PutClassAsyncEventObject *t_AsyncEvent = new PutClassAsyncEventObject ( this , pClass , lFlags , pHandler , pCtx ) ;

	if ( CImpTraceRouteProv :: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv :: s_BackupThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}
	else
	{
		CImpTraceRouteProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}


	t_AsyncEvent->Exec () ;

/*
 *	Wait for worker object to complete processing
 */

	if ( t_AsyncEvent->Wait ( FALSE  ) )
	{
		t_Result = t_AsyncEvent->GetErrorObject ().GetWbemStatus () ;
	}
	else
	{
		t_Result = WBEM_ERROR_CRITICAL_ERROR ;
	}

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"Returning from CImpTraceRouteProv::PutClasseAsync () with Result = (%lx)" ,
		t_Result 
	) ;
)

	return t_Result ;

}

HRESULT CImpTraceRouteProv :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpTraceRouteProv :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	CreateClassEnumAsyncEventObject *t_AsyncEvent = new CreateClassEnumAsyncEventObject ( this , Superclass , lFlags , pHandler , pCtx ) ;

	if ( CImpTraceRouteProv :: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv :: s_BackupThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}
	else
	{
		CImpTraceRouteProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}


	t_AsyncEvent->Exec () ;

/*
 *	Wait for worker object to complete processing
 */

	if ( t_AsyncEvent->Wait ( FALSE  ) )
	{
		t_Result = t_AsyncEvent->GetErrorObject ().GetWbemStatus () ;
		if ( SUCCEEDED ( t_Result ) )
		{
		}
	}
	else
	{
		t_Result = WBEM_ERROR_CRITICAL_ERROR ;
	}

	return t_Result ;
}

HRESULT CImpTraceRouteProv :: PutInstance (

    IWbemClassObject FAR *pInstance,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInstance, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"CImpTraceRouteProv::PutInstanceAsync ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous UpdateInstance object
 */

	PutInstanceAsyncEventObject *t_AsyncEvent = new PutInstanceAsyncEventObject ( this , pInstance , lFlags , pHandler , pCtx ) ;

	if ( CImpTraceRouteProv :: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv :: s_BackupThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}
	else
	{
		CImpTraceRouteProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}

	t_AsyncEvent->Exec () ;

/*
 *	Wait for worker object to complete processing
 */

	if ( t_AsyncEvent->Wait ( FALSE  ) )
	{
		t_Result = t_AsyncEvent->GetErrorObject ().GetWbemStatus () ;
	}
	else
	{
		t_Result = WBEM_ERROR_CRITICAL_ERROR ;
	}

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"Returning from CImpTraceRouteProv::PutInstanceAsync () with Result = (%lx)" ,
		t_Result 
	) ;
)

	return t_Result ;
}

HRESULT CImpTraceRouteProv :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpTraceRouteProv :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"CImpTraceRouteProv::CreateInstanceEnumAsync ( (%s) )" ,
		Class
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	CreateInstanceEnumAsyncEventObject *t_AsyncEvent = new CreateInstanceEnumAsyncEventObject ( this , Class , lFlags , pHandler , pCtx ) ;

	if ( CImpTraceRouteProv :: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv :: s_BackupThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}
	else
	{
		CImpTraceRouteProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}

	t_AsyncEvent->Exec () ;

/*
 *	Wait for worker object to complete processing
 */

	if ( t_AsyncEvent->Wait ( FALSE  ) )
	{
		t_Result = t_AsyncEvent->GetErrorObject ().GetWbemStatus () ;
		if ( SUCCEEDED ( t_Result ) )
		{
		}
	}
	else
	{
		t_Result = WBEM_ERROR_CRITICAL_ERROR ;
	}

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"ReturningFrom CImpTraceRouteProv::CreateInstanceEnum ( (%s) ) with Result = (%lx)" ,
		Class ,
		t_Result
	) ;
)
	return t_Result ;

}

HRESULT CImpTraceRouteProv :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpTraceRouteProv :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		L"\r\n"
	) ;


	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"CImpTraceRouteProv::ExecQueryAsync ( (%s),(%s) )" ,
		QueryFormat ,
		Query 
	) ;
)

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	ExecQueryAsyncEventObject *t_AsyncEvent = new ExecQueryAsyncEventObject ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;

	if ( CImpTraceRouteProv :: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv :: s_BackupThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}
	else
	{
		CImpTraceRouteProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;
	}


	t_AsyncEvent->Exec() ;

/*
 *	Wait for worker object to complete processing
 */

	if ( t_AsyncEvent->Wait ( FALSE  ) )
	{
		t_Result = t_AsyncEvent->GetErrorObject ().GetWbemStatus () ;
		if ( SUCCEEDED ( t_Result ) )
		{
		}
	}
	else
	{
		t_Result = WBEM_ERROR_CRITICAL_ERROR ;
	}

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog.Write (  

		__FILE__,__LINE__,
		L"Returning from CImpTraceRouteProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" ,
		QueryFormat,
		Query,
		t_Result 
	) ;
)

	return t_Result ;
}

HRESULT CImpTraceRouteProv :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpTraceRouteProv :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpTraceRouteProv :: ExecMethod( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpTraceRouteProv :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpTraceRouteLocator::CImpTraceRouteLocator
// CImpTraceRouteLocator::~CImpTraceRouteLocator
//
//***************************************************************************

CImpTraceRouteLocator::CImpTraceRouteLocator ()
{
	m_ReferenceCount = 0 ; 

/* 
 * Place code in critical section
 */

    InterlockedIncrement ( & CTraceRouteLocatorClassFactory :: s_ObjectsInProgress ) ;
}

CImpTraceRouteLocator::~CImpTraceRouteLocator(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CTraceRouteLocatorClassFactory :: s_ObjectsInProgress ) ;
}

//***************************************************************************
//
// CImpTraceRouteLocator::QueryInterface
// CImpTraceRouteLocator::AddRef
// CImpTraceRouteLocator::Release
//
// Purpose: IUnknown members for CImpTraceRouteLocator object.
//***************************************************************************

STDMETHODIMP CImpTraceRouteLocator::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemLocator )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpTraceRouteLocator::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpTraceRouteLocator::Release(void)
{
	LONG t_Ref ;
	if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

STDMETHODIMP_( HRESULT ) CImpTraceRouteLocator :: ConnectServer ( 

	BSTR a_Namespace, 
	BSTR a_User, 
	BSTR a_Password, 
	BSTR a_lLocaleId, 
	long a_lFlags, 
	BSTR Authority,
	IWbemContext FAR *pCtx ,
	IWbemServices FAR* FAR* a_Service
) 
{
	if ( ! CImpTraceRouteProv :: s_DefaultThreadObject )
	{
 		CImpTraceRouteProv :: s_DefaultThreadObject = new SnmpDefaultThreadObject ( "s_DefaultTraceRoute" ) ;
 		CImpTraceRouteProv :: s_BackupThreadObject = new SnmpDefaultThreadObject ( "s_BackupTraceRoute" ) ;
	}

	IWbemServices FAR* t_Locator ;

	HRESULT t_Result = CoCreateInstance (
  
		CLSID_CTraceRouteProvClassFactory ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemServices ,
		( void ** ) & t_Locator
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemCallResult *t_ErrorObject = NULL ;

		t_Result = t_Locator->OpenNamespace (

			a_Namespace ,
			0 ,
			pCtx,
			( IWbemServices ** ) a_Service ,
			&t_ErrorObject 
		) ;

		if ( t_Result == WBEM_NO_ERROR )
		{
/* 
 * Connected to OLE MS Server
 */

			((CImpTraceRouteProv *)*a_Service)->SetLocaleId ( a_lLocaleId ) ;
		}
		else
		{
/*
 *	Failed to connect to OLE MS Server.
 */
		}


		if ( t_ErrorObject )
			t_ErrorObject->Release () ;

		t_Locator->Release () ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\include\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrtget.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS  Property Provider

//

//  Purpose: Implementation for the GetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL GetObjectAsyncEventObject :: Hop_Put ( 

	WbemSnmpErrorObject &a_ErrorObject , 
	IWbemClassObject *a_Hop ,
	wchar_t *a_SourceAddress ,
	wchar_t *a_DestinationAddress ,
	wchar_t *a_SubnetAddress ,
	wchar_t *a_SubnetMask ,
	ULONG a_InterfaceIndex ,
	wchar_t *a_GatewayAddress ,
	wchar_t *a_GatewaySubnetAddress ,
	wchar_t *a_GatewaySubnetMask ,
	ULONG a_GatewayInterfaceIndex ,
	wchar_t *a_DestinationRouteAddress ,
	wchar_t *a_DestinationRouteMask ,
	BOOL a_IpForwarding 
)
{
	VARIANT t_Variant ;
	VariantInit ( &t_Variant ) ;

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_SourceAddress ) ;

	HRESULT t_Result = a_Hop->Put ( L"m_IpAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_DestinationAddress ) ;

	t_Result = a_Hop->Put ( L"m_DestinationIpAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_SubnetMask ) ;

	t_Result = a_Hop->Put ( L"m_IpSubnetMask" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_SubnetAddress ) ;

	t_Result = a_Hop->Put ( L"m_IpSubnetAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_I4 ;
	t_Variant.lVal = a_InterfaceIndex ;

	t_Result = a_Hop->Put ( L"m_InterfaceIndex" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_DestinationRouteAddress ) ;

	t_Result = a_Hop->Put ( L"m_RouteAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_DestinationRouteMask ) ;

	t_Result = a_Hop->Put ( L"m_RouteMask" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewayAddress ) ;

	t_Result = a_Hop->Put ( L"m_GatewayIpAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewaySubnetMask ) ;

	t_Result = a_Hop->Put ( L"m_GatewayIpSubnetMask" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_GatewaySubnetAddress ) ;

	t_Result = a_Hop->Put ( L"m_GatewayIpSubnetAddress" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_I4 ;
	t_Variant.lVal = a_GatewayInterfaceIndex ;

	t_Result = a_Hop->Put ( L"m_GatewayInterfaceIndex" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	t_Variant.vt = VT_BOOL ;
	t_Variant.boolVal = a_IpForwarding ? VARIANT_TRUE : VARIANT_FALSE;

	t_Result = a_Hop->Put ( L"m_IpForwarding" , 0 , & t_Variant , 0 ) ;
	VariantClear ( &t_Variant ) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		return FALSE ;
	}

	return TRUE ;
}

BOOL GetObjectAsyncEventObject :: Hop_GetIpForwarding ( WbemSnmpErrorObject &a_ErrorObject , IWbemServices *t_Proxy , BOOL &a_IpForwarding )
{
	BOOL t_Status ;

	IWbemClassObject *t_IpForwardObject = NULL ;
	IWbemCallResult *t_ErrorObject = NULL ;

	HRESULT t_Result = t_Proxy->GetObject (

		L"MS_SNMP_RFC1213_MIB_ip=@" ,
		0 ,
		NULL,
		& t_IpForwardObject ,
		& t_ErrorObject
	) ;

	if ( t_ErrorObject ) 
		t_ErrorObject->Release () ;

	if ( t_Status = SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( &t_Variant ) ;

		LONG t_PropertyFlavour = 0 ;
		VARTYPE t_PropertyType = 0 ;

		HRESULT t_Result = t_IpForwardObject->Get (

			L"ipForwarding" ,
			0 ,
			& t_Variant ,
			& t_PropertyType ,
			& t_PropertyFlavour
		) ;
			
		if ( t_Status = SUCCEEDED ( t_Result ) )
		{
			a_IpForwarding = wcscmp ( t_Variant.bstrVal , L"forwarding" ) == 0 ;
		}

		VariantClear ( & t_Variant ) ;

		t_IpForwardObject->Release () ;
	}

	return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Hop_Get ( WbemSnmpErrorObject &a_ErrorObject , KeyRef *a_SourceKey , KeyRef *a_DestinationKey ) 
{
	BOOL t_Status ;

	wchar_t *t_SourceAddress = a_SourceKey->m_vValue.bstrVal ;
	wchar_t *t_DestinationAddress = a_DestinationKey->m_vValue.bstrVal ;

	wchar_t *t_SourceAddressName = GetHostNameByAddress ( a_SourceKey->m_vValue.bstrVal ) ;

	if ( t_SourceAddress && t_DestinationAddress )
	{
		SnmpIpAddressType t_SourceIpAddress ( t_SourceAddress ) ;
		SnmpIpAddressType t_DestinationIpAddress ( t_DestinationAddress ) ;

		if ( t_SourceIpAddress && t_DestinationIpAddress )
		{
			IWbemServices *t_Server = m_Provider->GetServer () ;
			IWbemServices *t_Proxy ;
			t_Status = GetProxy ( a_ErrorObject , t_Server , t_SourceAddressName , &t_Proxy ) ;
			if ( t_Status ) 
			{
				wchar_t *t_DestinationRouteAddress = 0 ;
				wchar_t *t_DestinationRouteMask = 0 ;
				wchar_t *t_SubnetAddress = 0 ;
				wchar_t *t_SubnetMask = 0 ;
				ULONG t_InterfaceIndex = 0 ;
				wchar_t *t_GatewayAddress = 0 ;
				wchar_t *t_GatewaySubnetAddress = 0 ;
				wchar_t *t_GatewaySubnetMask = 0 ;
				ULONG t_GatewayInterfaceIndex = 0 ;
				BOOL t_IpForwarding = FALSE ;

				t_Status = Hop_GetIpForwarding (

					a_ErrorObject , 
					t_Proxy , 
					t_IpForwarding 
				) ;
								
				t_Status = t_Status & CalculateRoute ( 

					a_ErrorObject ,
					t_Proxy ,
					t_SourceIpAddress.GetValue () ,
					t_DestinationIpAddress.GetValue () ,
					t_SubnetAddress ,
					t_SubnetMask ,
					t_InterfaceIndex ,
					t_GatewayAddress ,
					t_GatewaySubnetAddress ,
					t_GatewaySubnetMask ,
					t_GatewayInterfaceIndex ,
					t_DestinationRouteAddress ,
					t_DestinationRouteMask 
				) ;

				if ( t_Status )
				{
					SnmpIpAddressType t_HopDestinationType ( t_GatewayAddress ) ;
					wchar_t *t_HopDestination = t_HopDestinationType.GetStringValue () ;

					IWbemClassObject *t_Hop = NULL ;

					HRESULT t_Result = m_ClassObject->SpawnInstance ( 0 , & t_Hop ) ;
					if ( t_Status = SUCCEEDED ( t_Result ) )
					{
						t_Status = Hop_Put ( 

							a_ErrorObject , 
							t_Hop ,
							t_SourceAddress ,
							t_DestinationAddress ,
							t_SubnetAddress ,
							t_SubnetMask ,
							t_InterfaceIndex ,
							t_GatewayAddress ,
							t_GatewaySubnetAddress ,
							t_GatewaySubnetMask ,
							t_GatewayInterfaceIndex ,
							t_DestinationRouteAddress ,
							t_DestinationRouteMask ,
							t_IpForwarding 
						) ;
	
						if ( t_Status = SUCCEEDED ( t_Result ) )
						{
							m_NotificationHandler->Indicate ( 1 , & t_Hop ) ;								
						}
					}

					t_Hop->Release () ;
				}

				delete [] t_DestinationRouteAddress ;
				delete [] t_DestinationRouteMask ;
				delete [] t_GatewayAddress ;
				delete [] t_GatewaySubnetAddress ;
				delete [] t_GatewaySubnetMask ;
				delete [] t_SubnetAddress ;
				delete [] t_SubnetMask ;

				t_Proxy->Release () ;
			}

			t_Server->Release () ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	delete [] t_SourceAddressName ;

	return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_Hop ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status ;

	KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
	KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
	if ( t_Key1 && t_Key2 )
	{
		if ( wcscmp ( t_Key1->m_pName , L"m_IpAddress" ) == 0 )
		{
			if ( wcscmp ( t_Key2->m_pName , L"m_DestinationIpAddress" ) == 0 )
			{
				if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
				{
					t_Status = Hop_Get ( a_ErrorObject , t_Key1 , t_Key2 ) ;
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else if ( wcscmp ( t_Key2->m_pName , L"m_IpAddress" ) == 0 )
		{
			if ( wcscmp ( t_Key1->m_pName , L"m_DestinationIpAddress" ) == 0 )
			{
				if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
				{
					t_Status = Hop_Get ( a_ErrorObject , t_Key2 , t_Key1 ) ;
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL GetObjectAsyncEventObject :: ProvidedTopNTable_Get ( WbemSnmpErrorObject &a_ErrorObject , KeyRef *a_TopNReport , KeyRef *a_TopNIndex ) 
{
	BOOL t_Status = FALSE ;

	TopNTableProv *t_TopNTableProv = m_Provider->GetTopNTableProv () ;
	TopNCache *t_TopNCache = t_TopNTableProv->LockTopNCache () ;

	IWbemClassObject *t_TopNTableObject = NULL ;
	ULONG t_Key = TopNTableStore :: GetKey ( a_TopNReport->m_vValue.lVal , a_TopNIndex->m_vValue.lVal ) ;
	
	if ( t_TopNCache->Lookup ( t_Key , t_TopNTableObject ) )
	{
		IWbemClassObject* t_pClone = NULL;
		t_TopNTableObject->Clone(&t_pClone);
		m_NotificationHandler->Indicate ( 1 , & t_pClone ) ;
		t_pClone->Release();
		t_Status = TRUE ;
	}

	t_TopNTableProv->UnlockTopNCache () ;
	return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_ProvidedTopNTable ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status ;

	KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
	KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
	if ( t_Key1 && t_Key2 )
	{
		if ( wcscmp ( t_Key1->m_pName , L"hostTopNReport" ) == 0 )
		{
			if ( wcscmp ( t_Key2->m_pName , L"hostTopNIndex" ) == 0 )
			{
				if ( ( t_Key1->m_vValue.vt == VT_I4 ) && ( t_Key2->m_vValue.vt == VT_I4 ) )
				{
					t_Status = ProvidedTopNTable_Get ( a_ErrorObject , t_Key1 , t_Key2 ) ;
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else if ( wcscmp ( t_Key2->m_pName , L"hostTopNReport" ) == 0 )
		{
			if ( wcscmp ( t_Key1->m_pName , L"hostTopNIndex" ) == 0 )
			{
				if ( ( t_Key1->m_vValue.vt == VT_I4 ) && ( t_Key2->m_vValue.vt == VT_I4 ) )
				{
					t_Status = ProvidedTopNTable_Get ( a_ErrorObject , t_Key2 , t_Key1 ) ;
				}
				else
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Instantiate ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status = ! m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( t_Status )
	{
		t_Status = GetClassObject ( m_ParsedObjectPath->m_pClass ) ;
		if ( t_Status )
		{
			if ( wcscmp ( m_ParsedObjectPath->m_pClass , L"Hop" ) == 0 )
			{
				t_Status = 	Dispatch_Hop ( a_ErrorObject ) ;
				if ( t_Status ) 
					SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			}
			else if ( wcscmp ( m_ParsedObjectPath->m_pClass , L"MS_SNMP_RFC1271_MIB_ProvidedhostTopNTable" ) == 0 )
			{
				t_Status = 	Dispatch_ProvidedTopNTable ( a_ErrorObject ) ;
				if ( t_Status ) 
					SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			}
			else
			{
				ProcessComplete () ;
			}
		}
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

GetObjectAsyncEventObject :: GetObjectAsyncEventObject (

	CImpTraceRouteProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Context

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag ) ,
	m_Class ( NULL ) 
{
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;

	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->Indicate ( 1 , & t_NotifyStatus ) ;
		t_NotifyStatus->Release () ;
	}
}

void GetObjectAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	if ( CImpTraceRouteProv:: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv:: s_BackupThreadObject->ReapTask ( *this ) ;
	}
	else
	{
		CImpTraceRouteProv:: s_DefaultThreadObject->ReapTask ( *this ) ;
	}

	delete this ;
}

void GetObjectAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			BOOL t_Status = Instantiate ( m_ErrorObject ) ;
			if ( t_Status )
			{
				if ( GetState () == WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE )
				{
					ProcessComplete () ;
				}
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrtquery.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL ExecQueryAsyncEventObject :: DispatchAssocQuery ( 
													  
	WbemSnmpErrorObject &a_ErrorObject , 
	wchar_t **a_ObjectPath 
)
{
	*a_ObjectPath = NULL ;

	BOOL t_Status ;
	
	SQL_LEVEL_1_TOKEN *pArrayOfTokens = m_RPNExpression->pArrayOfTokens ;
	int nNumTokens = m_RPNExpression->nNumTokens ;

	if ( ! pArrayOfTokens )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( nNumTokens != 3 )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 0 ].dwPropertyFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 0 ].dwConstFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 0 ].nTokenType != SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 0 ].vConstValue.vt != VT_BSTR )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 0 ].vConstValue.bstrVal == NULL )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 1 ].dwPropertyFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 1 ].dwConstFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 1 ].nTokenType != SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 1 ].vConstValue.vt != VT_BSTR )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 1 ].vConstValue.bstrVal == NULL )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	if ( pArrayOfTokens [ 2 ].nTokenType != SQL_LEVEL_1_TOKEN :: TOKEN_OR )
	{
		t_Status = 0 ;
		return t_Status ;
	}

	*a_ObjectPath = UnicodeStringDuplicate ( pArrayOfTokens [ 0 ].vConstValue.bstrVal ) ;

	t_Status = GetClassObject ( m_RPNExpression->bsClassName ) ;
	if ( t_Status )
	{
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: DispatchQuery ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status ;

	if ( wcscmp ( m_RPNExpression->bsClassName , L"" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_AllAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"ConnectionSource" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_ConnectionSource ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"ConnectionDestination" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_ConnectionDestination ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"NextHop" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_NextHop ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"HopToProxySystem_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_HopToProxySystemAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"HopToInterfaceTable_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_HopToInterfaceTableAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"HopToGatewayInterfaceTable_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_HopToGatewayInterfaceTableAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"HopToInterfaceTable_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_HopToInterfaceTableAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"HopToSubnetwork_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_HopToSubnetworkAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"HopToGatewaySubnetwork_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_HopToGatewaySubnetworkAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"SubnetworkToTopN_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_SubnetworkToTopNAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"TopNToMacAddress_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_TopNToMacAddressAssoc ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"Proxy_Win32Service_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_ProxyToWin32Service ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"Proxy_ProcessStats_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_ProxyToProcessStats ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"Proxy_NetworkStats_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_ProxyToNetworkStats ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else if ( wcscmp ( m_RPNExpression->bsClassName , L"Proxy_InterfaceStats_Assoc" ) == 0 )
	{
		wchar_t *t_ObjectPath = NULL ;
		t_Status = DispatchAssocQuery ( a_ErrorObject , &t_ObjectPath ) ;
		if ( t_Status )
		{
			t_Status = Dispatch_ProxyToInterfaceStats ( a_ErrorObject , t_ObjectPath ) ;
			if ( t_Status )
				SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;

			delete [] t_ObjectPath ;
		}
	}
	else
	{
#if 1
		t_Status = TRUE ;
		SetState ( WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ) ;
#else
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
#endif
	}

	return t_Status ;
}

BOOL ExecQueryAsyncEventObject :: Instantiate ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status ;

	if ( wcsicmp ( m_QueryFormat , WBEM_QUERY_LANGUAGE_WQL ) == 0 )
	{
		t_Status = ! m_SqlParser.Parse ( & m_RPNExpression ) ;
		if ( t_Status )
		{
			t_Status = DispatchQuery ( a_ErrorObject ) ;			
		}
		else
		{
			t_Status = FALSE ;
			a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_ErrorObject.SetMessage ( L"SQL1 query was invalid" ) ;
		}
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY_TYPE ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		a_ErrorObject.SetMessage ( L"Query Language not supported" ) ;
	}

	return t_Status ;
}

ExecQueryAsyncEventObject :: ExecQueryAsyncEventObject (

	CImpTraceRouteProv *a_Provider , 
	BSTR a_QueryFormat , 
	BSTR a_Query , 
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Context

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag ) ,
	m_Query ( UnicodeStringDuplicate ( a_Query ) ) ,
	m_QueryFormat ( UnicodeStringDuplicate ( a_QueryFormat ) ) ,
	m_QuerySource ( m_Query ) , 
	m_SqlParser ( &m_QuerySource ) ,
	m_RPNExpression ( NULL ) 
{
}

ExecQueryAsyncEventObject :: ~ExecQueryAsyncEventObject () 
{
// Get Status object

	delete [] m_Query ;
	delete [] m_QueryFormat ;
	delete m_RPNExpression ;

	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->Indicate ( 1 , & t_NotifyStatus ) ;
		t_NotifyStatus->Release () ;
	}
}

void ExecQueryAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	if ( CImpTraceRouteProv:: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv:: s_BackupThreadObject->ReapTask ( *this ) ;
	}
	else
	{
		CImpTraceRouteProv:: s_DefaultThreadObject->ReapTask ( *this ) ;
	}

	delete this ;
}

void ExecQueryAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			BOOL t_Status = Instantiate ( m_ErrorObject ) ;
			if ( t_Status )
			{
				if ( GetState () == WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE )
				{
					ProcessComplete () ;
				}
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrtset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL PutInstanceAsyncEventObject :: Update ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status = FALSE ;

	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

PutInstanceAsyncEventObject :: PutInstanceAsyncEventObject (

	CImpTraceRouteProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Context

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag ) ,
	m_Class ( NULL ) ,
	m_Object ( a_Object ) 
{
	m_Object->AddRef () ;
}

PutInstanceAsyncEventObject :: ~PutInstanceAsyncEventObject () 
{
// Get Status object

	delete [] m_Class ;

	m_Object->Release () ;

	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->Indicate ( 1 , & t_NotifyStatus ) ;
		t_NotifyStatus->Release () ;
	}
}

void PutInstanceAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	if ( CImpTraceRouteProv:: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv:: s_BackupThreadObject->ReapTask ( *this ) ;
	}
	else
	{
		CImpTraceRouteProv:: s_DefaultThreadObject->ReapTask ( *this ) ;
	}

	delete this ;
}

void PutInstanceAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			BOOL t_Status = Update ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\include\classfac.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMPPropProvClassFactory_H
#define _SNMPPropProvClassFactory_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for both types of providers.

class CTraceRouteLocatorClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

    CTraceRouteLocatorClassFactory () ;
    ~CTraceRouteLocatorClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CTraceRouteProvClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;


    CTraceRouteProvClassFactory () ;
    ~CTraceRouteProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#endif // _SNMPPropProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\trrtupcl.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL PutClassAsyncEventObject :: Update ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status = FALSE ;

	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

PutClassAsyncEventObject :: PutClassAsyncEventObject (

	CImpTraceRouteProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Context

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag ) ,
	m_Class ( NULL ) ,
	m_Object ( a_Object ) 
{
	m_Object->AddRef () ;
}

PutClassAsyncEventObject :: ~PutClassAsyncEventObject () 
{
// Get Status object

	delete [] m_Class ;

	m_Object->Release () ;

	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->Indicate ( 1 , & t_NotifyStatus ) ;
		t_NotifyStatus->Release () ;
	}
}

void PutClassAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	if ( CImpTraceRouteProv:: s_DefaultThreadObject->GetActive () )
	{
		CImpTraceRouteProv:: s_BackupThreadObject->ReapTask ( *this ) ;
	}
	else
	{
		CImpTraceRouteProv:: s_DefaultThreadObject->ReapTask ( *this ) ;
	}

	delete this ;
}

void PutClassAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			BOOL t_Status = Update ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\wndtime.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "wndtime.h"
#include "rmon.h"

ProviderStore* TimerWindow::m_provMap = NULL;

TimerWindow::TimerWindow(ProviderStore* provMap)
{	
	m_provMap = provMap;
	m_IsValid = FALSE;
	WNDCLASS  w ;

	w.style            = CS_HREDRAW | CS_VREDRAW;
	w.lpfnWndProc      = TimerWindowProc;
	w.cbClsExtra       = 0;
	w.cbWndExtra       = 0;
	w.hInstance        = 0;
	w.hIcon            = NULL;
	w.hCursor          = NULL;
	w.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
	w.lpszMenuName     = NULL;
	w.lpszClassName    = L"TimerWindow";

	if (0 != RegisterClass(&w))
	{
		m_timerWindowHandle = CreateWindow (L"TimerWindow", L"TimerWindow", WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, 0, NULL);

		if (NULL != m_timerWindowHandle)
		{
			m_IsValid = ( 0 != SetTimer(m_timerWindowHandle, WINDOW_TIMER_ID, WINDOW_TIMER_STROBE_PERIOD, NULL) );
		}
	}
	else
	{
		m_timerWindowHandle = NULL;
	}
}


TimerWindow::~TimerWindow()
{
	if (NULL != m_timerWindowHandle)
	{
		if (m_IsValid)
		{
			KillTimer(m_timerWindowHandle, WINDOW_TIMER_ID);
		}
		
		DestroyWindow(m_timerWindowHandle);
	}
}

LONG CALLBACK TimerWindow::TimerWindowProc(
						HWND hWnd ,UINT message ,
						WPARAM wParam ,LPARAM lParam)
{
	LONG ret = 0 ;

	// send timer events to the Timer

	if ((message == WM_TIMER) && (wParam == WINDOW_TIMER_ID))
	{
		m_provMap->Lock();

		ProviderStore tmpProvMap;
		POSITION pos = m_provMap->GetStartPosition();

		while (pos)
		{
			ULONG rkey;
			TopNTableProv *provObject;
			m_provMap->GetNextAssoc(pos, rkey, provObject);
			tmpProvMap.SetAt(rkey, provObject);
		}

		m_provMap->Unlock();
		pos = tmpProvMap.GetStartPosition();

		while (pos)
		{
			ULONG rkey;
			TopNTableProv *provObject;
			tmpProvMap.GetNextAssoc(pos, rkey, provObject);
			provObject->Strobe();
		}

		tmpProvMap.RemoveAll();
	}
	else
	{
		ret = DefWindowProc(hWnd, message, wParam, lParam);
	}

	return ret;
}


BOOL ProviderStore::RegisterProviderWithTimer(TopNTableProv* prov)
{
	if (Lock())
	{
		if (m_timerThread == NULL)
		{
			m_timerThread = new TimerThread(this);
			m_timerThread->WaitForStartup();

			if (!m_timerThread->IsValid())
			{
				delete m_timerThread;
				m_timerThread = NULL;
				Unlock();
				return FALSE;
			}
		}

		SetAt((ULONG)(prov), prov);
		Unlock();
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

BOOL ProviderStore::UnregisterProviderWithTimer(TopNTableProv* prov)
{
	if (Lock())
	{
		RemoveKey((ULONG)(prov));

		if (IsEmpty())
		{
			delete m_timerThread;
			m_timerThread = NULL;
		}

		Unlock();
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

ProviderStore::ProviderStore()
{
	InitHashTable(23);
	m_timerThread = NULL;
}

ProviderStore::~ProviderStore()
{
	if (NULL != m_timerThread)
	{
		Lock();
		delete m_timerThread;
		RemoveAll();
		Unlock();
	}
}


TimerThread::TimerThread(ProviderStore* parent)
{
	m_wndTimer = NULL;
	m_parent = parent;
}

void TimerThread::Initialise()
{
	CoInitialize(NULL);
	m_wndTimer = new TimerWindow(m_parent);
}

void TimerThread::Uninitialise()
{
	delete m_wndTimer;
	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\include\rmon.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _RMON_H_
#define _RMON_H_

class RmonConfigData
{

private:

	ULONG m_pollPeriod;
	ULONG m_initialPeriod;
	ULONG m_dataOffset;
	ULONG m_dataRetry;
	ULONG m_nsize;
	ULONG m_index;
	BSTR m_statstype;


public:

	RmonConfigData(const ULONG poll = 5, const ULONG firstpoll = 1, const ULONG data = 50,
					const ULONG dataretry = 50, const ULONG size = 10, BSTR stats = NULL, const ULONG index = 0);
	
	ULONG	GetPollPeriod() { return m_pollPeriod; }
	ULONG	GetInitialPeriod() { return m_initialPeriod; }
	ULONG	GetPollPeriodSecs() { return (m_pollPeriod/1000); }
	ULONG	GetInitialPeriodSecs() { return (m_initialPeriod/1000); }
	ULONG	GetDataOffset() { return m_dataOffset; }
	ULONG	GetDataRetry() { return m_dataRetry; }
	ULONG	GetNSize() { return m_nsize; }
	ULONG	GetIndex() { return m_index; }
	BSTR	GetStatsType() { return m_statstype; }
	void	SetPollPeriod(ULONG val) { m_pollPeriod = (val*1000); }
	void	SetInitialPeriod(ULONG val) { m_initialPeriod = (val*1000); }
	void	SetDataOffset(ULONG val) { m_dataOffset = (val*100); }
	void	SetDataRetry(ULONG val) { m_dataRetry = (val*100); }
	void	SetNSize(ULONG val) { m_nsize = val; }
	void	SetIndex(ULONG val) { m_index = val; }
	void	SetStatsType(BSTR val);

	~RmonConfigData() { SetStatsType(NULL); }

};


class TopNCache : public CMap< ULONG, ULONG, IWbemClassObject*, IWbemClassObject* >
{
private:
	ULONG HashKey(ULONG key) { return key; }

public:

	TopNCache() { InitHashTable(113); }
};


class TopNTableStore
{
private:
	CCriticalSection m_Lock;

public:

	TopNCache*	m_pTopNCache;

	TopNTableStore() { m_pTopNCache = new TopNCache; }

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
	static ULONG GetKey(IWbemClassObject *obj);
	static ULONG GetKey(ULONG topNReport, ULONG topNIndex);

	~TopNTableStore() { delete m_pTopNCache; }

};


class TopNTableProv
{
private:

	TopNTableStore			m_CachedResults;
	ULONG					m_CacheAge;
	RmonConfigData			m_Confdata;
	IWbemClassObject*		m_pObjProv;
	BOOL					m_IsValid;
	IWbemServices*			m_wbemServ;
	ProviderStore*			m_timer;
	BOOL					m_Strobing;
	ULONG					m_StrobeCount;
	SnmpEventObject*		m_FirstTimeWait;

	enum Status
	{
		CREATE_ENUM_STATUS = 0,
		POLL_ENUM_STATUS,
		RETRY_ENUM_STATUS
	} m_Status;


	BOOL	InitializeRmon();
	BOOL	GetRmonConfData();
	BOOL	GetWBEMEnumerator(IEnumWbemClassObject **ppEnum, wchar_t *strclass);
	BOOL	CopyEntry(IWbemClassObject** pDest, IWbemClassObject* pSource);
	void	GetData(IEnumWbemClassObject* pEnum, IWbemClassObject* psrcObj);
	BOOL	DeleteRmonConfiguration();
	LONG	SetRmonConfiguration();
	void	ResetRmonDuration();
	BOOL	AddHostProperties(IWbemClassObject* pDest, ULONG topNR, const CString& addrStr);

	static BOOL	GetWBEMProperty(IWbemClassObject* obj, VARIANT& val, wchar_t* prop);
	static BOOL	PutWBEMProperty(IWbemClassObject* obj, VARIANT& val, wchar_t* prop);

public:

		TopNTableProv(IWbemServices*	wbemServ, ProviderStore& timer);

	void	Poll();
	void	RetryPoll();
	void	Strobe();
	BOOL	IsValid() { return m_IsValid; }

	TopNCache *LockTopNCache () ;
	void UnlockTopNCache () ;

		~TopNTableProv();
};


#endif //_RMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\include\trrt.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define WBEM_CLASS_EXTENDEDSTATUS	L"__ExtendedStatus" 

#define WBEM_TASKSTATE_START					0x0
#define WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE	0x100000
#define WBEM_TASKSTATE_ASYNCHRONOUSABORT		0x100001

class WbemTaskObject : public SnmpTaskObject
{
private:
protected:

	ULONG m_State ;
	WbemSnmpErrorObject m_ErrorObject ;

	IWbemContext *m_Context ;
	ULONG m_OperationFlag ;
	IWbemClassObject *m_ClassObject ;
	IWbemObjectSink *m_NotificationHandler ;
	CImpTraceRouteProv *m_Provider ;

	static SnmpMap <wchar_t *,wchar_t *,IWbemServices *,IWbemServices *> s_ConnectionPool ;
	static SnmpMap <wchar_t *,wchar_t *,wchar_t *,wchar_t *> s_AddressPool ;
	static SnmpMap <wchar_t *,wchar_t *,wchar_t *,wchar_t *> s_NamePool ;
	static SnmpMap <wchar_t *,wchar_t *,wchar_t *,wchar_t *> s_QualifiedNamePool ;


protected:

	void SetContext ( IWbemContext *a_Context ) ;
	IWbemContext *GetContext () ;
	BOOL GetClassObject ( wchar_t *a_Class ) ;
	BOOL GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;

	ULONG GetState () ;
	void SetState ( ULONG a_State ) ;

/*
 *	Common functions
 */

	BOOL CalculateRoute ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		IWbemServices *a_Proxy ,
		ULONG a_SourceAddress ,
		ULONG a_DestinationAddress ,
		wchar_t *&a_SubnetAddress ,
		wchar_t *&a_SubnetMask ,
		ULONG &a_InterfaceIndex ,
		wchar_t *&a_GatewayAddress ,
		wchar_t *&a_GatewaySubnetAddress ,
		wchar_t *&a_GatewaySubnetMask ,
		ULONG &a_GatewayInterfaceIndex ,
		wchar_t *&a_DestinationRouteAddress ,
		wchar_t *&a_DestinationRouteMask

	) ;

	BOOL GetRouteEntry ( 
													  
		WbemSnmpErrorObject &a_ErrorObject , 
		IWbemClassObject *a_RoutingTableEntry ,
		wchar_t *&t_ipRouteDest ,
		wchar_t *&t_ipRouteNextHop ,
		wchar_t *&t_ipRouteMask ,
		ULONG &t_ipRouteIfIndex ,
		ULONG &t_ipRouteMetric1 
	) ;

	BOOL GetAddressEntry ( 
													  
		WbemSnmpErrorObject &a_ErrorObject , 
		IWbemClassObject *a_AddressTableEntry ,
		wchar_t *&a_ipAdEntAddr ,
		wchar_t *&a_ipAdEntNetMask ,
		ULONG &a_ipAdEntIfIndex 
	) ;

	BOOL FindAddressEntryByIndex ( 
													  
		WbemSnmpErrorObject &a_ErrorObject , 
		IEnumWbemClassObject *a_AddressTableEnumerator ,
		wchar_t *&a_ipAdEntAddr ,
		wchar_t *&a_ipAdEntNetMask ,
		ULONG a_ipAdEntIfIndex 
	) ;

	BOOL FindAddressEntryByAddress ( 
													  
		WbemSnmpErrorObject &a_ErrorObject , 
		IEnumWbemClassObject *a_AddressTableEnumerator ,
		wchar_t *a_ipAdEntAddr ,
		wchar_t *&a_ipAdEntNetMask ,
		ULONG &a_ipAdEntIfIndex 
	) ;

/*
 *	Network helper functions
 */

	static wchar_t *GetHostAddressByName ( wchar_t *a_HostName ) ;
	static wchar_t *GetHostNameByAddress ( wchar_t *a_HostAddress ) ;
	static wchar_t *GetQualifiedHostNameByAddress ( wchar_t *a_HostAddress ) ;

	static wchar_t *GetHostName () ;

	static wchar_t *GetUncachedHostAddressByName ( wchar_t *a_HostName ) ;
	static wchar_t *GetUncachedHostNameByAddress ( wchar_t *a_HostAddress ) ;
	static wchar_t *GetUncachedQualifiedHostNameByAddress ( wchar_t *a_HostAddress ) ;

/*
 *	String helper functions
 */

	static wchar_t *QuoteAndEscapeString ( wchar_t *a_String ) ;
	static wchar_t *QuoteString ( wchar_t *a_String ) ;

public:

	WbemTaskObject ( 

		CImpTraceRouteProv *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		ULONG a_OperationFlag 
	) ;

	~WbemTaskObject () ;

	WbemSnmpErrorObject &GetErrorObject () ;

	static BOOL GetProxy ( WbemSnmpErrorObject &a_ErrorObject , IWbemServices *a_RootService , wchar_t *a_Proxy , IWbemServices **a_ProxyService ) ;

} ;
class GetObjectAsyncEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;

protected:

	void ProcessComplete () ;
	BOOL Instantiate ( WbemSnmpErrorObject &a_ErrorObject ) ;

	BOOL Dispatch_Hop ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL Hop_GetIpForwarding ( WbemSnmpErrorObject &a_ErrorObject , IWbemServices *t_Proxy , BOOL &a_IpForwarding ) ;
	BOOL Hop_Get ( WbemSnmpErrorObject &a_ErrorObject , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL Hop_Put ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		IWbemClassObject *a_Hop ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask ,
		BOOL a_IpForwarding 
	) ;

	BOOL Dispatch_ProvidedTopNTable ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL ProvidedTopNTable_Get ( WbemSnmpErrorObject &a_ErrorObject , KeyRef *a_TopNReport , KeyRef *a_TopNIndex ) ;

public:

	GetObjectAsyncEventObject ( 

		CImpTraceRouteProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Context
	) ;

	~GetObjectAsyncEventObject () ;

	void Process () ;
} ;

class CreateInstanceEnumAsyncEventObject : public WbemTaskObject
{
private:

	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL Instantiate ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL Dispatch_ProvidedhostTopNTable ( WbemSnmpErrorObject &a_ErrorObject ) ;

public:

	CreateInstanceEnumAsyncEventObject ( 

		CImpTraceRouteProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Context 
	) ;

	~CreateInstanceEnumAsyncEventObject () ;

	void Process () ;
} ;


class ExecQueryAsyncEventObject : public WbemTaskObject
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;
	wchar_t *m_Class ;

	CTextLexSource m_QuerySource ;
	SQL1_Parser m_SqlParser ;
	SQL_LEVEL_1_RPN_EXPRESSION *m_RPNExpression ;

protected:

	void ProcessComplete () ;
	BOOL Instantiate ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL DispatchQuery ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL DispatchAssocQuery ( WbemSnmpErrorObject &a_ErrorObject , wchar_t **a_ObjectPath ) ;

protected:

	BOOL Dispatch_AllAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;

	BOOL All_Hop_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey 
	) ;

	BOOL All_NextHop_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey ,
		IWbemServices *a_Proxy ,
		IWbemClassObject *a_HopObject ,
		wchar_t *a_SourceName ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		ULONG a_SourceIpAddress ,
		ULONG a_DestinationIpAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask
	) ;

	BOOL All_ConnectionDestination_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey ,
		IWbemServices *a_Proxy ,
		IWbemClassObject *a_HopObject ,
		wchar_t *a_SourceName ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		ULONG a_SourceIpAddress ,
		ULONG a_DestinationIpAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask
	) ;

	BOOL All_HopToProxySystem_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey ,
		IWbemServices *a_Proxy ,
		IWbemClassObject *a_HopObject ,
		wchar_t *a_SourceName ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		ULONG a_SourceIpAddress ,
		ULONG a_DestinationIpAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask
	) ;


	BOOL All_HopToInterfaceTable_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey ,
		IWbemServices *a_Proxy ,
		IWbemClassObject *a_HopObject ,
		wchar_t *a_SourceName ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		ULONG a_SourceIpAddress ,
		ULONG a_DestinationIpAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask
	) ;

	BOOL All_HopToGatewayInterfaceTable_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey ,
		IWbemServices *a_Proxy ,
		IWbemClassObject *a_HopObject ,
		wchar_t *a_SourceName ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		ULONG a_SourceIpAddress ,
		ULONG a_DestinationIpAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask
	) ;

	BOOL All_HopToSubnetwork_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey ,
		IWbemServices *a_Proxy ,
		IWbemClassObject *a_HopObject ,
		wchar_t *a_SourceName ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		ULONG a_SourceIpAddress ,
		ULONG a_DestinationIpAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask
	) ;

	BOOL All_HopToGatewaySubnetwork_Association ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		wchar_t *a_ObjectPath , 
		KeyRef *a_SourceKey , 
		KeyRef *DestinationKey ,
		IWbemServices *a_Proxy ,
		IWbemClassObject *a_HopObject ,
		wchar_t *a_SourceName ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		ULONG a_SourceIpAddress ,
		ULONG a_DestinationIpAddress ,
		wchar_t *a_SubnetAddress ,
		wchar_t *a_SubnetMask ,
		ULONG a_InterfaceIndex ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask
	) ;

	BOOL Dispatch_ConnectionSource ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_ConnectionDestination ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_NextHop ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_HopToProxySystemAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_HopToInterfaceTableAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_HopToGatewayInterfaceTableAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_HopToSubnetworkAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_HopToGatewaySubnetworkAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_SubnetworkToTopNAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_TopNToMacAddressAssoc ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_ProxyToWin32Service ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_ProxyToProcessStats ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_ProxyToNetworkStats ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;
	BOOL Dispatch_ProxyToInterfaceStats ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath ) ;

	BOOL ConnectionSource_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL NextHop_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL ConnectionDestination_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL HopToSubnetwork_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL HopToGatewaySubnetwork_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL HopToInterfaceTable_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL HopToGatewayInterfaceTable_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL HopToProxySystem_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey , KeyRef *DestinationKey ) ;
	BOOL SubnetworkToTopN_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_IpSubnetAddrKey ) ;
	BOOL TopNToMacAddress_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_IndexKey , KeyRef *a_ReportKey ) ;
	BOOL ProxyToWin32Service_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey ) ;
	BOOL ProxyToProcessStats_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey ) ;
	BOOL ProxyToNetworkStats_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey ) ;
	BOOL ProxyToInterfaceStats_Association ( WbemSnmpErrorObject &a_ErrorObject , wchar_t *a_ObjectPath , KeyRef *a_SourceKey ) ;

	BOOL ConnectionDestination_Put ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		IWbemClassObject *a_ConnectionDestination ,
		wchar_t *a_ObjectPath ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask 
	) ;

	BOOL NextHop_Put ( 

		WbemSnmpErrorObject &a_ErrorObject , 
		IWbemClassObject *a_NextHop ,
		wchar_t *a_ObjectPath ,
		wchar_t *a_SourceAddress ,
		wchar_t *a_DestinationAddress ,
		wchar_t *a_GatewayAddress ,
		wchar_t *a_GatewaySubnetAddress ,
		wchar_t *a_GatewaySubnetMask ,
		ULONG a_GatewayInterfaceIndex ,
		wchar_t *a_DestinationRouteAddress ,
		wchar_t *a_DestinationRouteMask 
	) ;

public:

	ExecQueryAsyncEventObject ( 

		CImpTraceRouteProv *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Context 
	) ;

	~ExecQueryAsyncEventObject () ;

	void Process () ;
} ;

class PutInstanceAsyncEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_Object ;
	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL Update ( WbemSnmpErrorObject &a_ErrorObject ) ;

public:

	PutInstanceAsyncEventObject ( 
		
		CImpTraceRouteProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Context 
	) ;

	~PutInstanceAsyncEventObject () ;

	void Process () ;
} ;

class PutClassAsyncEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_Object ;
	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL Update ( WbemSnmpErrorObject &a_ErrorObject ) ;

public:

	PutClassAsyncEventObject ( 
		
		CImpTraceRouteProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Context 
	) ;

	~PutClassAsyncEventObject () ;

	void Process () ;
} ;

class CreateClassEnumAsyncEventObject : public WbemTaskObject
{
private:

	wchar_t *m_SuperClass ;

protected:

	void ProcessComplete () ;
	BOOL Instantiate ( WbemSnmpErrorObject &a_ErrorObject ) ;

public:

	CreateClassEnumAsyncEventObject ( 

		CImpTraceRouteProv *a_Provider , 
		BSTR a_SuperClass , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Context 
	) ;

	~CreateClassEnumAsyncEventObject () ;

	void Process () ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\include\trrtprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPPropertyProvider_H_
#define _SNMPPropertyProvider_H_

class SnmpDefaultThreadObject : public SnmpThreadObject
{
private:

	BOOL m_Active ;

protected:
public:

	SnmpDefaultThreadObject ( const char *a_ThreadName = NULL ) : SnmpThreadObject ( a_ThreadName ) , m_Active ( FALSE ) {} ;
	~SnmpDefaultThreadObject () {} ;

	void Initialise () { CoInitialize ( NULL ) ; }
	void Uninitialise () { CoUninitialize () ; }

	BOOL GetActive () { return m_Active ; }
	void SetActive ( BOOL a_Active = TRUE ) { m_Active = a_Active ; }
} ;

class CImpTraceRouteProv : public IWbemServices
{
private:

	BOOL m_Initialised ;
	LONG m_ReferenceCount ;         //Object reference count

	CCriticalSection m_CriticalSection ;

	WbemNamespacePath m_NamespacePath ;
	wchar_t *m_Namespace ;

	IWbemServices *m_Server ;
	IWbemServices *m_Parent ;

	wchar_t *m_localeId ;

	BOOL m_GetNotifyCalled ;
	BOOL m_GetExtendedNotifyCalled ;
	IWbemClassObject *m_NotificationClassObject ;
	IWbemClassObject *m_ExtendedNotificationClassObject ;

	static ProviderStore s_ProviderStore ;
	TopNTableProv *m_TopNTableProv ;

private:

	BOOL AttachParentServer ( 

		WbemSnmpErrorObject &a_errorObject ,
		BSTR Namespace, 
		IWbemContext *pCtx,
		long lFlags, 
		IWbemServices FAR* FAR* ppNewContext, 
		IWbemCallResult FAR* FAR* ppErrorObject

	) ;

	BOOL AttachServer (

		WbemSnmpErrorObject &a_errorObject ,
		BSTR Namespace, 
		IWbemContext *pCtx,
		long lFlags, 
		IWbemServices FAR* FAR* ppNewContext, 
		IWbemCallResult FAR* FAR* ppErrorObject

	) ;
	
protected:
public:

	CImpTraceRouteProv () ;
    ~CImpTraceRouteProv () ;

	static SnmpDefaultThreadObject *s_DefaultThreadObject ;
	static SnmpDefaultThreadObject *s_BackupThreadObject ;

	// Implementation

	IWbemServices *GetServer () ;
	IWbemServices *GetParent () ;

	void SetParent ( IWbemServices *a_Parent ) ;
	void SetServer ( IWbemServices *a_Server ) ;

	TopNTableProv *GetTopNTableProv () { return m_TopNTableProv ; }

	void EnableRmonPolling () ;

	WbemNamespacePath *GetNamespacePath () { return & m_NamespacePath ; }

	wchar_t *GetNamespace () ;
	void SetNamespace ( wchar_t *a_Namespace ) ;

	void SetLocaleId ( wchar_t *a_localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	BOOL CreateExtendedNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject 
	) ;

	BOOL CreateNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject 
	) ;

	IWbemClassObject *GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;
	IWbemClassObject *GetExtendedNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

} ;

///////////////////////////////////////////////////////////////////
// This class is used to enumerate instances

class CEnumInst : public IEnumWbemClassObject
{
private:

	LONG m_ReferenceCount ;

protected:
public:

    CEnumInst (

		HANDLE hContext  ,
		WCHAR * pClass  ,
		IWbemServices FAR* pOLEMSGateway  ,
		CImpTraceRouteProv *pProvider
	) ;

	~CEnumInst () ;

  // IUnknown members

	STDMETHODIMP QueryInterface ( REFIID  , LPVOID FAR * ) ;
	STDMETHODIMP_( ULONG ) AddRef () ;
	STDMETHODIMP_( ULONG ) Release () ;
      
  // IEnumMosClassObject methods 

	STDMETHODIMP Reset () ;

	STDMETHODIMP Next (

		ULONG uCount  ,
		IWbemClassObject FAR* FAR* pProp  ,
		ULONG FAR* puReturned
	) ;

	STDMETHODIMP Clone (

		IEnumWbemClassObject FAR* FAR* pEnum 
	) ;

	STDMETHODIMP Skip (

		ULONG nNum
	) ;

} ;

class CImpTraceRouteLocator : public IWbemLocator
{
private:

	LONG m_ReferenceCount ;         //Object reference count

protected:
public:

	CImpTraceRouteLocator () ;
    ~CImpTraceRouteLocator () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


    /* IWbemLocator methods */

    STDMETHODIMP ConnectServer ( 
		
		BSTR NetworkResource, 
		BSTR User, 
		BSTR Password, 
		BSTR lLocaleId, 
		long lFlags, 
		BSTR Authority,
		IWbemContext FAR *pCtx ,
		IWbemServices FAR* FAR* ppNamespace
	) ;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\include\wndtime.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __WNDTIME_H__
#define __WNDTIME_H__

#define WINDOW_TIMER_ID				1
#define WINDOW_TIMER_STROBE_PERIOD	500

class ProviderStore;
class TopNTableProv;

//only one of these windows can ever be created because of static memebers.

class TimerWindow
{
private:
	static ProviderStore*	m_provMap;
	BOOL			m_IsValid;
	HWND			m_timerWindowHandle;

public:

		TimerWindow(ProviderStore* provMap);

	BOOL	IsValid() { return m_IsValid; }

	static LONG CALLBACK TimerWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);


		~TimerWindow();
};


class TimerThread : public SnmpThreadObject
{
private:

	TimerWindow*	m_wndTimer;
	ProviderStore*	m_parent;

	void Initialise ();
	void Uninitialise ();


public:

		TimerThread(ProviderStore* parent);

	BOOL	IsValid() { return ( (NULL != m_wndTimer) ? m_wndTimer->IsValid() : FALSE ); }

		~TimerThread() {}
};


class ProviderStore : public CMap< ULONG, ULONG, TopNTableProv*, TopNTableProv* >
{
private:

	CCriticalSection m_Lock;
	TimerThread* m_timerThread;

	ULONG HashKey(ULONG key) { return key; }


public:

		ProviderStore();

	BOOL	RegisterProviderWithTimer(TopNTableProv* prov);
	BOOL	UnregisterProviderWithTimer(TopNTableProv* prov);
	BOOL	Lock() { return m_Lock.Lock(); }
	BOOL	Unlock() { return m_Lock.Unlock(); }

		~ProviderStore();

};

#endif // __WNDTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\traceroute\include\guids.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// {E507506A-DC59-11d0-82D7-00A0C9038B34}
DEFINE_GUID(CLSID_CTraceRouteProvClassFactory, 
0xe507506a, 0xdc59, 0x11d0, 0x82, 0xd7, 0x0, 0xa0, 0xc9, 0x3, 0x8b, 0x34);

// {E507506B-DC59-11d0-82D7-00A0C9038B34}
DEFINE_GUID(CLSID_CTraceRouteLocatorClassFactory, 
0xe507506b, 0xdc59, 0x11d0, 0x82, 0xd7, 0x0, 0xa0, 0xc9, 0x3, 0x8b, 0x34);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\bstring.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "bstring.h"

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\cthread.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*
 * CTHREAD.CPP
 *
 * Implemenations of the derived thread classed used in notification.
 */
#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include <textdef.h>
#include "enum.h"
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

SCODE CNotifyThread :: Process()
{
	BOOL bEvent = FALSE;
	while(TRUE)
	{
		DWORD dwResult = Wait(SMIR_CHANGE_INTERVAL);

		if(WAIT_EVENT_0 == dwResult)
		{
			bEvent = TRUE;
		}
		else if(WAIT_EVENT_TERMINATED == dwResult)
		{
			return SMIR_THREAD_EXIT;
		}
		else if( (dwResult == WAIT_TIMEOUT) && bEvent)
		{
			bEvent = FALSE;
			IConnectionPoint *pNotifyCP;
			CSmir::sm_ConnectionObjects->FindConnectionPoint(IID_ISMIR_Notify, &pNotifyCP);
			((CSmirNotifyCP*)pNotifyCP)->TriggerEvent();
			pNotifyCP->Release();
			SetEvent(m_doneEvt);
			break;
		}
	}

	return SMIR_THREAD_EXIT;
}

CNotifyThread :: CNotifyThread(HANDLE* evtsarray, ULONG arraylen):CThread()
{
	//addref the smir for this thread
	m_doneEvt = evtsarray[arraylen-1];
	
	//add the events
	for (ULONG i = 0; i < (arraylen - 1); i++)
	{
		AddEvent(evtsarray[i]);
	}
}

CNotifyThread :: ~CNotifyThread()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\evtcons.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"

#include <textdef.h>
#include <helper.h>
#include "bstring.h"

#include "evtcons.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif
 


/*
 * CSmirWbemEventConsumer::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirWbemEventConsumer::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		//are we being asked for an interface we support?
		if ((IID_IUnknown == riid)  || 
			(IID_IWbemObjectSink == riid) || 
			(IID_ISMIR_WbemEventConsumer == riid) )
		{
			*ppv=this;
			((LPUNKNOWN)*ppv)->AddRef();
			return NOERROR;
		}

		//we don't support the interface being asked for...
		return ResultFromScode(E_NOINTERFACE);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirWbemEventConsumer::AddRef
 * CSmirWbemEventConsumer::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirWbemEventConsumer::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirWbemEventConsumer::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;

		if ( 0 != (ret = InterlockedDecrement(&m_cRef)) )
		{
			return ret;
		}

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirWbemEventConsumer::CSmirWbemEventConsumer(CSmir* psmir) : m_hEvents (NULL), m_Serv(NULL)
{
	CSMIRClassFactory::objectsInProgress++;
	//init the reference count
	m_cRef=0;
	m_callbackThread = NULL;
	
	if (NULL == psmir)
	{
		m_hEvents = NULL;
		return;
	}

	//Create the event
	m_hEvents = new HANDLE[SMIR_EVT_COUNT];

	for (int x = 0; x < SMIR_EVT_COUNT; x++)
	{
		m_hEvents[x] = NULL;
	}

	m_hEvents[SMIR_CHANGE_EVT] = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_hEvents[SMIR_THREAD_EVT] = CreateEvent(NULL, FALSE, TRUE, NULL);
}

CSmirWbemEventConsumer :: ~CSmirWbemEventConsumer()
{
	//close the change event handle
	if(NULL != m_hEvents)
	{
		if ((NULL != m_callbackThread) && (NULL != m_hEvents[SMIR_THREAD_EVT]) && 
			(WAIT_OBJECT_0 != WaitForSingleObject(m_hEvents[SMIR_THREAD_EVT], 0)) )
		{
			m_callbackThread->Release();
		}

		for (ULONG i = 0; i < SMIR_EVT_COUNT; i++)
		{
			if (NULL != m_hEvents[i])
			{
				CloseHandle(m_hEvents[i]);
			}
		}

		delete [] m_hEvents;
	}

	if (NULL != m_Serv)
	{
		m_Serv->Release();
		m_Serv = NULL;
	}

	CSMIRClassFactory::objectsInProgress--;
}

HRESULT CSmirWbemEventConsumer::Indicate(IN long lObjectCount, IN IWbemClassObject **ppObjArray)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((NULL != m_hEvents) && (NULL != m_hEvents[SMIR_THREAD_EVT]))
		{
			//if thread is dead start a thread to watch for further change events
			if (WAIT_OBJECT_0 == WaitForSingleObject(m_hEvents[SMIR_THREAD_EVT], 0)) 
			{
				m_callbackThread = new CNotifyThread(m_hEvents, SMIR_EVT_COUNT);
				m_callbackThread->AddRef();
				DWORD dwThreadHandle = m_callbackThread->Start();
				if (WBEM_E_FAILED == dwThreadHandle)
				{
					m_callbackThread->Release();
					m_callbackThread = NULL;
				}

			}
			else
			{
				//set change event to restart timer
				SetEvent(m_hEvents[SMIR_CHANGE_EVT]);
			}
		}

		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemEventConsumer::SetStatus(IN long lFlags, IN long lParam, IN BSTR strParam,
										IN IWbemClassObject *pObjParam)
{
	return NOERROR;
}

HRESULT CSmirWbemEventConsumer::Register(CSmir* psmir)
{
	if (NULL == m_hEvents)
	{
		return WBEM_E_FAILED;
	}

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	HRESULT result= CSmirAccess :: GetContext (psmir , &moContext);
	result = CSmirAccess :: Open(psmir,&moServ);
	if ((S_FALSE==result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem the SMIR is not there and cannot be created
		return WBEM_E_FAILED;
	}

	BSTR t_bstrQueryType = SysAllocString(FILTER_QUERYTYPE_VAL);
	BSTR t_bstrQuery = SysAllocString(FILTER_QUERY_VAL);
	result = moServ->ExecNotificationQueryAsync( 
								t_bstrQueryType,	// [in] BSTR QueryLanguage,
								t_bstrQuery,		// [in] BSTR Query,
								0,					// [in] long lFlags,
								moContext,			// [in] IWbemContext *pCtx,
								this);				// [in] IWbemObjectSink *pResponseHandler
	SysFreeString(t_bstrQueryType);
	SysFreeString(t_bstrQuery);

	if ( moContext )
		moContext->Release () ;
	
	//keep this around for unregister...
	m_Serv = moServ;
	
	return result;
}

HRESULT CSmirWbemEventConsumer::GetUnRegisterParams(IWbemServices** ppServ)
{
	HRESULT retVal = WBEM_E_FAILED;

	if (m_Serv)
	{
		*ppServ = m_Serv;
		m_Serv = NULL;
		retVal = S_OK;
	}

	return retVal;
}


HRESULT CSmirWbemEventConsumer::UnRegister(CSmir* psmir, IWbemServices* pServ)
{
	if (NULL == m_hEvents)
	{
		return WBEM_E_FAILED;
	}

	return pServ->CancelAsyncCall(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\helper.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include <helper.h>
#include "handles.h"
#include "classfac.h"
#include <textdef.h>
#include "bstring.h"
#include "evtcons.h"
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif
#include <cominit.h>

extern BOOL g_initialised ;

//BSTR Helpers
SCODE CopyBSTR(BSTR *pDst, BSTR *pSrc)
{
	if(*pDst)
		SysFreeString(*pDst);
	if(*pSrc)
	{
		*pDst = SysAllocString(*pSrc);
		return S_OK;
	}
	else
		return E_INVALIDARG;
}
// {74864DA1-0630-11d0-A5B6-00AA00680C3F}
//DEFINE_GUID(CLSID_MosGateway, 
//0x74864da1, 0x630, 0x11d0, 0xa5, 0xb6, 0x0, 0xaa, 0x0, 0x68, 0xc, 0x3f);

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey,  wchar_t* pszValueName, wchar_t* pszValue);

SmirClassFactoryHelper :: SmirClassFactoryHelper()
:	pGroupHandleClassFactory(NULL), pClassHandleClassFactory(NULL),
	pModHandleClassFactory(NULL), pSMIRClassFactory(NULL),
	pNotificationClassHandleClassFactory(NULL), pExtNotificationClassHandleClassFactory(NULL)
{
}

SmirClassFactoryHelper :: ~SmirClassFactoryHelper()
{
	if(NULL != pGroupHandleClassFactory)
		pGroupHandleClassFactory->Release();
	if(NULL != pClassHandleClassFactory)
		pClassHandleClassFactory->Release();
	if(NULL != pModHandleClassFactory)
		pModHandleClassFactory->Release();
	if(NULL != pNotificationClassHandleClassFactory)
		pNotificationClassHandleClassFactory->Release();
	if(NULL != pExtNotificationClassHandleClassFactory)
		pExtNotificationClassHandleClassFactory->Release();
	if(NULL != pSMIRClassFactory )
	{
		pSMIRClassFactory->Release();
	}
}

SCODE SmirClassFactoryHelper :: CreateInstance(REFCLSID rclsid,REFIID riid, LPVOID * ppv)
{
	CSMIRGenericClassFactory *ppClassFactory = NULL ;
	SCODE result = S_OK;
	*ppv=NULL;
	
	if((CLSID_SMIR_Database==rclsid)||
				(IID_IConnectionPointContainer==rclsid))
	{
		ppClassFactory = new CSMIRClassFactory(rclsid);
	}
	else if(CLSID_SMIR_ModHandle == rclsid)
	{
		ppClassFactory = new CModHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_GroupHandle == rclsid)
	{
		ppClassFactory = new CGroupHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_ClassHandle == rclsid)
	{
		ppClassFactory = new CClassHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_NotificationClassHandle == rclsid)
	{
		ppClassFactory = new CNotificationClassHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_ExtNotificationClassHandle == rclsid)
	{
		ppClassFactory = new CExtNotificationClassHandleClassFactory(rclsid);
	}

	ppClassFactory->AddRef();
	result = ppClassFactory->CreateInstance (NULL ,riid ,ppv);
	ppClassFactory->Release();

	if((S_OK != result)||(*ppv == NULL))
	{
		return result;
	}
	return result;
}

/* CSmirAccess
 *A simple class to open and create the smir - extended to opan any namespace
 */

void CSmirAccess :: ShutDown ()
{
	if (CSmir::sm_ConnectionObjects != NULL)
	{
		CSmir::sm_ConnectionObjects->Release ();
		CSmir::sm_ConnectionObjects = NULL ;
	}

	if(NULL != g_pClassFactoryHelper)
	{
		delete g_pClassFactoryHelper;
		g_pClassFactoryHelper = NULL;
	}
	
	//SMIR requires re-initialization!
	g_initialised = FALSE ;
}

STDMETHODIMP CSmirAccess :: Init ()
{
	return S_OK;
}

STDMETHODIMP CSmirAccess :: Open (

	CSmir *a_Smir , 
	IWbemServices **server, 
	BSTR ObjectPath, 
	BOOL relativeToSMIR
)
{
	IWbemServices *returnedServ = NULL ;
	*server=NULL;

	if (relativeToSMIR && (ObjectPath == NULL))
	{
		return WBEM_E_FAILED;
	}

	if(FAILED(Connect(a_Smir, &returnedServ, ObjectPath, relativeToSMIR)))
	{
		return WBEM_E_FAILED;
	}
	*server = returnedServ;
	return S_OK;
}

STDMETHODIMP CSmirAccess :: Open(

	CSmir *a_Smir , 
	IWbemServices **server, 
	ISmirClassHandle *hClass, 
	eOpenType eType
)
{
	if(NULL == server)
		return WBEM_E_FAILED;

	SCODE returnCode=S_OK;

	BSTR szTModstr = NULL;
	BSTR szTGroupstr = NULL;
	hClass->GetModuleName(&szTModstr);
	hClass->GetGroupName(&szTGroupstr);

	wchar_t *pTGroupNSString = NULL ;
	if(eType == eGroup)
	{
		hClass->GetGroupName(&szTGroupstr);
		pTGroupNSString = new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+wcslen(BACKSLASH_STR)+wcslen(szTGroupstr)+1];
	}
	else
	{
		hClass->GetGroupName(&szTGroupstr);
		pTGroupNSString = new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+1];
	}

	if(NULL != pTGroupNSString)
	{
		wcscpy(pTGroupNSString,szTModstr);
		//<module name>
		if(eType == eGroup)
		{	
			wcscat(pTGroupNSString,BACKSLASH_STR);
			wcscat(pTGroupNSString,szTGroupstr);
			// <module name>\<group name>
		}

		CBString t_Str ( pTGroupNSString ) ;
		SCODE result= CSmirAccess :: Open(

			a_Smir, 
			server, 
			t_Str.GetString (), 
			TRUE
		);

		delete [] pTGroupNSString;
		
		if ((FAILED(result))||(NULL == server))
		{
			//if we can't open the namespace the group handle must be invalid
			returnCode =  result;
		}
	}
	else
	{
		returnCode= E_OUTOFMEMORY;
	}

	if(FAILED(returnCode))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,returnCode);
		returnCode = (returnCode==E_OUTOFMEMORY?E_OUTOFMEMORY:WBEM_E_FAILED);
	}

	//free the string we got from hGroup
	SysFreeString(szTModstr);
	SysFreeString(szTGroupstr);

	return returnCode;
}

STDMETHODIMP CSmirAccess :: Open(

	CSmir *a_Smir , 
	IWbemServices **server, 
	ISmirGroupHandle *hGroup, 
	eOpenType eType
)
{
	if(NULL == server)
		return WBEM_E_FAILED;

	SCODE returnCode=S_OK;

	BSTR szTModstr=NULL;
	BSTR szTGroupstr=NULL;
	hGroup->GetModuleName(&szTModstr);

	wchar_t *pTGroupNSString = NULL;
	if(eType == eGroup)
	{
		hGroup->GetName(&szTGroupstr);
		pTGroupNSString =new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+wcslen(BACKSLASH_STR)+wcslen(szTGroupstr)+1];
	}
	else
	{
		pTGroupNSString =new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+1];
	}

	if(NULL != pTGroupNSString)
	{
		wcscpy(pTGroupNSString,szTModstr);
		// <module name>
		if(eType == eGroup)
		{
			wcscat(pTGroupNSString,BACKSLASH_STR);
			wcscat(pTGroupNSString,szTGroupstr);
		}
		// <module name>\<group name>

		CBString t_BStr ( pTGroupNSString ) ;

		SCODE result= CSmirAccess :: Open (

			a_Smir, 
			server, 
			t_BStr.GetString (), 
			TRUE
		);

		delete [] pTGroupNSString;
		
		if ((FAILED(result))||(NULL == server))
		{
			//if we can't open the namespace the group handle must be invalid
			returnCode = result;
		}
	}
	else
	{
		returnCode = E_OUTOFMEMORY;
	}

	if(FAILED(returnCode))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,returnCode);
		returnCode = (returnCode==E_OUTOFMEMORY?E_OUTOFMEMORY:WBEM_E_FAILED);
	}

	//free the strings we got from hModule and hGroup
	SysFreeString(szTModstr);
	SysFreeString(szTGroupstr);

	return returnCode;
}

STDMETHODIMP CSmirAccess :: Open (

	CSmir *a_Smir , 
	IWbemServices **server, 
	ISmirModHandle *hMod
)
{
	if(NULL == server)
		return WBEM_E_FAILED;
	
	SCODE returnCode=S_OK;

	//open the module name space
	//build the object path
	BSTR szTstr=NULL;
	hMod->GetName(&szTstr);
	wchar_t *pTstring = new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)+wcslen(szTstr)+1];

	if(NULL != pTstring)
	{
		wcscpy(pTstring,szTstr);
		// <module name>

		CBString t_BStr ( pTstring ) ;
		SCODE res = CSmirAccess :: Open (

			a_Smir, 
			server,
			t_BStr.GetString (), 
			TRUE
		);

		//clean up
		delete [] pTstring;
		
		if (FAILED(res)||(NULL == server))
		{
			returnCode = res;
		}
	}
	else
	{
		returnCode =  E_OUTOFMEMORY;
	}

	//free the string we got from hGroup
	SysFreeString(szTstr);

	if(FAILED(returnCode))
	{
		returnCode = (returnCode==E_OUTOFMEMORY?E_OUTOFMEMORY:WBEM_E_FAILED);
	}

	return S_OK;
}

STDMETHODIMP CSmirAccess :: Connect (

	IN CSmir *a_Smir , 
	OUT IWbemServices **a_Server, 
	IN BSTR a_Namespace , 
	IN BOOL a_RelativeToSMIR
)
{
	//I only have one point of failure so don't use the garbage collector
	*a_Server = NULL;

	//open the  namespace (default is the smir)

	HRESULT t_Result;

	ISMIRWbemConfiguration *t_Configuration = NULL ;
	IWbemServices *t_Service = NULL ;
	IWbemContext *t_Context = NULL;

	t_Result = a_Smir->QueryInterface (

		IID_ISMIRWbemConfiguration ,
		( void **) & t_Configuration
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Configuration->GetContext ( & t_Context ) ;
		t_Result = t_Configuration->GetServices ( & t_Service ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = WbemSetProxyBlanket(t_Service,
				RPC_C_AUTHN_DEFAULT,
				RPC_C_AUTHZ_DEFAULT,
				COLE_DEFAULT_PRINCIPAL,
				RPC_C_AUTHN_LEVEL_DEFAULT,
				RPC_C_IMP_LEVEL_DEFAULT,
				NULL,
				EOAC_DYNAMIC_CLOAKING);

			if ( FAILED ( t_Result ) && t_Result != E_NOINTERFACE )
			{
				t_Service->Release();
				t_Service = NULL;
			}
			else
			{
				t_Result = S_OK ;
			}
		}
		else
		{
			t_Result = t_Configuration->Authenticate (

				NULL,
				NULL,
				NULL,
				NULL,
				0 ,
				NULL ,
				TRUE
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Configuration->GetServices ( & t_Service ) ;
				
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = WbemSetProxyBlanket(t_Service,
						RPC_C_AUTHN_DEFAULT,
						RPC_C_AUTHZ_DEFAULT,
						COLE_DEFAULT_PRINCIPAL,
						RPC_C_AUTHN_LEVEL_DEFAULT,
						RPC_C_IMP_LEVEL_DEFAULT,
						NULL,
						EOAC_DYNAMIC_CLOAKING);

					if ( FAILED ( t_Result ) && t_Result != E_NOINTERFACE )
					{
						t_Service->Release();
						t_Service = NULL;
					}
					else
					{
						t_Result = S_OK ;
					}
				}
			}
		}

		t_Configuration->Release () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if( a_Namespace != NULL )
		{
			CBString t_BStr ( a_Namespace )  ;

			if ( a_RelativeToSMIR )
			{
				t_Result = t_Service->OpenNamespace (

					t_BStr.GetString (), 
					0,
					t_Context, 
					a_Server, 
					NULL
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = WbemSetProxyBlanket(*a_Server,
						RPC_C_AUTHN_DEFAULT,
						RPC_C_AUTHZ_DEFAULT,
						COLE_DEFAULT_PRINCIPAL,
						RPC_C_AUTHN_LEVEL_DEFAULT,
						RPC_C_IMP_LEVEL_DEFAULT,
						NULL,
						EOAC_DYNAMIC_CLOAKING);

					if ( FAILED ( t_Result )  && t_Result != E_NOINTERFACE )
					{
						(*a_Server)->Release();
						(*a_Server) = NULL;
					}
					else
					{
						t_Result = S_OK ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}

			t_Service->Release () ;
		}
		else
		{
			*a_Server = t_Service ;
		}
	}

	if ( t_Context )
		t_Context->Release();
 
	return t_Result ;
}

STDMETHODIMP CSmirAccess :: GetContext (

	IN CSmir *a_Smir , 
	OUT IWbemContext **a_Context
)
{
	//I only have one point of failure so don't use the garbage collector
	*a_Context = NULL;

	//open the  namespace (default is the smir)

	HRESULT t_Result;

	ISMIRWbemConfiguration *t_Configuration = NULL ;

	t_Result = a_Smir->QueryInterface (

		IID_ISMIRWbemConfiguration ,
		( void **) & t_Configuration
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Configuration->GetContext ( a_Context ) ;
		t_Configuration->Release () ;
	}

	return t_Result ;
}

void FormatProviderErrorMsg(char*file, int line, SCODE errorCode)
{
	//use the strings
	switch (errorCode)
	{
		case WBEM_NO_ERROR:
		break;
		case WBEM_S_NO_MORE_DATA:
		break;
		case WBEM_E_FAILED:
		break;
		case WBEM_E_NOT_FOUND:
		break;
		case WBEM_E_ACCESS_DENIED:
		break;
		case WBEM_E_PROVIDER_FAILURE:
		break;
		case WBEM_E_TYPE_MISMATCH:
		break;
		case WBEM_E_OUT_OF_MEMORY:
		break;
		case WBEM_E_INVALID_CONTEXT:
		break;
		case WBEM_E_INVALID_PARAMETER:
		break;
		case WBEM_E_NOT_AVAILABLE:
		break;
		case WBEM_E_CRITICAL_ERROR:
		break;
		case WBEM_E_INVALID_STREAM:
		break;
		case WBEM_E_NOT_SUPPORTED:
		break;
		case WBEM_E_INVALID_SUPERCLASS:
		break;
		case WBEM_E_INVALID_NAMESPACE:
		break;
		case WBEM_E_INVALID_OBJECT:
		break;
		case WBEM_E_INVALID_CLASS:
		break;
		case WBEM_E_PROVIDER_NOT_FOUND:
		break;
		case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		break;
		case WBEM_E_PROVIDER_LOAD_FAILURE:
		break;
		case WBEM_E_INITIALIZATION_FAILURE:
		break;
		case WBEM_E_INVALID_OPERATION:
		break;
		case WBEM_E_INVALID_QUERY:
		break;
		case WBEM_E_INVALID_QUERY_TYPE:
		break;
		case E_INVALIDARG:
		break;
		case E_UNEXPECTED:
		break;
		case E_OUTOFMEMORY:
		break;
		default:
		break;
	}
}

SCODE CGroupToClassAssociator :: Associate (

	CSmir *a_Smir,
	BSTR szModuleName, 
	BSTR szGroupName, 
	ISmirClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName)||(NULL==szGroupName))
		return WBEM_E_FAILED;

	IWbemServices *moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_GROUP_ASSOC_CLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
													RESERVED_WBEM_FLAG,  &v,NULL,NULL);
	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	CString associationClassName(CString(szClassName)
						+CString(SMIR_GROUP_ASSOC_CLASS_NAME_POSTFIX));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		SysFreeString(szClassName);
		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	//don't need this anymore
	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a group property**********************************/
	//get the fully qualified class name
	//group = "\\\\.\\root\\default\\SMIR\\RFC1213_MIB:Group=\"atV1ObjectGroup\"";
	CString groupPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(BACKSLASH_STR)
				+CString(szModuleName)
				+CString(COLON_STR)
				+CString(GROUP_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szGroupName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=groupPath.AllocSysString();
	result = pInst->Put(SMIR_GROUP_ASSOC_GROUP_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it
	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR\RFC1316-MIB:Group="charV1ObjectGroup"}
	 *or
	 *associators of {\\.\root\default\SMIR\RFC1213-MIB:Group="atV1ObjectGroup"}
		 */
	return S_OK;
}

SCODE CModuleToClassAssociator :: Associate (

	CSmir *a_Smir,
	BSTR szModuleName, 
	ISmirClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName))
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_MODULE_ASSOC_CLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
												RESERVED_WBEM_FLAG,  &v,NULL,NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX));

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		SysFreeString(szClassName);
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a group property**********************************/
	//get the fully qualified class name
	//group = "\\\\.\\root\\default\\SMIR:Module=\"RFC1213_MIB\"";
	CString groupPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(COLON_STR)
				+CString(MODULE_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szModuleName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=groupPath.AllocSysString();
	result = pInst->Put(SMIR_MODULE_ASSOC_MODULE_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"}
	     */
	return S_OK;
}

SCODE CModuleToNotificationClassAssociator :: Associate (

	CSmir *a_Smir,
	BSTR szModuleName, 
	ISmirNotificationClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName))
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_MODULE_ASSOC_NCLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirNotificationClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
												RESERVED_WBEM_FLAG,  &v,NULL,NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX));

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		SysFreeString(szClassName);
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a module property**********************************/
	//get the fully qualified class name
	//module = "\\\\.\\root\\default\\SMIR:Module=\"RFC1213_MIB\"";
	CString modPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(COLON_STR)
				+CString(MODULE_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szModuleName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=modPath.AllocSysString();
	result = pInst->Put(SMIR_MODULE_ASSOC_MODULE_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);
	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"}
	     */
	return S_OK;
}

SCODE CModuleToExtNotificationClassAssociator :: Associate(

	CSmir *a_Smir,
	BSTR szModuleName, 
	ISmirExtNotificationClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName))
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_MODULE_ASSOC_EXTNCLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirExtNotificationClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
												RESERVED_WBEM_FLAG,  &v,NULL,NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX));

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		SysFreeString(szClassName);
		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a module property**********************************/
	//get the fully qualified class name
	//module = "\\\\.\\root\\default\\SMIR:Module=\"RFC1213_MIB\"";
	CString modPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(COLON_STR)
				+CString(MODULE_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szModuleName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=modPath.AllocSysString();
	result = pInst->Put(SMIR_MODULE_ASSOC_MODULE_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"}
	     */
	return S_OK;
}

SCODE CSMIRToClassAssociator :: Associate (

	CSmir *a_Smir,
	ISmirClassHandle *hClass
)
{
	if (NULL == hClass)
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL;
	CBString t_BStr ( SMIR_ASSOC_CLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString () , 0, 
									NULL,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	//make an instance
	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//get the class name
	result  = ((CSmirClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG,  &v,NULL,NULL);
	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_ASSOC_CLASS_NAME_POSTFIX));

	SysFreeString(szClassName);

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a smir property**********************************/
	//get the fully qualified class name
	//smir = "\\\\.\\root\\default\\SMIR";
	CString smirPath(SMIR_CLASS_ASSOCIATION_ENDPOINT);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=smirPath.AllocSysString();
	result = pInst->Put(SMIR_ASSOC_SMIR_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	
	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;
	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR\RFC1316-MIB:Group="charV1ObjectGroup"}
	 *or
	 *associators of {\\.\root\default\SMIR\RFC1213-MIB:Group="atV1ObjectGroup"}
		 */
	return S_OK;
}

SCODE CNotificationMapper :: Map (

	CSmir *a_Smir,
	IWbemClassObject *pObj, 
	enum NotificationMapperType type
)
{
	if (NULL == pObj)
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default\SMIR namespace
	result = CSmirAccess :: Open(a_Smir,&moServ);

	if ((FAILED(result)) || (NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	//get an object
	IWbemClassObject *pClass = NULL;

	if (SNMP_NOTIFICATION_CLASS == type)
	{
		CBString t_BStr ( SMIR_NOTIFICATION_MAPPER ) ;
		result = moServ->GetObject(t_BStr.GetString (), 0, moContext, &pClass, NULL); 
	}
	else if (SNMP_EXT_NOTIFICATION_CLASS == type)
	{
		CBString t_BStr ( SMIR_EXT_NOTIFICATION_MAPPER ) ;
		result = moServ->GetObject(t_BStr.GetString (), 0, moContext,&pClass, NULL); 
	}

	if ((FAILED(result))||(NULL == pClass))
	{
		moServ->Release();
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = pObj->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v, NULL, NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	
	/****************Set the eventclass property********************************/
	result = pInst->Put(SMIR_NOTIFICATION_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	//Get the trapoid
	result  = pObj->Get(TRAPOID_PROP, RESERVED_WBEM_FLAG, &v, NULL, NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************Set the trapoid property********************************/
	result = pInst->Put(SMIR_NOTIFICATION_TRAP_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\maindll.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef INITGUID
#define INITGUID
#endif


#include <precomp.h>
#include <initguid.h>
#include "smir.h"
#include "csmir.h"
#include "handles.h"
#include "classfac.h"
#include "textdef.h"
#include "thread.h"
#include "helper.h"
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey,  wchar_t* pszValueName, wchar_t* pszValue);


//Globals Bah!

BOOL g_initialised = FALSE ;

//OK we need this one
HINSTANCE   g_hInst;
//and this is a thread safe speed up
SmirClassFactoryHelper *g_pClassFactoryHelper=NULL;
CSmirConnObject* CSmir::sm_ConnectionObjects = NULL;

CRITICAL_SECTION g_CriticalSection ;


//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (HINSTANCE hInstance, ULONG ulReason , LPVOID pvReserved)
{
	BOOL status = TRUE;
	
	/*remember the instance handle to the dll so that we can use it in
	 *register dll
	 */
	g_hInst=hInstance;
	SetStructuredExceptionHandler seh;


	try
	{
		switch (ulReason)
		{
			case DLL_PROCESS_ATTACH:
			{
				InitializeCriticalSection ( & g_CriticalSection ) ;
				DisableThreadLibraryCalls(hInstance);
			}
			break;
			case DLL_PROCESS_DETACH:
			{
				CThread :: ProcessDetach();
				DeleteCriticalSection ( & g_CriticalSection ) ;
				//release the helper

			}
			break;
			//if DisableThreadLibraryCalls() worked these will never be called
			case DLL_THREAD_DETACH:
			case DLL_THREAD_ATTACH:
			{
			}
			break;
			default:
			{
				status = FALSE;
			}
			break;
		}
	}
	catch(Structured_Exception e_SE)
	{
		status = FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		status = FALSE;
	}
	catch(...)
	{
		status = FALSE;
	}

    return status ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (REFCLSID rclsid , REFIID riid, void **ppv)
{
	HRESULT status = S_OK ;
	SetStructuredExceptionHandler seh;

	
	try
	{
		EnterCriticalSection ( & g_CriticalSection ) ;

		if ( !g_initialised )
		{
			/*I don't do anything in thread attach and
			 *detach so do give them to me
			 */
			//BOOL bCallsDisabled;
			//bCallsDisabled=DisableThreadLibraryCalls(hInstance);

			//initialise the helper
			if (S_OK != CSmirAccess :: Init())
			{
				status = FALSE;
			}
			else
			{
				//allocate the cached class factory
				if(NULL == g_pClassFactoryHelper)
					g_pClassFactoryHelper= new SmirClassFactoryHelper;
				status = TRUE ;
			}

			g_initialised = TRUE ;
		}

		CSMIRGenericClassFactory *lpClassFac = NULL;
		
		if((CLSID_SMIR_Database==rclsid)||
						(IID_IConnectionPointContainer ==rclsid))
		{
			lpClassFac = new CSMIRClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_ModHandle==rclsid)
		{
			lpClassFac = new CModHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_GroupHandle==rclsid)
		{
			lpClassFac = new CGroupHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_ClassHandle==rclsid)
		{
			lpClassFac = new CClassHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_NotificationClassHandle==rclsid)
		{
			lpClassFac = new CNotificationClassHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_ExtNotificationClassHandle==rclsid)
		{
			lpClassFac = new CExtNotificationClassHandleClassFactory(rclsid) ;
		}
		else
		{
			//the caller has asked for an interface I don't support
			return(CLASS_E_CLASSNOTAVAILABLE);
		}

		if (NULL==lpClassFac)
		{
			return(E_OUTOFMEMORY);
		}

		status = lpClassFac->QueryInterface (riid , ppv) ;
		if (FAILED(status))
		{
			delete lpClassFac;
		}

		LeaveCriticalSection ( & g_CriticalSection ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be unloaded.
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection ( & g_CriticalSection ) ;

		BOOL unload = (0 == CSMIRClassFactory :: locksInProgress) && 
					  (0 == CSMIRClassFactory :: objectsInProgress) &&
					  (0 == CModHandleClassFactory :: locksInProgress) && 
					  (0 == CModHandleClassFactory :: objectsInProgress) &&
					  (0 == CGroupHandleClassFactory :: locksInProgress) && 
					  (0 == CGroupHandleClassFactory :: objectsInProgress) &&
					  (0 == CClassHandleClassFactory :: locksInProgress) && 
					  (0 == CClassHandleClassFactory :: objectsInProgress) &&
					  (0 == CNotificationClassHandleClassFactory :: locksInProgress) && 
					  (0 == CNotificationClassHandleClassFactory :: objectsInProgress) &&
					  (0 == CExtNotificationClassHandleClassFactory :: locksInProgress) && 
					  (0 == CExtNotificationClassHandleClassFactory :: objectsInProgress);

		if ( unload )
			CSmirAccess :: ShutDown();

		LeaveCriticalSection ( & g_CriticalSection ) ;
		return ResultFromScode(unload?S_OK:S_FALSE);
	}
	catch(Structured_Exception e_SE)
	{
		return S_FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		return S_FALSE;
	}
	catch(...)
	{
		return S_FALSE;
	}
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllRegisterServer()
{
	SetStructuredExceptionHandler seh;

	try
	{
		wchar_t szID[NUMBER_OF_SMIR_INTERFACES][128];
		//wchar_t szCLSID[NUMBER_OF_SMIR_INTERFACES][128];
		LPTSTR szModule[512];

		/*life would be easier if I could create a pointer to a reference
		 *but I can't so I have to hand create each root string before creating
		 *the registry entries.
		 */

		//Create some base key strings.
		
		//one for the interrogative interface
		int iRet = StringFromGUID2(CLSID_SMIR_Database,(wchar_t*)&szID[0], 128);
		
		//one for the module handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ModHandle, (wchar_t*)&szID[1], 128);

		//one for the group handle interface
		iRet = StringFromGUID2(CLSID_SMIR_GroupHandle, (wchar_t*)&szID[2], 128);

		//one for the class handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ClassHandle, (wchar_t*)&szID[3], 128);

		//one for the notificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_NotificationClassHandle, (wchar_t*)&szID[4], 128);

		//one for the extnotificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ExtNotificationClassHandle, (wchar_t*)&szID[5], 128);

		for (int i=0;i<NUMBER_OF_SMIR_INTERFACES;i++)
		{
			wchar_t szCLSID[128];
			wcscpy((wchar_t*)szCLSID, CLSID_STR);
			wcscat((wchar_t*)szCLSID,(wchar_t*)&szID[i]);

			//Create entries under CLSID
			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, NULL, NULL, SMIR_NAME_STR))
				return SELFREG_E_CLASS;

			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, NOT_INTERT_STR, NULL, NULL))
				return SELFREG_E_CLASS;

			GetModuleFileName(g_hInst, (wchar_t*)szModule
				, sizeof(szModule)/sizeof(wchar_t));
			
			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, INPROC32_STR, NULL,(wchar_t*) szModule))
				return SELFREG_E_CLASS;

			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, INPROC32_STR,
					THREADING_MODULE_STR, APARTMENT_STR))
				return SELFREG_E_CLASS;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		wchar_t szID[128];
		wchar_t szCLSID[NUMBER_OF_SMIR_INTERFACES][128];
		wchar_t szTemp[256];

		//one for the smir interface
		int iRet = StringFromGUID2(CLSID_SMIR_Database, szID, 128);
		wcscpy((wchar_t*)szCLSID[0], CLSID_STR);
		wcscat((wchar_t*)szCLSID[0], szID);
		
		//one for the module handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ModHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[1], CLSID_STR);
		wcscat((wchar_t*)szCLSID[1], szID);

		//one for the group handle interface
		iRet = StringFromGUID2(CLSID_SMIR_GroupHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[2], CLSID_STR);
		wcscat((wchar_t*)szCLSID[2], szID);

		//one for the class handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ClassHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[3], CLSID_STR);
		wcscat((wchar_t*)szCLSID[3],szID);

		//one for the notificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_NotificationClassHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[4], CLSID_STR);
		wcscat((wchar_t*)szCLSID[4], szID);

		//one for the extnotificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ExtNotificationClassHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[5], CLSID_STR);
		wcscat((wchar_t*)szCLSID[5], szID);

		for (int i=0;i<NUMBER_OF_SMIR_INTERFACES;i++)
		{
			wsprintf(szTemp, REG_FORMAT_STR, (wchar_t*)&szCLSID[i], NOT_INTERT_STR);
			RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

			wsprintf(szTemp, REG_FORMAT_STR, (wchar_t*)&szCLSID[i], INPROC32_STR);
			RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

			RegDeleteKey(HKEY_LOCAL_MACHINE, (wchar_t*)&szCLSID[i]);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

    return S_OK;
 }

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256] = { L'\0' };

	wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
		wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
	, szKey, 0, NULL, REG_OPTION_NON_VOLATILE
	, KEY_ALL_ACCESS, NULL, &hKey, NULL))
	return FALSE;

    if (NULL!=pszValue)
    {
	if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
	    , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\classfac.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"
#include "evtcons.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif
//initialise the statics
LONG CModHandleClassFactory::locksInProgress = 0;
LONG CGroupHandleClassFactory::locksInProgress = 0;
LONG CClassHandleClassFactory::locksInProgress = 0;
LONG CNotificationClassHandleClassFactory::locksInProgress = 0;
LONG CExtNotificationClassHandleClassFactory::locksInProgress = 0;
LONG CSMIRClassFactory::locksInProgress = 0;

LONG CSMIRClassFactory::objectsInProgress = 0;
LONG CModHandleClassFactory::objectsInProgress = 0;
LONG CGroupHandleClassFactory::objectsInProgress = 0;
LONG CClassHandleClassFactory::objectsInProgress = 0;
LONG CNotificationClassHandleClassFactory::objectsInProgress = 0;
LONG CExtNotificationClassHandleClassFactory::objectsInProgress = 0;


CSMIRClassFactory :: CSMIRClassFactory (CLSID m_clsid) 
				:CSMIRGenericClassFactory(m_clsid) 
{
	bConstructed=300;
}

//***************************************************************************
//
// CSMIRClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CSMIRClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CSMIRClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CSMIRClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}
CSMIRClassFactory :: ~CSMIRClassFactory ( void ) 
{

};

//***************************************************************************
//
// CSMIRClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSMIRClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;

	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_Interrogative==riid)||
			(IID_ISMIR_Administrative==riid)||
				(IID_ISMIR_Database == riid) ||
					(IID_ISMIRWbemConfiguration == riid) ||
						(IID_ISMIR_Notify == riid)||
							(IID_IConnectionPointContainer==riid)||
								(IID_IUnknown==riid))
	{
		/*OK the interrogative, administrative and notify interfaces
		 *are contained in the smir interface so just create the smir
		 */
		try
		{
			lObj = (LPUNKNOWN)(new CSmir);
		}
		catch (...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}

//***************************************************************************
//
// CModHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CModHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CGroupHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CModHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}



//***************************************************************************
//
// CModHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CModHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_ModHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirModuleHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}

//***************************************************************************
//
// CClassHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CClassHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CGroupHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CClassHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CClassHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClassHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_ClassHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirClassHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}



//***************************************************************************
//
// CGroupHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CGroupHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}

//***************************************************************************
//
// CGroupHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CGroupHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CGroupHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CGroupHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_GroupHandle==riid)||
					(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirGroupHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}

//***************************************************************************
//
// CSMIRClassFactory::CSMIRClassFactory
// CSMIRClassFactory::~CSMIRClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CSMIRGenericClassFactory :: CSMIRGenericClassFactory (CLSID iid)
{
	m_referenceCount=0;
}

CSMIRGenericClassFactory::~CSMIRGenericClassFactory ()
{
}
STDMETHODIMP_(ULONG) CSMIRGenericClassFactory :: AddRef ()
{
	/*criticalSection.Lock();
	m_referenceCount++;
	criticalSection.Unlock();
	*/
	InterlockedIncrement(&m_referenceCount);
	return m_referenceCount;
}

STDMETHODIMP_(ULONG) CSMIRGenericClassFactory :: Release ()
{
	//if ((--m_referenceCount)==0)
	long ret;
	if ((ret=InterlockedDecrement(&m_referenceCount))==0)
	{
		delete this;
		return 0;
	}
	else
	{
		return ret;
	}
}


//****************************NotificationClass stuff*****************

//***************************************************************************
//
// CNotificationClassHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CNotificationClassHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CNotificationClassHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CNotificationClassHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CNotificationClassHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CNotificationClassHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter,
								REFIID riid, LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_NotificationClassHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirNotificationClassHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}


//***************************************************************************
//
// CExtNotificationClassHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CExtNotificationClassHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CExtNotificationClassHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CExtNotificationClassHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CExtNotificationClassHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CExtNotificationClassHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter,
								REFIID riid, LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_ExtNotificationClassHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirExtNotificationClassHandle;
		}
		catch (...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\enum.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include "enum.h"
#include "textdef.h"
#include "helper.h"
#include "bstring.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

CEnumSmirMod :: CEnumSmirMod( CSmir *a_Smir )
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir - create it if you can't open it
	IWbemServices * moServ = NULL ;	
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem
		if ( moContext )
			moContext->Release () ;
		return;
	}

	//I have now opened the smir namespace so look at the module namespaces
	IEnumWbemClassObject *pEnum = NULL ;

	//enumerate all of the namespaces that have a __CLASS of MODULE
	CBString t_BStr (MODULE_NAMESPACE_NAME);
	SCODE sRes = moServ->CreateInstanceEnum(t_BStr.GetString (), 
			RESERVED_WBEM_FLAG,moContext, &pEnum);

	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//we have another problem or we have no modules to enumerate
		return;
	}

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned;

	//OK we have some so loop over the namespaces
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirModHandle *pTModule = NULL ;

		SCODE result = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ModHandle,
									IID_ISMIR_ModHandle,(PVOID *)&pTModule);

		if (FAILED(result)||(NULL == pTModule))
		{
			//problem!
			pSmirMosClassObject->Release();
			pEnum->Release();
			//add some trace
			break;
		}

		/*things are looking good; we have the handle to the instance so get the info
		 *some of there properties may be blank so be defensive (SysAllocStrig does 
		 *most of this for us)
		 */
		
		//extract the properties		
		*((CSmirModuleHandle*)pTModule) << pSmirMosClassObject;

		pSmirMosClassObject->Release();
		pSmirMosClassObject=NULL;
		m_IHandleArray.Add(pTModule);		
	}

	pEnum->Release();
	/*as soon as this returns the caller (me) will addref and pass the 
	 *interface back to the [real] caller. => I will have to guard against
	 *someone releasing the interface whilst I'm using it.
	 */
}

CEnumSmirMod :: CEnumSmirMod(IEnumModule *pSmirMod)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	if (NULL == pSmirMod)
	{
		return;
	}

	ULONG uCount=1; 
    ISmirModHandle *pModule = NULL ;
    ULONG puReturned = 0;

	//OK loop over the module namespaces
	
	for(pSmirMod->Reset();S_OK==pSmirMod->Next(uCount,&pModule,&puReturned);)
	{
		ISmirModHandle *pTModule = NULL ;
		SCODE result = pModule->QueryInterface(IID_ISMIR_ModHandle,(void**)&pTModule );
		pModule->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to the array
		 */
		m_IHandleArray.Add(pTModule);		
	}
}

CEnumSmirMod :: ~CEnumSmirMod ()
{
	/*let the EnumObjectArray empty the module array and delete the 
	 *modules I created
	 */
}
/*
 * CEnumSmirMod::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumSmirMod::QueryInterface(IN REFIID riid, 
										  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ModuleEnumerator==riid)
			*ppv=this;

		if (NULL==*ppv)
		{
			return ResultFromScode(E_NOINTERFACE);
		}
		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CEnumSmirMod::Clone(IN IEnumModule  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ModIndex = m_Index;
		PENUMSMIRMOD pTmpEnumSmirMod = new CEnumSmirMod(this);
		m_Index = ModIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirMod)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		pTmpEnumSmirMod->QueryInterface(IID_ISMIR_ModuleEnumerator,(void**)ppenum);

		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}



/*
 * CEnumSmirGroup::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */
STDMETHODIMP CEnumSmirGroup::QueryInterface(IN REFIID riid, 
											OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_GroupEnumerator==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CEnumSmirGroup::Clone(OUT IEnumGroup  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppenum)
			return E_INVALIDARG;
		int GroupIndex = m_Index;
		PENUMSMIRGROUP pTmpEnumSmirGroup = new CEnumSmirGroup(this);
		m_Index = GroupIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirGroup)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		pTmpEnumSmirGroup->QueryInterface(IID_ISMIR_GroupEnumerator,(void**)ppenum);

		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CEnumSmirGroup :: ~CEnumSmirGroup ()
{
	/*let the EnumObjectArray empty the module array and delete the 
	 *modules I created
	 */
}

CEnumSmirGroup :: CEnumSmirGroup ( 

	IN CSmir *a_Smir , 
	IN ISmirModHandle *hModule
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//fill in the path etc
	if(NULL!=hModule)
	{
		IWbemServices * moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
		res= CSmirAccess :: Open(a_Smir,&moServ,hModule);
		if ((S_FALSE==res)||(NULL == (void*)moServ))
		{
			if ( moContext )
				moContext->Release () ;

			//we have a problem
			return;
		}

		//I have now opened the module namespace so look at the group namespaces

		IEnumWbemClassObject *pEnum = NULL ;
		CBString t_BStr (GROUP_NAMESPACE_NAME);
		SCODE sRes = moServ->CreateInstanceEnum (

			t_BStr.GetString (), 
			RESERVED_WBEM_FLAG, 
			moContext,
			&pEnum
		);

		if ( moContext )
			moContext->Release () ;
		moServ->Release();

		if (FAILED(sRes)||(NULL == pEnum))
		{
			//there are no instances
			return;
		}

		ULONG uCount=1; 
		ULONG puReturned = 0 ;
		IWbemClassObject *pSmirMosClassObject = NULL ;

		pEnum->Reset();
		while(S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned))
		{
			ISmirGroupHandle *pTGroup = NULL ;

			SCODE result = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_GroupHandle,
													IID_ISMIR_GroupHandle, (PVOID *)&pTGroup);

			if (FAILED(result)||(NULL == pTGroup))
			{
				//we have a problem
				pSmirMosClassObject->Release();
				break;
			}
			//save the module name
			BSTR szModuleName = NULL ;
			hModule->GetName(&szModuleName);
			pTGroup->SetModuleName(szModuleName);
			SysFreeString(szModuleName);
			
			//extract the properties
			*((CSmirGroupHandle*)pTGroup) << pSmirMosClassObject;
			//release this resource here because we are in a loop
			pSmirMosClassObject->Release();
			m_IHandleArray.Add(pTGroup);		
		}

		pEnum->Release();
	}
	else
	{
		//open the smir and enumerate the modules
		ISmirInterrogator *pInterrogativeInt = NULL ;

		SCODE result = a_Smir->QueryInterface ( 

			IID_ISMIR_Interrogative, 
			( void ** ) &pInterrogativeInt
		) ;

		if (S_OK != result)
		{
			if(NULL != pInterrogativeInt)
				pInterrogativeInt->Release();
			return ;
		}

		IEnumModule *pEnumSmirMod = NULL ;
		//ok now let's use the interrogative interface
		result = pInterrogativeInt->EnumModules(&pEnumSmirMod);
		//now use the enumerator
		if((S_OK != result)||(NULL == pEnumSmirMod))
		{
			pInterrogativeInt->Release();
			//no modules
			return;
		}

		ISmirModHandle *phModule = NULL ;
		for(int iCount=0;S_OK==pEnumSmirMod->Next(1, &phModule, NULL);iCount++)
		{
			//we have the module so get the groups via the enumerator
			IEnumGroup *pEnumSmirGroup = NULL ;
			result = pInterrogativeInt->EnumGroups(&pEnumSmirGroup,phModule);
			//now use the enumerator
			if((S_OK == result)&&(pEnumSmirGroup))
			{
				ISmirGroupHandle *phGroup = NULL ;
				for(int iCount=0;S_OK==pEnumSmirGroup->Next(1, &phGroup, NULL);iCount++)
				{
					m_IHandleArray.Add(phGroup);		
				}
			}
			phModule->Release();
			pEnumSmirGroup->Release();
		}
		pEnumSmirMod->Release();
		pInterrogativeInt->Release();
	}
}

CEnumSmirGroup :: CEnumSmirGroup(IN IEnumGroup *pSmirGroup)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	if(NULL == pSmirGroup)
	{
		//bad args
		return;
	}

	ULONG uCount=1; 
    ISmirGroupHandle *pGroup = NULL ;
    ULONG puReturned;
	//OK loop over the group namespaces
	for(pSmirGroup->Reset();S_OK==pSmirGroup->Next(uCount,&pGroup,&puReturned);)
	{
		ISmirGroupHandle *pTGroup =NULL ;
		SCODE result = pGroup->QueryInterface(IID_ISMIR_ModHandle,(void**)&pTGroup );
		pGroup->Release();

		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTGroup);		
	}
}

/*
 * CEnumSmirClass::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumSmirClass :: QueryInterface(IN REFIID riid, 
											  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ClassEnumerator==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP CEnumSmirClass::Clone(IEnumClass  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ClassIndex = m_Index;
		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass(this);
		m_Index = ClassIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		if(NOERROR == pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppenum))
			return S_OK;

		return E_UNEXPECTED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

}

CEnumSmirClass :: CEnumSmirClass(IEnumClass *pSmirClass)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	ULONG uCount=1; 
    ISmirClassHandle *pClass = NULL ;
    ULONG puReturned;

	//OK loop through the enumerator
	
	for(pSmirClass->Reset();S_OK==pSmirClass->Next(uCount,&pClass,&puReturned);)
	{
		ISmirClassHandle *pTClass = NULL ;
		SCODE result = pClass->QueryInterface(IID_ISMIR_ClassHandle,(void**)&pTClass );
		pClass->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTClass);		
	}
}

/*enumerate all of the classes in the smir
 */

CEnumSmirClass :: CEnumSmirClass(

	CSmir *a_Smir ,
	ISmirDatabase *pSmir, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir
	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem
		return;
	}

	IEnumWbemClassObject *pEnum = NULL ;
	CBString t_Bstr(HMOM_SNMPOBJECTTYPE_STRING);
	SCODE sRes = moServ->CreateClassEnum (

		t_Bstr.GetString(),
		WBEM_FLAG_SHALLOW, 
		moContext, 
		&pEnum
	);

	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	//we have some classes so add them to the enumerator
	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0 ;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirClassHandle *pTClass = NULL ;

		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ClassHandle,
										IID_ISMIR_ClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			pSmirMosClassObject->Release();
			return;
		}

		pTClass->SetWBEMClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		
		//if this is an async enumeration signal the connectable object

		pSmirMosClassObject->Release();
	}
	pEnum->Release();
}

CEnumSmirClass :: CEnumSmirClass(

	CSmir *a_Smir ,
	ISmirDatabase *pSmir, 
	ISmirGroupHandle *hGroup, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	if(((CSmirGroupHandle*)hGroup)==NULL)
	{
		return;
	}

	//open the smir
	IWbemServices *moServ = NULL ;	//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ,hGroup,CSmirAccess::eModule);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem
		return;
	}

	BSTR szTmpGroupName = NULL ;				//the group name
	BSTR szTmpModuleName = NULL ;			//the module name

	hGroup->GetName(&szTmpGroupName);			//the group name
	hGroup->GetModuleName(&szTmpModuleName);	//the module name

	/*query for 
	 *associators of {\\.\root\default\SMIR\<module>:Group="<group>"}
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(BACKSLASH_STR)
					+CString(szTmpModuleName)
					+CString(COLON_STR)
					+CString(GROUP_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpGroupName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					);
	BSTR  szQuery = sQuery.AllocSysString();

	IEnumWbemClassObject *pEnum = NULL ;
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		0, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		SysFreeString(szTmpGroupName);
		SysFreeString(szTmpModuleName);
		return ;
	}

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirClassHandle *pTClass = NULL ;
		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ClassHandle,
										IID_ISMIR_ClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpGroupName);
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModuleName(szTmpModuleName);

		//save the group name
		pTClass->SetGroupName(szTmpGroupName);

		pTClass->SetWBEMClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		
		//if this is an async enumeration signal the connectable object
		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	SysFreeString(szTmpGroupName);
	pEnum->Release();
}

CEnumSmirClass :: CEnumSmirClass(

	CSmir *a_Smir ,
	ISmirDatabase *pSmir,
	ISmirModHandle *hModule, 
	DWORD dwCookie
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = 0;

	BSTR szTmpModuleName = NULL;
	hModule->GetName(&szTmpModuleName);

	/*query for 
	*associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"} where AssocClass=ModuleToClassAssociator
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(COLON_STR)
					+CString(MODULE_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpModuleName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					+CString(SMIR_ASSOC_QUERY_STR3)
					+CString(EQUALS_STR)
					+CString(SMIR_MODULE_ASSOC_CLASS_NAME)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		RESERVED_WBEM_FLAG, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		SysFreeString(szTmpModuleName);
		return ;
	}

	VARIANT pVal;
	VariantInit(&pVal);

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		BSTR szTmpGroupName = NULL;				//the group name (set when we find it)
		//find the group that this class belongs to (could be more than one group)

		//...

		//ok we have a class in the correct module so add it to the enumeration
		ISmirClassHandle *pTClass = NULL ;
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ClassHandle,
										IID_ISMIR_ClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModuleName(szTmpModuleName);

		pTClass->SetWBEMClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	pEnum->Release();
}

/*
 * CEnumSmir::Next
 * CEnumSmir::Skip
 * CEnumSmir::Reset
 *
 * Enumerator methods.  
 */

#pragma warning (disable:4018)

SCODE CEnumSmirMod::Next(IN ULONG celt, 
						   OUT ISmirModHandle **phModule, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
				//what is the next module in the SMIR namespace

				//allocate the handle and save it
				ISmirModHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

				//this could throw an exception but it would be the caller's fault
				if(NULL != hTmpModule)
				{
					phModule[iLoop] = hTmpModule;
					//don't forget that I have a handle to this
					phModule[iLoop]->AddRef();
					if (NULL != pceltFetched)
						(*pceltFetched)++;
				}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumSmirMod::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumSmirMod::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}

/*
 * CEnumSmir::AddRef
 * CEnumSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumSmirMod::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumSmirMod::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

/*
 * CEnumSmir::Next
 * CEnumSmir::Skip
 * CEnumSmir::Reset
 *
 * Enumerator methods.  
 */

#pragma warning (disable:4018)

SCODE CEnumSmirGroup::Next(IN ULONG celt, 
						   OUT ISmirGroupHandle **phModule, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next module in the SMIR namespace

					//allocate the handle and save it
					ISmirGroupHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phModule[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phModule[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumSmirGroup::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumSmirGroup::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}
/*
 * CEnumSmir::AddRef
 * CEnumSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumSmirGroup::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumSmirGroup::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}
/*
 * CEnumSmir::Next
 * CEnumSmir::Skip
 * CEnumSmir::Reset
 *
 * Enumerator methods.  
 */

#pragma warning (disable:4018)

SCODE CEnumSmirClass::Next(IN ULONG celt, 
						   OUT ISmirClassHandle **phModule, 
						   OUT ULONG * pceltFetched)
{	
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next module in the SMIR namespace

					//allocate the handle and save it
					ISmirClassHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phModule[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phModule[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumSmirClass::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumSmirClass::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}
/*
 * CEnumSmir::AddRef
 * CEnumSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumSmirClass::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumSmirClass::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}


//Notification Enum Classes

/*
 * CEnumNotificationClass::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumNotificationClass :: QueryInterface(IN REFIID riid, 
											  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_EnumNotificationClass==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CEnumNotificationClass::Clone(IEnumNotificationClass  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ClassIndex = m_Index;
		PENUMNOTIFICATIONCLASS pTmpEnumNotificationClass = new CEnumNotificationClass(this);
		m_Index = ClassIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumNotificationClass)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		if(NOERROR == pTmpEnumNotificationClass->QueryInterface(IID_ISMIR_EnumNotificationClass,(void**)ppenum))
			return S_OK;

		return E_UNEXPECTED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CEnumNotificationClass :: CEnumNotificationClass(IEnumNotificationClass *pSmirClass)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	ULONG uCount=1; 
    ISmirNotificationClassHandle *pClass = NULL ;
    ULONG puReturned;

	//OK loop through the enumerator
	
	for(pSmirClass->Reset();S_OK==pSmirClass->Next(uCount,&pClass,&puReturned);)
	{
		ISmirNotificationClassHandle *pTClass = NULL ;
		SCODE result = pClass->QueryInterface(IID_ISMIR_NotificationClassHandle,(void**)&pTClass );
		pClass->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTClass);		
	}
}

/*enumerate all of the classes in the smir
 */

CEnumNotificationClass :: CEnumNotificationClass (

	CSmir *a_Smir , 
	ISmirDatabase *pSmir, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir
	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem
		return;
	}

	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = NULL;
	CBString t_Bstr(HMOM_SNMPNOTIFICATIONTYPE_STRING);
	SCODE sRes = moServ->CreateClassEnum (

		t_Bstr.GetString(),
		WBEM_FLAG_SHALLOW, 
		moContext, 
		&pEnum
	);

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	//we have some classes so add them to the enumerator
	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirNotificationClassHandle *pTClass;

		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_NotificationClassHandle,
										IID_ISMIR_NotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			pSmirMosClassObject->Release();
			return;
		}

		pTClass->SetWBEMNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		
		//if this is an async enumeration signal the connectable object

		pSmirMosClassObject->Release();
	}
	pEnum->Release();
}


CEnumNotificationClass :: CEnumNotificationClass (

	IN CSmir *a_Smir , 
	ISmirDatabase *pSmir,
	ISmirModHandle *hModule, 
	DWORD dwCookie
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	//I have now opened the smir namespace so look at the classes
	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		return ;
	}

	IEnumWbemClassObject *pEnum = NULL ;
	BSTR szTmpModuleName = NULL ;
	hModule->GetName(&szTmpModuleName);

	/*query for 
	*associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"} where AssocClass=ModToNotificationClassAssoc
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(COLON_STR)
					+CString(MODULE_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpModuleName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					+CString(SMIR_ASSOC_QUERY_STR3)
					+CString(EQUALS_STR)
					+CString(SMIR_MODULE_ASSOC_NCLASS_NAME)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		RESERVED_WBEM_FLAG, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	VARIANT pVal;
	VariantInit(&pVal);

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	HRESULT enumResult = S_OK;
	for(pEnum->Reset();S_OK==(enumResult = pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned));)
	{
		BSTR szTmpGroupName = NULL;				//the group name (set when we find it)
		//find the group that this class belongs to (could be more than one group)

		//...

		//ok we have a class in the correct module so add it to the enumeration
		ISmirNotificationClassHandle *pTClass = NULL ;
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_NotificationClassHandle,
										IID_ISMIR_NotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModule(szTmpModuleName);

		pTClass->SetWBEMNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	pEnum->Release();
}


/*
 * CEnumNotificationClass::Next
 * CEnumNotificationClass::Skip
 * CEnumNotificationClass::Reset
 *  
 */

#pragma warning (disable:4018)

SCODE CEnumNotificationClass::Next(IN ULONG celt, 
						   OUT ISmirNotificationClassHandle **phClass, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next class

					//allocate the handle and save it
					ISmirNotificationClassHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phClass[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phClass[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumNotificationClass::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumNotificationClass::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}

/*
 * CEnumNotificationClass::AddRef
 * CEnumNotificationClass::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumNotificationClass::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}

}

ULONG CEnumNotificationClass::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
	    return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}

}


//ExtNotification Enum Classes

/*
 * CEnumExtNotificationClass::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumExtNotificationClass :: QueryInterface(IN REFIID riid, 
											  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_EnumExtNotificationClass==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CEnumExtNotificationClass::Clone(IEnumExtNotificationClass  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ClassIndex = m_Index;
		PENUMEXTNOTIFICATIONCLASS pTmpEnumNotificationClass = new CEnumExtNotificationClass(this);
		m_Index = ClassIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumNotificationClass)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		if(NOERROR == pTmpEnumNotificationClass->QueryInterface(IID_ISMIR_EnumExtNotificationClass,(void**)ppenum))
			return S_OK;

		return E_UNEXPECTED;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}

}

CEnumExtNotificationClass :: CEnumExtNotificationClass(IEnumExtNotificationClass *pSmirClass)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	ULONG uCount=1; 
    ISmirExtNotificationClassHandle *pClass = NULL ;
    ULONG puReturned;

	//OK loop through the enumerator
	
	for(pSmirClass->Reset();S_OK==pSmirClass->Next(uCount,&pClass,&puReturned);)
	{
		ISmirExtNotificationClassHandle *pTClass = NULL ;
		SCODE result = pClass->QueryInterface(IID_ISMIR_ExtNotificationClassHandle,(void**)&pTClass );
		pClass->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTClass);		
	}
}

/*enumerate all of the classes in the smir
 */

CEnumExtNotificationClass :: CEnumExtNotificationClass(

	CSmir *a_Smir , 
	ISmirDatabase *pSmir, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir
	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		//we have a problem
		if ( moContext )
			moContext->Release () ;
		return;
	}

	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = NULL ;
	CBString t_Bstr(HMOM_SNMPEXTNOTIFICATIONTYPE_STRING);
	SCODE sRes = moServ->CreateClassEnum (

		t_Bstr.GetString(),
		WBEM_FLAG_SHALLOW, 
		moContext,
		&pEnum
	);

	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	//we have some classes so add them to the enumerator
	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirExtNotificationClassHandle *pTClass = NULL ;

		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ExtNotificationClassHandle,
										IID_ISMIR_ExtNotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			pSmirMosClassObject->Release();
			return;
		}

		pTClass->SetWBEMExtNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	pEnum->Release();
}

CEnumExtNotificationClass :: CEnumExtNotificationClass (

	CSmir *a_Smir , 
	ISmirDatabase *pSmir,
	ISmirModHandle *hModule, 
	DWORD dwCookie
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	IWbemServices *moServ = NULL ;	//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		return ;
	}

	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = NULL ;
	BSTR szTmpModuleName = NULL;
	hModule->GetName(&szTmpModuleName);

	/*query for 
	*associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"} where AssocClass=ModToExtNotificationClassAssoc
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(COLON_STR)
					+CString(MODULE_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpModuleName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					+CString(SMIR_ASSOC_QUERY_STR3)
					+CString(EQUALS_STR)
					+CString(SMIR_MODULE_ASSOC_EXTNCLASS_NAME)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		RESERVED_WBEM_FLAG, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	VARIANT pVal;
	VariantInit(&pVal);

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		BSTR szTmpGroupName = NULL;				//the group name (set when we find it)
		//find the group that this class belongs to (could be more than one group)

		//...

		//ok we have a class in the correct module so add it to the enumeration
		ISmirExtNotificationClassHandle *pTClass = NULL ;
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ExtNotificationClassHandle,
										IID_ISMIR_ExtNotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModule(szTmpModuleName);

		pTClass->SetWBEMExtNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	pEnum->Release();
}

/*
 * CEnumNotificationClass::Next
 * CEnumNotificationClass::Skip
 * CEnumNotificationClass::Reset
 *  
 */

#pragma warning (disable:4018)

SCODE CEnumExtNotificationClass::Next(IN ULONG celt, 
						   OUT ISmirExtNotificationClassHandle **phClass, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next class

					//allocate the handle and save it
					ISmirExtNotificationClassHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phClass[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phClass[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumExtNotificationClass::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumExtNotificationClass::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}
/*
 * CEnumNotificationClass::AddRef
 * CEnumNotificationClass::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumExtNotificationClass::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumExtNotificationClass::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\csmir.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#define __UNICODE

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"
#include "enum.h"

#include <textdef.h>
#include <helper.h>
#include "bstring.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

extern CRITICAL_SECTION g_CriticalSection ;
	

/*
 * CSmir:: Constructor and destructor
 *
 * Purpose:
 *	Standard constructor and destructor for CSmir object
 *	There should only ever be one CSmir object because it holds the 
 *	connection point object and controlls the access to the database. 
 *  When the database changes it flaggs the chamce using the conenction
 *  point object. If you have more than one CSmir object you will miss
 *  database changes. The class factory handles all of this.
 * Parameters: None
 *
 * Return Value: None
 */

#pragma warning (disable:4355)

CSmir :: CSmir ()
		:m_Interrogator(this), m_Administrator(this),
		m_Configuration(this)
{
	//init reference count
	m_cRef=0;
	//increase the reference count in the class factory
	CSMIRClassFactory::objectsInProgress++;
}

#pragma warning (default:4355)

CSmir :: ~CSmir ()
{
	//decrease the reference count in the class factory
	CSMIRClassFactory::objectsInProgress--;
}

/*
 * CSmir::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the IUnknown, 
 *  ISmirDatabase, ISmirInterrogator, and ISmirAdministrator interfaces.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmir::QueryInterface(IN REFIID riid, OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*this lock is to protect the caller from changing his own
		 *parameter (ppv) whilst I am using it. This is unlikely and
		 *he deserves what he gets if he does it but it is still worth 
		 *the effort.
		 */
		criticalSection.Lock () ;
		//Always NULL the out-parameters
		*ppv=NULL;

		/*
		 * IUnknown comes from CSmir.  Note that here we do not need
		 * to explicitly typecast the object pointer into an interface
		 * pointer because the vtables are identical.  If we had
		 * additional virtual member functions in the object, we would
		 * have to cast in order to set the right vtable.  
		 */

		/*CLSID_ISMIR_Database serves very little purpose but it does provide
		 *an entry point from which you can ittetate the other interfaces; it
		 *makes sense to create an CLSID_ISMIR_Database instance and move to the 
		 *other interfaces rather than picking one of the other interfaces as the
		 *entry point.
		 */

		if ((IID_IUnknown==riid)||(IID_ISMIR_Database == riid))
			*ppv=this;

		//Other interfaces come from contained classes
		if (IID_ISMIR_Interrogative==riid)
			*ppv=&m_Interrogator;

		if (IID_ISMIR_Administrative==riid)
			*ppv=&m_Administrator;

		if((IID_IConnectionPointContainer == riid)||(IID_ISMIR_Notify == riid))
			*ppv = sm_ConnectionObjects;

		if(IID_ISMIRWbemConfiguration == riid)
			*ppv = &m_Configuration;

		if (NULL==*ppv)
		{
			criticalSection.Unlock () ;
			return E_NOINTERFACE;
		}

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		criticalSection.Unlock () ;
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmir ::AddRef
 * CSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmir::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*The CSmir object is a shared resource (as long as there is at leasr 
		 *one connection object) so I must protect the reference count.
		 */
		//increase the reference
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmir::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
		{
			return ret;
		}

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

/*
 * CSmir::AddNotify
 * CSmir::DeleteNotify
 *
 * Purpose:
 *	These methods provide the hooks into the notification interface.
 *	The caller implements the ISMIRNotify and passes ti to AddNotify, AddNotify
 *	marshals the connection point interface and calls Advise to add the 
 *	callers ISMIRNotify to the collection of objects to notify when the SMIR
 *	changes. DeleteNotify does the opposite.
 *
 * Parameters:
 *  pNotifySink       The caller's ISMIRNotify implementation
 *  pRichTea,lRichTea Cookie used to identify the caller's 
 *					  ISMIRNotify (generated by CSmir)
 *
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure, E_NOINTERFACE if the
 *                  interface is not supported, E_INVALIDARG if the parameters
 *					are invalid
 */

STDMETHODIMP CSmir :: AddNotify(IN ISMIRNotify *pNotifySink, OUT DWORD *pRichTea)
{
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection ( & g_CriticalSection );

		if (sm_ConnectionObjects == NULL)
		{
			sm_ConnectionObjects = new CSmirConnObject(this);
			sm_ConnectionObjects->AddRef ();
		}

		/*make sure that I don't get deleted whilst doing this. I should not have
		 *to do this since it can only happen if the caller releases the interface 
		 *whilst making the call.
		 */
		if (NULL == pNotifySink)
		{
			LeaveCriticalSection ( & g_CriticalSection ) ;
			return WBEM_E_FAILED;
		}
		/*I do not need a lock for this piece of code; having found the interface someone
		 *could release it from beneath me but the FindConnectionPoint causes an addref
		 *so I can rely on m_ConnectionObjects to keep his own house in order.
		 */
		IConnectionPoint *pCP = NULL ;
		SCODE hr = sm_ConnectionObjects->FindConnectionPoint(IID_ISMIR_Notify, &pCP);

		if ((S_OK != hr)||(NULL == pCP))
		{
			LeaveCriticalSection ( & g_CriticalSection ) ;
			return WBEM_E_FAILED;
		}

		hr = ((CSmirNotifyCP*)(pCP))->Advise(this, pNotifySink, pRichTea);
		pCP->Release();
		if (S_OK != hr)
		{
			LeaveCriticalSection ( & g_CriticalSection ) ;
			return WBEM_E_FAILED;
		}

		LeaveCriticalSection ( & g_CriticalSection ) ;
		return ((S_OK == hr)?S_OK:WBEM_E_FAILED);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CSmir :: DeleteNotify(IN DWORD lRichTea)
{
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection ( & g_CriticalSection ) ;

		if (sm_ConnectionObjects == NULL)
		{
			return WBEM_E_FAILED;
		}

		/*I don't need to lock the SMIR object until the unadvise but it 
		 *is safer and future proof if I do it here.
		 */
		SCODE hr=S_OK;
		/*I do not need a lock for this piece of code; having found the interface someone
		 *could release it from beneath me but the FindConnectionPoint causes an addref
		 *so I can rely on m_ConnectionObjects to keep his own house in order.
		 */
		IConnectionPoint *pCP = NULL;
		hr=sm_ConnectionObjects->FindConnectionPoint(IID_ISMIR_Notify, &pCP);

		if (hr != S_OK||(NULL == pCP))
		{
			LeaveCriticalSection ( & g_CriticalSection ) ;
			return  CONNECT_E_NOCONNECTION;
		}
		LeaveCriticalSection ( & g_CriticalSection ) ;

		hr=((CSmirNotifyCP*)(pCP))->Unadvise(this, lRichTea);
		pCP->Release();

		return ((S_OK == hr)?S_OK:CONNECT_E_NOCONNECTION==hr?E_INVALIDARG:WBEM_E_FAILED);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


/*CSmirInterrogator interface implementation
 * Constructor/destructor
 * CSmirInterrogator::QueryInterface
 * CSmirInterrogator::AddRef
 * CSmirInterrogator::Release
 *
 * IUnknown members that delegate to m_pSmir
 */

CSmirInterrogator :: CSmirInterrogator ( CSmir *pSmir ) : m_cRef ( 1 ) , m_pSmir ( pSmir ) 
{
}

STDMETHODIMP CSmirInterrogator::QueryInterface(IN REFIID riid, OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return m_pSmir->QueryInterface(riid, ppv);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirInterrogator::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * We maintain an "interface reference count" for debugging
		 * purposes, because the client of an object should match
		 * AddRef and Release calls through each interface pointer.
		 */
		++m_cRef;
		return m_pSmir->AddRef();
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirInterrogator::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * m_cRef is again only for debugging.  It doesn't affect
		 * CSmirInterrogator although the call to m_pSmir->Release does.
		 */
		--m_cRef;
		return m_pSmir->Release();
		//do not do anything after this release because you may have been deleted
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}


/* Interface implementations for the enumerator access methods
 *
 * CSmirInterrogator::EnumModules
 * CSmirInterrogator::EnumGroups
 * CSmirInterrogator::EnumClasses
 *
 * Parameters:
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 *
 */

SCODE CSmirInterrogator::EnumModules(OUT IEnumModule **ppEnumSmirMod)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppEnumSmirMod)
			return E_INVALIDARG;
		PENUMSMIRMOD pTmpEnumSmirMod = new CEnumSmirMod ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirMod)
		{
			return E_OUTOFMEMORY;
		}

		pTmpEnumSmirMod->QueryInterface(IID_ISMIR_ModuleEnumerator,(void**)ppEnumSmirMod);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator:: EnumGroups (OUT IEnumGroup **ppEnumSmirGroup, 
											IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirGroup)
			return E_INVALIDARG;
		PENUMSMIRGROUP pTmpEnumSmirGroup = new CEnumSmirGroup( m_pSmir , hModule);
		if(NULL == pTmpEnumSmirGroup)
		{
			return E_OUTOFMEMORY;
		}
		//we have an enumerator so  get the interface to pass back
		pTmpEnumSmirGroup->QueryInterface(IID_ISMIR_GroupEnumerator,(void**)ppEnumSmirGroup);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumAllClasses (OUT IEnumClass **ppEnumSmirclass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;

		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumClassesInGroup (OUT IEnumClass **ppEnumSmirclass, 
										 IN ISmirGroupHandle *hGroup)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass(m_pSmir , NULL,hGroup);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumClassesInModule (OUT IEnumClass **ppEnumSmirclass, 
										 IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass(m_pSmir , NULL, hModule);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppEnumSmirclass);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: GetWBEMClass(OUT IWbemClassObject **ppClass, IN BSTR pszClassName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if((NULL == pszClassName)||(NULL == ppClass))
			return E_INVALIDARG;

		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE res= CSmirAccess :: GetContext (m_pSmir , &moContext);
		res= CSmirAccess :: Open(m_pSmir , &moServ);

		if ((S_FALSE==res)||(NULL == (void*)moServ))
		{
			if ( moContext )
				moContext->Release () ;

			//we have a problem the SMIR is not there and cannot be created
			return WBEM_E_FAILED;
		}

		CBString t_BStr ( pszClassName ) ;
		res = moServ->GetObject(t_BStr.GetString (),RESERVED_WBEM_FLAG, moContext,ppClass,NULL);
		if ( moContext )
			moContext->Release () ;
		moServ->Release();
		if ((S_FALSE==res)||(NULL == *ppClass))
		{
			return WBEM_E_FAILED;
		}
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumAllNotificationClasses(IEnumNotificationClass **ppEnumSmirclass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;

		PENUMNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumNotificationClass ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumNotificationClass,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumAllExtNotificationClasses(IEnumExtNotificationClass **ppEnumSmirclass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;

		PENUMEXTNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumExtNotificationClass ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumExtNotificationClass,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumNotificationClassesInModule(IEnumNotificationClass **ppEnumSmirclass,
														   ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumNotificationClass( m_pSmir , NULL, hModule);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumNotificationClass,(void**)ppEnumSmirclass);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumExtNotificationClassesInModule(IEnumExtNotificationClass **ppEnumSmirclass,
															  ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMEXTNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumExtNotificationClass( m_pSmir , NULL, hModule);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumExtNotificationClass,(void**)ppEnumSmirclass);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirAdministrator::QueryInterface
 * CSmirAdministrator::AddRef
 * CSmirAdministrator::Release
 *
 * IUnknown members that delegate to m_pSmir
 */

CSmirAdministrator :: CSmirAdministrator ( CSmir *pSmir ) : m_cRef ( 1 ) , m_pSmir ( pSmir ) 
{
}

STDMETHODIMP CSmirAdministrator::QueryInterface(IN REFIID riid,
												OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return m_pSmir->QueryInterface(riid, ppv);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirAdministrator::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * We maintain an "interface reference count" for debugging
		 * purposes, because the client of an object should match
		 * AddRef and Release calls through each interface pointer.
		 */
		++m_cRef;
		return m_pSmir->AddRef();
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirAdministrator::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * m_cRef is again only for debugging.  It doesn't affect
		 * CObject2 although the call to m_pObj->Release does.
		 */
		--m_cRef;
		return m_pSmir->Release();
		//do not do anything after this release because you may have been deleted
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

SCODE CSmirAdministrator :: GetSerialiseHandle(ISmirSerialiseHandle **hSerialise,BOOL bClassDefinitionsOnly)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise)
		{
			return E_INVALIDARG;
		}
		CSmirSerialiseHandle *pSerialise = new CSmirSerialiseHandle(bClassDefinitionsOnly);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pSerialise)
		{
			return E_OUTOFMEMORY;
		}

		pSerialise->QueryInterface(IID_ISMIR_SerialiseHandle,(void**)hSerialise);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirAdministrator::AddModule
 * Purpose:			Creates the module namespace in the SMIR
 * Parameters:
 *	ISmirModHandle*	A module handle interface obtained through ISmirModHandle and
 *					filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: AddModuleToSerialise(ISmirModHandle *hModule,
												ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hModule)
		{
			return E_INVALIDARG;
		}
		if((*((CSmirModuleHandle*)hModule))!=NULL)
		{
			*((CSmirModuleHandle*)hModule)>>hSerialise;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddClassToSerialise(ISmirGroupHandle  *hGroup, 
												ISmirClassHandle *hClass,
												ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hClass || NULL == hGroup)
		{
			return E_INVALIDARG;
		}
		BSTR szGroupName=NULL;
		BSTR szModuleName=NULL;
		hGroup->GetName(&szGroupName);
		hGroup->GetModuleName(&szModuleName);

		hClass->SetGroupName(szGroupName);
		hClass->SetModuleName(szModuleName);

		SysFreeString(szModuleName);
		SysFreeString(szGroupName);

		if(*((CSmirClassHandle*)hClass)!=NULL )
		{
			//it is a valid handle so serialise it
			*((CSmirClassHandle*)hClass)>>hSerialise;
			return S_OK;
		}
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddGroupToSerialise(ISmirModHandle *hModule, 
												ISmirGroupHandle  *hGroup,
												ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hGroup|| NULL == hModule)
		{
			return E_INVALIDARG;
		}
		BSTR szModuleName=NULL;
		
		hModule->GetName(&szModuleName);
		
		hGroup->SetModuleName(szModuleName);
		//clean up
		SysFreeString(szModuleName);

		if(*((CSmirGroupHandle*)hGroup)!=NULL)
		{
			//do the serialise
			*((CSmirGroupHandle*)hGroup)>>hSerialise;
			return S_OK;
		}

		//either the modfule or group name were not set so it is an error
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddModule(IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == hModule)
		{
			return E_INVALIDARG;
		}
		if(S_OK==((CSmirModuleHandle*)hModule)->AddToDB(m_pSmir))
		{
			//notify people of the change
			return S_OK ;
		}
		return WBEM_E_FAILED ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
/*
 * CSmirAdministrator::DeleteModule
 * Purpose:			Delete the module namespace from the SMIR
 * Parameters:
 *	ISmirModHandle*	A module handle interface obtained through ISmirModHandle and
 *					filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: DeleteModule(IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the arguments
		if(NULL == hModule)
		{
			return E_INVALIDARG;
		}
		if(S_OK==((CSmirModuleHandle *)hModule)->DeleteFromDB(m_pSmir))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
/*
 * CSmirAdministrator::DeleteAllModules
 * Purpose:			Delete the SMIR
 * Parameters:
 *	ISmirModHandle*	A module handle interface obtained through ISmirModHandle and
 *					filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: DeleteAllModules()
{
	SetStructuredExceptionHandler seh;

	try
	{
		//enumerate all modules and delete them...
		IEnumModule *pEnumSmirMod = NULL;
		SCODE result = m_pSmir->m_Interrogator.EnumModules(&pEnumSmirMod);
		
		if((S_OK != result)||(NULL == pEnumSmirMod))
		{
			//no modules
			return WBEM_NO_ERROR;
		}

		ISmirModHandle *phModule = NULL ;

		for(int iCount=0;S_OK==pEnumSmirMod->Next(1, &phModule, NULL);iCount++)
		{
			//we have the module so delete it...
			if (FAILED(DeleteModule(phModule)))
			{
				result = WBEM_E_FAILED;
			}

			phModule->Release();
		}

		pEnumSmirMod->Release();
		return result;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirAdministrator::AddGroup
 * Purpose:			Delete the group namespace from the SMIR
 * Parameters:
 *	ISmirModHandle*		A module handle interface
 *	ISmirGroupHandle*	A group handle interface obtained through ISmirModHandle and
 *					    filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: AddGroup(IN ISmirModHandle *hModule, 
									 IN ISmirGroupHandle *hGroup)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the args
		if((NULL == hModule)||(NULL == hGroup))
		{
			//MyTraceEvent.Generate(__FILE__,__LINE__, "E_INVALIDARG");
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirGroupHandle *)hGroup)->AddToDB(m_pSmir,hModule))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: DeleteGroup(IN ISmirGroupHandle *hGroup)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//fill in the path etc
		if(NULL ==hGroup)
		{
			return E_INVALIDARG;
		}
			
		if ( FAILED( ((CSmirGroupHandle*)hGroup)->DeleteFromDB(m_pSmir) ) )
		{
			return WBEM_E_FAILED;
		}
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddClass(IN ISmirGroupHandle *hGroup, 
									 IN ISmirClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hGroup)||(NULL == hClass)||
				(NULL == ((CSmirClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirClassHandle*)hClass)->AddToDB(m_pSmir,hGroup))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: DeleteClass(IN ISmirClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hClass)||(NULL == ((CSmirClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		//Let the class do it's own work
		((CSmirClassHandle*)hClass)->DeleteFromDB( m_pSmir);
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddNotificationClass(ISmirNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameter
		if((NULL == hClass) ||
			((CSmirNotificationClassHandle*)NULL == *((CSmirNotificationClassHandle*)hClass)))

		{
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirNotificationClassHandle*)hClass)->AddToDB(m_pSmir))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
		//release the handles via the garbage collector
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddExtNotificationClass(ISmirExtNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameter
		if((NULL == hClass)	|| 
			((CSmirExtNotificationClassHandle*)NULL == *((CSmirExtNotificationClassHandle*)hClass)))
		{
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirExtNotificationClassHandle*)hClass)->AddToDB(m_pSmir))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
		//release the handles via the garbage collector
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CSmirAdministrator :: DeleteNotificationClass(ISmirNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hClass)||(NULL == ((CSmirNotificationClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		//Let the class do it's own work
		((CSmirNotificationClassHandle*)hClass)->DeleteFromDB(m_pSmir);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: DeleteExtNotificationClass(ISmirExtNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hClass)||(NULL == ((CSmirExtNotificationClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		//Let the class do it's own work
		((CSmirExtNotificationClassHandle*)hClass)->DeleteFromDB(m_pSmir);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddNotificationClassToSerialise(ISmirNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hClass)
		{
			return E_INVALIDARG;
		}
		if(*((CSmirNotificationClassHandle*)hClass) !=NULL )
		{
			//it is a valid handle so serialise it
			*((CSmirNotificationClassHandle*)hClass)>>hSerialise;
			return S_OK;
		}
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddExtNotificationClassToSerialise(ISmirExtNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hClass)
		{
			return E_INVALIDARG;
		}
		if(*((CSmirExtNotificationClassHandle*)hClass) !=NULL )
		{
			//it is a valid handle so serialise it
			*((CSmirExtNotificationClassHandle*)hClass)>>hSerialise;
			return S_OK;
		}
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: CreateWBEMClass(

	BSTR pszClassName, 
	ISmirClassHandle **pHandle
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pHandle) 
			return E_INVALIDARG;

		*pHandle = NULL ;

		//open the smir name space
		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE result= CSmirAccess :: GetContext (m_pSmir, &moContext);
		result= CSmirAccess :: Open(m_pSmir,&moServ);
		if(FAILED(result)||(NULL == moServ))
		{
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED ;
		}

		IWbemClassObject *baseClass = NULL ;
		//OK we have the namespace so create the class
		CBString t_BStr ( HMOM_SNMPOBJECTTYPE_STRING ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,
									moContext,&baseClass,NULL);

		//finished with this
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		if (FAILED(result)||(NULL==baseClass))
		{
			return WBEM_E_FAILED;
		}

		IWbemClassObject *t_MosClass = NULL ;

		result = baseClass->SpawnDerivedClass (0 , &t_MosClass);
		baseClass->Release () ;

		if ( ! SUCCEEDED ( result ) )
		{
			return WBEM_E_FAILED;
		}

		//name the class __CLASS Class

		VARIANT v;
		VariantInit(&v);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(pszClassName);

		result = t_MosClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		ISmirClassHandle *classHandle = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_ClassHandle , 
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_ClassHandle,
			(PPVOID)&classHandle
		);

		if ( SUCCEEDED ( result ) )
		{
			classHandle->SetWBEMClass ( t_MosClass ) ;
			*pHandle = classHandle ;
			t_MosClass->Release();
		}
		else
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		return S_OK ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: CreateWBEMNotificationClass(

	BSTR pszClassName,
	ISmirNotificationClassHandle **pHandle
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pHandle) 
			return E_INVALIDARG;

		*pHandle = NULL ;

		//open the smir name space
		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE result= CSmirAccess :: GetContext (m_pSmir , &moContext);
		result= CSmirAccess :: Open(m_pSmir, &moServ);
		if(FAILED(result)||(NULL == moServ))
		{
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED ;
		}

		IWbemClassObject *baseClass = NULL ;
		//OK we have the namespace so create the class
		CBString t_BStr ( NOTIFICATION_CLASS_NAME ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,
									moContext,&baseClass, NULL);

		//finished with this

		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		if (FAILED(result)||(NULL==baseClass))
		{
			return WBEM_E_FAILED;
		}

		IWbemClassObject *t_MosClass = NULL ;
		result = baseClass->SpawnDerivedClass (0 , &t_MosClass);
		baseClass->Release () ;

		if ( ! SUCCEEDED ( result ) )
		{
			return WBEM_E_FAILED;
		}

		//name the class __CLASS Class

		VARIANT v;
		VariantInit(&v);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(pszClassName);

		result = t_MosClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		ISmirNotificationClassHandle *classHandle = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_NotificationClassHandle , 
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_NotificationClassHandle,
			(PPVOID)&classHandle
		);

		if ( SUCCEEDED ( result ) )
		{
			classHandle->SetWBEMNotificationClass ( t_MosClass ) ;
			t_MosClass->Release();
			*pHandle = classHandle ;
		}
		else
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: CreateWBEMExtNotificationClass (

	BSTR pszClassName,
	ISmirExtNotificationClassHandle **pHandle
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pHandle) 
			return E_INVALIDARG;

		*pHandle = NULL ;

		//open the smir name space
		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE result= CSmirAccess :: GetContext (m_pSmir , &moContext);
		result= CSmirAccess :: Open(m_pSmir ,&moServ);
		if(FAILED(result)||(NULL == moServ))
		{
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED ;
		}

		IWbemClassObject *baseClass = NULL ;
		//OK we have the namespace so create the class
		CBString t_BStr ( HMOM_SNMPEXTNOTIFICATIONTYPE_STRING ) ;
		result = moServ->GetObject(t_BStr.GetString () , RESERVED_WBEM_FLAG,
									moContext,&baseClass, NULL);

		//finished with this

		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		if (FAILED(result)||(NULL==baseClass))
		{
			return WBEM_E_FAILED;
		}

		IWbemClassObject *t_MosClass = NULL ;

		result = baseClass->SpawnDerivedClass (0 , &t_MosClass );
		baseClass->Release () ;

		if ( ! SUCCEEDED ( result ) )
		{
			return WBEM_E_FAILED;
		}

		//name the class __CLASS Class

		VARIANT v;
		VariantInit(&v);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(pszClassName);

		result = t_MosClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		ISmirExtNotificationClassHandle *classHandle = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_ExtNotificationClassHandle , 
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_ExtNotificationClassHandle,
			(PPVOID)&classHandle
		);

		if ( SUCCEEDED ( result ) )
		{
			classHandle->SetWBEMExtNotificationClass ( t_MosClass ) ;
			t_MosClass->Release();
			*pHandle = classHandle ;
		}
		else
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirSerialiseHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirSerialiseHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_SerialiseHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}



/*
 * CSmirSerialiseHandle::AddRef
 * CSmirSerialiseHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirSerialiseHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirSerialiseHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirSerialiseHandle :: CSmirSerialiseHandle(BOOL bClassDefinitionsOnly)
{
	m_cRef=0;
	//I have two variables so that I can expand this at a later date
	m_bMOFPragmas = m_bMOFAssociations = !bClassDefinitionsOnly;

	m_serialiseString=QUALIFIER_PROPAGATION;

	//start in the root\default namespace
	if (TRUE == m_bMOFPragmas)
		m_serialiseString+=CString(ROOT_DEFAULT_NAMESPACE_PRAGMA);
	/**************************************************************************
	 *	        		create the SMIR namespace class
	 **************************************************************************/
	if(TRUE == m_bMOFAssociations)
	{
		/******************then create an instance*********************************/

		m_serialiseString+=SMIR_CLASS_DEFINITION;
		m_serialiseString+=SMIR_INSTANCE_DEFINITION;
	}
	//go to the SMIR namespace
	if (TRUE == m_bMOFPragmas)
		m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);


	/******************create the SnmpMacro class******************************/

	m_serialiseString+=SNMPMACRO_CLASS_START;
	//end the class definition
	m_serialiseString+=END_OF_CLASS;

	/******************create the SnmpObjectType class*************************/

	m_serialiseString+=SNMPOBJECTTYPE_CLASS_START;
	//end the class definition
	m_serialiseString+=END_OF_CLASS;

	/******************create the SnmpNotifyStatus class*************************/

	m_serialiseString+=SNMPNOTIFYSTATUS_CLASS_START;
	//end the class definition
	m_serialiseString+=END_OF_CLASS;
	
	/****************if asked for, create the SMIR specific stuff****************/
	if(TRUE == m_bMOFAssociations)
	{
		/******************create the SnmpNotification class*********************/

		m_serialiseString+=SNMPNOTIFICATION_CLASS_START;
		
		//add the properties
		m_serialiseString+=TIMESTAMP_QUALS_TYPE;
		m_serialiseString+=CString(TIMESTAMP_PROP);
		m_serialiseString+=END_OF_PROPERTY;
		
		m_serialiseString+=TRAPOID_QUALS_TYPE;
		m_serialiseString+=CString(TRAPOID_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_ADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_ADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_TADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_TADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=TRANSPORT_QUALS_TYPE;
		m_serialiseString+=CString(TRANSPORT_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=COMMUNITY_QUALS_TYPE;
		m_serialiseString+=CString(COMMUNITY_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;


		/******************create the SnmpExtendedNotification class*************/
		
		m_serialiseString+=SNMPEXTNOTIFICATION_CLASS_START;

		//add the properties
		m_serialiseString+=TIMESTAMP_QUALS_TYPE;
		m_serialiseString+=CString(TIMESTAMP_PROP);
		m_serialiseString+=END_OF_PROPERTY;
		
		m_serialiseString+=TRAPOID_QUALS_TYPE;
		m_serialiseString+=CString(TRAPOID_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_ADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_ADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_TADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_TADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=TRANSPORT_QUALS_TYPE;
		m_serialiseString+=CString(TRANSPORT_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=COMMUNITY_QUALS_TYPE;
		m_serialiseString+=CString(COMMUNITY_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;

		/******************create the NotificationMapper class*********************/

		m_serialiseString+=NOTIFICATIONMAPPER_CLASS_START;

		//add the two properies..
		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;

		/******************create the ExtendedNotificationMapper class*************/

		m_serialiseString+=EXTNOTIFICATIONMAPPER_CLASS_START;

		//add the two properies..
		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;


		/******************create the module class*****************************/

		m_serialiseString+=MODULE_CLASS_START;
		//add the properties

		//give the instance a name
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_NAME_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;

		//add the module oid property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_OID_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the module identity
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_ID_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the organisation property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_ORG_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;

		//add the contact info property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_CONTACT_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the Description property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_DESCRIPTION_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the revision property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_REVISION_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the last update property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_LAST_UPDATE_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the snmp version property
		m_serialiseString+=READONLY_LONG;
		m_serialiseString+=CString(MODULE_SNMP_VERSION_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the module imports as an property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_IMPORTS_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;

#if 0
		//each module will create it's own instance
		/**************************************************************************
		 *	        		create the SMIR Associator class
         *[assoc]
		 *class SmirToClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] ClassName;
		 *[read] SmirName;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_ASSOC_CLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_ASSOC_SMIR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

#endif

		/**************************************************************************
		 *	        		create the Module Associator class
         *[assoc]
		 *class SmirToClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] ClassName;
		 *[read] SmirName;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;
		/**************************************************************************
		 *	        		create the Group Associator class
         *[assoc]
		 *class SmirToClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] ClassName;
		 *[read] SmirName;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_GROUP_ASSOC_CLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_GROUP_ASSOC_GROUP_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

		/**************************************************************************
		 *	        		create the Notification/Module Associator class
         *[assoc]
		 *class ModToNotificationClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] SmirClass;
		 *[read] SmirModule;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_NCLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

		/**************************************************************************
		 *	        	create the ExtNotification/Module Associator class
         *[assoc]
		 *class ModToExtNotificationClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] SmirClass;
		 *[read] SmirModule;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_EXTNCLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

	}
}

SCODE CSmirSerialiseHandle :: GetText(BSTR *pszText)
{
	SetStructuredExceptionHandler seh;

	try
	{
		*pszText  = m_serialiseString.AllocSysString();

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CSmirWbemConfiguration :: CSmirWbemConfiguration ( CSmir *a_Smir ) : 

	m_Smir ( a_Smir ) ,
	m_ReferenceCount ( 1 ) ,
	m_Context ( NULL ) ,
	m_Service ( NULL ) 
{
    InterlockedIncrement ( & CSMIRClassFactory::objectsInProgress ) ;
}

CSmirWbemConfiguration :: ~CSmirWbemConfiguration ()
{
	InterlockedDecrement ( & CSMIRClassFactory :: objectsInProgress ) ;

	if ( m_Context )
		m_Context->Release () ;

	if ( m_Service )
		m_Service->Release () ;
}

HRESULT CSmirWbemConfiguration :: QueryInterface(IN REFIID iid,OUT PPVOID iplpv)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return m_Smir->QueryInterface(iid, iplpv);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirWbemConfiguration :: AddRef()
{
	SetStructuredExceptionHandler seh;

	try
	{
		InterlockedIncrement ( & m_ReferenceCount ) ; 
		return m_Smir->AddRef () ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirWbemConfiguration :: Release()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
		}
		return m_Smir->Release () ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

HRESULT CSmirWbemConfiguration :: Authenticate (

	BSTR Server,
	BSTR User,
    BSTR Password,
    BSTR Locale,
    long lSecurityFlags,                 
    BSTR Authority ,
	BOOL InProc
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		IWbemLocator *t_Locator = NULL ;


		HRESULT t_Result = CoCreateInstance (

			CLSID_WbemLocator ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_IUnknown ,
			( void ** ) & t_Locator
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_Unknown = NULL ;

			if ( Server )
			{
				CString t_BStr = CString ( BACKSLASH_STR ) ;
				t_BStr += CString ( BACKSLASH_STR ) ;
				t_BStr += CString ( Server ) ;
				t_BStr += CString ( BACKSLASH_STR ) ;
				t_BStr += CString ( SMIR_NAMESPACE ) ;

				BSTR t_Str = SysAllocString ( t_BStr.GetBuffer ( 0 ) ) ;

				t_Result = t_Locator->ConnectServer (

					t_Str ,
					Password,				// Password
					User,					// User
					Locale,					// Locale id
					lSecurityFlags,			// Flags
					Authority,				// Authority
					NULL,					// Context
					&t_Unknown 
				);

				SysFreeString ( t_Str ) ;
			}
			else
			{
				CString t_BStr = CString ( SMIR_NAMESPACE ) ;
				LPCTSTR t_Str = SysAllocString ( t_BStr.GetBuffer ( 0 ) ) ;

				t_Result = t_Locator->ConnectServer (

					t_Str ,
					Password,				// Password
					User,					// User
					Locale,					// Locale id
					lSecurityFlags,			// Flags
					Authority,				// Authority
					NULL,					// Context
					&t_Unknown 
				);

				SysFreeString ( t_Str ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_Service )
				{
					m_Service->Release () ;
				}

				t_Result = t_Unknown->QueryInterface (

					IID_IWbemServices ,
					( void **) & m_Service
				) ;

				t_Unknown->Release () ;
			}

			t_Locator->Release () ;
		}

		return t_Result ;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}


HRESULT CSmirWbemConfiguration :: Impersonate ( ISMIRWbemConfiguration *a_Configuration )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( m_Context ) 
			m_Context->Release () ;

		if ( m_Service )
			m_Service->Release () ;

		CSmirWbemConfiguration *t_Configuration = ( CSmirWbemConfiguration * ) a_Configuration ;

		m_Context = t_Configuration->m_Context ;
		m_Service = t_Configuration->m_Service ;

		if ( m_Context ) 
			m_Context->AddRef () ;

		if ( m_Service )
			m_Service->AddRef () ;

		return S_OK ;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemConfiguration :: SetContext ( IWbemContext *a_Context )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( m_Context )
		{
			m_Context->Release () ;
		}

		m_Context = a_Context ;

		if ( m_Context )
		{
			m_Context->AddRef () ;
		}

		return S_OK ;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemConfiguration :: GetContext ( IWbemContext **a_Context )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( a_Context && m_Context )
		{
			m_Context->AddRef () ;

			*a_Context = m_Context ;
			return S_OK ;
		}
		else
		{
			if (a_Context)
			{
				*a_Context = NULL ;
			}

			return WBEM_E_FAILED ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemConfiguration :: GetServices ( IWbemServices **a_Service )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( a_Service && m_Service )
		{
			m_Service->AddRef () ;
			*a_Service = m_Service ;
			return S_OK ;
		}
		else
		{
			*a_Service = NULL ;
			return WBEM_E_FAILED ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\handles.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"

#include <textdef.h>
#include <helper.h>
#include "bstring.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif


// A function to escape newlines, tabs etc. from a property value
static BSTR EscapeSpecialCharacters(BSTR strInputString)
{
	// Escape all the quotes - This code taken from winmgmt\common\var.cpp
	// =====================

	int nStrLen = wcslen(strInputString);
	LPWSTR wszValue = new WCHAR[nStrLen*2+10];
	LPWSTR pwc = wszValue;
	for(int i = 0; i < (int)nStrLen; i++)
	{    
		switch(strInputString[i])
		{
			case L'\n':
				*(pwc++) = L'\\';
				*(pwc++) = L'n';
				break;
			case L'\t':
				*(pwc++) = L'\\';
				*(pwc++) = L't';
				break;
			case L'"':
			case L'\\':
				*(pwc++) = L'\\';
				*(pwc++) = strInputString[i];
				break;
			default:
				*(pwc++) = strInputString[i];
				break;
		}
	}
	*pwc = 0;
	BSTR retValue = SysAllocString(wszValue);
	delete [] wszValue;
	return retValue;
}


/*
 * CSmirModuleHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirModuleHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ModHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}



/*
 * CSmirModuleHandle::AddRef
 * CSmirModuleHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirModuleHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		////CMOEvent_Trace MyTraceEvent(SMIR_STR);  

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirModuleHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirModuleHandle :: CSmirModuleHandle()
:	m_lSnmp_version(DEFAULT_SNMP_VERSION), m_szLastUpdate(NULL),
	m_szModuleOid(NULL), m_szName(NULL),
	m_szModuleId(NULL), m_szOrganisation(NULL),
	m_szContactInfo(NULL), m_szDescription(NULL),
	m_szRevision(NULL), m_szModImports(NULL)
{
	//start off as a handel to nothing
	//init reference count
	m_cRef=0;
	CModHandleClassFactory::objectsInProgress++;
}

/*
 * CSmirGroupHandle::void* operator
 * validate handle
 */

CSmirModuleHandle::operator void*()
{
	if(NULL!=m_szName)
		return this;
	return NULL;
}

/**************************************************************************************
 *Methods not exposed by the ISmirModHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

STDMETHODIMP CSmirModuleHandle::DeleteFromDB ( CSmir *a_Smir )
{
	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		return WBEM_E_FAILED;
	}

	//delete all of the classes in this module

	ISmirInterrogator *pInterrogativeInt = NULL ;
	res = g_pClassFactoryHelper->CreateInstance(

		CLSID_SMIR_Database,
		IID_ISMIR_Interrogative,
		(PVOID *)&pInterrogativeInt
	);

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_Configuration = NULL ;
	res = pInterrogativeInt->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_Configuration 
	) ;

	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_CopyConfiguration = NULL ;
	res = a_Smir->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_CopyConfiguration 
	) ;

	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		t_Configuration->Release () ;
		pInterrogativeInt->Release();
		return S_OK ;
	}

	t_Configuration->Impersonate ( t_CopyConfiguration ) ;

	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		t_Configuration->Release () ;
		t_CopyConfiguration->Release () ;
		pInterrogativeInt->Release();

		return S_OK ;
	}

	t_Configuration->Release () ;
	t_CopyConfiguration->Release () ;

	IEnumClass  *pTEnumSmirClass = NULL ;
	res = pInterrogativeInt->EnumClassesInModule(&pTEnumSmirClass,this);

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	//now use the enumerator
	//loop over the classes and remove them
	ISmirClassHandle *phClass = NULL ;
	for(int iCount=0;S_OK==pTEnumSmirClass->Next(1, &phClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirClassHandle*)phClass)->DeleteFromDB(a_Smir);
		phClass->Release();
	}

	pTEnumSmirClass->Release();

	IEnumNotificationClass  *pTEnumNotificationClass = NULL ;
	res = pInterrogativeInt->EnumNotificationClassesInModule(&pTEnumNotificationClass,this);

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	//now use the enumerator
	//loop over the classes and remove them
	ISmirNotificationClassHandle *phNClass = NULL ;
	for(iCount=0;S_OK==pTEnumNotificationClass->Next(1, &phNClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirNotificationClassHandle*)phNClass)->DeleteFromDB(a_Smir);
		phNClass->Release();
	}

	pTEnumNotificationClass->Release();

	IEnumExtNotificationClass  *pTEnumExtNotificationClass = NULL ;
	res = pInterrogativeInt->EnumExtNotificationClassesInModule(&pTEnumExtNotificationClass,this);
	
	//not needed anymore...
	pInterrogativeInt->Release();

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	//now use the enumerator
	//loop over the classes and remove them
	ISmirExtNotificationClassHandle *phExtNClass = NULL ;
	for(iCount=0;S_OK==pTEnumExtNotificationClass->Next(1, &phExtNClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirExtNotificationClassHandle*)phExtNClass)->DeleteFromDB(a_Smir);
		phExtNClass->Release();
	}

	pTEnumExtNotificationClass->Release();
	
	/********************Now delete the module********************/

	//create a buffer big enough
	wchar_t *pTstring = new wchar_t[wcslen(MODULE_NAMESPACE_NAME)+wcslen(EQUALS_STR)
							+wcslen(m_szName)+2+1];
	if(NULL == pTstring)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return E_OUTOFMEMORY;
	}

	wcscpy(pTstring, MODULE_NAMESPACE_NAME);
	wcscat(pTstring,EQUALS_STR);
	wcscat(pTstring,QUOTE_STR);
	// module =

	wcscat(pTstring,m_szName);
	wcscat(pTstring,QUOTE_STR);
	// module = <module>

	CBString t_Str (pTstring);
	SCODE result = moServ->DeleteInstance(t_Str.GetString (),RESERVED_WBEM_FLAG, moContext,NULL );

	//clean up
	delete [] pTstring;

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	if (FAILED(result))
	{
		//problem!
		return WBEM_E_FAILED;
	}
	return S_OK;
}

STDMETHODIMP CSmirModuleHandle::AddToDB( CSmir *a_Smir )
{
	/*open the smir name space this will addref it so it cannot be removed
	 *whilst we are using it
	 */
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ);

	if ((S_FALSE==result)||(NULL == (void*)moServ))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem the SMIR is not there and cannot be created
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pModClass = NULL ;
	CBString t_BStr ( MODULE_NAMESPACE_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString () , RESERVED_WBEM_FLAG,moContext,
								&pModClass,NULL);

	if (!SUCCEEDED(result))
	{
		/*OK we have the smir namespace so create the module namespace
		 *first create a class...
		 */


		IWbemClassObject *pNewClass = NULL ;
		CBString t_BStr ( OLEMS_NAMESPACE_CLASS ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,moContext,
									&pNewClass,NULL);

		if ((FAILED(result))||(NULL==pNewClass))
		{
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		// Spawn derived class

		IWbemClassObject *pNewDerivedClass = NULL ;
		result = pNewClass->SpawnDerivedClass ( 0 , &pNewDerivedClass ) ;
		if ((FAILED(result))||(NULL==pNewDerivedClass))
		{
			moServ->Release();
			pNewClass->Release () ;
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		pNewClass->Release () ;

		VARIANT v;
		VariantInit(&v);

		//I now have a new class so Give it a name
		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(MODULE_NAMESPACE_NAME);

		result = pNewDerivedClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			pNewDerivedClass->Release();
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		result = PutClassProperties(pNewDerivedClass) ;
		if (FAILED(result))
		{
			pNewDerivedClass->Release();
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}
		
		//now commit the changes
		result = moServ->PutClass(pNewDerivedClass, RESERVED_WBEM_FLAG,moContext,NULL);
		pNewDerivedClass->Release();
		if (FAILED(result))
		{
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		//get an object

		t_BStr = MODULE_NAMESPACE_NAME ;
		result = moServ->GetObject(t_BStr.GetString (), 0, 
										moContext,&pModClass,NULL );
		if (FAILED(result))
		{
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

	}

	//and create an instance of the module namespace

	// Spawn instance of class

	IWbemClassObject *pNewInstance = NULL ;
	result = pModClass->SpawnInstance ( 0 , &pNewInstance ) ;
	if ((FAILED(result))||(NULL==pNewInstance))
	{
		moServ->Release();
		if ( moContext )
			moContext->Release () ;

		pModClass->Release () ;
		return WBEM_E_FAILED;
	}

	pModClass->Release () ;

	//fill in the instance
	*this >> pNewInstance;

	//and commit it to the namespace
	result = moServ->PutInstance(pNewInstance, RESERVED_WBEM_FLAG, moContext,NULL );
	pNewInstance->Release();
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;
		moServ->Release();

		return WBEM_E_FAILED;
	}

	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(result))
	{
		return WBEM_E_FAILED;
	}

	return S_OK;
}

const CSmirModuleHandle& CSmirModuleHandle :: operator <<(IWbemClassObject *pSmirMosClassObject)
{
	//get the name
	VARIANT v;
	VariantInit(&v);
	pSmirMosClassObject->Get(MODULE_NAME_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetName(V_BSTR(&v));
	}

	VariantClear(&v);
	 
	//get the object id
	pSmirMosClassObject->Get(MODULE_OID_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetModuleOID(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the object imports
	pSmirMosClassObject->Get(MODULE_IMPORTS_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetModuleImports(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the object id
	pSmirMosClassObject->Get(MODULE_ID_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetModuleIdentity(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the organisation
	pSmirMosClassObject->Get(MODULE_ORG_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetOrganisation(V_BSTR(&v));
	}

	VariantClear(&v);
	
	//get the contact
	pSmirMosClassObject->Get(MODULE_CONTACT_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetContactInfo(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the description
	pSmirMosClassObject->Get(MODULE_DESCRIPTION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetDescription(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the revision
	pSmirMosClassObject->Get(MODULE_REVISION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetRevision(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the version
	pSmirMosClassObject->Get(MODULE_SNMP_VERSION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_I4)
	{
		SetSnmpVersion(V_I4(&v));
	}
	//get the last update value
	pSmirMosClassObject->Get(MODULE_LAST_UPDATE_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetLastUpdate(V_BSTR(&v));
	}
	VariantClear(&v);
	return *this;
}

const CSmirModuleHandle& CSmirModuleHandle :: operator >>(IWbemClassObject *pInst)
{
	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	SCODE result;
	if(NULL != m_szName)
	{
		V_BSTR(&v)=SysAllocString(m_szName);

		result = pInst->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	else
	{
		//must have a name
		return *this;
	}
	//add the module oid property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szModuleOid)
	{
		V_BSTR(&v)=SysAllocString(m_szModuleOid);
		result = pInst->Put(MODULE_OID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the module identity
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szModuleId)
	{
		V_BSTR(&v)=SysAllocString(m_szModuleId);
		result = pInst->Put(MODULE_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the organisation property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szOrganisation)
	{
		V_BSTR(&v)=SysAllocString(m_szOrganisation);
		result = pInst->Put(MODULE_ORG_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the contact info property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szContactInfo)
	{
		V_BSTR(&v)=SysAllocString(m_szContactInfo);
		result = pInst->Put(MODULE_CONTACT_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}	
	//add the Description property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szDescription)
	{
		V_BSTR(&v)=SysAllocString(m_szDescription);
		result = pInst->Put(MODULE_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}

	//add the revision property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szRevision)
	{
		V_BSTR(&v)=SysAllocString(m_szRevision);
		result = pInst->Put(MODULE_REVISION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the last update property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szLastUpdate)
	{
		V_BSTR(&v)=SysAllocString(m_szLastUpdate);
		result = pInst->Put(MODULE_LAST_UPDATE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the snmp version property
	V_VT(&v) = VT_I4;
	V_I4(&v)=m_lSnmp_version;

	result = pInst->Put(MODULE_SNMP_VERSION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return *this;
	}

	//add the module identity as an property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szModImports)
	{
		V_BSTR(&v)=SysAllocString(m_szModImports);
	
		result = pInst->Put(MODULE_IMPORTS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	return *this;
}

HRESULT CSmirModuleHandle :: PutClassProperties (IWbemClassObject *pClass)
{
	HRESULT result;

	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");

	result = pClass->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the module oid property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_OID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the module identity
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the organisation property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_ORG_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the contact info property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_CONTACT_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the Description property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the revision property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_REVISION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the last update property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_LAST_UPDATE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the snmp version property
	V_VT(&v) = VT_I4;
	V_I4(&v)=0;
	result = pClass->Put(MODULE_SNMP_VERSION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the module identity as an property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");

	result = pClass->Put(MODULE_IMPORTS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	return result ;
}

const CSmirModuleHandle& CSmirModuleHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if(NULL!=pSHandle)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		CString szTmpString;
		//start in the SMIR namepspace
		if(TRUE==bMOFPragmas)
			szTmpString=CString(SMIR_NAMESPACE_PRAGMA);
		
		if (TRUE == bMOFAssociations)
		{
			//create an instance of the module namespac
			szTmpString+=MODULE_INSTANCE_START;
			//add the properties

			//give the instance a name
			szTmpString+=CString(MODULE_NAME_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szName);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//add the module oid property
			szTmpString+=CString(MODULE_OID_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szModuleOid);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the module identity
			szTmpString+=CString(MODULE_ID_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szModuleId);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the organisation property
			szTmpString+=CString(MODULE_ORG_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strOrganisation = EscapeSpecialCharacters(m_szOrganisation);
			szTmpString+=CString(strOrganisation);
			SysFreeString(strOrganisation);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//add the contact info property
			szTmpString+=CString(MODULE_CONTACT_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strContactInfo = EscapeSpecialCharacters(m_szContactInfo);
			szTmpString+=CString(strContactInfo);
			SysFreeString(strContactInfo);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the Description property
			szTmpString+=CString(MODULE_DESCRIPTION_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strDescription= EscapeSpecialCharacters(m_szDescription);
			szTmpString+=CString(strDescription);
			SysFreeString(strDescription);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the revision property
			szTmpString+=CString(MODULE_REVISION_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strRevision = EscapeSpecialCharacters(m_szRevision);
			szTmpString+=CString(strRevision);
			SysFreeString(strRevision);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the last update property
			szTmpString+=CString(MODULE_LAST_UPDATE_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szLastUpdate);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the snmp version property
			szTmpString+=CString(MODULE_SNMP_VERSION_PROPERTY);
			szTmpString+=CString(EQUALS_STR);
			wchar_t szVersion[17];
			_itow(m_lSnmp_version,szVersion,2);
			szTmpString+=CString(szVersion);
			szTmpString+=END_OF_PROPERTY;
			
			//add the module imports as an property
			szTmpString+=CString(MODULE_IMPORTS_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szModImports);
			szTmpString+=END_OF_PROPERTY_VALUE;

			szTmpString+=END_OF_CLASS;
		}
		/*******create the group class***********/
		//add the group class to the module namespace
		if(TRUE==bMOFPragmas)
		{
			szTmpString+=CString(START_OF_SMIR_NAMESPACE_PRAGMA);
			szTmpString+=CString(m_szName);
			szTmpString+=CString(END_OF_NAMESPACE_PRAGMA);
		}
		if (TRUE == bMOFAssociations)
		{
			szTmpString+=GROUP_CLASS_START;
			
			//add the properties
			//give the instance a name
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_NAME_PROPERTY);
			szTmpString+=END_OF_PROPERTY;

			//give the instance a group id
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_ID_PROPERTY);
			szTmpString+=END_OF_PROPERTY;
			
			//give the instance a status
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_STATUS_PROPERTY);
			szTmpString+=END_OF_PROPERTY;
			
			//give the instance a description
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_DESCRIPTION_PROPERTY);
			szTmpString+=END_OF_PROPERTY;

			//give the instance a reference
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(MODULE_REFERENCE_PROPERTY);
			szTmpString+=END_OF_PROPERTY;

			szTmpString+=END_OF_CLASS;
		}

		//and add the string to the serialise handle
		((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(szTmpString);

		//each group will create it's own instance

	}

	return *this;
}

SCODE CSmirModuleHandle :: GetName(BSTR *pszName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(pszName!=NULL)
		{
			*pszName=SysAllocString(m_szName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetModuleOID(BSTR *pszModuleOid)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszModuleOid)
		{
			*pszModuleOid=SysAllocString(m_szModuleOid);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetModuleIdentity(BSTR *pszModuleId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszModuleId)
		{
			*pszModuleId=SysAllocString(m_szModuleId);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetLastUpdate(BSTR *pszLastUpdate)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszLastUpdate)
		{
			*pszLastUpdate=SysAllocString(m_szLastUpdate);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetOrganisation(BSTR *pszOrganisation)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszOrganisation)
		{
			*pszOrganisation=SysAllocString(m_szOrganisation);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetContactInfo(BSTR *pszContactInfo)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszContactInfo)
		{
			*pszContactInfo=SysAllocString(m_szContactInfo);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetDescription(BSTR *pszDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszDescription)
		{
			*pszDescription=SysAllocString(m_szDescription);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetRevision(BSTR *pszRevision)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszRevision)
		{
			*pszRevision=SysAllocString(m_szRevision);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetSnmpVersion(ULONG *plSnmp_version)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != plSnmp_version)
		{
			*plSnmp_version=m_lSnmp_version;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetModuleImports (BSTR* ppszModImports)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != ppszModImports)
		{
			*ppszModImports=SysAllocString(m_szModImports);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetName(BSTR pszName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szName,&pszName);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetModuleOID(BSTR pszModuleOid)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleOid,&pszModuleOid);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetModuleIdentity(BSTR pszModuleId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleId,&pszModuleId);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetLastUpdate(BSTR pszLastUpdate)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szLastUpdate,&pszLastUpdate);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetOrganisation(BSTR pszOrganisation)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szOrganisation,&pszOrganisation);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetContactInfo(BSTR pszContactInfo)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szContactInfo,&pszContactInfo);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetDescription(BSTR pszDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szDescription,&pszDescription);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetRevision(BSTR pszRevision)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szRevision,&pszRevision);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetSnmpVersion(ULONG plSnmp_version)
{
	SetStructuredExceptionHandler seh;

	try
	{
		m_lSnmp_version=plSnmp_version;
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetModuleImports (BSTR pszModImports)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModImports,&pszModImports);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CSmirModuleHandle :: ~ CSmirModuleHandle()
{
	SysFreeString(m_szModuleOid);
	SysFreeString(m_szName);
	SysFreeString(m_szModuleId);
	SysFreeString(m_szOrganisation);
	SysFreeString(m_szContactInfo);
	SysFreeString(m_szDescription);
	SysFreeString(m_szRevision);
	SysFreeString(m_szModImports);
	SysFreeString(m_szLastUpdate);

	CModHandleClassFactory::objectsInProgress--;
}

/*Group handle methods
 */
/*
 * CSmirGroupHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirGroupHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_GroupHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirModuleHandle::AddRef
 * CSmirModuleHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirGroupHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirGroupHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirGroupHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirGroupHandle :: CSmirGroupHandle()
:	m_szModuleName(NULL), m_szName(NULL),
	m_szGroupId(NULL), m_szDescription(NULL),
	m_szReference(NULL),m_szStatus(NULL)
{
	//init the reference count
	m_cRef=0;
	//start off as a handel to nothing

	//inc the factory count
	CGroupHandleClassFactory::objectsInProgress++;
}

CSmirGroupHandle :: ~ CSmirGroupHandle()
{
	SysFreeString(m_szModuleName);
	SysFreeString(m_szName);
	SysFreeString(m_szGroupId);
	SysFreeString(m_szDescription);
	SysFreeString(m_szReference);
	SysFreeString(m_szStatus);
	CGroupHandleClassFactory::objectsInProgress--;
}

/*
 * CSmirGroupHandle::void* operator
 * validate handle
 */

CSmirGroupHandle::operator void*()
{
	if((NULL!=m_szModuleName)&&(NULL!=m_szName))
		return this;
	return NULL;
}

/**************************************************************************************
 *Methods not exposed by the ISmirGroupHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

STDMETHODIMP CSmirGroupHandle::AddToDB( CSmir *a_Smir , ISmirModHandle *hModule)
{
	//save the module name
	BSTR szTmpStr;
	hModule->GetName(&szTmpStr);
	SetModuleName(szTmpStr);
	SysFreeString(szTmpStr);

	//open the module namespace
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ,hModule);
	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}

	//get an object
	IWbemClassObject *pGrpClass = NULL ;
	CBString t_BStr ( GROUP_NAMESPACE_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pGrpClass,NULL );

	if ( !SUCCEEDED(result) )
	{	
		//OK we have the module namespace so create the group class
		IWbemClassObject *pNewClass = NULL ;
		CBString t_BStr ( OLEMS_NAMESPACE_CLASS ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,
									moContext, &pNewClass,NULL);

		if ((FAILED(result))||(NULL==pNewClass))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}

		// Spawn derived class

		IWbemClassObject *pNewDerivedClass = NULL ;
		result = pNewClass->SpawnDerivedClass ( 0 , &pNewDerivedClass ) ;
		pNewClass->Release();

		if ((FAILED(result))||(NULL==pNewDerivedClass))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}

		VARIANT v;
		VariantInit(&v);

		//OK I have a new class so give it a name
		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(GROUP_NAMESPACE_NAME);

		result = pNewDerivedClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pNewDerivedClass->Release();
			return WBEM_E_FAILED;
		}
		
		result = PutClassProperties(pNewDerivedClass) ;
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			pNewDerivedClass->Release();
			moServ->Release();
			return WBEM_E_FAILED;
		}

		//now commit the changes
		result = moServ->PutClass(pNewDerivedClass, RESERVED_WBEM_FLAG, moContext, NULL);
		pNewDerivedClass->Release();
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}

		//and create an instance of the group namespace
		//get an object

		//get an object
		t_BStr = GROUP_NAMESPACE_NAME ;
		result = moServ->GetObject(t_BStr.GetString (), 0, 
										moContext, &pGrpClass,NULL );
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}
	}

	// Spawn instance of class

	IWbemClassObject *pNewInstance ;
	result = pGrpClass->SpawnInstance ( 0 , &pNewInstance ) ;
	if ((FAILED(result))||(NULL==pNewInstance))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pGrpClass->Release () ;
		return WBEM_E_FAILED;
	}

	pGrpClass->Release () ;

	//fill in the instance
	*this >> pNewInstance;


	//and commit it to the namespace
	result = moServ->PutInstance(pNewInstance, RESERVED_WBEM_FLAG,moContext, NULL);
	pNewInstance->Release();

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;
		moServ->Release();

		return WBEM_E_FAILED;
	}

	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(result))
	{
		return WBEM_E_FAILED;
	}

	return S_OK;
}

STDMETHODIMP CSmirGroupHandle::DeleteFromDB ( CSmir *a_Smir )
{
	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == (void*)moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	/******************delete all of the classes in this group***********************/

	IEnumClass  *pTEnumSmirClass = NULL ;
	ISmirInterrogator *pInterrogativeInt = NULL ;
	SCODE result = g_pClassFactoryHelper->CreateInstance (

		CLSID_SMIR_Database,
		IID_ISMIR_Interrogative,
		(PVOID *)&pInterrogativeInt
	);

	if ( ! SUCCEEDED ( result ) )
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_Configuration = NULL ;
	result = pInterrogativeInt->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_Configuration 
	) ;

	if ( ! SUCCEEDED ( result ) )
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_CopyConfiguration = NULL ;
	result = pInterrogativeInt->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_CopyConfiguration 
	) ;

	if ( ! SUCCEEDED ( result ) )
	{
		t_Configuration->Release () ;
		pInterrogativeInt->Release();
	}

	t_Configuration->Impersonate ( t_CopyConfiguration ) ;

	if ( ! SUCCEEDED ( result ) )
	{
		t_Configuration->Release () ;
		t_CopyConfiguration->Release () ;
		pInterrogativeInt->Release();
	}

	t_Configuration->Release () ;
	t_CopyConfiguration->Release () ;

	res = pInterrogativeInt->EnumClassesInGroup (&pTEnumSmirClass,this);
	//now use the enumerator
	if(FAILED(res))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}
	//loop over the classes and remove them
	ISmirClassHandle *phClass=NULL;
	for(int iCount=0;S_OK==pTEnumSmirClass->Next(1, &phClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirClassHandle*)phClass)->DeleteClassFromGroup(a_Smir);
		phClass->Release();
	}
	pTEnumSmirClass->Release();
	pInterrogativeInt->Release();
	/************************* delete the associations******************************/
	//delete everthing that is associated with the group using 
	//references of {\\.\root\default\SMIR:<group>}
	IEnumWbemClassObject *pEnum = NULL ;

	CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(BACKSLASH_STR)
					+CString(m_szModuleName)
					+CString(COLON_STR)
					+CString(GROUP_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(m_szName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery,
									RESERVED_WBEM_FLAG, moContext, &pEnum);
	SysFreeString(szQuery);

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//all groups that contain classes are associated so this may not be a problem
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	ULONG uCount=1; 
	IWbemClassObject *pAssocMosClass = NULL ;
	ULONG puReturned;

	//loop over the associations
	VARIANT assocClass;
	VariantInit(&assocClass);
	VARIANT assocName;
	VariantInit(&assocName);
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
	{
		pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
		pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
		pAssocMosClass->Release();

		CString instString(

			CString(V_BSTR(&assocClass))
			+CString(EQUALS_STR)
			+CString(QUOTE_STR)
			+CString(V_BSTR(&assocName))
			+CString(QUOTE_STR)
		);

		VariantClear(&assocName);
		VariantClear(&assocClass);

		BSTR instBString = instString.AllocSysString();
		moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
		SysFreeString(instBString);
	}

	pEnum->Release();
	moServ->Release();
	
	/*************************now delete the group******************************/
	//open the module name space
	res= CSmirAccess :: Open(a_Smir,&moServ, this,CSmirAccess::eModule);
	if ((S_FALSE==res)||(NULL == (void*)moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	//OK we have the module namespace so delete the group

	//build the object path
	wchar_t *pTString = new wchar_t[wcslen(GROUP_NAMESPACE_NAME)+wcslen(EQUALS_STR)+
																wcslen(m_szName)+2+1];
	if(NULL == pTString)
	{
		//free the string we got from hGroup
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return E_OUTOFMEMORY;
	}

	wcscpy(pTString, GROUP_NAMESPACE_NAME);
	wcscat(pTString,EQUALS_STR);
	wcscat(pTString,QUOTE_STR);
	// GROUP =

	wcscat(pTString,m_szName);
	wcscat(pTString,QUOTE_STR);
	// GROUP = <group name>


	CBString t_Str (pTString);
	result = moServ->DeleteInstance(t_Str.GetString (), RESERVED_WBEM_FLAG, moContext,NULL);
	moServ->Release();
	if ( moContext )
		moContext->Release () ;

	delete [] pTString;
	
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}
	return S_OK;
}

const CSmirGroupHandle& CSmirGroupHandle :: operator <<(IWbemClassObject *pSmirMosClassObject)
{
	//get the name
	VARIANT v;
	VariantInit(&v);
	pSmirMosClassObject->Get(GROUP_NAME_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetName(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the group id
	pSmirMosClassObject->Get(GROUP_ID_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetGroupOID(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the status
	pSmirMosClassObject->Get(GROUP_STATUS_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetStatus(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the description
	pSmirMosClassObject->Get(GROUP_DESCRIPTION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetDescription(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the reference
	pSmirMosClassObject->Get(MODULE_REFERENCE_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetReference(V_BSTR(&v));
	}
	VariantClear(&v);

	return *this;
}

const CSmirGroupHandle& CSmirGroupHandle :: operator >>(IWbemClassObject *pInst)
{
	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	SCODE result;
	if(NULL != m_szName)
	{
		V_BSTR(&v)=SysAllocString(m_szName);
	
		result = pInst->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	else
	{
		return *this;
	}
	//add the group oid property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szGroupId)
	{
		V_BSTR(&v)=SysAllocString(m_szGroupId);
		result = pInst->Put(GROUP_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the status property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szStatus)
	{
		V_BSTR(&v)=SysAllocString(m_szStatus);
		result = pInst->Put(GROUP_STATUS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the Description property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szDescription)
	{
		V_BSTR(&v)=SysAllocString(m_szDescription);
		result = pInst->Put(GROUP_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the reference property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szReference)
	{
		V_BSTR(&v)=SysAllocString(m_szReference);
		result = pInst->Put(MODULE_REFERENCE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the references to the classes

	//and return
	return *this;
}

HRESULT CSmirGroupHandle :: PutClassProperties (IWbemClassObject *pClass)
{
	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	HRESULT result;

	V_BSTR(&v)=SysAllocString(L"");
	
	result = pClass->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the group oid property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(GROUP_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the status property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(GROUP_STATUS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the Description property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(GROUP_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result;
	}

	//add the reference property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_REFERENCE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}
	//add the references to the classes

	return result ;
}

const CSmirGroupHandle& CSmirGroupHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if(NULL!=pSHandle)
	{
		CString szTmpString;
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		//start in the group namepspace
		if(TRUE==bMOFPragmas)
		{
			szTmpString=CString(START_OF_SMIR_NAMESPACE_PRAGMA);
			szTmpString+=CString(m_szModuleName);
			szTmpString+=CString(END_OF_NAMESPACE_PRAGMA);
		}
		if(TRUE==bMOFAssociations)
		{
			//create an instance of the group namespace
			szTmpString+=GROUP_INSTANCE_START;

			//add the properties

			//give the instance a name
			szTmpString+=CString(GROUP_NAME_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szName);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//give the instance a group id
			szTmpString+=CString(GROUP_ID_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szGroupId);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//give the instance a status
			szTmpString+=CString(GROUP_STATUS_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szStatus);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//give the instance a description
			szTmpString+=CString(GROUP_DESCRIPTION_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szDescription);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//give the instance a reference
			szTmpString+=CString(MODULE_REFERENCE_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szReference);
			szTmpString+=END_OF_PROPERTY_VALUE;

			szTmpString+=CString(END_OF_CLASS);
		}

		//and add the string to the serialise handle
		((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(szTmpString);
		//each class will create it's self

	}

	return *this;
}

SCODE CSmirGroupHandle :: GetModuleName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szModuleName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetGroupOID(BSTR *szGroupId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szGroupId)
		{
			*szGroupId = SysAllocString(m_szGroupId);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetStatus(BSTR *szStatus)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szStatus)
		{
			*szStatus = SysAllocString(m_szStatus);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetDescription(BSTR *szDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szDescription)
		{
			*szDescription = SysAllocString(m_szDescription);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetReference(BSTR *szReference)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szReference)
		{
			*szReference = SysAllocString(m_szReference);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle ::  SetModuleName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle ::  SetName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetGroupOID(BSTR szGroupId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szGroupId,&szGroupId);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetStatus(BSTR szStatus)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szStatus,&szStatus);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetDescription(BSTR szDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szDescription,&szDescription);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetReference(BSTR szReference)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szReference,&szReference);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*Class handle methods
 */
/*
 * CSmirClassHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirClassHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ClassHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirModuleHandle::AddRef
 * CSmirModuleHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirClassHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirClassHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirClassHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirClassHandle :: CSmirClassHandle()
: m_pIMosClass(NULL), m_szModuleName(NULL), m_szGroupName(NULL)
{
	CClassHandleClassFactory::objectsInProgress++;

	//init the reference count
	m_cRef=0;
}

CSmirClassHandle :: ~ CSmirClassHandle()
{
	if (NULL != m_pIMosClass)
		m_pIMosClass->Release();
	SysFreeString(m_szModuleName);
	SysFreeString(m_szGroupName);
	CClassHandleClassFactory::objectsInProgress--;
}

/*
 * CSmirModuleHandle::void* operator
 * validate handle
 */

CSmirClassHandle::operator void*()
{
	if((NULL!=m_szModuleName)&&(NULL!=m_szGroupName)&&(NULL!=m_pIMosClass))
		return this;
	return NULL;
}

SCODE CSmirClassHandle :: SetWBEMClass(IWbemClassObject *pObj)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pObj)
		{
			m_pIMosClass = pObj;
			m_pIMosClass->AddRef () ;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle :: GetWBEMClass (

	IWbemClassObject **pObj
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pObj) 
			return E_INVALIDARG;

		//if the class already exists return it

		if(m_pIMosClass != NULL)
		{
			m_pIMosClass->AddRef();
			*pObj=m_pIMosClass;
			return S_OK;
		}
		else
		{
			*pObj= NULL ;
			return WBEM_E_FAILED ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle ::  SetModuleName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle :: GetModuleName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szModuleName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle ::  SetGroupName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szGroupName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle :: GetGroupName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szGroupName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/**************************************************************************************
 *Methods not exposed by the ISmirClassHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

SCODE CSmirClassHandle ::  AddToDB(CSmir *a_Smir,ISmirGroupHandle *hGroup)
{
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default name space
	result= CSmirAccess :: Open(a_Smir,&moServ);
	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		//if we cant open the namespace the group handle must be invalid
		return WBEM_E_FAILED;
	}
	//now commit the changes
	result = moServ->PutClass(m_pIMosClass, RESERVED_WBEM_FLAG, moContext,NULL);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return E_UNEXPECTED;
	}

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	//add the associations
	BSTR szGroupName = NULL ;
	BSTR szModuleName = NULL ;
	hGroup->GetName(&szGroupName);
	hGroup->GetModuleName(&szModuleName);

#if 0
	CSMIRToClassAssociator :: Associate(a_Smir,this);
#endif
	CGroupToClassAssociator	:: Associate(a_Smir,szModuleName, szGroupName, this);
	CModuleToClassAssociator :: Associate(a_Smir,szModuleName, this);
	SysFreeString(szGroupName);
	SysFreeString(szModuleName);
	return S_OK;
}

SCODE CSmirClassHandle ::  DeleteClassFromGroup( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMClass(&pIMosClass);
	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}

	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (NULL, &moContext);
	//SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	res= CSmirAccess :: Open(a_Smir,&moServ);
	if (FAILED(res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		pIMosClass->Release();
		return WBEM_E_FAILED;
	}
	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = NULL;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(V_BSTR(&v))
						+CString(CLOSE_BRACE_STR)
						+CString(SPACE_STR)
						+CString(SMIR_ASSOC_QUERY_STR4)
						+CString(EQUALS_STR)
						+CString(SMIR_GROUP_ASSOC_CLASS_NAME)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
							RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned;

		//loop over the associations to see how many there are
		int iAssociations=0;
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			iAssociations++;
			if(iAssociations>1)
			{
				break;
			}
		}
		if(1 == iAssociations)
		{
			//nly one so delete it
			moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
		}
		pEnum->Release();
	}
	//clean up
	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

SCODE CSmirClassHandle ::  DeleteFromDB ( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMClass(&pIMosClass);
	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}
	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (a_Smir, &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		pIMosClass->Release();
		return WBEM_E_FAILED;
	}
	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = NULL ;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(V_BSTR(&v))
						+CString(CLOSE_BRACE_STR)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned = 0;

		//loop over the associations
		VARIANT assocClass;
		VariantInit(&assocClass);
		VARIANT assocName;
		VariantInit(&assocName);
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
			pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
			CString instString(  

				CString(V_BSTR(&assocClass))
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(V_BSTR(&assocName))
				+CString(QUOTE_STR)
			);

			VariantClear(&assocName);
			VariantClear(&assocClass);

			BSTR instBString = instString.AllocSysString();
			moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
			
			SysFreeString(instBString);
			pAssocMosClass->Release();
		}
		pEnum->Release();
		//and delete it
		moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
	}
	//clean up
	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

const CSmirClassHandle& CSmirClassHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if (m_pIMosClass)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		VARIANT v;
		VariantInit(&v);
		m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);
		if (V_VT(&v) == VT_BSTR)
		{
			BSTR pszClassMof=NULL;
			HRESULT result = m_pIMosClass->GetObjectText(WBEM_FLAG_NO_FLAVORS, &pszClassMof);
			if (SUCCEEDED (result))
			{

				if(TRUE==bMOFPragmas)
				{
					//start in the SMIR namespace
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);
				}

				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(pszClassMof);
				SysFreeString(pszClassMof);

				if(TRUE==bMOFAssociations)
				{
					/*******************create the Module associations*************************/
					//instance of <assoc> \n{\n
					CString szTmpString =INSTANCE_START;
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Module="<Group>"";
					szTmpString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(MODULE_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;

					/*******************create the Group associations*************************/
					//instance of <assoc> \n{\n
					szTmpString+=INSTANCE_START;
					szTmpString+=CString(SMIR_GROUP_ASSOC_CLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=CString(SMIR_GROUP_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Group="<Group>"";
					szTmpString+=CString(SMIR_GROUP_ASSOC_GROUP_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(L"\\\\");
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(GROUP_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szGroupName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=szTmpString;
				}
			}
		}
		VariantClear(&v);
	}
	return *this;
}

/*NotificationClass handle methods
 */
/*
 * CSmirNotificationClassHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirNotificationClassHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_NotificationClassHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirNotificationClassHandle::AddRef
 * CSmirNotificationClassHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirNotificationClassHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirClassHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirNotificationClassHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CSmirNotificationClassHandle :: CSmirNotificationClassHandle()
:	m_pIMosClass(NULL), m_szModuleName(NULL)
{
	CNotificationClassHandleClassFactory::objectsInProgress++;

	//init the reference count
	m_cRef=0;
}

CSmirNotificationClassHandle :: ~CSmirNotificationClassHandle()
{
	if (NULL != m_pIMosClass)
		m_pIMosClass->Release();
	SysFreeString(m_szModuleName);
	CNotificationClassHandleClassFactory::objectsInProgress--;
}


/*
 * CSmirModuleHandle::void* operator
 * validate handle
 */

CSmirNotificationClassHandle::operator void*()
{
	if((NULL!=m_szModuleName) && (NULL!=m_pIMosClass))
		return this;
	return NULL;
}

SCODE CSmirNotificationClassHandle :: GetWBEMNotificationClass(

	IWbemClassObject **pObj
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pObj) 
			return E_INVALIDARG;

		//if the class already exists return it

		if(m_pIMosClass)
		{
			m_pIMosClass->AddRef();
			*pObj=m_pIMosClass;
			return S_OK;
		}
		else
		{
			*pObj=NULL ;
			return WBEM_E_FAILED;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CSmirNotificationClassHandle :: SetWBEMNotificationClass(IWbemClassObject *pObj)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pObj)
		{
			m_pIMosClass = pObj;
			m_pIMosClass->AddRef () ;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirNotificationClassHandle ::  SetModule(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirNotificationClassHandle :: GetModule(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			if (NULL == m_szModuleName)
			{
				*szName = NULL;
			}
			else
			{
				*szName=SysAllocString(m_szModuleName);
			}

			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


/**************************************************************************************
 *Methods not exposed by the ISmirClassHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

SCODE CSmirNotificationClassHandle ::  AddToDB(CSmir *a_Smir)
{
	BSTR szModuleName = NULL ;
	GetModule(&szModuleName);

	if (NULL == szModuleName)
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,E_INVALIDARG);
		return WBEM_E_FAILED;
	}
	
	//open the root\default name space

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ);

	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}

	//now commit the changes
	result = moServ->PutClass(m_pIMosClass, RESERVED_WBEM_FLAG, moContext,NULL);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return E_UNEXPECTED;
	}

	if ( moContext )
		moContext->Release () ;

	moServ->Release();

	//add the associations
	CModuleToNotificationClassAssociator :: Associate(a_Smir,szModuleName, this);
	SysFreeString(szModuleName);
	CNotificationMapper :: Map(a_Smir,m_pIMosClass, SNMP_NOTIFICATION_CLASS);

	return S_OK;
}


SCODE CSmirNotificationClassHandle ::  DeleteFromDB ( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMNotificationClass(&pIMosClass);

	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}

	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (a_Smir, &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);

	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		pIMosClass->Release();
		return WBEM_E_FAILED;
	}

	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);

	if (V_VT(&v) == VT_BSTR)
	{
		CString classnamestr(V_BSTR(&v));

		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = 0;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+classnamestr
						+CString(CLOSE_BRACE_STR)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned = 0;

		//loop over the associations
		VARIANT assocClass;
		VariantInit(&assocClass);
		VARIANT assocName;
		VariantInit(&assocName);
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
			pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
			CString instString(CString(V_BSTR(&assocClass))
								+CString(EQUALS_STR)
								+CString(V_BSTR(&assocName))
									);
			VariantClear(&assocName);
			VariantClear(&assocClass);

			BSTR instBString = instString.AllocSysString();
			moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
			
			SysFreeString(instBString);
			pAssocMosClass->Release();
		}
		pEnum->Release();
		pEnum = NULL;

		//now get the mapper instance and delete that too.
		sQuery = CString(SQL_QUERY_STR1) +
					CString(SMIR_NOTIFICATION_MAPPER) +
					CString(SQL_QUERY_STR2) +
					CString(SMIR_NOTIFICATION_CLASS_PROP) +
					CString(EQUALS_STR) +
					CString(QUOTE_STR) +
					classnamestr +
					CString(QUOTE_STR);

		BSTR  szQuery2 = sQuery.AllocSysString();
		t_QueryFormat = SMIR_ASSOC_QUERY2_TYPE ;
		sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery2, 

									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery2);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		uCount=1; 
		pAssocMosClass = NULL;
		puReturned = 0;
		VariantClear(&assocClass);

		//loop over the associations and delete them
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			sRes = pAssocMosClass->Get(OLEMS_PATH_PROP, RESERVED_WBEM_FLAG,
										&assocClass, NULL, NULL);
			pAssocMosClass->Release();

			if (FAILED(sRes) && (VT_BSTR == assocClass.vt))
			{
				CString instString(V_BSTR(&assocClass));
				VariantClear(&assocClass);
				BSTR instBString = instString.AllocSysString();
				moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
				SysFreeString(instBString);
			}
		}

		pEnum->Release();
		
		//now delete the class
		moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
	}

	//clean up
	moServ->Release();
	if ( moContext )
		moContext->Release () ;

	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

const CSmirNotificationClassHandle& CSmirNotificationClassHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if (m_pIMosClass)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		VARIANT vclass;
		VariantInit(&vclass);
		VARIANT vtrapoid;
		VariantInit(&vtrapoid);

		m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &vclass,NULL,NULL);
		m_pIMosClass->Get(TRAPOID_PROP, RESERVED_WBEM_FLAG, &vtrapoid,NULL,NULL);

		if ((V_VT(&vclass) == VT_BSTR) && (V_VT(&vtrapoid) == VT_BSTR))
		{
			BSTR pszClassMof = NULL ;
			m_pIMosClass->GetObjectText(WBEM_FLAG_NO_FLAVORS, &pszClassMof);
			if (pszClassMof)
			{

				if(TRUE==bMOFPragmas)
				{
					//start in the SMIR namespace
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);
				}

				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(pszClassMof);
				SysFreeString(pszClassMof);

				/*******************create the TrapNotificationMapper*************************/
				//instance of TrapNotificationMapper \n{\n
				CString tmpString=INSTANCE_START;
				tmpString+=CString(SMIR_NOTIFICATION_MAPPER);
				tmpString+=NL_BRACE_NL_STR;

				//SnmpTrapOID
				tmpString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vtrapoid));
				tmpString+=END_OF_PROPERTY_VALUE;

				//Eventclass
				tmpString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vclass));
				tmpString+=END_OF_PROPERTY_VALUE;
			
				tmpString+=END_OF_CLASS;
				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=tmpString;

				if(TRUE==bMOFAssociations)
				{
					/*******************create the SMIR associations*************************/
					/*******************create the Module associations***********************/
					//instance of <assoc> \n{\n
					CString szTmpString=INSTANCE_START;
					szTmpString+=CString(SMIR_MODULE_ASSOC_NCLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Module="<Group>"";
					szTmpString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(MODULE_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=szTmpString;
				}
			}
		}
		VariantClear(&vclass);
		VariantClear(&vtrapoid);
	}
	return *this;
}



/*ExtNotificationClass handle methods
 */
/*
 * CSmirExtNotificationClassHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirExtNotificationClassHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ExtNotificationClassHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirExtNotificationClassHandle::AddRef
 * CSmirExtNotificationClassHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirExtNotificationClassHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirClassHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirExtNotificationClassHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirExtNotificationClassHandle :: CSmirExtNotificationClassHandle()
:	m_pIMosClass (NULL), m_szModuleName(NULL)
{
	CExtNotificationClassHandleClassFactory::objectsInProgress++;

	//init the reference count
	m_cRef=0;
}

CSmirExtNotificationClassHandle :: ~CSmirExtNotificationClassHandle()
{
	if (NULL != m_pIMosClass)
		m_pIMosClass->Release();
	SysFreeString(m_szModuleName);
	CExtNotificationClassHandleClassFactory::objectsInProgress--;
}


/*
 * CSmirModuleHandle::void* operator
 * validate handle
 */

CSmirExtNotificationClassHandle::operator void*()
{
	if((NULL!=m_szModuleName) && (NULL!=m_pIMosClass))
		return this;
	return NULL;
}

SCODE CSmirExtNotificationClassHandle :: GetWBEMExtNotificationClass (

	IWbemClassObject **pObj
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pObj) 
			return E_INVALIDARG;

		//if the class already exists return it

		if(m_pIMosClass)
		{
			m_pIMosClass->AddRef();
			*pObj=m_pIMosClass;
			return S_OK;
		}
		else
		{
			*pObj=NULL;
			return WBEM_E_FAILED;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CSmirExtNotificationClassHandle :: SetWBEMExtNotificationClass(IWbemClassObject *pObj)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pObj)
		{
			m_pIMosClass = pObj;
			m_pIMosClass->AddRef () ;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirExtNotificationClassHandle ::  SetModule(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirExtNotificationClassHandle :: GetModule(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			if (NULL == m_szModuleName)
			{
				*szName = NULL;
			}
			else
			{
				*szName=SysAllocString(m_szModuleName);
			}

			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


/**************************************************************************************
 *Methods not exposed by the ISmirClassHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

SCODE CSmirExtNotificationClassHandle ::  AddToDB ( CSmir *a_Smir )
{
	BSTR szModuleName = NULL ;
	GetModule(&szModuleName);

	if (NULL == szModuleName)
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,E_INVALIDARG);
		return WBEM_E_FAILED;
	}
	
	//open the root\default name space

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ);
	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}

	//now commit the changes
	result = moServ->PutClass(m_pIMosClass, RESERVED_WBEM_FLAG, moContext,NULL);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release () ;
		return E_UNEXPECTED;
	}

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return E_UNEXPECTED;
	}

	//add the associations
	CModuleToExtNotificationClassAssociator :: Associate(a_Smir,szModuleName, this);
	SysFreeString(szModuleName);
	CNotificationMapper :: Map(a_Smir,m_pIMosClass, SNMP_EXT_NOTIFICATION_CLASS);

	return S_OK;
}

SCODE CSmirExtNotificationClassHandle ::  DeleteFromDB ( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMExtNotificationClass(&pIMosClass);

	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}

	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);

	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		pIMosClass->Release();
		return WBEM_E_FAILED;
	}

	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);

	if (V_VT(&v) == VT_BSTR)
	{
		CString classnamestr(V_BSTR(&v));

		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = NULL ;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+classnamestr
						+CString(CLOSE_BRACE_STR)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned = 0;

		//loop over the associations
		VARIANT assocClass;
		VariantInit(&assocClass);
		VARIANT assocName;
		VariantInit(&assocName);
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
			pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
			CString instString(CString(V_BSTR(&assocClass))
								+CString(EQUALS_STR)
								+CString(V_BSTR(&assocName))
									);
			VariantClear(&assocName);
			VariantClear(&assocClass);

			BSTR instBString = instString.AllocSysString();
			moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
			
			SysFreeString(instBString);
			pAssocMosClass->Release();
		}
		pEnum->Release();
		pEnum = NULL;

		//now get the mapper instance and delete that too.
		sQuery = CString(SQL_QUERY_STR1) +
					CString(SMIR_EXT_NOTIFICATION_MAPPER) +
					CString(SQL_QUERY_STR2) +
					CString(SMIR_NOTIFICATION_CLASS_PROP) +
					CString(EQUALS_STR) +
					CString(QUOTE_STR) +
					classnamestr +
					CString(QUOTE_STR);

		BSTR  szQuery2 = sQuery.AllocSysString();
		t_QueryFormat = SMIR_ASSOC_QUERY2_TYPE;
		sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery2, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery2);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		uCount=1; 
		pAssocMosClass = NULL;
		puReturned = 0;
		VariantClear(&assocClass);

		//loop over the associations and delete them
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			sRes = pAssocMosClass->Get(OLEMS_PATH_PROP, RESERVED_WBEM_FLAG,
										&assocClass, NULL, NULL);
			pAssocMosClass->Release();

			if (FAILED(sRes) && (VT_BSTR == assocClass.vt))
			{
				CString instString(V_BSTR(&assocClass));
				VariantClear(&assocClass);
				BSTR instBString = instString.AllocSysString();
				moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
				SysFreeString(instBString);
			}
		}

		pEnum->Release();
		
		//now delete the class
		moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
	}

	//clean up

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

const CSmirExtNotificationClassHandle& CSmirExtNotificationClassHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if (m_pIMosClass)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		VARIANT vclass;
		VariantInit(&vclass);
		VARIANT vtrapoid;
		VariantInit(&vtrapoid);

		m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &vclass,NULL,NULL);
		m_pIMosClass->Get(TRAPOID_PROP, RESERVED_WBEM_FLAG, &vtrapoid,NULL,NULL);

		if ((V_VT(&vclass) == VT_BSTR) && (V_VT(&vtrapoid) == VT_BSTR))
		{
			BSTR pszClassMof = NULL ;
			m_pIMosClass->GetObjectText(WBEM_FLAG_NO_FLAVORS, &pszClassMof);
			if (pszClassMof)
			{

				if(TRUE==bMOFPragmas)
				{
					//start in the SMIR namespace
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);
				}

				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(pszClassMof);
				SysFreeString(pszClassMof);

				/*******************create the ExtNotificationMapper*************************/
				//instance of ExtNotificationMapper \n{\n
				CString tmpString=INSTANCE_START;
				tmpString+=CString(SMIR_EXT_NOTIFICATION_MAPPER);
				tmpString+=NL_BRACE_NL_STR;

				//SnmpTrapOID
				tmpString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vtrapoid));
				tmpString+=END_OF_PROPERTY_VALUE;

				//Eventclass
				tmpString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vclass));
				tmpString+=END_OF_PROPERTY_VALUE;
			
				tmpString+=END_OF_CLASS;
				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=tmpString;

				if(TRUE==bMOFAssociations)
				{
					/*******************create the SMIR associations*************************/
					/*******************create the Module associations***********************/
					//instance of <assoc> \n{\n
					CString szTmpString=INSTANCE_START;
					szTmpString+=CString(SMIR_MODULE_ASSOC_EXTNCLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Module="<Group>"";
					szTmpString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(MODULE_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=szTmpString;
				}
			}
		}
		VariantClear(&vclass);
		VariantClear(&vtrapoid);
	}
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include <windows.h>
#include <provexpt.h>
#include <ocidl.h>
#include <olectl.h>
#include <objbase.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <wchar.h>
#include <process.h> 
#include <wbemidl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.  Copyright (c) 1997-2001 Microsoft Corporation
// Used by smir.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\smirevt.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*
 * SMIREVT.CPP
 *
 * Implemenation of a connection point object for the SMIR notify mechanism.
 * The methods/objects in this file are accessed by the SMIR API; the API
 * provides a user friendly interface to ISMIRNotify.
 */
#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include <textdef.h>
#include "evtcons.h"
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif


extern CRITICAL_SECTION g_CriticalSection ;


/**********************************************************************************
 * CSmirConnectionPoint
 *
 * Connectpoint implementation that supports the interface ISMIRNotify.
 *
 * CSmirConnObject::CSmirConnObject
 * CSmirConnObject::~CSmirConnObject
 ***********************************************************************************/
/*
 * CSmirConnectionPoint::CSmirConnectionPoint
 * CSmirConnectionPoint::~CSmirConnectionPoint
 *
 * Parameters (Constructor):
 *  pObj            PCSmirConnObject of the object we're in.  We can
 *                  query this for the IConnectionPointContainer
 *                  interface we might need.
 *  riid            REFIID of the interface we're supporting
 ***********************************************************************************/

CSmirConnectionPoint::CSmirConnectionPoint(PCSmirConnObject pObj, REFIID riid, CSmir *pSmir)
{
    m_cRef=0;
    m_iid=riid;
    /*
     * Our lifetime is controlled by the connectable object itself,
     * although other external clients will call AddRef and Release.
     * Since we're nested in the connectable object's lifetime,
     * there's no need to call AddRef on pObj.
     */
    m_pObj=pObj;
    m_dwCookieNext=100;       //Arbitrary starting cookie value
}

CSmirConnectionPoint::~CSmirConnectionPoint(void)
{
	DWORD	  lKey =  0;
	LPUNKNOWN pItem = NULL;
	POSITION  rNextPosition;
	for(rNextPosition=m_Connections.GetStartPosition();NULL!=rNextPosition;)
	{
		m_Connections.GetNextAssoc(rNextPosition, lKey, pItem );
		pItem->Release();
	}
	m_Connections.RemoveAll();

    return;
}

/*
 * CSmirConnectionPoint::QueryInterface
 * CSmirConnectionPoint::AddRef
 * CSmirConnectionPoint::Release
 *
 * Purpose:
 *  Non-delegating IUnknown members for CSmirConnectionPoint.
 */

STDMETHODIMP CSmirConnectionPoint::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if ((IID_IUnknown == riid) || 
			(IID_IConnectionPoint == riid)|| 
				(IID_ISMIR_Notify == riid))
        *ppv=(LPVOID)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSmirConnectionPoint::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSmirConnectionPoint::Release(void)
{
	long ret;
    if (0!=(ret=InterlockedDecrement(&m_cRef)))
        return ret;

    delete this;
    return 0;
}

/*
 * CSmirConnectionPoint::GetConnectionInterface
 *
 * Purpose:
 *  Returns the IID of the outgoing interface supported through
 *  this connection point.
 *
 * Parameters:
 *  pIID            IID * in which to store the IID.
 */

STDMETHODIMP CSmirConnectionPoint::GetConnectionInterface(IID *pIID)
{
    if (NULL==pIID)
        return ResultFromScode(E_POINTER);

    *pIID=m_iid;
    return NOERROR;
}

/*
 * CSmirConnectionPoint::GetConnectionPointContainer
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPointContainer that
 *  is manageing this connection point.
 *
 * Parameters:
 *  ppCPC           IConnectionPointContainer ** in which to return
 *                  the pointer after calling AddRef.
 */

STDMETHODIMP CSmirConnectionPoint::GetConnectionPointContainer
    (IConnectionPointContainer **ppCPC)
 {
    return m_pObj->QueryInterface(IID_IConnectionPointContainer
        , (void **)ppCPC);
 }

/*
 * CSmirConnectionPoint::Advise
 *
 * Purpose:
 *  Provides this connection point with a notification sink to
 *  call whenever the appropriate outgoing function/event occurs.
 *
 * Parameters:
 *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection
 *                  point must QueryInterface on this pointer to obtain
 *                  the proper interface to call.  The connection
 *                  point must also insure that any pointer held has
 *                  a reference count (QueryInterface will do it).
 *  pdwCookie       DWORD * in which to store the connection key for
 *                  later calls to Unadvise.
 */

STDMETHODIMP CSmirConnectionPoint::Advise(LPUNKNOWN pUnkSink
    , DWORD *pdwCookie)
{
    *pdwCookie=0;
	if (NULL == pUnkSink)
		return E_POINTER;

	/*
     * Verify that the sink has the interface it's supposed
     * to.  We don't have to know what it is because we have
     * m_iid to describe it.  If this works, then we 
     * have a pointer with an AddRef that we can save.
     */
    IUnknown       *pSink = NULL ;
    if (FAILED(pUnkSink->QueryInterface(m_iid, (PPVOID)&pSink)))
    {
		return CONNECT_E_CANNOTCONNECT;
	}
    
    //We got the sink, now store it. 
	*pdwCookie = InterlockedIncrement(&m_dwCookieNext);

	m_Connections.SetAt(*pdwCookie,pSink);
	/*Add ref the smir to make sure that this stays in memory for the lifetime of the 
	 *sink. The release is in unadvise.
	 */
    return S_OK;
}

/*
 * CSmirConnectionPoint::Unadvise
 *
 * Purpose:
 *  Terminates the connection to the notification sink identified
 *  with dwCookie (that was returned from Advise).  The connection
 *  point has to Release any held pointers for that sink.
 *
 * Parameters:
 *  dwCookie        DWORD connection key from Advise.
 */

STDMETHODIMP CSmirConnectionPoint::Unadvise(DWORD dwCookie)
{
	//the only invalid cookie is 0
    if (0==dwCookie)
	{
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirConnectionPoint::Unadvise E_INVALIDARG");
        return E_UNEXPECTED;
	}
	LPUNKNOWN pSink = NULL;
	//stop anyone else unadvising with the same cookie
	criticalSection.Lock () ;
	if(TRUE == m_Connections.Lookup(dwCookie,pSink))
	{
		m_Connections.RemoveKey(dwCookie);
		//having removed the key the look up will fail so we can release the critical section
		criticalSection.Unlock () ;
		pSink->Release();
		/*release the smir. This could cause the smir to unload from memory! Do not do
		 *anything after this because we are (ultimatly) owned by the smir object
		 */

		return S_OK;
	}
	criticalSection.Unlock () ;
    return CONNECT_E_NOCONNECTION;
}
/*
 * CSmirConnectionPoint::EnumConnections
 *
 * Purpose:
 *  Creates and returns an enumerator object with the
 *  IEnumConnections interface that will enumerate the IUnknown
 *  pointers of each connected sink.
 *
 * Parameters:
 *  ppEnum          LPENUMCONNECTIONS in which to store the
 *                  IEnumConnections pointer.
 */

STDMETHODIMP CSmirConnectionPoint::EnumConnections(LPENUMCONNECTIONS *ppEnum)
{
    LPCONNECTDATA       pCD = NULL;
    PCEnumConnections   pEnum = NULL;

	//NULL the IN parameter
    *ppEnum=NULL;

	//check that we have some connections
    if (0 == m_Connections.GetCount())
        return ResultFromScode(OLE_E_NOCONNECTION);

    /*
     * Create the array of CONNECTDATA structures to give to the
     * enumerator.
     */
    pCD=new CONNECTDATA[(UINT)m_Connections.GetCount()];

    if (NULL==pCD)
        return ResultFromScode(E_OUTOFMEMORY);

	DWORD	  lKey =  0;
	LPUNKNOWN pItem = NULL;
	POSITION  rNextPosition;
    UINT      j=0;
	for(rNextPosition=m_Connections.GetStartPosition();NULL!=rNextPosition;j++)
	{
		m_Connections.GetNextAssoc(rNextPosition, lKey, pItem );
        pCD[j].pUnk=pItem;
        pCD[j].dwCookie=lKey;
	}
    /*
     * If creation works, it makes a copy pCD, so we can
     * always delete it regardless of the outcome.
     */
    pEnum=new CEnumConnections(this, m_Connections.GetCount(), pCD);
    delete [] pCD;

    if (NULL==pEnum)
        return ResultFromScode(E_OUTOFMEMORY);

    //This does an AddRef for us.
    return pEnum->QueryInterface(IID_IEnumConnections, (PPVOID)ppEnum);
}

//Connection Enumerator follows

/*
 * CEnumConnections::CEnumConnections
 * CEnumConnections::~CEnumConnections
 *
 * Parameters (Constructor):
 *  pUnkRef         LPUNKNOWN to use for reference counting.
 *  cConn           ULONG number of connections in prgpConn
 *  prgConnData     LPCONNECTDATA to the array to enumerate.
 */

CEnumConnections::CEnumConnections(LPUNKNOWN pUnkRef, ULONG cConn
								   , LPCONNECTDATA prgConnData) : m_rgConnData ( NULL )
{
    UINT        i;

    m_cRef=0;
    m_pUnkRef=pUnkRef;

    m_iCur=0;
    m_cConn=cConn;

    /*
     * Copy the passed array.  We need to do this because a clone
     * has to have its own copy as well.
     */
    m_rgConnData=new CONNECTDATA[(UINT)cConn];

    if (NULL!=m_rgConnData)
    {
        for (i=0; i < cConn; i++)
        {
            m_rgConnData[i]=prgConnData[i];
            m_rgConnData[i].pUnk=prgConnData[i].pUnk;
            m_rgConnData[i].pUnk->AddRef();
        }
    }

    return;
}

CEnumConnections::~CEnumConnections(void)
{
    if (NULL!=m_rgConnData)
    {
        UINT        i;

        for (i=0; i < m_cConn; i++)
            m_rgConnData[i].pUnk->Release();

        delete [] m_rgConnData;
    }

    return;
}
/*
 * CEnumConnections::QueryInterface
 * CEnumConnections::AddRef
 * CEnumConnections::Release
 *
 * Purpose:
 *  IUnknown members for CEnumConnections object.
 */

STDMETHODIMP CEnumConnections::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumConnections==riid)
        *ppv=(LPVOID)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumConnections::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    m_pUnkRef->AddRef();
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumConnections::Release(void)
{
    m_pUnkRef->Release();

	long ret;
    if (0L!=(ret=InterlockedDecrement(&m_cRef)))
        return ret;

    delete this;
    return 0;
}

/*
 * CEnumConnections::Next
 *
 * Purpose:
 *  Returns the next element in the enumeration.
 *
 * Parameters:
 *  cConn           ULONG number of connections to return.
 *  pConnData       LPCONNECTDATA in which to store the returned
 *                  structures.
 *  pulEnum         ULONG * in which to return how many we
 *                  enumerated.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE otherwise,
 */

STDMETHODIMP CEnumConnections::Next(ULONG cConn
    , LPCONNECTDATA pConnData, ULONG *pulEnum)
{
    ULONG               cReturn=0L;

    if (NULL==m_rgConnData)
        return ResultFromScode(S_FALSE);

    if (NULL==pulEnum)
    {
        if (1L!=cConn)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulEnum=0L;

    if (NULL==pConnData || m_iCur >= m_cConn)
        return ResultFromScode(S_FALSE);

    while (m_iCur < m_cConn && cConn > 0)
    {
        *pConnData++=m_rgConnData[m_iCur];
        m_rgConnData[m_iCur++].pUnk->AddRef();
        cReturn++;
        cConn--;
    }

    if (NULL!=pulEnum)
        *pulEnum=cReturn;

    return NOERROR;
}

STDMETHODIMP CEnumConnections::Skip(ULONG cSkip)
{
    if (((m_iCur+cSkip) >= m_cConn) || NULL==m_rgConnData)
        return ResultFromScode(S_FALSE);

    m_iCur+=cSkip;
    return NOERROR;
}

STDMETHODIMP CEnumConnections::Reset(void)
{
    m_iCur=0;
    return NOERROR;
}

STDMETHODIMP CEnumConnections::Clone(LPENUMCONNECTIONS *ppEnum)
{
    PCEnumConnections   pNew;

    *ppEnum=NULL;

    //Create the clone
    pNew=new CEnumConnections(m_pUnkRef, m_cConn, m_rgConnData);

    if (NULL==pNew)
        return ResultFromScode(E_OUTOFMEMORY);

    pNew->AddRef();
    pNew->m_iCur=m_iCur;

    *ppEnum=pNew;
    return NOERROR;
}

/**********************************************************************************
 * CSmirConnObject
 *
 * Connectable Object implementation that supports the 
 * interface ISMIRNotify.
 *
 * CSmirConnObject::CSmirConnObject
 * CSmirConnObject::~CSmirConnObject
 ***********************************************************************************/

CSmirConnObject::CSmirConnObject(CSmir *pSmir) : m_rgpConnPt ( NULL )
{
//	CSMIRClassFactory::objectsInProgress++;
    m_cRef=0;
	//create SMIR_NUMBER_OF_CONNECTION_POINTS connection points
	m_rgpConnPt = new CSmirConnectionPoint*[SMIR_NUMBER_OF_CONNECTION_POINTS];
	for(int iLoop=0;iLoop<SMIR_NUMBER_OF_CONNECTION_POINTS;iLoop++)
		m_rgpConnPt[iLoop] = NULL;

	try
	{
		Init(pSmir);
	}
	catch(...)
	{
		if (m_rgpConnPt)
		{
			//free the connection points
			for(int iLoop=0;iLoop<SMIR_NUMBER_OF_CONNECTION_POINTS;iLoop++)
			{   
				if (NULL!=m_rgpConnPt[iLoop])
				{
					//release all of the connected objects
					//while(m_rgpConnPt[iLoop]->Release());
					m_rgpConnPt[iLoop]->Release();
				}
			}
			//and delete the connection point
			delete[] m_rgpConnPt;
			m_rgpConnPt = NULL;
		}

		throw;
	}
}

CSmirConnObject::~CSmirConnObject(void)
{
	if (m_rgpConnPt)
	{
		//free the connection points
		for(int iLoop=0;iLoop<SMIR_NUMBER_OF_CONNECTION_POINTS;iLoop++)
		{   
			if (NULL!=m_rgpConnPt[iLoop])
			{
				//release all of the connected objects
				//while(m_rgpConnPt[iLoop]->Release());
				m_rgpConnPt[iLoop]->Release();
			}
		}
		//and delete the connection point
		delete[] m_rgpConnPt;
	}

//	CSMIRClassFactory::objectsInProgress--;
}

/*
 * CSmirConnObject::Init
 *
 * Purpose:
 *  Instantiates the interface implementations for this object.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 * BOOL    TRUE if initialization succeeds, FALSE otherwise.
 */

BOOL CSmirConnObject::Init(CSmir *pSmir)
{
    //Create our connection points

	//the smir change CP
    m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT]=
									new CSmirNotifyCP(this, 
											IID_ISMIR_Notify, pSmir);
    
	if (NULL==m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT])
        return FALSE;

    m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT]->AddRef();

    return TRUE;
}
/*
 * CSmirConnObject::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown, ISampleOne, and ISampleTwo interfaces.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirConnObject::QueryInterface(REFIID riid, PPVOID ppv)
{
	if (ppv)
		*ppv = NULL;
	else
		return E_INVALIDARG;

	if((IID_IConnectionPointContainer == riid)||(IID_ISMIR_Notify == riid))
		*ppv = this;
	else
		return E_NOINTERFACE;

	return S_OK;
}

/*
 * CSmirConnObject::AddRef
 * CSmirConnObject::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

DWORD CSmirConnObject::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

DWORD CSmirConnObject::Release(void)
{
	long ret;
    if (0!=(ret=InterlockedDecrement(&m_cRef)))
	{
        return ret;
	}

    delete this;
    return 0;
}

/*
 * CSmirConnObject::EnumConnectionPoints
 *
 * Purpose:
 *  Creates and returns an enumerator object with the
 *  IEnumConnectionPoints interface that will enumerate the
 *  individual connection points supported in this object.
 *
 * Parameters:
 *  ppEnum          LPENUMCONNECTIONPOINTS in which to store the
 *                  IEnumConnectionPoints pointer.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, E_OUTOFMEMORY on failure or
 *                  other error code.
 */

STDMETHODIMP CSmirConnObject :: EnumConnectionPoints
    (LPENUMCONNECTIONPOINTS *ppEnum)
{
    IConnectionPoint       **rgCP = NULL ;
    CEnumConnectionPoints  * pEnum = NULL ;

    *ppEnum=NULL;

    rgCP=(IConnectionPoint **)m_rgpConnPt;

    //Create the enumerator:  we  have two connection points
    pEnum=new CEnumConnectionPoints(this, SMIR_NUMBER_OF_CONNECTION_POINTS, rgCP);

    if (NULL==pEnum)
        return ResultFromScode(E_OUTOFMEMORY);

    pEnum->AddRef();
    *ppEnum=pEnum;
    return NOERROR;
}

/*
 * CSmirConnObject::FindConnectionPoint
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPoint for a given
 *  outgoing IID.
 *
 * Parameters:
 *  riid            REFIID of the outgoing interface for which
 *                  a connection point is desired.
 *  ppCP            IConnectionPoint ** in which to return
 *                  the pointer after calling AddRef.
 *
 * Return Value:
 *  HRESULT         NOERROR if the connection point is found,
 *                  E_NOINTERFACE if it's not supported.
 */

STDMETHODIMP CSmirConnObject::FindConnectionPoint(REFIID riid
    , IConnectionPoint **ppCP)
{
    *ppCP=NULL;
	HRESULT result;
    if (IID_ISMIR_Notify==riid)
    {
        result = m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT]
								->QueryInterface(IID_IConnectionPoint, (PPVOID)ppCP);
		if (NULL != ppCP)
			return result;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//Connection Point Enumerator follows

/*
 * CEnumConnectionPoints::CEnumConnectionPoints
 * CEnumConnectionPoints::~CEnumConnectionPoints
 *
 * Parameters (Constructor):
 *  pUnkRef         LPUNKNOWN to use for reference counting.
 *  cPoints         ULONG number of connection points in prgpCP
 *  rgpCP           IConnectionPoint** to the array to enumerate.
 */

CEnumConnectionPoints::CEnumConnectionPoints(LPUNKNOWN pUnkRef
											 , ULONG cPoints, IConnectionPoint **rgpCP) : m_rgpCP ( NULL )
{
    UINT        i;

    m_cRef=0;
    m_pUnkRef=pUnkRef;

    m_iCur=0;
    m_cPoints=cPoints;
    m_rgpCP=new IConnectionPoint *[(UINT)cPoints];

    if (NULL!=m_rgpCP)
    {
        for (i=0; i < cPoints; i++)
        {
            m_rgpCP[i]=rgpCP[i];
            m_rgpCP[i]->AddRef();
        }
    }

    return;
}

CEnumConnectionPoints::~CEnumConnectionPoints(void)
{
    if (NULL!=m_rgpCP)
    {
        UINT        i;

        for (i=0; i < m_cPoints; i++)
            m_rgpCP[i]->Release();

        delete [] m_rgpCP;
    }

    return;
}

/*
 * CEnumConnectionPoints::QueryInterface
 * CEnumConnectionPoints::AddRef
 * CEnumConnectionPoints::Release
 *
 * Purpose:
 *  IUnknown members for CEnumConnectionPoints object.
 */

STDMETHODIMP CEnumConnectionPoints::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumConnectionPoints==riid)
        *ppv=(LPVOID)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumConnectionPoints::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    m_pUnkRef->AddRef();
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumConnectionPoints::Release(void)
{
    m_pUnkRef->Release();

	long ret;
    if (0L!=(ret=InterlockedDecrement(&m_cRef)))
        return ret;

    delete this;
    return 0;
}

/*
 * CEnumConnectionPoints::Next
 *
 * Purpose:
 *  Returns the next element in the enumeration.
 *
 * Parameters:
 *  cPoints         ULONG number of connection points to return.
 *  ppCP            IConnectionPoint** in which to store the returned
 *                  pointers.
 *  pulEnum         ULONG * in which to return how many we
 *                  enumerated.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE otherwise,
 */

STDMETHODIMP CEnumConnectionPoints::Next(ULONG cPoints
    , IConnectionPoint **ppCP, ULONG *pulEnum)
{
    ULONG               cReturn=0L;

    if (NULL==m_rgpCP)
        return ResultFromScode(S_FALSE);

    if (NULL==ppCP)
        return ResultFromScode(E_POINTER);

    if (NULL==pulEnum)
    {
        if (1L!=cPoints)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulEnum=0L;

    if (NULL==*ppCP || m_iCur >= m_cPoints)
        return ResultFromScode(S_FALSE);

    while (m_iCur < m_cPoints && cPoints > 0)
    {
	    *ppCP=m_rgpCP[m_iCur++];

        if (NULL!=*ppCP)
            (*ppCP)->AddRef();

        ppCP++;
        cReturn++;
        cPoints--;
    }

    if (NULL!=pulEnum)
        *pulEnum=cReturn;

    return NOERROR;
}

STDMETHODIMP CEnumConnectionPoints::Skip(ULONG cSkip)
{
    if (((m_iCur+cSkip) >= m_cPoints) || NULL==m_rgpCP)
        return ResultFromScode(S_FALSE);

    m_iCur+=cSkip;
    return NOERROR;
}


STDMETHODIMP CEnumConnectionPoints::Reset(void)
{
    m_iCur=0;
    return NOERROR;
}

STDMETHODIMP CEnumConnectionPoints::Clone
    (LPENUMCONNECTIONPOINTS *ppEnum)
{
    PCEnumConnectionPoints   pNew = NULL ;

    *ppEnum=NULL;

    //Create the clone
    pNew=new CEnumConnectionPoints(m_pUnkRef, m_cPoints, m_rgpCP);

    if (NULL==pNew)
        return ResultFromScode(E_OUTOFMEMORY);

    pNew->AddRef();
    pNew->m_iCur=m_iCur;

    *ppEnum=pNew;
    return NOERROR;
}
/*
 * CSmirEnumClassCP/CSmirNotifyCP::
 *
 * Purpose:
 *  Provides the notify connection point advise, unadvise constructor and destructor.
 *
 * Parameters:
 *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection
 *                  point must QueryInterface on this pointer to obtain
 *                  the proper interface to call.  The connection
 *                  point must also insure that any pointer held has
 *                  a reference count (QueryInterface will do it).
 *  pdwCookie       DWORD * in which to store the connection key for
 *                  later calls to Unadvise.
 */

CSmirNotifyCP :: CSmirNotifyCP(PCSmirConnObject pCO, REFIID riid, CSmir *pSmir):
						CSmirConnectionPoint(pCO,riid,pSmir), m_evtConsumer (NULL)
{
//	CSMIRClassFactory::objectsInProgress++;
	m_bRegistered = FALSE;
	m_evtConsumer = new CSmirWbemEventConsumer(pSmir);
	void* tmp = NULL;
	
	if (FAILED(m_evtConsumer->QueryInterface(IID_ISMIR_WbemEventConsumer, &tmp)))
	{
		delete m_evtConsumer;
		m_evtConsumer = NULL;
	}
}

CSmirNotifyCP :: ~CSmirNotifyCP()
{
	if (NULL != m_evtConsumer)
	{	
		m_evtConsumer->Release();
	}
//	CSMIRClassFactory::objectsInProgress--;
}

/*
 * CSmirConnObject::TriggerEvent
 *
 * Purpose:
 *  Functions to make each connection point generate calls
 *  to any connected sinks.  Since these functions are specific
 *  to IDuckEvents, they only deal with the connection point
 *  for that one interface
 *
 * Parameters:
 *  iEvent          UINT of the event to trigger, either
 *                  EVENT_QUACK, EVENT_FLAP, or EVENT_PADDLE.
 *
 * Return Value:
 *  BOOL            TRUE events are triggered, FALSE if there
 *                  are no connected sinks.
 */

BOOL CSmirNotifyCP::TriggerEvent()
{
    IEnumConnections   *pEnum = NULL ;
    CONNECTDATA         cd ;

	if (FAILED(EnumConnections(&pEnum)))
		return FALSE;

	while (NOERROR == pEnum->Next(1, &cd, NULL))
	{
		//a promise fulfilled - Andrew Sinclair just in case anyone thinks otherwise!
		ISMIRNotify *pJudith;

		if (SUCCEEDED(cd.pUnk->QueryInterface(IID_ISMIR_Notify, (PPVOID)&pJudith)))
		{
			pJudith->ChangeNotify();
			pJudith->Release();
		}

		cd.pUnk->Release();
	}

	pEnum->Release();

	return TRUE;
}

STDMETHODIMP CSmirNotifyCP::Advise(CSmir* pSmir, LPUNKNOWN pUnkSink
    , DWORD *pdwCookie)
{
	if (NULL == m_evtConsumer)
	{
		return WBEM_E_FAILED;
	}

	//if this is the first person to connect
	if(m_Connections.IsEmpty())
	{
		//register for WBEM Events for Smir Namespace changes
		if (SUCCEEDED(m_evtConsumer->Register(pSmir)))
		{
			m_bRegistered = TRUE;
		}
	}

	return CSmirConnectionPoint::Advise(pUnkSink, pdwCookie);
}

STDMETHODIMP CSmirNotifyCP::Unadvise(CSmir* pSmir, DWORD dwCookie)
{
	EnterCriticalSection ( & g_CriticalSection ) ;

	HRESULT hr = CSmirConnectionPoint::Unadvise(dwCookie);
	IWbemServices *t_pServ = NULL;

	if(S_OK== hr)
	{
		//if this is the last connection unregister for WBEM Events
		if(m_Connections.IsEmpty())
		{
			if (NULL == m_evtConsumer)
			{
				return WBEM_E_FAILED;
			}
			else if (m_bRegistered)
			{
				hr = m_evtConsumer->GetUnRegisterParams(&t_pServ);
			}
		}
	}

	LeaveCriticalSection ( & g_CriticalSection ) ;

	if (SUCCEEDED(hr) && (t_pServ != NULL))
	{
		hr = m_evtConsumer->UnRegister(pSmir, t_pServ);
		t_pServ->Release();
		t_pServ = NULL;

		//guarantees only one query at a time with the event consumer (sink)....
		EnterCriticalSection ( & g_CriticalSection ) ;
		m_bRegistered = FALSE;
		LeaveCriticalSection ( & g_CriticalSection ) ;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\bstring.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _BSTRING_H_
#define _BSTRING_H_

class CBString
{
private:
    BSTR    m_pString;


public:
    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
        }
        m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#endif // _BSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\classfac.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPSMIRClassFactory_H
#define _SNMPSMIRClassFactory_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for the interogative and administrative interfaces
class CSMIRGenericClassFactory : public IClassFactory
{
private:
	CCriticalSection	criticalSection ;
    long m_referenceCount ;
public:

    CSMIRGenericClassFactory (CLSID m_clsid) ;
    virtual ~CSMIRGenericClassFactory ( void ) ;

	//IUnknown members
	virtual STDMETHODIMP QueryInterface (IN  REFIID , OUT LPVOID FAR * )PURE;
    STDMETHODIMP_( ULONG ) AddRef (void);
    STDMETHODIMP_( ULONG ) Release (void) ;

	//IClassFactory members
    virtual STDMETHODIMP CreateInstance ( IN LPUNKNOWN , IN REFIID , OUT LPVOID FAR * )PURE;
    virtual STDMETHODIMP LockServer (IN BOOL )PURE;
};

class CSMIRClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG objectsInProgress ;
	static LONG locksInProgress ;
	BOOL		  bConstructed;

    CSMIRClassFactory (CLSID m_clsid);
    virtual ~CSMIRClassFactory ( void );

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID , OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( IN LPUNKNOWN , IN REFIID , OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};
/////////////////////////////////////////////////////////////////////////
// These classes are the class factories for the handle interfaces

class CModHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
   	static LONG objectsInProgress ;
	CModHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){} ;
    virtual ~CModHandleClassFactory ( void ){} ;

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};
class CClassHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
	static LONG objectsInProgress ;
    CClassHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CClassHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN  REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};
class CGroupHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
    static LONG objectsInProgress ;
	CGroupHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CGroupHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};



//****************************NotificationClass stuff*****************

class CNotificationClassHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
    static LONG objectsInProgress ;
	CNotificationClassHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CNotificationClassHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};


class CExtNotificationClassHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
    static LONG objectsInProgress ;
	CExtNotificationClassHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CExtNotificationClassHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};

#endif // _SNMPSMIRClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\csmirdef.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _CSMIRDEF_H_
#define _CSMIRDEF_H_

//missing #defs
#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

#ifndef DllImport
#define DllImport	__declspec( dllimport )
#endif
#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif

//forward declarations and typedefs

//main access classes
class CSmir;
class CSmirAdministrator;
class CSmirInterogator;


//enumerator classes
class CEnumSmirMod;
typedef CEnumSmirMod *PENUMSMIRMOD;
class CEnumSmirGroup;
typedef CEnumSmirGroup *PENUMSMIRGROUP;
class CEnumSmirClass;
typedef CEnumSmirClass * PENUMSMIRCLASS;
class CEnumNotificationClass;
typedef CEnumNotificationClass * PENUMNOTIFICATIONCLASS;
class CEnumExtNotificationClass;
typedef CEnumExtNotificationClass * PENUMEXTNOTIFICATIONCLASS;

//handle classes
class CSmirModuleHandle ;
typedef CSmirModuleHandle *HSMIRMODULE;
class CSmirGroupHandle ;
typedef CSmirGroupHandle *HSMIRGROUP;
class CSmirClassHandle;
typedef CSmirClassHandle *HSMIRCLASS;

class CSMIRClassFactory;
class CModHandleClassFactory;
class CGroupHandleClassFactory;
class CClassHandleClassFactory;
class CNotificationClassHandleClassFactory;
class CExtNotificationClassHandleClassFactory;

class CSmirConnObject;

//simple defines
//number of SMIR classes to register
#define NUMBER_OF_SMIR_INTERFACES			6

//connection point defines
#define SMIR_CHANGE_EVENT					1
#define SMIR_SIGNALED_CHANGE_EVENT			2

//wait between successive smir changes
#define SMIR_CHANGE_INTERVAL				10000 //in milliseconds

#define DEFAULT_SNMP_VERSION				1

//Event return values
#define SMIR_THREAD_DELETED					100
#define SMIR_THREAD_EXIT					(SMIR_THREAD_DELETED+1)


//WBEM_DEFINES
#define RESERVED_WBEM_FLAG							0

// WBEM constants

#define WBEM_CLASS_PROPAGATION WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\thread.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*
 * THREAD.CPP
 *
 * Implemenation of thread wrapper class.
 */
#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include "thread.h"
#include <textdef.h>
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

ThreadMap <CThread*, CThread*, CThread*,CThread*> CThread :: m_ThreadMap ;
CThread :: CThread()
{
	m_cRef=1;
	bWaiting=FALSE;
	m_ulThreadHandle = NULL;
	m_hThreadStopEvent= NULL;
	if(NULL == (m_hThreadStopEvent = CreateEvent(NULL, FALSE, 
								FALSE, NULL)))
	{
		// WBEM_E_FAILED;
	}

	if(NULL == (m_hThreadSyncEvent = CreateEvent(NULL, FALSE, 
								FALSE, NULL)))
	{
		// WBEM_E_FAILED;
	}
	m_ThreadMap.SetAt(this,this);	
}
CThread::operator void*()
{
	if((NULL != m_hThreadStopEvent) && (NULL != m_hThreadStopEvent))
	{
		//the thread has been created
    	return this;
	}
	else
	{
		//the thread is invalid
    	return (void*)NULL;
	}

}
ULONG CThread :: Release()
{
    if (0!=--m_cRef)
	{
        return m_cRef;
	}
    delete this;
    return 0;
}
CThread:: ~CThread()
{
	//clean-up
	if(m_hThreadStopEvent)
	{
		CloseHandle(m_hThreadStopEvent);
	}
	if(m_hThreadSyncEvent)
	{
		CloseHandle(m_hThreadSyncEvent);
	}
	m_ThreadMap.RemoveKey(this);
}
void __cdecl GenericThreadProc(void *arglist)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT hr = CoInitialize(NULL);

		if (SUCCEEDED(hr))
		{
			try
			{
				CThread *pThreadObject = (CThread*) arglist;
				if(S_OK == hr)
				{
					hr = pThreadObject->Process();
					if(SMIR_THREAD_DELETED != hr)
					{
						pThreadObject->Exit();
					}
					//else the thread has just been deleted
				}
			}
			catch(...)
			{
				CoUninitialize();
				throw;
			}

			CoUninitialize();
		}
	}
	catch(Structured_Exception e_SE)
	{
		return;
	}
	catch(Heap_Exception e_HE)
	{
		return;
	}
	catch(...)
	{
		return;
	}
}

#pragma warning (disable:4018)

SCODE CThread :: Wait(DWORD timeout)
{
	//create an array of wait events
	int iNumberOfEvents = m_UserEvents.GetCount()+1;
	HANDLE *lpHandles = new HANDLE[iNumberOfEvents];
	POSITION  rNextPosition;
    UINT      iLoop=0;
	for(rNextPosition=m_UserEvents.GetStartPosition();
		(NULL!=rNextPosition)&&(iLoop<iNumberOfEvents);iLoop++)
	{
		HANDLE	  lKey =  0;
		HANDLE pItem = NULL;
		m_UserEvents.GetNextAssoc(rNextPosition, lKey, pItem );
		lpHandles[iLoop] = pItem;
	}

	lpHandles[iNumberOfEvents-1] = m_hThreadStopEvent;

	//signal to the exit code that we are waiting
	bWaiting =TRUE;
	//wait for an event to fire
	DWORD dwResult = WaitForMultipleObjects(iNumberOfEvents,
												lpHandles, FALSE, timeout);
	bWaiting =FALSE;
	delete [] lpHandles;

	if(dwResult == iNumberOfEvents-1)
	{
		//thread stopped
		return WAIT_EVENT_TERMINATED;
	}
	else if (( ( dwResult<(iNumberOfEvents-1) ) ) ||
			 (dwResult == WAIT_TIMEOUT) )
	{
		//a user event fired
		return dwResult;
	}
	else if ((WAIT_ABANDONED_0 >= dwResult)&&(dwResult<(WAIT_ABANDONED_0+iNumberOfEvents)))
	{
		//it gave up
		return (WAIT_EVENT_ABANDONED+(dwResult-WAIT_ABANDONED_0)-1);
	}
	//else the wait call failed
	return WAIT_EVENT_FAILED;
}

#pragma warning (default:4018)

SCODE CThread :: Start()
{
	//kick of the thread
	if(NULL == (void*)*this)
	{
		//creation failed
		return WBEM_E_FAILED;
	}
	if(NULL != m_ulThreadHandle)
	{
		//already running
		return THREAD_STARED;
	}
	if(-1==(m_ulThreadHandle = _beginthread (&GenericThreadProc, 0,((void*) this))))
	{
		//begin thread failed
		return WBEM_E_FAILED;
	}

	return S_OK;
}
SCODE CThread :: Stop ()
{
	if(NULL==(void*)(*this)||(-1 == m_ulThreadHandle))
	{
		return WBEM_E_FAILED;
	}
	//terminate the thread if someone is waiting for it
	if(bWaiting)
	{
		SetEvent(m_hThreadStopEvent);
		WaitForSingleObject(m_hThreadSyncEvent,INFINITE);
	}
	//else just exit
	return S_OK;
}
void CThread :: ProcessDetach()
{
	POSITION  rNextPosition;
    UINT      iLoop=0;
	for(rNextPosition=m_ThreadMap.GetStartPosition();
		NULL!=rNextPosition;iLoop++)
	{
		CThread	  *plKey =  0;
		CThread *pItem = NULL;
		m_ThreadMap.GetNextAssoc(rNextPosition, plKey, pItem );
		pItem->Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\csmir.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _CSMIR_H_
#define _CSMIR_H_

class CSmir;
class CSmirConnObject;


#include "smir.h"
#include "csmirdef.h"
#include "thread.h"
#include "cthread.h"
#include "smirevt.h"

class CSmirWbemConfiguration ; 
class CSmirAdministrator;
class CGroupToClassAssociator;
class CModuleToClassAssociator;
class CXToClassAssociator;
class CSMIRToClassAssociator;
class CSmirNotificationClassHandle;
class CSmirExtNotificationClassHandle;

class CSmirSerialiseHandle : public ISmirSerialiseHandle
{
private:
	friend CSmirAdministrator;
	friend CSmirGroupHandle;
	friend CSmirModuleHandle;
	friend CSmirClassHandle;
	friend CSmirNotificationClassHandle;
	friend CSmirExtNotificationClassHandle;
	CString m_serialiseString;
	LONG	m_cRef;
	BOOL	m_bMOFPragmas;
	BOOL	m_bMOFAssociations;

public:
	//IUnknown members
    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	STDMETHODIMP GetText (OUT BSTR *);

	CSmirSerialiseHandle(BOOL bClassDefinitionsOnly);
	virtual ~CSmirSerialiseHandle(){}

private:
		//private copy constructors to prevent bcopy
		CSmirSerialiseHandle(CSmirSerialiseHandle&);
		const CSmirSerialiseHandle& operator=(CSmirSerialiseHandle &);
		BOOL ReturnMOFPragmas(){return m_bMOFPragmas;};
		BOOL ReturnMOFAssociations(){return m_bMOFAssociations;};
};

class CSmirInterrogator : public ISmirInterrogator
{
private:
	LONG	m_cRef;
	CSmir	*m_pSmir;
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
		CMutex				criticalSection(FALSE,SMIR_CSMIR_INTERROGATOR_MUTEX) ;
#else
		CCriticalSection	criticalSection ;
#endif
public:

	CSmirInterrogator () ;

	//IUnknown members
    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// interrogative interface
	STDMETHODIMP EnumModules (OUT IEnumModule **ppEnumSmirMod);
	STDMETHODIMP EnumGroups  (OUT IEnumGroup **ppEnumSmirGroup, IN ISmirModHandle *hModule);
	STDMETHODIMP EnumAllClasses (OUT IEnumClass **ppEnumSmirclass);
	STDMETHODIMP EnumClassesInGroup (OUT IEnumClass **ppEnumSmirclass, IN ISmirGroupHandle *hGroup);
	STDMETHODIMP EnumClassesInModule (OUT IEnumClass **ppEnumSmirclass, IN ISmirModHandle *hModule);
	STDMETHODIMP GetWBEMClass	 (OUT IWbemClassObject **pObj, IN BSTR pszClassName);

	STDMETHODIMP EnumAllNotificationClasses(IEnumNotificationClass **ppEnumSmirclass);
	STDMETHODIMP EnumAllExtNotificationClasses(IEnumExtNotificationClass **ppEnumSmirclass);
	STDMETHODIMP EnumNotificationClassesInModule(IEnumNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule);
	STDMETHODIMP EnumExtNotificationClassesInModule(IEnumExtNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule);

	CSmirInterrogator(CSmir *pSmir);
	virtual ~CSmirInterrogator(){}
private:
		//private copy constructors to prevent bcopy
		CSmirInterrogator(CSmirInterrogator&);
		const CSmirInterrogator& operator=(CSmirInterrogator &);
};

class CSmirAdministrator : public ISmirAdministrator
{
private:
	LONG	m_cRef;
	CSmir	*m_pSmir;
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
		CMutex				criticalSection(FALSE,SMIR_CSMIR_ADMINISTRATOR_MUTEX) ;
#else
		CCriticalSection	criticalSection ;
#endif
public:

	CSmirAdministrator () ;

	//IUnknown members
    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	STDMETHODIMP CreateWBEMClass(IN BSTR pszClassName, OUT ISmirClassHandle **pHandle); 
	STDMETHODIMP CreateWBEMNotificationClass ( IN BSTR pszClassName, OUT ISmirNotificationClassHandle **pHandle ) ;
	STDMETHODIMP CreateWBEMExtNotificationClass ( IN BSTR pszClassName, OUT ISmirExtNotificationClassHandle **pHandle ) ;

	//administrative  interface
	STDMETHODIMP AddModule(IN ISmirModHandle *hModule);
	STDMETHODIMP DeleteModule(IN ISmirModHandle *hModule);
	STDMETHODIMP DeleteAllModules();
	STDMETHODIMP AddGroup(IN ISmirModHandle *hModule, IN ISmirGroupHandle *hGroup);
	STDMETHODIMP DeleteGroup(ISmirGroupHandle *hGroup);
	STDMETHODIMP AddClass(IN ISmirGroupHandle *hGroup, IN ISmirClassHandle *hClass);
	STDMETHODIMP DeleteClass(IN ISmirClassHandle *hClass);

	STDMETHODIMP GetSerialiseHandle(ISmirSerialiseHandle **hSerialise, BOOL bClassDefinitionsOnly);
	STDMETHODIMP AddModuleToSerialise(ISmirModHandle *hModule,ISmirSerialiseHandle *hSerialise);
	STDMETHODIMP AddGroupToSerialise(ISmirModHandle *hModule, ISmirGroupHandle *hGroup,ISmirSerialiseHandle *hSerialise);
	STDMETHODIMP AddClassToSerialise(ISmirGroupHandle *hGroup, ISmirClassHandle  *hClass,ISmirSerialiseHandle *hSerialise);

	STDMETHODIMP AddNotificationClass(ISmirNotificationClassHandle *hClass);
	STDMETHODIMP AddExtNotificationClass(ISmirExtNotificationClassHandle *hClass);
	STDMETHODIMP DeleteNotificationClass(ISmirNotificationClassHandle *hClass); 
	STDMETHODIMP DeleteExtNotificationClass(ISmirExtNotificationClassHandle *hClass);
	STDMETHODIMP AddNotificationClassToSerialise(ISmirNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise);
	STDMETHODIMP AddExtNotificationClassToSerialise(ISmirExtNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise);


	CSmirAdministrator(CSmir *pSmir) ;
	virtual ~CSmirAdministrator(){}
private:
		//private copy constructors to prevent bcopy
		CSmirAdministrator(CSmirAdministrator&);
		const CSmirAdministrator& operator=(CSmirAdministrator &);
};

class CSmirWbemConfiguration : public ISMIRWbemConfiguration
{
private:

	LONG m_ReferenceCount ;

	CSmir *m_Smir ;	
	IWbemContext *m_Context ;
	IWbemServices *m_Service ;

protected:
public:

	CSmirWbemConfiguration ( CSmir *a_Smir ) ;
	~CSmirWbemConfiguration () ;

	//IUnknown methods
	//=================

	STDMETHODIMP			QueryInterface(IN REFIID riid,OUT PPVOID ppv);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

    STDMETHODIMP Authenticate (

		BSTR Server,
		BSTR User,
        BSTR Password,
        BSTR Locale,
        long lSecurityFlags,                 
        BSTR Authority ,
		BOOL InProc

	) ;

	STDMETHODIMP Impersonate ( ISMIRWbemConfiguration *a_Configuration ) ;

    STDMETHODIMP SetContext ( IWbemContext *a_Context ) ;

	STDMETHODIMP GetContext ( IWbemContext **a_Context ) ;
	STDMETHODIMP GetServices ( IWbemServices **a_Service ) ;
} ;

class CSmir : public ISmirDatabase
{
	private:
		friend CSmirInterrogator;
		friend CSmirAdministrator;
		friend CSmirConnObject;

#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
		CMutex				criticalSection(FALSE,SMIR_CSMIR_MUTEX) ;
#else
		CCriticalSection	criticalSection ;
#endif
		LONG				m_cRef;
		CSmirInterrogator   m_Interrogator;
		CSmirAdministrator  m_Administrator;
		CSmirWbemConfiguration m_Configuration ;

	public:
		static CSmirConnObject*		sm_ConnectionObjects;
		//IUnknown members
	    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();
		
		STDMETHODIMP	AddNotify(IN ISMIRNotify *hNotify, OUT DWORD *);
		STDMETHODIMP	DeleteNotify(IN DWORD);

		CSmir();
		virtual ~CSmir();
private:
		//private copy constructors to prevent bcopy
		CSmir(CSmir&);
		const CSmir& operator=(CSmir &);
};
//structure used to pass arguments to the async class enumerator function
typedef struct 
{
   CSmirConnObject *ConnectionObjects;
   ISmirModHandle *hModule;
   ISmirGroupHandle *hGroup;
   IConnectionPoint  *pCP;
   DWORD dwCookie;
} EnumClassAsyncArgStruct;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\enum.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _ENUM_H_
#define _ENUM_H_

/*InterfaceGarbageCollector makes it easier to use the  interface
 *by remembering to release them when you fall out of scope. The is 
 *useful when you are using an IMosProvider and have lots of points
 *of failure; you can just give up and let the wrapper clean up for 
 *you.
 */

template<class TYPE, class ARG_TYPE>
class EnumObjectArray : public CObject
{
private:

	BOOL threadSafe ;
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
	CMutex  *criticalSection ;
#else
	CCriticalSection  *criticalSection ;
#endif
	CArray <TYPE, ARG_TYPE> carray ;

protected:
public:

	EnumObjectArray ( BOOL threadSafe = FALSE ) ;
	virtual ~EnumObjectArray () ;

	int GetSize () const  ;
	int GetUpperBound() const ;

	void SetSize (int newSize, int nGrowBy=-1) ;

	//FreeExtra not implemented
	void RemoveAll () ;
	TYPE GetAt(int index) const;
	// Not implemented void SetAt(TYPE key, ARG_TYPE newValue) ;
	TYPE& ElementAt(int nIndex);
	//GetData not implemented
	//SetAtGrow not implemented
	int Add(ARG_TYPE newElement);
	//Append not implemented
	//Copy not implemented
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount=1);
	void RemoveAt(int nIndex,  int nCount= 1);
	TYPE& operator[](TYPE key) ;
} ;


template <class TYPE, class ARG_TYPE>
EnumObjectArray <TYPE, ARG_TYPE> :: EnumObjectArray ( BOOL threadSafeArg )
: threadSafe ( threadSafeArg ) , criticalSection ( NULL )
{
	if (threadSafeArg)
	{
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
	criticalSection = new CMutex(FALSE,SMIR_ENUMOBJECT_MUTEX);
#else
	criticalSection = new CCriticalSection;
#endif

	}
}

template<class TYPE, class ARG_TYPE>
EnumObjectArray <TYPE, ARG_TYPE> :: ~EnumObjectArray () 
{
	int iSize = GetSize();
	for(int iLoop=0; iLoop<iSize; iLoop++)
	{
		IUnknown *pTUnknown=(IUnknown *)GetAt(iLoop);
		if(NULL!=pTUnknown)
			pTUnknown->Release();
	}

	if (threadSafe)
	{
		delete criticalSection;
	}
}

template<class TYPE, class ARG_TYPE>
int EnumObjectArray <TYPE, ARG_TYPE> :: GetSize() const
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		int count = carray.GetSize () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.GetSize () ;
	}
}

template<class TYPE, class ARG_TYPE>
int EnumObjectArray <TYPE, ARG_TYPE> :: GetUpperBound() const
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		int count = carray.GetUpperBound () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.GetUpperBound () ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: SetSize(int newSize, int nGrowBy) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.SetSize (newSize, nGrowBy) ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.SetSize (newSize, nGrowBy) ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: RemoveAll()
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.RemoveAll () ;
	}
}


template<class TYPE, class ARG_TYPE>
TYPE EnumObjectArray <TYPE, ARG_TYPE> :: GetAt(int nIndex) const
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		TYPE count = carray.GetAt (nIndex) ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.GetAt(nIndex)  ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& EnumObjectArray <TYPE, ARG_TYPE> :: ElementAt(int nIndex) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		TYPE *count = carray.ElementAt (nIndex) ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.ElementAt(nIndex)  ;
	}
}

template<class TYPE, class ARG_TYPE>
int EnumObjectArray <TYPE, ARG_TYPE> :: Add(ARG_TYPE newElement) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		int nIndex = carray.Add (newElement) ;
		criticalSection->Unlock () ;
		return nIndex ;
	}
	else
	{
		return carray.Add(newElement)  ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: InsertAt(int nIndex, ARG_TYPE newElement, int nCount) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.InsertAt (nIndex, newElement,  nCount) ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.InsertAt( nIndex, newElement, nCount)  ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: RemoveAt(int nIndex, int nCount) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.RemoveAt (nIndex, nCount) ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.RemoveAt( nIndex, nCount)  ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& EnumObjectArray <TYPE,ARG_TYPE> :: operator[](TYPE key)
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		VALUE &value = carray.operator [] ( key ) ;
		criticalSection->Unlock () ;
		return value ;
	}
	else
	{
		return carray.operator [] ( key ) ;
	}
}

class CEnumSmirMod : public IEnumModule
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirModHandle *, ISmirModHandle *> m_IHandleArray;

public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirModHandle **phModule,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumModule  **ppenum);

		CEnumSmirMod( CSmir *a_Smir );
		CEnumSmirMod(IN IEnumModule *pSmirMod);
		virtual ~CEnumSmirMod();

private:

		//private copy constructors to prevent bcopy
		CEnumSmirMod(CEnumSmirMod&);
		const CEnumSmirMod& operator=(CEnumSmirMod &);
};

class CEnumSmirGroup : public IEnumGroup
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirGroupHandle *, ISmirGroupHandle *> m_IHandleArray;

public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirGroupHandle **phModule,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumGroup  **ppenum);

		CEnumSmirGroup( IN CSmir *a_Smir , IN ISmirModHandle *hModule=NULL);
		CEnumSmirGroup(IN IEnumGroup *pSmirGroup);
		virtual ~CEnumSmirGroup();

private:

		//private copy constructors to prevent bcopy
		CEnumSmirGroup(CEnumSmirGroup&);
		const CEnumSmirGroup& operator=(CEnumSmirGroup &);

};

class CEnumSmirClass : public IEnumClass
{
protected:

		//reference count

		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirClassHandle *, ISmirClassHandle *> m_IHandleArray;
public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirClassHandle **phModule,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumClass  **ppenum);

		CEnumSmirClass ( CSmir *a_Smir , IN ISmirDatabase *pSmir = NULL , DWORD dwCookie = 0 ) ;
		CEnumSmirClass ( CSmir *a_Smir , IN ISmirDatabase *pSmir , IN ISmirGroupHandle *hGroup , DWORD dwCookie = 0 ) ;
		CEnumSmirClass ( CSmir *a_Smir , IN ISmirDatabase *pSmir , IN ISmirModHandle *hModule , DWORD dwCookie = 0 ) ;
		CEnumSmirClass ( IN IEnumClass *pSmirClass ) ;
		virtual ~CEnumSmirClass(){};

private:

		//private copy constructors to prevent bcopy
		CEnumSmirClass(CEnumSmirClass&);
		const CEnumSmirClass& operator=(CEnumSmirClass &);
};


class CEnumNotificationClass : public IEnumNotificationClass
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirNotificationClassHandle *, ISmirNotificationClassHandle *> m_IHandleArray;

public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirNotificationClassHandle **phClass,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumNotificationClass  **ppenum);

		CEnumNotificationClass ( IN CSmir *a_Smir , IN ISmirDatabase *pSmir=NULL, DWORD dwCookie=0);
		CEnumNotificationClass ( IN CSmir *a_Smir , IN ISmirDatabase *pSmir, IN ISmirModHandle *hModule, DWORD dwCookie=0);
		CEnumNotificationClass ( IN IEnumNotificationClass *pSmirClass);
		virtual ~CEnumNotificationClass(){};

private:

		//private copy constructors to prevent bcopy
		CEnumNotificationClass(CEnumNotificationClass&);
		const CEnumNotificationClass& operator=(CEnumNotificationClass &);
};

class CEnumExtNotificationClass : public IEnumExtNotificationClass
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirExtNotificationClassHandle *, ISmirExtNotificationClassHandle *> m_IHandleArray;

public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirExtNotificationClassHandle **phClass,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumExtNotificationClass  **ppenum);

		CEnumExtNotificationClass( IN CSmir *a_Smir , IN ISmirDatabase *pSmir=NULL, DWORD dwCookie=0);
		CEnumExtNotificationClass( IN CSmir *a_Smir , IN ISmirDatabase *pSmir, IN ISmirModHandle *hModule, DWORD dwCookie=0);
		CEnumExtNotificationClass( IN IEnumExtNotificationClass *pSmirClass);
		virtual ~CEnumExtNotificationClass(){};

private:

		//private copy constructors to prevent bcopy
		CEnumExtNotificationClass(CEnumExtNotificationClass&);
		const CEnumExtNotificationClass& operator=(CEnumExtNotificationClass &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\evtcons.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _EVTCONS_H_
#define _EVTCONS_H_

#define SMIR_EVT_COUNT	2
#define SMIR_CHANGE_EVT 0
#define SMIR_THREAD_EVT	1

class CSmirWbemEventConsumer : public ISMIRWbemEventConsumer
{
private:

	LONG			m_cRef;
	HANDLE			*m_hEvents;
	CNotifyThread	*m_callbackThread;
	IWbemServices	*m_Serv;

	//private copy constructors to prevent bcopy
	CSmirWbemEventConsumer(CSmirWbemEventConsumer&);
	const CSmirWbemEventConsumer& operator=(CSmirWbemEventConsumer &);


public:

	//Implementation
	//===============

		CSmirWbemEventConsumer(CSmir* psmir);

	HRESULT	Register(CSmir* psmir);
	HRESULT	UnRegister(CSmir* psmir, IWbemServices* pServ);
	HRESULT GetUnRegisterParams(IWbemServices** ppServ);

		~CSmirWbemEventConsumer();


	//IUnknown methods
	//=================

	STDMETHODIMP			QueryInterface(IN REFIID riid,OUT PPVOID ppv);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();
   

	//IWbemObjectSink methods
	//=======================

	STDMETHODIMP_(HRESULT)	Indicate(	IN long lObjectCount,
										IN IWbemClassObject **ppObjArray
										);

	STDMETHODIMP_(HRESULT)	SetStatus(	IN long lFlags,
										IN long lParam,
										IN BSTR strParam,
										IN IWbemClassObject *pObjParam
										);
};


#endif //_EVTCONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\handles.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _HANDLES_H_
#define _HANDLES_H_
class CSmirModuleHandle : public ISmirModHandle
{
	private:
		friend CSmirAdministrator;
		friend CEnumSmirMod;
		friend CModHandleClassFactory;


		//reference count
		LONG		m_cRef;

		//member variables
		BSTR		m_szModuleOid;
		BSTR		m_szName;
		BSTR		m_szModuleId;
		BSTR		m_szOrganisation;
		BSTR		m_szContactInfo;
		BSTR		m_szDescription;
		BSTR		m_szRevision;
		BSTR		m_szModImports;
		ULONG		m_lSnmp_version;
		BSTR		m_szLastUpdate;

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE) GetName(OUT BSTR *pszName);
		STDMETHODIMP_(SCODE) GetModuleOID(OUT BSTR *pszModuleOid);
		STDMETHODIMP_(SCODE) GetModuleIdentity(OUT BSTR *pszModuleId);
		STDMETHODIMP_(SCODE) GetLastUpdate(OUT BSTR *plLastUpdate);
		STDMETHODIMP_(SCODE) GetOrganisation(OUT BSTR *pszOrganisation);
		STDMETHODIMP_(SCODE) GetContactInfo(OUT BSTR *pszContactInfo);
		STDMETHODIMP_(SCODE) GetDescription(OUT BSTR *pszDescription);
		STDMETHODIMP_(SCODE) GetRevision(OUT BSTR *pszRevision);
		STDMETHODIMP_(SCODE) GetSnmpVersion(OUT ULONG *plSnmp_version);
		STDMETHODIMP_(SCODE) GetModuleImports (BSTR*);

		STDMETHODIMP_(SCODE) SetName(IN BSTR pszName);
		STDMETHODIMP_(SCODE) SetModuleOID(IN BSTR pszModuleOid);
		STDMETHODIMP_(SCODE) SetModuleIdentity(OUT BSTR pszModuleId);
		STDMETHODIMP_(SCODE) SetLastUpdate(IN BSTR plLastUpdate);
		STDMETHODIMP_(SCODE) SetOrganisation(IN BSTR pszOrganisation);
		STDMETHODIMP_(SCODE) SetContactInfo(IN BSTR pszContactInfo);
		STDMETHODIMP_(SCODE) SetDescription(IN BSTR pszDescription);
		STDMETHODIMP_(SCODE) SetRevision(IN BSTR pszRevision);
		STDMETHODIMP_(SCODE) SetSnmpVersion(IN ULONG plSnmp_version);
		STDMETHODIMP_(SCODE) SetModuleImports (IN BSTR);

		//Class members
		CSmirModuleHandle();
		virtual ~ CSmirModuleHandle();
		const CSmirModuleHandle& operator>>(IWbemClassObject *pInst);
		const CSmirModuleHandle& operator<<(IWbemClassObject *pInst);
		const CSmirModuleHandle& operator>>(ISmirSerialiseHandle *pInst);
		HRESULT PutClassProperties (IWbemClassObject *pClass) ;
		operator void*();
		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir );
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );
	private:
		//private copy constructors to prevent bcopy
		CSmirModuleHandle(CSmirModuleHandle&);
		const CSmirModuleHandle& operator=(CSmirModuleHandle &);
};
class CSmirGroupHandle : public ISmirGroupHandle
{
	private:
		friend  CSmirAdministrator;
		friend  CEnumSmirGroup;
		friend  CGroupHandleClassFactory;
		
		//reference count
		LONG	m_cRef;

		BSTR	m_szModuleName;
		BSTR	m_szName;
		BSTR	m_szGroupId;
		BSTR	m_szDescription;
		BSTR	m_szReference;
		BSTR	m_szStatus;	

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE)  GetModuleName(OUT BSTR *pszName);
		STDMETHODIMP_ (SCODE) GetName(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetGroupOID(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetStatus(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetDescription(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetReference(OUT BSTR *);

		STDMETHODIMP_(SCODE)  SetModuleName(IN BSTR pszName);
		STDMETHODIMP_ (SCODE) SetName(IN BSTR );
		STDMETHODIMP_ (SCODE) SetGroupOID(IN BSTR );
		STDMETHODIMP_ (SCODE) SetStatus(IN BSTR );
		STDMETHODIMP_ (SCODE) SetDescription(IN BSTR );
		STDMETHODIMP_ (SCODE) SetReference(IN BSTR );

		//Class members
		const CSmirGroupHandle& operator>>(IWbemClassObject *pInst);
		const CSmirGroupHandle& operator<<(IWbemClassObject *pInst);
		const CSmirGroupHandle& operator>>(ISmirSerialiseHandle *pInst);
		HRESULT PutClassProperties (IWbemClassObject *pClass) ;
		operator void* ();
		CSmirGroupHandle();
		virtual ~ CSmirGroupHandle();
		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir , ISmirModHandle *hModule);
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );
	private:
		//private copy constructors to prevent bcopy
		CSmirGroupHandle(CSmirGroupHandle&);
		const CSmirGroupHandle& operator=(CSmirGroupHandle &);
};

class CSmirClassHandle : public ISmirClassHandle
{
	private:
		friend  CSmirAdministrator;
		friend  CEnumSmirClass;
		friend  CClassHandleClassFactory;
		friend  CModuleToClassAssociator;
		friend  CGroupToClassAssociator;
		friend  CSMIRToClassAssociator;

		//reference count
		LONG	m_cRef;
		IWbemClassObject *m_pIMosClass;
		BSTR	 m_szModuleName;
		BSTR	 m_szGroupName;

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE) GetModuleName(OUT BSTR *pszName);
		STDMETHODIMP_(SCODE) GetGroupName(OUT BSTR *pszName);
		STDMETHODIMP_(SCODE) SetModuleName(OUT BSTR pszName);
		STDMETHODIMP_(SCODE) SetGroupName(OUT BSTR pszName);
		STDMETHODIMP_(SCODE) GetWBEMClass(OUT IWbemClassObject **pObj);
		STDMETHODIMP_(SCODE) SetWBEMClass(IN IWbemClassObject *pObj);

		//Class members
		const CSmirClassHandle& operator>>(ISmirSerialiseHandle *pInst);
		operator void* ();

		CSmirClassHandle();
		virtual ~ CSmirClassHandle();

		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir , ISmirGroupHandle *hGroup);
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );
		STDMETHODIMP_(SCODE)  DeleteClassFromGroup( CSmir *a_Smir );
	private:
		//private copy constructors to prevent bcopy
		CSmirClassHandle(CSmirClassHandle&);
		const CSmirClassHandle& operator=(CSmirClassHandle &);
};

class CModuleToNotificationClassAssociator;
class CModuleToExtNotificationClassAssociator;

class CSmirNotificationClassHandle : public ISmirNotificationClassHandle
{
	private:
		friend  CSmirAdministrator;
		//friend  CEnumNotificationClass;
		friend  CNotificationClassHandleClassFactory;
		friend  CModuleToNotificationClassAssociator;

		//reference count
		LONG	m_cRef;
		IWbemClassObject *m_pIMosClass;
		BSTR	 m_szModuleName;

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();
		STDMETHODIMP_(SCODE) SetModule(THIS_ BSTR);
		STDMETHODIMP_(SCODE) GetModule(THIS_ BSTR*);

		STDMETHODIMP_(SCODE) GetWBEMNotificationClass (THIS_ OUT IWbemClassObject **pObj	);
		STDMETHODIMP_(SCODE) SetWBEMNotificationClass(THIS_ IWbemClassObject *pObj);

		//Class members
		const CSmirNotificationClassHandle& operator>>(ISmirSerialiseHandle *pInst);
		operator void* ();

		CSmirNotificationClassHandle();
		virtual ~CSmirNotificationClassHandle();

		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir );
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );

	private:
		//private copy constructors to prevent bcopy
		CSmirNotificationClassHandle(CSmirNotificationClassHandle&);
		const CSmirNotificationClassHandle& operator=(CSmirNotificationClassHandle &);
}; 


class CSmirExtNotificationClassHandle : public ISmirExtNotificationClassHandle
{
	private:
		friend  CSmirAdministrator;
		//friend  CEnumExtNotificationClass;
		friend  CExtNotificationClassHandleClassFactory;
		friend  CModuleToExtNotificationClassAssociator;

		//reference count
		LONG	m_cRef;
		IWbemClassObject *m_pIMosClass;
		BSTR	 m_szModuleName;

	public:
	//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE) SetModule(THIS_ BSTR);
		STDMETHODIMP_(SCODE) GetModule(THIS_ BSTR*);

		STDMETHODIMP_(SCODE) GetWBEMExtNotificationClass(OUT IWbemClassObject **pObj);
		STDMETHODIMP_(SCODE) SetWBEMExtNotificationClass(THIS_ IWbemClassObject *pObj);

		//Class members
		const CSmirExtNotificationClassHandle& operator>>(ISmirSerialiseHandle *pInst);
		operator void* ();

		CSmirExtNotificationClassHandle();
		virtual ~CSmirExtNotificationClassHandle();

		STDMETHODIMP_(SCODE) AddToDB ( CSmir *a_Smir );
		STDMETHODIMP_(SCODE) DeleteFromDB ( CSmir *a_Smir );

	private:
		//private copy constructors to prevent bcopy
		CSmirExtNotificationClassHandle(CSmirExtNotificationClassHandle&);
		const CSmirExtNotificationClassHandle& operator=(CSmirExtNotificationClassHandle &);

}; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\smir.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SMIR_H_
#define _SMIR_H_

struct ISmirInterrogator ;
struct ISmirAdministrator ;

/***************************** handles *************************************/
// {5009ab90-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_ModHandle, 
0x5009ab90, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

// {5009ab91-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ModHandle, 
0x5009ab91, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISmirModHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, GetName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetModuleOID)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetModuleIdentity)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetLastUpdate)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetOrganisation)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetContactInfo)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetDescription)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetRevision)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetSnmpVersion)(THIS_ ULONG *)PURE;
	STDMETHOD_(SCODE, GetModuleImports)(THIS_ BSTR*)PURE;

	STDMETHOD_(SCODE, SetName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetModuleOID)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetModuleIdentity)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetLastUpdate)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetOrganisation)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetContactInfo)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetDescription)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetRevision)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetSnmpVersion)(THIS_ ULONG)PURE;
	STDMETHOD_(SCODE, SetModuleImports)(THIS_ BSTR)PURE;

};

// {5009ab92-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_GroupHandle, 
0x5009ab92, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

// {5009ab93-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_GroupHandle, 
0x5009ab93, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
DECLARE_INTERFACE_(ISmirGroupHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//STDMETHOD_(HSMIRMODULE) GetParentHandle();
	STDMETHOD_(SCODE, GetModuleName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetGroupOID)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetStatus)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetDescription)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetReference)(THIS_ BSTR *)PURE;

	STDMETHOD_(SCODE, SetModuleName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetGroupOID)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetStatus)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetDescription)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetReference)(THIS_ BSTR)PURE;
};

enum NotificationMapperType
{
	SNMP_NOTIFICATION_CLASS = 0,
	SNMP_EXT_NOTIFICATION_CLASS
};

enum SmirBaseClass
{
	SMIR_OBJECTTYPE_OBJECT ,
	SMIR_NOTIFICATIONTYPE_OBJECT
} ;
 
// {5009ab94-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_ClassHandle, 
0x5009ab94, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

// {5009ab95-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ClassHandle, 
0x5009ab50, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
DECLARE_INTERFACE_(ISmirClassHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, GetModuleName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetGroupName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetWBEMClass)(IWbemClassObject **pObj)PURE;
	STDMETHOD_(SCODE, SetModuleName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetGroupName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetWBEMClass)(THIS_ IWbemClassObject *pObj)PURE;
};

/**********************  Notification classes  ***************************/

// {b11b26ac-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(CLSID_SMIR_NotificationClassHandle,
0xb11b26ac, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

// {b11b26ad-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_NotificationClassHandle,
0xb11b26ad, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(ISmirNotificationClassHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID*)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, SetModule)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, GetModule)(THIS_ BSTR*)PURE;
	STDMETHOD_(SCODE, GetWBEMNotificationClass)(IWbemClassObject **pObj)PURE;
	STDMETHOD_(SCODE, SetWBEMNotificationClass)(THIS_ IWbemClassObject *pObj)PURE;
};


// {b11b26ae-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(CLSID_SMIR_ExtNotificationClassHandle,
0xb11b26ae, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

// {b11b26af-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_ExtNotificationClassHandle,
0xb11b26af, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(ISmirExtNotificationClassHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID*)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, SetModule)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, GetModule)(THIS_ BSTR*)PURE;
	STDMETHOD_(SCODE, GetWBEMExtNotificationClass)(IWbemClassObject **pObj)PURE;
	STDMETHOD_(SCODE, SetWBEMExtNotificationClass)(THIS_ IWbemClassObject *pObj)PURE;
}; 

/**********************  Enumerator interfaces  **************************/

// {5009ab96-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ModuleEnumerator, 
0x5009ab96, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(IEnumModule,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//enum interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirModHandle **phClass, ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumModule  **ppenum)PURE;
};
// {5009ab97-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_GroupEnumerator, 
0x5009ab97, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(IEnumGroup,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//enum interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirGroupHandle **phClass, ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumGroup  **ppenum)PURE;
};
// {5009ab98-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ClassEnumerator, 
0x5009ab98, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(IEnumClass,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//enum interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirClassHandle **phClass, ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumClass  **ppenum)PURE;
};

/************************* Notification class enumerators *****************/

// {b11b26b0-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_EnumNotificationClass,
0xb11b26b0, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(IEnumNotificationClass, IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG, AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG, Release)(THIS_)PURE;

	// Enumerator interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirNotificationClassHandle **phClass,
					ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumNotificationClass **ppenum)PURE;
}; 


// {b11b26b1-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_EnumExtNotificationClass,
0xb11b26b1, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(IEnumExtNotificationClass, IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG, AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG, Release)(THIS_)PURE;

	// Enumerator interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirExtNotificationClassHandle **phClass,
					ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumExtNotificationClass **ppenum)PURE;
}; 

// {5009ab9e-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_Notify, 
0x5009ab9e, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISMIRNotify, IUnknown)
{

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    //ISMIRNotify members
    STDMETHOD(ChangeNotify)(THIS) PURE;
};

/************************  SMIR database class  *****************************/
// {5009ab9b-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_Database, 
0x5009ab9b, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

/************************  SMIR interfaces  *****************************/
DEFINE_GUID(IID_ISMIR_Database, 
0x5009ab9b, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISmirDatabase,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, AddNotify)(THIS_ ISMIRNotify *hNotify, DWORD *)PURE;
	STDMETHOD_(SCODE, DeleteNotify)(THIS_ DWORD)PURE;
};

// {5009ab9c-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_Interrogative, 
0x5009ab9c, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
 
DECLARE_INTERFACE_(ISmirInterrogator,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	// interrogative interface
	STDMETHOD_(SCODE, EnumModules) (THIS_ IEnumModule **ppEnumSmirMod) PURE;
	STDMETHOD_(SCODE, EnumGroups)  (THIS_ IEnumGroup **ppEnumSmirGroup, ISmirModHandle *hMudule) PURE;
	STDMETHOD_(SCODE, EnumAllClasses) (THIS_ IEnumClass **ppEnumSmirclass) PURE;
	STDMETHOD_(SCODE, EnumClassesInGroup) (THIS_ IEnumClass **ppEnumSmirclass, ISmirGroupHandle *hGroup) PURE;
	STDMETHOD_(SCODE, EnumClassesInModule) (THIS_ IEnumClass **ppEnumSmirclass, ISmirModHandle *hModule) PURE;
	STDMETHOD_(SCODE, GetWBEMClass)	   (THIS_ OUT IWbemClassObject **pObj, IN BSTR pszClassName)PURE;

	STDMETHOD_(SCODE, EnumAllNotificationClasses)(THIS_ IEnumNotificationClass **ppEnumSmirclass) PURE;
	STDMETHOD_(SCODE, EnumAllExtNotificationClasses)(THIS_ IEnumExtNotificationClass **ppEnumSmirclass) PURE;
	STDMETHOD_(SCODE, EnumNotificationClassesInModule)(THIS_ IEnumNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule) PURE;
	STDMETHOD_(SCODE, EnumExtNotificationClassesInModule)(THIS_ IEnumExtNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule) PURE;
};

// {5009ab9e-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_SerialiseHandle, 
0x5009ab9e, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
DECLARE_INTERFACE_(ISmirSerialiseHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, GetText)(THIS_ BSTR *)PURE;
};

// {5009ab9d-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_Administrative, 
0x5009ab9d, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISmirAdministrator,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, CreateWBEMClass)(THIS_ BSTR pszClassName, ISmirClassHandle **pHandle)PURE;
	STDMETHOD_(SCODE, CreateWBEMNotificationClass)(THIS_ BSTR pszClassName, ISmirNotificationClassHandle **pHandle)PURE;
	STDMETHOD_(SCODE, CreateWBEMExtNotificationClass)(THIS_ BSTR pszClassName, ISmirExtNotificationClassHandle **pHandle)PURE;

	STDMETHOD_(SCODE, AddModule)(THIS_ ISmirModHandle *hModule)PURE;
	STDMETHOD_(SCODE, DeleteModule)(THIS_ ISmirModHandle *hModule)PURE;
	STDMETHOD_(SCODE, DeleteAllModules)(THIS_)PURE;
	STDMETHOD_(SCODE, AddGroup)(THIS_ ISmirModHandle *hModule, ISmirGroupHandle *hGroup)PURE;
	STDMETHOD_(SCODE, DeleteGroup)(THIS_ ISmirGroupHandle *hGroup)PURE;
	STDMETHOD_(SCODE, AddClass)(THIS_ ISmirGroupHandle *hGroup, ISmirClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, DeleteClass)(THIS_ ISmirClassHandle *hClass)PURE;

	STDMETHOD_(SCODE, GetSerialiseHandle)(THIS_ ISmirSerialiseHandle **hSerialise, BOOL bClassDefinitionsOnly)PURE;
	STDMETHOD_(SCODE, AddModuleToSerialise)(THIS_ ISmirModHandle *hModule,ISmirSerialiseHandle *hSerialise)PURE;
	STDMETHOD_(SCODE, AddGroupToSerialise)(THIS_ ISmirModHandle *hModule, ISmirGroupHandle *hGroup,ISmirSerialiseHandle *hSerialise)PURE;
	STDMETHOD_(SCODE, AddClassToSerialise)(THIS_ ISmirGroupHandle *hGroup, ISmirClassHandle *hClass,ISmirSerialiseHandle *hSerialise)PURE;

	STDMETHOD_(SCODE, AddNotificationClass)(THIS_ ISmirNotificationClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, AddExtNotificationClass)(THIS_ ISmirExtNotificationClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, DeleteNotificationClass)(THIS_ ISmirNotificationClassHandle *hClass)PURE; 
	STDMETHOD_(SCODE, DeleteExtNotificationClass)(THIS_ ISmirExtNotificationClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, AddNotificationClassToSerialise)(THIS_ ISmirNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)PURE;
	STDMETHOD_(SCODE, AddExtNotificationClassToSerialise)(THIS_ ISmirExtNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)PURE;
};
/***************************** handles *************************************/

// {83D18EC0-F167-11d0-AB13-0000F81E8E2C}
DEFINE_GUID(IID_ISMIR_WbemEventConsumer, 
0x83d18ec0, 0xf167, 0x11d0, 0xab, 0x13, 0x0, 0x0, 0xf8, 0x1e, 0x8e, 0x2c);

//supports IID_ISMIR_WbemEventConsumer, IID_IWbemObjectSink and IID_IUnknown
DECLARE_INTERFACE_(ISMIRWbemEventConsumer, IWbemObjectSink)
{
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* IMosNotify methods */
    STDMETHOD_(HRESULT, Indicate)(THIS_ long lObjectCount, IWbemClassObject **ppObjArray) PURE;
    STDMETHOD_(HRESULT, SetStatus)(THIS_ long lFlags, long lParam, BSTR strParam, IWbemClassObject *pObjParam) PURE;
};

// {63BA5C10-5A47-11d1-931B-00AA00A4086C}
DEFINE_GUID(IID_ISMIRWbemConfiguration, 
0x63ba5c10, 0x5a47, 0x11d1, 0x93, 0x1b, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

DECLARE_INTERFACE_(ISMIRWbemConfiguration, IUnknown)
{
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD_(HRESULT, Authenticate)(THIS_ 

		BSTR Server,
		BSTR User,
        BSTR Password,
        BSTR Locale,
        long lSecurityFlags,                 
        BSTR Authority ,
		BOOL InProc

	) PURE;

	STDMETHOD_(HRESULT, Impersonate)(THIS_ ISMIRWbemConfiguration *a_Configuration) PURE;

    STDMETHOD_(HRESULT, SetContext)(THIS_ IWbemContext *a_Context ) PURE;
    STDMETHOD_(HRESULT, GetContext)(THIS_ IWbemContext **a_Context ) PURE;
	STDMETHOD_(HRESULT, GetServices)(THIS_ IWbemServices **a_Services ) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\cthread.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

class CNotifyThread : public CThread
{
	private:
		HANDLE	 m_doneEvt;
	public:
		CNotifyThread(HANDLE* evtsarray, ULONG arraylen);
		virtual ~CNotifyThread();
		SCODE Process();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\helper.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _HELPER_H_
#define _HELPER_H_

/*helper classes
*/

class SmirClassFactoryHelper;
extern SmirClassFactoryHelper *g_pClassFactoryHelper;

HRESULT CopyBSTR(BSTR *pDst, BSTR *pSrc);
void FormatProviderErrorMsg(char*,int,HRESULT);

class CNotificationMapper
{
public:

	CNotificationMapper(){}
	~CNotificationMapper(){}
	static STDMETHODIMP Map(CSmir *a_Smir,IWbemClassObject *pObj, enum NotificationMapperType type);

private:
		//private copy constructors to prevent bcopy
		CNotificationMapper(CNotificationMapper&);
		const CNotificationMapper& operator=(CNotificationMapper &);
};

class CXToClassAssociator
{
public:

	CXToClassAssociator(){}
	~CXToClassAssociator(){}

private:

		//private copy constructors to prevent bcopy
		CXToClassAssociator(CXToClassAssociator&);
		const CXToClassAssociator& operator=(CXToClassAssociator &);
};

class CGroupToClassAssociator : public CXToClassAssociator
{
public:

	CGroupToClassAssociator(){}
	~CGroupToClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, BSTR szGroup, ISmirClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CGroupToClassAssociator(CXToClassAssociator&);
	const CGroupToClassAssociator& operator=(CGroupToClassAssociator &);
};

class CModuleToClassAssociator : public CXToClassAssociator
{
public:

	CModuleToClassAssociator(){}
	~CModuleToClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, ISmirClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CModuleToClassAssociator(CXToClassAssociator&);
	const CModuleToClassAssociator& operator=(CModuleToClassAssociator &);
};

class CModuleToNotificationClassAssociator : public CXToClassAssociator
{
public:

	CModuleToNotificationClassAssociator(){}
	~CModuleToNotificationClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, ISmirNotificationClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CModuleToNotificationClassAssociator(CXToClassAssociator&);
	const CModuleToNotificationClassAssociator& operator=(CModuleToNotificationClassAssociator &);
};

class CModuleToExtNotificationClassAssociator : public CXToClassAssociator
{
public:

	CModuleToExtNotificationClassAssociator(){}
	~CModuleToExtNotificationClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, ISmirExtNotificationClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CModuleToExtNotificationClassAssociator(CXToClassAssociator&);
	const CModuleToExtNotificationClassAssociator& operator=(CModuleToExtNotificationClassAssociator &);
};

class CSMIRToClassAssociator : public CXToClassAssociator
{
public:

	CSMIRToClassAssociator(){}
	~CSMIRToClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,ISmirClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CSMIRToClassAssociator(CSMIRToClassAssociator&);
	const CSMIRToClassAssociator& operator=(CSMIRToClassAssociator &);
};

class CSmirAccess
{
private:

	static STDMETHODIMP Connect (

		CSmir *a_Smir , 
		OUT IWbemServices **server, 
		IN BSTR ObjectPath, 
		IN BOOL relativeToSMIR
	);

public:

	enum eOpenType {

		eModule=1,
		eGroup
	};

	//undefined constructor and destructor
	//so object should never be instantiated

	CSmirAccess();
	virtual ~CSmirAccess();
	
	static STDMETHODIMP Init();
	static void ShutDown();

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		BSTR ObjectPath=NULL, 
		BOOL relativeToSMIR = FALSE
	);

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		ISmirClassHandle *hClass,
		eOpenType eType=eGroup
	);

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		ISmirGroupHandle *hGroup,
		eOpenType eType=eGroup
	);

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		ISmirModHandle *hMod
	);

	static STDMETHODIMP GetContext (

		CSmir *a_Smir , 
		IWbemContext **a_Context
	) ;
};

class SmirClassFactoryHelper
{
private:

		CGroupHandleClassFactory *pGroupHandleClassFactory;
		CClassHandleClassFactory *pClassHandleClassFactory;
		CNotificationClassHandleClassFactory *pNotificationClassHandleClassFactory;
		CExtNotificationClassHandleClassFactory *pExtNotificationClassHandleClassFactory;
		CModHandleClassFactory   *pModHandleClassFactory;
		CSMIRClassFactory		 *pSMIRClassFactory;

public:

		SmirClassFactoryHelper();
		virtual ~SmirClassFactoryHelper();
		HRESULT CreateInstance(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\smirevt.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SMIREVT_H_
#define _SMIREVT_H_

//Number of connection points 
#define SMIR_NUMBER_OF_CONNECTION_POINTS		1
#define SMIR_NOTIFY_CONNECTION_POINT			0

class	CSmirConnectionPoint;
class	CSmirWbemEventConsumer;
class	CSmirConnObject;
typedef CSmirConnObject *PCSmirConnObject;

class	CEnumConnections;
typedef CEnumConnections *PCEnumConnections;

class	CEnumConnectionPoints;
typedef CEnumConnectionPoints *PCEnumConnectionPoints;

/*
 * Each connection is saved so that we can enumerate, delete, and trigger
 * This template provides the container for the connections and cookies
 */

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class ConnectionMap : public CObject
{
private:

	BOOL m_bThreadSafe ;
#ifdef NOT_IMPLEMENTED_AS_CLSCTX_INPROC_SERVER
	CMutex * m_criticalLock ;
#else
	CCriticalSection * m_criticalLock ;
#endif
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> m_cmap ;

protected:
public:

	ConnectionMap ( BOOL threadSafe = FALSE ) ;
	virtual ~ConnectionMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ConnectionMap ( BOOL threadSafeArg ) 
: m_bThreadSafe ( threadSafeArg ) , m_criticalLock ( NULL )
{
	if ( m_bThreadSafe )
	{
		m_criticalLock = new CCriticalSection ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~ConnectionMap () 
{
	if ( m_bThreadSafe )
	{
		delete m_criticalLock ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		int count = m_cmap.GetCount () ;
		m_criticalLock->Unlock () ;
		return count ;
	}
	else
	{
		return m_cmap.GetCount () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		BOOL isEmpty = m_cmap.IsEmpty () ;
		m_criticalLock->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return m_cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		BOOL lookup = m_cmap.Lookup ( key , rValue ) ;
		m_criticalLock->Unlock () ;
		return lookup ;
	}
	else
	{
		return m_cmap.Lookup ( key , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		VALUE &value = m_cmap.operator [] ( key ) ;
		m_criticalLock->Unlock () ;
		return value ;
	}
	else
	{
		return m_cmap.operator [] ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		m_cmap.SetAt ( key , newValue ) ;
		m_criticalLock->Unlock () ;
	}
	else
	{
		m_cmap.SetAt ( key , newValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		BOOL removeKey = m_cmap.RemoveKey ( key ) ;
		m_criticalLock->Unlock () ;
		return removeKey ;
	}
	else
	{
		return m_cmap.RemoveKey ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		m_cmap.RemoveAll () ;
		m_criticalLock->Unlock () ;
	}
	else
	{
		m_cmap.RemoveAll () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		POSITION position = m_cmap.GetStartPosition () ;
		m_criticalLock->Unlock () ;
		return position ;
	}
	else
	{
		return m_cmap.GetStartPosition () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		m_cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
		m_criticalLock->Unlock () ;
	}
	else
	{
		m_cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	}
}
/*
 * The connectable object implements IUnknown and
 * IConnectionPointContainer.  It is closely associated with
 * the connection point enumerator, CEnumConnectionPoints.
 */
class CSmirConnObject : public IConnectionPointContainer
{
    private:
        LONG       m_cRef;         //Object reference count

        //Array holding all the points we have.
        CSmirConnectionPoint **m_rgpConnPt;

    public:
        CSmirConnObject(CSmir *pSmir);
        virtual ~CSmirConnObject(void);

        BOOL Init(CSmir *pSmir);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(DWORD) AddRef(void);
        STDMETHODIMP_(DWORD) Release(void);

        //IConnectionPointContainer members
        STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **);
	    STDMETHODIMP FindConnectionPoint(REFIID, IConnectionPoint **);

        //Other members
//        BOOL TriggerEvent(UINT, SMIR_NOTIFY_TYPE);
//		BOOL TriggerEvent(long lObjectCount, ISmirClassHandle *phClass);
};
/*
 * The connectable object implements IUnknown and
 * IConnectionPointContainer.  It is closely associated with
 * the connection point enumerator, CEnumConnectionPoints.
 */
//Enumerator class for EnumConnectionPoints

class CEnumConnectionPoints : public IEnumConnectionPoints
{
    private:
        LONG           m_cRef;     //Object reference count
        LPUNKNOWN       m_pUnkRef;  //IUnknown for ref counting
        ULONG           m_iCur;     //Current element
        ULONG           m_cPoints;  //Number of conn points
        IConnectionPoint **m_rgpCP; //Source of conn points

    public:
        CEnumConnectionPoints(LPUNKNOWN, ULONG, IConnectionPoint **);
        virtual ~CEnumConnectionPoints(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumConnectionPoints members
        STDMETHODIMP Next(ULONG, IConnectionPoint **, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumConnectionPoints **);
};

/*
 * The connection point object iself is contained within the
 * connection point container, which is the connectable object.
 * It therefore manages a back pointer to that connectable object,
 * and implement IConnectionPoint.  This object has a few
 * member functions besides those in IConnectionPoint that are
 * used to fire the outgoing calls.
 */
class CSmirConnectionPoint : public IConnectionPoint
{
    private:
        LONG				m_cRef;     //Object reference count
        PCSmirConnObject	m_pObj;     //Containing object
        IID					m_iid;      //Our relevant interface
        LONG				m_dwCookieNext; //Counter
		CCriticalSection	criticalSection;

	protected:
        /*
         * For each connection we need to maintain
         * the sink pointer and the cookie assigned to it.
         */
		ConnectionMap <DWORD, DWORD, IUnknown *,IUnknown *> m_Connections ;

    public:
        CSmirConnectionPoint(PCSmirConnObject, REFIID, CSmir *pSmir);
        virtual ~CSmirConnectionPoint(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IConnectionPoint members
        STDMETHODIMP GetConnectionInterface(IID *);
        STDMETHODIMP GetConnectionPointContainer
            (IConnectionPointContainer **);
        STDMETHODIMP Advise(LPUNKNOWN, DWORD *);
        STDMETHODIMP Unadvise(DWORD);
        STDMETHODIMP EnumConnections(IEnumConnections **);
};

class CSmirNotifyCP : public CSmirConnectionPoint
{
	private:
		CSmirWbemEventConsumer	*m_evtConsumer;
		BOOL					m_bRegistered;

	public:
        STDMETHODIMP Advise(CSmir*,LPUNKNOWN, DWORD *);
        STDMETHODIMP Unadvise(CSmir*,DWORD);
		CSmirNotifyCP(PCSmirConnObject pCO, REFIID riid, CSmir *pSmir);
		~CSmirNotifyCP();
        BOOL TriggerEvent();
};
//Enumeration class for EnumConnections

class CEnumConnections : public IEnumConnections
    {
    private:
        LONG           m_cRef;     //Object reference count
        LPUNKNOWN       m_pUnkRef;  //IUnknown for ref counting
        ULONG           m_iCur;     //Current element
        ULONG           m_cConn;    //Number of connections
        LPCONNECTDATA   m_rgConnData; //Source of connections
    public:
        CEnumConnections(LPUNKNOWN, ULONG, LPCONNECTDATA);
        virtual ~CEnumConnections(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumConnections members
        STDMETHODIMP Next(ULONG, LPCONNECTDATA, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumConnections **);
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\textdef.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _TEXTDEF_H_
#define _TEXTDEF_H_
/*********************  HMOM strings  **************************/
#define HMOM_CLASS_PREFIX		L"__"
#define HMOM_CONNECT_USER		L""
#define HMOM_CONNECT_PASSWORD	L""
#define HMOM_EMPTY_STRING		L""
#define HMOM_SNMPMACRO_STRING			L"SnmpMacro"
#define HMOM_SNMPOBJECTTYPE_STRING		L"SnmpObjectType"
#define HMOM_CLASS_EXTENDEDSTATUS			L"__ExtendedStatus"
#define HMOM_CLASS_SNMPNOTIFYSTATUS		L"SnmpNotifyStatus"
#define HMOM_PROPERTY_SNMPSTATUSCODE	L"SnmpStatusCode"
#define HMOM_PROPERTY_SNMPSTATUSMESSAGE L"Description"
#define HMOM_SNMPNOTIFICATIONTYPE_STRING	L"SnmpNotification"
#define HMOM_SNMPEXTNOTIFICATIONTYPE_STRING	L"SnmpExtendedNotification"

//Strings used during self registeration
#define CLSID_STR			L"Software\\Classes\\CLSID\\"
#define REG_FORMAT_STR		L"%s\\%s"
#define NOT_INTERT_STR		L"NotInsertable"
#define INPROC32_STR		L"InprocServer32"
#define SMIR_NAME_STR		L"Microsoft WBEM SNMP Module Information Repository"
#define THREADING_MODULE_STR L"ThreadingModel"
#define APARTMENT_STR		L"Both"

//name space strings
#define OLEMS_NAMESPACE_CLASS	L"__namespace"
#define SMIR_NAMESPACE_NAME		L"SMIR"
#define OLEMS_ROOT_NAMESPACE	L"root\\snmp"
#define OLEMS_ROOT_NAMESPACE_FROM_ROOT	L"\\\\.\\root\\snmp"
#define SMIR_NAMESPACE_FROM_ROOT	L"\\\\.\\root\\snmp\\SMIR"
#define SMIR_CLASS_ASSOCIATION_ENDPOINT    L"\\\\.\\root\\snmp\\SMIR:SMIR=\"@\""
#define SMIR_NAMESPACE			L"root\\snmp\\SMIR"
#define MODULE_NAMESPACE_NAME	L"SNMP_MODULE"
#define GROUP_NAMESPACE_NAME	L"SNMP_GROUP"
#define SMIR_INSTANCE_NAME		L"SMIR"
#define CLASS_CLASS_NAME		L"CLASS"
#define OLEMS_CLASS_PROP		L"__CLASS"
#define OLEMS_PATH_PROP			L"__PATH"
#define OLEMS_GENUS_PROP		L"__GENUS"
#define OLEMS_SUPERCLASS_PROP	L"__SUPERCLASS"
#define OLEMS_NAME_PROP			L"Name"
#define DOT_STR					L"."
#define BACKSLASH_STR			L"\\"
#define EQUALS_STR				L"="
#define KEY_STR					L"Key"
#define QUOTE_STR				L"\""
#define COLON_STR				L":"
#define SEMICOLON_STR			L";"
#define REF_STR					L"ref"
#define SYNTAX_STR				L"syntax"
#define ASSOC_STR				L"assoc"
#define ABSTRACT_STR			L"abstract"
#define OPEN_BRACE_STR			L"{"
#define CLOSE_BRACE_STR			L"}"
#define SPACE_STR				L" "
#define NEWLINE_STR				L"\n"

//name space property strings
/*********************  module namespace **************************/
#define MODULE_NAME_PROPERTY			L"Name"
#define MODULE_OID_PROPERTY				L"Module_Oid"
#define MODULE_ID_PROPERTY				L"Module_Identity"
#define MODULE_ORG_PROPERTY				L"Organization"
#define MODULE_CONTACT_PROPERTY			L"Contact_Inf"
#define MODULE_DESCRIPTION_PROPERTY		L"Description"
#define MODULE_REVISION_PROPERTY		L"Revision"
#define MODULE_SNMP_VERSION_PROPERTY	L"Snmp_Version"
#define MODULE_LAST_UPDATE_PROPERTY		L"Last_Updated"
#define MODULE_IMPORTS_PROPERTY			L"Module_Imports"

/*********************  group namespace **************************/
#define GROUP_NAME_PROPERTY				L"Name"
#define GROUP_ID_PROPERTY				L"Group_Id"
#define GROUP_STATUS_PROPERTY			L"Status"
#define GROUP_DESCRIPTION_PROPERTY		L"Description"
#define MODULE_REFERENCE_PROPERTY		L"Reference"

/*********************  class namespace **************************/
//#define CLASS_NAME_PROPERTY				L"Name"


/*********************  Mutex strings   **************************/
#define SMIR_INTERFACE_GARBAGE_MAP_MUTEX	L"SMIR_InterfaceGarbageMap"
#define SMIR_CSMIR_MUTEX					L"SMIR_CSmir"
#define SMIR_CSMIR_INTERROGATOR_MUTEX		L"SMIR_CSmirInterogator"
#define SMIR_CSMIR_ADMINISTRATOR_MUTEX		L"SMIR_CSmirAdministrator"
#define SMIR_ENUMOBJECT_MUTEX				L"SMIR_EnumObjectArray"


/*********************  Association strings   **************************/
#define SMIR_ASSOC_QUERY1_TYPE				L"WQL"
#define SMIR_ASSOC_QUERY2_TYPE				L"WQL"

#define SMIR_ASSOC_CLASS_NAME					L"SmirToClassAssociator"
#define SMIR_ASSOC_CLASS_NAME_POSTFIX			L"SMIRAssociation"
#define SMIR_ASSOC_SMIR_PROP					L"SmirName"

#define SMIR_NOTIFICATION_MAPPER				L"NotificationMapper"
#define SMIR_EXT_NOTIFICATION_MAPPER			L"ExtendedNotificationMapper"
#define SMIR_NOTIFICATION_TRAP_PROP				L"SnmpTrapOID"
#define SMIR_NOTIFICATION_CLASS_PROP			L"EventClassName"

#define SMIR_MODULE_ASSOC_NCLASS_NAME			L"ModToNotificationClassAssociator"
#define SMIR_MODULE_ASSOC_EXTNCLASS_NAME		L"ModToExtNotificationClassAssociator"
#define SMIR_MODULE_ASSOC_CLASS_NAME			L"ModuleToClassAssociator"
#define SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX	L"SMIRModuleAssociation"
#define SMIR_MODULE_ASSOC_MODULE_PROP			L"SmirModule"

#define SMIR_GROUP_ASSOC_CLASS_NAME				L"GroupToClassAssociator"
#define SMIR_GROUP_ASSOC_CLASS_NAME_POSTFIX		L"SMIRGroupAssociation"
#define SMIR_GROUP_ASSOC_GROUP_PROP				L"SmirGroup"

#define SMIR_X_ASSOC_NAME_PROP					L"AssocName"
#define SMIR_X_ASSOC_CLASS_PROP					L"SmirClass"

//Strings for Notification and Extended Notification Base classes
#define EXTRINSIC_EVENT_CLASS_NAME				L"__ExtrinsicEvent"
#define NOTIFICATION_CLASS_NAME					L"SnmpNotification"
#define EXT_NOTIFICATION_CLASS_NAME				L"SnmpExtendedNotification"
#define TIMESTAMP_PROP							L"TimeStamp"
#define SENDER_ADDR_PROP						L"AgentAddress"
#define SENDER_TADDR_PROP						L"AgentTransportAddress"
#define TRANSPORT_PROP							L"AgentTransportProtocol"
#define TRAPOID_PROP							L"Identification"
#define COMMUNITY_PROP							L"Community"

//strings for Event registration
#define FILTER_QUERYTYPE_VAL					L"WQL"
#define FILTER_QUERY_VAL						L"SELECT * FROM __ClassOperationEvent"

/*query strings for getting the classes associated with a group are of the form
 *L"associators of {\\\\.\\root\\default\\SMIR\\<module>:Group=\"<group>\"}",
 */
#define SMIR_ASSOC_QUERY_STR1				L"associators of "
#define SMIR_ASSOC_QUERY_STR2				L"references of "
#define SMIR_ASSOC_QUERY_STR3				L" where AssocClass"
#define SMIR_ASSOC_QUERY_STR4				L" where ResultClass"

#define SQL_QUERY_STR1						L"select * from "
#define SQL_QUERY_STR2						L" where "


/***************************Serialise strings ************************************/
#define ROOT_DEFAULT_NAMESPACE_PRAGMA		L"#pragma namespace(\"\\\\\\\\.\\\\root\\\\snmp\")\n"
#define SMIR_NAMESPACE_PRAGMA				L"#pragma namespace(\"\\\\\\\\.\\\\root\\\\snmp\\\\SMIR\")\n"
#define START_OF_SMIR_NAMESPACE_PRAGMA		L"#pragma namespace(\"\\\\\\\\.\\\\root\\\\snmp\\\\SMIR\\\\"
#define END_OF_NAMESPACE_PRAGMA				L"\")\n"
#define OLEMS_ROOT_NAMESPACE_STR			L"\\\\\\\\.\\\\root\\\\snmp"
#define SMIR_NAMESPACE_STR					L"\\\\\\\\.\\\\root\\\\snmp\\\\SMIR"
#define READONLY_STRING						(CString(L"[read] string "))
#define WRITE_STRING						(CString(L"[write] string "))
#define WRITE_LONG							(CString(L"[write] sint32 "))
#define READ_ONLY_KEY_STRING				(CString(L"[read, key] string "))
#define READ_ONLY_REF_STRING				(CString(L"[read] object ref "))
#define READONLY_LONG						(CString(L"[read] sint32 "))
#define QUAL_FLAVOUR						(CString(L":ToInstance ToSubClass DisableOverride"))
#define TIMESTAMP_QUALS_TYPE				(CString(L"[textual_convention(\"TimeTicks\")")\
												+QUAL_FLAVOUR\
												+CString(L",encoding(\"TimeTicks\")")\
												+QUAL_FLAVOUR\
												+CString(L",object_syntax(\"TimeTicks\")")\
												+QUAL_FLAVOUR\
												+CString(L",read,object_identifier(\"1.3.6.1.2.1.1.3\")")\
												+QUAL_FLAVOUR\
												+CString(L",description(\"The time (in hundredths of a second) since the network management portion of the agent was last re-initialized.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] uint32 "))
#define TRAPOID_QUALS_TYPE					(CString(L"[textual_convention(\"OBJECTIDENTIFIER\")")\
												+QUAL_FLAVOUR\
												+CString(L", encoding(\"OBJECTIDENTIFIER\")")\
												+QUAL_FLAVOUR\
												+CString(L", object_syntax(\"OBJECTIDENTIFIER\")")\
												+QUAL_FLAVOUR\
												+CString(L", read, object_identifier(\"1.3.6.1.6.3.1.1.4.1\")")\
												+QUAL_FLAVOUR\
												+CString(L",description(\"The authoratative identification of this notification.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define SENDER_ADDR_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The network address of the entity that created this notification.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define SENDER_TADDR_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The network address of the entity that sent this notification. This may be a proxy for the original entity.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define TRANSPORT_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The transport protocol used by the sending entity.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define COMMUNITY_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The security context used to send this notification.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))												
#define ASSOC_QUALIFIER						(CString(L"[Association]")+CString(NEWLINE_STR))

#define QUALIFIER_PROPAGATION				(CString(L"\
qualifier write:ToInstance ToSubClass;\n\
qualifier read:ToInstance ToSubClass;\n\
qualifier provider:ToInstance ToSubClass;\n\
qualifier singleton:ToInstance ToSubClass;\n\
qualifier dynamic:ToInstance ToSubClass;\n\
qualifier textual_convention:ToInstance ToSubClass;\n\
qualifier object_identifier:ToInstance ToSubClass;\n\
qualifier varbindindex:ToInstance ToSubClass;\n\
qualifier encoding:ToInstance ToSubClass;\n\
qualifier object_syntax:ToInstance ToSubClass;\n\
qualifier status:ToInstance ToSubClass;\n\
qualifier fixed_length:ToInstance ToSubClass;\n\
qualifier variable_length:ToInstance ToSubClass;\n\
qualifier variable_value:ToInstance ToSubClass;\n\
qualifier bits:ToInstance ToSubClass;\n\
qualifier key_order:ToInstance ToSubClass;\n\
qualifier enumeration:ToInstance ToSubClass;\n\
qualifier bits:ToInstance ToSubClass;\n") + \
										CString(L"\
qualifier description:ToInstance ToSubClass;\n\
qualifier display_hint:ToInstance ToSubClass;\n\
qualifier defval:ToInstance ToSubClass;\n\
qualifier units:ToInstance ToSubClass;\n\
qualifier reference:ToInstance ToSubClass;\n\
qualifier virtual_key:ToInstance ToSubClass;\n\
qualifier rowstatus:ToInstance ToSubClass;\n\
qualifier module_name:ToInstance ToSubClass;\n\
qualifier module_imports:ToInstance ToSubClass;\n\
qualifier group_objectid:ToInstance ToSubClass;\n\n"))



#define INSTANCE_END						(CString(ESCAPED_QUOTE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR)\
											+CString(CLOSE_BRACE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR))

#define INSTANCE_START						(CString(L"instance of "))
#define END_OF_PROPERTY						(CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR))

#define NL_BRACE_NL_STR						(CString(NEWLINE_STR)\
											+CString(OPEN_BRACE_STR)\
											+CString(NEWLINE_STR))

#define END_OF_CLASS						(CString(CLOSE_BRACE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR)\
											+CString(NEWLINE_STR))

#define END_OF_INSTANCE						END_OF_CLASS

#define START_OF_PROPERTY_VALUE				(CString(EQUALS_STR)\
											+CString(QUOTE_STR))

#define END_OF_PROPERTY_VALUE				(CString(QUOTE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR))

#define	ESCAPED_QUOTE_STR					L"\\\""

#define ABSTRACT_CLASS_STRING				L"[abstract]\nclass "
#define CLASS_STRING						L"class "

#define SMIR_CLASS_DEFINITION					(CString(CLASS_STRING)\
												+CString(SMIR_INSTANCE_NAME)\
												+CString(COLON_STR)\
												+CString(OLEMS_NAMESPACE_CLASS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR)\
												+CString(READONLY_STRING)\
												+CString(OLEMS_NAME_PROP)\
												+CString(EQUALS_STR)\
												+CString(QUOTE_STR)\
												+CString(SMIR_INSTANCE_NAME)\
												+CString(END_OF_PROPERTY_VALUE)\
												+CString(END_OF_CLASS))

#define SMIR_INSTANCE_DEFINITION				(CString(INSTANCE_START)\
												+CString(SMIR_INSTANCE_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR)\
												+CString(END_OF_INSTANCE))


#define SNMPMACRO_CLASS_START					(CString(ABSTRACT_CLASS_STRING)\
												+CString(HMOM_SNMPMACRO_STRING)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define SNMPOBJECTTYPE_CLASS_START				(CString(ABSTRACT_CLASS_STRING)\
												+CString(HMOM_SNMPOBJECTTYPE_STRING)\
												+CString(COLON_STR)\
												+CString(HMOM_SNMPMACRO_STRING)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define SNMPNOTIFYSTATUS_CLASS_START			(CString(CLASS_STRING)\
												+CString(HMOM_CLASS_SNMPNOTIFYSTATUS)\
												+CString(COLON_STR)\
												+CString(HMOM_CLASS_EXTENDEDSTATUS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR)\
												+CString(WRITE_LONG)\
												+CString(HMOM_PROPERTY_SNMPSTATUSCODE)\
												+CString(SEMICOLON_STR)\
												+CString(NEWLINE_STR)\
												+CString(WRITE_STRING)\
												+CString(HMOM_PROPERTY_SNMPSTATUSMESSAGE)\
												+CString(SEMICOLON_STR)\
												+CString(NEWLINE_STR))

#define SNMPNOTIFICATION_CLASS_START			(CString(CLASS_STRING)\
												+CString(NOTIFICATION_CLASS_NAME)\
												+CString(COLON_STR)\
												+CString(EXTRINSIC_EVENT_CLASS_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define SNMPEXTNOTIFICATION_CLASS_START			(CString(CLASS_STRING)\
												+CString(EXT_NOTIFICATION_CLASS_NAME)\
												+CString(COLON_STR)\
												+CString(EXTRINSIC_EVENT_CLASS_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define NOTIFICATIONMAPPER_CLASS_START			(CString(CLASS_STRING)\
												+CString(SMIR_NOTIFICATION_MAPPER)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define EXTNOTIFICATIONMAPPER_CLASS_START		(CString(CLASS_STRING)\
												+CString(SMIR_EXT_NOTIFICATION_MAPPER)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define MODULE_CLASS_START						(CString(CLASS_STRING)\
												+CString(MODULE_NAMESPACE_NAME)\
												+CString(COLON_STR)\
												+CString(OLEMS_NAMESPACE_CLASS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define MODULE_INSTANCE_START					(CString(INSTANCE_START)\
												+CString(MODULE_NAMESPACE_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define GROUP_CLASS_START						(CString(CLASS_STRING)\
												+CString(GROUP_NAMESPACE_NAME)\
												+CString(COLON_STR)\
												+CString(OLEMS_NAMESPACE_CLASS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define GROUP_INSTANCE_START					(CString(INSTANCE_START)\
												+CString(GROUP_NAMESPACE_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\cominit.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
HRESULT InitializeCom();
void UninitializeCom();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\cominit.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "ComInit.h"

HRESULT (STDAPICALLTYPE *g_pfnCoInitializeEx)(void*, DWORD);

static BOOL g_bInitialized = FALSE;
static HINSTANCE  g_hOle32 = NULL;

BOOL InitComInit()
{
    UINT    uSize;
    BOOL    bRetCode = FALSE;

    HANDLE hMut;

    if(g_bInitialized) {
        return TRUE;
    }

    do {
        hMut = CreateMutex(NULL, TRUE,  "COMINIT_INITIALING");
        if(hMut == INVALID_HANDLE_VALUE) {
            Sleep(50);
        }
    } while(hMut == INVALID_HANDLE_VALUE);

    if(g_bInitialized) {
        CloseHandle(hMut);
        return TRUE;
    }

    LPTSTR   pszSysDir = new char[ MAX_PATH+10 ];
    if(pszSysDir == NULL)
        return FALSE;

    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);
    if(uSize > MAX_PATH) {
        delete[] pszSysDir;
        pszSysDir = new char[ uSize +10 ];
        if(pszSysDir == NULL)
            return FALSE;
        uSize = GetSystemDirectory(pszSysDir, uSize);
    }

    lstrcat(pszSysDir, "\\ole32.dll");

    g_hOle32 = LoadLibraryEx(pszSysDir, NULL, 0);
    delete pszSysDir;

    if(g_hOle32 != NULL) 
    {
        bRetCode = TRUE;   
        (FARPROC&)g_pfnCoInitializeEx = GetProcAddress(g_hOle32, "CoInitializeEx");
        if(!g_pfnCoInitializeEx) {
            FreeLibrary(g_hOle32);
            g_hOle32 = NULL;
            bRetCode = FALSE;
        }
    }
    g_bInitialized = TRUE;

    CloseHandle(hMut);

    return bRetCode;
}
BOOL IsDcomEnabled()
{
    InitComInit();
    if(g_hOle32) {
        // DCOM has been detected.
        // =======================
        return TRUE;
    } else {
        // DCOM was not detected.
        // ======================
        return FALSE;
    }
}

HRESULT InitializeCom()
{
    if(IsDcomEnabled()) {
        return g_pfnCoInitializeEx(0, COINIT_MULTITHREADED);
    }
    return CoInitialize(0);
}
void CloseStuff()
{
	if(g_hOle32)
	{
		FreeLibrary(g_hOle32);
		g_hOle32 = NULL;
		g_bInitialized = FALSE;
	}
}
void UninitializeCom()
{
	CoUninitialize();
	CloseStuff();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\main.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
#ifndef __MAIN_H_
#define __MAIN_H_

#define MAX_MSG_TEXT_LENGTH	1024
#define LANG_ID_STR	5

typedef struct 
{
	const char*	pszMofFilename;				//MOF filename
	int			nInstallType;				//Selection of InstallType items
	int			nPlatformVersions;			//Selection of PlatformType items
} MofDataTable;

enum InstallType 
{
	NoInstallType	= 0,
	Core			= 1, 
	SDK				= 2, 
	SNMP			= 4,
	MUI				= 8,
	NO_AUTORECOVERY	= 16
};

enum PlatformType
{
	NoPlatformType	= 0,
	Win95			= 1,
	Win98			= 2,
	WinNT351		= 4,
	WinNT4ToSP3		= 8,
	WinNT4AboveSP3	= 16,
	WinNT5			= 32
};

enum MsgType
{
	MSG_INFO,
	MSG_WARNING,
	MSG_ERROR
};

enum
{
	no_error,
	failed,
	critical_error,
	out_of_memory
};

STDAPI	DllRegisterServer(void);
//bool	NTSetupInProgress();
//void	SetFlagForCompile();
bool	DoSNMPInstall();
bool	FileExists(const char *pszFilename);
char*	GetFullFilename(const char *pszFilename, InstallType eInstallType=Core);
bool	GetStandardMofsForThisPlatform(CMultiString &mszPlatformMofs, int nCurInstallType);
bool	LoadMofList(IMofCompiler * pCompiler, const char *mszMofs, CString &szMOFsWhichFailedToLoad);
void	LogMessage(MsgType msgType, const char *pszMessage);
void	SetSNMPBuildRegValue();

#endif // __MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\thread.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _THREAD_H_
#define _THREAD_H_


#define THREAD_STARED			100
#define WAIT_EVENT_0			WAIT_OBJECT_0
#define WAIT_EVENT_FAILED		(MAXIMUM_WAIT_OBJECTS+1)
#define WAIT_EVENT_ABANDONED	(MAXIMUM_WAIT_OBJECTS+2)
#define WAIT_EVENT_TERMINATED	(MAXIMUM_WAIT_OBJECTS+3)

typedef void (*PVOIDTHREADPROC)(void *);
/*
 * Each connection is saved so that we can enumerate, delete, and trigger
 * This template provides the container for the connections and cookies
 */
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class EventMap : public CObject
{
private:

	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> m_cmap ;

protected:
public:

	EventMap () ;
	virtual ~EventMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: EventMap ()  
{
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~EventMap () 
{
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	int count = m_cmap.GetCount () ;
	return count ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	return m_cmap.IsEmpty () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	return m_cmap.Lookup ( key , rValue ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	return m_cmap.operator [] ( key ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	m_cmap.SetAt ( key , newValue ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	return m_cmap.RemoveKey ( key ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
		m_cmap.RemoveAll () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	return m_cmap.GetStartPosition () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	m_cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;

}
/*InterfaceGarbageCollector makes it easier to use the  interface
 *by remembering to release them when you fall out of scope. The is 
 *useful when you are using an IMosProvider and have lots of points
 *of failure; you can just give up and let the wrapper clean up for 
 *you.
 */
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class ThreadMap : public CObject
{
private:
	CCriticalSection * criticalSection ;
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> cmap ;
protected:
public:

	ThreadMap ();
	virtual ~ThreadMap () ;
	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ThreadMap () : 
								 criticalSection(NULL)
{
		criticalSection = new CCriticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~ThreadMap () 
{
	//this may be null
	delete criticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	criticalSection->Lock () ;
	int count = cmap.GetCount () ;
	criticalSection->Unlock () ;
	return count ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if (TRUE == m_bMakeThreadSafe)
	{
		criticalSection->Lock () ;
		BOOL isEmpty = cmap.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	criticalSection->Lock () ;
	BOOL lookup = cmap.Lookup ( key , rValue ) ;
	criticalSection->Unlock () ;
	return lookup ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	criticalSection->Lock () ;
	VALUE &value = cmap.operator [] ( key ) ;
	criticalSection->Unlock () ;
	return value ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	criticalSection->Lock () ;
	cmap.SetAt ( key , newValue ) ;
	criticalSection->Unlock () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	criticalSection->Lock () ;
	BOOL removeKey = cmap.RemoveKey ( key ) ;
	criticalSection->Unlock () ;
	return removeKey ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	criticalSection->Lock () ;
	cmap.RemoveAll () ;
	criticalSection->Unlock () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	criticalSection->Lock () ;
	POSITION position = cmap.GetStartPosition () ;
	criticalSection->Unlock () ;
	return position ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	criticalSection->Lock () ;
	cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	criticalSection->Unlock () ;
}
class CThread 
{
	private:
	   BOOL				 bWaiting;
	   HANDLE			 m_hThreadStopEvent;
	   HANDLE			 m_hThreadSyncEvent;
  	   DWORD			 m_cRef;

	   EventMap <HANDLE, HANDLE, HANDLE,HANDLE> m_UserEvents ;
	   static ThreadMap <CThread*, CThread*, CThread*,CThread*> m_ThreadMap ;

    protected:
   	   uintptr_t			 m_ulThreadHandle;

	public:
		CThread();
		virtual ~CThread();
		SCODE Start();
		SCODE Stop();
		SCODE Wait(DWORD timeout = INFINITE);
		virtual SCODE Process(){return S_OK;};
		void AddEvent(HANDLE userEvent){m_UserEvents.SetAt(userEvent,userEvent);}
		void DeleteEvent(HANDLE userEvent){m_UserEvents.RemoveKey(userEvent);}
		void Exit(){SetEvent(m_hThreadSyncEvent);}
		ULONG AddRef(void){return ++m_cRef;}
		ULONG Release(void);
		operator void*();
		static void ProcessDetach();
 };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\precomp.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PRECOMP_H_
#define __PRECOMP_H_

#include <ole2.h>
#include <windows.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\main.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <wbemidl.h>
#include "str.h"
#include "ComInit.h"
#include "reg.h"
#include "main.h"

#define VERBOSE_LOG 1

char	g_szLangId[LANG_ID_STR];

MofDataTable g_mofDataTable[] = 
{
	{ "snmpsmir.mof",	SNMP,		WinNT5 },
	{ "snmpreg.mof",	SNMP,		WinNT5 },
	{ NULL,			NoInstallType,	NoPlatformType }
};

BOOL WINAPI DllMain( IN HINSTANCE	hModule, 
                     IN ULONG		ul_reason_for_call, 
                     LPVOID			lpReserved
					)
{
	return TRUE;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup to perform various setup tasks
//          (This is not the normal use of DllRegisterServer!)
//
// Return:  NOERROR
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
	LogMessage(MSG_INFO, "Beginning SNMP Setup");

	// because wbem setup has changed, this condition no longer applies
//	if (NTSetupInProgress())
//	{
//		SetFlagForCompile();	// we can't compile MOF's because WBEM isn't setup yet,
//								// so set a flag for wbemupgd.dll to see so that it can compile them instead
//	}
//	else
	{
		InitializeCom();
		DoSNMPInstall();		// load the SNMP MOFs
		UninitializeCom();
	}

	SetSNMPBuildRegValue();		// set SNMP build number in registry

	LogMessage(MSG_INFO, "SNMP Setup Completed");

    return NOERROR;
}

/*  this function is no longer needed due to wbem setup changes

bool NTSetupInProgress()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for CheckIfDuringNTSetup.");
		return false;
	}

	char *pszSetup = NULL;
	if (r.GetStr("WMISetup", &pszSetup))
	{
		LogMessage(MSG_ERROR, "Unable to get WMI setup reg value for CheckIfDuringNTSetup.");
		return false;
	}
	if (!pszSetup)
	{
		LogMessage(MSG_ERROR, "Unable to get WMI setup reg value for CheckIfDuringNTSetup.");
		return false;
	}

	bool bRet = false;
	if (strcmp(pszSetup, "1") == 0)
		bRet = true;

	delete [] pszSetup;

	return bRet;
}

void SetFlagForCompile()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() == no_error)
	{
		r.SetStr("SNMPSetup", "1");
		LogMessage(MSG_INFO, "Flag set for later SNMP MOF compile by wbemupgd.dll.");
	}
	else
		LogMessage(MSG_ERROR, "Unable to set flag for later SNMP MOF compile.");
}
*/

bool DoSNMPInstall()
{
	bool bRet = true;
	bool bMofLoadFailure = false;
	CMultiString mszPlatformMofs;
	CString szFailedPlatformMofs;

	IMofCompiler* pCompiler = NULL;
    SCODE sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *) &pCompiler);
    
    if(SUCCEEDED(sc))
    {
		GetStandardMofsForThisPlatform(mszPlatformMofs, SNMP);

		bRet = LoadMofList(pCompiler, mszPlatformMofs, szFailedPlatformMofs);
		if (bRet == false)
			bMofLoadFailure = true;

		pCompiler->Release();
    }
	else
	{
		bRet = false;
	}

	CString szMessage;
	char szTemp[MAX_MSG_TEXT_LENGTH];
	if (szFailedPlatformMofs.Length())
	{
		LogMessage(MSG_ERROR, "The following SNMP file(s) failed to load:");
		LogMessage(MSG_ERROR, szFailedPlatformMofs);
	}
	else if (bMofLoadFailure)
	{
		LogMessage(MSG_ERROR, "None of the SNMP files could be loaded.");
	}
	else if (bRet == false)
	{
		LogMessage(MSG_ERROR, "No MOFs could be loaded because the MOF Compiler failed to intialize.");
	}
	return bRet;
}

bool GetStandardMofsForThisPlatform(CMultiString &mszPlatformMofs, int nCurInstallType)
{
	int nCurPlatform = WinNT5;
	char* pszFullName = NULL;

	for (int i = 0; g_mofDataTable[i].pszMofFilename != NULL; i++)
	{
		if ((g_mofDataTable[i].nPlatformVersions & nCurPlatform) &&
			(g_mofDataTable[i].nInstallType & nCurInstallType))
		{
			pszFullName = GetFullFilename(g_mofDataTable[i].pszMofFilename, (InstallType)nCurInstallType);
			if (pszFullName)
			{
				if (FileExists(pszFullName))
					mszPlatformMofs.AddUnique(pszFullName);
				delete [] pszFullName;
				pszFullName = NULL;
			}
			else
			{
				char szTemp[MAX_MSG_TEXT_LENGTH];
				sprintf(szTemp, "Failed GetFullFilename for %s with install type = %i in GetStandardMofsForthisPlatform.", g_mofDataTable[i].pszMofFilename, nCurInstallType);
				LogMessage(MSG_ERROR, szTemp);
				// do not return false here, keep processing other mofs
			}
		}
	}

	return true;
}

char* GetFullFilename(const char *pszFilename, InstallType eInstallType)
{
	char *pszDirectory = NULL;
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for GetFullFilename.");
		return NULL;
	}

	if (r.GetStr("Installation Directory", &pszDirectory))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Installation Directory from registry for GetFullFilename.");
		return NULL;
	}
	CString pszPathFilename(pszDirectory);
	if (eInstallType == MUI)
	{
		if (pszPathFilename.Length() && (pszPathFilename[pszPathFilename.Length()-1] != '\\'))
		{
			pszPathFilename += "\\MUI\\";
			pszPathFilename += g_szLangId;
		}
	}

	if (pszPathFilename.Length() && (pszPathFilename[pszPathFilename.Length()-1] != '\\'))
	{
		pszPathFilename += "\\";
	}
	pszPathFilename += pszFilename;

	delete [] pszDirectory;

	return pszPathFilename.Unbind();
}

bool FileExists(const char *pszFilename)
{
	char *szExpandedFilename = NULL;
	DWORD nRes = ExpandEnvironmentStrings(pszFilename,NULL,0); 
	if (nRes == 0)
	{
		szExpandedFilename = new char[strlen(pszFilename) + 1];
		if (szExpandedFilename == NULL)
		{
			return false;
		}
		strcpy(szExpandedFilename, pszFilename);
	}
	else
	{
		szExpandedFilename = new char[nRes];
		if (szExpandedFilename == NULL)
		{
			return false;
		}
		nRes = ExpandEnvironmentStrings(pszFilename,szExpandedFilename,nRes); 
		if (nRes == 0)
		{
			delete [] szExpandedFilename;
			return false;
		}
	}
	
	bool bExists = false;
	DWORD dwAttribs = GetFileAttributes(szExpandedFilename);
	if (dwAttribs != 0xFFFFFFFF)
	{
		bExists = true;
	}

	delete [] szExpandedFilename;
	return bExists;
}

bool LoadMofList(IMofCompiler * pCompiler, const char *mszMofs, CString &szMOFFailureList)
{
	LogMessage(MSG_INFO, "Beginning mof load");

	bool bRet = true;
	WCHAR wFileName[MAX_PATH];
	const char *pszMofs = mszMofs;
	char szTemp[MAX_MSG_TEXT_LENGTH];
	WBEM_COMPILE_STATUS_INFO statusInfo;

	while (*pszMofs != '\0')
	{
		char *szExpandedFilename = NULL;
		DWORD nRes = ExpandEnvironmentStrings(pszMofs,NULL,0); 
		if (nRes == 0)
		{
			szExpandedFilename = new char[strlen(pszMofs) + 1];
			if (szExpandedFilename == NULL)
			{
				LogMessage(MSG_INFO, "Failed allocating memory for szExpandedFilename - 1.");

				bRet = false;
				break;
			}
			strcpy(szExpandedFilename, pszMofs);
		}
		else
		{
			szExpandedFilename = new char[nRes];
			if (szExpandedFilename == NULL)
			{
				LogMessage(MSG_INFO, "Failed allocating memory for szExpandedFilename - 2.");

				bRet = false;
				break;
			}
			nRes = ExpandEnvironmentStrings(pszMofs,szExpandedFilename,nRes); 
			if (nRes == 0)
			{
				LogMessage(MSG_INFO, "Failed expanding environment strings.");

				delete [] szExpandedFilename;
				bRet = false;
				break;
			}
		}
		
#if VERBOSE_LOG
		sprintf(szTemp, "Processing %s", szExpandedFilename);
		LogMessage(MSG_INFO, szTemp);
#endif

		//Call MOF Compiler with (pszMofs);
     	mbstowcs(wFileName, szExpandedFilename, MAX_PATH);
       	SCODE sRet = pCompiler->CompileFile(wFileName, NULL, NULL, NULL, NULL, 0, 0, 0, &statusInfo);
		if (sRet != S_OK)
		{
			//This MOF failed to load.
			if (szMOFFailureList.Length())
				szMOFFailureList += "\n";
			szMOFFailureList += szExpandedFilename;

			sprintf(szTemp, "An error occurred while processing item %li defined on lines %li - %li in file %s",
					statusInfo.ObjectNum, statusInfo.FirstLine, statusInfo.LastLine, szExpandedFilename);
			LogMessage(MSG_ERROR, szTemp);

			bRet = false;
		}
		delete [] szExpandedFilename;

		//Move on to the next string
		pszMofs += strlen(pszMofs) + 1;
	}	// end while

	LogMessage(MSG_INFO, "Mof load completed.");

	return bRet;
}

void LogMessage(MsgType msgType, const char *pszMessage)
{
	char pszSetupMessage[MAX_MSG_TEXT_LENGTH];
	const char* pszCR = "\r\n";

	//Load messages from the resource
	switch (msgType)
	{
		case MSG_ERROR:
			strcpy(pszSetupMessage, "ERROR: ");
			break;
		case MSG_WARNING:
			strcpy(pszSetupMessage, "WARNING: ");
			break;
		case MSG_INFO:
		default:
			strcpy(pszSetupMessage, "");
			break;
	}

	char* pszNewMessage = new char[strlen(pszMessage) + 1];
	if (!pszNewMessage)
	{
		// we failed to allocate memory for the message, so no logging :(
		return;
	}
	strcpy(pszNewMessage, pszMessage);

	// get log file path and name
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		// no messages will be logged because we don't know where to write the log :(
		return;		
	}	

	char* pszFullDirectory = NULL;
	if (r.GetStr("Logging Directory", &pszFullDirectory))
	{
		// no messages will be logged because we don't know where to write the log :(
		return;		
	}
	if (!pszFullDirectory)
	{
		// no messages will be logged because we don't know where to write the log :(
		return;		
	}

	char* pszFilename = "setup.log";
	char* pszFullPath = new char [strlen(pszFullDirectory) + strlen("\\") + strlen(pszFilename) + 1];
	if (!pszFullPath)
	{
		// we failed to allocate memory for the path, so no logging :(
		delete [] pszNewMessage;
		return;
	}

	strcpy(pszFullPath, pszFullDirectory);
	strcat(pszFullPath, "\\");
	strcat(pszFullPath, pszFilename);
	delete [] pszFullDirectory;

    // Get time
    char timebuf[64];
    time_t now = time(0);
    struct tm *local = localtime(&now);
    if(local)
    {
        strcpy(timebuf, asctime(local));
        timebuf[strlen(timebuf) - 1] = 0;
    }
    else
        strcpy(timebuf,"unknown time");

	char* pszTime = new char [strlen(timebuf) + strlen("(): ") + 1];
	if (!pszTime)
	{
		// we failed to allocate memory for the time, so no logging :(

		delete [] pszNewMessage;
		delete [] pszFullPath;
		return;
	}

	strcpy(pszTime, "(");
	strcat(pszTime, timebuf);
	strcat(pszTime, "): ");

	// write messages to log file
	HANDLE hFile = CreateFile(pszFullPath, GENERIC_WRITE, 0, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		char* psz;
		DWORD dwWritten;
		SetFilePointer(hFile, 0, 0, FILE_END);
		psz = strtok(pszNewMessage, "\n");
		while (psz)
		{
			WriteFile(hFile, pszTime, strlen(pszTime), &dwWritten, 0);
			WriteFile(hFile, pszSetupMessage, strlen(pszSetupMessage), &dwWritten, 0);
			WriteFile(hFile, psz, strlen(psz), &dwWritten, 0);
			WriteFile(hFile, pszCR, strlen(pszCR), &dwWritten, 0);
			psz = strtok(NULL, "\n");
		}
		CloseHandle(hFile);
	}

	delete [] pszNewMessage;
	delete [] pszFullPath;
	delete [] pszTime;
}

void SetSNMPBuildRegValue()
{
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to set SNMP build reg value.");
		return;
	}
	
	char* pszBuildNo = new char[10];

	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(GetVersionEx(&os))
	{
		sprintf(pszBuildNo, "%lu.0000", os.dwBuildNumber);
	}
	r.SetStr("SNMP Build", pszBuildNo);

	delete [] pszBuildNo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\reg.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define WBEM_REG_WBEM					"Software\\Microsoft\\WBEM"
#define WBEM_REG_WINMGMT				"Software\\Microsoft\\WBEM\\CIMOM"
#define WBEM_REG_AUTORECOVER			"Autorecover MOFs"
#define WBEM_REG_AUTORECOVER_EMPTY		"Autorecover MOFs (empty)"
#define WBEM_REG_AUTORECOVER_RECOVERED	"Autorecover MOFs (recovered)"
#define SYSTEM_SETUP_REG				"System\\Setup"

class Registry
{
    HKEY	hPrimaryKey;
    HKEY	hSubkey;
    int		m_nStatus;
	LONG	m_nLastError;
public:
    enum { no_error, failed };

	Registry(char *pszLocalMachineStartKey);
	~Registry();
	int Open(HKEY hStart, const char *pszStartKey);
	int GetStr(const char *pszValueName, char **pValue);
	char* GetMultiStr(const char *pszValueName, DWORD &dwSize);
	int SetMultiStr(const char *pszValueName, const char*pData, DWORD dwSize);
	int DeleteEntry(const char *pszValueName);
	int SetStr(char *pszValueName, char *pszValue);
    int GetDWORD(TCHAR *pszValueName, DWORD *pdwValue);
    int SetDWORDStr(char *pszValueName, DWORD dwValue);
	int GetStatus() { return m_nStatus;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\str.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"

char *__g_pszStringBlank = "\0";	//Needs to be double terminated for the multi-string!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\reg.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "reg.h"
#include <stdio.h>

Registry::Registry(char *pszLocalMachineStartKey)
{
    hPrimaryKey	= 0;
    hSubkey = 0;
    m_nStatus = Open(HKEY_LOCAL_MACHINE, pszLocalMachineStartKey);
    hSubkey = hPrimaryKey;
}
Registry::~Registry()
{
    if (hSubkey)
        RegCloseKey(hSubkey);
    if (hPrimaryKey != hSubkey)
        RegCloseKey(hPrimaryKey);
}
int Registry::Open(HKEY hStart, const char *pszStartKey)
{
    int nStatus = no_error;
    DWORD dwDisp = 0;

	m_nLastError = RegCreateKeyEx(hStart, pszStartKey,
									0, 0, 0,
									KEY_ALL_ACCESS, 0, &hPrimaryKey, &dwDisp);

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}
char* Registry::GetMultiStr(const char *pszValueName, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return NULL;
	}
	if (dwSize == 0)
	{
		return NULL;
	}

	//allocate the buffer required
	char *pData = new char[dwSize];
	if (!pData)
	{
		dwSize = 0;
		return NULL;
	}
	
	//get the values
	m_nLastError = RegQueryValueEx(hSubkey, 
								   pszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return NULL;
	}

	return pData;
}

int Registry::SetMultiStr(const char *pszValueName, const char*pszValue, DWORD dwSize)
{
	m_nLastError = RegSetValueEx(hSubkey, 
								 pszValueName, 
								 0, 
								 REG_MULTI_SZ, 
								 LPBYTE(pszValue), 
								 dwSize);

    if (m_nLastError != 0)
		return failed;

    return no_error;
}

int Registry::GetStr(const char *pszValueName, char **pValue)
{
    *pValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
		return failed;

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        return failed;

    char *p = new char[dwSize];
	if (!p)
		return failed;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
		char tTemp;

		// Get the initial length
        DWORD nSize = ExpandEnvironmentStrings(p,&tTemp,1) + 1;
        TCHAR* pTemp = new TCHAR[nSize+1];
		if (!pTemp)
			return failed;

        if (!ExpandEnvironmentStrings(p,pTemp,nSize+1))
		{
			delete [] p;
			delete [] pTemp;
			return failed;
		}

        delete [] p;
        *pValue = pTemp;
    }
    else
        *pValue = p;
    return no_error;
}

int Registry::DeleteEntry(const char *pszValueName)
{
	m_nLastError = RegDeleteValue(  hSubkey, pszValueName);
	if (m_nLastError != 0)
	{
		return failed;
	}
	else
		return no_error;
}
int Registry::SetStr(char *pszValueName, char *pszValue)
{
	m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(pszValue),
        strlen(pszValue) + 1);

    if (m_nLastError != 0)
		return failed;
    return no_error;
}

int Registry::GetDWORD(TCHAR *pszValueName, DWORD *pdwValue)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_DWORD)
        return failed;

    return no_error;
}

int Registry::SetDWORDStr(char *pszValueName, DWORD dwVal)
{
    char cTemp[30];
    sprintf(cTemp, "%d", dwVal);

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(cTemp),
		strlen(cTemp) + 1);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//


#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the global dll functions

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "precomp.h"
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <olectl.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <windows.h>
#include <stdio.h>
#include <provexpt.h>
#include <tchar.h>
#include <wbemidl.h>
#include <provcoll.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

//OK we need these globals
HINSTANCE   g_hInst = NULL;
ProvDebugLog* CViewProvServ::sm_debugLog = NULL;
IUnsecuredApartment* CViewProvServ::sm_UnsecApp = NULL;

CRITICAL_SECTION g_CriticalSection;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{

	BOOL status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		//ProvThreadObject :: ProcessDetach (TRUE) ;
		DeleteCriticalSection(&g_CriticalSection);
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		g_hInst=hInstance;
		//ProvThreadObject :: ProcessAttach () ;
		InitializeCriticalSection(&g_CriticalSection);
		DisableThreadLibraryCalls(hInstance);
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
    }

    return status;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ;
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection(&g_CriticalSection);

		if (CViewProvServ::sm_debugLog == NULL)
		{
			ProvDebugLog::Startup();
			CViewProvServ::sm_debugLog = new ProvDebugLog(_T("ViewProvider"));;
		}

		if ( rclsid == CLSID_CViewProviderClassFactory ) 
		{
			CViewProvClassFactory *lpunk = new CViewProvClassFactory;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;

				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
			}
		}
		else
		{
			status = CLASS_E_CLASSNOTAVAILABLE ;
		}

		LeaveCriticalSection(&g_CriticalSection);
	}
	catch(Structured_Exception e_SE)
	{
		status = E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		status = E_OUTOFMEMORY;
	}
	catch(...)
	{
		status = E_UNEXPECTED;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	BOOL unload = FALSE;
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection(&g_CriticalSection);

		unload = (0 == CViewProvClassFactory :: locksInProgress)
						&& (0 == CViewProvClassFactory :: objectsInProgress);

		if (unload)
		{
			if (CViewProvServ::sm_debugLog != NULL)
			{
				delete CViewProvServ::sm_debugLog;
				CViewProvServ::sm_debugLog = NULL;
				ProvDebugLog::Closedown();
			}

			if (NULL != CViewProvServ::sm_UnsecApp)
			{
				CViewProvServ::sm_UnsecApp->Release();
				CViewProvServ::sm_UnsecApp = NULL;
			}

		}

		LeaveCriticalSection(&g_CriticalSection);
	}
	catch(Structured_Exception e_SE)
	{
		unload = FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		unload = FALSE;
	}
	catch(...)
	{
		unload = FALSE;
	}

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

//Strings used during self registeration

#define REG_FORMAT2_STR			_T("%s%s")
#define REG_FORMAT3_STR			_T("%s%s\\%s")
#define VER_IND_STR				_T("VersionIndependentProgID")
#define NOT_INTERT_STR			_T("NotInsertable")
#define INPROC32_STR			_T("InprocServer32")
#define PROGID_STR				_T("ProgID")
#define THREADING_MODULE_STR	_T("ThreadingModel")
#define APARTMENT_STR			_T("Both")

#define CLSID_STR				_T("CLSID\\")

#define PROVIDER_NAME_STR		_T("Microsoft WBEM View Provider")
#define PROVIDER_STR			_T("WBEM.VIEW.PROVIDER")
#define PROVIDER_CVER_STR		_T("WBEM.VIEW.PROVIDER\\CurVer")
#define PROVIDER_CLSID_STR		_T("WBEM.VIEW.PROVIDER\\CLSID")
#define PROVIDER_VER_CLSID_STR	_T("WBEM.VIEW.PROVIDER.0\\CLSID")
#define PROVIDER_VER_STR		_T("WBEM.VIEW.PROVIDER.0")

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(TCHAR* pszKey, TCHAR* pszSubkey, TCHAR* pszValueName, TCHAR* pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

	_tcscpy(szKey, HKEYCLASSES);
    _tcscat(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		_tcscat(szKey, _T("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);

    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI DllRegisterServer()
{
	SetStructuredExceptionHandler seh;

	try
	{
		TCHAR szModule[MAX_PATH + 1];
		GetModuleFileName(g_hInst,(TCHAR*)szModule, MAX_PATH + 1);
		TCHAR szProviderClassID[128];
		TCHAR szProviderCLSIDClassID[128];
#ifndef UNICODE
		wchar_t t_strGUID[128];

		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, t_strGUID, 128))
		{
			return SELFREG_E_CLASS;
		}

		if (0 == WideCharToMultiByte(CP_ACP,
							0,
							t_strGUID,
							-1,
							szProviderClassID,
							128,
							NULL,
							NULL))
		{
			return SELFREG_E_CLASS;
	}
#else
		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, szProviderClassID, 128))
		{
			return SELFREG_E_CLASS;
		}
#endif

		_tcscpy(szProviderCLSIDClassID,CLSID_STR);
		_tcscat(szProviderCLSIDClassID,szProviderClassID);

			//Create entries under CLSID
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
			return SELFREG_E_CLASS;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
	HRESULT hr = S_OK;
	SetStructuredExceptionHandler seh;

	try
	{
		TCHAR szTemp[128];
		TCHAR szProviderClassID[128];
		TCHAR szProviderCLSIDClassID[128];
#ifndef UNICODE
		wchar_t t_strGUID[128];

		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, t_strGUID, 128))
		{
			return SELFREG_E_CLASS;
		}

		if (0 == WideCharToMultiByte(CP_ACP,
							0,
							t_strGUID,
							-1,
							szProviderClassID,
							128,
							NULL,
							NULL))
		{
			return SELFREG_E_CLASS;
		}
#else
		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, szProviderClassID, 128))
		{
			return SELFREG_E_CLASS;
		}
#endif

		_tcscpy(szProviderCLSIDClassID,CLSID_STR);
		_tcscat(szProviderCLSIDClassID,szProviderClassID);

		//Delete entries under CLSID
		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, PROGID_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, VER_IND_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, NOT_INTERT_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, INPROC32_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, szProviderCLSIDClassID);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}
	}
	catch(Structured_Exception e_SE)
	{
		hr = E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		hr = E_OUTOFMEMORY;
	}
	catch(...)
	{
		hr = E_UNEXPECTED;
	}

    return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


WMIPRECOMPSHARED=1
USE_RTTI=1
USE_NATIVE_EH=ASYNC

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=viewprov
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS= \
    $(FRAMEWORK_EXPT_LIB) \
	$(FRAMEWORK_THRD_LIB) \
	$(FRAMEWORK_MFC_LIB) \
	$(FRAMEWORK_PARSER_LIB) \
	$(UTILLIB_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\activeds.lib \
	$(SDK_LIB_PATH)\adsiid.lib   \
	$(SDK_LIB_PATH)\advapi32.lib

INCLUDES=$(INCLUDES); \
	..\include; \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \
	$(UTILLIB_INC); \
	$(FRAMEWORK_THRD_INC); \
	$(FRAMEWORK_PARSER_INC); \
	$(FRAMEWORK_MFC_INC); \
	$(FRAMEWORK_EXPT_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \

SOURCES=\
	..\viewprov.rc	\
	..\maindll.cpp	\
	..\vpcfac.cpp \
	..\vpserv.cpp \
	..\vpget.cpp \
	..\vpput.cpp \
	..\vpquery.cpp \
	..\vpmthd.cpp \
	..\vpquals.cpp \
	..\vptasks.cpp \
	..\vptasksu.cpp \
	..\vptasksh.cpp \
	..\vptasksj.cpp \
	..\vpsinks.cpp \
	..\vp_core_qengine.cpp


# Next, specify options for the compiler using C_DEFINES. 
#C_DEFINES=$(C_DEFINES) -DLOCAL_SERVER -D_WIN32_DCOM -DVP_BUILD_AS_EXE -DVP_PERFORMANT_JOINS
C_DEFINES=$(C_DEFINES) -DVP_PERFORMANT_JOINS
USE_MSVCRT=1
USE_VCCOM=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\viewprov.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\main.cpp ===
//***************************************************************************

//

//  MAIND.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the global EXE functions

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "precomp.h"
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <olectl.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <stdio.h>
#include <tchar.h>
#include <wbemidl.h>
#include <provcoll.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

//OK we need these globals
ProvDebugLog* CViewProvServ::sm_debugLog = NULL;
IUnsecuredApartment* CViewProvServ::sm_UnsecApp = NULL;

CRITICAL_SECTION g_CriticalSection;

HMODULE ghOle32 = NULL;
BOOL s_Exiting = FALSE;

typedef HRESULT (WINAPI* PFNCOINITIALIZEEX)(void* pvReserved,  //Reserved  
                                            DWORD dwCoInit      //COINIT value
                                            );

typedef HRESULT (WINAPI* PFNCOINITIALIZESECURITY)(
								PSECURITY_DESCRIPTOR         pSecDesc,
								LONG                         cAuthSvc,
								SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
								void                        *pReserved1,
								DWORD                        dwAuthnLevel,
								DWORD                        dwImpLevel,
								void                        *pReserved2,
								DWORD                        dwCapabilities,
								void                        *pReserved3 );

HRESULT COMInit();
STDAPI ExeRegisterServer(void);
STDAPI ExeUnregisterServer(void);
CViewProvClassFactory *g_lpunk;

BOOL StartupVP (DWORD *pdwClassFac)
{
	InitializeCriticalSection(&g_CriticalSection);
	ProvDebugLog::Startup();
	CViewProvServ::sm_debugLog = new ProvDebugLog(_T("ViewProvider"));;
	g_lpunk = new CViewProvClassFactory;
	g_lpunk->AddRef();

	HRESULT hr = CoRegisterClassObject(
						  CLSID_CViewProviderClassFactory,			//Class identifier (CLSID) to be registered
						  (IUnknown *) g_lpunk,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  pdwClassFac								//Pointer to the value returned
						  );

	return (SUCCEEDED(hr));
}

void ShutdownVP(DWORD dwClassFac)
{
	delete CViewProvServ::sm_debugLog;
	CViewProvServ::sm_debugLog = NULL;
	ProvDebugLog::Closedown();

	if (NULL != CViewProvServ::sm_UnsecApp)
	{
		CViewProvServ::sm_UnsecApp->Release();
		CViewProvServ::sm_UnsecApp = NULL;
	}

	if (g_lpunk)
	{
		g_lpunk->Release();
	}

	CoRevokeClassObject(dwClassFac);
	DeleteCriticalSection(&g_CriticalSection);
}

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;

		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeRegisterServer();
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeUnregisterServer();
			}
            else if(_tcsicmp(t_Arg, _TEXT ( "/EMBEDDING" ) ) == 0)
		    {
			    // COM called us, so this is the real thing...
                t_Exit = FALSE;
		    }
		}
	}

	return t_Exit ;
}

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static TCHAR *t_TemplateCode = _TEXT("TemplateCode - View Provider") ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	if (t_HWnd)
	{
		ShowWindow ( t_HWnd, SW_SHOW ) ;
	}

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = WindowsInit(a_Handle);

	return t_HWnd;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting ) 
            return ;
	}
}


int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	BOOL t_Exit = ParseCommandLine();

	if (!t_Exit) 
	{
		// Initialize the COM Library.
		HRESULT hr = COMInit();

		HWND hWnd = WindowsStart(hInstance);

		if (hWnd)
		{
			DWORD dw = 0;

			if (StartupVP(&dw))
			{
				WindowsDispatch();
				ShutdownVP(dw);
			}

			WindowsStop(hWnd);
		}

		// Uninitialize the COM Library.
		::CoUninitialize() ;
	}

	return 0 ;
}


//Strings used during self registeration

#define REG_FORMAT2_STR			_T("%s%s")
#define REG_FORMAT3_STR			_T("%s%s\\%s")
#define VER_IND_STR				_T("VersionIndependentProgID")
#define NOT_INTERT_STR			_T("NotInsertable")
#define LOCALSRV32_STR			_T("LocalServer32")
#define PROGID_STR				_T("ProgID")
#define THREADING_MODULE_STR	_T("ThreadingModel")
#define APARTMENT_STR			_T("Both")

#define CLSID_STR				_T("CLSID\\")

#define PROVIDER_NAME_STR		_T("Microsoft WBEM View Provider")
#define PROVIDER_STR			_T("WBEM.VIEW.PROVIDER")
#define PROVIDER_CVER_STR		_T("WBEM.VIEW.PROVIDER\\CurVer")
#define PROVIDER_CLSID_STR		_T("WBEM.VIEW.PROVIDER\\CLSID")
#define PROVIDER_VER_CLSID_STR	_T("WBEM.VIEW.PROVIDER.0\\CLSID")
#define PROVIDER_VER_STR		_T("WBEM.VIEW.PROVIDER.0")

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(TCHAR* pszKey, TCHAR* pszSubkey, TCHAR* pszValueName, TCHAR* pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

	_tcscpy(szKey, HKEYCLASSES);
    _tcscat(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		_tcscat(szKey, _T("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);

    return TRUE;
}

//***************************************************************************
//
// ExeRegisterServer
//
// Purpose: Called when /register is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeRegisterServer(void)
{   
	TCHAR szModule[MAX_PATH + 1];
	HINSTANCE hInst = GetModuleHandle(_T("VIEWPROV"));
	GetModuleFileName(hInst,(TCHAR*)szModule, MAX_PATH + 1);
	TCHAR szProviderClassID[128];
	TCHAR szProviderCLSIDClassID[128];
#ifndef UNICODE
	wchar_t t_strGUID[128];

	if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, t_strGUID, 128))
	{
		return SELFREG_E_CLASS;
	}

	if (0 == WideCharToMultiByte(CP_ACP,
						0,
						t_strGUID,
						-1,
						szProviderClassID,
						128,
						NULL,
						NULL))
	{
		return SELFREG_E_CLASS;
	}
#else
	if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, szProviderClassID, 128))
	{
		return SELFREG_E_CLASS;
	}
#endif

	_tcscpy(szProviderCLSIDClassID,CLSID_STR);
	_tcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSRV32_STR, NULL,szModule))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSRV32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

//***************************************************************************
//
// ExeUnregisterServer
//
// Purpose: Called when /unregister is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeUnregisterServer(void)
{
	TCHAR szTemp[128];
	TCHAR szProviderClassID[128];
	TCHAR szProviderCLSIDClassID[128];
#ifndef UNICODE
	wchar_t t_strGUID[128];

	if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, t_strGUID, 128))
	{
		return SELFREG_E_CLASS;
	}

	if (0 == WideCharToMultiByte(CP_ACP,
						0,
						t_strGUID,
						-1,
						szProviderClassID,
						128,
						NULL,
						NULL))
	{
		return SELFREG_E_CLASS;
	}
#else
	if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, szProviderClassID, 128))
	{
		return SELFREG_E_CLASS;
	}
#endif

	HRESULT hr = S_OK;
	_tcscpy(szProviderCLSIDClassID,CLSID_STR);
	_tcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete ProgID keys
	_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_CVER_STR);

	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_CLSID_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}
	
	_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	//Delete VersionIndependentProgID keys
	_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_VER_CLSID_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_VER_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	//Delete entries under CLSID
	_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, PROGID_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, VER_IND_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, NOT_INTERT_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, LOCALSRV32_STR);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

	_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, szProviderCLSIDClassID);
	
	if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
	{
		hr = SELFREG_E_CLASS;
	}

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
HRESULT COMInit()
{
    HRESULT hr;
    PFNCOINITIALIZESECURITY pfnCoInitializeSecurity = NULL;
    PFNCOINITIALIZEEX pfnCoInitializeEx = NULL;

   	
    //Get handle to COM library 
    ghOle32 = LoadLibraryEx(_T("ole32.dll"), NULL, 0);

    if(ghOle32 != NULL) 
    {                                            
	    //Get ptr to functions CoInitialize and CoInitializeSecurity.
        pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress(ghOle32, 
                                                   "CoInitializeEx");
        pfnCoInitializeSecurity = (PFNCOINITIALIZESECURITY) GetProcAddress(ghOle32, 
                                             "CoInitializeSecurity");

        //Initialize COM
	    if (pfnCoInitializeEx) 
	    {
	        hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
        }
	    else 
	    {
            hr = CoInitialize(NULL);
	    }

	    if(FAILED(hr))
	    {
		    FreeLibrary(ghOle32);
            ghOle32 = NULL;
            return E_FAIL;
	    }
	  
	    //Initialize Security
	    if (pfnCoInitializeSecurity)
	    {
		    hr = pfnCoInitializeSecurity(NULL, -1, NULL, NULL, 
		      							   RPC_C_AUTHN_LEVEL_CONNECT, 
			       						   RPC_C_IMP_LEVEL_IMPERSONATE, 
     				   					   NULL, EOAC_NONE, 0);
        }
	
	    if(FAILED(hr))
	    {
	        CoUninitialize();
	        FreeLibrary(ghOle32);
            ghOle32 = NULL;
	        return E_FAIL;
	    }

    }
    else
    {
	    return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpcfac.cpp ===
//***************************************************************************

//

//  VPCFAC.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <vpserv.h>
#include <vpcfac.h>

extern CRITICAL_SECTION g_CriticalSection;

LONG CViewProvClassFactory :: objectsInProgress = 0 ;
LONG CViewProvClassFactory :: locksInProgress = 0 ;


//***************************************************************************
//
// CViewProvClassFactory::CViewProvClassFactory
// CViewProvClassFactory::~CViewProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CViewProvClassFactory::CViewProvClassFactory ()
{
	EnterCriticalSection(&g_CriticalSection);
	objectsInProgress++;
	LeaveCriticalSection(&g_CriticalSection);
	m_referenceCount = 0 ;
}

CViewProvClassFactory::~CViewProvClassFactory ()
{
	EnterCriticalSection(&g_CriticalSection);
	objectsInProgress--;
	LeaveCriticalSection(&g_CriticalSection);
}

//***************************************************************************
//
// CViewProvClassFactory::QueryInterface
// CViewProvClassFactory::AddRef
// CViewProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CViewProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CViewProvClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( &m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CViewProvClassFactory :: Release ()
{	
	SetStructuredExceptionHandler seh;
	LONG ref = 0;

	try
	{
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		ref = 0;
	}
	catch(Heap_Exception e_HE)
	{
		ref = 0;
	}
	catch(...)
	{
		ref = 0;
	}

	return ref ;
}

//***************************************************************************
//
// CViewProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CViewProvClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

}

//***************************************************************************
//
// CViewProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CViewProvClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	HRESULT status = E_FAIL;

	SetStructuredExceptionHandler seh;

	try
	{
		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION;
		}
		else 
		{
			CViewProvServ* prov =  new CViewProvServ;
			status = prov->QueryInterface (riid, ppvObject);

			if (NOERROR != status)
			{
				delete prov;
			}
		}
	}
	catch(Structured_Exception e_SE)
	{
		status = E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		status = E_OUTOFMEMORY;
	}
	catch(...)
	{
		status = E_UNEXPECTED;
	}

	return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\str.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
extern 	char *__g_pszStringBlank;

class CString
{
private:
	char *m_pszString;

	void DeleteString() { if (m_pszString != __g_pszStringBlank) delete [] m_pszString; } 
	char *DuplicateString()
	{
		char *psz = new char[strlen(m_pszString) + 1];
		if (psz == NULL)
			return NULL;
		strcpy(psz, m_pszString);
		return psz;
	}
public:
	CString() 
	{
		m_pszString = __g_pszStringBlank;
	}
	CString (const char *psz)
	{
		m_pszString = new char[strlen(psz) + 1];
		if (m_pszString == 0)
		{
			m_pszString = __g_pszStringBlank;
		}
		else
		{
			strcpy(m_pszString, psz);
		}
	}
	CString (CString &sz)
	{
		m_pszString = __g_pszStringBlank;
		*this = sz.m_pszString;
	}
	~CString() { DeleteString(); }
    size_t Length() const { return strlen(m_pszString); }    //09/17//int Length() const { return strlen(m_pszString); }
    CString& operator +=(const char *psz)
	{
		char *pszNewString = new char[Length() + strlen(psz) + 1];
		if (pszNewString == NULL)
			return *this;
		strcpy(pszNewString, m_pszString);
		strcat(pszNewString, psz);

		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}
	CString &operator = (const char *psz)
	{
		char *pszNewString = new char[strlen(psz) + 1];
		if (pszNewString == 0)
			return *this;
		strcpy(pszNewString, psz);
		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}
	char *Unbind()
	{
		if (m_pszString != __g_pszStringBlank)
		{
			char *psz = m_pszString;
			m_pszString = NULL;
			return psz;
		}
		else
			return DuplicateString();
	}
	char operator[](size_t nIndex) const	//09/17//char operator[](int nIndex) const
	{
		if (nIndex > Length())
			nIndex = Length();
		return m_pszString[nIndex];
	}

	operator const char *() { return m_pszString; }
};


class CMultiString
{
private:
	char *m_pszString;

	void DeleteString() { if (m_pszString != __g_pszStringBlank) delete [] m_pszString; } 
	char *DuplicateString()
	{
		char *psz = new char[Length(m_pszString) + 1];
		if (psz == NULL)
			return NULL;
		memcpy(psz, m_pszString, Length(m_pszString) + 1);
		return psz;
	}
	size_t Length(const char *psz) const	//09/17//int Length(const char *psz) const
	{
		size_t nLen = 0;
		while (*psz != '\0')
		{
			nLen += strlen(psz) + 1;
			psz += strlen(psz) + 1;
		}
		return nLen; 
	}
public:
	CMultiString() 
	{
		m_pszString = __g_pszStringBlank;
	}
	CMultiString (const char *psz)
	{
		m_pszString = new char[strlen(psz) + 1];
		if (m_pszString == NULL)
		{
			m_pszString = __g_pszStringBlank;
		}
		else
		{
			strcpy(m_pszString, psz);
		}
	}
	~CMultiString() { DeleteString(); }
    size_t Length() const //09/17//int Length() const
	{ 
		return Length(m_pszString);
	}
    CMultiString& operator +=(const char *psz)
	{
		size_t nLength = Length() + strlen(psz) + 3;
		char *pszNewString = new char[nLength];
		if (pszNewString == NULL)
			return *this;
		memcpy(pszNewString, m_pszString, Length());
		memcpy(pszNewString + Length(), psz, strlen(psz) + 1);
		pszNewString[Length() + strlen(psz) + 1] = '\0';

		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}
	void AddUnique(const char *pszNew)
	{
		bool bFound = false;
		const char *psz = m_pszString;
		while (psz && *psz)
		{
			if (_stricmp(psz, pszNew) == 0)
			{
				bFound = true;
				break;
			}
			psz += strlen(psz) + 1;
		}
		if (!bFound)
		{
			*this += pszNew;
		}
	}
	char *Unbind()
	{
		if (m_pszString != __g_pszStringBlank)
		{
			char *psz = m_pszString;
			m_pszString = NULL;
			return psz;
		}
		else
			return DuplicateString();
	}
	char operator[](size_t nIndex) const	//09/17//char operator[](int nIndex) const
	{
		if (nIndex > Length())
			nIndex = Length();
		return m_pszString[nIndex];
	}

	operator const char *() { return m_pszString; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpget.cpp ===
//***************************************************************************

//

//  VPGET.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the GetObject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>


GetObjectTaskObject::GetObjectTaskObject(CViewProvServ *a_Provider, 
	wchar_t *a_ObjectPath, ULONG a_Flag, IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *pCtx, IWbemServices* a_Serv, CWbemServerWrap *a_ServerWrap)
: WbemTaskObject (a_Provider, a_NotificationHandler, a_Flag, pCtx, a_Serv, a_ServerWrap),
	m_ObjectPath(NULL),
	m_ParsedObjectPath(NULL)
{
	m_ObjectPath = UnicodeStringDuplicate(a_ObjectPath);
}

GetObjectTaskObject::~GetObjectTaskObject ()
{
	BOOL t_Status = TRUE;

	if (m_bIndicate)
	{
		IWbemClassObject *t_NotifyStatus = NULL ;

		if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
		{
			t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		}

		if ( t_Status )
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
			
			if (t_NotifyStatus)
			{
				t_NotifyStatus->Release () ;
			}
		}
		else
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
		}
	}

	if (m_ObjectPath != NULL)
	{
		delete [] m_ObjectPath;
	}

	if (NULL != m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath;
	}

	if (m_StatusHandle != NULL)
	{
		CloseHandle(m_StatusHandle);
	}
}

BOOL GetObjectTaskObject::PerformGet(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst, const wchar_t* src, BOOL bAllprops)
{
	m_StatusHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
	
	if (m_StatusHandle == NULL)
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to create an Synchronization object" ) ;
		return FALSE;
	}

	BOOL retVal = PerformQueries(a_ErrorObject, bAllprops);
	BOOL bWait = TRUE;

	while (retVal && bWait)
	{
		DWORD dwWait = WbemWaitForSingleObject(m_StatusHandle, VP_QUERY_TIMEOUT);

		switch(dwWait)
		{
			case  WAIT_OBJECT_0:
			{
				retVal = ProcessResults(a_ErrorObject, pInst, src);
				bWait = FALSE;
			}
			break;

			case WAIT_TIMEOUT:
			{
				BOOL bCleanup = TRUE;

				if (m_ArrayLock.Lock())
				{
					if (m_ResultReceived)
					{
						m_ResultReceived = FALSE;
						bCleanup = FALSE;
					}

					m_ArrayLock.Unlock();
				}

				if (bCleanup)
				{
					CleanUpObjSinks(TRUE);
					a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed, or query timed out" ) ;
					retVal = FALSE;
					bWait = FALSE;
				}
			}
			break;

			default:
			{
				//Cancel outstanding requests and delete object sinks...
				//======================================================
				CleanUpObjSinks(TRUE);
				a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed" ) ;
				retVal = FALSE;
				bWait = FALSE;
			}
		}
	}

	return retVal;
}

BOOL GetObjectTaskObject::PerformQueries(WbemProvErrorObject &a_ErrorObject, BOOL bAllprops)
{
	//need enough tokens to handle association work-around serverpath or dotpath or relpath
	SQL_LEVEL_1_TOKEN* tokArray = new SQL_LEVEL_1_TOKEN[(m_ParsedObjectPath->m_dwNumKeys) * 6];
	m_iQueriesAsked++;
	m_ObjSinkArray.SetSize(0, m_NSpaceArray.GetSize());

	//m_NSpaceArray size is 1 for associations
	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		BOOL bContinue = TRUE;
		DWORD dwToks = 0;
		BOOL bFirst = TRUE;

		for (int i = 0; i < m_ParsedObjectPath->m_dwNumKeys; i++)
		{
			CPropertyQualifierItem* propItem;
			BOOL bFoundKey = FALSE;

			if (m_ParsedObjectPath->m_paKeys[i]->m_pName != NULL)
			{
				bFoundKey = m_PropertyMap.Lookup(m_ParsedObjectPath->m_paKeys[i]->m_pName, propItem);
			}
			else if (m_ParsedObjectPath->m_dwNumKeys == 1)
			{
				POSITION pos = m_PropertyMap.GetStartPosition();

				while (pos)
				{
					CStringW itmName;
					m_PropertyMap.GetNextAssoc(pos, itmName, propItem);
				
					if (propItem->IsKey())
					{
						bFoundKey = TRUE;
						break;
					}
				}
			}

			if (bFoundKey)
			{
				if (!propItem->m_SrcPropertyNames[x].IsEmpty())
				{
					tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
					tokArray[dwToks].nOperator = SQL_LEVEL_1_TOKEN::OP_EQUAL;
					tokArray[dwToks].pPropertyName = propItem->m_SrcPropertyNames[x].AllocSysString();
					
					if (m_bAssoc && (propItem->GetCimType() == CIM_REFERENCE))
					{
						bContinue = TransposeReference(propItem, m_ParsedObjectPath->m_paKeys[i]->m_vValue,
														&(tokArray[dwToks].vConstValue), FALSE, NULL);

						if (!bContinue)
						{
							break;
						}
						else
						{
							//add the extra tokens if neccessary
							//for the association work-around
							wchar_t *t_pChar = tokArray[dwToks].vConstValue.bstrVal;

							//must be \\server\namespace and not \\.\namespace or relpath
							if ( (*t_pChar == L'\\') && (*(t_pChar+1) == L'\\') && (*(t_pChar+2) != L'.') )
							{
								//add the dotted version
								tokArray[dwToks + 1] = tokArray[dwToks];
								dwToks++;
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 2;
								
								while (*t_pChar != L'\\')
								{
									t_pChar++;
								}

								--t_pChar;
								*t_pChar = L'.';
								--t_pChar;
								*t_pChar = L'\\';
								--t_pChar;
								*t_pChar = L'\\';
								BSTR t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;

								//add the relpath version
								tokArray[dwToks + 1] = tokArray[dwToks - 1];
								dwToks++;
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 4;
								
								while (*t_pChar != L':')
								{
									t_pChar++;
								}

								//exclude the ':'
								t_pChar++;
								t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
							}
						}
					}
					else
					{
						VariantInit(&(tokArray[dwToks].vConstValue));

                        if (FAILED(VariantCopy(&(tokArray[dwToks].vConstValue),
								&(m_ParsedObjectPath->m_paKeys[i]->m_vValue))))
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
					}

					//after every key add an AND
					//except if this is the first key && there is no where clause
					dwToks++;

					if ((!bFirst) || (m_SourceArray[x]->GetRPNExpression()->nNumTokens != 0))
					{
						tokArray[dwToks++].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;				
					}

					bFirst = FALSE;
				}
			}
		}

		if (bContinue)
		{
			CStringW queryStr = GetStringFromRPN(m_SourceArray[x]->GetRPNExpression(), dwToks, tokArray, bAllprops);
			CObjectSinkResults * objSnk = new CObjectSinkResults(this, x);
			objSnk->AddRef();
			m_ObjSinkArray.SetAtGrow(x, objSnk);
			CWbemServerWrap** nsPtrs = m_NSpaceArray[x]->GetServerPtrs();

			for (int m = 0; m < m_NSpaceArray[x]->GetCount(); m++)
			{
				if (nsPtrs[m] != NULL)
				{
					CViewProvObjectSink* pSnk = new CViewProvObjectSink(objSnk, nsPtrs[m], m);
					pSnk->AddRef();
					BSTR queryBStr = queryStr.AllocSysString();
					BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);
					IWbemObjectSink* pQuerySink = pSnk;
					IWbemContext * t_pCtx = m_Ctx;

					if (nsPtrs[m]->IsRemote())
					{
						pQuerySink = pSnk->Associate();
						t_pCtx = NULL; //don't use context for remote calls
					}

					IWbemServices *ptmpServ = nsPtrs[m]->GetServerOrProxy();

					if (ptmpServ)
					{
						if ( pQuerySink )
						{
							HRESULT t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);

							if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[m]->IsRemote())
							{
								if ( SUCCEEDED(UpdateConnection(&(nsPtrs[m]), &ptmpServ)) )
								{
									if (ptmpServ)
									{
										t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);
									}
								}
							}

							if (SUCCEEDED(t_hr))
							{
								if (m_ArrayLock.Lock())
								{
									m_iQueriesAsked++;
									m_ArrayLock.Unlock();
								}
								else
								{
									pSnk->DisAssociate();
								}
							}
							else
							{
								pSnk->DisAssociate();
							}
						}
						else
						{
							pSnk->DisAssociate();
						}

						if (ptmpServ)
						{
							nsPtrs[m]->ReturnServerOrProxy(ptmpServ);
						}
					}
					else
					{
						pSnk->DisAssociate();
					}

					pSnk->Release();
					SysFreeString(queryBStr);
					SysFreeString(queryLBStr);
				}
			}
		}

		//clean up token array for next pass...
		for (int n = 0; n < dwToks; n++)
		{
			if (tokArray[n].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION)
			{
				VariantClear(&(tokArray[n].vConstValue));
				SysFreeString(tokArray[n].pPropertyName);
				tokArray[n].pPropertyName = NULL;
			}
		}
	}

	delete [] tokArray;

	if (m_ArrayLock.Lock())
	{
		m_iQueriesAsked--;

		if (m_iQueriesAsked != m_iQueriesAnswered)
		{
			//just in case this was triggerred while we had yet to ask some queries
			ResetEvent(m_StatusHandle);
		}
		else
		{
			//just in case this wasn't triggerred while we were asking queries
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}

	if (m_iQueriesAsked == 0)
	{
		for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
		{
			if (m_ObjSinkArray[x] != NULL)
			{
				m_ObjSinkArray[x]->Release();
			}
		}

		m_ObjSinkArray.RemoveAll();

		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to send any queries, invalid namespaces" ) ;
		return FALSE;
	}

	return TRUE;
}

BOOL GetObjectTaskObject::ProcessResults(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst, const wchar_t* src)
{
	BOOL retVal = TRUE;
	int arrayIndex;
	int indexCnt = 0;

	for (int x = 0; retVal && (x < m_ObjSinkArray.GetSize()); x++)
	{
		if ((m_ObjSinkArray[x] != NULL) && m_ObjSinkArray[x]->IsSet())
		{
			if (SUCCEEDED(m_ObjSinkArray[x]->GetResult()))
			{
				DWORD dwCount = m_ObjSinkArray[x]->m_ObjArray.GetSize();

				if (0 < dwCount)
				{
					arrayIndex = x;
					indexCnt++;
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Object path and Class qualifiers resulted in a failed query." ) ;
			}
		}
		else 
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Invalid source namespace path OR object path and Class qualifiers resulted in a failed query." ) ;
		}
	}

	if (retVal)
	{
		if (0 == indexCnt)
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"No source objects found to support view object path." ) ;
			CleanUpObjSinks();
		}
		else
		{
			if ((src != NULL) && (pInst != NULL))
			{
				DWORD *pdwIndices = NULL;
				DWORD dwIndxCount = GetIndexList(src, &pdwIndices);

				for (DWORD i = 0; i < dwIndxCount; i++)
				{
					if ((m_ObjSinkArray[pdwIndices[i]] != NULL) && SUCCEEDED(m_ObjSinkArray[pdwIndices[i]]->GetResult())
						&& m_ObjSinkArray[pdwIndices[i]]->m_ObjArray.GetSize() == 1)
					{
						if (*pInst == NULL)
						{
							m_ObjSinkArray[pdwIndices[i]]->m_ObjArray[0]->GetWrappedObject()->AddRef();
							*pInst = m_ObjSinkArray[pdwIndices[i]]->m_ObjArray[0]->GetWrappedObject();
						}
						else
						{
							(*pInst)->Release();
							*pInst = NULL;
						}
					}
				}

				if (dwIndxCount)
				{
					delete [] pdwIndices;
				}
			}

			if (m_JoinOnArray.IsValid())
			{
#ifdef VP_PERFORMANT_JOINS
				retVal = CreateAndIndicateJoinsPerf(a_ErrorObject, TRUE);
#else
				retVal = CreateAndIndicateJoins(a_ErrorObject, TRUE);
#endif

				if (!retVal && (a_ErrorObject.GetWbemStatus() == WBEM_NO_ERROR))
				{
					a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
					a_ErrorObject.SetMessage ( L"Failed to map source instance(s) to view instance." ) ;
				}

			}
			else //union
			{
				if ( (1 < indexCnt) || (m_ObjSinkArray[arrayIndex]->m_ObjArray.GetSize() > 1) )
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Ambiguous object path. Too many source instances returned." ) ;
					CleanUpObjSinks();
				}
				else
				{
					if ((src == NULL) && (pInst != NULL))
					{
						if ((m_ObjSinkArray[arrayIndex] != NULL) && SUCCEEDED(m_ObjSinkArray[arrayIndex]->GetResult())
							&& m_ObjSinkArray[arrayIndex]->m_ObjArray.GetSize())
						{
							m_ObjSinkArray[arrayIndex]->m_ObjArray[0]->GetWrappedObject()->AddRef();
							*pInst = m_ObjSinkArray[arrayIndex]->m_ObjArray[0]->GetWrappedObject();
						}
					}

					retVal =  CreateAndIndicateUnions(a_ErrorObject, arrayIndex);

					if (!retVal && (a_ErrorObject.GetWbemStatus() == WBEM_NO_ERROR))
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
						a_ErrorObject.SetMessage ( L"Failed to map source instance(s) to view instance." ) ;
					}
				}
			}

			if (!retVal && (pInst != NULL) && (*pInst != NULL))
			{
				(*pInst)->Release();
				*pInst = NULL;
			}
		}
	}
	else
	{
		CleanUpObjSinks();
	}

	return retVal;
}

BOOL GetObjectTaskObject::GetSourceObject(const wchar_t* src, IWbemClassObject** pInst, BOOL bAllprops)
{
	//Have to test that object path is real and return
	//the IWbemClassObject for the source requested....
	//==================================================

	m_bIndicate = FALSE;
	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, m_ParsedObjectPath);

			if (t_Status)
			{
				if (m_bAssoc)
				{
					t_Status = FALSE;
				}
				else
				{
					t_Status = PerformGet(m_ErrorObject, pInst, src, bAllprops);
				}
			}
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL GetObjectTaskObject :: GetObject ()
{
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("GetObjectTaskObject :: GetObject\r\n")
		) ;
)

	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, m_ParsedObjectPath);

			if (t_Status)
			{
				t_Status = PerformGet(m_ErrorObject);
			}
		}
		else
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("GetObjectTaskObject :: GetObject:Class definition not found\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"GetObjectTaskObject :: GetObject:Unable to parse object path %s\r\n",
		m_ObjectPath
		) ;
)
	}

DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("leaving GetObjectTaskObject :: GetObject with %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpmthd.cpp ===
//***************************************************************************

//

//  VPMTHD.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the PutInstance implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

ExecMethodTaskObject :: ExecMethodTaskObject (

		CViewProvServ *a_Provider , 
		wchar_t *a_ObjectPath ,
		wchar_t *a_MethodName,
		ULONG a_Flag ,
		IWbemClassObject *a_InParams ,		
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_Flag , pCtx ) ,
	m_InParamObject( a_InParams ), m_OutParamObject ( NULL ),
	m_ParsedObjectPath ( NULL ), m_ObjectPath(NULL), m_Method(NULL)
{

	if (m_InParamObject != NULL)
	{
		m_InParamObject->AddRef();
	}

	m_ObjectPath = UnicodeStringDuplicate(a_ObjectPath);
	m_Method = UnicodeStringDuplicate(a_MethodName);
}

ExecMethodTaskObject :: ~ExecMethodTaskObject () 
{
	if (m_OutParamObject != NULL)
	{
		if ( SUCCEEDED(m_ErrorObject.GetWbemStatus ()) )
		{
			HRESULT t_Result = m_NotificationHandler->Indicate(1, &m_OutParamObject);
		}

		m_OutParamObject->Release();
	}

	if (m_InParamObject != NULL)
	{
		m_InParamObject->Release();
	}

	delete [] m_ObjectPath ;
	delete [] m_Method ;

	if (NULL != m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath;
	}

	// Get Status object
	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = TRUE;
	
	if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
	{
		t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	}

	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
		
		if (t_NotifyStatus)
		{
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
	}

}

BOOL ExecMethodTaskObject :: ExecMethod ()
{
DebugOut8( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecMethodTaskObject :: ExecMethod\r\n")
		) ;
)

	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			IWbemQualifierSet* pQuals = NULL;
			BOOL bStatic = FALSE;

			//get the method qualifier set so we can determine
			//if the method is static...
			if ( SUCCEEDED(m_ClassObject->GetMethodQualifierSet(m_Method, &pQuals)) )
			{
				//get the MethodSources qualifier
				VARIANT v;
				VariantInit(&v);

				if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_STATIC, 0, &v, NULL)) )
				{
					if (v.vt == VT_BOOL)
					{
						bStatic = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
					}
					else
					{
						t_Status = FALSE;
						m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
						m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_ErrorObject.SetMessage ( L"Static method qualifier should be boolean." ) ;
					}
				}

				VariantClear(&v);
				pQuals->Release();
			}
			else
			{
				t_Status = FALSE;
				m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_ErrorObject.SetMessage ( L"Failed to get Method qualifiers" ) ;
			}

			if (t_Status)
			{
				t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, bStatic ? NULL : m_ParsedObjectPath);
			}

			if (t_Status)
			{
				//only unions
				if (m_bAssoc || m_JoinOnArray.IsValid())
				{
					t_Status = FALSE;
					m_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_SUPPORTED ) ;
					m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_ErrorObject.SetMessage ( L"Methods only supported for Union views" ) ;
				}
			}

			if (t_Status)
			{
				LONG t_index = 0;
				CStringW t_srcMethod;
				BOOL t_bStatic = FALSE;

				t_Status = CompareMethods(m_ErrorObject, t_index, t_srcMethod, t_bStatic);

				if (t_Status)
				{
					t_Status = PerformMethod(m_ErrorObject, t_index, t_srcMethod, t_bStatic);
				}
			}
		}
		else
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut8( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecMethodTaskObject :: ExecMethod:Class definition not found\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut8( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"ExecMethodTaskObject :: ExecMethod:Unable to parse object path %s\r\n",
		m_ObjectPath
		) ;
)
	}

DebugOut8( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("leaving ExecMethodTaskObject :: ExecMethod with %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}

//steps...
//1. Get the method signature and parse it's qualifiers
//2. Get the source method and it's signature
//3. Compare the signatures
//========================================================
BOOL ExecMethodTaskObject::CompareMethods(WbemProvErrorObject &a_ErrorObject, LONG &a_Index,
										  CStringW &a_SrcMethodName, BOOL &a_bStatic)
{
	BOOL retVal = FALSE;
	IWbemQualifierSet* pQuals = NULL;

	//get the method qualifier set so we can determine
	//what the source method for this view method is...
	if ( SUCCEEDED(m_ClassObject->GetMethodQualifierSet(m_Method, &pQuals)) )
	{
		//get the MethodSources qualifier
		VARIANT v;
		VariantInit(&v);

		if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_METHOD, 0, &v, NULL)) )
		{
			retVal = TRUE;

			if (v.vt == VT_BSTR)
			{
				if (m_SourceArray.GetSize() != 1)
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
					a_ErrorObject.SetMessage ( L"MethodSources qualifier should match ViewSources size." ) ;
				}
				else
				{
					a_SrcMethodName = v.bstrVal;
				}
			}
			else if (v.vt == (VT_BSTR | VT_ARRAY))
			{
				if (SafeArrayGetDim(v.parray) == 1)
				{
					LONG count = v.parray->rgsabound[0].cElements;
					BSTR HUGEP *pbstr;

					if (m_SourceArray.GetSize() != count)
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
						a_ErrorObject.SetMessage ( L"MethodSources qualifier should match ViewSources size." ) ;
					}
					else
					{
						if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
						{
							for (LONG x = 0; x < count; x++)
							{
								if ((pbstr[x] != NULL) && (*(pbstr[x]) != L'\0'))
								{
									//only one value should be present
									if (a_SrcMethodName.IsEmpty())
									{
										a_SrcMethodName = pbstr[x];
										a_Index = x;
									}
									else
									{
										a_SrcMethodName.Empty();
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
										a_ErrorObject.SetMessage ( L"MethodSources qualifier should have only one non-empty value." ) ;
										break;
									}
								}
							}

							SafeArrayUnaccessData(v.parray);
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
							a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
							a_ErrorObject.SetMessage (L"Failed to access MethodSources array.");
						}
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"MethodSources array qualifier has incorrect dimensions.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
				a_ErrorObject.SetMessage ( L"MethodSources qualifier has the wrong type." ) ;
			}

			if (retVal)
			{
				if (!a_SrcMethodName.IsEmpty())
				{
					IWbemClassObject* t_SrcObj = m_SourceArray[a_Index]->GetClassObject();

					if (t_SrcObj != NULL)
					{
						IWbemClassObject* pVInParam = NULL;
						IWbemClassObject* pVOutParam = NULL;
						IWbemClassObject* pSInParam = NULL;
						IWbemClassObject* pSOutParam = NULL;

						if ( SUCCEEDED(m_ClassObject->GetMethod(m_Method, 0, &pVInParam, &pVOutParam)) )
						{
							if ( SUCCEEDED(t_SrcObj->GetMethod(a_SrcMethodName, 0, &pSInParam, &pSOutParam)) )
							{
								//got all the info we need, now compare the signatures...
								if ( ((pVInParam == NULL) && (pSInParam != NULL)) ||
									((pVInParam != NULL) && (pSInParam == NULL)) ||
									((pVOutParam == NULL) && (pSOutParam != NULL)) ||
									((pVOutParam != NULL) && (pSOutParam == NULL)) )
								{
									//signature mismatch
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_SUPPORTED) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
									a_ErrorObject.SetMessage ( L"View method signature does not match source method signature." ) ;
								}
								else
								{
									if (pSInParam != NULL) //pVInParam is non-null
									{
										if (WBEM_S_DIFFERENT == pSInParam->CompareTo(WBEM_FLAG_IGNORE_OBJECT_SOURCE |
																					WBEM_FLAG_IGNORE_DEFAULT_VALUES |
																					WBEM_FLAG_IGNORE_FLAVOR, pVInParam))
										{
											//signature mismatch
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_SUPPORTED) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
											a_ErrorObject.SetMessage ( L"View method signature does not match source method signature." ) ;
										}
									}

									if (retVal && (pSOutParam != NULL)) //pVOutParam is non-null
									{
										if (WBEM_S_DIFFERENT == pSOutParam->CompareTo(WBEM_FLAG_IGNORE_OBJECT_SOURCE |
																					WBEM_FLAG_IGNORE_DEFAULT_VALUES |
																					WBEM_FLAG_IGNORE_FLAVOR, pVOutParam))
										{
											//signature mismatch
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_SUPPORTED) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
											a_ErrorObject.SetMessage ( L"View method signature does not match source method signature." ) ;
										}
									}

									//check to see that methods are both
									//static or both non-static
									if (retVal)
									{
										BOOL t_bViewStatic = FALSE;
										BOOL t_bSrcStatic = FALSE;
										VARIANT t_vStatic;
										VariantInit(&t_vStatic);
										
										if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_STATIC, 0, &t_vStatic, NULL)) )
										{
											if (t_vStatic.vt == VT_BOOL)
											{
												t_bViewStatic = (t_vStatic.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
											}
											else
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_TYPE_MISMATCH) ;
												a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
												a_ErrorObject.SetMessage ( L"Static qualifier on Method should be boolean" ) ;

											}
										}

										VariantClear(&t_vStatic);
										VariantInit(&t_vStatic);
										IWbemQualifierSet* t_SrcQuals = NULL;

										if ( SUCCEEDED(t_SrcObj->GetMethodQualifierSet(a_SrcMethodName, &t_SrcQuals)) )
										{
											if ( SUCCEEDED(t_SrcQuals->Get(VIEW_QUAL_STATIC, 0, &t_vStatic, NULL)) )
											{
												if (t_vStatic.vt == VT_BOOL)
												{
													t_bSrcStatic = (t_vStatic.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
												}
												else
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus (WBEM_PROV_E_TYPE_MISMATCH) ;
													a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
													a_ErrorObject.SetMessage ( L"Static qualifier on Method should be boolean" ) ;

												}
											}

											t_SrcQuals->Release();
										}
										
										VariantClear(&t_vStatic);

										if (retVal)
										{
											if ((t_bSrcStatic) && (t_bViewStatic))
											{
												a_bStatic = TRUE;
											}
											else if ((!t_bSrcStatic) && (!t_bViewStatic))
											{
												a_bStatic = FALSE;
											}
											else
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
												a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
												a_ErrorObject.SetMessage (L"Both source and view methods must be static or both non-static");
											}

										}
									}
								}
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
								a_ErrorObject.SetMessage ( L"Source method could not be found" ) ;
							}
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
							a_ErrorObject.SetMessage ( L"View method could not be found" ) ;
						}

						//release all the signature objects
						if (pVInParam != NULL)
						{
							pVInParam->Release();
						}

						if (pVOutParam != NULL)
						{
							if (retVal)
							{
								if ( FAILED(pVOutParam->SpawnInstance(0, &m_OutParamObject)) )
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_UNEXPECTED) ;
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Failed to spawn out parameter");
								}
							}

							pVOutParam->Release();
						}

						if (pSInParam != NULL)
						{
							pSInParam->Release();
						}

						if (pSOutParam != NULL)
						{
							pSOutParam->Release();
						}

						//release the source class object
						t_SrcObj->Release();
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
						a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
						a_ErrorObject.SetMessage (L"Source class not available");
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Source of method not specified in MethodSources qualifier");
				}
			}
		}
		else
		{
			a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
			a_ErrorObject.SetMessage ( L"MethodSource qualifier is missing" ) ;
		}

		VariantClear(&v);
		pQuals->Release();
	}
	else
	{
		a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
		a_ErrorObject.SetMessage ( L"Method or Method qualifiers are missing" ) ;
	}

	return retVal;
}

//map the object path to the source instance and perform the method
//if static make sure that the object path supplied was a class path.
BOOL ExecMethodTaskObject::PerformMethod(WbemProvErrorObject &a_ErrorObject, LONG a_Index,
										 CStringW a_SrcMethodName, BOOL a_bStatic)
{
	BOOL retVal = FALSE;
	int index = 0;
	BSTR inst_path = NULL;

	if (a_bStatic)
	{
		//make sure we were passed the class path
		if (m_ParsedObjectPath->IsClass())
		{
			//get the class and make sure there is
			//only one namespace associated with it.
			if (m_NSpaceArray[a_Index]->GetCount() == 1)
			{
				retVal = TRUE;
				inst_path = SysAllocString(m_SourceArray[a_Index]->GetClassName());
			}
			else
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Could not resolve path to single namespace for source Static method." ) ;
			}
		}
		else
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
			a_ErrorObject.SetMessage ( L"Static method called with instance rather than class path" ) ;
		}
	}
	else
	{
		//get the source instance for the view instance
		IWbemClassObject* pSrcInst;
		inst_path = MapFromView(m_ObjectPath, NULL, &pSrcInst, TRUE);

		if (inst_path != NULL)
		{
			//get the index of the class
			VARIANT vCls;

			if ( SUCCEEDED(pSrcInst->Get(WBEM_PROPERTY_CLASS, 0, &vCls, NULL, NULL)) )
			{
				if (vCls.vt == VT_BSTR)
				{
					if (m_ClassToIndexMap.Lookup(vCls.bstrVal, index))
					{
						if (a_Index == index)
						{
							retVal = TRUE;
						}
						else
						{
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Object path passed resulted in a different class of object to that of the methodsource" ) ;
						}
					}
					else
					{
						VARIANT vSCls;
						VariantInit(&vSCls);

						if ( SUCCEEDED(pSrcInst->Get(WBEM_PROPERTY_DERIVATION, 0, &vSCls, NULL, NULL)) )
						{
							if (vSCls.vt == VT_BSTR)
							{
								if (m_ClassToIndexMap.Lookup(vSCls.bstrVal, index))
								{
									if (a_Index == index)
									{
										retVal = TRUE;
									}
									else
									{
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_ErrorObject.SetMessage ( L"Source instance class not found in source list" ) ;
									}
								}
							}
							else if (vSCls.vt == (VT_ARRAY | VT_BSTR))
							{
								if (SafeArrayGetDim(vSCls.parray) == 1)
								{
									LONG count = vSCls.parray->rgsabound[0].cElements;
									BSTR HUGEP *pbstr;

									if ( SUCCEEDED(SafeArrayAccessData(vSCls.parray, (void HUGEP**)&pbstr)) )
									{
										for (LONG x = 0; x < count; x++)
										{
											if (m_ClassToIndexMap.Lookup(pbstr[x], index))
											{
												if (a_Index == index)
												{
													retVal = TRUE;
													break;
												}
											}
										}

										SafeArrayUnaccessData(vSCls.parray);

										if (!retVal)
										{
											a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
											a_ErrorObject.SetMessage ( L"Source instance class not found in source list" ) ;
										}
									}
									else
									{
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Failed to access __Derivation array.");
									}
								}
								else
								{
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"__Derivation array qualifier has incorrect dimensions.");
								}
							}
							else
							{
								a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Source instance has non string __Derivation property" ) ;
							}

							VariantClear(&vSCls);
						}
						else
						{
							a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Source instance has no __Derivation property" ) ;
						}
					}
				}
				else
				{
					a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Source instance has non string __Class property" ) ;
				}

				VariantClear(&vCls);
			}
			else
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Source instance has no __Class property" ) ;
			}

			pSrcInst->Release();
		}
		else
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Instance supplied could not be mapped to a single source instance" ) ;
		}
	}

	if (retVal)
	{
		//Execute the method and indicate the outparams...
		//also set the result and we're all done!
		//which namespace do we execmethod, try them all until we succeed 
		CWbemServerWrap** pServs = m_NSpaceArray[index]->GetServerPtrs();
		HRESULT hr = WBEM_E_FAILED;

		for (UINT i = 0; i < m_NSpaceArray[index]->GetCount(); i++)
		{
			if (pServs[i] != NULL)
			{
				IWbemClassObject *t_outparam = NULL;
				IWbemServices *ptmpServ = pServs[i]->GetServerOrProxy();

				if (ptmpServ)
				{
					BSTR t_MethName = a_SrcMethodName.AllocSysString();
					hr = ptmpServ->ExecMethod(inst_path, t_MethName, 0,
											m_Ctx, m_InParamObject,
											&t_outparam, NULL);

					if ( FAILED(hr) && (HRESULT_FACILITY(hr) != FACILITY_ITF) && pServs[i]->IsRemote())
					{
						if ( SUCCEEDED(UpdateConnection(&(pServs[i]), &ptmpServ)) )
						{
							if (ptmpServ)
							{
								hr = ptmpServ->ExecMethod(inst_path, t_MethName, 0,
											m_Ctx, m_InParamObject,
											&t_outparam, NULL);
							}
						}
					}

					SysFreeString(t_MethName);

					if (ptmpServ)
					{
						pServs[i]->ReturnServerOrProxy(ptmpServ);
					}
				}

				if (SUCCEEDED (hr) )
				{
					if (m_OutParamObject != NULL)
					{
						if (t_outparam != NULL)
						{
							//copy contents of the outparam to view outparam
							if ( SUCCEEDED(t_outparam->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)) )
							{
								BSTR t_propName = NULL;
								VARIANT t_propValue;
								VariantInit(&t_propValue);

								HRESULT t_hr = t_outparam->Next(0, &t_propName, &t_propValue, NULL, NULL);

								while (hr == WBEM_S_NO_ERROR)
								{
									//copy this property
									if (SUCCEEDED(hr = m_OutParamObject->Put(t_propName, 0, &t_propValue, NULL)))
									{
										//get the next property
										VariantClear(&t_propValue);
										VariantInit(&t_propValue);
										SysFreeString(t_propName);
										t_propName = NULL;
										hr = t_outparam->Next(0, &t_propName, &t_propValue, NULL, NULL);
									}
									else
									{
										break;
									}
								}

								VariantClear(&t_propValue);

								if (t_propName != NULL)
								{
									SysFreeString(t_propName);
								}

								if (FAILED(hr))
								{
									t_outparam->EndEnumeration();
									retVal = FALSE;
								}
							}
							else
							{
								retVal = FALSE;
							}
							
							if (!retVal)
							{
								m_OutParamObject->Release();
								m_OutParamObject = NULL;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Source method executed but the view provider failed to copy the out parameter object" ) ;
							}
						}
						else
						{
							m_OutParamObject->Release();
							m_OutParamObject = NULL;
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Source method executed without returning the out parameter object" ) ;
						}
					}

					if (t_outparam != NULL)
					{
						t_outparam->Release();
					}

					break;
				}
			}
		}

		if ( FAILED (hr) )
		{
			if (m_OutParamObject)
			{
				m_OutParamObject->Release();
				m_OutParamObject = NULL;
			}

			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
#ifdef VP_SINGLE_NAMESPACE_TRIED
			wchar_t buff[100];
			wsprintf(buff, L"ExecMethod with source object failed with code: %lx", hr);
			a_ErrorObject.SetMessage ( buff ) ;
#else	//VP_SINGLE_NAMESPACE_TRIED
			a_ErrorObject.SetMessage ( L"ExecMethod with source object failed" ) ;
#endif	//VP_SINGLE_NAMESPACE_TRIED
		}
	}

	if (inst_path != NULL)
	{
		SysFreeString(inst_path);
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpput.cpp ===
//***************************************************************************

//

//  VPPUT.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the PutInstance implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern BOOL CompareSimplePropertyValues(VARIANT* v1, VARIANT* v2, CIMTYPE ct);

PutInstanceTaskObject::PutInstanceTaskObject (CViewProvServ *a_Provider , IWbemClassObject *a_Inst , 
												ULONG a_Flag , IWbemObjectSink *a_NotificationHandler,
												IWbemContext *pCtx) 
:WbemTaskObject (a_Provider, a_NotificationHandler, a_Flag, pCtx)
{
	m_InstObject = a_Inst;

	if (m_InstObject != NULL)
	{
		m_InstObject->AddRef();

		if (WBEM_FLAG_CREATE_ONLY == (a_Flag & WBEM_FLAG_CREATE_ONLY))
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER );
			m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER );
			m_ErrorObject.SetMessage ( L"The provider does not support instance creation via PutInstanceAsync." );
		}
	}
	else
	{
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetMessage ( L"A non-null instance must be supplied as an argument" ) ;
	}
}


PutInstanceTaskObject::~PutInstanceTaskObject ()
{
	BOOL t_Status = TRUE;

	IWbemClassObject *t_NotifyStatus = NULL ;

	if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
	{
		t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	}

	if ( t_Status )
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
		
		if (t_NotifyStatus)
		{
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
	}

	if (m_InstObject != NULL)
	{
		m_InstObject->Release();
	}
}

BOOL PutInstanceTaskObject::PutInstance()
{
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance\r\n)")
		) ;
)
	if (FAILED(m_ErrorObject.GetWbemStatus()))
	{
		return FALSE;
	}

	VARIANT v;
	VariantInit (&v);
	BOOL t_Status = SUCCEEDED(m_InstObject->Get(WBEM_PROPERTY_CLASS, 0, &v, NULL, NULL));

	if (( t_Status ) && (VT_BSTR == v.vt))
	{
		t_Status = SetClass(v.bstrVal) ;

		if (t_Status)
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject);

			if (t_Status)
			{
				//only unions
				if (!m_bAssoc && !m_JoinOnArray.IsValid())
				{
					t_Status = PerformPut(m_ErrorObject);
				}
				else
				{
					m_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_SUPPORTED ) ;
					m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_ErrorObject.SetMessage ( L"Operation only supported for Union views" ) ;
				}
			}
		}
		else
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance:Dynamic NT Eventlog Provider does not support WRITE for this class\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_OBJECT ) ;
		m_ErrorObject.SetMessage ( L"Unable to obtain class name from object." ) ;
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance:Unable to obtain class name from object.\r\n")
		) ;
)
	}

	VariantClear(&v);
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance:returning %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}

BOOL PutInstanceTaskObject::PerformPut(WbemProvErrorObject &a_ErrorObject)
{
	BOOL retVal = FALSE;
	VARIANT v;

	//Two step process, first get the instance being changed...
	if ( SUCCEEDED(m_InstObject->Get(WBEM_PROPERTY_RELPATH, 0, &v, NULL, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			IWbemClassObject* pSrcInst;
			BSTR refStr = MapFromView(v.bstrVal, NULL, &pSrcInst, TRUE);

			if (refStr != NULL)
			{
				//Second step...
				//map any property changes to the new instance and call PutInstance
				VARIANT vCls;

				if ( SUCCEEDED(pSrcInst->Get(WBEM_PROPERTY_CLASS, 0, &vCls, NULL, NULL)) )
				{
					if (vCls.vt == VT_BSTR)
					{
						int index;

						if (m_ClassToIndexMap.Lookup(vCls.bstrVal, index))
						{
							POSITION propPos = m_PropertyMap.GetStartPosition();
							retVal = TRUE;

							while ((propPos != NULL) && retVal)
							{
								VARIANT vProp;
								CIMTYPE ct;
								CStringW propName;
								CPropertyQualifierItem* propProps;
								m_PropertyMap.GetNextAssoc(propPos, propName, propProps);

								if (!propProps->m_SrcPropertyNames[index].IsEmpty())
								{
									if ( SUCCEEDED(m_InstObject->Get(propName, 0, &vProp, &ct, NULL)) )
									{
										VARIANT vSProp;

										if ( SUCCEEDED (pSrcInst->Get(propProps->m_SrcPropertyNames[index], 0, &vSProp, &ct, NULL)) )
										{
											if (!CompareSimplePropertyValues(&vProp, &vSProp, ct))
											{
												if ( FAILED(pSrcInst->Put(propProps->m_SrcPropertyNames[index], 0, &vProp, ct)) )
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
													a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
													a_ErrorObject.SetMessage ( L"Failed to Put property in source instance" ) ;
												}
											}

											VariantClear(&vSProp);
										}
										else
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
											a_ErrorObject.SetMessage ( L"Failed to Get property from source instance" ) ;
										}

										VariantClear(&vProp);
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_ErrorObject.SetMessage ( L"Failed to get property from view instance" ) ;
									}
								}
							}

							if (retVal)
							{
								//which namespace do we put into, try them all until we succeed 
								CWbemServerWrap** pServs = m_NSpaceArray[index]->GetServerPtrs();
								HRESULT hr = WBEM_E_FAILED;

								for (UINT i = 0; i < m_NSpaceArray[index]->GetCount(); i++)
								{
									if (pServs[i] != NULL)
									{
										IWbemServices *ptmpServ = pServs[i]->GetServerOrProxy();

										if (ptmpServ)
										{
											hr = ptmpServ->PutInstance(pSrcInst, WBEM_FLAG_UPDATE_ONLY, m_Ctx, NULL);

											if ( FAILED(hr) && (HRESULT_FACILITY(hr) != FACILITY_ITF) && pServs[i]->IsRemote())
											{
												if ( SUCCEEDED(UpdateConnection(&(pServs[i]), &ptmpServ)) )
												{
													if (ptmpServ)
													{
														hr = ptmpServ->PutInstance(pSrcInst, WBEM_FLAG_UPDATE_ONLY, m_Ctx, NULL);
													}
												}
											}

											if (ptmpServ)
											{
												pServs[i]->ReturnServerOrProxy(ptmpServ);
											}

											if (SUCCEEDED (hr) )
											{
												break;
											}
										}
									}
								}

								if ( FAILED (hr) )
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
#ifdef VP_SINGLE_NAMESPACE_TRIED
									wchar_t buff[100];
									wsprintf(buff, L"PutInstance on source object failed with code: %lx", hr);
									a_ErrorObject.SetMessage ( buff ) ;
#else	//VP_SINGLE_NAMESPACE_TRIED
									a_ErrorObject.SetMessage ( L"PutInstance on source object failed" ) ;
#endif	//VP_SINGLE_NAMESPACE_TRIED
								}
							}
						}
						else
						{
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Source instance class not found in source list" ) ;
						}
					}
					else
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Source instance has non string __Class property" ) ;
					}

					VariantClear(&vCls);
				}
				else
				{
					a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Source instance has no __Class property" ) ;
				}

				pSrcInst->Release();
				SysFreeString(refStr);
			}
			else
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Instance supplied could not be mapped to a single source instance" ) ;
			}
		}
		else
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
			a_ErrorObject.SetMessage ( L"Instance supplied has non string __RelPath property" ) ;
		}

		VariantClear(&v);
	}
	else
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		a_ErrorObject.SetMessage ( L"Instance supplied has no __RelPath property" ) ;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpquery.cpp ===
//***************************************************************************

//

//  VPGET.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the ExecQuery implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>


//for association work-around
struct MY_SQL_LEVEL_1_TOKEN
{
	BOOL m_bSpecial;
	SQL_LEVEL_1_TOKEN m_Tok;

    MY_SQL_LEVEL_1_TOKEN() { m_bSpecial = FALSE; } 
    
	//assignment operators
	MY_SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src)
	{
		m_bSpecial = FALSE;
		this->m_Tok = Src;
		return *this;
	}

    MY_SQL_LEVEL_1_TOKEN& operator=(MY_SQL_LEVEL_1_TOKEN &Src)
	{
		*this = Src.m_Tok;
		m_bSpecial = Src.m_bSpecial;
		return *this;
	}

	//copy constructors match the operators
    MY_SQL_LEVEL_1_TOKEN(MY_SQL_LEVEL_1_TOKEN &Src) { *this = Src; }
    MY_SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src) { *this = Src; }
};

ExecQueryTaskObject::ExecQueryTaskObject(CViewProvServ *a_Provider , 
		BSTR a_QueryFormat, BSTR a_Query, ULONG a_Flag,
		IWbemObjectSink *a_NotificationHandler,	IWbemContext *pCtx
) 
: WbemTaskObject(a_Provider, a_NotificationHandler, a_Flag, pCtx),
 m_Query(NULL),
 m_QueryFormat(NULL),
 m_RPNExpression(NULL)
{
	m_Query = UnicodeStringDuplicate(a_Query);
	m_QueryFormat = UnicodeStringDuplicate(a_QueryFormat);
}

ExecQueryTaskObject::~ExecQueryTaskObject ()
{
	BOOL t_Status = TRUE;
	IWbemClassObject *t_NotifyStatus = NULL ;

	if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
	{
		t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	}

	if ( t_Status )
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
		
		if (t_NotifyStatus)
		{
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
	}

	if (m_Query != NULL)
	{
		delete [] m_Query;
	}

	if (m_QueryFormat != NULL)
	{
		delete [] m_QueryFormat;
	}

	if (m_RPNExpression != NULL)
	{
		delete m_RPNExpression;
	}

	if (m_StatusHandle != NULL)
	{
		CloseHandle(m_StatusHandle);
	}
}

BOOL ExecQueryTaskObject::PerformQuery(WbemProvErrorObject &a_ErrorObject)
{
	BOOL retVal = FALSE;
	m_StatusHandle = CreateEvent(NULL, TRUE, FALSE, NULL); 
	retVal = PerformEnumQueries(a_ErrorObject);

	if (retVal)
	{
		BOOL bWait = TRUE;

		while (bWait)
		{
			DWORD dwWait = WbemWaitForSingleObject(m_StatusHandle, VP_QUERY_TIMEOUT);

			switch (dwWait)
			{
				case WAIT_OBJECT_0:
				{
					if (ResetEvent(m_StatusHandle))
					{
						m_ResultReceived = FALSE;
						retVal = PerformSelectQueries(a_ErrorObject, bWait);

						if (retVal)
						{
							if (bWait)
							{
								while (bWait)
								{
									dwWait = WbemWaitForSingleObject(m_StatusHandle, VP_QUERY_TIMEOUT);

									switch (dwWait)
									{
										case WAIT_OBJECT_0 :
										{
											retVal = ProcessResults(a_ErrorObject);
											bWait = FALSE;
										}
										break;

										case WAIT_TIMEOUT:
										{
											BOOL bCleanup = TRUE;

											if (m_ArrayLock.Lock())
											{
												if (m_ResultReceived)
												{
													m_ResultReceived = FALSE;
													bCleanup = FALSE;
												}

												m_ArrayLock.Unlock();
											}

											if (bCleanup)
											{
												CleanUpObjSinks(TRUE);
												a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
												a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed, or query timed out" ) ;
												retVal = FALSE;
												bWait = FALSE;
											}
										}
										break;

										default:
										{
											//Cancel outstanding requests and delete object sinks...
											//======================================================
											CleanUpObjSinks(TRUE);
											a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
											a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed" ) ;
											retVal = FALSE;
											bWait = FALSE;
										}
									}
								}
							}
							else
							{
								retVal = ProcessResults(a_ErrorObject);
							}
						}
						else
						{
							ProcessResults(a_ErrorObject);
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to perform source query(ies), a WIN32 API failed" ) ;
						ProcessResults(a_ErrorObject);
					}

					bWait = FALSE;
				}
				break;

				case WAIT_TIMEOUT:
				{
					BOOL bCleanup = TRUE;

					if (m_ArrayLock.Lock())
					{
						if (m_ResultReceived)
						{
							m_ResultReceived = FALSE;
							bCleanup = FALSE;
						}

						m_ArrayLock.Unlock();
					}

					if (bCleanup)
					{
						CleanUpObjSinks(TRUE);
						a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed, or query timed out" ) ;
						retVal = FALSE;
						bWait = FALSE;
					}
				}
				break;

				default:
				{
					//Cancel outstanding requests and delete object sinks...
					//======================================================
					CleanUpObjSinks(TRUE);
					a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed" ) ;
					retVal = FALSE;
					bWait = FALSE;
				}
			}
		}
	}
	else
	{
		//no outstanding requests, just delete object sinks...
		//====================================================
		CleanUpObjSinks();
	}

	return retVal;
}

//The following function does 'simple' analysis of the current
//query and modifies the source queries accordingly...
//============================================================
void ExecQueryTaskObject::ModifySourceQueriesForUserQuery()
{
	MY_SQL_LEVEL_1_TOKEN* pExtraToks = new MY_SQL_LEVEL_1_TOKEN[m_RPNExpression->nNumTokens + 1];

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		DWORD dwToks = 0;
		BOOL bOptimize = TRUE;

		for (int i = 0; bOptimize && (i < m_RPNExpression->nNumTokens); i++)
		{
			switch (m_RPNExpression->pArrayOfTokens[i].nTokenType)
			{
				case SQL_LEVEL_1_TOKEN::TOKEN_AND:
				{
					pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_OR:
				{
					pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
				{
					pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
				}
				break;

				case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
				{
					CPropertyQualifierItem* propItem;

					if (m_PropertyMap.Lookup(m_RPNExpression->pArrayOfTokens[i].pPropertyName, propItem))
					{
						if (!propItem->m_SrcPropertyNames[x].IsEmpty())
						{
							//TransposeReference if necessary
							//=================================
							MY_SQL_LEVEL_1_TOKEN tmpToken = m_RPNExpression->pArrayOfTokens[i];
							BOOL bCont = TRUE;

							if (m_bAssoc && (propItem->GetCimType() == CIM_REFERENCE))
							{
								bCont = TransposeReference(propItem, m_RPNExpression->pArrayOfTokens[i].vConstValue,
																&(tmpToken.m_Tok.vConstValue), FALSE, NULL);

								if (bCont)
								{
									//mark the token as special
									//for the association work-around
									tmpToken.m_bSpecial = TRUE;
								}
							}

							if (bCont)
							{
								pExtraToks[dwToks] = tmpToken;
								SysFreeString(pExtraToks[dwToks].m_Tok.pPropertyName);
								pExtraToks[dwToks++].m_Tok.pPropertyName = propItem->m_SrcPropertyNames[x].AllocSysString();
							}
							else
							{
								//can't "simply" optimize this query!
								dwToks = 0;
								bOptimize = FALSE;
							}
						}
						else
						{
							//can't "simply" optimize this query!
							dwToks = 0;
							bOptimize = FALSE;
						}
					}
					else
					{
						//can't "simply" optimize this query!
						dwToks = 0;
						bOptimize = FALSE;
					}
				}
				break;

				default:
				{
				}
			}
		}

		if (dwToks != 0)
		{
			if (m_SourceArray[x]->GetRPNExpression()->nNumTokens > 0)
			{
				pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
			}

			for (i = 0; i < dwToks; i++)
			{
				m_SourceArray[x]->GetRPNExpression()->AddToken(pExtraToks[i].m_Tok);

				if (pExtraToks[i].m_bSpecial)
				{
					//add the extra tokens if neccessary
					//for the association work-around
					wchar_t *t_pChar = pExtraToks[i].m_Tok.vConstValue.bstrVal;

					//must be \\server\namespace and not \\.\namespace or relpath
					if ( (*t_pChar == L'\\') && (*(t_pChar+1) == L'\\') && (*(t_pChar+2) != L'.') )
					{
						//add the dotted version
						SQL_LEVEL_1_TOKEN t_Tok = pExtraToks[i].m_Tok;
						t_pChar = t_Tok.vConstValue.bstrVal + 2;
						
						while (*t_pChar != L'\\')
						{
							t_pChar++;
						}

						--t_pChar;
						*t_pChar = L'.';
						--t_pChar;
						*t_pChar = L'\\';
						--t_pChar;
						*t_pChar = L'\\';
						BSTR t_strtmp = SysAllocString(t_pChar);
						VariantClear(&(t_Tok.vConstValue));
						VariantInit(&(t_Tok.vConstValue));
						t_Tok.vConstValue.vt = VT_BSTR;
						t_Tok.vConstValue.bstrVal = t_strtmp;
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_Tok);

						//add an Or token
						SQL_LEVEL_1_TOKEN t_OrTok;
						t_OrTok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_OrTok);

						//add the relpath version
						t_pChar = t_Tok.vConstValue.bstrVal + 4;
						
						while (*t_pChar != L':')
						{
							t_pChar++;
						}

						//exclude the ':'
						t_pChar++;
						t_strtmp = SysAllocString(t_pChar);
						VariantClear(&(t_Tok.vConstValue));
						VariantInit(&(t_Tok.vConstValue));
						t_Tok.vConstValue.vt = VT_BSTR;
						t_Tok.vConstValue.bstrVal = t_strtmp;
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_Tok);

						//add the last OR
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_OrTok);
					}
				}
			}
		}
	}

	delete [] pExtraToks;
}

//This function does 'simple' analysis of the join and modifies the
//unexecuted source queries accordingly for the results received so far...
//=========================================================================
void ExecQueryTaskObject::ModifySourceQueriesWithEnumResults()
{
	wchar_t** classA = m_JoinOnArray.GetAClasses();
	wchar_t** propsA = m_JoinOnArray.GetAProperties();
	wchar_t** classB = m_JoinOnArray.GetBClasses();
	wchar_t** propsB = m_JoinOnArray.GetBProperties();
	UINT* ops = m_JoinOnArray.GetOperators();
	int iEnum;	//the index of the enumerated class
	int iMod;	//the index of the source query to be modified

	for (int x = 0; x < m_JoinOnArray.GetCount(); x++)
	{
		BOOL bIsAEnum = m_EnumerateClasses.Lookup(classA[x], iEnum);
		BOOL bIsBEnum = m_EnumerateClasses.Lookup(classB[x], iEnum);
		wchar_t* propEnum;
		wchar_t* propMod;

		if ( (bIsAEnum && !bIsBEnum) || (!bIsAEnum && bIsBEnum) )
		{
			if (bIsAEnum) 
			{
				if (!m_ClassToIndexMap.Lookup(classA[x], iEnum))
				{
					//an error forget this case!
					continue;
				}
				else
				{
					if (!m_ClassToIndexMap.Lookup(classB[x], iMod))
					{
						//an error forget this case!
						continue;
					}
					else
					{
						propEnum = propsA[x];
						propMod = propsB[x];
					}
				}
			}
			else
			{
				if (!m_ClassToIndexMap.Lookup(classB[x], iEnum))
				{
					//an error forget this case!
					continue;
				}
				else
				{
					if (!m_ClassToIndexMap.Lookup(classA[x], iMod))
					{
						//an error forget this case!
						continue;
					}
					else
					{
						propEnum = propsB[x];
						propMod = propsA[x];
					}
				}
			}

			//don't transpose references as
			//they are already in source format.
			int m = 0;
			SQL_LEVEL_1_TOKEN opToken;
			opToken.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
			SQL_LEVEL_1_TOKEN token;
			token.nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
			token.pPropertyName = SysAllocString(propMod);

			if (ops[x] == CJoinOnQualifierArray::NOT_EQUALS_OPERATOR)
			{
				token.nOperator = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
			}
			else if (ops[x] == CJoinOnQualifierArray::EQUALS_OPERATOR)
			{
				token.nOperator = SQL_LEVEL_1_TOKEN::OP_EQUAL;
			}

			BOOL bAddAnd = m_SourceArray[iMod]->GetRPNExpression()->nNumTokens > 0;

			for (int n = 0; n < m_ObjSinkArray[iEnum]->m_ObjArray.GetSize(); n++)
			{
				VariantInit(&token.vConstValue);
				IWbemClassObject* pObj = m_ObjSinkArray[iEnum]->m_ObjArray[n]->GetWrappedObject();

				if ( SUCCEEDED(pObj->Get(propEnum, 0, &token.vConstValue, NULL, NULL)) )
				{
					m_SourceArray[iMod]->GetRPNExpression()->AddToken(token);
					m++;

					if (m > 1)
					{
						m_SourceArray[iMod]->GetRPNExpression()->AddToken(opToken);
					}
				}

				VariantClear(&token.vConstValue);
			}

			if ((bAddAnd) && (m != 0))
			{
				opToken.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
				m_SourceArray[iMod]->GetRPNExpression()->AddToken(opToken);
			}
		}
	}
}

BOOL ExecQueryTaskObject::PerformSelectQueries(WbemProvErrorObject &a_ErrorObject, BOOL &bWait)
{
	bWait = FALSE;
	
	if (!m_JoinOnArray.IsValid() ||	m_EnumerateClasses.IsEmpty())
	{
		return TRUE;
	}

	ModifySourceQueriesWithEnumResults();
	
	//reset number of queries asked and answered
	m_iQueriesAsked = 1;
	m_iQueriesAnswered = 0;

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		int dummyInt;

		if (!m_EnumerateClasses.Lookup(m_SourceArray[x]->GetClassName(), dummyInt))
		{
			CStringW queryStr = GetStringFromRPN(m_SourceArray[x]->GetRPNExpression(), 0, NULL);
			CWbemServerWrap** nsPtrs = m_NSpaceArray[x]->GetServerPtrs();

            if (queryStr.GetLength() > 0)
            {
			    for (int m = 0; m < m_NSpaceArray[x]->GetCount(); m++)
			    {
				    if (nsPtrs[m] != NULL)
				    {
					    CViewProvObjectSink* pSnk = new CViewProvObjectSink(m_ObjSinkArray[x], nsPtrs[m], m);
					    pSnk->AddRef();
					    BSTR queryBStr = queryStr.AllocSysString();
					    BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);
					    IWbemObjectSink* pQuerySink = pSnk;
					    IWbemContext * t_pCtx = m_Ctx;

					    if (nsPtrs[m]->IsRemote())
					    {
						    pQuerySink = pSnk->Associate();
						    t_pCtx = NULL; //don't use context for remote cimoms
					    }

					    IWbemServices *ptmpServ = nsPtrs[m]->GetServerOrProxy();

					    if (ptmpServ)
					    {
						    if ( pQuerySink )
						    {
							    HRESULT t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);

							    if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[m]->IsRemote())
							    {
								    if ( SUCCEEDED(UpdateConnection(&(nsPtrs[m]), &ptmpServ)) )
								    {
									    if (ptmpServ)
									    {
										    t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);
									    }
								    }
							    }

							    if (SUCCEEDED(t_hr))
							    {
								    if (m_ArrayLock.Lock())
								    {
									    m_iQueriesAsked++;
									    m_ArrayLock.Unlock();
								    }
								    else
								    {
									    pSnk->DisAssociate();
								    }
							    }
							    else
							    {
								    pSnk->DisAssociate();
							    }
						    }
						    else
						    {
							    pSnk->DisAssociate();
						    }

						    if (ptmpServ)
						    {
							    nsPtrs[m]->ReturnServerOrProxy(ptmpServ);
						    }
					    }
					    else
					    {
						    pSnk->DisAssociate();
					    }

					    SysFreeString(queryLBStr);
					    SysFreeString(queryBStr);
					    pSnk->Release();
				    }
			    }
            }
		}
	}

	if (m_ArrayLock.Lock())
	{
		m_iQueriesAsked--;

		if (m_iQueriesAsked != m_iQueriesAnswered)
		{
			//just in case this was triggerred while we had yet to ask some queries
			ResetEvent(m_StatusHandle);
		}
		else
		{
			//just in case this wasn't triggerred while we were asking queries
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}

	if (m_iQueriesAsked == 0)
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to perform source query(ies), invalid source namespace(s)" ) ;
		return FALSE;
	}
	else
	{
		bWait = TRUE;
	}

	return TRUE;
}

BOOL ExecQueryTaskObject::PerformEnumQueries(WbemProvErrorObject &a_ErrorObject)
{
	m_iQueriesAsked++;
	ModifySourceQueriesForUserQuery();
	m_ObjSinkArray.SetSize(0, m_NSpaceArray.GetSize());

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		BOOL bDone = FALSE;
		int dummyInt;
		CObjectSinkResults * objSnk = new CObjectSinkResults(this, x);
		objSnk->AddRef();
		m_ObjSinkArray.SetAtGrow(x, objSnk);

		if (!m_JoinOnArray.IsValid() ||	m_EnumerateClasses.IsEmpty() ||
			m_EnumerateClasses.Lookup(m_SourceArray[x]->GetClassName(), dummyInt) )
		{
			CStringW queryStr = GetStringFromRPN(m_SourceArray[x]->GetRPNExpression(), 0, NULL);

            if (queryStr.GetLength() > 0)
            {
			    CWbemServerWrap** nsPtrs = m_NSpaceArray[x]->GetServerPtrs();

			    for (int m = 0; m < m_NSpaceArray[x]->GetCount(); m++)
			    {
				    if (nsPtrs[m] != NULL)
				    {
					    CViewProvObjectSink* pSnk = new CViewProvObjectSink(objSnk, nsPtrs[m], m);
					    pSnk->AddRef();
					    BSTR queryBStr = queryStr.AllocSysString();
					    BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);
					    IWbemObjectSink* pQuerySink = pSnk;
					    IWbemContext * t_pCtx = m_Ctx;

					    if (nsPtrs[m]->IsRemote())
					    {
						    pQuerySink = pSnk->Associate();
						    t_pCtx = NULL; //don't use context for remote cimoms
					    }

					    IWbemServices *ptmpServ = nsPtrs[m]->GetServerOrProxy();

					    if (ptmpServ)
					    {
						    if ( pQuerySink )
						    {
							    HRESULT t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);

							    if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[m]->IsRemote())
							    {
								    if ( SUCCEEDED(UpdateConnection(&(nsPtrs[m]), &ptmpServ)) )
								    {
									    if (ptmpServ)
									    {
										    t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);
									    }
								    }
							    }

							    if (SUCCEEDED(t_hr))
							    {
								    if (m_ArrayLock.Lock())
								    {
									    m_iQueriesAsked++;
									    m_ArrayLock.Unlock();
								    }
								    else
								    {
									    pSnk->DisAssociate();
								    }
							    }
							    else
							    {
								    pSnk->DisAssociate();
							    }
						    }
						    else
						    {
							    pSnk->DisAssociate();
						    }

						    if (ptmpServ)
						    {
							    nsPtrs[m]->ReturnServerOrProxy(ptmpServ);
						    }
					    }
					    else
					    {
						    pSnk->DisAssociate();
					    }

					    pSnk->Release();
					    SysFreeString(queryBStr);
					    SysFreeString(queryLBStr);
				    }
			    }
            }
		}
	}

	if (m_ArrayLock.Lock())
	{
		m_iQueriesAsked--;

		if (m_iQueriesAsked != m_iQueriesAnswered)
		{
			//just in case this was triggerred while we had yet to ask some queries
			ResetEvent(m_StatusHandle);
		}
		else
		{
			//just in case this wasn't triggerred while we were asking queries
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}

	if (m_iQueriesAsked == 0)
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to perform source query(ies), invalid source namespace(s)" ) ;
		return FALSE;
	}

	return TRUE;
}

BOOL ExecQueryTaskObject::ProcessResults(WbemProvErrorObject &a_ErrorObject)
{
	BOOL retVal = TRUE;
	int indexCnt = 0;

	for (int x = 0; retVal && (x < m_ObjSinkArray.GetSize()); x++)
	{
		if (m_ObjSinkArray[x]->IsSet())
		{
			if (SUCCEEDED(m_ObjSinkArray[x]->GetResult()))
			{
				DWORD dwCount = m_ObjSinkArray[x]->m_ObjArray.GetSize();

				if (0 < dwCount)
				{
					indexCnt++;
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Object path and Class qualifiers resulted in a failed query." ) ;
			}
		}
		else 
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Invalid source namespace path OR object path and Class qualifiers resulted in a failed query." ) ;
		}
	}

	if (0 == indexCnt)
	{
		if (retVal)
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"No source objects found to support view object path." ) ;
		}

		CleanUpObjSinks();
	}
	else
	{
		if (m_JoinOnArray.IsValid())
		{
#ifdef VP_PERFORMANT_JOINS
			BOOL t_bRes = CreateAndIndicateJoinsPerf(a_ErrorObject, m_bSingleton);
#else
			BOOL t_bRes = CreateAndIndicateJoins(a_ErrorObject, m_bSingleton);
#endif
			retVal =  retVal && t_bRes;
		}
		else //union or association
		{
			if ((m_bSingleton) && (indexCnt > 1))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Too many view instances can be created." ) ;
				CleanUpObjSinks();
			}
			else
			{
				BOOL t_bRes = CreateAndIndicateUnions(a_ErrorObject, -1);
				retVal =  retVal && t_bRes;
			}
		}
	}

	return retVal;
}

BOOL ExecQueryTaskObject :: ExecQuery ()
{
	BOOL t_Status ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery\r\n")
		) ;
)

	if ( _wcsicmp ( m_QueryFormat , WBEM_QUERY_LANGUAGE_SQL1 ) == 0 )
	{
		CTextLexSource querySource(m_Query);
		SQL1_Parser sqlParser(&querySource) ;
		t_Status = ! sqlParser.Parse ( & m_RPNExpression ) ;

		if ( t_Status )
		{
			t_Status = SetClass(m_RPNExpression->bsClassName) ;
			
			if ( t_Status )
			{
				t_Status = ParseAndProcessClassQualifiers(m_ErrorObject);

				if (t_Status)
				{
					t_Status = PerformQuery(m_ErrorObject);
				}
			}
			else
			{
				t_Status = FALSE ;
				m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS ) ;
				m_ErrorObject.SetMessage ( L"Unknown Class" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:Unknown Class\r\n")
		) ;
)
			}
		}
		else
		{
			t_Status = FALSE ;
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			m_ErrorObject.SetMessage ( L"WQL query was invalid for this provider" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:WQL query was invalid for this provider\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY_TYPE ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		m_ErrorObject.SetMessage ( L"Query Language not supported" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:Query Language not supported\r\n")
		) ;
)
	}

DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:Returning %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpquals.cpp ===
//***************************************************************************

//

//  VPQUALS.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the implementation of qualifier storage classes

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <malloc.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <wbemidl.h>
#include <stdio.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

CStringW GetStringFromRPNToken(SQL_LEVEL_1_TOKEN* pRPNToken)
{
    CStringW ret;

	if (NULL != pRPNToken->pPropertyName)
	{
		ret = L'('; 
		ret += pRPNToken->pPropertyName;

		switch(pRPNToken->nOperator)
		{
			case SQL_LEVEL_1_TOKEN::OP_EQUAL:
			{
				ret += L'=';
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
			{
				ret += L"<>";
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
			{
				ret += L">=";
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
			{
				ret += L"<=";
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
			{
				ret += L'<';
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
			{
				ret += L'>';
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_LIKE:
			{
				ret += L" like ";
			}
			break;
			default:
			{
				ret.Empty();
			}
		}

		if (!ret.IsEmpty())
		{
			switch (pRPNToken->vConstValue.vt)
			{
				case VT_NULL:
				{
					ret += L"null)";
				}
				break;
				case VT_BSTR:
				{
					if (pRPNToken->bConstIsStrNumeric)
					{
						ret += pRPNToken->vConstValue.bstrVal;
						ret += L')';
					}
					else
					{
						ret += L'\"';
						wchar_t* buff = new wchar_t[(wcslen(pRPNToken->vConstValue.bstrVal)*2) + 1];
						wchar_t* tmp = pRPNToken->vConstValue.bstrVal;
						wchar_t* tmpBuff = buff;

						while (*tmp != NULL)
						{
							if ((*tmp == L'\\') || (*tmp == L'"'))
							{
								*tmpBuff = L'\\';
								*tmpBuff++;
							}

							*tmpBuff = *tmp;
							*tmpBuff++;
							*tmp++;
						}

						*tmpBuff = 0;
						ret += buff;
						delete [] buff;
						ret += L"\")";
					}
				}
				break;
				case VT_BOOL:
				{
					if (pRPNToken->vConstValue.boolVal == VARIANT_TRUE)
					{
						ret += L"TRUE)";
					}
					else
					{
						ret += L"FALSE)";
					}
				}
				break ;

				case VT_I4:
				{
					WCHAR tmpBuff[20];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%d", pRPNToken->vConstValue.lVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_I2:
				{
					WCHAR tmpBuff[20];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%d", (int)pRPNToken->vConstValue.iVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_UI1:
				{
					WCHAR tmpBuff[20];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%d", (int)pRPNToken->vConstValue.bVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_R4:
				{
					WCHAR tmpBuff[25];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%G", pRPNToken->vConstValue.fltVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_R8:
				{
					WCHAR tmpBuff[25];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%lG", pRPNToken->vConstValue.dblVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				default:
				{
					ret.Empty();
				}
			}
		}
	}
    
	return ret;
}

CStringW GetStringFromRPN(SQL_LEVEL_1_RPN_EXPRESSION* pRPN, DWORD num_extra,
						 SQL_LEVEL_1_TOKEN* pExtraTokens, BOOL bAllprops)
{
	CStringW ret;

	if (NULL == pRPN)
	{
		return ret;
	}

	if (NULL != pRPN->bsClassName)
	{
		CStringW props;

		if ((bAllprops) || (0 == pRPN->nNumberOfProperties))
		{
			props = L'*';
		}
		else
		{
			props = pRPN->pbsRequestedPropertyNames[0];

			for (int x = 1; x < pRPN->nNumberOfProperties; x++)
			{
				props += L", ";
				props += pRPN->pbsRequestedPropertyNames[x];
			}

			props += L", ";
			props += WBEM_PROPERTY_PATH;
			props += L", ";
			props += WBEM_PROPERTY_SERVER;
		}

		ret = L"Select ";
		ret += props;
		ret += L" From ";
		ret += pRPN->bsClassName;

		if ((0 != pRPN->nNumTokens) || (0 != num_extra))
		{
			CStringW whereStr;
			CArray<CStringW, LPCWSTR> exprStack;

			//not likely to get more than five expressions in a row!
			//if we do, we'll grow the array!
			exprStack.SetSize(0, 5);
			DWORD stack_count = 0;

			for (int x = 0; x < (pRPN->nNumTokens + num_extra); x++)
			{
				SQL_LEVEL_1_TOKEN* pToken;

				if (x < pRPN->nNumTokens)
				{
					pToken = &(pRPN->pArrayOfTokens[x]);
				}
				else
				{
					pToken = &(pExtraTokens[x - pRPN->nNumTokens]);
				}

				if (SQL_LEVEL_1_TOKEN::OP_EXPRESSION == pToken->nTokenType)
				{
					if (whereStr.IsEmpty())
					{
						whereStr = GetStringFromRPNToken(pToken);

						if (whereStr.IsEmpty())
						{
							ret.Empty();
							break;
						}
					}
					else
					{
						exprStack.SetAtGrow(stack_count, GetStringFromRPNToken(pToken));

						if (exprStack[stack_count].IsEmpty())
						{
							ret.Empty();
							break;
						}

						stack_count++;
					}
				}
				else if (SQL_LEVEL_1_TOKEN::TOKEN_NOT == pToken->nTokenType)
				{
					CStringW tempStr(L"(Not ");
					
					if (stack_count > 0)
					{
						tempStr += exprStack[stack_count-1];
						tempStr += L')';
						exprStack.SetAt(stack_count-1, tempStr);
					}
					else if (!whereStr.IsEmpty())
					{
						tempStr += whereStr;
						tempStr += L')';
						whereStr = tempStr;
					}
					else
					{
						ret.Empty();
						break;
					}
				}
				else
				{
					CStringW opStr;
					
					if (SQL_LEVEL_1_TOKEN::TOKEN_AND == pToken->nTokenType)
					{
						opStr = L" And ";
					}
					else if (SQL_LEVEL_1_TOKEN::TOKEN_OR == pToken->nTokenType)
					{
						opStr = L" Or ";
					}
					else
					{
						ret.Empty();
						break;
					}

					CStringW tempStr(L'(');

					if (stack_count > 1)
					{
						tempStr += exprStack[stack_count-2];
						tempStr += opStr;
						tempStr += exprStack[stack_count-1];
						tempStr += L')';
						exprStack.SetAt(stack_count-2, tempStr);
						stack_count = stack_count--;
					}
					else if (stack_count == 1)
					{
						tempStr += whereStr;
						tempStr += opStr;
						tempStr += exprStack[0];
						tempStr += L')';
						whereStr = tempStr;
						stack_count = 0;
					}
					else
					{
						ret.Empty();
						whereStr.Empty();
						break;
					}
				}
			}

			exprStack.RemoveAll();

			if (whereStr.IsEmpty() || (stack_count != 0))
			{
				ret.Empty();
			}
			else
			{
				ret += L" Where ";
				ret += whereStr;
			}
		}
	}

	return ret;
}

CSourceQualifierItem::CSourceQualifierItem(wchar_t* qry, IWbemClassObject* obj)
: m_pClassObj(NULL), m_RPNExpr(NULL)
{
	m_isValid = FALSE;

	m_QueryStr = qry;

	if (NULL != qry)
	{
		CTextLexSource querySource(qry);
		SQL1_Parser sqlParser(&querySource);
		m_isValid = SQL1_Parser::SUCCESS == sqlParser.Parse(&m_RPNExpr);
	}

	m_pClassObj = obj;

	if (NULL != m_pClassObj)
	{
		m_pClassObj->AddRef();
	}
}

CSourceQualifierItem::~CSourceQualifierItem()
{
	if (NULL != m_RPNExpr)
	{
		delete m_RPNExpr;
	}

	if (NULL != m_pClassObj)
	{
		m_pClassObj->Release();
	}
}

void CSourceQualifierItem::SetClassObject(IWbemClassObject* pObj)
{
	if (NULL != m_pClassObj)
	{
		m_pClassObj->Release();
	}

	if (NULL != pObj)
	{
		pObj->AddRef();
	}

	m_pClassObj = pObj;
}

IWbemClassObject* CSourceQualifierItem::GetClassObject()
{
	if (NULL != m_pClassObj)
	{
		m_pClassObj->AddRef();
	}

	return m_pClassObj;
}

BSTR CSourceQualifierItem::GetClassName()
{
	if (NULL != m_RPNExpr)
	{
		return m_RPNExpr->bsClassName;
	}

	return NULL;
}

CNSpaceQualifierItem::CNSpaceQualifierItem(const wchar_t* ns_path)
{
	m_Valid = FALSE;
	m_ServObjs = NULL;
	m_NSPaths = NULL;
	m_Count = 0;

	if (NULL != ns_path)
	{
		Parse(ns_path);
	}
}

CNSpaceQualifierItem::~CNSpaceQualifierItem()
{
	if (NULL != m_ServObjs)
	{
		for (UINT x = 0; x < m_Count; x++)
		{
			if (NULL != m_ServObjs[x])
			{
				m_ServObjs[x]->Release();
			}
		}

		delete [] m_ServObjs;
	}

	if (m_NSPaths != NULL)
	{
		delete [] m_NSPaths;
	}
}

void CNSpaceQualifierItem::Parse(const wchar_t* ns_path)
{
	wchar_t* buff = _wcsdup(ns_path);

	if (buff == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	wchar_t* tmp = wcsstr(buff, NS_DELIMIT);
	CFreeBuff _1(buff);

	if (tmp == NULL)
	{
		m_NSPaths = new CStringW[1];
		m_NSPaths[0] = buff;
		m_NSPaths[0].TrimLeft();

		if (m_NSPaths[0].IsEmpty())
		{
			delete [] m_NSPaths;
			m_NSPaths = NULL;
		}
		else
		{
			m_Count = 1;
			m_Valid = TRUE;
			m_NSPaths[0].TrimRight();
		}
	}
	else
	{
		wchar_t** tmpbuff = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

		if (tmpbuff == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		CFreeBuff _2(tmpbuff);

		if (tmp != buff)
		{
			tmpbuff[0] = buff;
			m_Count++;
		}

		while (TRUE)
		{
			*tmp = L'\0';
			tmp = tmp + 2;
			
			if (*tmp != L'\0')
			{
				tmpbuff[m_Count] = tmp;
				tmp = wcsstr(tmpbuff[m_Count], NS_DELIMIT);
				m_Count++;

				if (tmp == NULL)
				{
					break;
				}
				
				if ( (m_Count > 0) && (0 == (m_Count%MAX_QUERIES)) )
				{
					UINT x = _msize(tmpbuff);
					tmpbuff = (wchar_t**)realloc(tmpbuff, x+(MAX_QUERIES*sizeof(wchar_t*)));
					_2.SetBuff(tmpbuff);

					if (tmpbuff == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}
				}
			}
			else
			{
				break;
			}
		}

		if (m_Count > 0)
		{
			m_NSPaths = new CStringW[m_Count];

			for (UINT x=0; x < m_Count; x++)
			{
				m_NSPaths[x] = tmpbuff[x];
				m_NSPaths[x].TrimLeft();

				if (m_NSPaths[x].IsEmpty())
				{
					break;
				}
				else
				{
					m_NSPaths[x].TrimRight();
				}
			}

			if (!m_NSPaths[m_Count-1].IsEmpty())
			{
				m_Valid = TRUE;
			}
		}
	}
}

CJoinOnQualifierArray::CJoinOnQualifierArray()
{
	m_Count = 0;
	m_AClasses = NULL;
	m_AProps = NULL;
	m_BClasses = NULL;
	m_BProps = NULL;
	m_Ops = NULL;
	m_Buff = NULL;
	m_Valid = FALSE;
	m_bDone = NULL;
}

CJoinOnQualifierArray::~CJoinOnQualifierArray()
{
	if (NULL != m_AClasses)
	{
		free(m_AClasses);
	}

	if (NULL != m_BClasses)
	{
		free(m_BClasses);
	}

	if (NULL != m_AProps)
	{
		free(m_AProps);
	}

	if (NULL != m_BProps)
	{
		free(m_BProps);
	}

	if (NULL != m_Ops)
	{
		free(m_Ops);
	}

	if (NULL != m_Buff)
	{
		free(m_Buff);
	}

	if (NULL != m_bDone)
	{
		delete [] m_bDone;
	}

	m_AllClasses.RemoveAll();
}

BOOL CJoinOnQualifierArray::Set(const wchar_t* jStr)
{
	if (NULL != jStr)
	{
		Parse(jStr);
	}

	return m_Valid;
}

void CJoinOnQualifierArray::Parse(const wchar_t* qualStr)
{
	m_Buff = _wcsdup(qualStr);
	wchar_t* tmp = m_Buff;
	m_Valid = TRUE;
			    
	m_AClasses = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_AClasses == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_BClasses = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_BClasses == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_AProps = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_AProps == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_BProps = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_BProps == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_Ops = (UINT*)malloc(MAX_QUERIES*sizeof(UINT));

	if (m_Ops == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	while ((tmp != NULL) && (L'\0' != *tmp) && (m_Valid))
	{
		m_AClasses[m_Count] = GetClassStr(tmp);

		if ((NULL != m_AClasses[m_Count]) && (L'\0' != *(m_AClasses[m_Count])))
		{
			m_AllClasses.SetAt(m_AClasses[m_Count], 0);
			m_AProps[m_Count] = GetPropertyStrAndOperator(tmp, m_Ops[m_Count]);

			if ((NULL != m_AProps[m_Count]) && (L'\0' != *(m_AProps[m_Count])) && (0 != m_Ops[m_Count]))
			{
				m_BClasses[m_Count] = GetClassStr(tmp);

				if ((NULL != m_BClasses[m_Count]) && (L'\0' != *(m_BClasses[m_Count])))
				{
					m_AllClasses.SetAt(m_BClasses[m_Count], 0);
					m_BProps[m_Count] = GetPropertyStr(tmp);

					if ((NULL != m_BProps[m_Count]) && (L'\0' != *(m_BProps[m_Count])) && StripAnd(tmp))
					{
						m_Count++;

						if ((tmp != NULL) && (L'\0' != *tmp) && (m_Count > 0) && (0 == (m_Count%MAX_QUERIES)) )
						{
							UINT x = _msize(m_AClasses);
							m_AClasses = (wchar_t**)realloc(m_AClasses, x+(MAX_QUERIES*sizeof(wchar_t*)));

							if (m_AClasses == NULL)
							{
								throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
							}

							m_BClasses = (wchar_t**)realloc(m_BClasses, x+(MAX_QUERIES*sizeof(wchar_t*)));

							if (m_BClasses == NULL)
							{
								throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
							}

							m_AProps = (wchar_t**)realloc(m_AProps, x+(MAX_QUERIES*sizeof(wchar_t*)));

							if (m_AProps == NULL)
							{
								throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
							}

							m_BProps = (wchar_t**)realloc(m_BProps, x+(MAX_QUERIES*sizeof(wchar_t*)));

							if (m_BProps == NULL)
							{
								throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
							}

							x = _msize(m_Ops);
							m_Ops = (UINT*)realloc(m_Ops, x+(MAX_QUERIES*sizeof(UINT)));

							if (m_Ops == NULL)
							{
								throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
							}
						}
					}
					else
					{
						m_Valid = FALSE;
					}
				}
				else
				{
					m_Valid = FALSE;
				}
			}
			else
			{
				m_Valid = FALSE;
			}
		}
		else
		{
			m_Valid = FALSE;
		}
	}

	if (0 == m_Count)
	{
		m_Valid = FALSE;
	}

	if (!m_Valid)
	{
		if (NULL != m_AClasses)
		{
			free(m_AClasses);
			m_AClasses = NULL;
		}

		if (NULL != m_BClasses)
		{
			free(m_BClasses);
			m_BClasses = NULL;
		}

		if (NULL != m_AProps)
		{
			free(m_AProps);
			m_AProps = NULL;
		}

		if (NULL != m_BProps)
		{
			free(m_BProps);
			m_BProps = NULL;
		}

		if (NULL != m_Ops)
		{
			free(m_Ops);
			m_Ops = NULL;
		}

		if (NULL != m_Buff)
		{
			free(m_Buff);
			m_Buff = NULL;
		}
	}
	else
	{
		m_bDone = new BOOL[m_Count];
		memset((void *)m_bDone, 0, sizeof(BOOL)*m_Count);
	}
}

wchar_t* CJoinOnQualifierArray::SkipSpace(wchar_t*& src)
{
	while (iswspace(*src))
	{
		if (*src != L'\0')
		{
			*src = L'\0';
			src++;
		}
	}

	return ((*src == L'\0') ? NULL : src);
}

wchar_t* CJoinOnQualifierArray::SkipToSpecial(wchar_t*& src)
{
	while ((*src != L'.') && (*src != L'=') && (*src != L'!') && (*src != L'<')
		&& !iswspace(*src) && (*src != L'\0'))
	{
		src++;
	}

	return ((*src == L'\0') ? NULL : src);
}

wchar_t* CJoinOnQualifierArray::GetClassStr(wchar_t*& src)
{
	wchar_t* ret = SkipSpace(src);

	if (NULL != ret)
	{
		src = SkipToSpecial(src);

		if ((NULL != src) && (src != ret) && ((*src == L'.')))
		{
			*src = L'\0';
			src++;
		}
		else
		{
			ret = NULL;
		}
	}

	return ret;
}

wchar_t* CJoinOnQualifierArray::GetPropertyStrAndOperator(wchar_t*& src, UINT& op)
{
	wchar_t* ret = src;
	op =  NO_OPERATOR;

	src = SkipToSpecial(src);
	src = SkipSpace(src);

	if ((NULL != src) && (src != ret))
	{
		if (*src == L'=')
		{
			*src = L'\0';
			op = EQUALS_OPERATOR;
			src++;
		}
		else if (*src == L'!')
		{
			wchar_t* prev = src;
			src++;

			if (*src == L'=')
			{
				*prev = L'\0';
				op = NOT_EQUALS_OPERATOR;
				src++;
			}
			else
			{
				ret = NULL;
			}
		}
		else if (*src == L'<')
		{
			wchar_t* prev = src;
			src++;

			if (*src == L'>')
			{
				*prev = L'\0';
				op = NOT_EQUALS_OPERATOR;
				src++;
			}
			else
			{
				ret = NULL;
			}
		}
	}
	else
	{
		ret = NULL;
	}

	return ret;
}

wchar_t* CJoinOnQualifierArray::GetPropertyStr(wchar_t*& src)
{
	wchar_t* ret = src;
	src = SkipToSpecial(src);

	if (NULL != src)
	{
		if ( (src != ret) && iswspace(*src) )
		{
			if (*src != L'\0')
			{
				*src = L'\0';
				src++;
			}
		}
		else
		{
			ret = NULL;
		}
	}

	return ret;
}

BOOL CJoinOnQualifierArray::StripAnd(wchar_t*& src)
{

	if (NULL == src)
	{
		return TRUE;
	}

	src = SkipSpace(src);

	if (NULL == src)
	{
		return TRUE;
	}

	if ((*src == L'a') || (*src == L'A'))
	{
		src++;

		if ((*src == L'n') || (*src == L'N'))
		{
			src++;

			if ((*src == L'd') || (*src == L'D'))
			{
				src++;
				wchar_t* tmp = src;
				src = SkipSpace(src);

				if ((NULL != src) && (tmp != src))
				{
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}

BOOL CJoinOnQualifierArray::ValidateJoin()
{
	if (!m_Valid)
	{
		return m_Valid;
	}

	CMap<CStringW, LPCWSTR, UINT, UINT> validatedClasses;
	CArray<CStringW, LPCWSTR> spareClasses;
	UINT x = 0;

	if (_wcsicmp(m_AClasses[x], m_BClasses[x]) == 0)
	{
		m_Valid = FALSE;
	}
	else
	{
		validatedClasses.SetAt(m_AClasses[x], 0);
		validatedClasses.SetAt(m_BClasses[x], 0);
		x++;
	}

	while ((m_Valid) && (x < m_Count))
	{
		if (_wcsicmp(m_AClasses[x], m_BClasses[x]) == 0)
		{
			m_Valid = FALSE;
		}
		else
		{
			UINT val;

			if (validatedClasses.Lookup(m_AClasses[x], val))
			{
				validatedClasses.SetAt(m_BClasses[x], 0);
			}
			else
			{
				if (validatedClasses.Lookup(m_BClasses[x], val))
				{
					validatedClasses.SetAt(m_AClasses[x], 0);
				}
				else
				{
					spareClasses.Add(m_AClasses[x]);
					spareClasses.Add(m_BClasses[x]);
				}
			}
		}

		x++;
	}

	while ( m_Valid && (0 != spareClasses.GetSize()) )
	{
		m_Valid = FALSE;
		
		for (int i = 0; i < spareClasses.GetSize(); i++)
		{
			UINT val;

			if (validatedClasses.Lookup(spareClasses[i], val))
			{
				if (0 == (i%2))
				{
					validatedClasses.SetAt(spareClasses[i+1], 0);
					spareClasses.RemoveAt(i, 2);
					i -= 1;
				}
				else
				{
					validatedClasses.SetAt(spareClasses[i-1], 0);
					spareClasses.RemoveAt(i-1, 2);
					i -= 2;
				}

				m_Valid = TRUE;
			}
		}
	}

	spareClasses.RemoveAll();
	validatedClasses.RemoveAll();

	return m_Valid;
}


CPropertyQualifierItem::CPropertyQualifierItem(const wchar_t* prop, BOOL bHD, BOOL bKy, CIMTYPE ct, CStringW rfto, BOOL bDt)
{
	if (NULL != prop)
	{
		m_ViewPropertyName = prop;
	}

	m_bDirect = bDt;
	m_HiddenDefault = bHD;
	m_bKey =  bKy;
	m_CimType =  ct;
	m_RefTo = rfto;
}

CPropertyQualifierItem::~CPropertyQualifierItem()
{
	m_SrcPropertyNames.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpserv.cpp ===
//***************************************************************************

//

//  VPSERV.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the WBEM services interfaces

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

//need the following three lines
//to get the security stuff to work

#include "precomp.h"

#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>
#include <vpcfac.h>

extern CRITICAL_SECTION g_CriticalSection;
extern HRESULT SetSecurityLevelAndCloaking(IUnknown* pInterface, const wchar_t* prncpl);

#ifdef UNICODE
#if 0
extern HRESULT GetCurrentSecuritySettings(DWORD *pdwAuthnSvc, DWORD *pdwAuthzSvc,
								   DWORD *pdwAuthLevel, DWORD *pdwImpLevel,
								   DWORD *pdwCapabilities);


void VPGetUserName()
{
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);

	//first get current security info then set it on the proxy...
    DWORD dwAuthnSvc = 0;
    DWORD dwAuthzSvc = 0;
    DWORD dwAuthLevel = 0;
    DWORD dwImpLevel = 0;
    DWORD dwCapabilities = 0;

	HRESULT hr = GetCurrentSecuritySettings(&dwAuthnSvc, &dwAuthzSvc, &dwAuthLevel, &dwImpLevel, &dwCapabilities);

	HANDLE hThreadTok = NULL;

	if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
	{
		DWORD dwBytesReturned = 0;
		UCHAR tokBuff [1024];
		PTOKEN_USER ptokUser = (PTOKEN_USER)tokBuff;

		if (GetTokenInformation(hThreadTok, TokenUser, ptokUser,
									sizeof(tokBuff), &dwBytesReturned)) 
		{
			wchar_t buffN[1024];
			DWORD buffNlen = 1024;
			wchar_t buffD[1024];
			DWORD buffDlen = 1024;
			SID_NAME_USE snu;

			if (!LookupAccountSid(NULL, ptokUser->User.Sid, buffN, &buffNlen, buffD, &buffDlen, &snu))
			{
				DWORD dwErr = GetLastError();
			}
		}

		CloseHandle(hThreadTok);
	}
}
#endif
#endif

wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
	if ( string )
	{
		int textLength = wcslen ( string ) ;

		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
		wcscpy ( textBuffer , string ) ;

		return textBuffer ;
	}
	else
	{
		return NULL ;
	}
}

wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
	int prefixTextLength = 0 ;
	if ( prefix )
	{
		prefixTextLength = wcstombs ( NULL , prefix , 0 ) ;
	}

	int suffixTextLength = 0 ;
	if ( suffix )
	{
		suffixTextLength = wcstombs ( NULL , suffix , 0 ) ;
	}

	if ( prefix || suffix )
	{
		int textLength = prefixTextLength + suffixTextLength ;
		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

		if ( prefix )
		{
			wcscpy ( textBuffer , prefix ) ;
		}

		if ( suffix )
		{
			wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
		}

		return textBuffer ;
	}	
	else
		return NULL ;
}

CWbemServerWrap::CWbemServerWrap(IWbemServices *pServ, const wchar_t* prncpl, const wchar_t* path)
: m_Principal(NULL), m_Path(NULL)
{
	m_ref = 0;
	m_MainServ = pServ;
	
	if (prncpl != NULL)
	{
		m_Principal = UnicodeStringDuplicate(prncpl);
	}

	if (path != NULL)
	{
		m_Path = SysAllocString(path);
	}

	if (m_MainServ)
	{
		m_MainServ->AddRef();
	}
}

CWbemServerWrap::~CWbemServerWrap()
{
	if (m_MainServ)
	{
		m_MainServ->Release();
	}

#ifdef UNICODE
	if (m_Lock.Lock())
	{
		m_ProxyPool.RemoveAll();
		m_Lock.Unlock();
	}
#endif

	if (m_Principal != NULL)
	{
		delete [] m_Principal;
	}

	if (m_Path != NULL)
	{
		SysFreeString(m_Path);
	}
}

IWbemServices* CWbemServerWrap::GetServerOrProxy()
{
	IWbemServices * retVal = NULL;

#ifdef UNICODE
	if (m_MainServ == NULL)
	{
		return m_MainServ;
	}

	//if (IsRemote())
	{
		if (m_Lock.Lock())
		{
			POSITION t_pos = m_ProxyPool.GetHeadPosition();

			while (t_pos)
			{
				CWbemProxyServerWrap &t_srvRef = m_ProxyPool.GetNext(t_pos);

				if (!t_srvRef.m_InUse)
				{
					t_srvRef.m_InUse = TRUE;
					retVal = t_srvRef.m_Proxy;
					break;
				}
			}

			//calling back into COM so must unlock
			//addref MainServ then release it afterward;
			IWbemServices *t_MainCopy = m_MainServ;
			t_MainCopy->AddRef();

			m_Lock.Unlock();
			
			if (retVal == NULL)
			{
				IClientSecurity *pcs = NULL;

				if ( SUCCEEDED (t_MainCopy->QueryInterface(IID_IClientSecurity, (void**)&pcs)) )
				{
					if (FAILED(pcs->CopyProxy(t_MainCopy, (IUnknown **)(&retVal))))
					{
						retVal = NULL;
					}
					else
					{
						CWbemProxyServerWrap t_srv(retVal);
						t_srv.m_InUse = TRUE;

						if (m_Lock.Lock())
						{
							//only store and use if m_MainServ is unchanged
							if (t_MainCopy == m_MainServ)
							{
								m_ProxyPool.AddTail(t_srv);
							}
							else
							{
								//pathological case, mainserv was bad and has changed
								//could recurse at this point but is it worth it?
								//not thought so at this time.
								retVal->Release();
								retVal = NULL;
							}

							m_Lock.Unlock();
						}
						else
						{
							//can't use this proxy if I can't store it
							retVal->Release();
							retVal = NULL;
						}
					}

					pcs->Release();
				}
 			}

			t_MainCopy->Release();

			if (retVal && FAILED(SetSecurityLevelAndCloaking(retVal, IsRemote() ? m_Principal : COLE_DEFAULT_PRINCIPAL)))
			{
				retVal->AddRef(); //addref for the release that Returning the proxy will do
				ReturnServerOrProxy(retVal);
				retVal = NULL;
			}
		}
	}
	//else
	//{
	//	retVal = m_MainServ;
	//}

#else
		retVal = m_MainServ;
#endif

	if (retVal)
	{
		retVal->AddRef();
	}

	return retVal;
}

void CWbemServerWrap::ReturnServerOrProxy(IWbemServices* a_pServ)
{
#ifdef UNICODE
	//if (IsRemote())
	{
		if (m_Lock.Lock())
		{
			POSITION t_pos = m_ProxyPool.GetHeadPosition();

			while (t_pos)
			{
				CWbemProxyServerWrap &t_proxyRef = m_ProxyPool.GetNext(t_pos);

				if (t_proxyRef.m_Proxy == a_pServ)
				{
					t_proxyRef.m_InUse = FALSE;
					break;
				}
			}

			m_Lock.Unlock();
		}
	}
#endif

	a_pServ->Release();
}

BOOL CWbemServerWrap::ProxyBelongsTo(IWbemServices *a_proxy)
{
	BOOL retVal = FALSE;
#ifdef UNICODE
	if (IsRemote())
	{
		if (m_Lock.Lock())
		{
			POSITION t_pos = m_ProxyPool.GetHeadPosition();

			while (t_pos)
			{
				CWbemProxyServerWrap &t_proxyRef = m_ProxyPool.GetNext(t_pos);

				if (t_proxyRef.m_Proxy == a_proxy)
				{
					retVal = TRUE;
					break;
				}
			}

			m_Lock.Unlock();
		}
	}
#endif

	return retVal;
}

void CWbemServerWrap::SetMainServer(IWbemServices *a_pServ)
{
#ifdef UNICODE
	if (m_Lock.Lock())
	{
		if (m_MainServ)
		{
			m_MainServ->Release();
		}

		m_MainServ = a_pServ;

		if (m_MainServ)
		{
			m_MainServ->AddRef();
		}

		m_ProxyPool.RemoveAll();
		m_Lock.Unlock();
	}
#endif
}

ULONG CWbemServerWrap::AddRef()
{
	return (ULONG)(InterlockedIncrement(&m_ref));
}

ULONG CWbemServerWrap::Release()
{
	ULONG i = (ULONG)(InterlockedDecrement(&m_ref));

	if (i == 0)
	{
		delete this;
	}

	return i;
}

void CIWbemServMap::EmptyMap()
{
	if (Lock())
	{
		RemoveAll();
		Unlock();
	}
}

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CViewProvServ ::CViewProvServ
// CViewProvServ ::~CViewProvServ
//
//***************************************************************************

CViewProvServ ::CViewProvServ () :
	sm_Locator (NULL),
	sm_ConnectionMade (NULL),
	m_UserName (NULL),
	m_Initialised (FALSE),
	m_Server (NULL),
	m_Namespace (NULL),
	m_NotificationClassObject (NULL),
	m_ExtendedNotificationClassObject (NULL),
	m_GetNotifyCalled (FALSE),
	m_GetExtendedNotifyCalled (FALSE ),
	m_localeId (NULL)
{
	EnterCriticalSection(&g_CriticalSection);
    CViewProvClassFactory :: objectsInProgress++ ;
	LeaveCriticalSection(&g_CriticalSection);

	m_ReferenceCount = 0 ;

/*
 * Implementation
 */

	sm_ConnectionMade = CreateEvent(NULL, TRUE, FALSE, NULL);
}

CViewProvServ ::~CViewProvServ(void)
{
	delete [] m_localeId ;
	delete [] m_Namespace ;

	if ( m_Server ) 
		m_Server->Release () ;

	if ( m_NotificationClassObject )
		m_NotificationClassObject->Release () ;

	if ( m_ExtendedNotificationClassObject )
		m_ExtendedNotificationClassObject->Release () ;

	if (sm_Locator != NULL)
	{
		sm_Locator->Release();
	}

	if (NULL != sm_ConnectionMade)
	{
		CloseHandle(sm_ConnectionMade);
	}

	sm_ServerMap.EmptyMap();

	if (sm_ServerMap.Lock())
	{
		sm_OutStandingConnections.RemoveAll();
		sm_ServerMap.Unlock();
	}

	if (m_UserName != NULL)
	{
		SysFreeString(m_UserName);
	}

	EnterCriticalSection(&g_CriticalSection);
	CViewProvClassFactory :: objectsInProgress--;
	LeaveCriticalSection(&g_CriticalSection);
}

HRESULT CViewProvServ::GetUnsecApp(IUnsecuredApartment** ppLoc)
{
	if (NULL == ppLoc)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	EnterCriticalSection(&g_CriticalSection);

	HRESULT hr = WBEM_NO_ERROR;

	if (NULL == sm_UnsecApp)
	{
		hr = CoCreateInstance(CLSID_UnsecuredApartment, NULL, CLSCTX_LOCAL_SERVER,
								IID_IUnsecuredApartment, ( void ** )&sm_UnsecApp);

		if (FAILED(hr))
		{
			sm_UnsecApp = NULL;
		}
		else
		{
			sm_UnsecApp->AddRef();
		}
	}
	else
	{
		sm_UnsecApp->AddRef();
	}

	*ppLoc = sm_UnsecApp;
	LeaveCriticalSection(&g_CriticalSection);

	return hr;
}

#if 0
typedef HRESULT (__stdcall *VP_PROC_DllGetClassObject)(REFCLSID rclsid , REFIID riid, void **ppv);
#endif

HRESULT CViewProvServ::GetLocator(IWbemLocator **ppLoc)
{
	if (NULL == ppLoc)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		*ppLoc = NULL;
	}

	HRESULT hr = WBEM_E_FAILED;

	if (m_criticalSection.Lock())
	{
		if (NULL == sm_Locator)
		{
			m_criticalSection.Unlock();
#ifdef UNICODE
			hr = CoCreateInstance(CLSID_WbemLocator, NULL,
									CLSCTX_INPROC_SERVER,
									IID_IWbemLocator, ( void ** )ppLoc);
			
#else

			hr = CoCreateInstance(CLSID_WbemUnauthenticatedLocator, NULL,
									CLSCTX_INPROC_SERVER,
									IID_IWbemLocator, ( void ** )ppLoc);

#endif
			if (m_criticalSection.Lock())
			{
				//another thread may have connected for us...
				if (NULL == sm_Locator)
				{
					if (SUCCEEDED(hr))
					{
						sm_Locator = *ppLoc;
						sm_Locator->AddRef();
					}
				}
				else
				{
					if (FAILED(hr))
					{
						hr = WBEM_NO_ERROR;
						sm_Locator->AddRef();
						*ppLoc = sm_Locator;
					}
				}
			}
			else
			{
				return hr;
			}
		}
		else
		{
			hr = WBEM_NO_ERROR;
			sm_Locator->AddRef();
			*ppLoc = sm_Locator;
		}

		m_criticalSection.Unlock();
	}

	return hr;
}

//***************************************************************************
//
// CViewProvServ ::QueryInterface
// CViewProvServ ::AddRef
// CViewProvServ ::Release
//
// Purpose: IUnknown members for CViewProvServ object.
//***************************************************************************

STDMETHODIMP CViewProvServ ::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (iplpv == NULL)
		{
			return E_INVALIDARG;
		}

		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( IWbemServices* ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( IWbemServices* ) this ;		
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( IWbemProviderInit* ) this ;		
		}
		

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return S_OK ;
		}
		else
		{
			return E_NOINTERFACE ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDMETHODIMP_(ULONG) CViewProvServ ::AddRef(void)
{
   	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CViewProvServ ::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG t_Ref ;
		if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return t_Ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

IWbemServices *CViewProvServ :: GetServer () 
{ 
	if ( m_Server )
		m_Server->AddRef () ; 

	return m_Server ; 
}

void CViewProvServ :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CViewProvServ :: GetNamespace () 
{
	return m_Namespace ; 
}

void CViewProvServ :: SetNamespace ( wchar_t *a_Namespace ) 
{
	m_Namespace = UnicodeStringDuplicate ( a_Namespace ) ; 
}

IWbemClassObject *CViewProvServ :: GetNotificationObject (
										WbemProvErrorObject &a_errorObject,
										IWbemContext *pCtx
									) 
{
	if ( m_NotificationClassObject )
	{
		m_NotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateNotificationObject ( a_errorObject, pCtx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_NotificationClassObject->AddRef () ;
		}

	}

	return m_NotificationClassObject ; 
}

IWbemClassObject *CViewProvServ :: GetExtendedNotificationObject (
										WbemProvErrorObject &a_errorObject,
										IWbemContext *pCtx
									) 
{
	if ( m_ExtendedNotificationClassObject )
	{
		m_ExtendedNotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateExtendedNotificationObject ( a_errorObject, pCtx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_ExtendedNotificationClassObject->AddRef () ;
		}
	}

	return m_ExtendedNotificationClassObject ; 
}

BOOL CViewProvServ :: CreateExtendedNotificationObject ( 

	WbemProvErrorObject &a_errorObject,
	IWbemContext *pCtx
)
{
	if ( m_GetExtendedNotifyCalled )
	{
		if ( m_ExtendedNotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetExtendedNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	BSTR t_bstrTemp = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);

	HRESULT t_Result = m_Server->GetObject (

		t_bstrTemp ,
		0 ,
		pCtx,
		& m_ExtendedNotificationClassObject ,
		NULL 
	) ;

	SysFreeString(t_bstrTemp);

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;

		m_ExtendedNotificationClassObject = NULL ;
	}

	return t_Status ;
}

BOOL CViewProvServ :: CreateNotificationObject ( 

	WbemProvErrorObject &a_errorObject,
	IWbemContext *pCtx
)
{
	if ( m_GetNotifyCalled )
	{
		if ( m_NotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	BSTR t_bstrTemp = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);

	HRESULT t_Result = m_Server->GetObject (

		t_bstrTemp ,
		0 ,
		pCtx,
		& m_NotificationClassObject ,
		NULL 
	) ;

	SysFreeString(t_bstrTemp);

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
		m_NotificationClassObject = NULL;
	}

	return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CViewProvServ :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: QueryObjectSink ( 

	long lFlags,		
	IWbemOb